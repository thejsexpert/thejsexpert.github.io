{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to JSExpert","text":""},{"location":"#welcome-to-jsexpert","title":"Welcome to JSExpert","text":"<pre><code>import * as msw from \"msw\";\n\n// Logging the Module\nconsole.log(msw);\n\n//list all the method names\nconsole.log(Object.keys(msw));\n</code></pre> <ul> <li>Holy Grail</li> </ul> Question: How do you practice data structures in JavaScript? <p>Answer: To practice, try solving algorithm challenges on platforms like:</p> <ul> <li>LeetCode</li> <li>CodeSignal</li> <li>HackerRank</li> </ul> Function <p>If you don\u2019t <code>return</code> anything from a function, <code>undefined</code> is returned (implicitly):</p> <pre><code>&gt; function f() { }\n&gt; f()\nundefined\n</code></pre> <ul> <li>Speaking JavaScript by Dr. Axel Rauschmayer</li> </ul> <ul> <li>programiz</li> <li>onecompiler</li> </ul> <p></p> <p></p> <ul> <li>Medium: JavaScript fundamentals: Variables and Data types</li> <li>Blog: Data Types in JavaScript</li> </ul>"},{"location":"#different-kinds-of-loops","title":"Different Kinds of Loops","text":"<p>JavaScript supports different kinds of loops:</p> <ul> <li>for - loops through a block of code a number of times</li> <li>for/in - loops through the properties of an object</li> <li>for/of - loops through the values of an iterable object</li> <li>while - loops through a block of code while a specified condition is true</li> <li>do/while - also loops through a block of code while a specified condition is true</li> </ul> <p>W3schools: Different Kinds of Loops</p> <p>Digital Ocean: Understanding Map and Set Objects in JavaScript</p> <p></p>"},{"location":"#this","title":"this","text":"<p>Understanding <code>this</code> in Object Methods</p> <pre><code>const obj1 = {\n  name: \"joh\",\n  canFly: function () {\n    return `${this.name} in the sky`;\n  },\n};\n</code></pre> <p>why do we need to use <code>this</code>, isnt the name is inside same object</p> <p>Great question! Yes, <code>name</code> is inside the same object, but when you define a method (like <code>canFly</code>) within the object, you need to use this to refer to properties of the object itself.</p> Here\u2019s why <ul> <li><code>this</code> inside a method refers to the object itself. So, using <code>this.name</code> refers to the <code>name</code> property of the object that the method is being called on.</li> </ul> <p>If you just use <code>name</code> directly in the function, JavaScript will not automatically understand that you mean the <code>name</code> property of the object. It will treat it as a local variable or look for it in the surrounding scope (like a global scope), which is why it would result in an error or unexpected behavior.</p> Example<pre><code>const obj1 = {\n  name: \"joh\",\n  canFly: function () {\n    return `${this.name} in the sky`; // 'this' refers to obj1 here\n  },\n};\n\nconsole.log(obj1.canFly()); // Outputs: \"joh in the sky\"\n</code></pre> <p>If you didn't use <code>this</code>:</p> <pre><code>const obj1 = {\n  name: \"joh\",\n  canFly: function () {\n    return `${name} in the sky`; // 'name' is not recognized, error or unexpected result\n  },\n};\n\nconsole.log(obj1.canFly()); // Likely outputs an error, since 'name' is undefined here\n</code></pre> <p>In summary, <code>this</code> ensures you're referring to the property of the current object, and it helps avoid confusion with local variables or names in other scopes.</p>"},{"location":"#roadmapshjavascript","title":"roadmap.sh/javascript","text":""},{"location":"#scopes","title":"Scopes","text":"<p>In JavaScript, scope refers to the visibility of a variable or how it can be used after it is declared. The scope of a variable depends on the keyword that was used to declare it.</p> <p>The three types of Scope are Global Scope, Function Scope, and Block Scope.(1)</p> <ol> <li> <p>Global Variables in HTML</p> <p>With JavaScript, the global scope is the JavaScript environment.</p> <p>In HTML, the global scope is the window object.</p> <p>Global variables defined with the <code>var</code> keyword belong to the window object:</p> <pre><code>var carName = \"Volvo\";\n// code here can use window.carName\n</code></pre> <p>Global variables defined with the <code>let</code> keyword do not belong to the window object:</p> <pre><code>let carName = \"Volvo\";\n// code here can not use window.carName\n</code></pre> <ul> <li>w3schools.com: Global Variables in HTML</li> </ul> </li> </ol> Scope determines the accessibility (visibility) of variables. <p>JavaScript variables have 3 types of scope:</p> <ul> <li>Block scope</li> <li>Function scope (Local Scope)</li> <li>Global scope</li> </ul> <ul> <li>JavaScript Scope</li> </ul>"},{"location":"#comparing-objects-in-js","title":"Comparing Objects in JS","text":"<ul> <li>geeksforgeeks: How to Compare Objects in JavaScript?</li> <li>codedamn: How to compare objects in JavaScript?</li> <li>personal Blog: How to Compare Objects in JavaScript</li> <li>syncfusion: 5 Different Ways to Deep Compare JavaScript Objects</li> <li>stackoverflow</li> <li>comparing objects</li> <li>Mastering Object Comparison in JavaScript: 4 techniques to compare </li> </ul> <p>why strings are equal when <code>===</code> but array arent in js</p> <p>In JavaScript, the <code>===</code> operator checks both value and type for equality, but it behaves differently for primitive types (like strings and numbers) and reference types (like arrays and objects).</p> <ol> <li> <p>Strings:</p> <p>Strings are primitive values in JavaScript. When you compare strings using <code>===</code>, JavaScript checks if the actual content (the sequence of characters) is the same. Since strings are immutable, when two string values have the same characters, they are considered equal.</p> Example<pre><code>let str1 = \"hello\";\nlet str2 = \"hello\";\nconsole.log(str1 === str2); // true\n</code></pre> </li> <li> <p>Arrays:</p> <p>Arrays are objects in JavaScript, which means they are reference types. When you compare arrays using <code>===</code>, JavaScript checks if the two arrays reference the exact same object in memory, not whether their contents are the same.</p> <p>Even if two arrays have the same elements, they're considered not equal because they are different objects in memory.</p> Example<pre><code>let arr1 = [1, 2, 3];\nlet arr2 = [1, 2, 3];\nconsole.log(arr1 === arr2); // false\n</code></pre> <p>In this case, <code>arr1</code> and <code>arr2</code> are two different objects in memory, so they are not considered equal by <code>===</code>.</p> </li> </ol> Tip <p>To compare arrays by their contents, you would need to iterate through them and check each element, or use a utility function (e.g., <code>JSON.stringify(arr1) === JSON.stringify(arr2)</code>).</p> can we console the memory location of object ? <p>In JavaScript, you can't directly access the memory location of an object like you can in lower-level languages such as C or C++. JavaScript abstracts away memory management to make it easier to work with.</p> <p>However, you can still observe references to objects. When you log an object in the console, you get a representation of it, but not the actual memory address. If you compare two variables holding objects, what you're comparing is their references (or the \"pointer\" to the object in memory, in a sense). Two variables can point to the same object, or to different objects.</p> <pre><code>let obj1 = { name: 'Alice' };\nlet obj2 = obj1;  // obj2 references the same object as obj1\nlet obj3 = { name: 'Alice' };  // obj3 is a different object with the same content\n\nconsole.log(obj1 === obj2);  // true, both point to the same object\nconsole.log(obj1 === obj3);  // false, they are different objects in memory\n</code></pre> <p>While you can't see the actual memory address, you can compare the references and check if two variables refer to the same object.</p> <p>If you're using the console in a browser (like Chrome), when you log an object, the console will show the object structure, and you can even interactively explore it. But again, this is a representation of the object, not its memory location.</p> <p>If you're looking to dive deeper into performance, memory management, or debugging, you might use tools like Chrome's DevTools heap profiler, but these tools focus more on memory usage and object lifecycles rather than exposing the raw memory addresses.</p> <ul> <li>Free Tool: Emoji Picker</li> </ul>"},{"location":"#npm-i-vs-npm-i-with-flag","title":"<code>npm i</code> vs <code>npm i</code> with flag","text":"<ul> <li><code>npm i</code>: Installs dependencies with npm's current (v7+) peer dependency resolution, which may cause errors if there are conflicting peer dependencies.</li> <li><code>npm i --legacy-peer-deps</code>: Installs dependencies while ignoring peer dependency conflicts, falling back to the older, pre-v7 behavior.</li> </ul> <p>In practice, if you're working with older packages that haven't been updated to work with npm v7+ peer dependency handling, using <code>--legacy-peer-deps</code>might help you avoid issues.</p>"},{"location":"#js-array-destructive-and-non-destructive-methods","title":"JS Array Destructive and Non-Destructive Methods","text":"<p>what exaclty is javascript destructive method and non desctructive method</p> <p>In JavaScript, destructive and non-destructive methods refer to how operations affect the data they operate on, especially in the context of arrays or objects.</p>"},{"location":"#destructive-methods","title":"Destructive Methods","text":"<p>A destructive method (also called a mutating method) directly modifies the original data structure (like an array or object). It changes the data in place, rather than creating a new copy. These methods are often used when you want to update or alter the original data directly.</p> Examples of Destructive Methods: <ol> <li> <p>Array Methods:</p> <ul> <li><code>push()</code>: Adds one or more elements to the end of an array.</li> <li><code>pop()</code>: Removes the last element from an array.</li> <li><code>shift()</code>: Removes the first element from an array.</li> <li><code>unshift()</code>: Adds one or more elements to the beginning of an array.</li> <li><code>splice()</code>: Adds, removes, or replaces elements at a specific index in an array.</li> <li><code>sort()</code>: Sorts the elements of the array in place.</li> <li><code>reverse()</code>: Reverses the order of elements in the array.</li> </ul> </li> <li> <p>Object Methods:</p> <ul> <li>Directly modifying properties on an object is destructive.</li> </ul> javascript<pre><code>const obj = { a: 1, b: 2 };\nobj.a = 3; // Modifies the original object\n</code></pre> </li> </ol> Example of a Destructive Method<pre><code>let arr = [1, 2, 3];\narr.push(4); // Modifies the original array\nconsole.log(arr); // [1, 2, 3, 4]\n</code></pre>"},{"location":"#non-destructive-methods","title":"Non-Destructive Methods","text":"<p>A non-destructive method (also called a non-mutating method) does not modify the original data structure. Instead, it creates and returns a new data structure with the updated values, leaving the original one unchanged.</p> Examples of Non-Destructive Methods <ol> <li> <p>Array Methods:</p> <ul> <li><code>concat()</code>: Merges two or more arrays without modifying the original ones.</li> <li><code>slice()</code>: Returns a shallow copy of a portion of an array, leaving the original array intact.</li> <li><code>map()</code>: Creates a new array with the results of calling a provided function on every element in the array.</li> <li><code>filter()</code>: Creates a new array with all elements that pass the test implemented by the provided function.</li> <li><code>reduce()</code>: Accumulates a value based on the array\u2019s elements (but does not mutate the original array).</li> </ul> </li> <li> <p>String Methods:</p> <ul> <li>Methods like <code>slice()</code>, <code>toLowerCase()</code>, and <code>toUpperCase()</code> return new strings without modifying the original one.</li> </ul> </li> <li> <p>Object Methods:</p> <ul> <li>Using <code>Object.assign()</code> or the spread operator (<code>{...obj}</code>) to copy an object creates a new object, leaving the original object unchanged.</li> </ul> </li> </ol> Example of a Non-Destructive Method<pre><code>let arr = [1, 2, 3];\nlet newArr = arr.concat(4); // Does not modify the original array\nconsole.log(arr); // [1, 2, 3]\nconsole.log(newArr); // [1, 2, 3, 4]\n</code></pre>"},{"location":"#key-differences","title":"Key Differences:","text":"<ul> <li>Destructive Methods: Modify the original data.</li> <li>Non-Destructive Methods: Do not modify the original data but instead return a new data structure.</li> </ul> <p>Choosing between destructive and non-destructive methods depends on whether you want to preserve the original data or directly alter it.</p>"},{"location":"#using-in-real-time","title":"Using in Real Time","text":"<p>when does it is used in real time application in js or react</p> <p>In real-time applications, destructive and non-destructive methods in JavaScript (and React) are often used based on the specific behavior needed for managing state or manipulating data. Here's how and when each type of method is commonly used in JavaScript and React:</p>"},{"location":"#1-destructive-methods-in-real-time-applications","title":"1. Destructive Methods in Real-time Applications","text":"When to Use Destructive Methods <ol> <li> <p>When performance optimization is crucial:</p> <ul> <li>Destructive methods directly modify the existing data, which can be faster in scenarios where creating a new copy of data is resource-intensive. This is particularly useful in performance-critical applications where you need to avoid unnecessary copies of large datasets.</li> </ul> </li> <li> <p>Managing application state with direct mutations (React):</p> <ul> <li>In some cases, modifying data directly (destructive methods) can be acceptable, but in React, this should be done cautiously. React requires you to treat state immutably to trigger re-renders, but there are times when mutable operations are used temporarily (before triggering a state update).</li> </ul> </li> <li> <p>Manipulating local data structures (arrays, objects) that don\u2019t need to be copied:</p> <ul> <li>When working with non-shared data that doesn\u2019t need to be reused, modifying the original structure directly is more straightforward and often necessary. For example, modifying a local array with <code>.push()</code>, <code>.pop()</code>, or <code>.shift()</code>.</li> </ul> </li> </ol> Example in Real-Time Applications (React/JS) <ul> <li> <p>Modifying an array of items in state:</p> <ul> <li> <p>You might want to add or remove items from an array in state, but in React, you should avoid mutating state directly. However, it could be useful when working with data before setting state or for manipulating data before rendering.</p> <pre><code>const handleAddItem = (newItem) =&gt; {\n    const newItems = [...items]; // Copy the array (non-destructive approach)\n    newItems.push(newItem); // Destructive method to modify the copied array\n    setItems(newItems); // Set the state with the modified array\n}\n</code></pre> </li> </ul> </li> </ul> Example of Destructive Methods in Non-React JS <ul> <li> <p>Modifying arrays or objects in client-side JavaScript: You might use destructive methods when manipulating data in a client-side application, such as adding/removing users from an array.</p> <pre><code>let users = [\"Alice\", \"Bob\", \"Charlie\"];\nusers.push(\"David\"); // Destructive method\nconsole.log(users); // [\"Alice\", \"Bob\", \"Charlie\", \"David\"]\n</code></pre> </li> </ul>"},{"location":"#2-non-destructive-methods-in-real-time-applications","title":"2. Non-Destructive Methods in Real-time Applications","text":"When to Use Non-Destructive Methods <ol> <li> <p>React State Management:</p> <ul> <li>React relies on the immutability of state to ensure that components re-render properly when state changes. Non-destructive methods (e.g., <code>.map()</code>, <code>.filter()</code>, <code>.concat()</code>) are used to create new state objects or arrays without mutating the original state directly. This ensures that React can detect the changes and trigger the necessary re-renders.</li> </ul> </li> <li> <p>When you need to preserve the original data:</p> <ul> <li>If you need to maintain the integrity of the original data (for example, when it's shared across different parts of the application), non-destructive methods are preferred because they create a new copy of the data.</li> </ul> </li> <li> <p>In scenarios with data sharing between components:</p> <ul> <li>If you have a data structure that is shared between components, you don't want to inadvertently modify it in one component and cause unexpected side effects in another. Using non-destructive methods ensures that the original data is not altered.</li> </ul> </li> </ol> Example in React (Non-Destructive Methods for State) <ol> <li> <p>Adding or Removing Items from an Array in State (React-specific):</p> <ul> <li> <p>When updating the state in React, you should use non-destructive methods to avoid direct mutation of state. Here's an example where you are adding a new item to an array state using <code>.concat()</code> (non-destructive) rather than <code>.push()</code> (destructive).</p> <pre><code>const handleAddItem = (newItem) =&gt; {\n    const updatedItems = items.concat(newItem); // Non-destructive\n    setItems(updatedItems); // Update the state with the new array\n};\n</code></pre> </li> </ul> </li> <li> <p>Updating a specific value in an object (React):</p> <ul> <li> <p>To update an object property in React, you should use the spread operator (<code>...</code>) to create a new object rather than mutating the original one. This triggers a re-render in React.</p> <pre><code>const updateUser = (newName) =&gt; {\n    const updatedUser = {...user, name: newName}; // Non-destructive method\n    setUser(updatedUser); // Set the updated user object to the state\n};\n</code></pre> </li> </ul> </li> </ol> Example in Real-Time JavaScript (Non-Destructive Methods) <ul> <li> <p>Creating a copy of an array and updating it without affecting the original array:</p> <pre><code>let arr = [1, 2, 3];\nlet newArr = arr.slice(); // Non-destructive: creates a shallow copy of the array\nnewArr.push(4);\nconsole.log(arr); // [1, 2, 3] (original array remains unchanged)\nconsole.log(newArr); // [1, 2, 3, 4] (new array with modification)\n</code></pre> </li> <li> <p>Object cloning with spread operator:</p> <pre><code>let obj = {name: \"John\", age: 30};\nlet newObj = {...obj, age: 31}; // Non-destructive, creates a new object\nconsole.log(obj); // {name: \"John\", age: 30}\nconsole.log(newObj); // {name: \"John\", age: 31}\n</code></pre> </li> </ul> When Does It Apply in Real-Time React Applications? <ul> <li> <p>State Updates: In React, non-destructive methods are essential when you update the state. For example, when adding items to an array or updating an object in the state, you must not mutate the state directly (i.e., no <code>.push()</code>, <code>.splice()</code>, or direct property changes). Instead, use methods like <code>.concat()</code>, <code>.map()</code>, and the spread operator to ensure immutability and proper re-rendering.</p> </li> <li> <p>Immutable Data Patterns: Applications that use Redux or other state management libraries that rely on immutability (common in React apps) heavily utilize non-destructive methods to ensure that the state changes are tracked and updates happen correctly.</p> </li> <li> <p>Data Persistence or Local Modifications: For operations that don\u2019t need to update the state or affect other parts of the app, destructive methods can be used locally within a function or component. For example, manipulating temporary data or cache data might be done using destructive methods.</p> </li> </ul> <p>In Conclusion:</p> <ul> <li>Destructive methods are useful for quick, localized, or performance-sensitive operations but should be avoided in React state management due to the need for immutability.</li> <li>Non-destructive methods are favored in React to ensure state changes are predictable, and re-renders occur properly without mutating data directly.</li> </ul> <p>In a real-time application (such as React), non-destructive methods are more common when dealing with state, as React relies on immutability to trigger the necessary updates to the UI. Destructive methods can still be useful in situations where performance is critical or when you want to manipulate temporary data.</p>"},{"location":"#nullish-coalesing-operator-vs-logical-or-operator","title":"Nullish Coalesing Operator vs Logical OR Operator","text":"<p>Prefer the nullish coalescing operator (<code>??</code>) over the logical OR operator (<code>||</code>) when you want to provide a fallback value only if the original value is <code>null</code> or <code>undefined</code>, not for other falsy values like <code>0</code>, <code>\"\"</code> (empty string), or <code>false</code>.</p>"},{"location":"#comparing-two-objects","title":"Comparing two objects","text":"<pre><code>obj1 = {\n  name: \"john\",\n  canFly: function () {\n    return `${this.name} in the sky`;\n  },\n};\n\nobj2 = {\n  name: \"john\",\n  canFly: function () {\n    return `${this.name} in the sky`;\n  },\n};\n\nconsole.log(obj1.canFly());\nconsole.log(obj2.canFly());\n\nconsole.log(obj1 === obj2);\nconsole.log(JSON.stringify(obj1) === JSON.stringify(obj2));\n</code></pre>"},{"location":"#javascript-syllabus","title":"JavaScript Syllabus","text":""},{"location":"#pdf","title":"PDF","text":"<ul> <li>Speaking JS by Axel Rauschmayer</li> <li>PDF: Pro JavaScript Design-Patterns</li> </ul> <p>Related Blogs</p> <ul> <li>Array Methods by category</li> </ul>"},{"location":"#js-protocol","title":"JS Protocol","text":"<p>The JavaScript Iteration Protocols and How They Fit In</p> <p>ES6 introduced two new protocols that work together to define how iteration should function in JavaScript: the Iterable Protocol and the Iterator Protocol. These protocols enable objects to be used with the <code>for...of</code> loop and other constructs that expect iterable data.</p>"},{"location":"#iterable-protocol","title":"Iterable Protocol","text":"<p>The iterable protocol allows an object to define its iteration behavior. An object is considered iterable if it implements the <code>@@iterator</code> method, accessible via <code>Symbol.iterator</code>. This method must return an object that conforms to the iterator protocol.</p>"},{"location":"#iterator-protocol","title":"Iterator Protocol","text":"<p>The iterator protocol defines a standard way to produce a sequence of values. An object is an iterator when it implements a <code>next()</code> method with the following requirements:</p> <p>The <code>next()</code> method must return an object with two properties:</p> <ul> <li><code>value</code>: the next value in the sequence (can be <code>undefined</code> if the iteration is complete).</li> <li><code>done</code>: a boolean indicating whether the iterator has completed. It's <code>true</code> when the sequence is finished, and <code>false</code> otherwise.</li> </ul> Example<pre><code>const myIterable = {\n  data: [1, 2, 3],\n  [Symbol.iterator]() {\n    let index = 0;\n    return {\n      next: () =&gt; {\n        if (index &lt; this.data.length) {\n          return { value: this.data[index++], done: false };\n        } else {\n          return { value: undefined, done: true };\n        }\n      },\n    };\n  },\n};\n\nfor (const value of myIterable) {\n  console.log(value); // Output: 1, 2, 3\n}\n</code></pre> <p>In this example, <code>myIterable</code> is an iterable because it has a Symbol.iterator method. The method returns an iterator object with a <code>next()</code> method that produces values from the <code>data</code> array until there are no more values, at which point it signals completion.</p> JavaScript Protocols: Overview and Types <p>Clarifying \"JavaScript Protocols\"</p> <p>The term \"JavaScript protocols\" can refer to two distinct concepts:</p> <ul> <li>Web/network protocols that JavaScript interacts with (like HTTP, WebSocket, etc.).</li> <li>Native JavaScript object protocols-internal standards that objects and functions can implement to enable certain behaviors (such as iteration or observability).</li> </ul> <p>1. Native JavaScript Protocols</p> <p>JavaScript defines several protocols-standardized interfaces that objects can implement to work with built-in language features. The most notable native protocols include:</p> <ul> <li> <p>Iterator Protocol: Enables objects to define or customize their iteration behavior (e.g., for use in <code>for...of</code> loops).</p> </li> <li> <p>Iterable Protocol: Allows objects to be iterated over by defining a <code>[Symbol.iterator]</code> method.</p> </li> <li> <p>Async Iterator Protocol: Similar to the iterator protocol, but supports asynchronous iteration with <code>[Symbol.asyncIterator]</code>.</p> </li> <li> <p>Observable Protocol: A proposed protocol for creating declarative, asynchronous streams of data.</p> </li> <li> <p>Generator Protocol: Functions that can be paused and resumed, producing a sequence of values.</p> </li> </ul> <ul> <li>Iteration protocols in JavaScript </li> <li> <p>book: the-joy-of-javascript</p> </li> <li> <p>perplexity: how many javascript protocals</p> </li> </ul> <ul> <li>9 Native data protocols</li> <li>JavaScript ES6 / ES2015 Iterables and Iterators</li> <li>Toptal's Quick and Practical JavaScript Cheat Sheet: ES6 and Beyond</li> <li>JavaScript technologies overview</li> <li>The JavaScript Iteration Protocols and How They Fit In</li> <li>Why JavaScript ES6 and Its Successors Are So Great</li> </ul>"},{"location":"#books","title":"Books","text":""},{"location":"tags/","title":"Tags","text":""},{"location":"tags/#tags","title":"Tags","text":""},{"location":"advanced/intro/","title":"Intro","text":""},{"location":"advanced/intro/#intro","title":"Intro","text":""},{"location":"blog/","title":"Index","text":""},{"location":"blog/#blog","title":"Blog","text":""},{"location":"blog/2025/04/27/performance-optimization/","title":"Performance optimization","text":"","tags":["Personal"]},{"location":"blog/2025/04/27/performance-optimization/#performance-optimization","title":"Performance optimization","text":"<p>Performance optimization is crucial in various domains, including software development, system design, and data processing. Techniques can vary depending on the context, but here are some general strategies for optimizing performance:</p>","tags":["Personal"]},{"location":"blog/2025/04/27/performance-optimization/#1-code-optimization","title":"1. Code Optimization:","text":"<ul> <li>Profiling: Use profiling tools to identify bottlenecks in your code.</li> <li>Efficient Algorithms: Choose algorithms with lower time and space complexity.</li> <li>Code Refactoring: Clean up and optimize code to reduce unnecessary operations.</li> <li>Inlining: Inline small functions to reduce overhead.</li> </ul>","tags":["Personal"]},{"location":"blog/2025/04/27/performance-optimization/#2-data-structure-optimization","title":"2. Data Structure Optimization:","text":"<ul> <li>Choose the Right Data Structures: Use appropriate data structures (e.g., hash tables, trees) based on access patterns.</li> <li>Memory Layout: Optimize memory layout to enhance cache locality.</li> </ul>","tags":["Personal"]},{"location":"blog/2025/04/27/performance-optimization/#3-database-optimization","title":"3. Database Optimization:","text":"<ul> <li>Indexing: Create indexes on frequently queried columns.</li> <li>Query Optimization: Write efficient SQL queries and avoid complex joins or subqueries.</li> <li>Caching: Implement caching mechanisms to reduce database load.</li> </ul>","tags":["Personal"]},{"location":"blog/2025/04/27/performance-optimization/#4-system-level-optimization","title":"4. System-Level Optimization:","text":"<ul> <li>Concurrency: Use multi-threading or asynchronous processing to make better use of system resources.</li> <li>Resource Management: Optimize the use of CPU, memory, and I/O resources.</li> <li>Load Balancing: Distribute workloads evenly across servers or resources.</li> </ul>","tags":["Personal"]},{"location":"blog/2025/04/27/performance-optimization/#5-network-optimization","title":"5. Network Optimization:","text":"<ul> <li>Reduce Latency: Minimize the time it takes for data to travel between systems.</li> <li>Compression: Compress data to reduce bandwidth usage.</li> <li>Caching: Cache frequently accessed data to reduce network load.</li> </ul>","tags":["Personal"]},{"location":"blog/2025/04/27/performance-optimization/#6-compilation-and-build-optimization","title":"6. Compilation and Build Optimization:","text":"<ul> <li>Optimization Flags: Use compiler optimization flags to improve execution speed.</li> <li>Minification: Minify code (especially JavaScript and CSS) to reduce file size.</li> </ul>","tags":["Personal"]},{"location":"blog/2025/04/27/performance-optimization/#7-memory-optimization","title":"7. Memory Optimization:","text":"<ul> <li>Garbage Collection: Optimize garbage collection strategies to manage memory more efficiently.</li> <li>Memory Pools: Use memory pools to reduce allocation and deallocation overhead.</li> </ul>","tags":["Personal"]},{"location":"blog/2025/04/27/performance-optimization/#8-load-testing-and-benchmarking","title":"8. Load Testing and Benchmarking:","text":"<ul> <li>Stress Testing: Test how your system behaves under extreme conditions.</li> <li>Benchmarking: Measure performance and identify areas for improvement.</li> </ul>","tags":["Personal"]},{"location":"blog/2025/04/27/performance-optimization/#9-code-review-and-best-practices","title":"9. Code Review and Best Practices:","text":"<ul> <li>Peer Reviews: Have others review your code for potential optimizations.</li> <li>Best Practices: Follow industry best practices and design patterns that promote performance.</li> </ul>","tags":["Personal"]},{"location":"blog/2025/04/27/performance-optimization/#10-hardware-optimization","title":"10. Hardware Optimization:","text":"<ul> <li>Upgrade Hardware: Sometimes upgrading hardware can provide a significant performance boost.</li> <li>Tune Hardware Settings: Configure hardware settings (like CPU frequency, disk caching) for optimal performance.</li> </ul> <p>Each context will have its specific techniques and tools, so it\u2019s important to tailor these strategies to the specific requirements and constraints of your project or system.</p>","tags":["Personal"]},{"location":"blog/2025/04/27/what-is-pwa/","title":"What is PWA?","text":"","tags":["Personal"]},{"location":"blog/2025/04/27/what-is-pwa/#what-is-pwa","title":"What is PWA?","text":"<p>A Progressive Web App (PWA) is a type of web application that uses modern web technologies to deliver an app-like experience to users. PWAs combine the best of web and mobile apps, offering features such as:</p> <ol> <li>Offline Capability: PWAs can work offline or in low-network conditions thanks to service workers.</li> <li>App-like Experience: They can be added to the home screen and launched in a standalone window, resembling native apps.</li> <li>Responsive Design: PWAs work seamlessly across various devices and screen sizes.</li> <li>Push Notifications: They can send notifications to users even when the app isn't open.</li> <li>Fast Loading: Optimized for speed and performance, enhancing user experience.</li> </ol>","tags":["Personal"]},{"location":"blog/2025/04/27/what-is-pwa/#can-any-website-be-made-a-pwa","title":"Can Any Website Be Made a PWA?","text":"<p>Yes, most websites can be turned into PWAs, but certain criteria and enhancements are necessary:</p> <ol> <li>HTTPS: Your website must be served over HTTPS for security reasons.</li> <li>Web App Manifest: Include a manifest file that provides metadata about the app.</li> <li>Service Worker: Implement a service worker to handle caching, offline access, and push notifications.</li> <li>Responsive Design: Ensure the website is mobile-friendly and works well on various screen sizes.</li> <li>Performance Optimization: Optimize loading times and responsiveness to provide a smooth user experience.</li> </ol>","tags":["Personal"]},{"location":"blog/2025/04/27/what-is-pwa/#steps-to-turn-your-website-into-a-pwa","title":"Steps to Turn Your Website into a PWA","text":"<ol> <li>Serve Over HTTPS: Ensure your site is secure.</li> <li>Create a Manifest File: Define your app\u2019s metadata.</li> <li>Implement a Service Worker: This script runs in the background and manages caching and offline capabilities.</li> <li>Make It Responsive: Use responsive design techniques (like CSS media queries) to ensure usability on all devices.</li> <li>Test Your PWA: Use tools like Google Lighthouse to assess your PWA\u2019s performance and compliance.</li> </ol>","tags":["Personal"]},{"location":"blog/2025/04/27/what-is-pwa/#summary","title":"Summary","text":"<p>While you can convert most websites into PWAs, achieving the best results may require some development effort and optimizations. Once done, users can enjoy a more integrated, app-like experience!</p>","tags":["Personal"]},{"location":"blog/2025/04/27/what-is-pwa/#reference","title":"Reference","text":"<ul> <li>Adjust Color Temperature of Your Screen Using Terminal in Ubuntu and Fedora</li> <li>Use web apps</li> </ul>","tags":["Personal"]},{"location":"blog/2025/04/28/difference-between-single--double-curly-braces/","title":"Difference between Single &amp; Double Curly Braces","text":"","tags":["Personal"]},{"location":"blog/2025/04/28/difference-between-single--double-curly-braces/#difference-between-single-double-curly-braces","title":"Difference between <code>Single</code> &amp; <code>Double</code> Curly Braces","text":"<p>In JavaScript (and JSX), <code>{}</code> and <code>{{}}</code> are used in different contexts, and here's the distinction:</p> Success <code>{}</code> (Single Curly Braces)<code>{{}}</code> (Double Curly Braces) <ul> <li> <p>In JSX: <code>{}</code> is used to embed JavaScript expressions into JSX.</p> <ul> <li>Example: <code>const name = 'John';</code> and <code>&lt;div&gt;{name}&lt;/div&gt;</code> will render the value of <code>name</code> inside the <code>&lt;div&gt;</code>.</li> </ul> </li> <li> <p>In JavaScript: <code>{}</code> is also used for defining objects, blocks, or destructuring.</p> <ul> <li> <p>In JSX: When you want to embed a variable or a JavaScript expression (like a number, string, function call, etc.) inside JSX, you wrap it with <code>{}</code>. For example:</p> <pre><code>const greeting = 'Hello, World!';\nreturn &lt;h1&gt;{greeting}&lt;/h1&gt;;  // The value of greeting will be displayed inside the &lt;h1&gt;\n</code></pre> </li> </ul> </li> </ul> <ul> <li> <p>In JSX: {{}} is commonly used when you're passing an object as a prop, especially for inline styles or for embedding an object inside JSX.</p> <ul> <li> <p>For inline styles, you need to use a double pair of curly braces:</p> <pre><code>const style = { color: 'blue', fontSize: '16px' };\nreturn &lt;div style={{ color: 'blue', fontSize: '16px' }}&gt;Styled Text&lt;/div&gt;;\n</code></pre> <ul> <li>The first pair <code>{}</code> is for the JSX syntax (since it's in JSX, it expects expressions).</li> <li>The second pair <code>{{}}</code> is the object itself that you want to pass (the inline styles are represented as an object).</li> </ul> </li> <li> <p>Another use case is when you're passing an object to a function or a component prop:</p> <pre><code>&lt;Component prop={{ key: 'value' }} /&gt;\n</code></pre> <p>This means you're passing an object <code>{ key: 'value' }</code> to the <code>prop</code> of the <code>Component</code>.</p> </li> </ul> </li> </ul> <ul> <li><code>{}</code> (Single Curly Braces): Used to embed JavaScript expressions in JSX.</li> <li><code>{{}}</code> (Double Curly Braces): Used when you want to pass an object (like inline styles or any other object) inside JSX.</li> </ul>","tags":["Personal"]},{"location":"blog/2025/04/28/difference-between-single--double-curly-braces/#improvements","title":"Improvements","text":"MainLayoutHeader <pre><code>import { Layout } from \"antd\";\nimport Header from \"./Header\";\nimport Sidebar from \"./Sidebar\";\nimport { useState } from \"react\";\n\nconst { Content } = Layout;\n\nconst MainLayout = ({ children }) =&gt; {\n    const [collapsed, setCollapsed] = useState(false);\n\n    // Calculate sidebar width based on collapse state\n    const sidebarWidth = collapsed ? 80 : 240;\n\n    // Calculate content width based on sidebar state\n    const contentWidth = `calc(100% - ${sidebarWidth}px)`;\n\n    return (\n        &lt;Layout style={{ minHeight: \"100vh\" }}&gt;\n            &lt;Header collapsed={collapsed} setCollapsed={setCollapsed} /&gt;\n            &lt;Layout style={{ display: \"flex\" }}&gt;\n                &lt;Sidebar collapsed={collapsed} width={sidebarWidth} /&gt;\n                &lt;Content style={{ width: contentWidth }}&gt;{children}&lt;/Content&gt;\n            &lt;/Layout&gt;\n        &lt;/Layout&gt;\n    );\n};\n\nexport default MainLayout;\n</code></pre> <pre><code>import { MenuUnfoldOutlined, MenuFoldOutlined } from \"@ant-design/icons\";\nimport { Layout } from \"antd\";\n\nconst { Header: AntHeader } = Layout;\n\nconst Header = ({ collapsed, setCollapsed }) =&gt; {\n    return (\n        &lt;AntHeader style={{ padding: 0 }}&gt;\n            &lt;div style={{ display: \"flex\", justifyContent: \"space-between\" }}&gt;\n                &lt;div&gt;\n                    &lt;button\n                        onClick={() =&gt; setCollapsed(!collapsed)}\n                        style={{ background: \"none\", border: \"none\" }}\n                    &gt;\n                        {collapsed ? &lt;MenuUnfoldOutlined /&gt; : &lt;MenuFoldOutlined /&gt;}\n                    &lt;/button&gt;\n                &lt;/div&gt;\n                &lt;div&gt; {/* Other header content */} &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/AntHeader&gt;\n    );\n};\n\nexport default Header;\n</code></pre>","tags":["Personal"]},{"location":"blog/2025/04/28/difference-between-single--double-curly-braces/#final-optimized-code","title":"Final Optimized Code:","text":"MainLayout.jsxHeader.jsx <pre><code>import { useState, useCallback } from \"react\";\nimport { Layout } from \"antd\";\nimport { RightCircleOutlined, LeftCircleOutlined } from \"@ant-design/icons\";\n\nimport Header from \"./Header\";\nimport Sidebar from \"./Sidebar\";\n\nconst { Content } = Layout;\n\nconst MainLayout = ({ children }) =&gt; {\n    const [collapsed, setCollapsed] = useState(false);\n\n    // Using useCallback to memoize the function and prevent unnecessary re-renders\n    const toggleSidebar = useCallback(() =&gt; {\n        setCollapsed((prev) =&gt; !prev);\n    }, []);\n\n    const sidebarWidth = collapsed ? 80 : 240;\n    const contentWidth = `calc(100% - ${sidebarWidth}px)`;\n\n    return (\n        &lt;Layout&gt;\n            &lt;Header toggleSidebar={toggleSidebar} /&gt; {/* Pass toggleSidebar to Header */}\n            &lt;Layout style={{ display: \"flex\" }}&gt;\n                &lt;Sidebar collapsed={collapsed} width={sidebarWidth} /&gt;\n                &lt;Content style={{ width: contentWidth, position: \"relative\" }}&gt;\n                    {collapsed ? (\n                        &lt;RightCircleOutlined\n                            onClick={toggleSidebar}\n                            aria-label=\"Expand Sidebar\"\n                        /&gt;\n                    ) : (\n                        &lt;LeftCircleOutlined\n                            onClick={toggleSidebar}\n                            aria-label=\"Collapse Sidebar\"\n                        /&gt;\n                    )}\n                    {children}\n                &lt;/Content&gt;\n            &lt;/Layout&gt;\n        &lt;/Layout&gt;\n    );\n};\n\nexport default MainLayout;\n</code></pre> <pre><code>import React from 'react';\nimport { Layout, Button } from 'antd';\nimport { MenuFoldOutlined, MenuUnfoldOutlined } from '@ant-design/icons';\n\nconst { Header: AntHeader } = Layout;\n\nconst Header = ({ toggleSidebar }) =&gt; {\n    return (\n        &lt;AntHeader style={{ padding: 0, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}&gt;\n            {/* Button to toggle sidebar */}\n            &lt;Button\n                type=\"primary\"\n                icon={toggleSidebar ? &lt;MenuUnfoldOutlined /&gt; : &lt;MenuFoldOutlined /&gt;}\n                onClick={toggleSidebar}\n                aria-label=\"Toggle Sidebar\"\n                style={{ marginLeft: 16 }}\n            /&gt;\n            {/* You can add other elements like branding, user info, etc. */}\n            &lt;div style={{ fontSize: '18px', color: 'white' }}&gt;My Application&lt;/div&gt;\n        &lt;/AntHeader&gt;\n    );\n};\n\nexport default Header;\n</code></pre>","tags":["Personal"]},{"location":"blog/2025/04/28/difference-between-single--double-curly-braces/#react-responsive","title":"react-responsive","text":"<pre><code>npm install react-responsive\n</code></pre> Updated Code with Responsiveness <pre><code>import { Layout } from \"antd\";\nimport Header from \"./Header\";\nimport Sidebar from \"./Sidebar\";\nimport { useState } from \"react\";\nimport { useMediaQuery } from \"react-responsive\";\n\nconst { Content } = Layout;\n\nconst MainLayout = ({ children }) =&gt; {\n    // State for sidebar collapse\n    const [collapsed, setCollapsed] = useState(false);\n\n    // Set sidebar width based on collapse state\n    const sidebarWidth = collapsed ? 80 : 240;\n\n    // Use media query to check if the screen is small\n    const isSmallScreen = useMediaQuery({ maxWidth: 768 });\n\n    // Automatically collapse sidebar on small screens\n    if (isSmallScreen &amp;&amp; !collapsed) {\n        setCollapsed(true);\n    }\n\n    // Calculate content width based on sidebar state\n    const contentWidth = `calc(100% - ${sidebarWidth}px)`;\n\n    return (\n        &lt;Layout style={{ minHeight: \"100vh\" }}&gt;\n            &lt;Header collapsed={collapsed} setCollapsed={setCollapsed} /&gt;\n            &lt;Layout style={{ display: \"flex\" }}&gt;\n                &lt;Sidebar collapsed={collapsed} width={sidebarWidth} /&gt;\n                &lt;Content style={{ width: contentWidth }}&gt;{children}&lt;/Content&gt;\n            &lt;/Layout&gt;\n        &lt;/Layout&gt;\n    );\n};\n\nexport default MainLayout;\n</code></pre> <pre><code>// 1. Use effect to update sidebar collapse state based on screen size\nuseEffect(() =&gt; {\n  if (isSmallScreen &amp;&amp; !collapsed) {\n    setCollapsed(true); // Collapse sidebar on small screens\n  } else if (!isSmallScreen &amp;&amp; collapsed) {\n    setCollapsed(false); // Expand sidebar on large screens\n  }\n}, [isSmallScreen, collapsed]); // Trigger effect on screen size change\n\n// 2. Automatically collapse sidebar on small screens, but allow manual toggle on large screens\nuseEffect(() =&gt; {\n  if (isSmallScreen) {\n    setCollapsed(true); // Collapse sidebar on small screens\n  } else {\n    // Don't override user's manual collapse state on large screens\n    setCollapsed((prev) =&gt; prev); // Keep the previous state intact\n  }\n}, [isSmallScreen]); // Trigger this effect only when the screen size changes\n\n// 3. Automatically collapse sidebar on small screens, but allow manual toggle on large screens\nuseEffect(() =&gt; {\n  if (isSmallScreen) {\n    setCollapsed(true); // Collapse sidebar on small screens\n  } else {\n    setCollapsed(false); // Expand sidebar on larger screens\n  }\n}, [isSmallScreen]); // Trigger this effect only when the screen size changes\n</code></pre>","tags":["Personal"]},{"location":"blog/2025/04/28/difference-between-single--double-curly-braces/#reference","title":"Reference","text":"<ul> <li>Responsive websites with React-Responsive</li> <li>Use React Responsive Libraries</li> <li>RTK Query For Beginners</li> </ul>","tags":["Personal"]},{"location":"blog/2025/04/28/export-issue-lexical-declartion/","title":"Export Issue Lexical Declartion","text":"","tags":["Personal"]},{"location":"blog/2025/04/28/export-issue-lexical-declartion/#export-issue-lexical-declartion","title":"Export Issue Lexical Declartion","text":"<pre><code>Uncaught ReferenceError: can't access lexical declaration 'axiosBaseQuery' before initialization\n    &lt;anonymous&gt; http://localhost:4400/src/features/forex/services/forexApi.js?t=1735203341695:10\n</code></pre> <pre><code>// ASIOS\nimport axiosInstance from \"./axiosInstance\";\n\nconst axiosBaseQuery =\n    ({ baseUrl } = { baseUrl: \"\" }) =&gt;\n    async ({ url, method, meta, data, params, headers }) =&gt; {\n    try {\n        const result = await axiosInstance.base({\n          url: baseUrl + url,\n          method,\n          meta,\n          data,\n          params,\n          headers,\n        });\n\n        return { data: result.data, meta: { ...meta, method } };\n    } catch (axiosError) {\n        const err = axiosError;\n        return {\n        error: {\n            status: err.response?.status,\n            data: err.response?.data || err.message,\n            meta: { ...meta, method },\n        },\n        };\n    }\n    };\n\nexport default axiosBaseQuery;\n\n\n// API\nimport { createApi } from \"@reduxjs/toolkit/query/react\";\nimport queryString from \"query-string\";\nimport axiosBaseQuery from \"@shared/services/axios/axiosBaseQuery\";\nimport { CONFIG } from \"@shared/utils/config\";\nimport { handleApiMessage } from \"@shared/utils/apiMessage\";\nimport logger from \"@shared/utils/logger\";\n\nexport const forexApi = createApi({\n  reducerPath: \"forexApi\",\n  baseQuery: axiosBaseQuery({\n    baseUrl: CONFIG.API_BASE_URL,\n  }),\n  endpoints: (builder) =&gt; ({\n    getForexApprovalPerson: builder.query({\n      query: ({ sellingAmount }) =&gt; {\n        const queryParams = queryString.stringify({\n          sellingAmount,\n        });\n\n        return {\n          url: ApprovalPerson?${queryParams},\n          method: \"get\",\n        };\n      },\n    }),\n    postForex: builder.mutation({\n      query: (data) =&gt; ({\n        url: \"FOREX\",\n        method: \"post\",\n        data,\n      }),\n    }),\n  }),\n});\n\nexport const { useGetForexApprovalPersonQuery, usePostForexMutation } =\n  forexApi;\n</code></pre> <p>The error you're encountering, <code>Uncaught ReferenceError: can't access lexical declaration 'axiosBaseQuery' before initialization</code>, occurs because of a problem related to the order of variable declarations and imports. In JavaScript, <code>let</code>, <code>const</code>, and <code>class</code> declarations are hoisted in a way that they are not accessible before they are initialized, which is likely what's happening in your case.</p> <p>Let's break it down:</p> <p>Problem Explanation</p> <p>The issue seems to be happening because <code>axiosBaseQuery</code> is being used before it is properly initialized. Specifically, this issue arises when there is a circular dependency or a situation where the import and declaration order creates a race condition. Potential Causes</p> <ol> <li>Circular Dependencies: If <code>axiosBaseQuery</code> imports something that relies on the <code>forexApi</code> (or any related module), it can cause this issue.</li> <li>Execution Order: JavaScript hoisting does not allow you to use variables before they are initialized. You might be trying to use <code>axiosBaseQuery</code> in a way that it's not available when it's first referenced.</li> </ol> Suggested Fixes <ol> <li> <p>Check for Circular Dependencies: Make sure there are no circular dependencies between the modules you're importing. If <code>axiosBaseQuery</code> depends on something from <code>forexApi</code>, or vice versa, try to refactor the imports to avoid this loop.</p> </li> <li> <p>Move <code>axiosBaseQuery</code> definition above the <code>export</code>: Ensure that <code>axiosBaseQuery</code> is properly defined and initialized before any module attempts to access it. In your case, this should already be the case, but it's worth checking the import order.</p> </li> <li> <p>Use Named Imports (Optional): Instead of using a default export for <code>axiosBaseQuery</code>, consider using named exports to make sure the imports are correctly resolved.</p> </li> <li> <p>Refactor the Import and Usage: Here\u2019s how you could refactor the code to potentially avoid the initialization error:</p> </li> </ol> <p>Refactor <code>axiosBaseQuery</code> to ensure proper initialization:</p> <pre><code>// axiosBaseQuery.js\nimport axiosInstance from \"./axiosInstance\";\n\nexport const axiosBaseQuery =\n  ({ baseUrl } = { baseUrl: \"\" }) =&gt;\n  async ({ url, method, meta, data, params, headers }) =&gt; {\n    try {\n      const result = await axiosInstance.base({\n        url: baseUrl + url,\n        method,\n        meta,\n        data,\n        params,\n        headers,\n      });\n\n      return { data: result.data, meta: { ...meta, method } };\n    } catch (axiosError) {\n      const err = axiosError;\n      return {\n        error: {\n          status: err.response?.status,\n          data: err.response?.data || err.message,\n          meta: { ...meta, method },\n        },\n      };\n    }\n  };\n</code></pre> <p>Use named import for <code>axiosBaseQuery</code></p> <pre><code>// forexApi.js\nimport { axiosBaseQuery } from \"@shared/services/axios/axiosBaseQuery\";\nimport { createApi } from \"@reduxjs/toolkit/query/react\";\nimport queryString from \"query-string\";\nimport { CONFIG } from \"@shared/utils/config\";\nimport { handleApiMessage } from \"@shared/utils/apiMessage\";\nimport logger from \"@shared/utils/logger\";\n\nexport const forexApi = createApi({\n  reducerPath: \"forexApi\",\n  baseQuery: axiosBaseQuery({\n    baseUrl: CONFIG.API_BASE_URL,\n  }),\n  endpoints: (builder) =&gt; ({\n    getForexApprovalPerson: builder.query({\n      query: ({ sellingAmount }) =&gt; {\n        const queryParams = queryString.stringify({\n          sellingAmount,\n        });\n\n        return {\n          url: `ApprovalPerson?${queryParams}`,\n          method: \"get\",\n        };\n      },\n    }),\n    postForex: builder.mutation({\n      query: (data) =&gt; ({\n        url: \"FOREX\",\n        method: \"post\",\n        data,\n      }),\n    }),\n  }),\n});\n\nexport const { useGetForexApprovalPersonQuery, usePostForexMutation } =\n  forexApi;\n</code></pre> <p>By ensuring <code>axiosBaseQuery</code> is exported correctly and imported without circular dependencies, this should resolve the issue you're seeing.</p>","tags":["Personal"]},{"location":"blog/2024/05/29/deep-dive-into-map/","title":"Deep Dive into .map()","text":"","tags":["Personal"]},{"location":"blog/2024/05/29/deep-dive-into-map/#deep-dive-into-map","title":"Deep Dive into <code>.map()</code>","text":"<p>Deep Dive into <code>.map()</code>: Advanced Usage and Hidden Features in JavaScript</p> <p>Great question! These are all ways to use the <code>map()</code> function in JavaScript, but they serve slightly different purposes based on how you <code>return</code> values.</p>","tags":["Personal"]},{"location":"blog/2024/05/29/deep-dive-into-map/#1-mapitem-itemid","title":"1. <code>.map((item) =&gt; item.id)</code>","text":"<p>This syntax is used when you're returning a single value (such as <code>item.id</code>) without wrapping it in an object or block. This is called an implicit return. It\u2019s common when you\u2019re just transforming each item to a single property.</p> <pre><code>let ids = items.map((item) =&gt; item.id);\n</code></pre> <ul> <li>This will create a new array <code>ids</code> containing only the <code>id</code> property from each <code>item</code>.</li> <li>When to use it: When you want to return a single value (a property or a simple transformation) for each element.</li> </ul>","tags":["Personal"]},{"location":"blog/2024/05/29/deep-dive-into-map/#2-mapitem","title":"2. <code>.map((item) =&gt; ({}))</code>","text":"<p>This syntax is used when you want to return an object for each item in the array. The parentheses <code>()</code> around the curly braces <code>{}</code> are necessary to tell JavaScript that you are returning an object instead of defining a block of code.</p> <pre><code>let newObjects = items.map((item) =&gt; ({\n  id: item.id,\n  name: item.name,\n}));\n</code></pre> <ul> <li>This creates a new array <code>newObjects</code> where each element is an object with both <code>id</code> and <code>name</code> properties.</li> <li>When to use it: When you want to return an object for each item.</li> </ul>","tags":["Personal"]},{"location":"blog/2024/05/29/deep-dive-into-map/#3-mapitem-return-explicit-return","title":"3. <code>.map((item) =&gt; { return {} })</code> (Explicit return)","text":"<p>In some cases, you may need to perform more operations or add logic before returning a value. In this case, you can use curly braces <code>{}</code> to define a block of code and explicitly use the return keyword to <code>return</code> an object or any other value.</p> <pre><code>let newArray = items.map((item) =&gt; {\n  let newItem = { id: item.id };\n\n  if (item.isActive) {\n    newItem.status = \"Active\";\n  }\n\n  return newItem;\n});\n</code></pre> <ul> <li>When to use it: When you need to do more than just return a value (such as doing calculations, adding conditions, etc.), or when you want to make your logic clearer. If you open the function body with <code>{}</code>, you need to use the return keyword to explicitly <code>return</code> something.</li> </ul>","tags":["Personal"]},{"location":"blog/2024/05/29/deep-dive-into-map/#summary","title":"Summary:","text":"<ul> <li><code>.map((item) =&gt; item.id)</code>: Use when you\u2019re returning a single value (no object or extra logic).</li> <li><code>.map((item) =&gt; ({ ... }))</code>: Use when you\u2019re returning an object directly.</li> <li><code>.map((item) =&gt; { return ... })</code>: Use when you need additional logic inside the function body before returning a value.</li> </ul>","tags":["Personal"]},{"location":"blog/2024/05/29/deep-dive-into-map/#advanced-and-hidden-usage-of-map","title":"Advanced and Hidden Usage of <code>.map()</code>","text":"<ol> <li> <p>Chaining <code>.map()</code> with Other Array Methods:</p> <ul> <li>Example: Combining <code>.map()</code> with <code>.filter()</code> or <code>.reduce()</code> for complex transformations.</li> <li>Use Case: Processing data through multiple stages of transformation and filtering.</li> </ul> <pre><code>const processedData = data\n  .filter((item) =&gt; item.isActive)\n  .map((item) =&gt; ({ id: item.id, name: item.name }))\n  .reduce((acc, item) =&gt; acc.concat(item.name), []);\n</code></pre> </li> <li> <p>Transforming Arrays of Objects:</p> <ul> <li>Example: Creating new objects or modifying existing ones while mapping.</li> <li>Use Case: Reshaping data structures for UI components or APIs.</li> </ul> <pre><code>const userProfiles = users.map((user) =&gt; ({\n  id: user.id,\n  fullName: `${user.firstName} ${user.lastName}`,\n  isActive: user.status === \"active\",\n}));\n</code></pre> </li> <li> <p>Using <code>.map()</code> for Index-Based Transformations:</p> <ul> <li>Example: Accessing the index of each element within the <code>.map()</code> function.</li> <li>Use Case: Applying logic based on the position of each item in the array.</li> </ul> <pre><code>const indexedItems = items.map((item, index) =&gt; ({ ...item, index }));\n</code></pre> </li> <li> <p>Mapping Over Non-Array Objects:</p> <ul> <li>Example: Using <code>Object.keys()</code> or <code>Object.entries()</code> with <code>.map()</code>.</li> <li>Use Case: Transforming object properties or key-value pairs.</li> </ul> <pre><code>const obj = { a: 1, b: 2, c: 3 };\nconst entries = Object.entries(obj).map(\n  ([key, value]) =&gt; `${key}: ${value}`\n);\n</code></pre> </li> <li> <p>Creating Nested Data Structures:</p> <ul> <li>Example: Using <code>.map()</code> to generate nested arrays or objects.</li> <li>Use Case: Preparing data for complex UI components like nested tables or trees.</li> </ul> <pre><code>const nestedData = data.map((item) =&gt; ({\n  id: item.id,\n  details: {\n    name: item.name,\n    description: item.description,\n  },\n}));\n</code></pre> </li> <li> <p>Transforming Arrays with Side Effects:</p> <ul> <li>Example: Performing operations that have side effects, though this is generally discouraged.</li> <li>Use Case: Logging or modifying external states during the transformation.</li> </ul> <pre><code>const updatedItems = items.map((item) =&gt; {\n  console.log(`Processing item with id: ${item.id}`);\n\n  return { ...item, processed: true };\n});\n</code></pre> </li> </ol> <p>These advanced techniques and hidden usages of <code>.map()</code> can help you unlock its full potential and apply it to more complex scenarios.</p>","tags":["Personal"]},{"location":"blog/2024/05/21/exploring-objectprototype-in-javascript/","title":"Exploring Object.prototype in JavaScript","text":"","tags":["js"]},{"location":"blog/2024/05/21/exploring-objectprototype-in-javascript/#exploring-objectprototype-in-javascript","title":"Exploring <code>Object.prototype</code> in JavaScript","text":"<p>You can inspect the Object.prototype in various ways depending on the environment you are working in. Here are a few methods to do this:</p>","tags":["js"]},{"location":"blog/2024/05/21/exploring-objectprototype-in-javascript/#in-a-browser-console","title":"In a Browser Console","text":"<ul> <li>Open Developer Tools: You can usually open this by pressing <code>F12</code>, <code>Ctrl+Shift+I</code>, or <code>Cmd+Option+I</code>.</li> <li>Go to the Console Tab: Here you can execute JavaScript code.</li> <li> <p>Inspect <code>Object.prototype</code>: Type the following code and press Enter:</p> <pre><code>console.dir(Object.prototype);\n</code></pre> </li> </ul>","tags":["js"]},{"location":"blog/2024/05/21/exploring-objectprototype-in-javascript/#using-nodejs","title":"Using Node.js","text":"<ul> <li>Open a Terminal: Ensure you have Node.js installed.</li> <li>Run the Node.js REPL: Type node and press Enter.</li> <li> <p>Inspect <code>Object.prototype</code>: Type the following code and press Enter:</p> <pre><code>console.dir(Object.prototype);\n</code></pre> </li> </ul>","tags":["js"]},{"location":"blog/2024/05/21/exploring-objectprototype-in-javascript/#example-output","title":"Example Output","text":"<p>When you inspect <code>Object.prototype</code>, you should see an object with various methods and properties like <code>hasOwnProperty</code>, <code>toString</code>, <code>valueOf</code>, etc. Here is a partial example of what you might see:</p> <pre><code>{\n  constructor: \u0192 Object(),\n  hasOwnProperty: \u0192 hasOwnProperty(),\n  isPrototypeOf: \u0192 isPrototypeOf(),\n  propertyIsEnumerable: \u0192 propertyIsEnumerable(),\n  toLocaleString: \u0192 toLocaleString(),\n  toString: \u0192 toString(),\n  valueOf: \u0192 valueOf()\n}\n</code></pre>","tags":["js"]},{"location":"blog/2024/05/21/exploring-objectprototype-in-javascript/#exploring-in-detail","title":"Exploring in Detail","text":"<p>You can also explore the prototype chain by accessing properties and methods directly in the console. For example:</p> <pre><code>console.log(Object.prototype.hasOwnProperty);\nconsole.log(Object.prototype.toString);\n</code></pre> <p>These methods belong to the <code>Object.prototype</code> and are inherited by all objects created in JavaScript unless explicitly overridden.</p>","tags":["js"]},{"location":"blog/2024/05/17/understanding-functional-state-updates-in-react-a-deep-dive-into-setselectedgroupdata/","title":"Understanding Functional State Updates in React: A Deep Dive into setSelectedGroupData","text":"","tags":["react","js"]},{"location":"blog/2024/05/17/understanding-functional-state-updates-in-react-a-deep-dive-into-setselectedgroupdata/#understanding-functional-state-updates-in-react-a-deep-dive-into-setselectedgroupdata","title":"Understanding Functional State Updates in React: A Deep Dive into <code>setSelectedGroupData</code>","text":"<p>When managing state in React, especially with complex objects, you often need to update just one part of the state without affecting the rest. A common pattern for this is the functional state update, which ensures your state changes are safe, predictable, and efficient.</p> <p>Let\u2019s break down the line of code:</p> <pre><code>setSelectedGroupData((prevData) =&gt; ({\n    ...prevData,\n    isReadUnread: updatedIsRead,\n}));\n</code></pre> What\u2019s Happening Here? <ol> <li> <p>Functional Update:</p> <p>The function passed to <code>setSelectedGroupData</code> receives the previous state (<code>prevData</code>) as an argument. This approach is particularly useful when your new state depends on the previous one, preventing potential bugs caused by asynchronous state updates.</p> </li> <li> <p>Immutability with the Spread Operator:</p> <p>The spread operator (<code>...prevData</code>) is used to create a shallow copy of the current state. In React, state is immutable\u2014meaning you shouldn't modify it directly. By copying the existing state into a new object, you preserve immutability, which is crucial for React to efficiently detect changes and trigger re-renders.</p> </li> <li> <p>Merging State:</p> <p>After copying the old state, the <code>isReadUnread</code> property is updated with a new value (<code>updatedIsRead</code>). This process ensures that only this specific property is changed, while all other properties remain intact.</p> </li> </ol> Why Use This Pattern? <ul> <li>Avoiding Bugs: Functional updates ensure that your state is always based on the most current data, avoiding potential race conditions.</li> <li>Performance: By only changing the necessary parts of the state, React can optimize re-renders, leading to better performance.</li> <li>Readability: This pattern makes it clear which parts of the state are being updated, making your code easier to understand and maintain.</li> </ul>","tags":["react","js"]},{"location":"blog/2024/05/17/understanding-functional-state-updates-in-react-a-deep-dive-into-setselectedgroupdata/#conclusion","title":"Conclusion","text":"<p>Understanding and utilizing functional state updates in React is essential for building reliable and performant applications. By leveraging patterns like the one we've explored, you can ensure that your state management is both efficient and robust, paving the way for a smoother development process.</p>","tags":["react","js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/","title":"Handling Circular References in JavaScript: Avoiding 'TypeError: cyclic object value' in JSON.stringify","text":"","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify","title":"Handling Circular References in JavaScript: Avoiding 'TypeError: cyclic object value' in JSON.stringify","text":"<p>The TypeError: cyclic object value error typically occurs when trying to convert a JavaScript object that contains circular references into a JSON string. Circular references happen when an object references itself either directly or indirectly, creating an infinite loop that <code>JSON.stringify</code> cannot handle.</p> <p>Here's an example of a circular reference:</p> <pre><code>let obj = {};\nobj.self = obj;\nJSON.stringify(obj); // TypeError: cyclic object value\n</code></pre>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#how-to-solve-it","title":"How to Solve It","text":"<p>To solve this issue, you have a few options:</p> <ol> <li> <p>Remove Circular References:</p> <p>Manually ensure that your object does not have any circular references before calling <code>JSON.stringify</code>.</p> </li> <li> <p>Use a Custom Replacer Function:</p> <p>Use a replacer function with <code>JSON.stringify</code> to filter out circular references.</p> </li> <li> <p>Use a Library:</p> <p>Utilize a library designed to handle circular references, such as <code>circular-json</code>(deprecated) or <code>flatted</code>.</p> <pre><code>function getCircularReplacer() {\n    const seen = new WeakSet();\n    return (key, value) =&gt; {\n        if (typeof value === \"object\" &amp;&amp; value !== null) {\n            if (seen.has(value)) {\n                return;\n            }\n            seen.add(value);\n        }\n        return value;\n    };\n}\n\nJSON.stringify(obj, getCircularReplacer());\n</code></pre> Danger <pre><code>npm install circular-json\n</code></pre> <pre><code>const CircularJSON = require('circular-json');\nconst jsonString = CircularJSON.stringify(obj);\n</code></pre> <p>Or using flatted:</p> Success <pre><code>npm install flatted\n</code></pre> <pre><code>const { stringify, parse } = require('flatted');\nconst jsonString = stringify(obj);\n</code></pre> </li> </ol>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#example-solution","title":"Example Solution","text":"<p>Here is an example of using a custom replacer function to handle circular references:</p> <pre><code>const obj1 = {};\nconst obj2 = { obj1 };\nobj1.obj2 = obj2;\n\nfunction getCircularReplacer() {\n    const seen = new WeakSet();\n    return (key, value) =&gt; {\n        if (typeof value === \"object\" &amp;&amp; value !== null) {\n            if (seen.has(value)) {\n                return;\n            }\n            seen.add(value);\n        }\n        return value;\n    };\n}\n\nconst jsonString = JSON.stringify(obj1, getCircularReplacer());\nconsole.log(jsonString);\n</code></pre> <p>By using these methods, you can avoid the TypeError: cyclic object value error and successfully convert your object to a JSON string.</p>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#improvement","title":"Improvement","text":"Example1 Bug <pre><code>style={{\n    display: \"flex\",\n    justifyContent:\n    JSON.stringify(item?.userId)?.toUpperCase() === appUserIdUC\n        ? \"flex-end\"\n        : \"flex-start\",\n}}\n</code></pre> <p>is this correct way to stringify data</p> <p>Using <code>JSON.stringify</code> in this context is unnecessary and not the correct approach for comparing strings. Instead, you should directly compare the values after ensuring they are strings. Here's the corrected version:</p> Success <pre><code>style={{\n    display: \"flex\",\n    justifyContent: item?.userId?.toString().toUpperCase() === appUserIdUC\n        ? \"flex-end\"\n        : \"flex-start\",\n}}\n</code></pre> <p>Explanation:</p> <ul> <li>item?.userId?.toString().toUpperCase(): This ensures that <code>item?.userId</code> is converted to a string and transformed to uppercase for comparison.</li> <li>appUserIdUC: This is assumed to be already in uppercase format for comparison.</li> </ul> <p>This approach avoids unnecessary stringification and makes the code cleaner and more efficient.</p>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#when-to-use-jsonstringify","title":"When to use JSON,stringify","text":"<p>In this context, JSON.stringify might be necessary if selectedAttendees is an array or an object that needs to be sent as a string in the bodyPayload. However, if selectedAttendees is already a string or a primitive value, JSON.stringify is not needed.</p> <pre><code> const bodyPayload = {\n            companyId: selectedCompanyId,\n            circularPlanningTemplateId: selectedMenuItem,\n            remarks: values?.remarks,\n            ModeofCommunication: remarksData?.remarks,\n            attentionTo: JSON.stringify(selectedAttendees),\n            isactive: true,\n        }; \n</code></pre> <p>Here\u2019s how you can adjust it based on different scenarios:</p>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#if-selectedattendees-is-an-array-or-object","title":"If selectedAttendees is an Array or Object:","text":"<p>If <code>selectedAttendees</code> is an array or object and you need to send it as a JSON string, your current approach is correct.</p> <pre><code>const bodyPayload = {\n    companyId: selectedCompanyId,\n    circularPlanningTemplateId: selectedMenuItem,\n    remarks: values?.remarks,\n    ModeofCommunication: remarksData?.remarks,\n    attentionTo: JSON.stringify(selectedAttendees), // Correct if selectedAttendees is an array or object\n    isactive: true,\n};\n</code></pre>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#summary","title":"Summary","text":"<ul> <li>Use <code>JSON.stringify</code> if selectedAttendees is an array or object.</li> <li>Do not use <code>JSON.stringify</code> if selectedAttendees is already a string.</li> </ul> <p>This ensures that the bodyPayload is constructed correctly based on the type of selectedAttendees.</p>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#scenario-circular-references-in-nested-objects","title":"Scenario: Circular References in Nested Objects","text":"<p>Imagine you have a complex data structure representing a company with departments, and each department has a reference to the company, creating a circular reference.</p> <pre><code>// Define a company object\nconst company = {\n    name: \"TechCorp\",\n    departments: []\n};\n\n// Define a department object\nconst department = {\n    name: \"Engineering\",\n    company: company // Circular reference\n};\n\n// Add the department to the company's departments array\ncompany.departments.push(department);\n\n// Attempt to stringify the company object\ntry {\n    const jsonString = JSON.stringify(company);\n    console.log(jsonString);\n} catch (error) {\n    console.error(\"Error stringifying object:\", error);\n}\n</code></pre>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#explanation","title":"Explanation:","text":"<ul> <li> <p>Circular Reference: The <code>company</code> object contains a reference to the <code>department</code> object, which in turn has a reference back to the company object. This creates a circular reference.</p> </li> <li> <p>JSON.stringify: When you try to convert the <code>company</code> object to a JSON string using <code>JSON.stringify</code>, the process fails because <code>JSON.stringify</code> cannot handle circular references.</p> </li> </ul>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#handling-the-circular-reference","title":"Handling the Circular Reference","text":"<p>To avoid the TypeError: cyclic object value error, you can use a custom replacer function or a library like <code>circular-json</code> or <code>flatted</code>.</p>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#avoiding-circular-references","title":"Avoiding Circular References","text":"<p>To avoid circular references, you can use a custom serializer or a library like flatted to handle circular references:</p> <p>First, install <code>flatted</code>:</p> <pre><code>npm install flatted\n</code></pre> <p>Then update the component to use <code>flatted</code>:</p> <pre><code>import React, { useState, useEffect } from 'react';\nimport { stringify } from 'flatted';\n\nconst ExampleComponent = () =&gt; {\n  const [employee, setEmployee] = useState({\n    name: \"Eve\",\n    position: \"Software Engineer\",\n    department: {}\n  });\n\n  useEffect(() =&gt; {\n    // Creating a circular reference\n    const department = {\n        name: \"Engineering\",\n        employees: [employee]\n    };\n\n    setEmployee(prevEmployee =&gt; {\n        const updatedEmployee = { ...prevEmployee, department };\n        department.manager = updatedEmployee; // Adding circular reference\n        return updatedEmployee;\n    });\n\n    try {\n        // console.log(JSON.stringify(employee));\n        console.log(stringify(employee)); // Using flatted.stringify\n    } catch (error) {\n        console.error(\"Error: \", error.message);\n    }\n  }, [employee]);\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Employee Details&lt;/h1&gt;\n      &lt;p&gt;Name: {employee.name}&lt;/p&gt;\n      &lt;p&gt;Position: {employee.position}&lt;/p&gt;\n      &lt;p&gt;Department: {employee.department.name}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default ExampleComponent;\n</code></pre> <p>By using the flatted library, you can handle circular references safely and serialize your objects without encountering the <code>TypeError: cyclic object value</code>.</p>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#real-time-office-error","title":"Real-Time Office Error","text":"Danger circularTemplate.js<pre><code>const handleMenuClick = (e) =&gt; {\n    setSelectedMenuItem(e.key);\n    // error on dispatch e.key\n    dispatch(actionForGetCircularPlanningCompanyDtos(e.key))\n    setSelectedMenuItemTitle(e.item.props['value'])\n};\n\n\nconst columns = [\n    {\n        title: \"Attention to\",\n        key: \"attentionTo\",\n        render: (record) =&gt; {\n            //   try {\n            //     return JSON.parse(record?.attentionTo &amp;&amp; record?.attentionTo)\n            //       ?.map((x) =&gt; x.AttentionTo)\n            //       ?.join(\", \");\n            //   } catch (error) {\n            //     console.error(\"Error parsing JSON:\", error);\n            //   }\n\n            try {\n                const rawAttentionTo = record?.attentionTo;\n\n                if (typeof rawAttentionTo === 'string' &amp;&amp;\n                    rawAttentionTo.trim().startsWith('[') &amp;&amp;\n                    rawAttentionTo.trim().endsWith(']')) {\n\n                    const attentionToArray = JSON.parse(rawAttentionTo);\n\n                    if (Array.isArray(attentionToArray) &amp;&amp; attentionToArray.length &gt; 0) {\n                        return attentionToArray.map((x) =&gt; x.AttentionTo).join(\", \");\n                    }\n                }\n\n                return \"\";\n            } catch (error) {\n                console.error(\"Error parsing JSON:\", error);\n                return \"\";\n            }\n        }\n    }\n]\n\n&lt;Table dataSource={companyDtosData} columns={columns} loading={getCircularPlanningCompanyDtosLoading} /&gt;\n</code></pre> Success <pre><code>// UPDATED\nconst handleMenuClick = (id, title) =&gt; {\n    setSelectedMenuItem(id);\n    setSelectedMenuItemTitle(title)\n    if(!isEmpty(id))\n        dispatch(actionForGetCircularPlanningCompanyDtos(id))\n};\n\n// added\nconst utilFunc = (data) =&gt; {\n    if (!data) return [];\n\n    return data.map((item, index) =&gt; {\n        let parsedAttentionTo = [];\n        try {\n            if (typeof item.attentionTo === 'string') {\n                parsedAttentionTo = JSON.parse(item.attentionTo);\n            }\n        } catch (error) {\n            console.error(`Error parsing attentionTo for item at index ${index}:`, error);\n        }\n\n        return {\n            ...item,\n            attentionTo: parsedAttentionTo // Ensure the key matches your data structure\n        };\n    });\n};\n\n// updated\nuseEffect(() =&gt; {\n    if (getCircularPlanningCompanyDtosResp) {\n        console.log('Original Response: ', getCircularPlanningCompanyDtosResp);\n\n        // Call utilFunc to parse attentionTo and update state\n        const parsedData = utilFunc(getCircularPlanningCompanyDtosResp);\n        console.log('Parsed Data: ', parsedData);\n        setCompanyDtosData(parsedData);\n    }\n}, [getCircularPlanningCompanyDtosResp]);\n\n\n...\n&lt;Menu\n    // REMOVED\n    // onClick={handleMenuClick}\n    style={{ width: 256 }}\n    defaultSelectedKeys={['0']}\n    defaultOpenKeys={['sub1']}\n    mode=\"inline\"\n&gt;\n    {allCircularPlanningTemplateLoading ? &lt;Skeleton active /&gt; : templateData.map((item, index) =&gt; (\n        &lt;Menu.Item\n            key={item?.id}\n            value={item?.title}\n            // className=\"sidebars__menu--item\"\n            // ADDED\n            onClick={() =&gt; handleMenuClick(item?.id, item?.title)}\n            className={`sidebars__menu--item ${index % 2 === 0 ? 'even-row' : 'odd-row'}`}\n        &gt;\n            &lt;span&gt;{index + 1}. {item.title}&lt;/span&gt;\n        &lt;/Menu.Item&gt;\n    ))}\n&lt;/Menu&gt;\n</code></pre>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#reference","title":"Reference","text":"<ul> <li>circular-json: deprecated</li> <li>flatted: sucessor of circular-json</li> </ul>","tags":["js"]},{"location":"blog/2024/05/12/handling-json-parsing-errors-in-javascript-a-practical-approach/","title":"Handling JSON Parsing Errors in JavaScript: A Practical Approach","text":"","tags":["react","js"]},{"location":"blog/2024/05/12/handling-json-parsing-errors-in-javascript-a-practical-approach/#handling-json-parsing-errors-in-javascript-a-practical-approach","title":"Handling JSON Parsing Errors in JavaScript: A Practical Approach","text":"<p>Parsing JSON strings in JavaScript can sometimes lead to unexpected errors, especially when dealing with data from various sources. One common error encountered is \"Unexpected token 's', 'string' is not valid JSON,\" indicating an issue with the input string. In this blog, we'll explore a practical approach to handle such errors effectively.</p>","tags":["react","js"]},{"location":"blog/2024/05/12/handling-json-parsing-errors-in-javascript-a-practical-approach/#understanding-the-problem","title":"Understanding the Problem","text":"<p>The error typically occurs when the input string is not a valid JSON format. For instance, when the input string is plain text or improperly formatted JSON, attempting to parse it will result in a syntax error. To address this, we need to ensure the input is a valid JSON string before parsing it.</p> <p>Bug</p> TypeError: cyclic object value in ReactTypeError: o is undefined <p>Error parsing JSON: SyntaxError: Unexpected token 's', \"string\" is not valid JSON</p> <ul> <li>Error \"Uncaught SyntaxError: Unexpected token with JSON.parse\"</li> <li>How to Fix SyntaxError: Unexpected token &lt; in JSON at position 0</li> <li>JavaScript TypeError \u2013 Cyclic object value</li> <li>TypeError: cyclic object value in React</li> </ul> <ul> <li>TypeError: Cannot read property '0' of undefined in react</li> </ul>","tags":["react","js"]},{"location":"blog/2024/05/12/handling-json-parsing-errors-in-javascript-a-practical-approach/#the-solution","title":"The Solution","text":"<p>To handle this issue, we can follow a structured approach:</p> <ol> <li> <p>Log the Raw Input:</p> <p>Inspect the raw input to understand its content.</p> </li> <li> <p>Check for Valid JSON:</p> <p>Ensure the input is a valid JSON string.</p> </li> <li> <p>Parse Safely:</p> <p>Parse the JSON string and handle any errors gracefully.</p> </li> </ol> <p>Example</p> explainclean code <pre><code>render: (record) =&gt; {\n    console.log(\"Record: \", record);\n\n    try {\n        const rawAttentionTo = record?.attentionTo;\n        console.log(\"Raw attentionTo: \", rawAttentionTo);\n\n        // Check if rawAttentionTo is a valid JSON string\n        if (typeof rawAttentionTo === 'string' &amp;&amp; \n            rawAttentionTo.trim().startsWith('[') &amp;&amp; \n            rawAttentionTo.trim().endsWith(']')) {\n\n            const attentionToArray = JSON.parse(rawAttentionTo);\n            console.log(\"Parsed Array: \", attentionToArray);\n\n            // Ensure the parsed value is an array and contains data\n            if (Array.isArray(attentionToArray) &amp;&amp; attentionToArray.length &gt; 0) {\n                return attentionToArray.map((x) =&gt; x.AttentionTo).join(\", \");\n            }\n        }\n\n        // Return a fallback value if attentionToArray is empty or not an array\n        return \"\";\n    } catch (error) {\n        console.error(\"Error parsing JSON:\", error);\n        return \"\"; // Return an empty string or a fallback value in case of error\n    }\n}\n</code></pre> <pre><code>render: (record) =&gt; {\n    try {\n        const rawAttentionTo = record?.attentionTo;\n\n        if (typeof rawAttentionTo === 'string' &amp;&amp; \n            rawAttentionTo.trim().startsWith('[') &amp;&amp; \n            rawAttentionTo.trim().endsWith(']')) {\n\n            const attentionToArray = JSON.parse(rawAttentionTo);\n\n            if (Array.isArray(attentionToArray) &amp;&amp; attentionToArray.length &gt; 0) {\n                return attentionToArray.map((x) =&gt; x.AttentionTo).join(\", \");\n            }\n        }\n\n        return \"\";\n    } catch (error) {\n        console.error(\"Error parsing JSON:\", error);\n        return \"\";\n    }\n}\n</code></pre>","tags":["react","js"]},{"location":"blog/2024/05/12/handling-json-parsing-errors-in-javascript-a-practical-approach/#why-this-approach-works","title":"Why This Approach Works","text":"<p>This approach works by ensuring that only valid JSON strings are parsed, preventing unexpected errors. By validating the input and handling errors gracefully, we ensure the application remains robust and user-friendly.</p>","tags":["react","js"]},{"location":"blog/2024/05/12/handling-json-parsing-errors-in-javascript-a-practical-approach/#conclusion","title":"Conclusion","text":"<p>Handling JSON parsing errors in JavaScript requires careful validation and error handling. By following the steps outlined above, you can effectively manage and debug JSON parsing issues, ensuring a smoother user experience. Whether you're dealing with data from APIs or other sources, this approach helps maintain the integrity and reliability of your application.</p>","tags":["react","js"]},{"location":"blog/2024/05/26/handling-multiple-api-calls-with-search-input-in-react-using-debouncing-and-axios/","title":"Handling Multiple API Calls with Search Input in React using Debouncing and Axios","text":"","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/26/handling-multiple-api-calls-with-search-input-in-react-using-debouncing-and-axios/#handling-multiple-api-calls-with-search-input-in-react-using-debouncing-and-axios","title":"Handling Multiple API Calls with Search Input in React using Debouncing and Axios","text":"<p>Handling multiple API calls in React when interacting with a search input requires careful management to ensure that the results are fetched in an efficient and user-friendly way. Several techniques and tools are available to manage multiple simultaneous API calls and handle issues like race conditions, debouncing, and performance optimization.</p> <p>Here are the techniques and tools you can use:</p>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/26/handling-multiple-api-calls-with-search-input-in-react-using-debouncing-and-axios/#1-debouncing","title":"1.  Debouncing","text":"<p>Debouncing is crucial to avoid making an API request on every keystroke in the search input. Instead, wait until the user has stopped typing for a short period (e.g., 300ms).</p> <p>Example:</p> <pre><code>import { useState, useEffect } from 'react';\nimport debounce from 'lodash.debounce';\n\nconst SearchComponent = () =&gt; {\n  const [query, setQuery] = useState('');\n  const [results, setResults] = useState([]);\n\n  const handleSearch = debounce(async (searchTerm) =&gt; {\n    if (searchTerm) {\n      const response1 = fetch(`https://api.example.com/search1?q=${searchTerm}`);\n      const response2 = fetch(`https://api.example.com/search2?q=${searchTerm}`);\n\n      const [result1, result2] = await Promise.all([response1, response2]);\n      const data1 = await result1.json();\n      const data2 = await result2.json();\n\n      // Combine results or handle them separately\n      setResults([...data1, ...data2]);\n    }\n  }, 300);\n\n  useEffect(() =&gt; {\n    handleSearch(query);\n  }, [query]);\n\n  return (\n    &lt;input \n      type=\"text\" \n      value={query} \n      onChange={(e) =&gt; setQuery(e.target.value)} \n      placeholder=\"Search...\"\n    /&gt;\n  );\n};\n</code></pre> <ul> <li>Tools: You can use libraries like <code>lodash.debounce</code> to debounce the search function.</li> <li>Why: This reduces unnecessary API calls and improves performance.</li> </ul>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/26/handling-multiple-api-calls-with-search-input-in-react-using-debouncing-and-axios/#2-cancelling-previous-requests-using-abortcontroller","title":"2.  Cancelling Previous Requests (Using AbortController)","text":"<p>When making multiple API calls, you should cancel the previous request if a new one is initiated, especially in scenarios like search inputs. This avoids race conditions where a slower previous call might overwrite a more recent one.</p> <pre><code>import { useState, useEffect } from 'react';\n\nconst SearchComponent = () =&gt; {\n  const [query, setQuery] = useState('');\n  const [results, setResults] = useState([]);\n\n  useEffect(() =&gt; {\n    const controller = new AbortController();\n    const signal = controller.signal;\n\n    const fetchData = async () =&gt; {\n      try {\n        const response1 = fetch(`https://api.example.com/search1?q=${query}`, { signal });\n        const response2 = fetch(`https://api.example.com/search2?q=${query}`, { signal });\n      }\n    }\n  })\n}\n</code></pre>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/26/handling-multiple-api-calls-with-search-input-in-react-using-debouncing-and-axios/#key-tools-and-techniques","title":"Key Tools and Techniques:","text":"<ul> <li>AbortController: For canceling ongoing API requests when a new request is made.</li> <li>Axios: To handle the HTTP requests with cancellation support.</li> <li>Lodash Debounce: To optimize API calls during search input.</li> <li>Promise.all: To handle multiple concurrent API calls.</li> </ul>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/13/history-api/","title":"History API","text":"","tags":["react","js"]},{"location":"blog/2024/05/13/history-api/#history-api","title":"History API","text":"<p>The History API in JavaScript provides methods to manipulate the browser's history stack programmatically. This allows developers to navigate back and forth between different states of the application without reloading the page. This API is particularly useful in single-page applications (SPAs) and web applications that dynamically load content without full page refreshes.</p> <p>The History interface of the History API allows manipulation of the browser session history, that is the pages visited in the tab or frame that the current page is loaded in.</p>","tags":["react","js"]},{"location":"blog/2024/05/13/history-api/#importance-of-history-api","title":"Importance of History API:","text":"<ul> <li> <p>Enhanced User Experience: Allows smoother navigation within an application without reloading the entire page, which can improve perceived performance and user experience.</p> </li> <li> <p>State Management: Enables saving and managing application state in the browser history, making it possible to bookmark or share specific states of the application.</p> </li> <li> <p>SEO Benefits: Helps in building SPAs that can still have SEO-friendly URLs and states, as the application can update the URL without reloading the page.</p> </li> </ul>","tags":["react","js"]},{"location":"blog/2024/05/13/history-api/#when-to-use-the-history-api","title":"When to Use the History API:","text":"<ul> <li> <p>Single-Page Applications (SPAs): When building applications where page transitions and state changes occur without full page reloads.</p> </li> <li> <p>Enhancing Navigation: When you want to enable back and forward navigation within your application's states or pages.</p> </li> <li> <p>Managing Application State: When you need to manage and update the browser URL to reflect different states or sections of your application.</p> </li> </ul> <p>Tip</p> Instance propertiesInstance methods <ul> <li>length</li> <li>scrollRestoration</li> <li>state</li> </ul> <ul> <li>back()</li> <li>forward()</li> <li>go()</li> <li>pushState()</li> <li>replaceState()</li> </ul> <p>Example</p> <pre><code>// Adding a new state to the history\nhistory.pushState({ page: 'home' }, \"Home\", \"/\");\n\n// Handling popstate event to detect back/forward navigation\nwindow.onpopstate = function(event) {\nconsole.log('Navigated to state:', event.state);\n// Code to update UI based on the state object\n};\n</code></pre> <p>In this simple example:</p> <ul> <li>history.pushState() adds a new state to the history stack with the specified state object <code>({ page: 'home' })</code>, a title (\"Home\"), and URL (\"/\").</li> <li>window.onpopstate listens for back/forward navigation events (popstate), allowing you to handle these events and update your UI accordingly.</li> </ul>","tags":["react","js"]},{"location":"blog/2024/05/13/history-api/#reference","title":"Reference","text":"<ul> <li>History: mozilla</li> <li>Working_with_the_History_API: mozzila</li> <li>api-reference history :github</li> </ul>","tags":["react","js"]},{"location":"blog/2024/08/06/how-many-concurrent-requests-can-a-web-browser-handle/","title":"How Many Concurrent Requests Can a Web Browser Handle?","text":"","tags":["antd","react"]},{"location":"blog/2024/08/06/how-many-concurrent-requests-can-a-web-browser-handle/#how-many-concurrent-requests-can-a-web-browser-handle","title":"How Many Concurrent Requests Can a Web Browser Handle?","text":"<p>The number of concurrent requests a web browser can handle depends on several factors including the browser type, version, and whether <code>HTTP/1.1</code> or <code>HTTP/2</code> is being used. </p> <p>Here's a general overview:</p> <ol> <li> <p>HTTP/1.1:</p> <ul> <li>Standard Limit: Most browsers traditionally limit the number of concurrent connections per domain to around 6. This limit is set to prevent overwhelming the server and to manage resources efficiently.</li> </ul> </li> <li> <p>HTTP/2:</p> <ul> <li>Improved Handling: HTTP/2 allows multiplexing, meaning multiple requests and responses can be sent over a single connection simultaneously. This significantly improves performance and reduces the need for multiple connections.</li> <li> <p>Connection Limit: With HTTP/2, browsers are more efficient in handling many concurrent requests as it uses a single connection to manage multiple streams.</p> </li> <li> <p>HTTP/3:</p> </li> <li> <p>Further Improvements: HTTP/3, which is based on QUIC (Quick UDP Internet Connections), offers even better performance and handles multiple requests efficiently over a single connection with reduced latency and improved speed.</p> </li> </ul> </li> </ol>","tags":["antd","react"]},{"location":"blog/2024/08/06/how-many-concurrent-requests-can-a-web-browser-handle/#standard-approach-for-managing-requests","title":"Standard Approach for Managing Requests:","text":"<ol> <li> <p>Throttle Requests:</p> <ul> <li>Purpose: To prevent overwhelming the browser or server with too many requests at once.</li> <li>How: Implement request throttling techniques where you control the rate of outgoing requests. This can be done using libraries or custom logic in your code.</li> </ul> </li> <li> <p>Use of HTTP/2 or HTTP/3:</p> <ul> <li>Purpose: To improve performance by allowing multiple requests over a single connection.</li> <li>How: Ensure your server supports HTTP/2 or HTTP/3 and that your application benefits from the multiplexing and efficiency provided by these protocols.</li> </ul> </li> <li> <p>Batch Requests:</p> <ul> <li>Purpose: To reduce the number of individual network requests by combining multiple requests into a single batch.</li> <li>How: Use techniques such as GraphQL to fetch multiple pieces of data in a single request or combine related REST API calls into a single request if supported by the API.</li> </ul> </li> <li> <p>Debounce and Throttle API Calls:</p> <ul> <li>Purpose: To avoid making excessive requests, especially in scenarios where users trigger requests rapidly (e.g., search suggestions).</li> <li>How: Implement debouncing (waiting a short time after the last user action before making a request) and throttling (limiting the number of requests over a certain period).</li> </ul> </li> <li> <p>Use Caching:</p> <ul> <li>Purpose: To reduce the number of requests sent to the server and improve performance by reusing previously fetched data.</li> <li>How: Implement client-side caching mechanisms, such as <code>Cache-Control</code> headers and local storage, to store and reuse data.</li> </ul> </li> <li> <p>Monitor and Optimize:</p> <ul> <li>Purpose: To ensure that your application remains performant and within the limits of browser capabilities.</li> <li>How: Use tools like browser developer tools, performance monitoring, and analytics to track and optimize the number of requests and their impact on performance.</li> </ul> </li> </ol>","tags":["antd","react"]},{"location":"blog/2024/08/06/how-many-concurrent-requests-can-a-web-browser-handle/#practical-example","title":"Practical Example:","text":"<p>If you have multiple independent API calls, you might handle them in parallel to optimize performance. Here\u2019s a simple example using <code>Promise.all</code> with <code>async/await</code>:</p> ExampleExplanation <pre><code>async function fetchMultipleData() {\n    try {\n        // Use Promise.all to handle multiple requests in parallel\n        const [response1, response2, response3] = await Promise.all([\n            fetch('https://api.example.com/data1'),\n            fetch('https://api.example.com/data2'),\n            fetch('https://api.example.com/data3')\n        ]);\n\n        // Convert responses to JSON\n        const data1 = await response1.json();\n        const data2 = await response2.json();\n        const data3 = await response3.json();\n\n        console.log('Data1:', data1);\n        console.log('Data2:', data2);\n        console.log('Data3:', data3);\n    } catch (error) {\n        console.error('Error:', error);\n    }\n}\n\nfetchMultipleData();\n</code></pre> <ul> <li>Parallel Requests: <code>Promise.all</code> runs all the fetch requests in parallel, efficiently handling multiple requests.</li> <li>Error Handling: Any errors in any of the requests are caught in the <code>catch</code> block.</li> </ul>","tags":["antd","react"]},{"location":"blog/2024/08/06/how-many-concurrent-requests-can-a-web-browser-handle/#summary","title":"Summary","text":"<ul> <li>Browser Limits: Browsers handle around 6 concurrent connections per domain with HTTP/1.1 and can handle many more with HTTP/2 and HTTP/3 due to multiplexing.</li> <li>Standard Approach: Use HTTP/2 or HTTP/3, implement request throttling and debouncing, batch requests, use caching, and monitor performance for optimal handling of requests.</li> </ul> <p>By following these practices, you can effectively manage concurrent requests and optimize the performance of your web applications.</p>","tags":["antd","react"]},{"location":"blog/2024/06/01/optimizing-javascript-object-manipulation-with-destructuring/","title":"Optimizing JavaScript Object Manipulation with Destructuring","text":"","tags":["Personal"]},{"location":"blog/2024/06/01/optimizing-javascript-object-manipulation-with-destructuring/#optimizing-javascript-object-manipulation-with-destructuring","title":"Optimizing JavaScript Object Manipulation with Destructuring","text":"<p>When working with objects in JavaScript, we often need to create a new object by including certain properties while omitting others. A common approach is to use the spread operator to copy the properties and then manually delete the unwanted ones. </p> <p>However, this can be optimized using destructuring.</p>","tags":["Personal"]},{"location":"blog/2024/06/01/optimizing-javascript-object-manipulation-with-destructuring/#the-problem","title":"The Problem","text":"<p>Here\u2019s a common pattern we often see when manipulating objects:</p> <pre><code>let apiPayload = {\n  ...updateApiData,\n  id: updateApiData?.referenceTemplateId,\n};\n\ndelete apiData?.referenceId;\ndelete apiData?.referenceTemplateId;\n</code></pre> <p>In this case, we\u2019re creating a new object (<code>apiPayload</code>) by copying all properties from <code>updateApiData</code> and then deleting two properties (<code>referenceId</code> and <code>referenceTemplateId</code>). While this works, it's not the most efficient way.</p>","tags":["Personal"]},{"location":"blog/2024/06/01/optimizing-javascript-object-manipulation-with-destructuring/#the-optimized-approach","title":"The Optimized Approach","text":"<p>Instead of creating an object and then using <code>delete</code> to remove properties, we can use object destructuring to omit properties we don't need and build the new object in one step:</p> <pre><code>let { referenceTemplateId, referenceId, ...rest } = updateApiData;\n\nlet apiPayload = {\n  ...rest,\n  id: referenceTemplateId\n};\n</code></pre>","tags":["Personal"]},{"location":"blog/2024/06/01/optimizing-javascript-object-manipulation-with-destructuring/#how-it-works","title":"How It Works:","text":"<ul> <li>Destructuring: In the first line, <code>referenceTemplateId</code> and <code>referenceId</code> are extracted from <code>updateApiData</code>, and <code>rest</code> contains the remaining properties.</li> <li>Spread Operator: The <code>rest</code> object is spread into the new <code>apiPayload</code>, and we explicitly set the <code>id</code> property to <code>referenceTemplateId</code>.</li> </ul>","tags":["Personal"]},{"location":"blog/2024/06/01/optimizing-javascript-object-manipulation-with-destructuring/#why-this-is-better","title":"Why This Is Better:","text":"<ul> <li>Cleaner Code: You avoid modifying the original object after its creation.</li> <li>More Efficient: Using destructuring is more declarative, making the intent of your code clearer.</li> <li>Immutable Approach: By avoiding <code>delete</code>, you\u2019re following a more functional approach to immutability, which is a best practice in many programming paradigms.</li> </ul>","tags":["Personal"]},{"location":"blog/2024/06/01/optimizing-javascript-object-manipulation-with-destructuring/#conclusion","title":"Conclusion","text":"<p>Destructuring is a powerful feature in JavaScript that allows us to write cleaner and more efficient code when manipulating objects. By using destructuring and the spread operator, we can optimize our code for readability and performance, making it more maintainable in the long run.</p>","tags":["Personal"]},{"location":"blog/2024/04/01/understanding-javascript-array-methods-mutating-vs-non-mutating/","title":"Understanding JavaScript Array Methods: Mutating vs. Non-Mutating","text":"","tags":["Programming"]},{"location":"blog/2024/04/01/understanding-javascript-array-methods-mutating-vs-non-mutating/#understanding-javascript-array-methods-mutating-vs-non-mutating","title":"Understanding JavaScript Array Methods: Mutating vs. Non-Mutating","text":"<p>When working with arrays in JavaScript, it's crucial to understand the distinction between mutating and non-mutating array methods. This differentiation plays a significant role in how arrays are manipulated and can greatly impact the behavior of your code.</p>","tags":["Programming"]},{"location":"blog/2024/04/01/understanding-javascript-array-methods-mutating-vs-non-mutating/#mutating-array-methods","title":"Mutating Array Methods:","text":"<p>Mutating array methods are those that modify the original array directly. They alter the array's contents in place, without creating a new array.</p> <p>Some commonly used mutating array methods include:</p> <ol> <li> <p><code>push()</code> and <code>pop()</code>: These methods add and remove elements from the end of the array, respectively.</p> </li> <li> <p><code>shift()</code> and <code>unshift()</code>: They add and remove elements from the beginning of the array, respectively.</p> </li> <li> <p><code>splice()</code>: This method can add, remove, or replace elements at any position within the array.</p> </li> <li> <p><code>sort()</code> and <code>reverse()</code>: These methods reorder the elements of the array.</p> </li> <li> <p><code>fill()</code> and <code>copyWithin()</code>: They modify elements within the array based on specified criteria.</p> </li> <li> <p><code>forEach()</code>: It iterates over each element of the array and allows you to perform actions on them.</p> </li> </ol>","tags":["Programming"]},{"location":"blog/2024/04/01/understanding-javascript-array-methods-mutating-vs-non-mutating/#non-mutating-array-methods","title":"Non-Mutating Array Methods:","text":"<p>Non-mutating array methods, on the other hand, do not modify the original array. Instead, they return a new array with the desired modifications, leaving the original array unchanged.</p> <p>Some common non-mutating array methods include:</p> <ol> <li> <p><code>concat()</code>:     This method combines two or more arrays and returns a new array.</p> </li> <li> <p><code>slice()</code>:     It returns a portion of the array without modifying the original array (returns a new array).</p> </li> <li> <p><code>filter()</code> and <code>map()</code>:     These methods create new arrays based on specific criteria or transformations applied to the original array's elements.</p> </li> <li> <p><code>reduce()</code> and <code>reduceRight()</code>:     They reduce the array to a single value based on a provided function.</p> </li> <li> <p><code>some()</code> and <code>every()</code>:     These methods check if certain conditions are met by at least one or all elements in the array, respectively.</p> </li> <li> <p><code>indexOf()</code> and <code>lastIndexOf()</code>:     They find the index of a specified element within the array.</p> </li> </ol> <p>Understanding the difference between <code>mutating</code> and <code>non-mutating</code> array methods is crucial for writing efficient and bug-free JavaScript code. Choosing the appropriate method based on your requirements can lead to cleaner, more maintainable code and prevent unintended side effects.</p>","tags":["Programming"]},{"location":"blog/2024/04/01/understanding-javascript-array-methods-mutating-vs-non-mutating/#conclusion","title":"Conclusion","text":"<p>In summary, mutating array methods directly modify the original array, while non-mutating array methods return a new array without altering the original one. By leveraging these methods effectively, you can harness the full power of JavaScript arrays in your projects.</p>","tags":["Programming"]},{"location":"blog/2024/05/15/javascript-arrow-functions/","title":"JavaScript Arrow Functions","text":"","tags":["js","arrow"]},{"location":"blog/2024/05/15/javascript-arrow-functions/#javascript-arrow-functions","title":"JavaScript Arrow Functions","text":"<p>Modern JavaScript introduced arrow functions as alternatives to regular functions. \u00adThere are two concepts you need to know about arrow functions.</p> <p>First, they use a dif\u00adfer\u00adent syntax than regular functions. Defining an arrow function is much quicker, requiring just a few characters and one line of code. The second impor\u00adt ant, but not so obvious, change is that they use something called a lexical scope, making them more intuitive and less error prone.</p>","tags":["js","arrow"]},{"location":"blog/2024/05/15/javascript-arrow-functions/#writing-arrow-functions","title":"Writing Arrow Functions","text":"<p>Instead of using the function keyword to declare an arrow function, we use the equal-to and greater-\u00adthan signs to form an arrow (=&gt;). This syntax, also called the fat arrow, reduces noise and results in more compact code.</p> <p>Therefore, modern JavaScript prefers this syntax when passing functions as arguments.</p> <p>In addition, if an arrow function has only one \u00adparameter and one statement, we can omit the curly brackets and the return keyword. In this compact form, we call the function a concise body function. Listing 2-10 shows the definition of a traditional function followed by an arrow function.</p> <pre><code>const traditional = function (x) {\n    return x * x;\n}\nconst conciseBody = x =&gt; x * x;\n</code></pre> <p>Listing 2-10: A traditional function and an arrow function with the concise body syntax </p> <p>We first define a standard function with the function keyword and familiar return statement. Then we write the same functionality as an arrow function with the concise body syntax. Here we omit the curly brackets and use an implied return statement, without the return keyword.</p>","tags":["js","arrow"]},{"location":"blog/2024/05/15/javascript-arrow-functions/#reference","title":"Reference","text":"<ul> <li>The complete developer by Martin Krause : pg-20</li> </ul>","tags":["js","arrow"]},{"location":"blog/2024/05/20/js-objects/","title":"JS objects","text":"","tags":["js"]},{"location":"blog/2024/05/20/js-objects/#js-objects","title":"JS objects","text":"<p>In JavaScript, every object inherits properties and methods from its prototype. The base object from which all other objects derive, Object.prototype, includes several built-in methods and properties that are fundamental to working with objects. Here are some of the most commonly used ones:</p> Built-ins PropertiesMethodsPrototypal Methods <ul> <li> <p>constructor</p> <ul> <li>Refers to the function that created the instance's prototype.</li> <li>Example: <code>obj.constructor</code></li> </ul> </li> <li> <p>proto</p> <ul> <li>Refers to the prototype of the object.</li> <li>Example: <code>obj.__proto__</code></li> </ul> </li> </ul> <ol> <li> <p>hasOwnProperty()</p> <ul> <li>Determines if an object has a property as its own (not inherited).</li> <li>Example: <code>obj.hasOwnProperty('propertyName')</code></li> </ul> </li> <li> <p>isPrototypeOf()</p> <ul> <li>Checks if an object exists in another object's prototype chain.</li> <li>Example: <code>prototypeObject.isPrototypeOf(obj)</code></li> </ul> </li> <li> <p>propertyIsEnumerable()</p> <ul> <li>Checks if a property is enumerable.</li> <li>Example: <code>obj.propertyIsEnumerable('propertyName')</code></li> </ul> </li> <li> <p>toString()</p> <ul> <li>Returns a string representation of the object.</li> <li>Example: <code>obj.toString()</code></li> </ul> </li> <li> <p>valueOf()</p> <ul> <li>Returns the primitive value of the specified object.</li> <li>Example: <code>obj.valueOf()</code></li> </ul> </li> <li> <p>toLocaleString()</p> <ul> <li>Returns a string representation of the object, localized according to the locale settings.</li> <li>Example: <code>obj.toLocaleString()</code></li> </ul> </li> </ol> <p>Static Methods</p> <ol> <li> <p>defineProperty() (added in ES5)</p> <ul> <li>Defines a new property directly on an object, or modifies an existing property on an object, and returns the object.</li> <li>Example: <code>Object.defineProperty(obj, 'newProp', { value: 42 })</code></li> </ul> </li> <li> <p>defineProperties() (added in ES5)</p> <ul> <li>Defines new or modifies existing properties directly on an object, returning the object.</li> <li>Example: <code>Object.defineProperties(obj, { 'prop1': { value: 42 }, 'prop2': { value: 43 } })</code></li> </ul> </li> <li> <p>getOwnPropertyDescriptor() (added in ES5)</p> <ul> <li>Returns a property descriptor for a named property on an object.</li> <li>Example: <code>Object.getOwnPropertyDescriptor(obj, 'propertyName')</code></li> </ul> </li> <li> <p>getOwnPropertyNames() (added in ES5)</p> <ul> <li>Returns an array of all properties (enumerable or not) found directly upon a given object.</li> <li>Example: <code>Object.getOwnPropertyNames(obj)</code></li> </ul> </li> <li> <p>keys() (added in ES5)</p> <ul> <li>Returns an array of a given object's own enumerable property names.</li> <li>Example: <code>Object.keys(obj)</code></li> </ul> </li> <li> <p>entries() (added in ES8)</p> <ul> <li>Returns an array of a given object's own enumerable string-keyed property [key, value] pairs.</li> <li>Example: <code>Object.entries(obj)</code></li> </ul> </li> <li> <p>values() (added in ES8)</p> <ul> <li>Returns an array of a given object's own enumerable property values.</li> <li>Example: <code>Object.values(obj)</code></li> </ul> </li> <li> <p>fromEntries() (added in ES10)</p> <ul> <li>Transforms a list of key-value pairs into an object.</li> <li>Example: <code>Object.fromEntries([['key1', 'value1'], ['key2', 'value2']])</code></li> </ul> </li> </ol> <p>JavaScript objects can also inherit methods from their prototypes. For example, arrays inherit methods from Array.prototype, strings from String.prototype, etc.</p> <p>Here's an example with arrays:</p> <ol> <li> <p>push()</p> <ul> <li>Adds one or more elements to the end of an array and returns the new length of the array.</li> <li>Example: <code>arr.push(element)</code></li> </ul> </li> <li> <p>pop()</p> <ul> <li>Removes the last element from an array and returns that element.</li> <li>Example: <code>arr.pop()</code></li> </ul> </li> <li> <p>map()</p> <ul> <li>Creates a new array populated with the results of calling a provided function on every element in the calling array.</li> <li>Example: <code>arr.map(function(element) { return element * 2; })</code></li> </ul> </li> </ol> <p>These are some of the core <code>methods</code> and <code>properties</code> that are built into JavaScript objects. The language also provides a robust set of methods and properties for specialized objects like <code>arrays</code>, <code>strings</code>, and <code>functions</code>.</p>","tags":["js"]},{"location":"blog/2024/05/20/js-objects/#prototype-constructor-methods","title":"Prototype &amp; Constructor Methods","text":"","tags":["js"]},{"location":"blog/2024/05/20/js-objects/#prototype-methods","title":"Prototype Methods","text":"<p>Prototype methods are defined on the constructor's prototype. All instances of the object share the same method.</p> <pre><code>function Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\n// Shared method (prototype method)\nPerson.prototype.sayHello = function() {\n  console.log('Hello, my name is ' + this.name);\n};\n\nlet person1 = new Person('Alice', 25);\nlet person2 = new Person('Bob', 30);\n\nperson1.sayHello(); // \"Hello, my name is Alice\"\nperson2.sayHello(); // \"Hello, my name is Bob\"\n\n// Both instances share the same sayHello method\nconsole.log(person1.sayHello === person2.sayHello); // true\n</code></pre> <p>In this example, <code>sayHello</code> is a prototype method, meaning <code>person1</code> and <code>person2</code> share the same <code>sayHello</code> method.</p>","tags":["js"]},{"location":"blog/2024/05/20/js-objects/#instance-specific-constructor-methods","title":"Instance-Specific (Constructor) Methods","text":"<p>Instance-specific methods are defined inside the constructor function. Each instance of the object will have its own copy of these methods.</p> <pre><code>function Person(name, age) {\n  this.name = name;\n  this.age = age;\n\n  // Instance-specific method (constructor method)\n  this.describe = function() {\n    console.log(this.name + ' is ' + this.age + ' years old.');\n  };\n}\n\nlet person1 = new Person('Alice', 25);\nlet person2 = new Person('Bob', 30);\n\nperson1.describe(); // \"Alice is 25 years old.\"\nperson2.describe(); // \"Bob is 30 years old.\"\n\n// Each instance has its own copy of describe\nconsole.log(person1.describe === person2.describe); // false\n</code></pre> <p>In this example, <code>describe</code> is a constructor method, meaning <code>person1</code> and <code>person2</code> each have their own copy of the describe method.</p>","tags":["js"]},{"location":"blog/2024/05/20/js-objects/#key-differences","title":"Key Differences","text":"<ul> <li> <p>Memory Efficiency:</p> <ul> <li>Constructor Methods: Each instance gets its own copy of the method, which can consume more memory.</li> <li>Prototype Methods: All instances share the same method, which is more memory-efficient.</li> </ul> </li> <li> <p>Usage:</p> <ul> <li>Constructor Methods: Use when each instance needs its own unique version of the method, often because the method relies on instance-specific data or state.</li> <li>Prototype Methods: Use when the method's behavior should be the same across all instances, to save memory and maintain consistency.</li> </ul> </li> </ul> Example <pre><code>function Person(name, age) {\n    this.name = name;\n    this.age = age;\n\n    // Instance-specific method (constructor method)\n    this.describe = function() {\n        console.log(this.name + ' is ' + this.age + ' years old.');\n    };\n}\n\n// Shared method (prototype method)\nPerson.prototype.sayHello = function() {\n    console.log('Hello, my name is ' + this.name);\n};\n\nlet person1 = new Person('Alice', 25);\nlet person2 = new Person('Bob', 30);\n\nperson1.describe(); // \"Alice is 25 years old.\"\nperson2.describe(); // \"Bob is 30 years old.\"\n\nperson1.sayHello(); // \"Hello, my name is Alice\"\nperson2.sayHello(); // \"Hello, my name is Bob\"\n\n// Each instance has its own copy of describe\nconsole.log(person1.describe === person2.describe); // false\n\n// Both instances share the same sayHello method\nconsole.log(person1.sayHello === person2.sayHello); // true\n</code></pre> <p>In this example:</p> <ul> <li><code>describe</code> is a constructor method, so each instance (<code>person1</code> and <code>person2</code>) has its own copy.</li> <li><code>sayHello</code> is a prototype method, so <code>person1</code> and <code>person2</code> share the same method.</li> </ul>","tags":["js"]},{"location":"blog/2024/05/20/js-objects/#terminology","title":"Terminology","text":"<p>Static methods and constructor methods are not the same in JavaScript. Let's delve into their differences with clear examples.</p>","tags":["js"]},{"location":"blog/2024/05/20/js-objects/#static-methods","title":"Static Methods","text":"<p>Static methods are methods defined on the constructor function itself. They are not available on instances of the constructor. Static methods are called directly on the constructor.</p> <pre><code>class Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n\n  // Static method\n  static compareAge(person1, person2) {\n    return person1.age - person2.age;\n  }\n}\n\nconst alice = new Person('Alice', 25);\nconst bob = new Person('Bob', 30);\n\n// Calling the static method on the constructor\nconsole.log(Person.compareAge(alice, bob)); // -5\n\n// Static method is not available on instances\nconsole.log(alice.compareAge); // undefined\n</code></pre> <p>In this example, <code>compareAge</code> is a static method defined on the <code>Person</code> constructor. It is called directly on <code>Person</code> and not on the instances (<code>alice</code> and <code>bob</code>).</p>","tags":["js"]},{"location":"blog/2024/05/20/js-objects/#constructor-methods-instance-methods","title":"Constructor Methods (Instance Methods)","text":"<p>Constructor methods are methods defined inside the constructor function. Each instance of the object will have its own copy of these methods.</p> <p>Constructor methods are defined inside the constructor function using this. They are specific to each instance of the object and are accessed through instances of the constructor.</p> <pre><code>class Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n\n    // Constructor method (instance method)\n    this.describe = function() {\n      console.log(`${this.name} is ${this.age} years old.`);\n    };\n  }\n}\n\nconst alice = new Person('Alice', 25);\nconst bob = new Person('Bob', 30);\n\n// Calling the constructor method on instances\nalice.describe(); // \"Alice is 25 years old.\"\nbob.describe(); // \"Bob is 30 years old.\"\n\n// Each instance has its own copy of describe\nconsole.log(alice.describe === bob.describe); // false\n</code></pre> <p>In this example, <code>describe</code> is a constructor method. Each instance (<code>alice</code> and <code>bob</code>) has its own copy of the <code>describe</code> method.</p>","tags":["js"]},{"location":"blog/2024/05/20/js-objects/#summary-of-differences","title":"Summary of Differences","text":"<ol> <li> <p>Definition and Availability:</p> <ul> <li>Static Methods: Defined on the constructor function itself. Available on the constructor, not on instances.</li> <li>Constructor Methods: Defined inside the constructor function. Each instance gets its own copy of the method.</li> </ul> </li> <li> <p>Calling:</p> <ul> <li>Static Methods: Called on the constructor itself.</li> <li>Constructor Methods: Called on instances of the constructor.</li> </ul> </li> </ol> Example Combining Both <pre><code>class Person {\n    constructor(name, age) {\n        this.name = name;\n        this.age = age;\n\n        // Constructor method\n        this.describe = function() {\n        console.log(`${this.name} is ${this.age} years old.`);\n        };\n    }\n\n    // Static method\n    static compareAge(person1, person2) {\n        return person1.age - person2.age;\n    }\n}\n\nconst alice = new Person('Alice', 25);\nconst bob = new Person('Bob', 30);\n\n// Calling the constructor method on instances\nalice.describe(); // \"Alice is 25 years old.\"\nbob.describe(); // \"Bob is 30 years old.\"\n\n// Calling the static method on the constructor\nconsole.log(Person.compareAge(alice, bob)); // -5\n\n// Static method is not available on instances\nconsole.log(alice.compareAge); // undefined\n\n// Each instance has its own copy of describe\nconsole.log(alice.describe === bob.describe); // false\n</code></pre> <p>In this example:</p> <ul> <li><code>compareAge</code> is a static method and is called on the Person constructor.</li> <li><code>describe</code> is a constructor method and is called on instances of Person.</li> </ul> how to know or check if it is contructor methods or static methods in javascript? <p>In JavaScript, whether a method is a constructor method (instance method) or a static method depends on where it is defined and how it is accessed. Here\u2019s how you can identify and distinguish between them:</p> Constructor Methods (Instance Methods)Static Methods <p>Constructor methods are defined inside the constructor function using this. They are specific to each instance of the object and are accessed through instances of the constructor.</p> <pre><code>class Person {\n    constructor(name, age) {\n        this.name = name;\n        this.age = age;\n\n        // Constructor method (instance method)\n        this.describe = function() {\n        console.log(`${this.name} is ${this.age} years old.`);\n        };\n    }\n}\n\nconst alice = new Person('Alice', 25);\n\n// Check if describe is a constructor method\nconsole.log(alice.describe); // function\n\n// Verify it's not available on the constructor itself\nconsole.log(Person.describe); // undefined\n</code></pre> <p>Static methods are defined on the constructor function directly using the static keyword. They are called on the constructor function itself, not on instances of the constructor.</p> <pre><code>class Person {\n    constructor(name, age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    // Static method\n    static compareAge(person1, person2) {\n        return person1.age - person2.age;\n    }\n}\n\nconst alice = new Person('Alice', 25);\n\n// Check if compareAge is a static method\nconsole.log(Person.compareAge); // function\n\n// Verify it's not available on instances of the constructor\nconsole.log(alice.compareAge); // undefined\n</code></pre> How to Identify Them <ul> <li> <p>Location of Definition:</p> <ul> <li>Constructor Methods: Defined inside the constructor function using this.</li> <li>Static Methods: Defined outside the constructor, prefixed with the static keyword within the class.</li> </ul> </li> <li> <p>Access Method:</p> <ul> <li>Constructor Methods: Accessed through instances of the constructor (<code>instance.method()</code>).</li> <li>Static Methods: Accessed directly on the constructor function itself (<code>Constructor.method()</code>).</li> </ul> </li> <li> <p>Usage:</p> <ul> <li>Constructor Methods: Typically used when each instance needs its own copy of the method, often to operate on instance-specific data.</li> <li>Static Methods: Used when the method does not depend on instance-specific data and is more utility-like, applying broadly to the constructor itself or its class.</li> </ul> </li> </ul> Checking in Practice <p>To check if a method is a constructor method or a static method in JavaScript:</p> <ol> <li> <p>Look at where the method is defined:</p> <ul> <li>Inside the constructor function (<code>this.method = function() {...}</code>): It\u2019s a constructor method.</li> <li>Using static keyword (<code>static methodName() {...}</code>): It\u2019s a static method.</li> </ul> </li> <li> <p>Verify how the method is accessed:</p> <ul> <li>Through instances (<code>instance.method()</code>): It\u2019s likely a constructor method.</li> <li>On the constructor itself (<code>Constructor.method()</code>): It\u2019s likely a static method.</li> </ul> </li> </ol> <p>By understanding these distinctions, you can effectively identify and differentiate between constructor methods and static methods in JavaScript classes.</p>","tags":["js"]},{"location":"blog/2024/05/20/js-objects/#reference","title":"Reference","text":"<ul> <li>multipart requests</li> <li>What does enctype='multipart/form-data' mean?</li> <li></li> </ul>","tags":["js"]},{"location":"blog/2024/08/09/loglist/","title":"Loglist","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/08/09/loglist/#loglist","title":"Loglist","text":"Companies.jsapi.jsaction.jsreducer.jsComponent <pre><code>import LogList from \"./LogList\";\n\nconst Companies = ({\n    searchEmailTender,\n    rowEventhandlers,\n    companyId,\n    emailReferenceId,\n    getDetails,\n    selectedTenderRowId,\n    isCircular,\n    showProjectTab,\n    selectedBusinessTabPaneKey,\n    selectedCompanyAttentionToIds,\n}) =&gt; {\n    {\n        /* added */\n    }\n    const {\n        getCircularPlanningResp,\n        getCircularPlanningLoading,\n    } = useSelector((state) =&gt; state.reference);\n\n    const [activeKey, setActiveKey] = useState(\"1\");\n\n    const handleTabChange = (key) =&gt; {\n        setActiveKey(key);\n\n        if (key === \"4\") {\n        dispatch(actionForCircularPlanningLog());\n        }\n    };\n\n    useEffect(() =&gt; {\n        setActiveKey(\"1\");\n        setCompanyDetails();\n        setContactPerson();\n        setRemarksHistory();\n    }, [selectedTenderRowId]);\n\n    return (\n        &lt;&gt;\n        {/* ........ */}\n        &lt;Tabs\n            // defaultActiveKey=\"1\"\n            activeKey={activeKey}\n            type=\"line\"\n            className=\"circularplanning__tabs--contact\"\n            onChange={handleTabChange}\n        &gt;\n            &lt;TabPane tab=\"Contact Details\" key=\"1\"&gt;\n                {contactDetails()}\n            &lt;/TabPane&gt;\n            &lt;TabPane tab=\"Tender Checklist\" key=\"2\"&gt;\n            &lt;div className=\"person_info tender-checklist\"&gt;\n                &lt;div className=\"company_header\"&gt;\n                &lt;div\n                    className=\"referenceDetails__label\"\n                    style={{\n                        display: \"flex\",\n                        width: \"100%\",\n                        justifyContent: \"space-between\",\n                    }}\n                &gt;\n                    &lt;button className=\"referenceDetails--title header_print_btn\"&gt;\n                    Tender Checklist\n                    &lt;/button&gt;\n                    &lt;Button\n                        style={{ height: \"28px\", lineHeight: \"21px\" }}\n                        type=\"primary\"\n                        onClick={() =&gt; setModalVisible(true)}\n                    &gt;\n                    Circular Content\n                    &lt;/Button&gt;\n                &lt;/div&gt;\n                &lt;/div&gt;\n                &lt;CheckListContainer referenceId={getDetails?.referenceId} /&gt;\n            &lt;/div&gt;\n            &lt;/TabPane&gt;\n            &lt;TabPane tab=\"Log List\" key=\"4\"&gt;\n                {/* ADDED */}\n                {activeKey === \"4\" &amp;&amp; (\n                    &lt;LogList\n                        loading={getCircularPlanningLoading}\n                        data={getCircularPlanningResp}\n                    /&gt;\n                )}\n                &lt;LogList /&gt;\n            &lt;/TabPane&gt;\n        &lt;/Tabs&gt;;\n        &lt;/&gt;\n    );\n};\n</code></pre> <pre><code>import queryString from \"query-string\";\nimport { appBaseUrl, baseUrl, cqBaseUrl } from \"utils/config\";\nimport { getService, postService, putService } from \"../../commonServices\";\n\nexport class ReferencesService {\n    // loglist\n    getCircularPlanningLog(body) {\n        // let url = `${appBaseUrl}/referenceManagement/circularplanninglogsGetAllData`;\n        let url = `https://my-json-server.typicode.com/Bishow-Thapa/my-json-server/items`;\n        console.log(\"im callled\");\n        let data = getService(url, body);\n        return data;\n    }\n}\n</code></pre> <pre><code>// log\nexport const actionForCircularPlanningLog = (body) =&gt; {\n    console.log(\"Fetching log list...\"); // Debugging log\n    return async (dispatch) =&gt; {\n        dispatch(init(REFERENCE__TYPES.GET_CIRCULAR_PLANNING_LOG));\n        const response = await referencesService.getCircularPlanningLog(body);\n\n        if (response.isSuccess) {\n            dispatch(\n                success(REFERENCE__TYPES.GET_CIRCULAR_PLANNING_LOG, response.data)\n            );\n        } else if (!response.isSuccess) {\n            dispatch(error(response.errorMessage));\n        }\n        dispatch(finish(REFERENCE__TYPES.GET_CIRCULAR_PLANNING_LOG));\n    };\n};\n</code></pre> <pre><code>import { CALENDAR_EVENTS_TYPES, GLOBAL, REFERENCE__TYPES } from \"../../types\";\nimport { uniqBy } from \"lodash\";\n\nconst INITIAL_STATE = {\n    {/* ... */}\n    getCircularPlanningResp: [],\n    getCircularPlanningLoading: false,\n    {/* ... */}\n};\n\nexport default function referenceReducer(state = INITIAL_STATE, action) {\n    switch (action.type) {\n        // log\n        case REFERENCE__TYPES.GET_CIRCULAR_PLANNING_LOG_INIT:\n            return {\n                ...state,\n                getCircularPlanningResp: [],\n                getCircularPlanningLoading: true,\n            };\n\n        case REFERENCE__TYPES.GET_CIRCULAR_PLANNING_LOG_SUCCESS:\n            return {\n                ...state,\n                getCircularPlanningResp: action.payload,\n                getCircularPlanningLoading: false,\n            };\n\n        case REFERENCE__TYPES.GET_CIRCULAR_PLANNING_LOG_FINISH:\n            return {\n                ...state,\n                getCircularPlanningLoading: false,\n            };\n    }\n}\n</code></pre> LogList/index.js<pre><code>import React, { useEffect, useReducer } from \"react\";\nimport { Table } from \"antd\";\nimport moment from \"moment\";\n\nconst LogList = (props) =&gt; {\n    let { loading, data } = props;\n\n    const columns = [\n        {\n            title: \"S.N\",\n            dataIndex: \"key\",\n            render: (_, __, index) =&gt; index + 1,\n        },\n        {\n            title: \"Remarks\",\n            dataIndex: \"remarks\",\n            key: \"remarks\",\n        },\n        {\n            title: \"Creation Time\",\n            dataIndex: \"creationTime\",\n            key: \"creationTime\",\n            render: (text) =&gt; moment(text).format(\"YYYY-MM-DD\"),\n        },\n    ];\n\n    //   const dataSource =\n    //     data.map((log) =&gt; ({\n    //       key: log.id,\n    //       remarks: log.remarks,\n    //       creationTime: log.creationTime,\n    //     })) || [];\n    const dataSource = (data || []).map((log) =&gt; ({\n        key: log.id,\n        remarks: log.remarks,\n        creationTime: log.creationTime,\n    }));\n\n    return (\n        &lt;Table\n            dataSource={dataSource}\n            loading={loading}\n            columns={columns}\n            pagination={false}\n        /&gt;\n    );\n};\n\nexport default LogList;\n</code></pre>","tags":["Porgramming","React"]},{"location":"blog/2024/06/03/mastering-object-destructuring-rest-and-spread-operators-in-javascript/","title":"Mastering Object Destructuring, Rest, and Spread Operators in JavaScript","text":"","tags":["react"]},{"location":"blog/2024/06/03/mastering-object-destructuring-rest-and-spread-operators-in-javascript/#mastering-object-destructuring-rest-and-spread-operators-in-javascript","title":"Mastering <code>Object Destructuring</code>, <code>Rest</code>, and <code>Spread</code> Operators in JavaScript","text":"<p>JavaScript\u2019s modern syntax enhancements make working with objects and arrays cleaner and more intuitive. Among these features, object destructuring, the rest operator, and the spread operator stand out. Let\u2019s dive into each of these, understand their use cases, and learn how to wield them like a pro.</p>","tags":["react"]},{"location":"blog/2024/06/03/mastering-object-destructuring-rest-and-spread-operators-in-javascript/#overview","title":"Overview","text":"","tags":["react"]},{"location":"blog/2024/06/03/mastering-object-destructuring-rest-and-spread-operators-in-javascript/#object-destructuring","title":"Object Destructuring","text":"<p>Object destructuring allows you to extract values from objects and assign them to variables in a concise way. This not only makes your code cleaner but also helps in avoiding repetitive code.</p> ExampleWhen to UseWhen Not to Use <pre><code>const person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"Wonderland\"\n};\n\n// Traditional access\nconst name = person.name;\nconst age = person.age;\n\n// Destructuring\nconst { name, age } = person;\n\nconsole.log(name); // Alice\nconsole.log(age);  // 30\n</code></pre> <ul> <li>Extracting Multiple Properties: Use destructuring when you need to pull multiple properties from an object.</li> <li>Renaming Variables: When you need different variable names, destructuring allows you to rename properties during extraction.</li> <li>Providing Default Values: Destructuring lets you set default values for properties that may be undefined.</li> </ul> <ul> <li>If Not Extracting Multiple Properties: If you're only accessing one or two properties, the traditional way might be simpler.</li> <li>For Deeply Nested Properties: For deeply nested objects, destructuring can become cumbersome. Use it judiciously.</li> </ul>","tags":["react"]},{"location":"blog/2024/06/03/mastering-object-destructuring-rest-and-spread-operators-in-javascript/#rest-operator","title":"Rest Operator","text":"<p>The rest operator allows you to collect the remaining properties of an object (or elements of an array) into a new object (or array). It\u2019s perfect for scenarios where you need to handle some properties separately while keeping the rest.</p> ExampleWhen to UseWhen Not to Use <pre><code>const person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"Wonderland\",\n    profession: \"Engineer\"\n};\n\n// Destructuring with rest\nconst { name, ...rest } = person;\n\nconsole.log(name);   // Alice\nconsole.log(rest);   // { age: 30, city: 'Wonderland', profession: 'Engineer' }\n</code></pre> <ul> <li>Separating Properties: When you want to isolate specific properties and work with the rest.</li> <li>Managing Dynamic Data: For scenarios where the number of properties can change and you want to handle them flexibly.</li> </ul> <ul> <li>If You Need All Properties: If you need to work with all properties, the rest operator might add unnecessary complexity.</li> </ul>","tags":["react"]},{"location":"blog/2024/06/03/mastering-object-destructuring-rest-and-spread-operators-in-javascript/#spread-operator","title":"Spread Operator","text":"<p>The spread operator allows you to create a new object or array by copying properties or elements from an existing one. It\u2019s ideal for merging objects, cloning, or adding new elements.</p> ExampleWhen to UseWhen Not to Use <pre><code>const person = {\n    name: \"Alice\",\n    age: 30\n};\n\n// Cloning and extending an object\nconst updatedPerson = {\n    ...person,\n    city: \"Wonderland\"\n};\n\nconsole.log(updatedPerson);\n// { name: 'Alice', age: 30, city: 'Wonderland' }\n</code></pre> <ul> <li>Merging Objects or Arrays: When you need to combine objects or arrays without mutating the originals.</li> <li>Cloning: To create a shallow copy of an object or array, ensuring immutability.</li> <li>Adding or Modifying Elements: When you want to add new properties or elements while retaining the existing ones.</li> </ul> <ul> <li>Deep Cloning Needed: The spread operator only performs a shallow copy. For deep cloning, consider other methods.</li> <li>Performance Concerns: For very large objects or arrays, spreading might impact performance, so be mindful of its use in performance-critical code.</li> </ul>","tags":["react"]},{"location":"blog/2024/06/03/mastering-object-destructuring-rest-and-spread-operators-in-javascript/#conclusion","title":"Conclusion","text":"<p>Mastering these three features will make you a more efficient and expressive JavaScript developer. Use object destructuring for cleaner code and variable extraction, the rest operator to handle remaining data, and the spread operator to combine and clone objects and arrays effortlessly. With practice, these tools will become second nature, helping you write cleaner, more maintainable code.</p>","tags":["react"]},{"location":"blog/2024/08/08/principle-of-least-privilege-polp/","title":"Principle of Least Privilege (PoLP)","text":"","tags":["Programming","React"]},{"location":"blog/2024/08/08/principle-of-least-privilege-polp/#principle-of-least-privilege-polp","title":"Principle of Least Privilege (PoLP)","text":"<p>The Principle of Least Privilege (PoLP) is a security concept that dictates that any user, program, or system should have the minimum level of access\u2014or privileges\u2014necessary to perform its tasks. This principle helps minimize the potential damage in the event of a security breach or misuse.</p>","tags":["Programming","React"]},{"location":"blog/2024/08/08/principle-of-least-privilege-polp/#in-the-context-of-tokens","title":"In the Context of Tokens:","text":"<ol> <li> <p>Limited Scope:</p> <ul> <li>Access Control: When issuing tokens (like access tokens), restrict their permissions to only what is necessary for the specific action or resource. For example, if a user only needs to read data from an API, the token should not grant permission to modify or delete that data.</li> <li>Granular Permissions: Use scopes to define what actions can be performed with the token. For instance, in an OAuth system, you might have different scopes for read and write access.</li> </ul> </li> <li> <p>Temporary Access:</p> <ul> <li>Short-Lived Tokens: Use short-lived access tokens that expire quickly. This limits the window of opportunity for an attacker if a token is compromised.</li> <li>Refresh Tokens: Use longer-lived refresh tokens to obtain new access tokens as needed, rather than extending the lifetime of access tokens.</li> </ul> </li> <li> <p>Role-Based Access Control (RBAC):</p> <ul> <li>Role Definition: Define roles within your application and grant permissions based on those roles. For example, a regular user might have different permissions than an admin user.</li> <li>Fine-Tuning Access: Adjust the permissions associated with roles to ensure they align with the principle of least privilege.</li> </ul> </li> </ol>","tags":["Programming","React"]},{"location":"blog/2024/08/08/principle-of-least-privilege-polp/#benefits-of-applying-polp","title":"Benefits of Applying PoLP:","text":"<ul> <li>Reduced Attack Surface: By limiting access, you reduce the number of potential vulnerabilities an attacker can exploit.</li> <li>Containment: If an account or token is compromised, the damage is contained to only the specific permissions granted, rather than allowing full access.</li> <li>Easier Auditing: With well-defined roles and permissions, it becomes easier to audit access and monitor for suspicious activity.</li> </ul>","tags":["Programming","React"]},{"location":"blog/2024/08/08/principle-of-least-privilege-polp/#example-scenario","title":"Example Scenario:","text":"<p>Suppose you have an application with two types of users: regular users and administrators.</p> <ul> <li>Regular User Token: This token might only have permissions to read their own data and perform specific actions like updating their profile.</li> <li>Administrator Token: This token would have broader permissions, such as creating, reading, updating, and deleting any user data.</li> </ul> <p>By ensuring that tokens are scoped appropriately based on the user's role, you minimize the risk associated with token misuse or theft, effectively implementing the Principle of Least Privilege.</p>","tags":["Programming","React"]},{"location":"blog/2024/08/08/principle-of-least-privilege-polp/#example","title":"Example","text":"<p>Sure! Here\u2019s an example of how to scope user tokens in a typical web application using OAuth 2.0 as a reference. This will illustrate how to manage permissions based on user roles.</p> <p>Example: Scoping User Tokens</p> <p>In this example, we'll consider a simple scenario where we have two roles: User and Admin. Each role will have different permissions, and we'll implement a system to issue scoped tokens accordingly.</p>","tags":["Programming","React"]},{"location":"blog/2024/08/08/principle-of-least-privilege-polp/#step-1-define-scopes","title":"Step 1: Define Scopes","text":"<p>First, let's define the scopes for our application:</p> <ul> <li> <p>User Scopes</p> </li> <li> <p><code>read:profile</code>: Permission to read user profile data.</p> </li> <li> <p><code>update:profile</code>: Permission to update user profile data.</p> </li> <li> <p>Admin Scopes:</p> </li> <li> <p><code>read:all_users</code>: Permission to read all users' data.</p> </li> <li><code>write:all_users</code>: Permission to create, update, or delete any user data.</li> </ul>","tags":["Programming","React"]},{"location":"blog/2024/08/08/principle-of-least-privilege-polp/#step-2-implement-token-generation","title":"Step 2: Implement Token Generation","text":"<p>Here's a simplified example of how you might generate tokens with scopes using a hypothetical API in Node.js with Express:</p> ExpressExplanation <pre><code>// server.js\nconst express = require('express');\nconst jwt = require('jsonwebtoken');\n\nconst app = express();\nconst PORT = 3000;\n\n// Example users with roles\nconst users = {\n    user1: { role: 'user', scopes: ['read:profile', 'update:profile'] },\n    admin1: { role: 'admin', scopes: ['read:all_users', 'write:all_users'] },\n};\n\n// Generate JWT Token\nconst generateToken = (username) =&gt; {\n    const user = users[username];\n    if (!user) throw new Error('User not found');\n\n    const token = jwt.sign(\n        {\n            username,\n            role: user.role,\n            scopes: user.scopes,\n        },\n        'your_secret_key', // Use a strong secret key in production\n        { expiresIn: '1h' } // Token expires in 1 hour\n    );\n\n    return token;\n};\n\n// Login Endpoint\napp.post('/login', (req, res) =&gt; {\n    const { username } = req.body; // Assume we get username from request body\n\n    try {\n        const token = generateToken(username);\n        res.json({ token });\n    } catch (error) {\n        res.status(401).send(error.message);\n    }\n});\n\n// Middleware to Protect Routes\nconst authenticate = (requiredScope) =&gt; {\n    return (req, res, next) =&gt; {\n        const token = req.headers['authorization']?.split(' ')[1]; // Bearer token\n        if (!token) return res.status(401).send('Unauthorized');\n\n        jwt.verify(token, 'your_secret_key', (err, decoded) =&gt; {\n            if (err) return res.status(403).send('Token is invalid');\n\n            // Check for required scope\n            if (!decoded.scopes.includes(requiredScope)) {\n                return res.status(403).send('Insufficient permissions');\n            }\n\n            req.user = decoded; // Attach user info to request\n            next();\n        });\n    };\n};\n\n// Protected Routes\napp.get('/profile', authenticate('read:profile'), (req, res) =&gt; {\n    res.json({ message: 'User profile data', user: req.user.username });\n});\n\napp.get('/admin/users', authenticate('read:all_users'), (req, res) =&gt; {\n    res.json({ message: 'All users data' });\n});\n\napp.listen(PORT, () =&gt; {\n    console.log(`Server running on http://localhost:${PORT}`);\n});\n</code></pre> <ol> <li> <p>User Definition: We define users with their roles and associated scopes.</p> </li> <li> <p>Token Generation:</p> <ul> <li>When a user logs in, a token is generated using JWT (JSON Web Tokens).</li> <li>The token contains the username, role, and scopes, and it expires after 1 hour.</li> </ul> </li> <li> <p>Authentication Middleware:</p> <ul> <li>The <code>authenticate</code> middleware checks if the token is present and valid.</li> <li>It also verifies that the user has the required scope to access the protected route.</li> </ul> </li> <li> <p>Protected Routes:</p> <ul> <li>The <code>/profile</code> route requires the <code>read:profile</code> scope.</li> <li>The <code>/admin/users</code> route requires the <code>read:all_users</code> scope</li> </ul> </li> </ol>","tags":["Programming","React"]},{"location":"blog/2024/08/08/principle-of-least-privilege-polp/#step-3-client-side-usage","title":"Step 3: Client Side Usage","text":"<p>Here\u2019s a basic example of how a client might use the token:</p> <pre><code>// Client.js\nconst loginUser = async (username) =&gt; {\n  const response = await fetch(\"http://localhost:3000/login\", {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify({ username }),\n  });\n\n  const data = await response.json();\n  localStorage.setItem(\"token\", data.token); // Store the token\n};\n\nconst getProfile = async () =&gt; {\n  const token = localStorage.getItem(\"token\");\n\n  const response = await fetch(\"http://localhost:3000/profile\", {\n    method: \"GET\",\n    headers: {\n      Authorization: `Bearer ${token}`, // Include the token\n    },\n  });\n\n  const data = await response.json();\n  console.log(data);\n};\n\n// Example Usage\nloginUser(\"user1\").then(() =&gt; getProfile());\n</code></pre>","tags":["Programming","React"]},{"location":"blog/2024/08/08/principle-of-least-privilege-polp/#conclusion","title":"Conclusion","text":"<p>This example demonstrates how to scope user tokens based on roles and permissions using JWT. By implementing the Principle of Least Privilege, you can enhance security by ensuring that users only have access to the resources necessary for their role, minimizing potential damage from a compromised token.</p>","tags":["Programming","React"]},{"location":"blog/2024/05/14/prettier-formatter-for-visual-studio-code/","title":"Prettier Formatter for Visual Studio Code","text":"","tags":["vscode","formatting"]},{"location":"blog/2024/05/14/prettier-formatter-for-visual-studio-code/#prettier-formatter-for-visual-studio-code","title":"Prettier Formatter for Visual Studio Code","text":"<p>Prettier is an opinionated code formatter. It enforces a consistent style by parsing your code and re-printing it with its own rules that take the maximum line length into account, wrapping code when necessary.</p> <p></p> <p></p>","tags":["vscode","formatting"]},{"location":"blog/2024/05/30/efficiently-removing-a-property-from-an-object-while-retaining-its-value/","title":"Efficiently Removing a Property from an Object While Retaining Its Value","text":"","tags":["Personal"]},{"location":"blog/2024/05/30/efficiently-removing-a-property-from-an-object-while-retaining-its-value/#efficiently-removing-a-property-from-an-object-while-retaining-its-value","title":"Efficiently Removing a Property from an Object While Retaining Its Value","text":"<p>When working with JavaScript objects, there are cases where you might want to remove a property from an object but still retain its value for later use. This is common when preparing payloads for API requests. In this blog, we'll explore how to efficiently delete a property and still make use of its value, along with some advanced alternatives.</p> <p>Scenario:</p> <p>You have an object <code>updatePayload</code>, which contains an <code>id</code> property. You need to delete the <code>id</code> from <code>updatePayload</code> but still retain the value of <code>id</code> for further use. Here\u2019s the basic solution:</p>","tags":["Personal"]},{"location":"blog/2024/05/30/efficiently-removing-a-property-from-an-object-while-retaining-its-value/#basic-approach","title":"Basic Approach","text":"CodeExplanation <pre><code>let updatePayload = {\n...newValues,\nid: updateTaskRecord?.id\n};\n\n// Store the ID in a separate variable\nconst idToSend = updatePayload.id;\n\n// Delete `id` from updatePayload\ndelete updatePayload.id;\n\n// Dispatch the action with `idToSend`\ndispatch(updateToDoEvent(updatePayload, idToSend));\n</code></pre> <ul> <li>The <code>id</code> is saved in <code>idToSend</code> before deleting it from <code>updatePayload</code>.</li> <li>After deleting the <code>id</code> from the object, you still have the value available for use in your dispatch or function calls.</li> </ul>","tags":["Personal"]},{"location":"blog/2024/05/30/efficiently-removing-a-property-from-an-object-while-retaining-its-value/#advanced-alternatives","title":"Advanced Alternatives","text":"<ol> <li> <p>Destructuring Assignment</p> <p>You can leverage destructuring to pull out the <code>id</code> while spreading the rest of the object\u2019s properties into a new one:</p> <pre><code>const { id: idToSend, ...restOfPayload } = {\n    ...newValues,\n    id: updateTaskRecord?.id\n};\n\n// Dispatch the action\ndispatch(updateToDoEvent(restOfPayload, idToSend));\n</code></pre> In this approach <ul> <li>We use object destructuring to extract the <code>id</code> into <code>idToSend</code>, and at the same time, we create a new object <code>restOfPayload</code> with the remaining properties.</li> <li>This method is cleaner and doesn't require manually deleting properties.</li> </ul> </li> <li> <p>Using <code>lodash.omit</code> (Utility Library)</p> <p>Another advanced method is to use the lodash library, which provides a utility function omit for removing properties from objects.</p> <pre><code>import omit from 'lodash/omit';\n\nlet updatePayload = {\n...newValues,\nid: updateTaskRecord?.id\n};\n\n// Use `omit` to create a new object without the `id` property\nconst restOfPayload = omit(updatePayload, 'id');\n\n// Dispatch the action with `idToSend`\ndispatch(updateToDoEvent(restOfPayload, updatePayload.id));\n</code></pre> <p>The <code>omit</code> function returns a new object without the specified properties, making this approach concise and readable.</p> </li> <li> <p>Using Proxies for Dynamic Property Removal</p> <p>If you want more control, you can use a Proxy to dynamically manage how the object behaves when accessed, including removing properties conditionally.</p> <pre><code>let updatePayload = new Proxy({ ...newValues, id: updateTaskRecord?.id }, {\nget: (target, prop) =&gt; prop === 'id' ? undefined : target[prop]\n});\n\n// The proxy automatically excludes `id`\ndispatch(updateToDoEvent(updatePayload, updateTaskRecord?.id));\n</code></pre> <p>This method can be overkill for simple cases but gives a lot of power in scenarios where property access needs to be customized dynamically.</p> </li> </ol>","tags":["Personal"]},{"location":"blog/2024/05/30/efficiently-removing-a-property-from-an-object-while-retaining-its-value/#conclusion","title":"Conclusion","text":"<p>While the basic method of storing the <code>id</code> in a separate variable and deleting it from the object works, advanced techniques like <code>destructuring</code>, utility libraries like <code>lodash</code>, or even JavaScript proxies offer clean and efficient ways to handle property deletion while retaining values.</p>","tags":["Personal"]},{"location":"blog/2024/05/10/understanding-the-difference-between-response-object-and-parsed-data-object/","title":"Understanding the Difference Between Response Object and Parsed Data Object","text":"","tags":["js"]},{"location":"blog/2024/05/10/understanding-the-difference-between-response-object-and-parsed-data-object/#understanding-the-difference-between-response-object-and-parsed-data-object","title":"Understanding the Difference Between Response Object and Parsed Data Object","text":"<p>When working with APIs in JavaScript, particularly with the Fetch API, it's crucial to distinguish between the Response object and the parsed data object obtained from API responses. </p> <p>Here\u2019s a concise breakdown to clarify these concepts:</p>","tags":["js"]},{"location":"blog/2024/05/10/understanding-the-difference-between-response-object-and-parsed-data-object/#response-object","title":"Response Object","text":"<ul> <li>Definition: The Response object is provided by the Fetch API to represent the entire HTTP response received from an API endpoint.</li> <li>Contents: It includes metadata such as headers, status codes, and methods to access the response body (e.g., <code>.json()</code>, <code>.text()</code>).</li> <li>Type: When checking its type with <code>typeof</code>, it returns \"object\".</li> <li>Usage: You use the Response object to check the status of the request, access headers, and initiate methods to read and parse the response body content.</li> </ul>","tags":["js"]},{"location":"blog/2024/05/10/understanding-the-difference-between-response-object-and-parsed-data-object/#parsed-data-object","title":"Parsed Data Object","text":"<ul> <li>Definition: After parsing the response body using methods like <code>.json()</code> or <code>.text()</code> on the Response object, you obtain a parsed JavaScript object or string.</li> <li>Contents: This object represents the actual data content received from the API in a usable format within JavaScript.</li> <li>Type: When checking its type with <code>typeof</code>, it typically returns \"object\" (for JSON data) or \"string\" (for text data).</li> <li>Usage: It allows you to directly manipulate and use the data obtained from the API response within your application logic, such as rendering UI components or processing further.</li> </ul> <p>Example Scenario</p> javascript<pre><code>fetch('https://api.example.com/data')\n.then(response =&gt; {\n    if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    return response.json(); // Parse JSON response body\n})\n.then(data =&gt; {\n    // Response object\n    console.log(typeof response); // Outputs: \"object\"\n\n    // Parsed data object\n    console.log(typeof data); // Outputs: \"object\" (if parsed as JSON)\n\n    // Further process 'data' as needed\n    console.log(data); // Parsed JSON data object\n})\n.catch(error =&gt; {\n    console.error('Fetch error:', error);\n});\n</code></pre>","tags":["js"]},{"location":"blog/2024/05/10/understanding-the-difference-between-response-object-and-parsed-data-object/#conclusion","title":"Conclusion","text":"<p>Understanding the distinction between the Response object and the parsed data object is fundamental for effective API integration in JavaScript. The Response object encapsulates the entire HTTP response, while the parsed data object represents the meaningful content of that response in a format suitable for application logic. This clarity enables developers to handle API responses efficiently and leverage data seamlessly in their web applications.</p>","tags":["js"]},{"location":"blog/2024/01/29/understanding-the-impact-of-the-return-statement-in-javascripts-map-function/","title":"Understanding the Impact of the Return Statement in JavaScript's Map Function","text":""},{"location":"blog/2024/01/29/understanding-the-impact-of-the-return-statement-in-javascripts-map-function/#understanding-the-impact-of-the-return-statement-in-javascripts-map-function","title":"Understanding the Impact of the Return Statement in JavaScript's Map Function","text":"<p>In JavaScript, the <code>map</code> function is a powerful tool for transforming arrays by applying a function to each element. However, the presence or absence of the <code>return</code> statement within this function can significantly affect its behavior and the resulting output.</p> <p>Consider the following code snippet:</p> javascript<pre><code>const participantIds = test?.applicationTypeDetails?.tos?.map((item) =&gt; {\n  console.log(\"Ttos: \", item?.participantId);\n  return item?.participantId;\n});\n</code></pre> <p>In this snippet, <code>participantIds</code> is generated by mapping over the tos array, and for each item, we log \"Ttos: \" along with the participantId value. But crucially, we also use the <code>return</code> statement to explicitly specify that the <code>participantId</code> value should be included in the resulting array.</p> <p>Using the <code>return</code> statement ensures that each element processed by the <code>map</code> function contributes a specific value to the resulting array. This clarity is especially important when dealing with potentially <code>undefined</code> values, as it allows for consistent handling.</p> <p>However, if we were to omit the return statement, JavaScript would implicitly add <code>undefined</code> values to the resulting array for each item processed. While this may not always be desirable, it illustrates how the absence of the <code>return</code> statement impacts the function's behavior.</p>"},{"location":"blog/2024/01/29/understanding-the-impact-of-the-return-statement-in-javascripts-map-function/#conclusion","title":"Conclusion","text":"<p>In conclusion, the choice of using or not using the <code>return</code> statement within the <code>map</code> function depends on the desired outcome. Explicitly using return offers clarity and control over the resulting array, especially when dealing with potentially undefined values, while omitting it may lead to implicit <code>undefined</code> values being included in the output. Understanding this distinction empowers JavaScript developers to wield the <code>map</code> function effectively in their code.</p>"},{"location":"blog/2024/05/25/role-based-vs-permission-based-access-control-in-react/","title":"Role-Based vs Permission-Based Access Control in React","text":"","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/25/role-based-vs-permission-based-access-control-in-react/#role-based-vs-permission-based-access-control-in-react","title":"Role-Based vs Permission-Based Access Control in React","text":"Role-Based vs Permission-Based Access Control in React: Which is Better for Displaying Elements? <p>When deciding between permission-based or role-based access control (RBAC) for showing certain elements in a React application, both approaches have their pros and cons, depending on the complexity of your system. Here's a comparison to help decide which approach suits your needs:</p>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/25/role-based-vs-permission-based-access-control-in-react/#1-role-based-access-control-rbac","title":"1.  Role-Based Access Control (RBAC)","text":"<p>In RBAC, users are assigned roles, and each role has permissions to access certain features. For example, an \"Admin\" role might have access to more elements than a \"User\" role.</p> Pros: <ul> <li>Simpler to manage: Assign roles once, and permissions are derived from the role.</li> <li>Less configuration: You only need to define roles and check them, reducing complexity.</li> <li>Scalability: Easier to scale for smaller apps where roles are clearly defined (e.g., Admin, User, Guest).</li> </ul> Cons: <ul> <li>Limited granularity: You can't easily fine-tune permissions within roles (e.g., two Admins with different permissions).</li> </ul> <pre><code>const userRole = 'Admin'; // This would come from your state or API\n\nconst AdminElement = () =&gt; &lt;div&gt;Admin Content&lt;/div&gt;;\nconst UserElement = () =&gt; &lt;div&gt;User Content&lt;/div&gt;;\n\nreturn (\n  &lt;&gt;\n    {userRole === 'Admin' &amp;&amp; &lt;AdminElement /&gt;}\n    {userRole === 'User' &amp;&amp; &lt;UserElement /&gt;}\n  &lt;/&gt;\n);\n</code></pre>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/25/role-based-vs-permission-based-access-control-in-react/#2-permission-based-access-control","title":"2. Permission-Based Access Control","text":"<p>In permission-based control, users are granted individual permissions directly (e.g., \"canViewDashboard\", \"canEditProfile\"). Permissions are more granular and allow for fine-tuning access control.</p> Pros: <ul> <li>More flexibility: Permissions can be applied to specific features regardless of roles, allowing fine-grained control.</li> <li>Complex scenarios: Suitable for larger apps with multiple permission needs across various features.</li> </ul> Cons: <ul> <li>Harder to manage: Managing individual permissions for every feature can become complex, especially as the app grows.</li> <li>Overhead: More API calls and logic to check each specific permission.</li> </ul> <pre><code>const userPermissions = ['canViewDashboard', 'canEditProfile']; // Fetched from API or state\n\nconst DashboardElement = () =&gt; &lt;div&gt;Dashboard&lt;/div&gt;;\nconst EditProfileElement = () =&gt; &lt;div&gt;Edit Profile&lt;/div&gt;;\n\nreturn (\n  &lt;&gt;\n    {userPermissions.includes('canViewDashboard') &amp;&amp; &lt;DashboardElement /&gt;}\n    {userPermissions.includes('canEditProfile') &amp;&amp; &lt;EditProfileElement /&gt;}\n  &lt;/&gt;\n);\n</code></pre>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/25/role-based-vs-permission-based-access-control-in-react/#3-hybrid-approach","title":"3. Hybrid Approach:","text":"<p>Many systems use a hybrid of both methods, where roles define broad access and permissions are used for finer control.</p> <pre><code>const userRole = 'Admin';\nconst userPermissions = ['canViewSettings'];\n\nconst SettingsElement = () =&gt; &lt;div&gt;Settings&lt;/div&gt;;\n\nreturn (\n  &lt;&gt;\n    {userRole === 'Admin' &amp;&amp; userPermissions.includes('canViewSettings') &amp;&amp; &lt;SettingsElement /&gt;}\n  &lt;/&gt;\n);\n</code></pre> <p>This allows roles to handle major access control while permissions handle finer details.</p>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/25/role-based-vs-permission-based-access-control-in-react/#choosing-the-right-approach","title":"Choosing the Right Approach:","text":"<ul> <li>Small apps: If your app has a clear set of predefined roles (e.g., Admin, Editor, Viewer), role-based access control is simpler and faster to implement.</li> <li>Large apps or complex permission needs: For larger applications where users need fine-grained control over different features (e.g., granular permissions across multiple areas), permission-based control will be more flexible.</li> </ul>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/25/role-based-vs-permission-based-access-control-in-react/#in-summary","title":"In summary:","text":"<ul> <li>Role-based control is good for simplicity and clear boundaries.</li> <li>Permission-based control is good for complex systems with more granular needs.</li> </ul>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/25/role-based-vs-permission-based-access-control-in-react/#question","title":"Question","text":"<p>Access control is a critical aspect of web application security, ensuring that users only have access to the data and features they are authorized to use. There are several different types of access control mechanisms commonly used in web applications:</p> <ol> <li> <p>Role-Based Access Control (RBAC)</p> <p>In RBAC, access to resources and features is granted based on roles assigned to users. Each role has predefined permissions, and users are assigned roles depending on their responsibilities.</p> Characteristics: <ul> <li>Roles like \"Admin,\" \"Editor,\" and \"Viewer\" are created.</li> <li>Users are assigned one or more roles.</li> <li>Permissions are attached to roles, not individual users.</li> </ul> Example: <ul> <li>Admin can access all pages.</li> <li>Editor can modify content but not user settings.</li> <li>Viewer can only view content.</li> </ul> Common Use Cases: <ul> <li>Content Management Systems (CMS)</li> <li>Enterprise Resource Planning (ERP) systems</li> </ul> </li> <li> <p>Permission-Based Access Control</p> <p>In Permission-Based control, permissions are granted to individual users or groups based on specific actions, rather than roles. Permissions allow more fine-grained control, often granting access to individual resources or features.</p> Characteristics: <ul> <li>Users have explicit permissions like \"canViewDashboard\" or \"canEditProfile.\"</li> <li>Permissions are more granular and provide better flexibility.</li> </ul> Example: <ul> <li>A user might have permission to view the dashboard but not edit their profile.</li> </ul> Common Use Cases: <ul> <li>SaaS platforms with flexible access controls.</li> <li>Applications with complex permissions across features.</li> </ul> </li> <li> <p>Discretionary Access Control (DAC)</p> <p>In DAC, the owner of the data or resource decides who can access it. The access control decision is made based on user identity and group membership. The resource owner can modify permissions, granting or restricting access to other users.</p> Characteristics: <p>The owner (user or admin) has full control over the access rights of others. Flexible but potentially less secure than mandatory access control.</p> Example: <p>A file owner can choose who can read or edit their file.</p> Common Use Cases: <p>File-sharing systems. Personal data control in collaborative platforms.</p> </li> <li> <p>Mandatory Access Control (MAC)</p> <p>In MAC, access control policies are enforced by the system and are not controlled by individual users. The system assigns security labels to users and data, and access decisions are made based on these labels.</p> Characteristics: <ul> <li>Access is granted based on clearance levels.</li> <li>The system administrator defines the rules; users have no control over who can access the data.</li> </ul> <p>???+ example \"Example:</p> <pre><code>-   Classified government systems where access is based on security clearances (e.g., Confidential, Secret, Top Secret).\n</code></pre> Common Use Cases: <ul> <li>Military or governmental systems.</li> <li>High-security environments requiring strict controls.</li> </ul> </li> <li> <p>Attribute-Based Access Control (ABAC)</p> <p>In ABAC, access decisions are made based on user attributes (e.g., department, job title, location), resource attributes, and environmental conditions (e.g., time of day). It allows for highly dynamic and context-aware access control.</p> Characteristics: <ul> <li>Rules are based on attributes rather than predefined roles or permissions.</li> <li>Policies can specify who has access under certain conditions.</li> </ul> Example: <ul> <li>Only employees in the \"HR\" department can access employee records during office hours.</li> </ul> Common Use Cases: <ul> <li>Dynamic systems like cloud services or IoT systems.</li> <li>Systems requiring granular and context-aware access control.</li> </ul> </li> <li> <p>Identity-Based Access Control (IBAC)</p> <p>In IBAC, access is determined by the individual identity of the user. Each user has specific access to certain resources based on their personal identification.</p> Characteristics: <ul> <li>Personalized access control for each user.</li> <li>Access control decisions are made based on the user's identity.</li> </ul> Example: <ul> <li>A specific user has access to their own documents but not others'.</li> </ul> Common Use Cases: <ul> <li>Personalized dashboards.</li> <li>Applications where each user manages their own data.</li> </ul> </li> <li> <p>Token-Based Access Control (e.g., OAuth, JWT)</p> <p>Token-Based Access Control is widely used in modern web applications where users are authenticated via tokens (like JWT). The token carries information about the user\u2019s permissions and is used to verify access.</p> Characteristics: <ul> <li>Stateless authentication where tokens are passed with each request.</li> <li>Can be used for Single Sign-On (SSO) and third-party API access.</li> </ul> Example: <ul> <li>OAuth tokens grant access to resources on behalf of users.</li> <li>JWT tokens are used to authenticate and authorize users in a web app.</li> </ul> Common Use Cases: <ul> <li>RESTful APIs.</li> <li>Single Sign-On (SSO) systems.</li> </ul> </li> <li> <p>Context-Based Access Control (CBAC)</p> <p>In CBAC, access control is based on the context of the request, including factors like the user's location, device, and time of access.</p> Characteristics: <ul> <li>Highly dynamic access control, taking into account external factors.</li> <li>Context can change access permissions in real time.</li> </ul> Example: <ul> <li>A user can access a system only during working hours and from an approved device.</li> </ul> Common Use Cases: <ul> <li>Enterprise systems with location and time-based access controls.</li> <li>IoT systems with real-time environmental conditions.</li> </ul> </li> <li> <p>Rule-Based Access Control</p> <p>Rule-Based Access Control defines access rules that the system follows. These rules determine who has access to which resources and under what conditions.</p> Characteristics: <ul> <li>Rules are predefined based on specific conditions.</li> <li>Offers flexibility, as rules can be customized for various situations.</li> </ul> Example: <ul> <li>A user can access a report if they have completed a mandatory training course.</li> </ul> Common Use Cases: <ul> <li>Automated systems requiring complex rules.</li> <li>Security systems with specific conditional access requirements.</li> </ul> </li> </ol> Conclusion: <ul> <li>RBAC is simple and widely used for role-based access across different user types.</li> <li>Permission-Based control offers more flexibility with finer control over resources.</li> <li>ABAC is best for dynamic, attribute-driven environments like cloud or IoT.</li> <li>Token-Based control is essential for stateless systems and API access.</li> </ul> <p>Choose the model based on the complexity and security needs of your application!</p> <pre><code>Summary\n\nRBAC: Based on roles.\nPermission-Based: Based on specific permissions.\nDAC: Resource owners define access.\nMAC: System-enforced access policies.\nABAC: Based on attributes like department or time.\nIBAC: Based on user identity.\nToken-Based: Uses tokens (e.g., JWT) for stateless authentication.\nCBAC: Access based on context like location or time.\nRule-Based: Rules define access criteria.\n</code></pre>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/22/unveiling-static-and-prototype-methods-in-javascript-built-in-objects/","title":"Unveiling Static and Prototype Methods in JavaScript Built-in Objects","text":"","tags":["js"]},{"location":"blog/2024/05/22/unveiling-static-and-prototype-methods-in-javascript-built-in-objects/#unveiling-static-and-prototype-methods-in-javascript-built-in-objects","title":"Unveiling Static and Prototype Methods in JavaScript Built-in Objects","text":"<p>To thoroughly understand and see the static methods and constructor methods in JavaScript built-in objects, you can use a combination of developer tools, documentation, and JavaScript code. Here\u2019s a detailed guide:</p>","tags":["js"]},{"location":"blog/2024/05/22/unveiling-static-and-prototype-methods-in-javascript-built-in-objects/#1-using-developer-tools","title":"1. Using Developer Tools","text":"<p>In a Browser Console</p> <ol> <li>Open Developer Tools: You can usually open this by pressing <code>F12</code>, <code>Ctrl+Shift+I</code>, or <code>Cmd+Option+I</code>.</li> <li>Go to the Console Tab: Here you can execute JavaScript code.</li> </ol>","tags":["js"]},{"location":"blog/2024/05/22/unveiling-static-and-prototype-methods-in-javascript-built-in-objects/#viewing-static-methods","title":"Viewing Static Methods","text":"<p>Static methods are functions that are called on the class itself, not on instances of the class. For example, <code>Array.from()</code> is a static method on the <code>Array</code> constructor.</p> <pre><code>console.dir(Array);\nconsole.dir(Object);\nconsole.dir(Math);\n</code></pre>","tags":["js"]},{"location":"blog/2024/05/22/unveiling-static-and-prototype-methods-in-javascript-built-in-objects/#viewing-constructor-methods","title":"Viewing Constructor Methods","text":"<p>Constructor methods (or prototype methods) are functions that are available on the instances of the objects. For example, <code>Array.prototype.push()</code> is a constructor method.</p> <pre><code>console.dir(Array.prototype);\nconsole.dir(Object.prototype);\n</code></pre>","tags":["js"]},{"location":"blog/2024/05/22/unveiling-static-and-prototype-methods-in-javascript-built-in-objects/#2-using-javascript-code","title":"2. Using JavaScript Code","text":"","tags":["js"]},{"location":"blog/2024/05/22/unveiling-static-and-prototype-methods-in-javascript-built-in-objects/#list-all-static-methods-and-properties","title":"List All Static Methods and Properties","text":"<p>To list all static methods and properties of a built-in object, you can use the following code snippet:</p> <pre><code>function listStaticMethods(obj) {\n  return Object.getOwnPropertyNames(obj).filter(prop =&gt; typeof obj[prop] === 'function');\n}\n\nconsole.log(listStaticMethods(Array)); // List static methods of Array\nconsole.log(listStaticMethods(Object)); // List static methods of Object\nconsole.log(listStaticMethods(Math));   // List static methods of Math\n</code></pre>","tags":["js"]},{"location":"blog/2024/05/22/unveiling-static-and-prototype-methods-in-javascript-built-in-objects/#list-all-prototype-methods","title":"List All Prototype Methods","text":"<p>To list all prototype methods of a built-in object, you can use the following code snippet:</p> <pre><code>function listPrototypeMethods(obj) {\n  return Object.getOwnPropertyNames(obj.prototype).filter(prop =&gt; typeof obj.prototype[prop] === 'function');\n}\n\nconsole.log(listPrototypeMethods(Array)); // List prototype methods of Array\nconsole.log(listPrototypeMethods(Object)); // List prototype methods of Object\n</code></pre>","tags":["js"]},{"location":"blog/2024/05/22/unveiling-static-and-prototype-methods-in-javascript-built-in-objects/#3-consulting-documentation","title":"3. Consulting Documentation","text":"<p>Refer to the official JavaScript documentation for comprehensive details on built-in objects, their static methods, and prototype methods:</p> <ul> <li> <p>MDN Web Docs: This is a highly recommended resource for in-depth information on JavaScript built-in objects. For example:</p> </li> <li> <p>Array</p> </li> <li>Object</li> <li>Math</li> </ul> Example Output <p>When you run the provided code snippets, you will get lists of methods:</p> <p>Static Methods of Array:</p> <pre><code>[\"from\", \"isArray\", \"of\"]\n</code></pre> <p>Prototype Methods of Array:</p> <pre><code>[\"constructor\", \"copyWithin\", \"fill\", \"find\", \"findIndex\", \"keys\", \"entries\", \"values\", \"pop\", \"push\", \"concat\", \"join\", \"reverse\", \"shift\", \"unshift\", \"slice\", \"splice\", \"sort\", \"indexOf\", \"lastIndexOf\", \"every\", \"some\", \"forEach\", \"map\", \"filter\", \"reduce\", \"reduceRight\", \"includes\", \"flat\", \"flatMap\", \"at\", \"toLocaleString\", \"toString\", \"length\"]\n</code></pre> <p>By using these methods, you can thoroughly explore and understand the static and prototype methods available in JavaScript <code>built-in</code> objects.</p>","tags":["js"]},{"location":"blog/2024/06/04/understanding-asyncawait/","title":"Understanding async/await","text":"","tags":["react"]},{"location":"blog/2024/06/04/understanding-asyncawait/#understanding-asyncawait","title":"Understanding <code>async/await</code>","text":"<p>In modern JavaScript development, managing asynchronous operations is crucial for creating responsive and efficient applications. Two key tools for handling async operations are async and await.</p> <p>Understanding <code>async/await</code>: A Guide to Managing Asynchronous Operations</p> Here\u2019s a breakdown <ul> <li> <p>Synchronous Actions: If your <code>dispatch</code> calls are for synchronous actions (simple object literals), you don\u2019t need to use <code>async/await</code>. Synchronous actions are dispatched and handled immediately.</p> </li> <li> <p>Asynchronous Actions (Thunks): If your <code>dispatch</code> calls are for asynchronous operations (like API calls), you may use <code>async/await</code> to handle these operations more effectively. This often involves using middleware like <code>redux-thunk</code> or <code>redux-saga</code>.</p> </li> </ul>","tags":["react"]},{"location":"blog/2024/06/04/understanding-asyncawait/#overview","title":"Overview","text":"<p>Here\u2019s a breakdown of what they are, when to use them, and when they might not be the best choice.</p>","tags":["react"]},{"location":"blog/2024/06/04/understanding-asyncawait/#what-is-asyncawait","title":"What is async/await?","text":"<p><code>async/await</code> is a syntactic sugar introduced in ECMAScript 2017 (ES8) that simplifies working with asynchronous code. It allows you to write asynchronous code that looks and behaves more like synchronous code, making it easier to read and maintain.</p> <ul> <li> <p><code>async</code>: This keyword is used to declare a function as asynchronous. An <code>async</code> function always returns a promise, and inside this function, you can use the await keyword.</p> </li> <li> <p><code>await</code>: This keyword is used inside async functions to pause the execution of the code until the promise is resolved or rejected. It essentially waits for the promise to complete and returns the result, allowing you to work with asynchronous code as if it were synchronous.</p> </li> </ul>","tags":["react"]},{"location":"blog/2024/06/04/understanding-asyncawait/#when-to-use-asyncawait","title":"When to Use <code>async/await</code>","text":"<ol> <li> <p>Simplifying Code: Use <code>async/await</code> to make your asynchronous code more readable and easier to maintain. It reduces the need for chaining multiple <code>.then()</code> calls and nesting callbacks, making the flow of your code more linear and intuitive.</p> </li> <li> <p>Error Handling: <code>async/await</code> allows you to use <code>try/catch</code> blocks for error handling, which is often more straightforward than handling errors with <code>.catch()</code> in promise chains. This makes it easier to manage errors in a predictable way.</p> </li> <li> <p>Sequential Asynchronous Operations: When you need to perform multiple asynchronous operations in sequence, <code>async/await</code> helps you write code that waits for each operation to complete before moving to the next one. This is useful for tasks where each step depends on the results of the previous one.</p> </li> <li> <p>Readability and Debugging: <code>async/await</code> can make debugging easier because it avoids deeply nested code and complex promise chains. Stack traces are also typically clearer, as the code looks more like synchronous code.</p> </li> </ol>","tags":["react"]},{"location":"blog/2024/06/04/understanding-asyncawait/#when-not-to-use-asyncawait","title":"When Not to Use async/await","text":"<ol> <li> <p>Parallel Asynchronous Operations: If you need to execute multiple asynchronous operations in parallel and do not need to wait for each to complete before starting the next, using <code>async/await</code> can be less efficient. Instead, you might use <code>Promise.all()</code> to run promises concurrently and handle them collectively.</p> <pre><code>// Using Promise.all for parallel execution\nconst fetchData = async () =&gt; {\n    const [data1, data2] = await Promise.all([\n        fetch('url1').then(response =&gt; response.json()),\n        fetch('url2').then(response =&gt; response.json())\n    ]);\n    // Process data1 and data2\n};\n</code></pre> </li> <li> <p>Non-Promise-Based Asynchronous Code: <code>async/await</code> is designed for handling promises. If you're dealing with callback-based asynchronous patterns (like some older APIs), you might need to use Promise wrappers or continue using callbacks. However, for new code, consider refactoring to use promises if possible.</p> </li> <li> <p>Simple Asynchronous Functions: For very simple asynchronous operations where readability and maintainability are not a concern, and where the asynchronous code is straightforward, using <code>async/await</code> might be overkill. Simple <code>.then()</code> chains might suffice.</p> </li> <li> <p>Non-Blocking Operations: In cases where the operations are non-blocking and you don\u2019t need to wait for their results, you might not need <code>async/await</code>. For instance, if you\u2019re dispatching actions or events that do not require waiting for completion, <code>async/await</code> may not be necessary.</p> </li> </ol>","tags":["react"]},{"location":"blog/2024/06/04/understanding-asyncawait/#conclusion","title":"Conclusion","text":"<p><code>async/await</code> is a powerful tool for handling asynchronous code in a clean and readable manner. It is ideal for simplifying code, improving error handling, and managing sequential asynchronous tasks. However, for tasks requiring parallel execution, non-promise-based code, or very simple asynchronous logic, other approaches might be more appropriate.</p> <p>By understanding when to use <code>async/await</code> and when other methods might be better suited, you can write more efficient and maintainable asynchronous code in your JavaScript applications.</p>","tags":["react"]},{"location":"blog/2024/08/10/empty-array-or-null/","title":"Empty array or null","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/08/10/empty-array-or-null/#empty-array-or-null","title":"Empty array or null","text":"<p>In your case, both approaches can work, but using an empty array (<code>[]</code>) instead of <code>null</code> for <code>getCircularPlanningResp</code> is generally a better practice.</p> <p>Here\u2019s why:</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/10/empty-array-or-null/#1-consistency","title":"1. Consistency:","text":"<ul> <li>Empty Array (<code>[]</code>): Using an empty array signifies that there are no logs available yet, which aligns with the concept of a list. This allows your components to render without worrying about type checking and makes it clear that you can still iterate over it safely.</li> <li>Null: Using <code>null</code> can lead to situations where you have to add additional checks or handling in your components to avoid errors when trying to map over it.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/10/empty-array-or-null/#2-ease-of-mapping","title":"2. Ease of Mapping:","text":"<ul> <li>When you return an empty array, you can directly call <code>.map()</code> on it without any checks:</li> </ul> <pre><code>const dataSource = getCircularPlanningResp.map((log) =&gt; ({\n  key: log.id,\n  remarks: log.remarks,\n  creationTime: log.creationTime,\n}));\n</code></pre> <p>This avoids the need for additional checks and improves readability.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/10/empty-array-or-null/#3-state-management","title":"3. State Management:","text":"<ul> <li>It can be clearer in your state management. For example:</li> </ul> <pre><code>const initialState = {\n  getCircularPlanningResp: [], // Use an empty array\n  getCircularPlanningLoading: false,\n};\n</code></pre> <p>This indicates that <code>getCircularPlanningResp</code> will always be an array, which can help prevent potential <code>TypeError</code> issues throughout your code.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/10/empty-array-or-null/#4-ui-feedback","title":"4. UI Feedback:","text":"<ul> <li>When <code>getCircularPlanningResp</code> is an empty array, you can render a message like \"No logs available\" directly in your component if needed:</li> </ul> <pre><code>if (dataSource.length === 0) {\n  return &lt;div&gt;No logs available&lt;/div&gt;;\n}\n</code></pre>","tags":["Porgramming","React"]},{"location":"blog/2024/08/10/empty-array-or-null/#conclusion","title":"Conclusion","text":"<p>While both <code>null</code> and an empty array can be used, using an empty array (<code>[]</code>) is generally preferred because it simplifies your logic, improves code clarity, and avoids potential errors when dealing with array operations. It also aligns well with how data is usually expected in UI components, making the development process smoother.</p>","tags":["Porgramming","React"]},{"location":"class/in-depth/","title":"In Depth","text":""},{"location":"class/in-depth/#in-depth","title":"In Depth","text":""},{"location":"class/in-depth/#1-refine-your-understanding-of-class-vs-object","title":"1. Refine Your Understanding of Class vs. Object","text":"<p>You're correct that a class is a blueprint, and an object is an instance of that class. But let\u2019s break down this distinction more deeply:</p> <ul> <li>Class: A class defines the structure and behavior of an object. It includes instance properties and methods (which belong to an instance of the class), and static properties and methods (which belong to the class itself).</li> <li>Object: When you create an object (an instance of the class), it holds its own set of instance properties and has access to the instance methods defined in the class. Static methods and properties are not directly tied to individual objects but to the class itself.</li> </ul> <pre><code>class Car {\n  // Static property\n  static carCount = 0;\n\n  // Instance property\n  model = \"Tesla\";\n\n  // Instance method\n  drive() {\n    console.log(`${this.model} is driving`);\n  }\n\n  // Static method\n  static getCarCount() {\n    return Car.carCount;\n  }\n\n  // Constructor to increase car count when a new instance is created\n  constructor() {\n    Car.carCount += 1;\n  }\n}\n\nconst car1 = new Car();\nconst car2 = new Car();\n\nconsole.log(Car.getCarCount()); // Static method: 2\ncar1.drive(); // Instance method: Tesla is driving\n</code></pre> <ul> <li><code>carCount</code> is a static property that tracks the number of <code>Car</code> instances created.</li> <li><code>getCarCount()</code> is a static method that accesses <code>carCount</code> without needing an instance of Car.</li> <li><code>drive()</code> is an instance method, which needs an object (<code>car1</code>, <code>car2</code>, etc.) to be called.</li> </ul>"},{"location":"class/in-depth/#learn-about-the-constructor-and-prototype-properties","title":"Learn about the <code>constructor</code> and <code>prototype</code> Properties","text":"<p>Every JavaScript function (including classes) has a <code>prototype</code> property, and every instance of a class has a <code>constructor</code> property, which points back to the class (or function) it was created from.</p> <p>To deepen your understanding, you can inspect the <code>prototype</code> and <code>constructor</code> properties of class instances and functions.</p> Example<pre><code>class Animal {\n  static species = \"Mammal\";\n\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {\n    console.log(`${this.name} makes a sound.`);\n  }\n}\n\nconst dog = new Animal(\"Dog\");\nconsole.log(dog.constructor); // Animal()\nconsole.log(dog.constructor === Animal); // true\n\nconsole.log(Animal.prototype); // Logs the prototype of Animal class\nconsole.log(dog.__proto__); // Logs the prototype of the instance (same as Animal.prototype)\n</code></pre> <p>This will help you understand how the prototype chain works in depth and how the constructor function is tied to both classes and objects.</p>"},{"location":"class/in-depth/#further-explore-the-prototypical-inheritance","title":"Further Explore the Prototypical Inheritance","text":"<p>In JavaScript, everything is based on prototype inheritance. Even though class syntax is a cleaner way to define constructor functions, behind the scenes, JavaScript is still using prototypes.</p> <p>When you create an instance of a class, it inherits properties and methods from the class's prototype. For static properties and methods, they are directly part of the class itself, not the prototype of instances.</p> <ul> <li>Prototype: Each object has a <code>link</code> to a prototype object, which is where inherited properties and methods are stored.</li> <li>Static Methods: Static methods don't go into the prototype but are directly on the class.</li> </ul> <pre><code>class Example {\n  static staticMethod() {\n    console.log(\"Static method\");\n  }\n\n  instanceMethod() {\n    console.log(\"Instance method\");\n  }\n}\n\nconst obj = new Example();\n\n// Static methods are part of the class, not the prototype\nconsole.log(Example.hasOwnProperty(\"staticMethod\")); // true\nconsole.log(Example.prototype.hasOwnProperty(\"staticMethod\")); // false\n\n// Instance methods are part of the prototype\nconsole.log(Example.prototype.hasOwnProperty(\"instanceMethod\")); // true\n</code></pre> <p>This distinction is essential for understanding how objects and classes relate to one another in JavaScript.</p>"},{"location":"class/in-depth/#tell-me-in-depth-about-constructor-why-do-we-need-it-when-and-how-to-use-it-in-javascript","title":"tell me in depth about constructor. why do we need it. when and how to use it in javascript.","text":""},{"location":"class/intro/","title":"Overview","text":""},{"location":"class/intro/#class","title":"Class","text":"<p>can we list in console what are the static methods and properties in javascript.</p> <p>from what i know is that the class is like a map and object is house. to use the class methods and properties , we have to first create an object and through it we can only use the methods and properties of a class. but for static methods and properities, we donot have to create object to access and use it. This is what i know. am i correct ?</p> <p>Yes, you're absolutely correct!</p>"},{"location":"class/intro/#understanding-classes-objects-and-static-methodsproperties","title":"Understanding Classes, Objects, and Static Methods/Properties","text":""},{"location":"class/intro/#1-objects","title":"1. Objects:","text":"<ul> <li>An object is an instance of a class.</li> <li>When you create an object using a class, it can access instance methods (i.e., non-static methods) and instance properties (i.e., non-static properties) of that class.</li> <li>These instance methods and properties belong to the specific object created from the class.</li> </ul>"},{"location":"class/intro/#2-classes","title":"2. Classes:","text":"<ul> <li>A class is a blueprint or template for creating objects. It can have:</li> <li>Instance methods/properties: These are the methods and properties that require an instance (object) of the class to be used.</li> <li>Static methods/properties: These are properties and methods that belong to the class itself, not to any individual object created from it.</li> </ul>"},{"location":"class/intro/#3-static-methodsproperties","title":"3. Static Methods/Properties:","text":"<ul> <li>Static methods and properties are part of the class itself and not the instances (objects) created from it.</li> <li>You can access static methods/properties directly through the class without needing to create an object.</li> </ul> <pre><code>class MyClass {\n  static staticProperty = \"I am a static property\";\n\n  static staticMethod() {\n    console.log(\"I am a static method\");\n  }\n\n  instanceProperty = \"I am an instance property\";\n\n  instanceMethod() {\n    console.log(\"I am an instance method\");\n  }\n}\n\n// Accessing static property and method directly through the class\nconsole.log(MyClass.staticProperty); // \"I am a static property\"\nMyClass.staticMethod(); // \"I am a static method\"\n\n// Accessing instance property and method requires an object\nconst myObject = new MyClass();\nconsole.log(myObject.instanceProperty); // \"I am an instance property\"\nmyObject.instanceMethod(); // \"I am an instance method\"\n</code></pre>"},{"location":"class/intro/#listing-static-methods-and-properties-in-the-console","title":"Listing Static Methods and Properties in the Console","text":"<p>To list the static methods and properties of a class in JavaScript, you can use <code>console.log()</code> along with <code>Object.getOwnPropertyNames()</code>. This will return an array of all own properties (including static properties and methods) of the class itself.</p> Example for listing static methods/properties<pre><code>class MyClass {\n  static staticProperty = \"Static Property\";\n\n  static staticMethod() {\n    console.log(\"Static Method\");\n  }\n\n  instanceProperty = \"Instance Property\";\n\n  instanceMethod() {\n    console.log(\"Instance Method\");\n  }\n}\n\n// Listing static properties and methods of MyClass\nconsole.log(Object.getOwnPropertyNames(MyClass)); // [\"staticProperty\", \"staticMethod\", \"length\", \"prototype\"]\n</code></pre> <p><code>Object.getOwnPropertyNames(MyClass)</code> returns the static methods/properties of the class (including the default ones like <code>length</code> and <code>prototype</code>).</p> <p>If you want to filter out just the static methods and properties, excluding things like <code>length</code>, you can do something like this:</p> <pre><code>const staticProperties = Object.getOwnPropertyNames(MyClass).filter(\n  (prop) =&gt; prop !== \"prototype\"\n);\nconsole.log(staticProperties); // [\"staticProperty\", \"staticMethod\"]\n</code></pre> <p>This will give you a list of static properties and methods defined directly on the class.</p>"},{"location":"class/intro/#summary-of-your-understanding","title":"Summary of Your Understanding","text":"<p>You\u2019re on point! Here's a recap of your understanding:</p> <ul> <li>Object = an instance of a class (can access instance properties and methods).</li> <li>Class = a blueprint to create objects. Static methods/properties belong to the class itself, not the instances.</li> <li>Static methods/properties can be accessed directly from the class without needing to create an instance.</li> </ul> <p>You can access static methods and properties by referring directly to the class, like this:</p> <pre><code>MyClass.staticMethod();\nconsole.log(MyClass.staticProperty);\n</code></pre>"},{"location":"designpattern/categories/","title":"Categories","text":""},{"location":"designpattern/categories/#categories","title":"Categories","text":"<p>so design patterns in js is all about objects</p> <p>Yes, design patterns in JavaScript often revolve around objects because JavaScript is an object-oriented language (though it also supports functional programming). In JavaScript, most design patterns are centered around organizing and structuring objects, managing their behavior, and defining how they interact with each other.</p> <p>Here are some common design patterns in JavaScript that focus on objects:</p> Conclusion <p>While objects are central to JavaScript design patterns, these patterns are more about structuring and managing the relationships and behaviors of those objects. The goal is to make code easier to manage, extend, and maintain by applying reusable solutions to common design problems.</p> <p>Some patterns also borrow from functional programming principles, but the core structure often revolves around object creation, behavior management, and state handling.</p>"},{"location":"designpattern/categories/#why-are-design-patterns-in-javascript-focused-on-objects","title":"Why are design patterns in JavaScript focused on objects?","text":"<p>Here's why design patterns in JavaScript often focus on objects:</p> <ol> <li> <p>JavaScript is Object-Oriented: JavaScript supports object-oriented programming (OOP), which revolves around objects and their properties/methods. Even though JavaScript is multi-paradigm and supports functional programming, the language's design encourages using objects to model real-world entities and behaviors.</p> </li> <li> <p>Objects Represent Real-World Entities: Objects are great for modeling real-world concepts. For example, a <code>Car</code> object can have properties like <code>make</code> and <code>model</code>, and methods like <code>start()</code> or <code>stop()</code>. This makes it easier to represent and work with complex systems. Many design patterns, such as the Factory or Singleton patterns, aim to solve problems of object creation and management.</p> </li> <li> <p>Flexibility of Objects: JavaScript objects are flexible, allowing dynamic property addition and methods. This is why many design patterns (like the Module or Decorator patterns) revolve around adding or modifying behaviors to objects at runtime.</p> </li> <li> <p>State Management with Objects: Objects are an excellent way to manage state. Many design patterns, such as the <code>Observer</code> or <code>State</code> patterns, are used to manage how an object's state changes over time or how it communicates with other objects when the state changes. Objects are ideal for keeping track of internal states and behaviors.</p> </li> <li> <p>Encapsulation: Objects allow for encapsulation\u2014keeping internal details private and exposing only the necessary interface. This is the basis of patterns like the <code>Module</code> and <code>Singleton</code> patterns, where you limit access to certain parts of an object while exposing others to the outside world.</p> </li> <li> <p>Inheritance: JavaScript (with prototypal inheritance) allows objects to inherit properties and methods from other objects. Patterns like the <code>Prototype</code> pattern take advantage of this, allowing you to create new objects based on the structure of existing ones without directly creating a new class.</p> </li> </ol>"},{"location":"designpattern/categories/#are-design-patterns-only-about-objects","title":"Are design patterns only about objects?","text":"<p>Not necessarily. While most of the popular patterns in JavaScript revolve around objects, there are also patterns that are more about function management, such as:</p> <ul> <li> <p>Functional Patterns: Patterns like <code>Currying</code>, <code>Memoization</code>, and <code>Higher-Order Functions</code> focus on functions rather than objects.</p> </li> <li> <p>Async Patterns: Patterns like <code>Observer</code> and <code>Promise</code> or <code>Async/Await</code> are more concerned with handling asynchronous operations.</p> </li> </ul> <p>However, when you're dealing with object-oriented design in JavaScript (or any OOP-based language), you'll often find that design patterns are heavily oriented around how objects are structured, created, and interact with one another.</p> Summary <p>Design patterns in JavaScript are often centered around objects because objects are a natural fit for representing real-world entities, encapsulating state, and managing behaviors. While JavaScript allows for both object-oriented and functional programming, the language's object model makes it a popular choice for applying these design patterns.</p> <p>Are Design Patterns Only for Objects in JavaScript?</p> <p>No, design patterns are not exclusive to JavaScript objects. While JavaScript is an object-oriented language, design patterns apply to all kinds of software development, including object-oriented, functional, and procedural programming. They are commonly used in:</p> <ul> <li>Object-Oriented Programming (OOP): Patterns like Singleton, Factory, and Observer are often associated with OOP languages (like Java or C++), but they are also used in JavaScript.</li> <li>Functional Programming: Patterns like Currying, Composition, or Decorator can be implemented in a functional programming style, which is often seen in modern JavaScript.</li> </ul> <p>In JavaScript, while you may see patterns implemented with objects or classes (like the Singleton), many patterns can also be applied to functions, closures, and other structures.</p>"},{"location":"designpattern/categories/#non-object-focused-dp","title":"Non Object focused dp","text":"<p>Would you like to explore non-object-focused design patterns in JavaScript or dive deeper into any specific object-based pattern?</p> <p>Great! Let's explore some non-object-focused design patterns in JavaScript, particularly those that are more function-oriented or deal with asynchronous behavior. These patterns focus on functions, state management, and flow control rather than directly on objects.</p>"},{"location":"designpattern/categories/#1-functional-patterns","title":"1. Functional Patterns:","text":"<p>These patterns focus on the behavior and manipulation of functions themselves.</p> <p>1.1. Currying:</p> <p>Currying is the process of transforming a function that takes multiple arguments into a series of functions that each take one argument.</p> <pre><code>function add(a) {\n  return function (b) {\n    return a + b;\n  };\n}\n\nconst add5 = add(5);\nconsole.log(add5(10)); // 15\nconsole.log(add5(20)); // 25\n</code></pre> <p>In this example, <code>add</code> is curried so that you can create specialized functions (like <code>add5</code>) that remember the first argument and return a function that takes the next argument.</p> <p>1.2. Memoization:</p> <p>Memoization is a technique for optimizing performance by caching the results of expensive function calls based on input parameters. If the same input is provided again, the result is retrieved from the cache instead of recalculating it.</p> <pre><code>function memoize(fn) {\n  const cache = {};\n  return function (arg) {\n    if (cache[arg]) {\n      return cache[arg]; // Return cached result\n    } else {\n      const result = fn(arg);\n      cache[arg] = result;\n      return result;\n    }\n  };\n}\n\nconst slowFunction = (num) =&gt; {\n  console.log(\"Calculating...\");\n  return num * 2;\n};\n\nconst fastFunction = memoize(slowFunction);\n\nconsole.log(fastFunction(10)); // Calculating... 20\nconsole.log(fastFunction(10)); // 20 (no calculation, from cache)\n</code></pre> <p>This pattern improves performance by avoiding recalculating results that have already been computed.</p> <p>1.3. Function Composition:</p> <p>Function composition allows you to combine simple functions to create more complex ones. This pattern is useful in functional programming to build reusable and modular components.</p> <pre><code>const add5 = (x) =&gt; x + 5;\nconst multiply2 = (x) =&gt; x * 2;\n\n// Composing the functions\nconst add5AndMultiply2 = (x) =&gt; multiply2(add5(x));\n\nconsole.log(add5AndMultiply2(3)); // (3 + 5) * 2 = 16\n</code></pre> <p>Here, <code>add5</code> and <code>multiply2</code> are simple functions, but when combined through composition, they create a more complex operation.</p>"},{"location":"designpattern/categories/#2-asynchronous-patterns","title":"2. Asynchronous Patterns:","text":"<p>These patterns deal with handling asynchronous operations like promises, events, or time-based operations.</p> <p>2.1. Promise Chain (Async Flow):</p> <p>The Promise chain pattern helps to handle sequences of asynchronous operations in a clean, readable way. Promises are used to deal with async operations, allowing us to chain operations that depend on previous ones.</p> <pre><code>function getDataFromAPI(url) {\n  return new Promise((resolve, reject) =&gt; {\n    setTimeout(() =&gt; {\n      if (url) {\n        resolve({ data: \"Some API data\" });\n      } else {\n        reject(\"Error: No URL provided\");\n      }\n    }, 1000);\n  });\n}\n\ngetDataFromAPI(\"https://api.example.com\")\n  .then((response) =&gt; {\n    console.log(response.data); // \"Some API data\"\n    return getDataFromAPI(\"\"); // Simulate error\n  })\n  .catch((error) =&gt; {\n    console.log(error); // \"Error: No URL provided\"\n  });\n</code></pre> <p>The <code>Promise</code> pattern is especially useful for handling async code in a way that avoids deeply nested callbacks (callback hell) and makes the code more readable.</p> <p>2.2. Observer Pattern (Event Listeners):</p> <p>While it's often used in OOP, the <code>Observer</code> pattern also works in asynchronous scenarios where functions are notified of events or changes. In JavaScript, this is commonly implemented with event listeners or callbacks.</p> <pre><code>function EventEmitter() {\n  this.events = {};\n}\n\nEventEmitter.prototype.on = function (event, listener) {\n  if (!this.events[event]) {\n    this.events[event] = [];\n  }\n  this.events[event].push(listener);\n};\n\nEventEmitter.prototype.emit = function (event, data) {\n  if (this.events[event]) {\n    this.events[event].forEach((listener) =&gt; listener(data));\n  }\n};\n\nconst emitter = new EventEmitter();\n\nemitter.on(\"dataReceived\", (data) =&gt; {\n  console.log(\"Data received:\", data);\n});\n\nsetTimeout(() =&gt; {\n  emitter.emit(\"dataReceived\", { id: 1, name: \"John Doe\" });\n}, 2000); // Trigger after 2 seconds\n</code></pre> <p>In this example, an <code>EventEmitter</code> acts as a \"subject\" that notifies listeners (observers) when an event (like <code>'dataReceived'</code>) happens asynchronously.</p> <p>2.3. Async/Await (Syntactic Sugar for Promises):</p> <p>The <code>async/await</code> pattern allows you to write asynchronous code in a more synchronous-like manner, improving readability and avoiding callback hell.</p> <pre><code>async function fetchData(url) {\n  try {\n    let response = await fetch(url);\n    let data = await response.json();\n    console.log(data);\n  } catch (error) {\n    console.log(\"Error:\", error);\n  }\n}\n\nfetchData(\"https://api.example.com\");\n</code></pre> <p>With <code>async/await</code>, asynchronous code looks like normal sequential code, making it easier to write and understand.</p>"},{"location":"designpattern/categories/#3-state-management-patterns","title":"3. State Management Patterns:","text":"<p>State management patterns help to manage and track the state of an application, especially in larger or more complex applications.</p> <p>3.1. State Pattern (Managing State Transitions):</p> <p>In JavaScript, the State pattern is useful for managing state transitions, such as handling different modes or stages within an application.</p> <pre><code>function State() {\n  this.state = \"initial\";\n\n  this.setState = function (newState) {\n    this.state = newState;\n    console.log(`State changed to: ${this.state}`);\n  };\n\n  this.getState = function () {\n    return this.state;\n  };\n}\n\nconst appState = new State();\nappState.setState(\"loading\");\nappState.setState(\"loaded\");\n</code></pre> <p>This pattern can be extended to more complex systems where each state has its own behavior and transition logic.</p>"},{"location":"designpattern/categories/#summary","title":"Summary:","text":"<p>These non-object-focused patterns in JavaScript show that design patterns are not always about objects. Many patterns focus on functions, flow control (like promises), and state management. These patterns are highly useful for:</p> <ul> <li>Optimizing performance (Memoization).</li> <li>Managing asynchronous behavior (Promise Chain, Async/Await).</li> <li>Handling complex function behaviors (Currying, Function Composition).</li> <li>Tracking and transitioning states (State Pattern, Observer for events).</li> </ul>"},{"location":"designpattern/daily/","title":"Daily","text":"<p>Which design patterns can I use daily in JavaScript and React, and how should I implement them?</p>"},{"location":"designpattern/daily/#overview","title":"Overview","text":"<p>In both JavaScript and React, some design patterns are used more frequently due to the nature of front-end development and state management. Below are the most common design patterns you\u2019ll likely use daily, along with examples of how to implement them in both JavaScript and React.</p>"},{"location":"designpattern/daily/#1-module-pattern-javascript-custom-hooks-react","title":"1. Module Pattern (JavaScript) / Custom Hooks (React)","text":"<ul> <li>Purpose: The <code>Module Pattern</code> encapsulates code into a private scope, while in React, <code>Custom Hooks</code> encapsulate reusable logic.</li> <li>When to use: When you want to reuse logic across your application or manage specific behavior in an isolated way.</li> </ul> JavaScriptReact Example in JavaScript (Module Pattern)<pre><code>const calculatorModule = (function () {\n    let result = 0; // Private variable\n\n    return {\n        add: function (num) {\n            result += num;\n            return result;\n        },\n        reset: function () {\n            result = 0;\n            return result;\n        },\n    };\n})();\n\n// Usage\ncalculatorModule.add(5); // 5\ncalculatorModule.reset(); // 0\n</code></pre> Example in React (Custom Hook)<pre><code>import { useState } from 'react';\n\nfunction useCounter() {\n    const [count, setCount] = useState(0);\n\n    const increment = () =&gt; setCount(count + 1);\n    const reset = () =&gt; setCount(0);\n\n    return { count, increment, reset };\n}\n\nfunction CounterComponent() {\n    const { count, increment, reset } = useCounter();\n\n    return (\n        &lt;div&gt;\n            &lt;p&gt;{count}&lt;/p&gt;\n            &lt;button onClick={increment}&gt;Increment&lt;/button&gt;\n            &lt;button onClick={reset}&gt;Reset&lt;/button&gt;\n        &lt;/div&gt;\n    );\n}\n</code></pre> <p>Why Daily?</p> <p>You can use Modules to organize your logic into reusable blocks, while Custom Hooks in React let you encapsulate functionality like state management or data fetching in a reusable way.</p>"},{"location":"designpattern/daily/#2-observer-pattern-javascript-reacts-component-lifecycle-and-context-api","title":"2. Observer Pattern (JavaScript) / React\u2019s Component Lifecycle and Context API","text":"<ul> <li>Purpose: The <code>Observer Pattern</code> allows objects to subscribe to events, while React\u2019s <code>Context API</code> and <code>useEffect</code> are used to manage state changes and notify components.</li> <li>When to use: When you need to handle state or data changes across multiple components.</li> </ul> JavaScriptReact Example in JavaScript (Observer Pattern)<pre><code>class Subject {\n    constructor() {\n        this.observers = [];\n    }\n\n    subscribe(observer) {\n        this.observers.push(observer);\n    }\n\n    notify(data) {\n        this.observers.forEach(observer =&gt; observer.update(data));\n    }\n}\n\nclass Observer {\n    update(data) {\n        console.log('Data received:', data);\n    }\n}\n\nconst subject = new Subject();\nconst observer1 = new Observer();\nconst observer2 = new Observer();\n\nsubject.subscribe(observer1);\nsubject.subscribe(observer2);\n\nsubject.notify('Hello Observers');\n</code></pre> Example in React (Context API)<pre><code>import React, { createContext, useState, useContext } from 'react';\n\nconst ThemeContext = createContext();\n\nfunction ThemeProvider({ children }) {\n    const [theme, setTheme] = useState('light');\n\n    const toggleTheme = () =&gt; {\n        setTheme(theme === 'light' ? 'dark' : 'light');\n    };\n\n    return (\n        &lt;ThemeContext.Provider value={{ theme, toggleTheme }}&gt;\n            {children}\n        &lt;/ThemeContext.Provider&gt;\n    );\n}\n\nfunction ThemedComponent() {\n    const { theme, toggleTheme } = useContext(ThemeContext);\n    return (\n        &lt;div&gt;\n            &lt;p&gt;Current theme: {theme}&lt;/p&gt;\n            &lt;button onClick={toggleTheme}&gt;Toggle Theme&lt;/button&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default function App() {\n    return (\n        &lt;ThemeProvider&gt;\n            &lt;ThemedComponent /&gt;\n        &lt;/ThemeProvider&gt;\n    );\n}\n</code></pre> <p>Why Daily?</p> <p>In JavaScript, you may need the Observer Pattern to manage event-driven updates, while in React, Context API and useEffect are used frequently for state and lifecycle management.</p>"},{"location":"designpattern/daily/#3-factory-pattern-javascript-component-composition-react","title":"3. Factory Pattern (JavaScript) / Component Composition (React)","text":"<ul> <li>Purpose: The <code>Factory Pattern</code> creates objects without specifying the exact class, while in React, <code>Component Composition</code> allows you to assemble components dynamically.</li> <li>When to use: When creating objects or components based on dynamic inputs.</li> </ul> JavaScriptReact Example in JavaScript (Factory Pattern)<pre><code>function ButtonFactory(type) {\n    if (type === 'primary') {\n        return { style: 'blue', text: 'Primary Button' };\n    } else if (type === 'secondary') {\n        return { style: 'gray', text: 'Secondary Button' };\n    }\n}\n\nconst primaryButton = ButtonFactory('primary');\nconst secondaryButton = ButtonFactory('secondary');\n\nconsole.log(primaryButton);  // { style: 'blue', text: 'Primary Button' }\n</code></pre> Example in React (Component Composition)<pre><code>function Button({ style, text }) {\n    return &lt;button className={style}&gt;{text}&lt;/button&gt;;\n}\n\nfunction ButtonFactory({ type }) {\n    if (type === 'primary') {\n        return &lt;Button style=\"blue\" text=\"Primary Button\" /&gt;;\n    } else if (type === 'secondary') {\n        return &lt;Button style=\"gray\" text=\"Secondary Button\" /&gt;;\n    }\n    return null;\n}\n\nfunction App() {\n    return (\n        &lt;div&gt;\n            &lt;ButtonFactory type=\"primary\" /&gt;\n            &lt;ButtonFactory type=\"secondary\" /&gt;\n        &lt;/div&gt;\n    );\n}\n</code></pre> <p>Why Daily?</p> <p>In JavaScript, the Factory Pattern helps dynamically create objects, and in React, Component Composition lets you dynamically build your UI based on the application's state or user input.</p>"},{"location":"designpattern/daily/#4-singleton-pattern-javascript-redux-store-react","title":"4. Singleton Pattern (JavaScript) / Redux Store (React)","text":"<ul> <li>Purpose: The <code>Singleton Pattern</code> ensures that a class has only one instance, and in React, <code>Redux Store</code> is a global singleton store for state management.</li> <li>When to use: When you need a single source of truth for managing shared state.</li> </ul> JavaScriptReact Example in JavaScript (Singleton Pattern)<pre><code>const Singleton = (function() {\n    let instance;\n\n    function createInstance() {\n        return { data: 'I am the single instance' };\n    }\n\n    return {\n        getInstance: function() {\n            if (!instance) {\n                instance = createInstance();\n            }\n            return instance;\n        }\n    };\n})();\n\nconst instance1 = Singleton.getInstance();\nconst instance2 = Singleton.getInstance();\n\nconsole.log(instance1 === instance2); // true\n</code></pre> Example in React (Redux Store)<pre><code>import { createStore } from 'redux';\n\nconst initialState = { counter: 0 };\n\nfunction counterReducer(state = initialState, action) {\n    switch (action.type) {\n        case 'INCREMENT':\n            return { counter: state.counter + 1 };\n        default:\n            return state;\n    }\n}\n\nconst store = createStore(counterReducer);\n\nstore.subscribe(() =&gt; console.log(store.getState()));\n\nstore.dispatch({ type: 'INCREMENT' });  // Output: { counter: 1 }\nstore.dispatch({ type: 'INCREMENT' });  // Output: { counter: 2 }\n</code></pre> <p>Why Daily?</p> <p>In JavaScript, the Singleton Pattern helps manage single instances, and in React, Redux serves as a central store, which is essential for managing global state across the app.</p>"},{"location":"designpattern/daily/#5-decorator-pattern-javascript-higher-order-components-react","title":"5. Decorator Pattern (JavaScript) / Higher-Order Components (React)","text":"<ul> <li>Purpose: The <code>Decorator Pattern</code> allows for dynamic behavior addition, while in React, <code>Higher-Order Components (HOC)</code> wrap components to add functionality.</li> <li>When to use: When you need to add features to existing objects or components.</li> </ul> JavaScriptReact Example in JavaScript (Decorator Pattern)<pre><code>function addTimestamp(originalFunction) {\n    return function(...args) {\n        console.log('Timestamp:', new Date());\n        return originalFunction(...args);\n    };\n}\n\nfunction logMessage(message) {\n    console.log(message);\n}\n\nconst decoratedLog = addTimestamp(logMessage);\ndecoratedLog('Hello!'); // Logs the timestamp and then \"Hello!\"\n</code></pre> Example in React (Higher-Order Component)<pre><code>function withLogging(WrappedComponent) {\n    return function(props) {\n        console.log('Rendering:', WrappedComponent.name);\n        return &lt;WrappedComponent {...props} /&gt;;\n    };\n}\n\nfunction Button(props) {\n    return &lt;button&gt;{props.text}&lt;/button&gt;;\n}\n\nconst ButtonWithLogging = withLogging(Button);\n\nfunction App() {\n    return &lt;ButtonWithLogging text=\"Click Me\" /&gt;;\n}\n</code></pre> <p>Why Daily?</p> <p>Use the Decorator Pattern to add new behaviors to existing objects in JavaScript, and in React, HOCs help you reuse logic by enhancing components with additional functionality.</p>"},{"location":"designpattern/daily/#conclusion","title":"Conclusion:","text":"<ul> <li>Daily in JavaScript: Module Pattern, Observer Pattern, Factory Pattern, Singleton Pattern, Decorator Pattern.</li> <li>Daily in React: Custom Hooks, Context API, Component Composition</li> </ul>"},{"location":"designpattern/intro/","title":"Intro","text":"<p>To master JavaScript design patterns, you can focus on the following key topics and categories. These topics will help you understand the core patterns used in JavaScript development and how they can be applied in different scenarios.</p>"},{"location":"designpattern/intro/#1-creational-patterns","title":"1. Creational Patterns","text":"<ul> <li> <p>Goal: Deal with object creation mechanisms, trying to create objects in a manner suitable for the situation.</p> </li> <li> <p>Key Patterns:</p> <ul> <li>Constructor Pattern</li> <li>Factory Pattern</li> <li>Abstract Factory Pattern</li> <li>Singleton Pattern</li> <li>Prototype Pattern</li> <li>Builder Pattern</li> </ul> </li> </ul>"},{"location":"designpattern/intro/#2-structural-patterns","title":"2. Structural Patterns","text":"<ul> <li> <p>Goal: Deal with object composition and how objects and classes can be combined to form larger structures while keeping them flexible and efficient.</p> </li> <li> <p>Key Patterns:</p> <ul> <li>Module Pattern (often considered a structural pattern in JavaScript)</li> <li>Decorator Pattern</li> <li>Adapter Pattern</li> <li>Facade Pattern</li> <li>Proxy Pattern</li> <li>Flyweight Pattern</li> <li>Bridge Pattern</li> </ul> </li> </ul>"},{"location":"designpattern/intro/#3-behavioral-patterns","title":"3. Behavioral Patterns","text":"<ul> <li>Goal: Focus on communication between objects, defining how objects interact and share responsibility.</li> <li> <p>Key Patterns:</p> <ul> <li>Observer Pattern</li> <li>Strategy Pattern</li> <li>Command Pattern</li> <li>Iterator Pattern</li> <li>Mediator Pattern</li> <li>State Pattern</li> <li>Memento Pattern</li> <li>Visitor Pattern</li> <li>Chain of Responsibility Pattern</li> <li>Template Method Pattern</li> </ul> </li> </ul>"},{"location":"designpattern/intro/#4-concurrency-patterns-relevant-for-asynchronous-operations","title":"4. Concurrency Patterns (relevant for asynchronous operations)","text":"<ul> <li>Goal: Manage multithreading or asynchronous operations in an efficient and controlled way.</li> <li> <p>Key Patterns:</p> <ul> <li>Promises</li> <li>Async/Await</li> <li>Callbacks (though not necessarily a formal design pattern, understanding callback mechanisms is crucial)</li> <li>Throttling/Debouncing</li> <li>Publish-Subscribe Pattern (variation of Observer Pattern for event handling)</li> <li>Event Loop and Queues (JavaScript-specific concepts for managing concurrency)</li> </ul> </li> </ul>"},{"location":"designpattern/intro/#5-architectural-patterns","title":"5. Architectural Patterns","text":"<ul> <li>Goal: Deal with the architecture of applications, ensuring the structure is maintainable and scalable.</li> <li> <p>Key Patterns:</p> <ul> <li>MVC (Model-View-Controller)</li> <li>MVVM (Model-View-ViewModel)</li> <li>Flux Architecture (used with React, often implemented with Redux)</li> <li>Microservices (if you're working in Node.js)</li> </ul> </li> </ul>"},{"location":"designpattern/intro/#6-functional-programming-concepts-relevant-to-javascript","title":"6. Functional Programming Concepts (Relevant to JavaScript)","text":"<ul> <li>Goal: Understand how functional programming can be applied to write cleaner, more predictable code.</li> <li> <p>Key Concepts:</p> <ul> <li>Pure Functions</li> <li>Higher-Order Functions</li> <li>Function Composition</li> <li>Currying</li> <li>Immutability</li> </ul> </li> </ul>"},{"location":"designpattern/intro/#7-javascript-specific-design-patterns","title":"7. JavaScript-Specific Design Patterns","text":"<ul> <li>Goal: Learn patterns that are highly relevant to the JavaScript language and its peculiarities.</li> <li> <p>Key Patterns:</p> <ul> <li>Revealing Module Pattern</li> <li>IIFE (Immediately Invoked Function Expression)</li> <li>Mixin Pattern (for code reusability, especially in ES5 and older)</li> <li>Event Delegation</li> <li>Prototype Inheritance</li> <li>Promises and Async Patterns</li> </ul> </li> </ul>"},{"location":"designpattern/intro/#8-solid-principles-while-not-specific-design-patterns-these-principles-guide-the-use-of-patterns-effectively","title":"8. SOLID Principles (While not specific design patterns, these principles guide the use of patterns effectively)","text":"<ul> <li>Single Responsibility Principle (SRP)</li> <li>Open/Closed Principle (OCP)</li> <li>Liskov Substitution Principle (LSP)</li> <li>Interface Segregation Principle (ISP)</li> <li>Dependency Inversion Principle (DIP)</li> </ul>"},{"location":"designpattern/intro/#9-error-handling-patterns","title":"9. Error Handling Patterns","text":"<ul> <li>Goal: Learn strategies for handling errors gracefully.</li> <li> <p>Key Concepts:</p> <ul> <li>Try/Catch</li> <li>Graceful Degradation</li> <li>Fail Fast</li> <li>Error Propagation</li> </ul> </li> </ul>"},{"location":"designpattern/intro/#10-performance-optimization-patterns","title":"10. Performance Optimization Patterns","text":"<ul> <li>Goal: Understand patterns that help in improving the performance of JavaScript applications.</li> <li> <p>Key Patterns:</p> <ul> <li>Lazy Loading</li> <li>Memoization</li> <li>Throttling and Debouncing (useful for optimizing user interactions)</li> <li>Chunking</li> <li>Virtual DOM (relevant for front-end frameworks like React)</li> </ul> </li> </ul>"},{"location":"designpattern/intro/#suggested-learning-path","title":"Suggested Learning Path:","text":"<ol> <li>Start with Creational Patterns like Factory, Singleton, and Constructor, as they help manage object creation.</li> <li>Explore Structural Patterns to learn about object composition and efficient architecture.</li> <li>Delve into Behavioral Patterns to handle object interactions and communication (Observer, Strategy, etc.).</li> <li>Dive deeper into Concurrency Patterns to manage asynchronous operations, critical for modern JavaScript apps.</li> <li>Understand Architectural Patterns, especially MVC, Flux, and MVVM, for building scalable apps.</li> <li>Focus on JavaScript-specific patterns like Module, IIFE, and Event Delegation, as these are crucial for mastering JS.</li> <li>Apply SOLID principles to make the use of design patterns more effective and maintainable.</li> </ol> <p>Mastering these topics will help you apply design patterns to JavaScript effectively in various contexts.</p>"},{"location":"designpattern/js/","title":"JS","text":""},{"location":"designpattern/js/#how-to-use-javascript-design-patterns-in-daily-applications-simple-examples","title":"How to Use JavaScript Design Patterns in Daily Applications (Simple Examples)","text":"<p>Here\u2019s how you can use the most common design patterns in JavaScript in your daily applications:</p>"},{"location":"designpattern/js/#1-module-pattern","title":"1. Module Pattern","text":"<p>The Module Pattern helps organize your code by encapsulating related functions into a single object, making your code more modular and reusable. It\u2019s great for managing separate functionality like API services or UI components.</p> Simple ExampleUserService.jsmain.js <pre><code>// UserService.js (Module)\nconst UserService = (function () {\n    let users = [];\n\n    function addUser(user) {\n        users.push(user);\n        console.log(\"User added:\", user);\n    }\n\n    function getUsers() {\n        return users;\n    }\n\n    return {\n        addUser,\n        getUsers,\n    };\n})();\n\n// Usage\nUserService.addUser({ name: \"John\", age: 30 });\nUserService.addUser({ name: \"Jane\", age: 25 });\nconsole.log(UserService.getUsers()); // [{ name: 'John', age: 30 }, { name: 'Jane', age: 25 }]\n</code></pre> <pre><code>// UserService.js\nconst UserService = (function() {\n    let users = [];\n\n    function addUser(user) {\n        users.push(user);\n        console.log('User added:', user);\n    }\n\n    function getUsers() {\n        return users;\n    }\n\n    return {\n        addUser,\n        getUsers\n    };\n})();\n\nexport default UserService;\n</code></pre> <pre><code>// main.js\nimport UserService from './UserService.js';\n\nUserService.addUser({ name: 'John', age: 30 });\nUserService.addUser({ name: 'Jane', age: 25 });\nconsole.log(UserService.getUsers()); // [{ name: 'John', age: 30 }, { name: 'Jane', age: 25 }]\n</code></pre> <p>When to Use:</p> <ul> <li>Whenever you need to manage different pieces of functionality in your app separately (e.g., user management, data fetching).</li> </ul>"},{"location":"designpattern/js/#2-observer-pattern","title":"2. Observer Pattern","text":"<p>The Observer Pattern is useful when you have multiple parts of your app that need to react to changes, like a UI updating in response to data changes.</p> Simple ExampleSubject.jsObserver.jsmain.js <pre><code>// Subject.js\nclass Subject {\n    constructor() {\n        this.observers = [];\n    }\n\n    subscribe(observer) {\n        this.observers.push(observer);\n    }\n\n    notify(data) {\n        this.observers.forEach(observer =&gt; observer.update(data));\n    }\n}\n\n// Observer.js\nclass Observer {\n    update(data) {\n        console.log('Received data:', data);\n    }\n}\n\n// Usage\nconst subject = new Subject();\nconst observer1 = new Observer();\nconst observer2 = new Observer();\n\nsubject.subscribe(observer1);\nsubject.subscribe(observer2);\n\nsubject.notify('New Data Available');\n// Both observers will log: \"Received data: New Data Available\"\n</code></pre> <pre><code>// Subject.js\nclass Subject {\n    constructor() {\n        this.observers = [];\n    }\n\n    subscribe(observer) {\n        this.observers.push(observer);\n    }\n\n    notify(data) {\n        this.observers.forEach(observer =&gt; observer.update(data));\n    }\n}\n\nexport default Subject;\n</code></pre> <pre><code>// Observer.js\nclass Observer {\n    update(data) {\n        console.log('Received data:', data);\n    }\n}\n\nexport default Observer;\n</code></pre> <pre><code>// main.js\nimport Subject from './Subject.js';\nimport Observer from './Observer.js';\n\nconst subject = new Subject();\nconst observer1 = new Observer();\nconst observer2 = new Observer();\n\nsubject.subscribe(observer1);\nsubject.subscribe(observer2);\n\nsubject.notify('New Data Available');\n// Both observers will log: \"Received data: New Data Available\"\n</code></pre> <p>When to Use:</p> <ul> <li>Use it when you need to notify multiple components or modules when a certain event occurs (e.g., real-time notifications or data updates).</li> </ul>"},{"location":"designpattern/js/#3-factory-pattern","title":"3. Factory Pattern","text":"<p>The Factory Pattern is helpful when you need to create different types of objects based on certain conditions, like different kinds of UI components or products.</p> Simple ExampleButtonFactory.jsmain.js <pre><code>// ButtonFactory.js\nfunction ButtonFactory(type) {\n    if (type === 'primary') {\n        return { text: 'Primary Button', style: 'blue' };\n    } else if (type === 'secondary') {\n        return { text: 'Secondary Button', style: 'gray' };\n    } else {\n        return { text: 'Default Button', style: 'default' };\n    }\n}\n\n// Usage\nconst primaryButton = ButtonFactory('primary');\nconst secondaryButton = ButtonFactory('secondary');\n\nconsole.log(primaryButton); // { text: 'Primary Button', style: 'blue' }\nconsole.log(secondaryButton); // { text: 'Secondary Button', style: 'gray' }\n</code></pre> <pre><code>// ButtonFactory.js\nfunction ButtonFactory(type) {\n    if (type === 'primary') {\n        return { text: 'Primary Button', style: 'blue' };\n    } else if (type === 'secondary') {\n        return { text: 'Secondary Button', style: 'gray' };\n    } else {\n        return { text: 'Default Button', style: 'default' };\n    }\n}\n\nexport default ButtonFactory;\n</code></pre> <pre><code>// main.js\nimport ButtonFactory from './ButtonFactory.js';\n\nconst primaryButton = ButtonFactory('primary');\nconst secondaryButton = ButtonFactory('secondary');\n\nconsole.log(primaryButton); // { text: 'Primary Button', style: 'blue' }\nconsole.log(secondaryButton); // { text: 'Secondary Button', style: 'gray' }\n</code></pre> <p>When to Use:</p> <ul> <li>When you need to create objects based on some conditions, such as dynamically generating UI elements (e.g., buttons, forms).</li> </ul>"},{"location":"designpattern/js/#4-singleton-pattern","title":"4. Singleton Pattern","text":"<p>The Singleton Pattern is useful when you need a single instance of an object or service across your entire application, like a logger or configuration manager.</p> Simple ExampleLogger.jsmain.js <pre><code>// Logger.js (Singleton)\nconst Logger = (function () {\n    let instance;\n\n    function createInstance() {\n        return {\n        log: function (message) {\n            console.log(\"Log message:\", message);\n        },\n        };\n    }\n\n    return {\n        getInstance: function () {\n        if (!instance) {\n            instance = createInstance();\n        }\n        return instance;\n        },\n    };\n})();\n\n// Usage\nconst logger1 = Logger.getInstance();\nconst logger2 = Logger.getInstance();\n\nlogger1.log(\"This is the first log\"); // \"Log message: This is the first log\"\nlogger2.log(\"This is the second log\"); // \"Log message: This is the second log\"\n\nconsole.log(logger1 === logger2); // true (same instance)\n</code></pre> <pre><code>// Logger.js\nconst Logger = (function() {\n    let instance;\n\n    function createInstance() {\n        return {\n            log: function(message) {\n                console.log('Log message:', message);\n            }\n        };\n    }\n\n    return {\n        getInstance: function() {\n            if (!instance) {\n                instance = createInstance();\n            }\n            return instance;\n        }\n    };\n})();\n\nexport default Logger;\n</code></pre> <pre><code>// main.js\nimport Logger from './Logger.js';\n\nconst logger1 = Logger.getInstance();\nconst logger2 = Logger.getInstance();\n\nlogger1.log('This is the first log');  // \"Log message: This is the first log\"\nlogger2.log('This is the second log'); // \"Log message: This is the second log\"\n\nconsole.log(logger1 === logger2); // true (same instance)\n</code></pre> <p>When to Use:</p> <ul> <li>Use it when you need a shared instance of an object (e.g., a logging service or configuration settings) throughout your app.</li> </ul>"},{"location":"designpattern/js/#5-decorator-pattern","title":"5. Decorator Pattern","text":"<p>The Decorator Pattern allows you to add extra functionality to an existing object without modifying its structure, like adding logging or validation.</p> Simple ExamplelogDecorator.jsgreet.jsmain.js <pre><code>// Original function\nfunction greet(name) {\n    return `Hello, ${name}`;\n}\n\n// Decorator to log function calls\nfunction logDecorator(fn) {\n    return function (...args) {\n        console.log(`Calling function with args: ${args}`);\n        return fn(...args);\n    };\n}\n\n// Usage\nconst decoratedGreet = logDecorator(greet);\nconsole.log(decoratedGreet(\"John\")); // \"Calling function with args: John\" followed by \"Hello, John\"\n</code></pre> <pre><code>// logDecorator.js\nfunction logDecorator(fn) {\n    return function(...args) {\n        console.log(`Calling function with args: ${args}`);\n        return fn(...args);\n    };\n}\n\nexport default logDecorator;\n</code></pre> <pre><code>// greet.js\nfunction greet(name) {\n    return `Hello, ${name}`;\n}\n\nexport default greet;\n</code></pre> <pre><code>// main.js\nimport logDecorator from './logDecorator.js';\nimport greet from './greet.js';\n\nconst decoratedGreet = logDecorator(greet);\nconsole.log(decoratedGreet('John'));  // \"Calling function with args: John\" followed by \"Hello, John\"\n</code></pre> <p>When to Use:</p> <ul> <li>When you need to add extra functionality (e.g., logging, validation, caching) to existing functions or methods without altering their core logic.</li> </ul> File Explained <p>This folder structure with file names makes it easier to integrate design patterns into your daily JavaScript workflow. Here's a summary of file names and what they do:</p> <ol> <li>Module Pattern: Encapsulate logic in modules (<code>UserService.js</code>).</li> <li>Observer Pattern: Build an event-driven system with subscribers (<code>Subject.js</code>, <code>Observer.js</code>).</li> <li>Factory Pattern: Dynamically create objects based on input (<code>ButtonFactory.js</code>).</li> <li>Singleton Pattern: Ensure only one instance of a service or resource (<code>Logger.js</code>).</li> <li>Decorator Pattern: Add functionality to functions without changing them (<code>logDecorator.js</code>, <code>greet.js</code>).</li> </ol> <p>By splitting your project into smaller, pattern-based files, you'll achieve better maintainability and code organization in large-scale applications.</p>"},{"location":"designpattern/js/#conclusion","title":"Conclusion:","text":"<p>Here\u2019s how you can use these design patterns in daily JavaScript applications:</p> <ol> <li>Module Pattern: Organize your code into reusable modules, great for services like user management or API handling.</li> <li>Observer Pattern: Use when you need event-driven behavior, like updating multiple parts of the UI when data changes.</li> <li>Factory Pattern: Dynamically create objects based on conditions, perfect for generating UI components.</li> <li>Singleton Pattern: Ensure only one instance of a service or configuration manager is created, such as a logger.</li> <li>Decorator Pattern: Add extra functionality to existing objects (e.g., logging, validation) without modifying their structure.</li> </ol> <p>These patterns help make your code more structured, maintainable, and scalable as your JavaScript applications grow.</p>"},{"location":"designpattern/mnemonic/","title":"Mnemonic","text":""},{"location":"designpattern/mnemonic/#creational-patterns","title":"Creational Patterns:","text":"<p>Some Fat Cats Paint Beautiful Canvases</p> <ul> <li>Singleton</li> <li>Factory</li> <li>Constructor</li> <li>Prototype</li> <li>Builder</li> </ul>"},{"location":"designpattern/mnemonic/#structural-patterns","title":"Structural Patterns:","text":"<p>Many Friendly Dogs Are Full of Pretty Energy</p> <ul> <li>Module</li> <li>Facade</li> <li>Decorator</li> <li>Adapter</li> <li>Flyweight</li> <li>Proxy</li> <li>Event Delegation</li> </ul>"},{"location":"designpattern/mnemonic/#behavioral-patterns","title":"Behavioral Patterns:","text":"<p>Only Sweet Dogs Make Super Cute Hugs</p> <ul> <li>Observer</li> <li>Strategy</li> <li>Decorator</li> <li>Mediator</li> <li>State</li> <li>Chain of Responsibility</li> <li>Handler (Command)</li> </ul>"},{"location":"designpattern/mnemonic/#most-used-design-patterns","title":"Most Used Design Patterns","text":"<p>As a beginner, it\u2019s essential to focus on the most commonly used design patterns in JavaScript. Below are the most used design patterns from each category, along with examples of how you can use them.</p>"},{"location":"designpattern/mnemonic/#1-creational-pattern-factory-pattern","title":"1. Creational Pattern: Factory Pattern","text":"<ul> <li>Purpose: The Factory Pattern provides a way to create objects without exposing the exact class or constructor used, which makes the code more flexible.</li> <li>When to use: When you need to create different types of objects based on certain conditions.</li> </ul> Example <pre><code>function Car(type) {\n    this.type = type;\n    this.drive = function () {\n        console.log(\"Driving a \" + this.type);\n    };\n}\n\nfunction CarFactory() {\n    this.createCar = function (type) {\n        if (type === \"sedan\") {\n            return new Car(\"Sedan\");\n        } else if (type === \"suv\") {\n            return new Car(\"SUV\");\n        } else {\n            return new Car(\"Unknown type\");\n        }\n    };\n}\n\n// Usage\nconst factory = new CarFactory();\nconst sedan = factory.createCar(\"sedan\");\nconst suv = factory.createCar(\"suv\");\n\nsedan.drive(); // Output: Driving a Sedan\nsuv.drive(); // Output: Driving an SUV\n</code></pre> <p>As a Beginner:</p> <p>Use the Factory Pattern when you want to avoid the complexity of handling object creation for different types and want a centralized way to create instances.</p>"},{"location":"designpattern/mnemonic/#2-structural-pattern-module-pattern","title":"2. Structural Pattern: Module Pattern","text":"<ul> <li>Purpose: The Module Pattern allows you to create private and public variables and methods by using closures.</li> <li>When to use: When you need to encapsulate code, keeping some variables private and exposing only the necessary functions or variables.</li> </ul> Example <pre><code>const calculatorModule = (function() {\n    let result = 0; // Private variable\n\n    return {\n        add: function(x) {\n            result += x;\n            return result;\n        },\n        subtract: function(x) {\n            result -= x;\n            return result;\n        },\n        getResult: function() {\n            return result;\n        }\n    };\n})();\n\n// Usage\ncalculatorModule.add(10); // 10\ncalculatorModule.subtract(3); // 7\nconsole.log(calculatorModule.getResult()); // Output: 7\n</code></pre> <p>As a Beginner:</p> <p>Use the Module Pattern to organize your code into a clean structure. It\u2019s perfect for creating reusable libraries or utilities, especially when you want to hide implementation details.</p>"},{"location":"designpattern/mnemonic/#3-behavioral-pattern-observer-pattern","title":"3. Behavioral Pattern: Observer Pattern","text":"<ul> <li>Purpose: The Observer Pattern allows one object (subject) to notify other objects (observers) when its state changes.</li> <li>When to use: When you have multiple parts of your application that need to react to changes in the state of an object (e.g., event handling).</li> </ul> Example <pre><code>class Subject {\n    constructor() {\n        this.observers = [];\n    }\n\n    subscribe(observer) {\n        this.observers.push(observer);\n    }\n\n    unsubscribe(observer) {\n        this.observers = this.observers.filter((obs) =&gt; obs !== observer);\n    }\n\n    notify(data) {\n        this.observers.forEach((observer) =&gt; observer.update(data));\n    }\n}\n\nclass Observer {\n    update(data) {\n        console.log(\"Observer received data:\", data);\n    }\n}\n\n// Usage\nconst subject = new Subject();\nconst observer1 = new Observer();\nconst observer2 = new Observer();\n\nsubject.subscribe(observer1);\nsubject.subscribe(observer2);\n\nsubject.notify(\"Hello Observers\"); // Output: Observer received data: Hello Observers (twice)\n</code></pre> <p>As a Beginner:</p> <p>Use the Observer Pattern in event-driven applications, such as when building event handlers or pub-sub systems where you need to notify multiple objects of state changes.</p>"},{"location":"designpattern/mnemonic/#4-concurrency-pattern-promises","title":"4. Concurrency Pattern: Promises","text":"<ul> <li>Purpose: Promises simplify asynchronous operations, allowing for cleaner and more manageable code when dealing with tasks like fetching data.</li> <li>When to use: When handling asynchronous operations such as API calls or setTimeout, and you want to avoid callback hell.</li> </ul> Example <pre><code>function fetchData() {\n    return new Promise((resolve, reject) =&gt; {\n        setTimeout(() =&gt; {\n            resolve(\"Data fetched successfully!\");\n        }, 1000);\n    });\n}\n\n// Usage\nfetchData()\n.then((data) =&gt; {\n    console.log(data); // Output: Data fetched successfully!\n})\n.catch((error) =&gt; {\n    console.error(\"Error:\", error);\n});\n</code></pre> <p>As a Beginner:</p> <p>Use Promises to handle asynchronous code without nesting callbacks. This improves readability and maintainability in JavaScript when working with APIs or delayed actions.</p>"},{"location":"designpattern/mnemonic/#5-architectural-pattern-mvc-model-view-controller","title":"5. Architectural Pattern: MVC (Model-View-Controller)","text":"<ul> <li>Purpose: The MVC pattern separates your application into three parts: Model (data), View (UI), and Controller (business logic), allowing for better separation of concerns.</li> <li>When to use: When building web applications where you want to organize your code based on user interface, data, and logic separation.</li> </ul> Example (Simplified MVC in vanilla JS): <pre><code>// Model\nconst model = {\n    items: [],\n    addItem(item) {\n        this.items.push(item);\n        controller.updateView();\n    },\n};\n\n// View\nconst view = {\n    render(items) {\n        const list = document.getElementById(\"item-list\");\n        list.innerHTML = items.map((item) =&gt; `&lt;li&gt;${item}&lt;/li&gt;`).join(\"\");\n    },\n};\n\n// Controller\nconst controller = {\n    addItem(item) {\n        model.addItem(item);\n    },\n    updateView() {\n        view.render(model.items);\n    },\n};\n\n// Usage (Assume there's an input and button in the HTML)\ndocument.getElementById(\"add-btn\").addEventListener(\"click\", () =&gt; {\n    const item = document.getElementById(\"item-input\").value;\n    controller.addItem(item);\n});\n</code></pre> <p>As a Beginner:</p> <p>Use MVC when building larger applications to keep your code organized and maintainable by separating the concerns of data, UI, and logic.</p>"},{"location":"designpattern/mnemonic/#summary-of-common-patterns-to-focus-on-as-a-beginner","title":"Summary of Common Patterns to Focus on as a Beginner:","text":"<ol> <li>Factory Pattern (Creational) \u2013 Helps with flexible object creation.</li> <li>Module Pattern (Structural) \u2013 Encapsulates code and organizes it.</li> <li>Observer Pattern (Behavioral) \u2013 Handles event-driven updates.</li> <li>Promises (Concurrency) \u2013 Simplifies asynchronous tasks.</li> <li>MVC (Architectural) \u2013 Organizes web applications for separation of concerns.</li> </ol> <p>Mastering these design patterns will give you a strong foundation for writing clean, maintainable, and efficient JavaScript code!</p>"},{"location":"designpattern/official/","title":"Official","text":""},{"location":"designpattern/official/#design-patterns","title":"Design patterns","text":"<p>Most languages have their set of anti-patterns. Based on the kind of problems that they solve, design patterns were categorized into a few broad categories by the GOF:</p> <ul> <li> <p>Creational design patterns: These patterns deal with various mechanisms of object creation. While most languages provide basic object creation methods, these patterns look at optimized or more controlled mechanisms of object creation.</p> </li> <li> <p>Structural design patterns: These patterns are all about the composition of objects and relationships among them. The idea is to have minimal impact on overall object relationships when something in the system changes.</p> </li> <li> <p>Behavioral design patterns: These patterns focus on the interdependency and communication between objects.</p> </li> </ul> <p>The following table is a useful ready reckoner to identify categories of patterns</p> <p>Creational patterns:</p> <ul> <li>Factory method</li> <li>Abstract factory</li> <li>Builder</li> <li>Prototype</li> <li>Singleton</li> </ul> <p>Structural patterns:</p> <ul> <li>Adapter</li> <li>Bridge</li> <li>Composite</li> <li>Decorator</li> <li>Fa\u00e7ade</li> <li>Flyweight</li> <li>Proxy</li> </ul> <p>Behavioral patterns</p> <ul> <li>Interpreter</li> <li>Template method</li> <li>Chain of responsibility</li> <li>Command</li> <li>Iterator</li> <li>Mediator</li> <li>Memento</li> <li>Observer</li> <li>State</li> <li>Strategy</li> <li>Visitor</li> </ul> <p>Some patterns that we will discuss in this chapter may not be part of this list as they are more specific to JavaScript or a variation of these classical patterns. Similarly, we will not discuss patterns that do not fit into JavaScript or are not in popular use.</p>"},{"location":"designpattern/advanced/recall/","title":"Recall","text":""},{"location":"designpattern/advanced/recall/#overview","title":"Overview","text":"<p>Remembering and recalling design patterns, especially in JavaScript, can be challenging at first due to the variety and complexity of patterns. However, there are several strategies that can help you master and efficiently recall them when needed.</p> <p>Here are some techniques to help with remembering and recalling design patterns:</p>"},{"location":"designpattern/advanced/recall/#1-understand-the-problem-the-pattern-solves","title":"1. Understand the Problem the Pattern Solves","text":"<p>Instead of memorizing the pattern itself, focus on understanding the problem it solves and when it's typically used. This way, you'll know why you might need a particular pattern, which makes it easier to recall.</p> <ul> <li>Example: The Observer Pattern is often used when you have a situation where multiple objects (observers) need to be notified when a certain event happens (subject). If you understand this problem, recalling the pattern becomes easier.</li> </ul>"},{"location":"designpattern/advanced/recall/#2-group-patterns-by-category","title":"2. Group Patterns by Category","text":"<p>Design patterns can be grouped into different categories based on their purpose. If you understand which category a pattern belongs to, you\u2019ll have a quicker mental map for choosing and recalling the correct one.</p> <p>Here are common categories:</p> <ul> <li>Creational Patterns: These are about object creation (e.g., Singleton, Factory, Prototype).</li> <li>Structural Patterns: These are about organizing objects and classes (e.g., Decorator, Facade, Adapter).</li> <li>Behavioral Patterns: These are about object interaction and communication (e.g., Observer, Strategy, Command).</li> </ul> <p>Grouping patterns into categories will help you recall the appropriate one based on the kind of problem you're facing.</p>"},{"location":"designpattern/advanced/recall/#3-use-visual-aids-diagrams","title":"3. Use Visual Aids (Diagrams)","text":"<p>A lot of design patterns are easier to understand with <code>visual diagrams</code>. Many online resources, books, and tutorials provide <code>UML</code> diagrams that map out the relationships between the objects involved in each pattern.</p> <ul> <li> <p>For example, a <code>Factory Pattern</code> often has a central class (factory) that creates other objects based on certain conditions. Seeing this visually makes it easier to recall how to implement it.</p> </li> <li> <p>Create your own diagrams for each pattern or keep a reference of them, as visualizing the structure can reinforce memory.</p> </li> </ul>"},{"location":"designpattern/advanced/recall/#4-practice-implementing-the-patterns","title":"4. Practice Implementing the Patterns","text":"<p>Once you've understood a pattern, the best way to remember it is by <code>practicing</code>. Try solving small problems using different patterns. The more you use them, the more they will become second nature.</p> <ul> <li> <p>Example: Try building a small app that uses <code>Observer Pattern</code> for handling events. You can also implement a <code>Factory Pattern</code> for creating different types of objects.</p> </li> <li> <p>When you implement a pattern, make sure to write comments explaining how the pattern solves the problem. This will deepen your understanding and make it easier to recall later.</p> </li> </ul>"},{"location":"designpattern/advanced/recall/#5-use-analogies","title":"5. Use Analogies","text":"<p>Sometimes thinking of patterns in terms of real-world analogies can help make them stick. For example:</p> <ul> <li> <p>Singleton Pattern: Think of a <code>president</code> in a country\u2014there's only one president, and everyone has to communicate with that president, just like the Singleton ensures only one instance exists.</p> </li> <li> <p>Observer Pattern: Think of a <code>news subscription</code> service where multiple people (observers) are notified when a news article (subject) is published.</p> </li> </ul> <p>By relating patterns to everyday objects or concepts, you can more easily recall them when needed.</p>"},{"location":"designpattern/advanced/recall/#6-keep-a-pattern-cheat-sheet","title":"6. Keep a \"Pattern Cheat Sheet\"","text":"<p>Create or keep a quick reference cheat sheet or table of patterns. Include:</p> <ul> <li>Name of the pattern.</li> <li>Problem it solves.</li> <li>Example use cases.</li> <li>Key characteristics.</li> <li>A small code snippet or diagram.</li> </ul> <p>Having a quick reference will help you <code>recall the patterns</code> faster in real projects. You can create this as a personal document or find a pre-made one online.</p>"},{"location":"designpattern/advanced/recall/#7-learn-from-real-world-codebases","title":"7. Learn From Real-World Codebases","text":"<p>When working on real-world projects, <code>look at existing code</code> to see how and where design patterns are used. Reading and analyzing well-structured code can help you recognize when certain patterns are being applied and reinforce your understanding of them.</p> <ul> <li>Open-source projects (like on GitHub) often employ design patterns effectively. Try to find patterns like <code>Factory</code>, <code>Singleton</code>, or <code>Observer</code> in popular libraries and frameworks.</li> </ul>"},{"location":"designpattern/advanced/recall/#8-teach-others","title":"8. Teach Others","text":"<p>One of the best ways to solidify your understanding of design patterns is to teach them to others. When explaining a pattern, you\u2019ll need to clearly describe:</p> <ul> <li>What problem it solves.</li> <li>How it\u2019s implemented.</li> <li>Why it\u2019s useful.</li> </ul> <p>This will force you to recall and reframe the knowledge in your own words, deepening your understanding.</p>"},{"location":"designpattern/advanced/recall/#9-use-flashcards","title":"9. Use Flashcards","text":"<p>Flashcards are a great way to test yourself and reinforce your memory. You can create flashcards for each design pattern with:</p> <ul> <li>The <code>name</code> of the pattern on one side.</li> <li>The <code>description</code> and <code>use case</code> on the other side.</li> </ul> <p>Apps like Anki or Quizlet can be used to create digital flashcards. You can test yourself periodically to reinforce recall.</p>"},{"location":"designpattern/advanced/recall/#10-start-with-common-patterns","title":"10. Start with Common Patterns","text":"<p>Focus on learning and mastering the most common patterns first, as these are most likely to be used in practice. Some of the most common ones are:</p> <ul> <li>Singleton</li> <li>Observer</li> <li>Factory</li> <li>Decorator</li> <li>Strategy</li> </ul> <p>Once you're comfortable with these, expanding your knowledge to other patterns like Command, Facade, or State will be easier.</p>"},{"location":"designpattern/advanced/recall/#11-pair-programming","title":"11. Pair Programming","text":"<p>If you work with a team, engaging in pair programming can be helpful. In a pair programming session, you can discuss how to apply different patterns in real-time. Explaining the patterns and working through the code together can reinforce your understanding and recall.</p>"},{"location":"designpattern/advanced/recall/#12-refactor-code-using-design-patterns","title":"12. Refactor Code Using Design Patterns","text":"<p>As you gain experience, try refactoring old code with design patterns. You might initially write a function that is simple and works, but over time, you can identify areas that would benefit from a specific pattern.</p> <ul> <li>Example: If you have a lot of repetitive object creation code, refactor it to use the Factory Pattern. If your code has a lot of conditional behavior, try using the Strategy Pattern to clean it up.</li> </ul>"},{"location":"designpattern/advanced/recall/#13-use-pattern-driven-development-pdd","title":"13. Use Pattern-Driven Development (PDD)","text":"<p>Instead of just learning patterns in isolation, try applying them directly in the context of your software development process. Pattern-driven development means consciously choosing the best patterns as part of your daily coding process.</p> <ul> <li>As you build applications, always think about which design pattern could solve a particular problem. This active engagement will help you internalize the patterns more effectively.</li> </ul>"},{"location":"designpattern/advanced/recall/#summary-of-key-tips","title":"Summary of Key Tips:","text":"<ul> <li>Understand the problem the pattern solves.</li> <li>Group patterns by category to make them easier to recall.</li> <li>Use visual diagrams to better understand the relationships in each pattern.</li> <li>Practice implementing the patterns regularly.</li> <li>Use analogies from real life to relate the patterns to common concepts.</li> <li>Create a Pattern Cheat Sheet for quick reference.</li> <li>Read real-world code to see patterns in action.</li> <li>Teach others or discuss patterns to solidify your understanding.</li> <li>Use flashcards for active recall and review.</li> <li>Start with the most common patterns and gradually expand.</li> <li>Use pair programming or collaborate with peers to reinforce patterns.</li> <li>Refactor code using patterns to reinforce learning.</li> <li>Embrace Pattern-Driven Development by consciously applying patterns in your work.</li> </ul> <p>By using these strategies, you'll be able to internalize design patterns in JavaScript and effectively recall and apply them when solving problems in your code.</p>"},{"location":"designpattern/creational/factory/","title":"Intro","text":""},{"location":"designpattern/creational/factory/#the-factory-pattern","title":"The Factory Pattern","text":"<p>The Factory pattern is another creational pattern concerned with the notion of creating objects</p> <p></p> <pre><code>function ShapeFactory() {\n  return {\n    createCircle() {\n      return { type: \"circle\", draw: () =&gt; console.log(\"Drawing a circle\") };\n    },\n    createSquare() {\n      return { type: \"square\", draw: () =&gt; console.log(\"Drawing a square\") };\n    },\n  };\n}\n\nfunction ColorFactory() {\n  return {\n    createRed() {\n      return { color: \"red\", apply: () =&gt; console.log(\"Applying red color\") };\n    },\n    createBlue() {\n      return { color: \"blue\", apply: () =&gt; console.log(\"Applying blue color\") };\n    },\n  };\n}\n\n// Abstract Factory\nfunction FactoryProducer() {\n  return {\n    getFactory(factoryType) {\n      switch (factoryType) {\n        case \"shape\":\n          return ShapeFactory();\n        case \"color\":\n          return ColorFactory();\n        default:\n          throw new Error(\"Unknown factory type\");\n      }\n    },\n  };\n}\n\nconst factoryProducer = FactoryProducer();\nconst shapeFactory = factoryProducer.getFactory(\"shape\");\nconst circle = shapeFactory.createCircle();\ncircle.draw(); // Drawing a circle\n\nconst colorFactory = factoryProducer.getFactory(\"color\");\nconst red = colorFactory.createRed();\nred.apply(); // Applying red color\n</code></pre> <p></p> <p>Which One Should You Start With?</p> <p>Start with the Module Pattern, as it aligns closely with modern JavaScript modules (<code>import/export</code>) and is essential for organizing code effectively. Once you're comfortable, explore Singleton and Factory for more specialized use cases.</p>"},{"location":"designpattern/creational/factory/#reference","title":"Reference","text":"<ul> <li>The Factory Pattern: Learning JavaScript Design Patterns by Addy Osmani</li> </ul>"},{"location":"designpattern/react/antd-resuable-component/","title":"antd component","text":""},{"location":"designpattern/react/antd-resuable-component/#overview","title":"Overview","text":"<p>In Ant Design (Antd), there are several components that can be customized to suit the specific needs of your application. Customizing these components can help you provide a more cohesive, brand-aligned, or feature-rich experience for your users.</p> <p>Below are some key components in Ant Design that are commonly customized, along with the reasons why customization can be important and beneficial:</p>"},{"location":"designpattern/react/antd-resuable-component/#1-button","title":"1. Button","text":"<ul> <li> <p>Customizations:</p> <ul> <li>Change the button\u2019s shape, size, or style.</li> <li>Add icons or images as prefixes/suffixes.</li> <li>Customize loading states (e.g., spinner in the button).</li> <li>Conditional button styles (e.g., red for delete, green for add).</li> </ul> </li> <li> <p>Benefits:</p> <ul> <li>Customizing buttons helps in improving the user experience by making them visually appealing, functional (e.g., adding icons), and aligned with the overall design system of your app.</li> </ul> </li> </ul> <pre><code>const CustomButton = ({ icon, type, loading, children }) =&gt; (\n  &lt;Button\n    type={type}\n    icon={icon}\n    loading={loading}\n    style={{ borderRadius: \"8px\" }}\n  &gt;\n    {children}\n  &lt;/Button&gt;\n);\n</code></pre> ExampleUsage <pre><code>import React from 'react';\nimport { Button } from 'antd';\nimport { ArrowUpOutlined, ArrowDownOutlined } from '@ant-design/icons';\n\n// Custom Button Component\nconst CustomButton = ({ type, icon, children, onClick }) =&gt; (\n    &lt;Button\n        type={type}\n        icon={icon}\n        onClick={onClick}\n        style={{ borderRadius: '8px', margin: '5px', padding: '10px 20px' }}\n    &gt;\n        {children}\n    &lt;/Button&gt;\n);\n\nexport default CustomButton;\n</code></pre> <pre><code>import React from 'react';\nimport CustomButton from './CustomButton'; // Path to your CustomButton component\n\nconst App = () =&gt; (\n    &lt;div&gt;\n        &lt;h2&gt;Custom Button Example&lt;/h2&gt;\n\n        &lt;CustomButton\n            type=\"primary\"\n            icon={&lt;ArrowUpOutlined /&gt;}\n            onClick={() =&gt; alert('Up Clicked')}\n        &gt;\n            Increase Value\n        &lt;/CustomButton&gt;\n\n        &lt;CustomButton\n            type=\"danger\"\n            icon={&lt;ArrowDownOutlined /&gt;}\n            onClick={() =&gt; alert('Down Clicked')}\n        &gt;\n            Decrease Value\n        &lt;/CustomButton&gt;\n    &lt;/div&gt;\n);\n\nexport default App;\n</code></pre>"},{"location":"designpattern/react/antd-resuable-component/#2-input","title":"2. Input","text":"<ul> <li> <p>Customizations:</p> <ul> <li>Add custom validation logic, placeholders, or tooltips.</li> <li>Style the input field (e.g., border-radius, colors, focus states).</li> <li>Add custom icons or clear functionality.</li> </ul> </li> <li> <p>Benefits:</p> <ul> <li>Inputs are used throughout any app, and consistent styling with custom validation or error handling improves form usability.</li> <li>Custom input components can provide specific features like auto-formatting, masking, or integrating with custom libraries (e.g., phone number input, date pickers).</li> </ul> </li> </ul> <pre><code>const CustomInput = ({ value, onChange, placeholder }) =&gt; (\n  &lt;Input\n    value={value}\n    onChange={onChange}\n    placeholder={placeholder}\n    style={{ borderRadius: \"4px\" }}\n  /&gt;\n);\n</code></pre> ExampleUsage <pre><code>import React from 'react';\nimport { Input } from 'antd';\n\n// Custom Input Component\nconst CustomInput = ({ placeholder, value, onChange, style }) =&gt; (\n    &lt;Input\n        value={value}\n        onChange={onChange}\n        placeholder={placeholder}\n        style={{ ...style, borderRadius: '5px' }}\n    /&gt;\n);\n\nexport default CustomInput;\n</code></pre> <pre><code>import React, { useState } from 'react';\nimport CustomInput from './CustomInput';\n\nconst App = () =&gt; {\n    const [inputValue, setInputValue] = useState('');\n\n    return (\n        &lt;div&gt;\n            &lt;h2&gt;Custom Input Example&lt;/h2&gt;\n\n            &lt;CustomInput\n                placeholder=\"Type something...\"\n                value={inputValue}\n                onChange={e =&gt; setInputValue(e.target.value)}\n                style={{ width: '300px', marginBottom: '20px' }}\n            /&gt;\n\n            &lt;p&gt;You typed: {inputValue}&lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default App;\n</code></pre>"},{"location":"designpattern/react/antd-resuable-component/#3-select-dropdown","title":"3. Select / Dropdown","text":"<ul> <li> <p>Customizations:</p> <ul> <li>Custom dropdown item rendering (e.g., custom components, icons, or checkboxes).</li> <li>Asynchronous options loading (e.g., fetching from an API).</li> <li>Custom multi-select with tags.</li> </ul> </li> <li> <p>Benefits:</p> <ul> <li>Select components are often used for filtering and choosing options. Customizing them ensures a better user experience with tailored behavior, UI, and dynamic data handling.</li> </ul> </li> </ul> <pre><code>const CustomSelect = ({ options, value, onChange }) =&gt; (\n  &lt;Select value={value} onChange={onChange} style={{ width: 200 }}&gt;\n    {options.map((option) =&gt; (\n      &lt;Select.Option key={option.value} value={option.value}&gt;\n        {option.label}\n      &lt;/Select.Option&gt;\n    ))}\n  &lt;/Select&gt;\n);\n</code></pre> ExampleUsage <pre><code>import React from 'react';\nimport { Select } from 'antd';\n\n// Custom Select Component\nconst CustomSelect = ({ options, value, onChange }) =&gt; (\n    &lt;Select value={value} onChange={onChange} style={{ width: 200 }}&gt;\n        {options.map(option =&gt; (\n        &lt;Select.Option key={option.value} value={option.value}&gt;\n            {option.label}\n        &lt;/Select.Option&gt;\n        ))}\n    &lt;/Select&gt;\n);\n\nexport default CustomSelect;\n</code></pre> <pre><code>import React, { useState } from 'react';\nimport CustomSelect from './CustomSelect';\n\nconst App = () =&gt; {\n    const [selectedOption, setSelectedOption] = useState(null);\n\n    const options = [\n        { value: 'apple', label: 'Apple' },\n        { value: 'banana', label: 'Banana' },\n        { value: 'orange', label: 'Orange' }\n    ];\n\n    return (\n        &lt;div&gt;\n            &lt;h2&gt;Custom Select Example&lt;/h2&gt;\n\n            &lt;CustomSelect\n                options={options}\n                value={selectedOption}\n                onChange={setSelectedOption}\n            /&gt;\n\n            {selectedOption &amp;&amp; &lt;p&gt;You selected: {selectedOption}&lt;/p&gt;}\n        &lt;/div&gt;\n    );\n};\n\nexport default App;\n</code></pre>"},{"location":"designpattern/react/antd-resuable-component/#4-table","title":"4. Table","text":"<ul> <li> <p>Customizations:</p> <ul> <li>Custom cell rendering (e.g., to display different components like icons, buttons, or styled text).</li> <li>Custom pagination (e.g., showing a dropdown or changing the page size dynamically).</li> <li>Custom filtering, sorting, or search behavior.</li> </ul> </li> <li> <p>Benefits:</p> <ul> <li>Tables often contain complex data and require different ways of interacting with rows and columns. A custom table can allow you to integrate actions (edit, delete) directly inside rows or cells, as well as customize sorting and filtering functionality.</li> </ul> </li> </ul> <pre><code>const CustomTable = ({ data, columns }) =&gt; (\n  &lt;Table\n    dataSource={data}\n    columns={columns}\n    pagination={{ pageSize: 10 }}\n    rowKey=\"id\"\n    // Add custom logic for actions, sorting, etc.\n  /&gt;\n);\n</code></pre> ExampleUsage <pre><code>import React from 'react';\nimport { Table } from 'antd';\n\n// Custom Table Component\nconst CustomTable = ({ data, columns }) =&gt; (\n    &lt;Table\n        dataSource={data}\n        columns={columns}\n        pagination={{ pageSize: 5 }}\n        rowKey=\"id\"\n    /&gt;\n);\n\nexport default CustomTable;\n</code></pre> <pre><code>import React from 'react';\nimport CustomTable from './CustomTable';\n\nconst App = () =&gt; {\n    const data = [\n        { id: 1, name: 'John Doe', age: 28, address: 'New York' },\n        { id: 2, name: 'Jane Smith', age: 32, address: 'London' },\n        { id: 3, name: 'George White', age: 45, address: 'Paris' },\n        { id: 4, name: 'Mary Brown', age: 29, address: 'Berlin' },\n        { id: 5, name: 'James Black', age: 38, address: 'Tokyo' },\n    ];\n\n    const columns = [\n        { title: 'Name', dataIndex: 'name', key: 'name' },\n        { title: 'Age', dataIndex: 'age', key: 'age' },\n        { title: 'Address', dataIndex: 'address', key: 'address' }\n    ];\n\n    return (\n        &lt;div&gt;\n            &lt;h2&gt;Custom Table Example&lt;/h2&gt;\n\n            &lt;CustomTable data={data} columns={columns} /&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default App;\n</code></pre>"},{"location":"designpattern/react/antd-resuable-component/#5-modal","title":"5. Modal","text":"<ul> <li> <p>Customizations:</p> <ul> <li>Change modal content (e.g., dynamic content, images, forms).</li> <li>Add custom footer buttons or actions.</li> <li>Handle closing logic (e.g., close on escape, outside click).</li> </ul> </li> <li> <p>Benefits:</p> <ul> <li>Modals are used for displaying notifications, forms, and confirmation dialogs. Customizing modals gives you full control over how they behave, the layout, and the interactions (e.g., customizing the footer with different actions).</li> </ul> </li> </ul> <pre><code>const CustomModal = ({ visible, onCancel, onOk, title, children }) =&gt; (\n  &lt;Modal visible={visible} onCancel={onCancel} onOk={onOk} title={title}&gt;\n    {children}\n  &lt;/Modal&gt;\n);\n</code></pre> ExampleUsage <pre><code>import React from 'react';\nimport { Modal, Button } from 'antd';\n\n// Custom Modal Component\nconst CustomModal = ({ visible, onClose, title, children, footer }) =&gt; (\n    &lt;Modal\n        visible={visible}\n        onCancel={onClose}\n        title={title}\n        footer={footer || [\n            &lt;Button key=\"cancel\" onClick={onClose}&gt;Cancel&lt;/Button&gt;,\n            &lt;Button key=\"ok\" type=\"primary\" onClick={onClose}&gt;OK&lt;/Button&gt;\n        ]}\n    &gt;\n        {children}\n    &lt;/Modal&gt;\n);\n\nexport default CustomModal;\n</code></pre> <pre><code>import React, { useState } from 'react';\nimport CustomModal from './CustomModal';\nimport { Button } from 'antd';\n\nconst App = () =&gt; {\n    const [modalVisible, setModalVisible] = useState(false);\n\n    return (\n        &lt;div&gt;\n            &lt;h2&gt;Custom Modal Example&lt;/h2&gt;\n\n            &lt;Button type=\"primary\" onClick={() =&gt; setModalVisible(true)}&gt;\n                Open Modal\n            &lt;/Button&gt;\n\n            &lt;CustomModal\n                visible={modalVisible}\n                onClose={() =&gt; setModalVisible(false)}\n                title=\"Custom Modal\"\n                footer={null} // You can also customize the footer\n            &gt;\n                &lt;p&gt;This is a custom modal with no footer.&lt;/p&gt;\n            &lt;/CustomModal&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default App;\n</code></pre>"},{"location":"designpattern/react/antd-resuable-component/#6-tooltip","title":"6. Tooltip","text":"<ul> <li> <p>Customizations:</p> <ul> <li>Custom content (e.g., rendering HTML or images).</li> <li>Change positioning (e.g., top, bottom, left, right).</li> <li>Add interactive elements like buttons or links inside tooltips.</li> </ul> </li> <li> <p>Benefits:</p> <ul> <li>Tooltips provide additional information on hover. Customizing tooltips can make them more informative, interactive, or visually aligned with your design.</li> </ul> </li> </ul> <pre><code>const CustomTooltip = ({ title, children }) =&gt; (\n  &lt;Tooltip title={title} placement=\"top\"&gt;\n    {children}\n  &lt;/Tooltip&gt;\n);\n</code></pre> ExampleUsage <pre><code>\n</code></pre> <pre><code>\n</code></pre>"},{"location":"designpattern/react/antd-resuable-component/#7-card","title":"7. Card","text":"<ul> <li> <p>Customizations:</p> <ul> <li>Custom headers, footers, or content.</li> <li>Add custom styling like background color, borders, or shadows.</li> <li>Add actions, buttons, or links within the card.</li> </ul> </li> <li> <p>Benefits:</p> <ul> <li>Cards are a great way to display grouped content. Customizing them allows you to adjust layouts, add different interactive elements, and make them align with your application's visual language.</li> </ul> </li> </ul> <pre><code>const CustomCard = ({ title, content, footer }) =&gt; (\n  &lt;Card title={title} extra={footer} style={{ width: 300 }}&gt;\n    {content}\n  &lt;/Card&gt;\n);\n</code></pre> ExampleUsage <pre><code>\n</code></pre> <pre><code>\n</code></pre>"},{"location":"designpattern/react/antd-resuable-component/#8-notification-alert","title":"8. Notification / Alert","text":"<ul> <li> <p>Customizations:</p> <ul> <li>Custom icons or action buttons.</li> <li>Dynamic styling based on notification type (error, success, info).</li> <li>Add custom close behavior or durations.</li> </ul> </li> <li> <p>Benefits:</p> <ul> <li>Notifications and alerts are critical for providing feedback to users. Customizing them ensures you can control their behavior, appearance, and make them more informative or interactive.</li> </ul> </li> </ul> <pre><code>const CustomNotification = ({ message, description, type }) =&gt; (\n  &lt;Notification\n    message={message}\n    description={description}\n    type={type}\n    duration={4.5}\n  /&gt;\n);\n</code></pre> ExampleUsage <pre><code>import React from 'react';\nimport { notification, Button } from 'antd';\n\n// Custom Notification Component\nconst CustomNotification = ({ message, description, type }) =&gt; {\n    notification[type]({\n        message: message,\n        description: description,\n        duration: 3\n    });\n};\n\nexport default CustomNotification;\n</code></pre> <pre><code>import React from 'react';\nimport CustomNotification from './CustomNotification';\nimport { Button } from 'antd';\n\nconst App = () =&gt; (\n    &lt;div&gt;\n        &lt;h2&gt;Custom Notification Example&lt;/h2&gt;\n\n        &lt;Button onClick={() =&gt; CustomNotification({ message: 'Success', description: 'Your action was successful.', type: 'success' })}&gt;\n            Show Success Notification\n        &lt;/Button&gt;\n\n        &lt;Button onClick={() =&gt; CustomNotification({ message: 'Error', description: 'Something went wrong.', type: 'error' })}&gt;\n            Show Error Notification\n        &lt;/Button&gt;\n    &lt;/div&gt;\n);\n\nexport default App;\n</code></pre>"},{"location":"designpattern/react/antd-resuable-component/#9-progress","title":"9. Progress","text":"<ul> <li> <p>Customizations:</p> <ul> <li>Add custom labels or statuses.</li> <li>Add custom labels or statuses.</li> <li>Display custom icons or text inside the progress bar.</li> </ul> </li> <li> <p>Benefits:</p> <ul> <li>Progress bars are useful for showing tasks or processes. Customizing them helps to display dynamic stages or give more context to the progress.</li> </ul> </li> </ul> <pre><code>const CustomProgress = ({ percent, status, label }) =&gt; (\n  &lt;Progress percent={percent} status={status} format={label} /&gt;\n);\n</code></pre> ExampleUsage <pre><code>\n</code></pre> <pre><code>\n</code></pre>"},{"location":"designpattern/react/antd-resuable-component/#10-avatar","title":"10. Avatar","text":"<ul> <li> <p>Customizations:</p> <ul> <li>Dynamic sources for avatar images (e.g., fetching from a URL or API).</li> <li>Customize size, shape, or status (online/offline).</li> <li>Add initials or fallback icons.</li> </ul> </li> <li> <p>Benefits:</p> <ul> <li>Avatars are used for profile pictures or user representations. Customizing them can provide fallback images, add status indicators, or change sizes dynamically based on the context.</li> </ul> </li> </ul> <pre><code>const CustomAvatar = ({ src, size, status }) =&gt; (\n  &lt;Avatar\n    src={src}\n    size={size}\n    style={{ border: \"2px solid #f0f0f0\" }}\n    status={status}\n  /&gt;\n);\n</code></pre> ExampleUsage <pre><code>\n</code></pre> <pre><code>\n</code></pre>"},{"location":"designpattern/react/antd-resuable-component/#why-customize-these-components","title":"Why Customize These Components?","text":"<ul> <li>Consistency: Customizing common components (buttons, inputs, tables, modals) ensures that your application has a consistent UI, making it easier for users to interact with and understand.</li> <li>User Experience: You can optimize interaction flows and visual feedback by customizing component behaviors, such as adding loading states, icons, or improving accessibility.</li> <li>Brand Alignment: Customization allows you to tailor the look and feel of Ant Design components to fit your brand's design guidelines, improving the overall appearance and user engagement.</li> <li>Functionality: Some components (e.g., modals, tables, inputs) might need to handle custom logic like dynamic data fetching, validation, or interaction with APIs, which requires customization.</li> </ul>"},{"location":"designpattern/react/antd-resuable-component/#conclusion","title":"Conclusion:","text":"<p>The most beneficial components to customize in Ant Design largely depend on your application's needs, but typically, components like <code>Button</code>, <code>Input</code>, <code>Table</code>, <code>Select</code>, <code>Modal</code>, and <code>Card</code> offer significant customization opportunities that can enhance the user experience and align with your app\u2019s design system. Customizing them allows you to implement unique functionalities, tailor the look and feel, and ensure a smooth, consistent interaction flow.</p>"},{"location":"designpattern/react/container-presentation-theory/","title":"Presentation/Container 2","text":""},{"location":"designpattern/react/container-presentation-theory/#intro","title":"Intro","text":"Tip <p>Business logic should ideally be separated from presentation logic to keep the components clean, maintainable, and reusable (using patterns like <code>container/presentational</code> or custom hooks).</p> <p>Yes, the Presentation/Container Pattern and the Smart/Dumb Component Pattern essentially refer to the same concept in React, although the terminology differs slightly.</p>"},{"location":"designpattern/react/container-presentation-theory/#presentationcontainer-pattern","title":"Presentation/Container Pattern","text":"<ul> <li>Container components (also known as smart components) are responsible for handling logic, state management, side effects (like API calls), and passing data to child components.</li> <li>Presentation components (also known as dumb components) are focused purely on rendering UI and are often stateless. They receive data via props and don\u2019t manage any complex logic themselves.</li> </ul>"},{"location":"designpattern/react/container-presentation-theory/#smartdumb-component-pattern","title":"Smart/Dumb Component Pattern","text":"<ul> <li>Smart components are the ones that manage the application's state and logic, fetch data, handle events, etc. These components are \"aware\" of how the application works and are usually stateful.</li> <li>Dumb components are the simple components that only focus on how things look. They receive all their data and behavior via props and don\u2019t have any internal logic or state management. They are \"dumb\" in the sense that they don't manage any logic beyond rendering UI.</li> </ul>"},{"location":"designpattern/react/container-presentation-theory/#key-differences","title":"Key Differences:","text":"<ul> <li>Terminology: The Presentation/Container pattern focuses on the separation of concerns between logic and UI, while Smart/Dumb is more of a common React community terminology that implies which components manage state and behavior.</li> <li> <p>Functional Role: Both terms describe the same idea where:</p> <ul> <li>Smart (Container) components are responsible for the application\u2019s logic, state, and handling side effects.</li> <li>Dumb (Presentational) components are purely responsible for displaying the UI based on the data passed down from the parent.</li> </ul> </li> </ul>"},{"location":"designpattern/react/container-presentation-theory/#example-of-the-two-patterns","title":"Example of the Two Patterns:","text":""},{"location":"designpattern/react/container-presentation-theory/#1-containersmart-component-stateful","title":"1. Container/Smart Component (Stateful)","text":"<pre><code>import React, { useState, useEffect } from \"react\";\nimport TodoList from \"./TodoList\"; // Dumb/Presentational Component\n\nconst TodoContainer = () =&gt; {\n  const [todos, setTodos] = useState([]);\n\n  useEffect(() =&gt; {\n    fetch(\"/api/todos\")\n      .then((response) =&gt; response.json())\n      .then((data) =&gt; setTodos(data));\n  }, []);\n\n  return &lt;TodoList todos={todos} /&gt;;\n};\n\nexport default TodoContainer;\n</code></pre>"},{"location":"designpattern/react/container-presentation-theory/#2-presentationaldumb-component-stateless","title":"2. Presentational/Dumb Component (Stateless)","text":"<pre><code>import React from \"react\";\n\nconst TodoList = ({ todos }) =&gt; (\n  &lt;ul&gt;\n    {todos.map((todo) =&gt; (\n      &lt;li key={todo.id}&gt;{todo.text}&lt;/li&gt;\n    ))}\n  &lt;/ul&gt;\n);\n\nexport default TodoList;\n</code></pre>"},{"location":"designpattern/react/container-presentation-theory/#conclusion","title":"Conclusion:","text":"<ul> <li>Presentation/Container Pattern and Smart/Dumb Pattern are indeed the same.</li> <li>Smart (Container) components manage state, logic, and side effects.</li> <li>Dumb (Presentational) components focus purely on displaying UI.</li> </ul> <p>This pattern is useful for <code>maintainability</code>, <code>testability</code>, and <code>reusability</code> in larger React applications by decoupling UI rendering from business logic.</p>"},{"location":"designpattern/react/container-presentation/","title":"Presentation/Container","text":""},{"location":"designpattern/react/container-presentation/#intro","title":"Intro","text":"<p>In the Presentation/Container Pattern, the naming and structure of files are crucial for maintaining clarity and scalability in your project. While there isn't a strict standard enforced across all React projects, there are widely accepted best practices and conventions for organizing your files and naming components.</p> <p>Here\u2019s how you can structure your files and name your components in a way that follows the Presentation/Container Pattern:</p>"},{"location":"designpattern/react/container-presentation/#1-folder-structure","title":"1. Folder Structure","text":"<p>A common approach is to structure your components in a <code>containers/</code> and <code>components/</code> (or <code>presentational/</code>) folder. The containers will handle logic, while the presentational components will focus on UI rendering.</p> Example Folder Structure: <pre><code>src/\n\u2502\n\u251c\u2500\u2500 components/              # Presentational components\n\u2502   \u251c\u2500\u2500 Button.js            # Dumb component\n\u2502   \u251c\u2500\u2500 TodoItem.js          # Dumb component\n\u2502   \u2514\u2500\u2500 TodoList.js          # Dumb component\n\u2502\n\u251c\u2500\u2500 containers/              # Container components (stateful)\n\u2502   \u251c\u2500\u2500 TodoContainer.js     # Smart component\n\u2502\n\u2514\u2500\u2500 App.js                   # App component, which might use containers\n</code></pre> <p>In this structure:</p> <ul> <li><code>components/</code>: Contains dumb/presentational components that receive data via props and render it. These are reusable UI elements.</li> <li><code>containers/</code>: Contains smart/container components that manage state and handle business logic. These components typically pass props to the presentational components.</li> </ul>"},{"location":"designpattern/react/container-presentation/#2-naming-conventions","title":"2. Naming Conventions","text":""},{"location":"designpattern/react/container-presentation/#for-presentational-dumb-components","title":"For Presentational (Dumb) Components:","text":"<ul> <li>Name them based on what they represent or how they display information.</li> <li>Use descriptive, singular nouns or phrases.</li> <li>These components should be UI-centric and stateless (or minimally stateful, if needed for UI reasons like toggles, form inputs, etc.).</li> </ul> Example <ul> <li><code>TodoItem.js</code>: Displays an individual todo.</li> <li><code>Button.js</code>: A simple button component.</li> <li><code>Header.js:</code> Renders a header UI.</li> </ul> <pre><code>// components/TodoItem.js\nimport React from 'react';\n\nconst TodoItem = ({ todo }) =&gt; {\n    return &lt;li&gt;{todo.text}&lt;/li&gt;;\n};\n\nexport default TodoItem;\n</code></pre>"},{"location":"designpattern/react/container-presentation/#for-container-smart-components","title":"For Container (Smart) Components:","text":"<ul> <li>Name them based on their function or the data they manage.</li> <li>The name should describe the container's responsibility (e.g., managing todos, user info).</li> <li>It is common to name them with the suffix <code>Container</code> (e.g., <code>TodoContainer.js</code> or <code>UserContainer.js</code>).</li> </ul> Example <ul> <li><code>TodoContainer.js</code>: Fetches and manages the todo list, passing data to TodoItem.</li> <li><code>UserContainer.js</code>: Manages the user authentication and data, passing data to a presentational component like <code>UserProfile</code>.</li> </ul> <pre><code>// containers/TodoContainer.js\nimport React, { useState, useEffect } from 'react';\nimport TodoItem from '../components/TodoItem';\n\nconst TodoContainer = () =&gt; {\n    const [todos, setTodos] = useState([]);\n\n    useEffect(() =&gt; {\n        // Imagine fetching todos from an API\n        const fetchTodos = async () =&gt; {\n            const response = await fetch('/api/todos');\n            const data = await response.json();\n            setTodos(data);\n        };\n\n        fetchTodos();\n    }, []);\n\n    return (\n        &lt;ul&gt;\n            {todos.map(todo =&gt; (\n                &lt;TodoItem key={todo.id} todo={todo} /&gt;\n            ))}\n        &lt;/ul&gt;\n    );\n};\n\nexport default TodoContainer;\n</code></pre>"},{"location":"designpattern/react/container-presentation/#3-use-clear-and-descriptive-file-names","title":"3. Use Clear and Descriptive File Names","text":"<p>Be clear in naming so it\u2019s immediately obvious which component is responsible for what:</p> <ul> <li> <p>Presentational Components: Prefer naming files after their role or function in the UI.</p> <ul> <li><code>Button.js</code>, <code>Header.js</code>, <code>TodoItem.js</code></li> </ul> </li> <li> <p>Container Components: Use the Container suffix to highlight that this component is responsible for logic and managing state.</p> <ul> <li><code>TodoContainer.js</code>, <code>UserContainer.js</code>, <code>ProfileContainer.js</code></li> </ul> </li> </ul> <p>This naming system allows you to easily understand the structure of the project just by looking at the file names.</p>"},{"location":"designpattern/react/container-presentation/#4-organizing-components-and-containers-together-optional","title":"4. Organizing Components and Containers Together (Optional)","text":"<p>In smaller projects, you might keep components and containers in the same directory or use subdirectories for a more modular approach.</p> Example folder structure with modular subfolders <pre><code>src/\n\u2502\n\u251c\u2500\u2500 features/                # Feature-based organization\n\u2502   \u251c\u2500\u2500 todos/\n\u2502   \u2502   \u251c\u2500\u2500 components/      # Presentational components related to todos\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 TodoItem.js\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 TodoList.js\n\u2502   \u2502   \u2514\u2500\u2500 containers/      # Containers for managing todos\n\u2502   \u2502       \u2514\u2500\u2500 TodoContainer.js\n\u2502   \u2514\u2500\u2500 users/\n\u2502       \u251c\u2500\u2500 components/      # Presentational components related to users\n\u2502       \u2514\u2500\u2500 containers/\n\u2502           \u2514\u2500\u2500 UserContainer.js\n\u2502\n\u2514\u2500\u2500 App.js\n</code></pre> <p>This approach groups related components by feature or domain rather than separating strictly by the component type (presentational vs. container).</p>"},{"location":"designpattern/react/container-presentation/#5-component-folder-with-index-file","title":"5. Component Folder with Index File","text":"<p>In some cases, you can also use an <code>index.js</code> file inside each feature or container folder to simplify imports.</p> Example <pre><code>src/\n\u2502\n\u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 TodoItem.js\n\u2502   \u2514\u2500\u2500 index.js   # Exports all components in this folder\n\u2502\n\u251c\u2500\u2500 containers/\n\u2502   \u251c\u2500\u2500 TodoContainer.js\n\u2502   \u2514\u2500\u2500 index.js   # Exports all containers in this folder\n\u2502\n\u2514\u2500\u2500 App.js\n</code></pre> <p><code>index.js</code> can look like this:</p> <pre><code>// components/index.js\nexport { default as TodoItem } from \"./TodoItem\";\n</code></pre> <p>This way, you can import components in <code>TodoContainer.js</code> like:</p> <pre><code>import { TodoItem } from \"../components\";\n</code></pre> <p>This keeps the import statements clean and scalable, especially as the project grows.</p>"},{"location":"designpattern/react/container-presentation/#summary-of-best-practices-for-file-structure-and-naming","title":"Summary of Best Practices for File Structure and Naming:","text":"<ol> <li> <p>File Organization:</p> <ul> <li>Store Presentational Components in a <code>components/</code> folder.</li> <li>Store Container Components in a <code>containers/</code> folder.</li> <li>Optionally, group by feature if your project scales.</li> </ul> </li> <li> <p>Naming Convention:</p> <ul> <li>Presentational/Dumb Components: Name them based on their function or the UI they represent (e.g., <code>TodoItem.js</code>, <code>Button.js</code>).</li> <li>Container/Smart Components: Use the <code>Container</code> suffix to indicate their role (e.g., <code>TodoContainer.js</code>, <code>UserContainer.js</code>).</li> </ul> </li> <li> <p>Modularity:</p> <ul> <li>As the project grows, consider grouping components by features or domains (e.g., <code>features/todos/</code>, <code>features/users/</code>).</li> </ul> </li> <li> <p>Avoid Overcomplication:</p> <ul> <li>Don\u2019t over-structure\u2014keep things simple in the beginning and scale as necessary.</li> </ul> </li> </ol> <p>By following these practices, you'll keep your codebase organized, modular, and maintainable as it grows.</p>"},{"location":"designpattern/react/custom-component/","title":"custom component","text":"<p>Whether to directly use the Statistic component or to create a CustomStatistic component depends on a few factors such as reusability, flexibility, and code clarity. Let's explore both approaches:</p>"},{"location":"designpattern/react/custom-component/#1-directly-using-the-statistic-component","title":"1. Directly Using the <code>Statistic</code> Component:","text":"ExampleExplanation <pre><code>&lt;Statistic\n    title=\"Active\"\n    value={11.28}\n    precision={2}\n    valueStyle={{\n        color: \"#3f8600\",\n    }}\n    suffix=\"%\"\n/&gt;\n</code></pre> <p>This approach is perfectly fine if:</p> <ul> <li>The <code>Statistic</code> component is used only once in your app, and you don't need to customize it often.</li> <li>You don't foresee needing to make changes like adding custom logic, styling, or behavior that is specific to this <code>Statistic</code> in multiple places.</li> </ul>"},{"location":"designpattern/react/custom-component/#2-creating-a-customstatistic-component","title":"2. Creating a <code>CustomStatistic</code> Component:","text":"ExampleExplanation <pre><code>const CustomStatistic = ({ title, value, suffix }) =&gt; (\n    &lt;Statistic\n        title={title}\n        value={value}\n        precision={2}\n        valueStyle={{\n            color: \"#3f8600\",\n        }}\n        suffix={suffix}\n    /&gt;\n);\n\n// Usage:\n&lt;CustomStatistic title=\"Active\" value={11.28} suffix=\"%\" /&gt;;\n</code></pre> <p>This approach is preferable if:</p> <ul> <li> <p>Reusability: You need to reuse the same <code>Statistic</code> component with the same style and behavior across multiple places in your app. In this case, creating a <code>CustomStatistic</code> component can help centralize and simplify any future changes to styling or logic (like adding additional customization).</p> </li> <li> <p>Consistency: If you have specific design patterns or customizations (like value styles, precision, or color) that need to be applied consistently across multiple statistics in your app, wrapping the <code>Statistic</code> in a custom component ensures all instances follow the same pattern without repetitive code.</p> </li> <li> <p>Extendability: If you might want to add more logic or dynamic behavior (like fetching the value, conditionally changing the color, or adding icons) in the future, having a <code>CustomStatistic</code> component gives you more flexibility.</p> </li> </ul>"},{"location":"designpattern/react/custom-component/#when-to-choose-each-approach","title":"When to Choose Each Approach","text":"<p>Use the <code>Statistic</code> directly:</p> <ul> <li>When it's a one-off use case.</li> <li>When you don\u2019t need customization or reuse.</li> </ul> <p>Create a <code>CustomStatistic</code> component:</p> <ul> <li>When the same logic/style is used in multiple places in your app.</li> <li>When you need to easily update or extend functionality (like adding a prefix, conditionally changing styles, adding animation, etc.).</li> </ul> <p>Example of Extending with More Flexibility (Custom Component):</p> <p>If you want to add more flexibility, like having a custom icon prefix, or allowing for dynamic color based on the value, you can extend your <code>CustomStatistic</code>:</p> <pre><code>const CustomStatistic = ({ title, value, suffix, icon, color }) =&gt; (\n  &lt;Statistic\n    title={title}\n    value={value}\n    precision={2}\n    valueStyle={{\n      color: color || \"#3f8600\", // Default to green if no color is provided\n    }}\n    prefix={icon}\n    suffix={suffix}\n  /&gt;\n);\n\n// Usage with dynamic values:\n&lt;CustomStatistic\n  title=\"Active\"\n  value={11.28}\n  suffix=\"%\"\n  icon={&lt;ArrowUpOutlined /&gt;}\n  color={value &gt; 10 ? \"#3f8600\" : \"#cf1322\"} // Example dynamic color based on value\n/&gt;;\n</code></pre> <p>Conclusion:</p> <ul> <li>Use <code>Statistic</code> directly when you're working with just a single instance and the customization needs are minimal.</li> <li>Create <code>CustomStatistic</code> if you need more flexibility, reuse, or consistency across your app, or if you're likely to extend the functionality in the future.</li> </ul> <p>In most cases, creating a <code>CustomStatistic</code> is a better practice if you're building a larger app with multiple similar components. It can save you time in the long run and make your code more maintainable.</p>"},{"location":"designpattern/react/intro/","title":"Intro","text":"<p>How can I use design patterns in real-time for large-scale web applications, and how do they fit into daily development?</p>"},{"location":"designpattern/react/intro/#overview","title":"Overview","text":"<p>In large-scale web applications, using design patterns helps improve code scalability, maintainability, and modularity. Here\u2019s how you can apply the most common patterns in real-time scenarios in a large web application, especially using JavaScript and React.</p>"},{"location":"designpattern/react/intro/#1-module-pattern-javascript-custom-hooks-react","title":"1. Module Pattern (JavaScript) / Custom Hooks (React)","text":"<p>Real-time Scenario:</p> <p>In a large web app, you often need to reuse logic like API calls, authentication checks, or form handling. Encapsulating these into modules (JavaScript) or custom hooks (React) ensures that the logic is reusable and maintainable.</p> <p>Real-world Example in React:</p> <p>Imagine you have a large application that requires fetching data from multiple APIs. You can create a custom hook for handling API requests.</p> <pre><code>// useFetch.js (Custom Hook)\nimport { useState, useEffect } from \"react\";\n\nfunction useFetch(url) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() =&gt; {\n    async function fetchData() {\n      try {\n        const response = await fetch(url);\n        const result = await response.json();\n        setData(result);\n      } catch (err) {\n        setError(err);\n      } finally {\n        setLoading(false);\n      }\n    }\n    fetchData();\n  }, [url]);\n\n  return { data, loading, error };\n}\n\n// Component usage\nfunction Users() {\n  const { data, loading, error } = useFetch(\n    \"https://jsonplaceholder.typicode.com/users\"\n  );\n\n  if (loading) return &lt;p&gt;Loading...&lt;/p&gt;;\n  if (error) return &lt;p&gt;Error loading data.&lt;/p&gt;;\n\n  return (\n    &lt;ul&gt;\n      {data.map((user) =&gt; (\n        &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  );\n}\n</code></pre> <p>Why Daily?</p> <p>In large-scale applications, Custom Hooks and Modules help you abstract repetitive logic like API calls, authentication, or state handling, making it easier to maintain the code.</p>"},{"location":"designpattern/react/intro/#2-observer-pattern-javascript-context-api-react","title":"2. Observer Pattern (JavaScript) / Context API (React)","text":"<p>Real-time Scenario:</p> <p>A large-scale app might need to notify multiple components about global changes like theme updates or user authentication state. The Observer Pattern in JavaScript, or Context API in React, allows for this kind of communication across the app.</p> <p>Real-world Example in React (Using Context API for Theme Management):</p> <pre><code>// themeContext.js\nimport React, { createContext, useState, useContext } from \"react\";\n\nconst ThemeContext = createContext();\n\nexport function ThemeProvider({ children }) {\n  const [theme, setTheme] = useState(\"light\");\n\n  const toggleTheme = () =&gt; {\n    setTheme(theme === \"light\" ? \"dark\" : \"light\");\n  };\n\n  return (\n    &lt;ThemeContext.Provider value={{ theme, toggleTheme }}&gt;\n      {children}\n    &lt;/ThemeContext.Provider&gt;\n  );\n}\n\nexport function useTheme() {\n  return useContext(ThemeContext);\n}\n\n// Any component\nfunction ThemeToggler() {\n  const { theme, toggleTheme } = useTheme();\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Current theme: {theme}&lt;/p&gt;\n      &lt;button onClick={toggleTheme}&gt;Toggle Theme&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\n// App.js\nimport { ThemeProvider } from \"./themeContext\";\nimport ThemeToggler from \"./ThemeToggler\";\n\nfunction App() {\n  return (\n    &lt;ThemeProvider&gt;\n      &lt;ThemeToggler /&gt;\n    &lt;/ThemeProvider&gt;\n  );\n}\n</code></pre> <p>Why Daily?</p> <p>You use Context API to handle global state changes (e.g., user preferences, authentication) that need to be accessible across multiple components in a large web app, ensuring consistency and avoiding prop-drilling.</p>"},{"location":"designpattern/react/intro/#3-factory-pattern-javascript-component-composition-react","title":"3. Factory Pattern (JavaScript) / Component Composition (React)","text":"<p>Real-time Scenario:</p> <p>When building complex forms or UI components that need to adapt based on user input or app state, the Factory Pattern in JavaScript or Component Composition in React is ideal.</p> <p>Real-world Example in React (Form Factory):</p> <pre><code>// FieldFactory.js\nfunction FieldFactory({ field }) {\n  switch (field.type) {\n    case \"text\":\n      return &lt;input type=\"text\" placeholder={field.label} /&gt;;\n    case \"select\":\n      return (\n        &lt;select&gt;\n          {field.options.map((option) =&gt; (\n            &lt;option key={option} value={option}&gt;\n              {option}\n            &lt;/option&gt;\n          ))}\n        &lt;/select&gt;\n      );\n    case \"checkbox\":\n      return &lt;input type=\"checkbox\" /&gt;;\n    default:\n      return null;\n  }\n}\n\n// DynamicForm.js\nfunction DynamicForm({ fields }) {\n  return (\n    &lt;form&gt;\n      {fields.map((field, index) =&gt; (\n        &lt;div key={index}&gt;\n          &lt;label&gt;{field.label}&lt;/label&gt;\n          &lt;FieldFactory field={field} /&gt;\n        &lt;/div&gt;\n      ))}\n    &lt;/form&gt;\n  );\n}\n\n// Usage\nconst formFields = [\n  { type: \"text\", label: \"Username\" },\n  { type: \"select\", label: \"Country\", options: [\"USA\", \"Canada\"] },\n  { type: \"checkbox\", label: \"Accept Terms\" },\n];\n\nfunction App() {\n  return &lt;DynamicForm fields={formFields} /&gt;;\n}\n</code></pre> <p>Why Daily?</p> <p>In large-scale applications, Factory Patterns or Component Composition help you manage the complexity of dynamic UIs and forms by allowing you to create components based on configurations or user input.</p>"},{"location":"designpattern/react/intro/#4-singleton-pattern-javascript-redux-store-react","title":"4. Singleton Pattern (JavaScript) / Redux Store (React)","text":"<p>Real-time Scenario:</p> <p>When managing shared state (e.g., user authentication, cart items) across multiple parts of your app, a Singleton in JavaScript or Redux Store in React ensures that you have a single source of truth.</p> <p>Real-world Example in React (Redux Store for Global State):</p> <pre><code>// store.js (Redux setup)\nimport { createStore } from \"redux\";\n\nconst initialState = { isAuthenticated: false };\n\nfunction authReducer(state = initialState, action) {\n  switch (action.type) {\n    case \"LOGIN\":\n      return { ...state, isAuthenticated: true };\n    case \"LOGOUT\":\n      return { ...state, isAuthenticated: false };\n    default:\n      return state;\n  }\n}\n\nconst store = createStore(authReducer);\n\n// Component usage (React + Redux)\nimport { useSelector, useDispatch } from \"react-redux\";\n\nfunction AuthButton() {\n  const dispatch = useDispatch();\n  const isAuthenticated = useSelector((state) =&gt; state.isAuthenticated);\n\n  return (\n    &lt;div&gt;\n      {isAuthenticated ? (\n        &lt;button onClick={() =&gt; dispatch({ type: \"LOGOUT\" })}&gt;Logout&lt;/button&gt;\n      ) : (\n        &lt;button onClick={() =&gt; dispatch({ type: \"LOGIN\" })}&gt;Login&lt;/button&gt;\n      )}\n    &lt;/div&gt;\n  );\n}\n\n// App.js\nimport { Provider } from \"react-redux\";\nimport AuthButton from \"./AuthButton\";\nimport store from \"./store\";\n\nfunction App() {\n  return (\n    &lt;Provider store={store}&gt;\n      &lt;AuthButton /&gt;\n    &lt;/Provider&gt;\n  );\n}\n</code></pre> <p>Why Daily?</p> <p>Redux (or any global state management tool like Zustand) is essential in large apps for managing state across components. It\u2019s a clear example of the Singleton Pattern, ensuring only one instance of your app\u2019s state exists.</p>"},{"location":"designpattern/react/intro/#5-decorator-pattern-javascript-higher-order-components-react","title":"5. Decorator Pattern (JavaScript) / Higher-Order Components (React)","text":"<p>Real-time Scenario:</p> <p>In a large app, you may want to add functionality (e.g., logging, authentication, or permissions) to components dynamically without modifying their implementation. The Decorator Pattern in JavaScript or Higher-Order Components (HOC) in React provides this flexibility.</p> <p>Real-world Example in React (HOC for Authorization):</p> <pre><code>// withAuth.js (HOC for authorization)\nfunction withAuth(WrappedComponent) {\n  return function (props) {\n    const isAuthenticated = useAuth(); // custom hook for checking auth\n\n    if (!isAuthenticated) {\n      return &lt;p&gt;You are not authorized to view this content&lt;/p&gt;;\n    }\n\n    return &lt;WrappedComponent {...props} /&gt;;\n  };\n}\n\n// SomeProtectedComponent.js\nfunction SomeProtectedComponent() {\n  return &lt;p&gt;Secret Content: You are authorized!&lt;/p&gt;;\n}\n\n// Usage in App.js\nconst ProtectedComponent = withAuth(SomeProtectedComponent);\n\nfunction App() {\n  return &lt;ProtectedComponent /&gt;;\n}\n</code></pre> <p>Why Daily?</p> <p>In large-scale web applications, HOCs and Decorators allow you to add functionality like authentication checks, logging, or performance tracking to components without duplicating code.</p>"},{"location":"designpattern/react/intro/#conclusion","title":"Conclusion:","text":"<p>In large-scale web applications, design patterns play a crucial role in organizing code, making it reusable, maintainable, and scalable. Here\u2019s how you can apply them:</p> <ol> <li>Module Pattern/Custom Hooks: Reuse logic (e.g., API calls, state handling).</li> <li>Observer Pattern/Context API: Manage global state (e.g., themes, auth).</li> <li>Factory Pattern/Component Composition: Dynamically generate components.</li> <li>Singleton Pattern/Redux Store: Centralized state management.</li> <li>Decorator Pattern/HOCs: Add cross-cutting concerns (e.g., auth, logging).</li> </ol> <p>Mastering these patterns ensures that your application remains efficient and maintainable as it grows.</p>"},{"location":"designpattern/react/mostly-used/","title":"Mostly Used","text":""},{"location":"designpattern/react/mostly-used/#overview","title":"Overview","text":"<p>In React, several design patterns are commonly used due to their flexibility and the nature of component-based development. While different projects and teams may lean towards different patterns depending on specific use cases, the following patterns are most frequently used in React applications:</p>"},{"location":"designpattern/react/mostly-used/#1-containerpresentational-pattern","title":"1. Container/Presentational Pattern","text":"<ul> <li> <p>Use case: Separates the concerns of data management (container) and UI rendering (presentational).</p> </li> <li> <p>Why it's used: Helps keep React components clean, focused, and maintainable by separating logic and UI.</p> </li> <li> <p>Container: Handles the state, logic, and side-effects.</p> </li> <li> <p>Presentational: Focuses only on rendering UI and receiving data via props.</p> </li> <li> <p>Example: In a Todo app, the Container might manage the state of the todo list, while the Presentational component would just display it.</p> </li> </ul>"},{"location":"designpattern/react/mostly-used/#2-higher-order-component-hoc-pattern","title":"2. Higher-Order Component (HOC) Pattern","text":"<ul> <li>Use case: Enhances or modifies a component by wrapping it in another component.</li> <li>Why it's used: Reusable logic can be abstracted and shared across components without altering their structure.</li> <li>Example: You might create an HOC for adding <code>authentication checks</code>, which wraps the component and checks if the user is logged in before rendering the UI.</li> </ul>"},{"location":"designpattern/react/mostly-used/#3-render-props-pattern","title":"3. Render Props Pattern","text":"<ul> <li>Use case: Allows sharing code between components using a function that returns a React element.</li> <li>Why it's used: Enables component logic to be shared without relying on inheritance or wrapping. It's more flexible than HOCs and allows you to inject UI elements based on shared logic.</li> <li>Example: A component might use <code>render props</code> to share a piece of functionality (like mouse position) with other components that need it.</li> </ul>"},{"location":"designpattern/react/mostly-used/#4-state-as-a-function-of-props-pattern","title":"4. State as a Function of Props Pattern","text":"<ul> <li>Use case: Using props to define the state of a component, rather than managing it internally.</li> <li>Why it's used: Encourages more predictable, testable, and reusable components.</li> <li>Example: React hooks, like <code>useState</code>, and even <code>Redux</code> (state management library) often adopt this pattern, where the state reflects props passed to the component.</li> </ul>"},{"location":"designpattern/react/mostly-used/#5-compound-component-pattern","title":"5. Compound Component Pattern","text":"<ul> <li>Use case: Allows components to work together in a way where they implicitly share state and behavior.</li> <li>Why it's used: Encapsulates the logic of a set of components, making them easy to use together without explicitly managing their relationships.</li> <li>Example: A <code>Tabs component</code> where the <code>Tab children</code> automatically know which one is active.</li> </ul>"},{"location":"designpattern/react/mostly-used/#6-context-api-pattern","title":"6. Context API Pattern","text":"<ul> <li>Use case: Sharing state globally across deeply nested components without having to pass props down manually.</li> <li>Why it's used: Great for managing global state like themes, authentication, or user preferences.</li> <li>Example: You might use <code>React's Context API</code> to share the user's authentication state across the entire app without having to pass the props down to each component.</li> </ul>"},{"location":"designpattern/react/mostly-used/#7-component-composition-pattern","title":"7. Component Composition Pattern","text":"<ul> <li>Use case: Combining small, reusable components to create more complex UIs.</li> <li>Why it's used: Encourages reusability and maintainability, following React\u2019s philosophy of building small, focused components.</li> <li>Example: A <code>Button</code> component may be used inside other components like <code>Card</code>, <code>Modal</code>, etc., to create consistent and reusable UI elements.</li> </ul>"},{"location":"designpattern/react/mostly-used/#8-observer-pattern-via-hooks-like-useeffect","title":"8. Observer Pattern (via Hooks like <code>useEffect</code>)","text":"<ul> <li>Use case: Observing changes in state or props and performing side effects.</li> <li>Why it's used: React\u2019s <code>useEffect</code> hook is a good example of an Observer Pattern, where components react to changes in state or props, making it easy to manage side effects like fetching data, subscribing to events, etc.</li> <li>Example: You might use <code>useEffect</code> to fetch data when the component mounts or when certain state variables change.</li> </ul>"},{"location":"designpattern/react/mostly-used/#which-one-is-most-used-in-react","title":"Which One is Most Used in React?","text":"<p>The most commonly used patterns in React are:</p> <ul> <li>Container/Presentational Pattern: This is often used to keep logic separate from the UI, especially in larger applications where managing the state is a concern.</li> <li>Higher-Order Components (HOCs) and Render Props: These two patterns are also widely used for code reuse, though with the introduction of React Hooks, many developers have shifted away from HOCs in favor of hooks for shared logic.</li> <li>Context API: For managing state globally and passing it down the component tree without having to manually pass props, especially in large apps.</li> <li>Component Composition: The core idea behind React is to compose components, so this pattern is used constantly in React applications.</li> </ul> <p>So, in summary, <code>Component Composition</code> and <code>Hooks</code> (State as a Function of Props) are foundational to React, and <code>Container/Presentational</code> and <code>HOCs/Render Props</code> are also commonly used. The use of these patterns depends on the app's complexity and requirements.</p>"},{"location":"eventloop/deep-copy/","title":"Deep Copy","text":""},{"location":"eventloop/deep-copy/#what-exactly-is-a-deep-copy-in-javascript","title":"What Exactly is a Deep Copy in JavaScript?","text":"<p>A deep copy in JavaScript refers to creating a new object that is a fully independent clone of the original, meaning:</p> <ul> <li>It copies all properties, including nested objects, recursively.</li> <li>Any modifications to the copied object do not affect the original object.</li> <li>It is only relevant for non-primitive types because primitives are always copied by value.</li> </ul>"},{"location":"eventloop/deep-copy/#deep-copy-is-only-for-non-primitive-types","title":"\ud83d\udd39 Deep Copy is Only for Non-Primitive Types","text":"<ul> <li>\u2705 Applies to: <code>Objects ({})</code>, <code>Arrays ([])</code>, <code>Functions (function() {})</code></li> <li> <p>\u274c Not Needed for: Strings (<code>\"text\"</code>), Numbers (<code>123</code>), Booleans (<code>true</code>), <code>null</code>, <code>undefined</code>, <code>BigInt</code>, <code>Symbol</code> (These are always copied by value)</p> Example: Deep Copy vs. Shallow Copy<pre><code>let obj1 = {\n  a: 1,\n  b: { c: 2 },\n};\n\n// \u274c Shallow Copy (References Nested Object)\nlet obj2 = { ...obj1 }; // Spread operator (shallow copy)\nobj2.b.c = 99;\n\nconsole.log(obj1.b.c); // 99 (Original is affected)\n\n// \u2705 Deep Copy (Independent Clone)\nlet obj3 = JSON.parse(JSON.stringify(obj1));\nobj3.b.c = 42;\n\nconsole.log(obj1.b.c); // 99 (Unchanged in original)\nconsole.log(obj3.b.c); // 42 (Modified only in copy)\n</code></pre> </li> </ul> <p>Explanation:</p> <ul> <li><code>obj2</code> (shallow copy) still shares the same nested object (<code>b</code>), so changes affect <code>obj1</code>.</li> <li><code>obj3</code> (deep copy) creates an independent clone of <code>b</code>, so modifying it doesn\u2019t affect <code>obj1</code>.</li> </ul>"},{"location":"eventloop/deep-copy/#ways-to-create-a-deep-copy-in-javascript","title":"\ud83d\udd39 Ways to Create a Deep Copy in JavaScript","text":"<p>Here are different ways to perform a deep copy:</p>"},{"location":"eventloop/deep-copy/#1-1-jsonparsejsonstringifyobj-basic-deep-copy","title":"1. 1\ufe0f\u20e3 <code>JSON.parse(JSON.stringify(obj)</code> (Basic Deep Copy)","text":"<ul> <li>\u2705 Works well for: Simple objects &amp; arrays</li> <li> <p>\u274c Limitations: Cannot copy functions, <code>Date</code>, <code>undefined</code>, <code>RegExp</code>, <code>Map</code>, <code>Set</code></p> <pre><code>let obj = { a: 1, b: { c: 2 } };\nlet deepCopy = JSON.parse(JSON.stringify(obj));\n\ndeepCopy.b.c = 100;\nconsole.log(obj.b.c); // 2 (Original remains unchanged)\n</code></pre> </li> </ul>"},{"location":"eventloop/deep-copy/#2-2-structuredcloneobj-recommended","title":"2. 2\ufe0f\u20e3 <code>structuredClone(obj)</code> (Recommended)","text":"<ul> <li>\u2705 Works with: Objects, Arrays, Maps, Sets, Dates, Buffers</li> <li> <p>\u274c Limitations: Cannot clone functions</p> <pre><code>let obj = { a: 1, b: { c: 2 } };\nlet deepCopy = structuredClone(obj);\n\ndeepCopy.b.c = 100;\nconsole.log(obj.b.c); // 2 (Original remains unchanged)\n</code></pre> </li> </ul> <p>Best method if your environment supports it (modern browsers &amp; Node.js 17+).</p>"},{"location":"eventloop/deep-copy/#3-3-lodashs-_clonedeepobj-best-for-complex-objects","title":"3. 3\ufe0f\u20e3 Lodash\u2019s <code>_.cloneDeep(obj)</code> (Best for Complex Objects)","text":"<ul> <li>\u2705 Handles: Functions, <code>Map</code>, <code>Set</code>, <code>Date</code>, <code>RegExp</code>, circular references</li> <li>\u274c Requires lodash (<code>npm install lodash</code>)</li> </ul>"},{"location":"eventloop/deep-copy/#when-to-use-deep-copy","title":"\ud83d\udd39 When to Use Deep Copy?","text":"Use a deep copy when: <ul> <li>You need a fully independent copy of an object.</li> <li>The object has nested structures that should not be linked.</li> <li>You want to prevent unintended mutations in shared objects.</li> </ul>"},{"location":"eventloop/deep-copy/#final-summary","title":"\ud83d\udd39 Final Summary","text":"Feature Shallow Copy \ud83d\udfe2 Deep Copy \ud83d\udd35 Definition Copies only top-level properties; nested objects still refer to the original Creates a completely independent clone of the entire object, including nested structures Default in JS? \u2705 Yes (for non-primitives) \u274c No (must be explicitly done) Effect on Nested Objects? Changes in nested objects affect both copies Changes do not affect the original object Performance Faster, as it only copies references Slower, as it recursively copies everything Example Methods <code>{ ...obj }</code>, <code>Object.assign()</code> <code>JSON.parse(JSON.stringify(obj))</code>, <code>structuredClone(obj)</code>, Lodash\u2019s <code>_.cloneDeep()</code>"},{"location":"eventloop/deep-copy/#key-takeaway","title":"Key Takeaway","text":"<ul> <li>Deep copies are only needed for non-primitive types because primitives are always copied by value.</li> <li>If you want an object copy without shared references, use structuredClone, <code>JSON.parse(JSON.stringify())</code>, or Lodash\u2019s <code>_.cloneDeep()</code>. \ud83d\ude80</li> </ul>"},{"location":"eventloop/intro/","title":"Intro","text":""},{"location":"eventloop/intro/#event-loop","title":"Event Loop","text":"<p>The event loop is a fundamental concept in JavaScript that enables its non-blocking, asynchronous behavior. It is the mechanism that allows JavaScript to handle tasks like I/O operations, timers, and callbacks efficiently, even though JavaScript is single-threaded.</p> <p></p> Quote <p>The event loop in JavaScript is a mechanism and algorithm that continuously monitors the call stack and task queues, ensuring that JavaScript executes code efficiently while remaining non-blocking.</p> <p>Event Loop in Technical Terms</p> <p>The event loop works like a coordinator between:</p> <ul> <li>Call Stack (where synchronous code runs)</li> <li>Task Queues (where asynchronous tasks wait)</li> <li>Web APIs (for timers, fetch requests, etc.)</li> </ul> <p>The event loop continuously checks if the call stack is empty, and if so, it pushes tasks from the task queues onto the stack for execution.</p>"},{"location":"eventloop/intro/#why-is-the-event-loop-important","title":"Why is the Event Loop Important?","text":"<p>JavaScript runs in a single-threaded environment, meaning it can only execute one task at a time. However, many tasks in a web application (like network requests, file reading, or timers) are asynchronous and take time to complete. The event loop ensures that these tasks don't block the main thread, allowing the application to remain responsive.</p>"},{"location":"eventloop/intro/#how-the-event-loop-works","title":"How the Event Loop Works","text":"<p>The event loop continuously monitors the call stack and the task queues to determine what to execute next. Here's a breakdown of the key components:</p> <ol> <li> <p>Call Stack:</p> <ul> <li>The call stack is where JavaScript keeps track of function calls. It operates in a Last In, First Out (LIFO) manner.</li> <li>When a function is called, it is added to the top of the stack. When the function returns, it is removed from the stack.</li> </ul> </li> <li> <p>Web APIs:</p> <ul> <li>Browser-provided APIs (like <code>setTimeout</code>, <code>fetch</code>, or DOM events) handle tasks that are asynchronous or take time to complete.</li> <li>When an asynchronous operation is initiated, it is offloaded to the Web API, and the main thread continues executing other code.</li> </ul> </li> <li> <p>Callback Queue (Task Queue):</p> <ul> <li>Once an asynchronous operation is completed, its callback function is placed in the callback queue.</li> <li> <p>Examples of tasks in the callback queue include:</p> </li> <li> <p>Callbacks from <code>setTimeout</code> or <code>setInterval</code>.</p> </li> <li>Event handlers like <code>click</code> or <code>keypress</code>.</li> <li>Callbacks from network requests (<code>fetch</code> or <code>XMLHttpRequest</code>).</li> </ul> </li> <li> <p>Microtask Queue:</p> <ul> <li>This queue has higher priority than the callback queue and is used for promises and other microtasks.</li> <li> <p>Examples of microtasks include:</p> </li> <li> <p><code>Promise.then()</code> or <code>Promise.catch()</code> callbacks.</p> </li> <li><code>queueMicrotask()</code>.</li> <li><code>MutationObserver</code> callbacks.</li> </ul> </li> <li> <p>Event Loop:</p> <ul> <li>The event loop constantly checks if the call stack is empty.</li> <li>If the call stack is empty, it first processes all tasks in the microtask queue.</li> <li>Once the microtask queue is empty, it processes tasks in the callback queue.</li> </ul> </li> </ol>"},{"location":"eventloop/intro/#example-of-the-event-loop-in-action","title":"Example of the Event Loop in Action","text":"<pre><code>console.log(\"Start\");\n\nsetTimeout(() =&gt; {\n  console.log(\"Timeout callback\");\n}, 0);\n\nPromise.resolve().then(() =&gt; {\n  console.log(\"Promise resolved\");\n});\n\nconsole.log(\"End\");\n</code></pre> Output<pre><code>Start\nEnd\nPromise resolved\nTimeout callback\n</code></pre> Explanation <ol> <li> <p><code>console.log('Start')</code> is executed and added to the call stack.</p> </li> <li> <p><code>setTimeout</code> is called, and its callback is offloaded to the Web API. After the timer completes (even if it's 0ms), the callback is moved to the callback queue.</p> </li> <li> <p><code>Promise.resolve().then()</code> is called, and its callback is added to the microtask queue.</p> </li> <li> <p><code>console.log('End')</code> is executed and added to the call stack.</p> </li> <li> <p>The call stack is now empty, so the event loop processes the microtask queue first, logging <code>Promise resolved</code>.</p> </li> <li> <p>Finally, the event loop processes the callback queue, logging <code>Timeout callback</code>.</p> </li> </ol>"},{"location":"eventloop/intro/#key-points-about-the-event-loop","title":"Key Points About the Event Loop","text":"<ol> <li> <p>Single-Threaded: JavaScript has only one call stack, meaning it can only do one thing at a time.</p> </li> <li> <p>Non-Blocking: Asynchronous operations are handled by Web APIs, so they don't block the main thread.</p> </li> <li> <p>Microtasks vs Macrotasks:</p> <ul> <li>Microtasks (e.g., promises) have higher priority and are executed before macrotasks (e.g., <code>setTimeout</code>).</li> </ul> </li> <li> <p>Event Loop Phases:</p> <ul> <li>The event loop processes microtasks first, then macrotasks, and repeats this cycle.</li> </ul> </li> </ol>"},{"location":"eventloop/intro/#visual-representation-of-the-event-loop","title":"Visual Representation of the Event Loop","text":"<ol> <li>Call Stack: Executes synchronous code.</li> <li>Web APIs: Handle asynchronous operations.</li> <li>Callback Queue: Holds callbacks from asynchronous operations.</li> <li>Microtask Queue: Holds promise callbacks and other microtasks.</li> <li>Event Loop: Moves tasks from the queues to the call stack when it's empty.</li> </ol>"},{"location":"eventloop/intro/#real-world-analogy","title":"Real-World Analogy","text":"<p>Imagine a restaurant:</p> <ul> <li>The call stack is the chef cooking one dish at a time.</li> <li>The Web APIs are the kitchen assistants handling tasks like fetching ingredients or washing dishes.</li> <li>The callback queue is the line of orders waiting to be cooked.</li> <li>The microtask queue is a priority line for urgent orders (like a VIP customer).</li> <li>The event loop is the manager who ensures the chef cooks orders from the priority line first, then the regular line.</li> </ul>"},{"location":"eventloop/intro/#summary","title":"Summary","text":"<p>The event loop is the backbone of JavaScript's asynchronous programming model. It ensures that asynchronous tasks are handled efficiently without blocking the main thread. By understanding the event loop, you can write more efficient and responsive JavaScript code.</p>"},{"location":"eventloop/intro/#event","title":"Event","text":"<p>In JavaScript, an event is an action or occurrence that happens in the browser, such as a user clicking a button, resizing a window, or pressing a key. Events are a core part of interactive web applications, allowing developers to respond to user actions or other changes in the application.</p>"},{"location":"eventloop/intro/#event-basics","title":"Event Basics","text":"<ol> <li> <p>Event Types: There are many types of events in JavaScript, such as:</p> <ul> <li>Mouse events: click, mouseover, mouseout, mousedown, mouseup</li> <li>Keyboard events: keydown, keyup, keypress</li> <li>Form events: submit, change, focus, blur</li> <li>Window events: load, resize, scroll</li> <li>Custom events: You can also create your own custom events.</li> </ul> </li> <li> <p>Event Target: The element or object that the event occurs on. For example, if a user clicks a button, the button is the event target.</p> </li> <li> <p>Event Listener: A function that waits for a specific event to occur and then executes in response. You attach an event listener to an element using methods like <code>addEventListener</code>.</p> </li> <li> <p>Event Object: When an event occurs, the browser creates an event object that contains information about the event, such as the type of event, the target element, and additional data (e.g., mouse coordinates for a click event).</p> </li> </ol>"},{"location":"eventloop/intro/#example-of-an-event-in-javascript","title":"Example of an Event in JavaScript","text":"<p>Here\u2019s a simple example of handling a click event:</p> <pre><code>// Select the button element\nconst button = document.querySelector(\"button\");\n\n// Add an event listener for the 'click' event\nbutton.addEventListener(\"click\", function (event) {\n  // event is the event object\n  console.log(\"Button clicked!\");\n  console.log(\"Event type:\", event.type); // Output: \"click\"\n  console.log(\"Target element:\", event.target); // Output: The button element\n});\n</code></pre>"},{"location":"eventloop/intro/#event-flow-bubbling-and-capturing","title":"Event Flow (Bubbling and Capturing)","text":"<p>Events in JavaScript follow a flow:</p> <ol> <li>Capturing Phase: The event starts from the top of the DOM tree and goes down to the target element.</li> <li>Target Phase: The event reaches the target element.</li> <li>Bubbling Phase: The event bubbles up from the target element back to the top of the DOM tree.</li> </ol> <p>You can control whether an event listener is triggered during the capturing or bubbling phase using the third parameter of <code>addEventListener</code>:</p> <pre><code>element.addEventListener(\n  \"click\",\n  function (event) {\n    console.log(\"Event triggered during bubbling phase\");\n  },\n  false\n); // false (default) means bubbling phase\n\nelement.addEventListener(\n  \"click\",\n  function (event) {\n    console.log(\"Event triggered during capturing phase\");\n  },\n  true\n); // true means capturing phase\n</code></pre>"},{"location":"eventloop/intro/#preventing-default-behavior","title":"Preventing Default Behavior","text":"<p>Some events have default behaviors (e.g., a form submission or a link click). You can prevent these default behaviors using <code>event.preventDefault()</code>:</p> <pre><code>const link = document.querySelector(\"a\");\n\nlink.addEventListener(\"click\", function (event) {\n  event.preventDefault(); // Prevents the link from navigating\n  console.log(\"Link click prevented\");\n});\n</code></pre>"},{"location":"eventloop/intro/#custom-events","title":"Custom Events","text":"<p>You can create and dispatch custom events using the <code>CustomEvent</code> constructor:</p> <pre><code>// Create a custom event\nconst customEvent = new CustomEvent(\"myCustomEvent\", {\n  detail: { message: \"This is a custom event\" },\n});\n\n// Add an event listener for the custom event\ndocument.addEventListener(\"myCustomEvent\", function (event) {\n  console.log(\"Custom event triggered:\", event.detail.message);\n});\n\n// Dispatch the custom event\ndocument.dispatchEvent(customEvent);\n</code></pre>"},{"location":"eventloop/intro/#summary_1","title":"Summary","text":"<ul> <li>An event in JavaScript is an action or occurrence in the browser.</li> <li>Events are handled using event listeners attached to elements.</li> <li>The event object contains details about the event.</li> <li>Events flow through the DOM in three phases: capturing, target, and bubbling.</li> <li>You can prevent default behaviors or create custom events.</li> </ul>"},{"location":"eventloop/macrotasks/","title":"Macro Queue","text":""},{"location":"eventloop/macrotasks/#macrotasks-task-queue-in-javascript","title":"Macrotasks (Task Queue) in JavaScript","text":""},{"location":"eventloop/macrotasks/#definition","title":"Definition","text":"<p>Macrotasks represent discrete units of work in the JavaScript event loop. They are executed in separate cycles of the event loop and include operations like I/O, timers, and UI rendering.</p>"},{"location":"eventloop/macrotasks/#examples","title":"Examples","text":"<ul> <li><code>setTimeout</code> and <code>setInterval</code></li> <li>DOM event handlers (e.g., <code>click</code>, <code>keydown</code>)</li> <li>I/O operations (e.g., reading files)</li> <li><code>requestAnimationFrame</code></li> <li>Script execution</li> </ul>"},{"location":"eventloop/macrotasks/#execution-flow","title":"Execution Flow","text":"<ol> <li>The event loop processes one macrotask per iteration.</li> <li>After executing a macrotask, all microtasks in the queue are processed.</li> <li>The browser may perform rendering operations before the next macrotask.</li> </ol>"},{"location":"eventloop/macrotasks/#memory-management-considerations","title":"Memory Management Considerations","text":"<ul> <li>Variables referenced in macrotask callbacks are retained until the task executes.</li> <li>Long-delayed macrotasks (e.g., <code>setTimeout(fn, 10000)</code>) may keep large objects in memory longer.</li> <li>Unreleased event listeners in macrotasks can cause memory leaks.</li> </ul>"},{"location":"eventloop/macrotasks/#code-example","title":"Code Example","text":"<pre><code>console.log(\"Start Macrotask\");\n\n// Macrotask 1\nsetTimeout(() =&gt; {\n  console.log(\"Macrotask 1 executed\");\n  const data = new Array(1e6).fill(\"X\"); // Large memory allocation\n}, 1000);\n\n// Macrotask 2\nsetTimeout(() =&gt; {\n  console.log(\"Macrotask 2 executed\");\n}, 2000);\n\nconsole.log(\"End initial execution\");\n</code></pre>"},{"location":"eventloop/memory-management/","title":"Memory Management","text":""},{"location":"eventloop/memory-management/#memory-management-in-javascript","title":"Memory Management in JavaScript","text":"<p>All of the concepts we will discuss in this chapter fall under a broad topic known as \u201cmemory management.\u201d Memory management, in simple terms, is how JavaScript allocates data we create to memory.(1)</p> <ol> <li>5. References, Values, and Memory Management</li> </ol> <p></p>"},{"location":"eventloop/memory-management/#introduction","title":"Introduction","text":"<p>To understand memory management, we need to understand \u201cheaps\u201d and \u201cstacks.\u201d These are both memory concepts and are both stored in the \u201crandom access memory\u201d or RAM.</p> <p>Computers have a fixed amount of RAM. Since JavaScript stores data in RAM, the amount of data your JavaScript uses impacts the amount of RAM used on your computer or server. As such, it can be possible to run out of RAM if you build a sufficiently complicated JavaScript application.</p> <p>So if the heap and stack are both stored in RAM, and they\u2019re both used for storing JavaScript data, what\u2019s the difference?</p> <ul> <li>The stack is a scratch space for the current JavaScript thread. JavaScript is typically single-threaded, so there is usually one stack per application. The stack is also limited in size, which is why numbers in JavaScript can only be so big.</li> <li>The heap is a dynamic memory store. Accessing data from the heap is more complicated, but the heap is not limited in size. As such, the heap will grow if needed.</li> </ul> <p>The heap is used by JavaScript to store objects and functions. For simple variables composed of numbers, strings, and other primitive types, the stack is typically used instead. The stack also stores information on functions which will be called.</p> Note <p>Note JavaScript has built-in functionality known as \u201cgarbage collection\u201d to avoid your application running out of RAM. This algorithm uses a number of different checks, like if a variable or object is no longer referenced in your code, to clear it from the memory. This goes some way to prevent you from running out of memory.</p>"},{"location":"eventloop/memory-management/#stacks","title":"Stacks","text":"<p>The stack is a scratch space for the current JavaScript thread. Every time you point to a primitive type (primitive, here, meaning anything which is not an object) in JavaScript, it is added to the top of the stack.</p> <p>In the following code, we define variables. Non-object type data is immediately added to the top of the stack.</p> <p>A representation of this can be seen in Figure 5-1.</p> <pre><code>const SOME_CONSTANT = 5;\nlet myNumber = 10;\nlet myVariable = \"Some Text\";\n</code></pre> <p>Sometimes, when running complex code or loops, you can see the stack in action. If you exceed the stack limit, you\u2019ll get the error, <code>RangeError: Maximum call stack size exceeded</code>.</p> <p>Different browsers and implementations of JavaScript like Node.js have different stack sizes, but you have to be running a lot of code simultaneously to ever get this error. You may also run into this error if you accidentally run an infinite loop.(1)</p> <ol> <li> <p>If you try to reassign a variable of primitive type, it gets added to the stack as well, even if the variables are supposedly pointing to the same value. Consider the following code, for example:</p> <pre><code>let myNumber = 5;\nlet newNumber = myNumber;\n</code></pre> <p>Although it seems like both of these variables should point to the same underlying value (that value being 5), JavaScript instead adds both references to the stack as individual entries with different values completely.</p> <p>What that means in practice is that for any primitive or non-object value in JavaScript, a deep copy is always made. Variables will not point to the same underlying value in memory but rather appear as new copies of data, each acting independently of each other, as shown in Figure 5-2</p> </li> </ol>"},{"location":"eventloop/memory-management/#the-event-loop","title":"The Event Loop","text":"<p>JavaScript code only has one stack in browsers, so it is commonly described as being single-threaded. However, JavaScript can act like it has multiple threads at once on the front end via something known as Web APIs.</p> <p>We use something called an API or application programming interfaces to let us outsource some of our computation somewhere else and wait for the response. Usually, APIs exist on a server. For example, you could hit an API for retrieving a list of articles on your website. We could then use this data in our code.</p> <p>\u201cAPI\u201d sounds complicated, but it\u2019s just a URL that we can hit, which will eventually send us a response from inside our code. For example, we may hit the URL <code>https://some-website.org/api/articles</code> to retrieve website articles. We would then receive a response from the API with all of the articles. In a future chapter, we\u2019ll deep dive into how APIs work.</p> <p>Browsers have some built-in APIs that can be called straight from your code. These are known as Web APIs, and they usually offer an interface between the code in your browser and the operating system itself. An example of a Web API is the global function, <code>setTimeout</code>, which lets us execute code after a certain number of seconds:</p> Note <p>Note Web API functions that take a long time to run, like <code>setTimeout</code>, are added to the event loop as \u201cmacrotasks.\u201d Some faster Web API functions are added as \u201cmicrotasks.\u201d Microtasks take priority when being added back to the main stack. Whether a Web API generates a macro or microtask is dependent on how long it takes to run!</p>"},{"location":"eventloop/memory-management/#the-heap","title":"The Heap","text":"<p>When we looked at objects, we covered how we can copy objects by making \u201cdeep\u201d and \u201cshallow\u201d copies of them. The reason we have deep and shallow copies in JavaScript is because of how objects are stored in the heap.</p> <p>While non-object types are stored in the stack only, objects are thrown into the heap, which is a more dynamic form of memory with no limit. This means that large objects will never exceed the stack limit.</p> Note <p>Note on object types Since functions and arrays are also of type \u201cobject,\u201d they too are stored in the heap!</p>"},{"location":"eventloop/memory-management/#object-and-reference-equality","title":"Object and Reference Equality","text":"<p>The final complexity that JavaScript introduces by using this method of storing objects and non-objects is to do with equality. JavaScript actually has a lot of difficulty comparing the values of two different objects, and it\u2019s basically down to stacks and heaps.</p>"},{"location":"eventloop/memory-management/#comparing-object-equality","title":"Comparing Object Equality","text":"<p>So how do you compare object equality for objects with different references in JavaScript? Well, it\u2019s not easy, and there is no built-in way to do it. Instead, you have the following options:</p> <ol> <li> <p>You can write your own function to compare each key and value in an object individually or find a good example online.</p> </li> <li> <p>In Node.js, which we will not be covering in a lot of detail in this book, you can use the built-in <code>assert.deepStrictEqual(obj1, obj2)</code> function to compare two objects.</p> </li> <li> <p>Finally, although it\u2019s not recommended, you can also convert both objects to strings using <code>JSON.stringify()</code> to compare their values. <code>JSON.stringify</code> will turn any object into a string, which will be stored on the stack. Then, if both strings are the same, you can assume equality. This is not advised since this JSON method also removes some types of data from objects, like functions. Therefore, you cannot be sure that it will always test for equality, making it quite unreliable.</p> </li> </ol> <p>If you\u2019re using Node.js, your best option is option 2. Otherwise, it is more advised that you write your own function (or find one online), as described in option 1.</p> <p></p> <p></p>"},{"location":"eventloop/memory-management/#reference","title":"Reference","text":"<ul> <li>How JavaScript Works by Jonathon Simpson</li> <li>JavaScript's Memory Management Explained</li> </ul> <p>Related Blogs</p> <ul> <li>Stack vs Heap</li> </ul>"},{"location":"eventloop/microtasks/","title":"Micro Queue","text":""},{"location":"eventloop/microtasks/#microtasks-job-queue-in-javascript","title":"Microtasks (Job Queue) in JavaScript","text":""},{"location":"eventloop/microtasks/#definition","title":"Definition","text":"<p>Microtasks are high-priority tasks that execute immediately after the current macrotask completes, before the next macrotask or rendering phase.</p>"},{"location":"eventloop/microtasks/#examples","title":"Examples","text":"<ul> <li><code>Promise</code> callbacks (<code>then/catch/finally</code>)</li> <li><code>queueMicrotask()</code></li> <li><code>MutationObserver</code> callbacks</li> <li><code>process.nextTick</code> (Node.js)</li> </ul>"},{"location":"eventloop/microtasks/#execution-flow","title":"Execution Flow","text":"<ol> <li>All microtasks in the queue are executed to completion.</li> <li>Microtasks can enqueue additional microtasks, which will all execute in the same cycle.</li> <li>The event loop only proceeds to the next macrotask when the microtask queue is empty.</li> </ol>"},{"location":"eventloop/microtasks/#memory-management-considerations","title":"Memory Management Considerations","text":"<ul> <li>Microtask closures may retain references to large objects.</li> <li>Infinite microtask loops (e.g., recursive <code>queueMicrotask</code>) can block the event loop and cause memory bloat.</li> <li>Proper promise cleanup is essential to avoid memory leaks.</li> </ul>"},{"location":"eventloop/microtasks/#code-example","title":"Code Example","text":"<pre><code>console.log(\"Start Microtask\");\n\n// Microtask\nPromise.resolve().then(() =&gt; {\n  console.log(\"Microtask 1 executed\");\n  // Creates another microtask\n  Promise.resolve().then(() =&gt; {\n    console.log(\"Microtask 2 executed\");\n  });\n});\n\n// Macrotask\nsetTimeout(() =&gt; {\n  console.log(\"Macrotask executed\");\n}, 0);\n\nconsole.log(\"End initial execution\");\n\n/* Execution Order:\n1. Start Microtask\n2. End initial execution\n3. Microtask 1 executed\n4. Microtask 2 executed\n5. Macrotask executed */\n</code></pre>"},{"location":"eventloop/queue/","title":"Macro vs Micro Queue","text":""},{"location":"eventloop/queue/#macro-task-micro-task-in-javascript","title":"Macro-task &amp; Micro-task in JavaScript","text":"Event Loop in JavaScript <p>The event loop is a mechanism in JavaScript that handles asynchronous operations and ensures that JavaScript (which is single-threaded) can execute non-blocking tasks efficiently.</p> <p>JavaScript executes code in two main phases:</p> <ol> <li>Call Stack Execution \u2013 Runs synchronous code line by line.</li> <li>Task Queue Processing \u2013 Handles asynchronous operations using the event loop.</li> </ol> <p>The event loop continuously checks:</p> <ul> <li>If the call stack is empty, it takes the next task from the queue and executes it.</li> <li>It prioritizes tasks based on their type (macro-task vs. micro-task).</li> </ul> <p>Asynchronous tasks in JavaScript are categorized into macro-tasks and micro-tasks.</p> <p></p> <p></p>"},{"location":"eventloop/queue/#1-macro-task-queue-task-queue","title":"1. Macro-task Queue (Task Queue)","text":"<ul> <li> <p>Macro-tasks are executed one at a time after the current synchronous code execution.</p> </li> <li> <p>Common macro-task sources:</p> <ul> <li><code>setTimeout</code></li> <li><code>setInterval</code></li> <li><code>setImmediate</code> (Node.js)</li> <li>I/O operations (e.g., file reading in Node.js)</li> <li>UI rendering events (like click handlers)</li> </ul> </li> </ul>"},{"location":"eventloop/queue/#2-micro-task-queue-priority-queue","title":"2. Micro-task Queue (Priority Queue)","text":"<ul> <li>Micro-tasks are executed before the next macro-task.</li> <li>If a micro-task adds another micro-task, it is also executed before moving to macro-tasks.</li> <li> <p>Common micro-task sources:</p> <ul> <li>Promises (<code>.then</code>, <code>.catch</code>, <code>.finally</code>)</li> <li>MutationObserver</li> <li>queueMicrotask (a manual way to queue a micro-task)</li> </ul> </li> </ul>"},{"location":"eventloop/queue/#execution-order-of-event-loop","title":"Execution Order of Event Loop","text":"<ul> <li>Run all synchronous code.</li> <li>Execute all micro-tasks from the micro-task queue.</li> <li>Pick the next macro-task from the macro-task queue.</li> <li>Repeat.</li> </ul>"},{"location":"eventloop/queue/#example-of-macro-micro-tasks","title":"Example of Macro &amp; Micro Tasks","text":"<pre><code>console.log(\"Start\");\n\nsetTimeout(() =&gt; {\n  console.log(\"Macro-task: setTimeout\");\n}, 0);\n\nPromise.resolve().then(() =&gt; {\n  console.log(\"Micro-task: Promise\");\n});\n\nconsole.log(\"End\");\n</code></pre>"},{"location":"eventloop/queue/#execution-flow","title":"Execution Flow","text":"<ol> <li><code>\"Start\"</code> \u2192 (Synchronous)</li> <li><code>\"End\"</code> \u2192 (Synchronous)</li> <li><code>\"Micro-task: Promise\"</code> \u2192 (Executed before macro-task)</li> <li><code>\"Macro-task: setTimeout\"</code> \u2192 (Executed after all micro-tasks)</li> </ol>"},{"location":"eventloop/queue/#why","title":"Why?","text":"<ul> <li>The promise callback goes into the micro-task queue.</li> <li>The <code>setTimeout</code> callback goes into the macro-task queue.</li> <li>Micro-tasks run before macro-tasks, so the promise executes first.</li> </ul>"},{"location":"eventloop/queue/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>\u2705 Micro-tasks have higher priority than macro-tasks</li> <li>\u2705 Promises execute before <code>setTimeout</code> due to micro-task priority</li> <li>\u2705 Event loop ensures non-blocking execution in JavaScript</li> </ul>"},{"location":"eventloop/queue/#reference","title":"Reference","text":"<ul> <li>JavaScript Microtask Vs. Macrotask \u2013 Differences Within The Event Loop</li> <li>https://www.naukri.com/code360/library/microtask-and-macrotask-in-javascript</li> <li> <p>Uncover the Secrets of JavaScript! What Are Call Stacks, Event Loops, Microtasks, and Macrotasks?</p> </li> <li> <p>Understanding the JavaScript Event Loop</p> </li> <li>Micro Task vs Macro Task</li> <li>Modern Browsers vs Node.js Architecture to handle Asynchronous Javascript</li> <li>Event Loop in JavaScript </li> </ul>"},{"location":"eventloop/shallow-copy/","title":"Shallow Copy","text":""},{"location":"eventloop/shallow-copy/#shallow-copy-reference-copy-for-non-primitives","title":"Shallow Copy = Reference Copy (for non-primitives)","text":"<p>Yes! By default, non-primitive types (<code>objects</code>, <code>arrays</code>, <code>functions</code>) are shallow copied in JavaScript.</p> <ul> <li>\ud83d\udd39 Primitive types are always copied by value (like a deep copy).</li> <li>\ud83d\udd39 Shallow copy and deep copy only apply to non-primitive types (<code>objects</code>, <code>arrays</code>, <code>functions</code>).</li> </ul>"},{"location":"eventloop/shallow-copy/#key-points","title":"Key Points:","text":"<ol> <li> <p>Shallow Copy = Reference Copy (for non-primitives)</p> <ul> <li>A shallow copy means a new variable gets a reference to the same object in memory, rather than duplicating the entire object.</li> <li>This applies only to non-primitive types (<code>objects</code>, <code>arrays</code>, <code>functions</code>).</li> </ul> <pre><code>let obj1 = { x: 10 };\nlet obj2 = obj1; // Shallow copy (both refer to the same object)\nobj2.x = 20;\nconsole.log(obj1.x); // 20 (changes reflected in both)\n</code></pre> </li> <li> <p>We Cannot Shallow Copy Primitive Types</p> <ul> <li>Primitive types (<code>number</code>, <code>string</code>, <code>boolean</code>, etc.) are always copied by value (deep copy behavior).</li> <li>Since primitives do not have internal references, the concept of a shallow copy does not apply to them.</li> </ul> <pre><code>let a = 10;\nlet b = a; // Deep copy (new independent value)\nb = 20;\nconsole.log(a); // 10 (unchanged)\n</code></pre> </li> </ol> <ul> <li>\u2705 Shallow copy = reference copy (for non-primitives)</li> <li>\u274c Primitive types cannot be shallow copied because they are always copied by value.</li> </ul> Final Summary <ul> <li>Shallow Copy copies only the top-level properties and references nested objects.</li> <li>Deep Copy duplicates the entire object, including all nested properties.</li> <li>By default, JavaScript makes shallow copies for non-primitives.</li> <li>To deep copy, you need explicit methods like <code>structuredClone()</code>, <code>JSON.parse(JSON.stringify())</code>, or Lodash's <code>_.cloneDeep()</code>.</li> </ul>"},{"location":"eventloop/shallow-copy/#difference-between-shallow-copy-and-deep-copy","title":"Difference Between Shallow Copy and Deep Copy","text":"Feature Shallow Copy \ud83d\udfe2 Deep Copy \ud83d\udd35 Definition Copies only the reference to the object, not its nested properties Creates a completely independent copy of the object and all its nested properties Effect on Nested Objects Changes in nested properties affect both the original and copied object Changes in nested properties do not affect the original object Performance Faster, as it only copies references Slower, as it creates new instances recursively Default Behavior in JS \u2705 Yes (for non-primitives) \u274c No (must be explicitly done) Example Methods <code>Object.assign()</code>, spread operator (<code>{ ...obj }</code>), <code>Array.prototype.slice()</code> <code>JSON.parse(JSON.stringify(obj))</code>, <code>structuredClone(obj)</code>, Lodash\u2019s <code>_.cloneDeep(obj)</code>"},{"location":"eventloop/shallow-copy/#question","title":"Question","text":"<p>Shallow copy and deep copy concepts do not apply to primitive types in JavaScript.</p> <p>Yes, exactly! \ud83d\ude80 Shallow copy and deep copy concepts do not apply to primitive types in JavaScript.</p> Why? <ul> <li>Primitive types (string, number, boolean, null, undefined, bigint, symbol) are immutable and stored by value.</li> <li>When assigned to a new variable, they are always copied by value, which behaves like a deep copy.</li> <li>Since primitives do not have nested structures or references, the concepts of shallow copy and deep copy are meaningless for them.</li> </ul> Example: Primitive Type Copying (Always By Value)<pre><code>let a = 10;\nlet b = a; // Copy by value (behaves like deep copy)\n\nb = 20; // Changing 'b' does not affect 'a'\n\nconsole.log(a); // 10 (Unchanged)\nconsole.log(b); // 20 (Modified)\n</code></pre> <p>\u2705 Since <code>b</code> gets a separate copy of <code>a</code>, modifying <code>b</code> does not affect <code>a</code>.</p> Why Does Shallow vs Deep Copy Matter Only for Non-Primitives? <p>Non-primitive types (<code>objects</code>, <code>arrays</code>, <code>functions</code>) are stored by reference.</p> <ul> <li>A shallow copy creates a new reference to the same object.</li> <li>A deep copy creates a completely independent clone.</li> </ul> Final Answer <ul> <li>\ud83d\udd39 Primitive types are always copied by value (like a deep copy).</li> <li>\ud83d\udd39 Shallow copy and deep copy only apply to non-primitive types (<code>objects</code>, <code>arrays</code>, <code>functions</code>).</li> </ul>"},{"location":"fp/books/","title":"Books","text":""},{"location":"fp/definition/","title":"Definition","text":""},{"location":"fp/definition/#programming-paradigms","title":"Programming Paradigms","text":"<p>A programming paradigm is a style, or \u201cway,\u201d of programming.</p> <p>Some languages make it easy to write in some paradigms but not others.</p> Warning <p>Never use the phrase \u201cprogramming language paradigm.\u201d</p> <p>A paradigm is a way of doing something (like programming), not a concrete thing (like a language). Now, it\u2019s true that if a programming language L happens to make a particular programming paradigm P easy to express, then we often say \u201cL is a P language\u201d (e.g. \u201cHaskell is a functional programming language\u201d) but that does not mean there is any such thing as a \u201cfunctional language paradigm\u201d.</p> <p>Paradigms are not meant to be mutually exclusive; a single program can feature multiple paradigms!</p> <p>Functional Programming For Dummies by John Paul Mueller, 10</p>"},{"location":"fp/definition/#high-order-functions-hoc","title":"High Order Functions (HOC)","text":"<p>Higher-order functions are central to functional programming and flow naturally from the idea that functions should be \u201cfirst-class objects\u201d in a language, with all of the rights and privileges that numbers or lists have.</p> <p>A higher-order function is one that accepts a function as input and/or returns a function as output.</p> <ul> <li>LEARN PHYSICS WITH FUNCTIONAL PROGRAMMING by 2023 by Scott N. Walck</li> </ul> <p>A function that takes another function as a parameter, or returns a function as a result, is known as a high-order function.</p> <ul> <li>Quick Functional Programming by David Matuszek</li> </ul> <p>A function that accepts another function as a parameter, or returns a function, or both, is known as a higher order function.</p> <p>Memoization is the process where interim values are cached rather than recreated, cutting down on the number of iterations and computation time.</p> <ul> <li>JavaScript Cookbook, Second Edition by Shelley Powers, pg: 80</li> </ul> Note <p>In a functional language, functions are values.</p> <p>This means that they can be stored in variables, passed around as parameters, and returned as the result of a function calls, just like any other type of value. There are even operations on functions that produce new functions.</p> <ul> <li>Quick Functional Programming by David Matuszek</li> </ul>"},{"location":"fp/definition/#currying","title":"Currying","text":"<p>Currying is a technique to convert a function that takes multiple parameters into a series of functions, each taking a single function.</p> <ul> <li>Quick Functional Programming by David Matuszek : pg-67</li> </ul> Note <p>No Description of Functional programming would be complete without a mention of currying. Curring is a technique developed by the mathematician Haskell Curry (the programing language Haskell is also named after him).</p>"},{"location":"fp/definition/#key-features-of-javascript","title":"Key features of JavaScript","text":"<p>JavaScript isn\u2019t a purely functional language, but it has all the features that we need for it to work as if it were. The main features of the language that we will be using are as follows:</p> <ul> <li>Functions as first-class objects</li> <li>Recursion</li> <li>Closures</li> <li>Arrow functions</li> <li>Spread</li> </ul> <p>Functions as first-class objects</p> <p>Saying that functions are first-class objects (also called first-class entities or first-class citizens) means that you can do everything with functions that you can do with other objects. For example, you can store a function in a variable, you can pass it to a function, you can print it out, and so on. This is really the key to doing FP; we will often be passing functions as parameters (to other functions) or returning a function as the result of a function call. If you have been doing <code>async</code> Ajax calls, then you have already been using this feature: a <code>callback</code> is a function that will be called after the Ajax call finishes and is passed as a parameter. Using jQuery, you could write something like the following:</p> <pre><code>$.get(\"some/url\", someData, function (result, status) {\n  // check status, and do something\n  // with the result\n});\n</code></pre> <p>The <code>$.get()</code> function receives a callback function as a parameter and calls it after the result is obtained.</p> The way to go <p>This is better solved, in a more modern way, by using promises or async/await, but for the sake of our example, the old way is enough. We\u2019ll be getting back to promises, though, in Chapter 12, Building Better Containers, when we discuss monads; in particular, see the Unexpected monads \u2013 promises section.</p> 3 basic ways to define function <p>JavaScript functions provide a way to encapsulate a block of code in order to reuse the code several times. They are first-class objects in JavaScript, which means they can be treated as an object, as well as an expression or statement.</p> <ul> <li>JavaScript Cookbook, Second Edition by Shelley Powers, pg: 61</li> </ul> note <p>An important concept to remember when considering the different ways you can create a function is hoisting. In JavaScript, all variable declarations are moved, or hoisted to the top of their current scope.</p> <p>That\u2019s declaration, though, not instantiation. The difference is critical. If you access a variable that\u2019s not declared, you\u2019ll get a <code>reference error</code>.</p> <p>However, if you access a variable before it\u2019s declared, but it is declared within the scope at a later time, you\u2019ll get an <code>undefined</code>:</p> <ul> <li>JavaScript Cookbook, Second Edition by Shelley Powers, pg: 62</li> </ul>"},{"location":"fp/definition/#asynchronous-operations","title":"Asynchronous Operations","text":"<p>Asynchronous operations are operations that happen outside the linear flow of program execution. Normally, the JavaScript engine will execute code line by line, in order from top to bottom, following the normal flow of your program (such as function calls, con\u2010 ditional logic, etc.).</p> <p>Asynchronous operations are broken up into two phases:</p> <ul> <li>call &amp;</li> <li>response.</li> </ul> <p>By definition, it\u2019s impossible to know at what point in the program flow you\u2019ll be when you receive an asynchronous response. There are a couple of popular ways to manage that uncertainty.</p>"},{"location":"fp/definition/#callbacks","title":"Callbacks","text":"<ul> <li>Callbacks are functions that you pass as arguments to be invoked when the callee has finished its job.</li> <li>Callbacks are commonly passed into event handlers, Ajax requests, and timers.</li> </ul> <p>You should already be familiar with passing callbacks to event listeners and timers:</p> CodeExplanation <pre><code>var $button = $('&lt;button class=\"select\"&gt;Click&lt;/button&gt;').appendTo(\"body\");\n\nasyncTest(\"Async callback event listener.\", function () {\n    $button.on(\"click\", function clicked() {\n        ok(true, \"Button clicked.\");\n        start();\n    });\n\n    setTimeout(function timedOut() {\n        $button.click();\n        $button.remove();\n    }, 20);\n});\n</code></pre> <p>In this code, the <code>clicked()</code> callback gets passed into into jQuery\u2019s <code>.on()</code> method. When <code>$button</code> receives a click event, it invokes <code>clicked()</code>, which runs the <code>ok()</code> assertion and then <code>start()</code>, which tells QUnit that it\u2019s finished waiting for asynchronous operations so it can continue to run tests.</p> <p>Next, the <code>timedOut()</code> callback is passed into <code>setTimeout()</code>, which triggers the click event on <code>$button</code> and removes the button from the DOM.</p> <p>Callbacks work great when you\u2019re only waiting for one operation at a time, or when you only have one job to do when the response comes back, but what if you need to manage multiple asynchronous dependencies or you have several unrelated tasks waiting on the same data (such as a provider authorization)? That\u2019s where promises can be very useful.</p>"},{"location":"fp/definition/#promises","title":"Promises","text":"<ul> <li>Promises are objects that allow you to add callback functions to success or failure queues.</li> <li>Instead of calling a callback function in response to the completion of an asynchronous (or synchronous) operation, you return a promise, which allows you to register any number of callbacks.</li> </ul> <p>The promise provides access to the state of the operation: whether it\u2019s <code>waiting</code> or <code>finished</code>, and in some cases, what the progress is. You can add callbacks to a promise at any time, which will trigger after the operation is complete and the promise is resolved. If the promise has already resolved, the callback will be invoked immediately.</p> <pre><code>var whenDataFetched = $.getJSON(\"https://graph.facebook.com/jsapplications\");\n\nasyncTest(\"Ajax promise API\", function () {\n  whenDataFetched\n    .done(function (response) {\n      ok(response, \"The server returned data.\");\n      start();\n    })\n    .fail(function () {\n      ok(true, \"There was an error.\");\n      start();\n    });\n});\n</code></pre> Note <p>The difference between a promise and a callback is that a promise is an object that gets returned from the callee, instead of a function that gets passed into and invoked by the callee. With promises, it\u2019s much easier to add additional callbacks if you need them and to isolate those callbacks from each other so that the callback code can be organized independently of the initiating call.</p> <p>Programming Javascript Applications by Eric Elliott - Orielly - pg: 41</p>"},{"location":"fp/definition/#click-this-link-closure","title":"click this link: Closure","text":""},{"location":"fp/definition/#click-this-link-js-data-types","title":"click this link: JS Data Types:","text":""},{"location":"fp/intro/","title":"Intro","text":"<p>Functional Programming</p> <ul> <li> <p>Functional programming is a style of programming that uses higher-order functions (as opposed to objects and data) to facilitate code organization and reuse. A higher order function treats functions as data, either taking a function as an argument or returning a function as a result.</p> </li> <li> <p>Programming Javascript Applications by Eric Elliott - Orielly, pg-36</p> </li> </ul> <p></p> Note <p>In Nepali, the term \"paradigm\" is commonly translated as \"\u092a\u093e\u0930\u093e\u0921\u093e\u0907\u092e\" (pronounced p\u0101r\u0101\u1e0d\u0101'ima) or \"\u0935\u093f\u091a\u093e\u0930\u0927\u093e\u0930\u093e\" (vich\u0101radh\u0101r\u0101), which means \"thought process\" or \"philosophy.\" The second term is more focused on the idea of a mindset or approach to thinking, which aligns with the concept of a paradigm in a more general sense.</p> <p>In the context of programming paradigms, it would typically be referred to as \"\u0915\u093e\u0930\u094d\u092f\u0935\u093f\u0927\u093f\" (k\u0101ryavidh\u012b), which means \"methodology\" or \"approach to work.\"</p> Quote <p>One of the best ways to learn something is to teach it.</p> <ul> <li>LEARN PHYSICS WITH FUNCTIONAL PROGRAMMING by 2023 by Scott N. Walck</li> </ul>"},{"location":"fp/principle/","title":"Principle","text":""},{"location":"fp/principle/#overview","title":"Overview","text":"<p>The main principles of functional programming (FP) that are consistent across all functional programming languages are:</p> <ol> <li> <p>First-Class and Higher-Order Functions:</p> <ul> <li>Functions are treated as first-class citizens, meaning they can be passed as arguments, returned from other functions, and assigned to variables.</li> <li>Higher-order functions are those that can take other functions as parameters or return them as results.</li> </ul> </li> <li> <p>Immutability:</p> <ul> <li>Data is immutable by default, meaning once a value is assigned to a variable, it cannot be changed. Instead of modifying values, new values are created by applying functions to existing ones.</li> </ul> </li> <li> <p>Pure Functions:</p> <ul> <li>A function is considered pure if it always produces the same output for the same input and has no side effects (e.g., no changes to the state of the system or I/O operations).</li> </ul> </li> <li> <p>Referential Transparency:</p> <ul> <li>An expression is referentially transparent if it can be replaced with its value without changing the program's behavior. This relies on pure functions and immutability.</li> </ul> </li> <li> <p>Function Composition:</p> <ul> <li>Functions can be composed to build more complex functions. The output of one function can be passed as the input to another, allowing for modular and reusable code.</li> </ul> </li> <li> <p>Lazy Evaluation:</p> <ul> <li>Computation is deferred until the value is actually needed. This can improve performance by avoiding unnecessary calculations and allows for the creation of infinite data structures.</li> </ul> </li> <li> <p>Declarative Style:</p> <ul> <li>Functional programming emphasizes describing what should be done, rather than how to do it (which is more typical in imperative programming). This leads to code that is more readable and easier to maintain.</li> </ul> </li> <li> <p>Avoidance of State and Side Effects:</p> <ul> <li>Functional programming avoids mutable state and side effects. This contrasts with imperative programming, where variables can change and side effects (such as I/O or changes to shared state) are common.</li> </ul> </li> <li> <p>Recursion:</p> <ul> <li>Recursion is a fundamental technique for looping or iteration in functional programming, since mutable state and traditional loops (like for or while) are avoided. Functions often call themselves to solve problems.</li> </ul> </li> <li> <p>Type Systems (in many FP languages):</p> <ul> <li>Many functional programming languages make extensive use of static typing and strong type systems to ensure correctness and reduce errors. Types often enable powerful features like type inference and higher-order type relationships.</li> </ul> </li> </ol> <p>These principles are core to the philosophy of functional programming, and while implementation may vary slightly across languages (e.g., Haskell, Scala, or F#), these concepts remain central to FP.</p>"},{"location":"fp/principle/#in-js","title":"In JS","text":"<p>Yes, many principles of functional programming can be applied in JavaScript, although JavaScript is not a purely functional programming language. It is a multi-paradigm language that supports functional, object-oriented, and imperative programming styles. Here's how JavaScript aligns with the core principles of functional programming:</p> <ol> <li> <p>First-Class and Higher-Order Functions</p> <ul> <li> <p>Yes. In JavaScript, functions are first-class citizens, meaning they can be passed as arguments, returned from other functions, and assigned to variables. JavaScript supports higher-order functions as well, where functions can take other functions as parameters or return them.</p> <pre><code>const add = (a, b) =&gt; a + b;\nconst applyOperation = (a, b, operation) =&gt; operation(a, b);\n\nconsole.log(applyOperation(2, 3, add)); // Output: 5\n</code></pre> </li> </ul> </li> <li> <p>Immutability</p> <ul> <li> <p>Partially. JavaScript does not enforce immutability by default, but it is possible to achieve immutability with techniques such as using <code>const</code> for variable declarations and libraries like Immutable.js or using features like <code>Object.freeze</code> or <code>Array.prototype.map</code> to avoid mutation.</p> <pre><code>const arr = [1, 2, 3];\nconst newArr = arr.map((x) =&gt; x * 2); // Creates a new array, doesn't mutate `arr`\nconsole.log(arr); // Output: [1, 2, 3]\nconsole.log(newArr); // Output: [2, 4, 6]\n</code></pre> </li> </ul> </li> <li> <p>Pure Functions</p> <ul> <li> <p>Yes. JavaScript supports pure functions, which return the same output for the same input and have no side effects. Writing pure functions in JavaScript is encouraged in functional programming practices.</p> <pre><code>const add = (a, b) =&gt; a + b; // Pure function\n</code></pre> </li> </ul> </li> <li> <p>Referential Transparency</p> <ul> <li> <p>Yes, but it's up to the developer to ensure that functions are pure and do not rely on mutable state, which allows for referential transparency.</p> <pre><code>const double = (x) =&gt; x * 2;\n// double(4) is referentially transparent; it can be replaced with 8\n</code></pre> </li> </ul> </li> <li> <p>Function Composition</p> <ul> <li> <p>Yes. JavaScript allows function composition, often done through chaining or using techniques like <code>compose</code> or <code>pipe</code> (popular in libraries like Ramda).</p> Example (using Ramda)<pre><code>const R = require(\"ramda\");\nconst add5 = (x) =&gt; x + 5;\nconst multiply2 = (x) =&gt; x * 2;\nconst composeFunc = R.compose(multiply2, add5); // Function composition\nconsole.log(composeFunc(3)); // Output: 16 (multiply2(add5(3)))\n</code></pre> </li> </ul> </li> <li> <p>Lazy Evaluation</p> <ul> <li> <p>Partially. JavaScript does not have built-in lazy evaluation, but it can be implemented using techniques such as generators or libraries like Lazy.js.</p> Example (using a generator function)<pre><code>function* range(start, end) {\n    while (start &lt; end) {\n    yield start++;\n    }\n}\nconst gen = range(1, 5);\nconsole.log(gen.next().value); // Output: 1 (evaluates lazily)\n</code></pre> </li> </ul> </li> <li> <p>Declarative Style</p> <ul> <li> <p>Yes. JavaScript allows for a declarative style, especially when working with arrays using methods like <code>map</code>, <code>filter</code>, <code>reduce</code>, etc. These methods help express what should be done, not how.</p> <pre><code>const arr = [1, 2, 3, 4];\nconst doubled = arr.map((x) =&gt; x * 2); // Declarative approach\n</code></pre> </li> </ul> </li> <li> <p>Avoidance of State and Side Effects</p> <ul> <li> <p>Partially. While JavaScript allows side effects (e.g., modifying global state, interacting with I/O), you can still minimize side effects by writing pure functions. Frameworks and libraries like React encourage minimizing side effects.</p> <pre><code>const sum = (a, b) =&gt; a + b; // No side effects\n</code></pre> </li> </ul> </li> <li> <p>Recursion</p> <ul> <li> <p>Yes. JavaScript supports recursion, and while it does not have tail call optimization (which could make recursion more efficient), recursion is commonly used in functional programming.</p> <pre><code>const factorial = (n) =&gt; (n === 0 ? 1 : n * factorial(n - 1));\nconsole.log(factorial(5)); // Output: 120\n</code></pre> </li> </ul> </li> <li> <p>Type Systems</p> <ul> <li>Partially. JavaScript is dynamically typed, meaning types are not enforced at compile time. However, with TypeScript (a superset of JavaScript), you get strong static typing that helps in ensuring type correctness, similar to the type systems in functional programming languages.</li> </ul> </li> </ol> <p>Summary</p> <p>While JavaScript does not enforce functional programming principles as strictly as purely functional languages like Haskell, it can still support functional programming paradigms. You can write <code>pure functions</code>, <code>use higher-order functions</code>, <code>avoid side effects</code>, and <code>emphasize immutability</code> in JavaScript with proper discipline. Libraries like Ramda and Lodash also offer functional programming utilities to help adopt a more functional style in JavaScript.</p>"},{"location":"fp/principle/#in-react","title":"In React","text":"<p>In React, you can apply many functional programming principles, and it's actually encouraged to write pure, declarative, and immutable code when working with React components. While React itself is a JavaScript library (which is multi-paradigm), it has a strong functional programming influence, especially with the introduction of React Hooks and function components.</p> <p>Here's how <code>functional programming principles</code> apply in React:</p> <ol> <li> <p>First-Class and Higher-Order Functions</p> <p>React components (especially with Hooks) are functions that can accept other functions as props or return other functions.</p> <ul> <li> <p>Higher-order functions in React: Functions that take other functions as arguments or return them as results (like render props or HOCs (Higher-Order Components)).</p> Higher-Order Component (HOC)<pre><code>// A higher-order component that adds a `count` state to any component\nconst withCounter = (WrappedComponent) =&gt; {\n  return function EnhancedComponent(props) {\n      const [count, setCount] = useState(0);\n      return &lt;WrappedComponent count={count} setCount={setCount} {...props} /&gt;;\n  };\n};\n\nconst MyComponent = ({ count, setCount }) =&gt; (\n  &lt;div&gt;\n      &lt;p&gt;Count: {count}&lt;/p&gt;\n      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;\n  &lt;/div&gt;\n);\n\nconst EnhancedComponent = withCounter(MyComponent);\n</code></pre> </li> </ul> </li> <li> <p>Immutability</p> <p>In React, state is often <code>immutable</code>. When state changes, instead of modifying the existing state, you create a <code>new state object</code>.</p> <pre><code>import React, { useState } from \"react\";\n\nconst Counter = () =&gt; {\n  const [count, setCount] = useState(0);\n\n  const increment = () =&gt; setCount((prevCount) =&gt; prevCount + 1);\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Count: {count}&lt;/p&gt;\n      &lt;button onClick={increment}&gt;Increment&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n</code></pre> <p>Here, <code>setCount</code> does not mutate the <code>count</code> directly but creates a new state value, which is the core of immutability in React.</p> </li> <li> <p>Pure Functions</p> <p>React components can be considered <code>pure functions</code> if they always return the same output for the same input and do not cause side effects.</p> <pre><code>const Greeting = ({ name }) =&gt; {\n  return &lt;h1&gt;Hello, {name}!&lt;/h1&gt;;\n};\n</code></pre> <p>In this example, the <code>Greeting</code> component is a pure function since it takes <code>name</code> as input and always returns the same output for the same <code>name</code>.</p> </li> <li> <p>Referential Transparency</p> <p>React encourages referential transparency in its components. If you replace a component call with its output, the behavior of the app won't change.</p> <pre><code>const Double = ({ value }) =&gt; value * 2;\n\nconst App = () =&gt; {\n  const number = 5;\n  return &lt;Double value={number} /&gt;;\n};\n</code></pre> <p>Here, you can replace <code>&lt;Double value={number} /&gt;</code> with the value <code>10</code>, and the behavior would remain the same.</p> </li> <li> <p>Function Composition</p> <p>You can compose functions to combine their behavior. This is often done with <code>custom hooks</code> or by chaining functions.</p> <pre><code>const withUppercase = (WrappedComponent) =&gt; {\n  return (props) =&gt; (\n    &lt;WrappedComponent {...props} text={props.text.toUpperCase()} /&gt;\n  );\n};\n\nconst DisplayText = ({ text }) =&gt; &lt;p&gt;{text}&lt;/p&gt;;\n\nconst EnhancedDisplayText = withUppercase(DisplayText);\n\n// Usage\n&lt;EnhancedDisplayText text=\"hello world\" /&gt;;\n</code></pre> <p>Here, the <code>withUppercase</code> HOC composes a function to convert the text to uppercase before passing it down to the <code>DisplayText</code> component.</p> </li> <li> <p>Lazy Evaluation</p> <p>In React, you can achieve <code>lazy evaluation</code> by <code>lazily loading components</code>. This helps improve performance by only loading components when they're needed.</p> <pre><code>import React, { Suspense, lazy } from \"react\";\n\n// Lazy load the component\nconst LazyComponent = lazy(() =&gt; import(\"./LazyComponent\"));\n\nconst App = () =&gt; (\n  &lt;div&gt;\n    &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;\n      &lt;LazyComponent /&gt;\n    &lt;/Suspense&gt;\n  &lt;/div&gt;\n);\n</code></pre> <p>In this example, <code>LazyComponent</code> is loaded only when it's required (i.e., when it's rendered), which aligns with lazy evaluation.</p> </li> <li> <p>Declarative Style</p> <p>React is all about <code>declarative programming</code>. You describe what the UI should look like based on the state, and React takes care of updating the DOM accordingly.</p> <pre><code>const TodoList = ({ todos }) =&gt; (\n  &lt;ul&gt;\n    {todos.map((todo, index) =&gt; (\n      &lt;li key={index}&gt;{todo}&lt;/li&gt;\n    ))}\n  &lt;/ul&gt;\n);\n</code></pre> <p>Here, you're declaring the structure of the UI based on the <code>todos</code> array, and React handles rendering and updating the DOM.</p> </li> <li> <p>Avoidance of State and Side Effects</p> <p>React encourages using pure components (components that don\u2019t cause side effects) and managing side effects through React Hooks (<code>useEffect</code>).</p> <ul> <li> <p>You can isolate side effects in <code>useEffect</code>, making components predictable and easy to reason about.</p> <pre><code>import React, { useState, useEffect } from \"react\";\n\nconst Timer = () =&gt; {\n  const [seconds, setSeconds] = useState(0);\n\n  useEffect(() =&gt; {\n      const intervalId = setInterval(() =&gt; {\n          setSeconds((prev) =&gt; prev + 1);\n      }, 1000);\n\n     return () =&gt; clearInterval(intervalId); // Cleanup side effect on component unmount\n  }, []);\n\n  return &lt;div&gt;Time: {seconds}s&lt;/div&gt;;\n};\n</code></pre> <p>In this example, the side effect (interval timer) is handled in <code>useEffect</code>, and the effect is cleaned up when the component unmounts.</p> </li> </ul> </li> <li> <p>Recursion</p> <p>React components can use <code>recursion</code> for rendering nested structures, like trees or lists.</p> <pre><code>const Tree = ({ node }) =&gt; {\n  return (\n    &lt;div&gt;\n      &lt;p&gt;{node.name}&lt;/p&gt;\n      {node.children &amp;&amp; (\n        &lt;div style={{ marginLeft: 20 }}&gt;\n          {node.children.map((child, index) =&gt; (\n            &lt;Tree key={index} node={child} /&gt;\n          ))}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nconst data = {\n  name: \"Root\",\n  children: [\n    { name: \"Child 1\" },\n    { name: \"Child 2\", children: [{ name: \"Grandchild 1\" }] },\n  ],\n};\n\nconst App = () =&gt; &lt;Tree node={data} /&gt;;\n</code></pre> <p>This is an example of recursive rendering of a tree structure in React.</p> </li> <li> <p>Type Systems</p> <p>React is <code>dynamically typed</code>, but you can improve type safety by using <code>TypeScript</code> or <code>PropTypes</code>.</p> PropTypes<pre><code>import PropTypes from \"prop-types\";\n\nconst Greeting = ({ name }) =&gt; &lt;h1&gt;Hello, {name}!&lt;/h1&gt;;\n\nGreeting.propTypes = {\n  name: PropTypes.string.isRequired,\n};\n</code></pre> Example with TypeScript<pre><code>interface GreetingProps {\n  name: string;\n}\n\nconst Greeting = ({ name }: GreetingProps) =&gt; &lt;h1&gt;Hello, {name}!&lt;/h1&gt;;\n</code></pre> <p>In both examples, you're using types to ensure that the name <code>prop</code> is a string and is provided.</p> </li> </ol> <p>Summary</p> <p>While React is not a pure functional programming language, it encourages many functional programming principles, especially with the advent of function components and React Hooks. By writing <code>pure</code>, <code>declarative</code>, and <code>immutable code</code>, React developers can create applications that are easier to reason about and maintain, leveraging functional programming techniques where appropriate.</p>"},{"location":"fundamental/intro/","title":"Overview","text":""},{"location":"fundamental/closure/javascript-closures/","title":"JS Closure","text":""},{"location":"fundamental/closure/javascript-closures/#javascript-closures","title":"JavaScript Closures","text":""},{"location":"fundamental/closure/javascript-closures/#what-is-a-closure","title":"What is a Closure?","text":"<p>A closure is a feature in JavaScript where an inner function has access to the outer (enclosing) function's variables. A closure has three scopes:</p> <ol> <li>Local scope (Own scope)</li> <li>Outer function\u2019s scope</li> <li>Global scope</li> </ol>"},{"location":"fundamental/closure/javascript-closures/#why-use-closures","title":"Why Use Closures?","text":"<p>Closures are used in JavaScript for several reasons:</p> <ul> <li>To create private variables or methods.</li> <li>To emulate block scope in pre-ES6 JavaScript.</li> <li>To maintain a reference to variables from an outer scope.</li> </ul>"},{"location":"fundamental/closure/javascript-closures/#practical-examples","title":"Practical Examples","text":""},{"location":"fundamental/closure/javascript-closures/#example-1-basic-closure","title":"Example 1: Basic Closure","text":"<pre><code>function outerFunction() {\n  let outerVariable = \"I am from outer function\";\n\n  function innerFunction() {\n    console.log(outerVariable); // innerFunction has access to outerVariable\n  }\n\n  return innerFunction;\n}\n\nconst closureFunction = outerFunction();\nclosureFunction(); // Output: I am from outer function\n</code></pre>"},{"location":"fundamental/closure/javascript-closures/#example-2-data-privacy","title":"Example 2: Data Privacy","text":"<p>Closures can be used to create private variables.</p> <pre><code>function createCounter() {\n  let count = 0; // Private variable\n\n  return {\n    increment: function () {\n      count++;\n      return count;\n    },\n    decrement: function () {\n      count--;\n      return count;\n    },\n    getCount: function () {\n      return count;\n    },\n  };\n}\n\nconst counter = createCounter();\nconsole.log(counter.increment()); // Output: 1\nconsole.log(counter.increment()); // Output: 2\nconsole.log(counter.decrement()); // Output: 1\nconsole.log(counter.getCount()); // Output: 1\n</code></pre>"},{"location":"fundamental/closure/javascript-closures/#example-3-emulating-block-scope-pre-es6","title":"Example 3: Emulating Block Scope (pre-ES6)","text":"<p>Before ES6, JavaScript did not have block scope. Closures were used to emulate block scope.</p> <pre><code>for (var i = 1; i &lt;= 3; i++) {\n  (function (i) {\n    setTimeout(function () {\n      console.log(i); // Output: 1, 2, 3\n    }, i * 1000);\n  })(i);\n}\n</code></pre>"},{"location":"fundamental/closure/javascript-closures/#example-4-function-factory","title":"Example 4: Function Factory","text":"<p>Closures can be used to create function factories.</p> <pre><code>function createGreeter(greeting) {\n  return function (name) {\n    console.log(greeting + \", \" + name);\n  };\n}\n\nconst sayHello = createGreeter(\"Hello\");\nsayHello(\"Alice\"); // Output: Hello, Alice\n\nconst sayHi = createGreeter(\"Hi\");\nsayHi(\"Bob\"); // Output: Hi, Bob\n</code></pre>"},{"location":"fundamental/closure/javascript-closures/#conclusion","title":"Conclusion","text":"<p>Closures are a powerful feature in JavaScript that allow functions to access variables from an outer scope. They are useful for creating private variables, emulating block scope, and generating function factories. Understanding closures is essential for mastering JavaScript and writing more efficient and secure code.</p>"},{"location":"fundamental/closure/overview/","title":"Overview","text":""},{"location":"fundamental/closure/overview/#what-is-a-closure-in-javascript-provide-an-example","title":"What is a \"closure\" in JavaScript? Provide an example.","text":"<p>A closure is a function defined inside another function (called the parent function), and has access to variables that are declared and defined in the parent function scope.</p> <p>The closure has access to variables in three scopes:</p> <ul> <li>Variables declared in their own scope.</li> <li>Variables declared in a parent function scope.</li> <li>Variables declared in the global namespace.</li> </ul> <pre><code>var globalVar = \"abc\";\n\n// Parent self-invoking function\n(function outerFunction(outerArg) {\n  // Begin of scope outerFunction\n\n  // Variable declared in outerFunction function scope\n  var outerFuncVar = \"x\"; // Fixed invalid quotation marks\n\n  // Closure self-invoking function\n  (function innerFunction(innerArg) {\n    // Begin of scope innerFunction\n\n    // Variable declared in innerFunction function scope\n    var innerFuncVar = \"y\";\n    console.log(\n      \"outerArg = \" +\n        outerArg +\n        \"\\n\" +\n        \"outerFuncVar = \" +\n        outerFuncVar +\n        \"\\n\" +\n        \"innerArg = \" +\n        innerArg +\n        \"\\n\" +\n        \"innerFuncVar = \" +\n        innerFuncVar +\n        \"\\n\" +\n        \"globalVar = \" +\n        globalVar\n    );\n  })(\n    // End of scope innerFunction\n    5\n  ); // Pass 5 as parameter\n})(\n  // End of scope outerFunction\n  7\n); // Pass 7 as parameter\n</code></pre> <p><code>innerFunction</code> is closure that is defined inside <code>outerFunction</code> and has access to all variables declared and defined in the <code>outerFunction</code> scope. In addition, the function defined inside another function as a closure will have access to variables declared in the <code>global namespace</code>.</p> <p>Thus, the output of the code above would be:</p> <pre><code>outerArg = 7\nouterFuncVar = x\ninnerArg = 5\ninnerFuncVar = y\nglobalVar = abc\n</code></pre> <p>pg: 21. JavaScript Interview Questions by Fabio Cimo</p>"},{"location":"fundamental/closure/overview/#what-are-javascript-data-types","title":"What are JavaScript data types?","text":"<p>In JavaScript, there are <code>three</code> primary data types, <code>two</code> composite data types, and <code>two</code> special data types.</p> <p>Primary Data Types</p> <ul> <li>String</li> <li>Number</li> <li>Boolean</li> </ul> <p>Composite Data Types</p> <ul> <li>Object</li> <li>Array</li> </ul> <p>Special Data Types</p> <ul> <li>Null</li> <li>Undefined</li> </ul> <p>pg: 6. JavaScript Interview Questions by Fabio Cimo</p>"},{"location":"fundamental/closure/overview/#define-event-bubbling","title":"Define event bubbling","text":"<p>JavaScript allows DOM elements to be nested inside each other. In such a case, if the handler of the child is clicked, the handler of parent will also work as if it were clicked too.</p> <p>pg: 7. JavaScript Interview Questions by Fabio Cimo</p>"},{"location":"fundamental/closure/overview/#what-are-screen-objects","title":"What are Screen objects?","text":"<p>Screen objects are used to read the information from the client\u2019s screen. The properties of screen objects are -</p> <ul> <li><code>AvalHeight</code>: Gives the height of client\u2019s screen.</li> <li><code>AvailWidth</code>: Gives the width of client\u2019s screen.</li> <li><code>ColorDepth</code>: Gives the bit depth of images on the client\u2019s screen</li> <li><code>Height</code>: Gives the total height of the client\u2019s screen, including the taskbar</li> <li><code>Width</code>: Gives the total width of the client\u2019s screen, including the taskbar</li> </ul>"},{"location":"fundamental/closure/overview/#books","title":"Books","text":""},{"location":"fundamental/closure/overview/#reference","title":"Reference","text":"<ul> <li>jsbin.com</li> </ul>"},{"location":"fundamental/js-async/overview/","title":"Overview","text":""},{"location":"fundamental/js-async/overview/#overview","title":"Overview","text":""},{"location":"fundamental/js-async/overview/#javascript-callbacks","title":"JavaScript Callbacks","text":"<p>A callback is a function passed as an argument to another function.</p> <pre><code>function myDisplayer(some) {\n  document.getElementById(\"demo\").innerHTML = some;\n}\n\nfunction myCalculator(num1, num2, myCallback) {\n  let sum = num1 + num2;\n  myCallback(sum);\n}\n\nmyCalculator(5, 5, myDisplayer);\n</code></pre> <ul> <li>In the example above, <code>myDisplayer</code> is a called a callback function.</li> <li>It is passed to <code>myCalculator()</code> as an argument.</li> </ul>"},{"location":"fundamental/js-async/overview/#callback-alternatives","title":"Callback Alternatives","text":"<p>With asynchronous programming, JavaScript programs can start long-running tasks, and continue running other tasks in parallel.</p> <p>But, asynchronus programmes are difficult to write and difficult to debug.</p> <p>Because of this, most modern asynchronous JavaScript methods don't use callbacks. Instead, in JavaScript, asynchronous programming is solved using Promises instead.</p> <p></p>"},{"location":"fundamental/js-async/overview/#reference","title":"Reference","text":"<ul> <li>javascript.info: Promise Basic</li> <li>programmiz: promise</li> <li>Developer mozzila: Promise</li> </ul>"},{"location":"fundamental/js-async/promise-code/","title":"Code","text":""},{"location":"fundamental/js-async/promise-code/#promise-code","title":"Promise Code","text":"<p>In JavaScript, a Promise is an object that represents the eventual completion (or failure) of an asynchronous operation and its resulting value. It\u2019s a way to handle asynchronous tasks, like fetching data from an API, reading files, or executing timeouts, in a more manageable way than callbacks. A Promise can be in one of three states:</p> <ul> <li>Pending: Initial state, neither fulfilled nor rejected.</li> <li>Fulfilled: The operation completed successfully, and a value is returned.</li> <li>Rejected: The operation failed, and an error is returned.</li> </ul> <p>Promises are created using the <code>Promise</code> constructor and can be chained with <code>.then()</code> and <code>.catch()</code> methods to handle the resolved value or errors. They also support <code>async/await</code> syntax for cleaner asynchronous code.</p> <p>Here\u2019s a brief overview of Promises and some practical \"hacks\" or techniques to use them effectively in JavaScript:</p>"},{"location":"fundamental/js-async/promise-code/#what-is-a-promise","title":"What is a Promise?","text":"<p>A Promise is created like this:</p> <pre><code>const myPromise = new Promise((resolve, reject) =&gt; {\n  // Asynchronous operation (e.g., fetching data)\n  setTimeout(() =&gt; {\n    const success = true; // Simulating a condition\n    if (success) {\n      resolve(\"Operation successful!\");\n    } else {\n      reject(\"Operation failed!\");\n    }\n  }, 1000);\n});\n</code></pre> <p>You can handle the result using:</p> javascript<pre><code>myPromise\n  .then((result) =&gt; console.log(result)) // \"Operation successful!\"\n  .catch((error) =&gt; console.error(error));\n</code></pre> <p>Or with <code>async/await</code>:</p> javascript<pre><code>async function handlePromise() {\n  try {\n    const result = await myPromise;\n    console.log(result);\n  } catch (error) {\n    console.error(error);\n  }\n}\n\nhandlePromise();\n</code></pre> Example<pre><code>const myPromise = new Promise((resolve, reject) =&gt; {\n  // Asynchronous operation: fetching data from an API\n  fetch(\"https://jsonplaceholder.typicode.com/posts/1\") // Example API\n    .then((response) =&gt; {\n      if (!response.ok) {\n        // If the HTTP status is not OK (e.g., 404, 500), reject the Promise\n        throw new Error(`HTTP error! Status: ${response.status}`);\n      }\n      return response.json(); // Parse the JSON response\n    })\n    .then((data) =&gt; {\n      resolve(data); // Resolve the Promise with the API data\n    })\n    .catch((error) =&gt; {\n      reject(error); // Reject the Promise if there's an error (e.g., network failure)\n    });\n});\n\n// Using the Promise\nmyPromise\n  .then((data) =&gt; console.log(\"API Response:\", data))\n  .catch((error) =&gt; console.error(\"Error:\", error));\n</code></pre>"},{"location":"fundamental/js-async/promise-code/#creating-a-delay-promise","title":"Creating a Delay Promise","text":"<p>Create a reusable delay for sequencing or debouncing.</p> <pre><code>function delay(ms) {\n  return new Promise((resolve) =&gt; setTimeout(resolve, ms));\n}\n\n// Example\nasync function example() {\n  console.log(\"Start\");\n  await delay(1000);\n  console.log(\"After 1 second\");\n}\n\nexample();\n</code></pre>"},{"location":"fundamental/js-async/promise-code/#simple","title":"Simple","text":"<p>However, for simple <code>fetch</code> calls, you can often use <code>fetch</code> directly since it\u2019s already Promise-based:</p> <pre><code>fetch(\"https://jsonplaceholder.typicode.com/posts/1\")\n  .then((response) =&gt; {\n    if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);\n    return response.json();\n  })\n  .then((data) =&gt; console.log(\"API Response:\", data))\n  .catch((error) =&gt; console.error(\"Error:\", error));\n</code></pre>"},{"location":"fundamental/js-async/promise-code/#why-use-the-promise-constructor-for-api-calls","title":"Why Use the Promise Constructor for API Calls?","text":"<p>While <code>fetch</code> already returns a Promise, wrapping it in a <code>Promise</code> constructor can be useful in specific scenarios:</p> <ul> <li>Custom Logic: You want to add custom logic before resolving/rejecting (e.g., transforming data, checking conditions).</li> <li>Legacy APIs: You\u2019re working with a callback-based API (not Promise-based) and need to convert it to a Promise.</li> <li>Combining Operations: You need to combine multiple async operations into a single Promise.</li> <li>Error Normalization: You want to standardize error handling across different APIs.</li> </ul>"},{"location":"fundamental/js-async/promise-code/#when-to-use-many-then-calls","title":"When to Use Many <code>.then()</code> Calls","text":"<p>Chaining multiple <code>.then()</code> calls is particularly useful when:</p> <ul> <li>You\u2019re transforming data step-by-step in a pipeline.</li> <li>Each step depends on the result of the previous one.</li> <li>You want to keep the code functional and avoid mutable state.</li> </ul> <pre><code>fetch(\"https://api.example.com/data\")\n  .then((res) =&gt; res.json())\n  .then((data) =&gt; data.filter((item) =&gt; item.active))\n  .then((filtered) =&gt; filtered.map((item) =&gt; item.name))\n  .then((names) =&gt; names.join(\", \"))\n  .then((result) =&gt; console.log(result));\n</code></pre>"},{"location":"fundamental/js-async/promise/","title":"Promise","text":""},{"location":"fundamental/js-async/promise/#promise","title":"Promise","text":"<p>In JavaScript, Promises are objects that link the producing and the consuming code together. While in simple terms a Promise in JavaScript means the same as a promise in real life.</p> <p>Whenever a Promise is created there are 3 conditions or would rather say results that we can expect:</p> <ul> <li>resolve</li> <li>reject</li> <li>pending</li> </ul> <p>Definition from geeksforgeeks</p> <p> </p> Promise <p>When you run <code>console.log(fetch instanceof Promise);</code> and get <code>false</code>, it's because <code>fetch</code> is a function, not a Promise object.</p> <ul> <li><code>fetch</code> is a built-in JavaScript function that returns a Promise when you call it, but the function itself is not an instance of <code>Promise</code>.</li> <li> <p>If you want to check if the result of calling <code>fetch()</code> is a Promise, you should do:</p> <pre><code>console.log(fetch('https://example.com') instanceof Promise); // true\n</code></pre> </li> <li> <p>If you check <code>fetch instanceof Promise</code>, you're asking if the function object <code>fetch</code> was created by the Promise constructor, which is not the case.</p> </li> <li> <p>The correct way to check if something is a Promise is either using <code>instanceof Promise</code> on the result of <code>fetch()</code>, or by checking if it has a <code>.then</code> method.</p> </li> </ul> <p>Summary:</p> <ul> <li><code>fetch</code> is a function, not a Promise.</li> <li><code>fetch()</code> (when called) returns a Promise.</li> </ul> <p>So, <code>console.log(fetch instanceof Promise);</code> is <code>false</code> because <code>fetch</code> is a function, not a Promise object.</p> <ul> <li>How to check if an object is a Promise?</li> <li> <p>[JavaScript] Can someone explain how this code with fetch and promises works???</p> </li> <li> <p>How JavaScript Promises Work \u2013 Tutorial for Beginners</p> </li> </ul>"},{"location":"fundamental/js-async/promise/#promise-thenables","title":"Promise &amp; Thenables","text":"<p>A Promise in JavaScript is an object that represents the eventual completion (success) or failure of an asynchronous operation and its resulting value. When you perform something that takes time (like fetching data from a server), a Promise acts as a placeholder for the future result. It can be in one of three states:</p> <ul> <li>Pending: The operation is still in progress.</li> <li>Fulfilled: The operation completed successfully, and the Promise has a result.</li> <li>Rejected: The operation failed, and the Promise has an error</li> </ul> <p>You interact with Promises using <code>.then()</code> for success and <code>.catch()</code> for errors.</p> <p>Thenables are any objects that have a <code>.then()</code> method. All Promises are thenables, but not all thenables are Promises. For example, you can create a plain object with a <code>.then()</code> method, and JavaScript will treat it like a Promise in many situations. This means:</p> <ul> <li>Promise: A specific, standardized object with special behavior for handling asynchronous results.</li> <li>Thenable: Any object with a <code>.then()</code> method, which can be \"promise-like\" but may not have all the features or guarantees of a real Promise.</li> </ul> <p>Summary:</p> <ul> <li>All Promises are thenables.</li> <li>Not all thenables are real Promises.</li> <li>Promises follow a standard and have built-in behaviors; thenables just need a <code>.then()</code> method.</li> </ul> <pre><code>// A real Promise\nlet promise = new Promise((resolve, reject) =&gt; {\n  resolve(\"done!\");\n});\n\n// A thenable (not a real Promise)\nlet thenable = {\n  then: function (resolve, reject) {\n    resolve(\"done!\");\n  },\n};\n</code></pre> <p>If you pass either to <code>Promise.resolve()</code>, JavaScript will treat both as if they are Promises, but only the first is a true Promise.</p> <p>Key Usage Differences</p> Aspect Promise Thenable Standardized Yes (Promises/A+ spec) No (just needs a <code>.then()</code> method) Reliability Always predictable (chaining, error handling, etc.) May not behave exactly like a real Promise Async/Await Fully supported Supported if the thenable implements <code>.then()</code> Interoperability Always works with <code>Promise.resolve()</code> and chains Works, but may have quirks in edge cases Library Support Used by modern APIs (e.g., Fetch, Axios) Used by some libraries for compatibility <p>Reference</p> <ul> <li>Definiation</li> <li>What\u2019s the difference between a Thenable and a Promise?</li> <li>Regarding Promises/A+ Specification, what is the difference between the terms \"thenable\" and \"promise\"?</li> <li>Thenables in JavaScript</li> </ul>"},{"location":"fundamental/js-async/promise/#difference-between-fetch-and-promise","title":"Difference Between <code>fetch</code> and <code>Promise</code>","text":""},{"location":"fundamental/js-async/promise/#fetch","title":"fetch","text":"<ul> <li> <p><code>fetch</code> is a built-in JavaScript function used to make HTTP requests (like GET, POST) to servers.</p> </li> <li> <p>When you call <code>fetch()</code>, it immediately returns a Promise that will eventually resolve to a Response object representing the result of the HTTP request.</p> </li> <li> <p><code>fetch</code> is specifically designed for network operations and is part of the Fetch API, which replaces older methods like XMLHttpRequest.</p> </li> <li> <p>Example usage:</p> <pre><code>fetch(\"https://api.example.com/data\")\n  .then((response) =&gt; response.json())\n  .then((data) =&gt; console.log(data));\n</code></pre> </li> </ul>"},{"location":"fundamental/js-async/promise/#promise_1","title":"Promise","text":"<ul> <li> <p>A <code>Promise</code> is a general-purpose JavaScript object for handling asynchronous operations.</p> </li> <li> <p>It represents a value that may be available now, in the future, or never, and provides methods (<code>then</code>, <code>catch</code>) to handle the eventual result or error.</p> </li> <li> <p>Promises are not tied to networking; they can be used for any asynchronous task, such as timers, file reading, or custom async logic.</p> </li> <li> <p>Example usage:</p> <pre><code>const myPromise = new Promise((resolve, reject) =&gt; {\n  // async operation\n  if (success) resolve(result);\n  else reject(error);\n});\n\nmyPromise.then((result) =&gt; console.log(result));\n</code></pre> </li> </ul>"},{"location":"fundamental/js-async/promise/#comparison-table","title":"Comparison Table","text":"Feature <code>fetch</code> <code>Promise</code> What it is Function for network requests Object for managing async operations Returns A Promise (when called) N/A (it is the object itself) Purpose HTTP/REST API calls Handle any asynchronous process Usage example <code>fetch(url).then(...)</code> <code>new Promise(...).then(...)</code> Part of Fetch API (Web standard) ES6 (ECMAScript 2015) standard"},{"location":"fundamental/js-async/promise/#in-summary","title":"In summary:","text":"<ul> <li><code>fetch</code> is a function that returns a Promise when making network requests.</li> <li><code>Promise</code> is the underlying mechanism that allows you to handle the asynchronous result of <code>fetch</code> and many other operations.</li> </ul> <p>Reference</p> <ul> <li>Fetch API &amp; Promise</li> <li>Promises and the Fetch API</li> <li>27.2. Asynchronous and Promises</li> </ul> <p>Youtube Tricks</p> <p>Github Codespace crash course</p>"},{"location":"fundamental/js-async/promise/#vip-watch-this","title":"VIP WATCH THIS","text":""},{"location":"fundamental/js-async/promise/#question","title":"Question","text":""},{"location":"fundamental/js-async/promise/#to-determine-if-a-function-in-javascript-returns-a-promise-you-can-use-these-practical-approaches","title":"To determine if a function in JavaScript returns a Promise, you can use these practical approaches","text":"To determine if a function in JavaScript returns a Promise, you can use these practical approaches <ol> <li> <p>Check the Documentation or Source</p> <ul> <li>The most reliable way is to consult the official documentation or the source code. For example, libraries like Axios, Fetch API, and many modern async utilities explicitly state that their functions return Promises.</li> </ul> </li> <li> <p>Look for the <code>Promise</code> Constructor</p> <ul> <li> <p>If a function is written like this:</p> <pre><code>function myAsyncFunc() {\n    return new Promise((resolve, reject) =&gt; {\n        // async code\n    });\n}\n</code></pre> <p>It returns a Promise.</p> </li> </ul> </li> <li> <p>Check for <code>async</code> Keyword</p> <ul> <li> <p>Functions declared with async always return a Promise, regardless of what you return inside:</p> <pre><code>async function foo() {\n    return 42;\n}\n// foo() returns Promise&lt;number&gt;\n</code></pre> </li> </ul> </li> <li> <p>Test with <code>.then()</code></p> <ul> <li> <p>If you call the function and can chain <code>.then()</code> on its result, it returns a Promise:</p> <pre><code>let result = myFunc();\nif (result &amp;&amp; typeof result.then === \"function\") {\n    // result is a Promise or thenable\n}\n</code></pre> </li> </ul> </li> <li> <p>Check for \"thenable\"</p> <ul> <li>Some objects are \"thenable\" (have a <code>.then()</code> method) but aren't native Promises. Calling .then() is a quick test, but only native Promises have the full API.</li> </ul> </li> <li> <p>Common Examples</p> <ul> <li> <p>Returns a Promise:</p> <ul> <li><code>fetch()</code>, <code>axios.get()</code>, <code>async function</code>, <code>Promise.resolve()</code></li> </ul> </li> <li> <p>Does NOT return a Promise:</p> <ul> <li>Most synchronous functions, <code>Array.map()</code>, <code>console.log()</code>, etc.</li> </ul> </li> </ul> </li> </ol> <p>Summary Table</p> Function Type Returns Promise? How to Tell <code>async function</code> Yes Uses <code>async</code> keyword Uses <code>new Promise(...)</code> Yes Returns <code>new Promise</code> Library docs say \"returns Promise\" Yes Check documentation Supports <code>.then()</code> chaining Yes Test with <code>.then()</code> Synchronous function No Returns value directly <p>In short:</p> <p>If a function is declared with <code>async</code>, returns <code>new Promise</code>, or documentation says it returns a Promise, it does. You can also test by chaining <code>.then()</code> \u2014 if that works, it's a Promise.</p>"},{"location":"fundamental/js-async/promise/#to-determine-if-something-is-a-promise-in-javascript-you-can-use-these-practical-methods","title":"To determine if something is a Promise in JavaScript, you can use these practical methods","text":"To determine if something is a Promise in JavaScript, you can use these practical methods: <ol> <li> <p>Using <code>instanceof</code> Operator</p> <p>Check if a value is an instance of the Promise constructor:</p> <pre><code>function isPromise(value) {\n    return value instanceof Promise;\n}\n</code></pre> <p>This returns <code>true</code> if the value is a Promise, and <code>false</code> otherwise.</p> </li> <li> <p>Checking for a <code>.then</code> Method</p> <p>Promises have a <code>.then</code> method. You can check if the value is an object (or function) and has a <code>.then</code> method:</p> <pre><code>function isPromise(p) {\n    return !!p &amp;&amp; (typeof p === 'object' || typeof p === 'function') &amp;&amp; typeof p.then === 'function';\n}\n</code></pre> <p>This also works for \"thenables\" (objects that act like Promises).</p> </li> <li> <p>Behavioral Check</p> <p>Try chaining <code>.then()</code> on the function's return value. If it works, it\u2019s a Promise or thenable:</p> <pre><code>const result = someFunction();\nif (result &amp;&amp; typeof result.then === 'function') {\n    // result is a Promise or thenable\n}\n</code></pre> <p>If <code>.then()</code> is not a function, it's not a Promise.</p> </li> <li> <p>Check Documentation or Source</p> <p>Official documentation or source code will state if a function returns a Promise.</p> </li> </ol> <p>Summary:</p> <ul> <li>Use <code>instanceof</code> Promise for native Promises.</li> <li>Check for a <code>.then</code> method for Promises and thenables.</li> <li>Consult docs for library or built-in functions.</li> </ul> <p>These methods help you reliably distinguish between Promises and non-Promises in JavaScript.</p>"},{"location":"fundamental/js-async/promise/#you-can-identify-a-promise-in-javascript-using-several-reliable-methods","title":"You can identify a Promise in JavaScript using several reliable methods:","text":"You can identify a Promise in JavaScript using several reliable methods: <ol> <li> <p>Check for <code>.then</code> Method (\"Thenable\" Check)</p> <p>The most common and broadly compatible way is to check if the object has a <code>.then</code> method that is a function:</p> <pre><code>function isPromise(value) {\n    return !!value &amp;&amp; typeof value.then === \"function\";\n}\n</code></pre> <p>If this returns <code>true</code>, the value is either a Promise or a \"thenable\" (an object that behaves like a Promise).</p> </li> <li> <p>Using <code>instanceof</code> Promise</p> <p>You can check if the value is an instance of the native Promise constructor:</p> <pre><code>function isPromise(value) {\n    return value instanceof Promise;\n}\n</code></pre> <p>This is reliable for native Promises, but may not work across different JavaScript contexts (like iframes) or for custom thenables.</p> </li> <li> <p>Using <code>Promise.resolve()</code> Identity</p> <p>If <code>Promise.resolve(value) === value</code>, then <code>value</code> is a Promise:</p> <pre><code>function isPromise(value) {\n    return Promise.resolve(value) === value;\n}\n</code></pre> <p>This works because <code>Promise.resolve()</code> returns the same object if the input is already a Promise.</p> </li> <li> <p>Documentation and Source Code</p> <p>For built-in functions and libraries, check the documentation to see if a function returns a Promise.</p> </li> </ol> <p>Summary Table</p> Method Works for Native Promise Works for Thenables Notes <code>.then</code> method check Yes Yes Most widely used <code>instanceof Promise</code> Yes No Only for native Promises <code>Promise.resolve(value)===value</code> Yes Yes Reliable for both <p>In practice:</p> <ul> <li>Use the <code>.then</code> method check for the broadest compatibility.</li> <li>Use <code>instanceof Promise</code> if you only care about native Promises.</li> <li>For maximum reliability, combine both if needed.</li> </ul> <p>These methods will help you confidently identify Promises in JavaScript.</p>"},{"location":"fundamental/js-async/promise/#reference","title":"Reference","text":"<ul> <li>async function - MDN</li> <li>Promise - MDN</li> <li>Promise.resolve() - MDN</li> <li>then() - MDN</li> <li>JavaScript Promises - JavaScript.info</li> <li>Axios Documentation</li> <li>React Router Documentation</li> <li> <p>TanStack Router Documentation</p> </li> <li> <p>JavaScript Program that returns true if an object looks like a Promise</p> </li> <li>All You Need to Know About JavaScript Promises</li> </ul>"},{"location":"js/intro/","title":"Intro","text":"<p>What\u2019s in a name?</p> <p>The name JavaScript was chosen to take advantage of the popularity of Java \u2013 just as a marketing ploy! Its first name was Mocha, then, LiveScript, and only then JavaScript.</p>"},{"location":"js/intro/#fp-and-other-programming-paradigms","title":"FP and other programming paradigms","text":"<p>Programming paradigms classify programming languages according to their features.</p> <p>However, some languages may be classified into multiple paradigms \u2013 as is the case of JavaScript itself!</p> <p>A primary division is imperative versus declarative languages. In the former, developers must instruct the machine on how to do its work, step by step.</p> <p>Programming may be procedural (if instructions are grouped into procedures) or object-oriented (if instructions are grouped with a related state).</p> <p>In declarative languages, in opposition, developers just declare properties that the sought result must satisfy, but not how to calculate it. Declarative languages may be logic-based (based on logic rules and constraints), reactive (based on data and event streams), or functional (based on the application and combination of functions).</p> <p>In a sense, we could say that imperative languages focus on how, while declarative languages focus on what.</p> <p>JavaScript is multi-paradigm: it\u2019s imperative (both procedural and object-oriented) but also allows declarative programming, both functional (like almost everything in this book! In particular, we will devote Chapter 5, Programming Declaratively, to this topic) and reactive (we\u2019ll see reactive FP in Chapter 11, Implementing Design Patterns).</p> <p></p>"},{"location":"js/intro/#reference","title":"Reference","text":"<ul> <li>Mastering JavaScript Functional Programming Third Edition by Federico Kereki</li> </ul>"},{"location":"js/advanced/maps-and-sets/","title":"Maps and Sets","text":""},{"location":"js/advanced/maps-and-sets/#maps-and-sets-the-new-data-structures-on-the-block","title":"Maps and Sets <code>\u2014 The New Data-structures on the Block</code>","text":""},{"location":"js/advanced/maps-and-sets/#reference","title":"Reference","text":"<ul> <li>JavaScript Next by Raju Gandhi, pg: 81</li> </ul>"},{"location":"js/advanced/promise/","title":"Promise","text":"<p>What is a Promise in JavaScript?</p> <p>A promise is a native JavaScript object that represents the eventual completion (or failure) of an asynchronous operation and its resulting value. Promises provide a way to handle asynchronous operations in a more manageable and cleaner manner compared to traditional callback-based approaches.</p>"},{"location":"js/advanced/promise/#history","title":"History","text":"<p>Promises were introduced to JavaScript as part of ECMAScript 2015 (ES6) to improve the way asynchronous operations are handled. They provide a more manageable way to deal with asynchronous code compared to traditional callback approaches, helping to avoid issues like callback hell.</p> <p>When Promises Were Introduced</p> <p>Promises were standardized in ECMAScript 2015 (ES6), which was officially released in June 2015. Before ES6, handling asynchronous operations was done using <code>callbacks</code>, which could lead to deeply nested and difficult-to-read code.</p>"},{"location":"js/advanced/promise/#key-concepts-of-promises","title":"Key Concepts of Promises","text":"States <ul> <li>Pending: The initial state, before the promise has been fulfilled or rejected.</li> <li>Fulfilled: The operation completed successfully, resulting in a value.</li> <li>Rejected: The operation failed, resulting in a reason (error).</li> </ul>"},{"location":"js/advanced/promise/#usage","title":"Usage","text":"<p>Do We Need to Use Promises Only for Asynchronous Data?</p> <p>While promises are commonly used for asynchronous operations, they can be used for any situation where you need to handle operations that may complete in the future, not just for asynchronous data fetching. However, their primary use case is for handling asynchronous operations like:</p> <ul> <li>Fetching data from a server</li> <li>Reading files (in Node.js)</li> <li>Timers and delays</li> </ul>"},{"location":"js/advanced/serialization/","title":"Serialization","text":""},{"location":"js/advanced/serialization/#serialization","title":"Serialization","text":""},{"location":"js/advanced/serialization/#question","title":"Question","text":"<p>why do we need to serailize to tranfer in http protocal? why does we can't transfers the direct object. what is the reason?\"</p> <p>Serialization is necessary to transfer objects over the HTTP protocol because HTTP is a text-based protocol that only understands text or binary data formats. Directly transferring an object as it exists in memory is not feasible due to several reasons:</p> Reasons for Serialization <ol> <li> <p>Incompatibility with HTTP Protocol: HTTP is designed to transfer data in text (ASCII or UTF-8) or binary format, not in the complex memory structures that objects are represented as within a running program.</p> </li> <li> <p>Language and Platform Independence: Serialization transforms objects into a standardized format that can be understood across different programming languages and platforms. Without serialization, the internal memory representation of an object in one language (e.g., Python) might not be understandable by another language (e.g., JavaScript).</p> </li> <li> <p>Security: Directly transferring raw memory data could expose sensitive information and increase the risk of security vulnerabilities. Serialization allows control over what data is included and how it is represented, enhancing security.</p> </li> <li> <p>Data Integrity and Structure: Serialization ensures that the data structure is preserved and can be accurately reconstructed. It converts complex objects into a structured format (like JSON or XML) that maintains the relationships between data fields.</p> </li> <li> <p>Efficiency and Performance: Serialized data can be optimized for transmission. Formats like JSON and Protocol Buffers are designed to be lightweight and efficient, reducing the amount of data transferred and improving performance.</p> </li> </ol> Why Direct Transfer of Objects is Not Feasible <ol> <li> <p>Memory Representation: Objects in memory contain pointers, memory addresses, and other metadata that are specific to the runtime environment. This low-level information is not meaningful outside the context of that environment.</p> </li> <li> <p>Endianness and Architecture Differences: Computers may have different endianness (byte order) and architecture (<code>32-bit</code> vs. <code>64-bit</code>), leading to differences in how data is stored in memory. Serialization abstracts these differences.</p> </li> <li> <p>Complex Object Graphs: Objects often reference other objects, creating complex graphs of interconnected data. Direct transfer would require duplicating the entire memory structure, which is impractical and error-prone.</p> </li> </ol> <p>Example</p>"},{"location":"js/advanced/serialization/#serialization-process","title":"Serialization Process","text":"<ol> <li> <p>Conversion to Text or Binary Format: The object is converted into a format like <code>JSON</code>, <code>XML</code>, or <code>Protocol Buffers</code>. This format represents the object's data in a standardized way.</p> </li> <li> <p>Transmission Over HTTP: The serialized data is included in the HTTP request or response body, allowing it to be transmitted over the network.</p> </li> <li> <p>Deserialization: On the receiving end, the data is converted back into an object, reconstructing the original data structure.</p> </li> </ol>"},{"location":"js/advanced/serialization/#example-of-serialization-and-transmission","title":"Example of Serialization and Transmission","text":""},{"location":"js/advanced/serialization/#json-serialization","title":"JSON Serialization","text":"Original Object (Python):<pre><code>user = {\"name\": \"Alice\", \"age\": 30, \"isMember\": True}\n</code></pre>"},{"location":"js/advanced/serialization/#serialized-json","title":"Serialized JSON:","text":"json<pre><code>{\n    \"name\": \"Alice\",\n    \"age\": 30,\n    \"isMember\": true\n}\n</code></pre>"},{"location":"js/advanced/serialization/#http-request","title":"HTTP Request:","text":"http<pre><code>POST /api/users HTTP/1.1\nHost: example.com\nContent-Type: application/json\n\n{\n    \"name\": \"Alice\",\n    \"age\": 30,\n    \"isMember\": true\n}\n</code></pre>"},{"location":"js/advanced/serialization/#deserialization-javascript","title":"Deserialization (JavaScript):","text":"javascript<pre><code>let user = JSON.parse('{\"name\": \"Alice\", \"age\": 30, \"isMember\": true}');\n</code></pre>"},{"location":"js/advanced/serialization/#conclusion","title":"Conclusion","text":"<p>Serialization is essential for transferring objects over the HTTP protocol because it converts objects into a text or binary format that is compatible with HTTP, ensures language and platform independence, and maintains data integrity and security. Direct transfer of objects is not feasible due to the complexity of memory representations and the need for standardized data formats.</p>"},{"location":"js/advanced/this-in-js/","title":"this","text":"<p>Understanding <code>this</code> in JavaScript: Context and Behavior Explained</p> <p>Understanding the <code>this</code> context in JavaScript can be a bit tricky, especially because it behaves differently in various situations.</p> <p>Let\u2019s break it down in simple terms.</p>"},{"location":"js/advanced/this-in-js/#what-is-this","title":"What is this?","text":"<p>In JavaScript, <code>this</code> refers to the object that is currently executing the code. It is a special keyword that changes depending on how a function is called.</p>"},{"location":"js/advanced/this-in-js/#how-this-works","title":"How this Works","text":"<p>The value of <code>this</code> depends on the context in which a function is invoked. Here\u2019s a basic guide to help understand it:</p> <ol> <li> <p>Global Context:</p> <ul> <li> <p>When <code>this</code> is used in the global scope (outside of any function), it refers to the global object. In a browser, this global object is window.</p> </li> <li> <p>In a browser, this global object is <code>window</code>.</p> </li> </ul> <pre><code>console.log(this); // In a browser, this logs the `window` object\n</code></pre> </li> <li> <p>Object Method:</p> <ul> <li>When <code>this</code> is used inside a method of an object, it refers to the object that the method is called on.</li> </ul> <pre><code>const obj = {\n    name: 'Alice',\n    greet: function() {\n        // `this` refers to `obj`, so it logs 'Alice'\n        console.log(this.name);\n    }\n};\n\nobj.greet();\n</code></pre> </li> <li> <p>Constructor Function:</p> <ul> <li>When <code>this</code> is used inside a constructor function (a function meant to create objects), it refers to the newly created object.</li> </ul> <pre><code>function Person(name) {\n    this.name = name;\n}\n\nconst alice = new Person('Alice');\nconsole.log(alice.name); // Logs 'Alice'\n</code></pre> </li> <li> <p>Event Handlers:</p> <ul> <li>In event handlers, <code>this</code> refers to the element that the event handler is attached to.</li> </ul> <pre><code>document.querySelector('button').addEventListener('click', function() {\n    console.log(this); // Logs the button element\n});\n</code></pre> </li> <li> <p>Arrow Functions:</p> <ul> <li>Arrow functions do not have their own <code>this</code>. Instead, they inherit <code>this</code> from the surrounding (lexical) context where they were defined. This is known as lexical scoping.</li> </ul> <pre><code>const obj = {\n    name: 'Alice',\n    greet: function() {\n        const innerFunction = () =&gt; {\n            // `this` refers to `obj`, because arrow function inherits `this` from `greet`\n            console.log(this.name);\n        };\n        innerFunction();\n    }\n};\n\nobj.greet(); // Logs 'Alice'\n</code></pre> </li> </ol>"},{"location":"js/advanced/this-in-js/#why-this-isnt-the-same-for-all","title":"Why <code>this</code> Isn\u2019t the Same for All","text":"<p>The behavior of <code>this</code> is designed to be flexible to accommodate different use cases in JavaScript. However, this flexibility can lead to confusion:</p> <ul> <li> <p>Dynamic Binding: <code>this</code> is dynamically bound based on how a function is called. This allows functions to operate on different objects depending on the context, but can make it hard to predict what <code>this</code> refers to without understanding the call site.</p> </li> <li> <p>Arrow Functions: Arrow functions were introduced to simplify the handling of <code>this</code> by lexically binding <code>this</code>, meaning they use the <code>this</code> value from where they were created, rather than where they are executed.</p> </li> </ul>"},{"location":"js/advanced/this-in-js/#summary","title":"Summary","text":"<ul> <li>Global Context: <code>this</code> refers to the global object (e.g., window in browsers).</li> <li>Object Method: <code>this</code> refers to the object the method is called on.</li> <li>Constructor Function: <code>this</code> refers to the newly created instance.</li> <li>Event Handlers: <code>this</code> refers to the element that triggered the event.</li> <li>Arrow Functions: <code>this</code> is inherited from the surrounding context, not dynamically bound.</li> </ul> <p>Understanding <code>this</code> involves recognizing how functions are called and how <code>this</code> is set based on these contexts. It\u2019s a core part of JavaScript\u2019s flexible function behavior but requires careful consideration to use effectively.</p>"},{"location":"js/advanced/reducer/intro/","title":"Intro","text":""},{"location":"js/advanced/reducer/intro/#overview","title":"Overview","text":"<p>In JavaScript, the concept of a reducer often comes into play when working with state management, particularly in functional programming and libraries like <code>Redux</code> or when using the <code>Array.prototype.reduce()</code> method.</p>"},{"location":"js/advanced/reducer/intro/#1-what-is-a-reducer","title":"1. What is a Reducer?","text":"<p>A reducer is a function that takes in two arguments: the current state and an action (or data), and then returns a new state based on that input. The key here is that a reducer function is pure, meaning it doesn\u2019t modify the original state but instead returns a new state.</p> <p>In the context of <code>React</code>, <code>Redux</code>, or other state management systems, a reducer is used to handle state updates based on different actions or events.</p>"},{"location":"js/advanced/reducer/intro/#2-when-to-use-a-reducer","title":"2. When to Use a Reducer?","text":"<p>You use a reducer when you need to handle changes to a state over time, especially when the state is complex or when there are different types of actions that need to modify the state in different ways.</p> <p>For example:</p> <ul> <li>When you're building a state management system (like Redux in React).</li> <li>When you need to perform updates on an array or object based on different operations (adding, removing, modifying items).</li> <li>When your state needs to be modified based on multiple conditions or events.</li> </ul>"},{"location":"js/advanced/reducer/intro/#3-how-to-use-a-reducer-in-javascript","title":"3. How to Use a Reducer in JavaScript?","text":""},{"location":"js/advanced/reducer/intro/#using-arrayprototypereduce","title":"Using <code>Array.prototype.reduce()</code>","text":"<p>In JavaScript, the <code>reduce()</code> method allows you to accumulate a value (like a sum, or a transformed array) by iterating over an array and applying a reducer function.</p> Syntax<pre><code>array.reduce((accumulator, currentValue) =&gt; {\n  // your logic here\n  return newAccumulator;\n}, initialValue);\n</code></pre> <ul> <li>accumulator: The value that accumulates the result (e.g., sum, object, etc.).</li> <li>currentValue: The current item in the array being processed.</li> <li>initialValue: An optional initial value for the accumulator.</li> </ul> Example<pre><code>// Summing numbers in an array\nconst numbers = [1, 2, 3, 4, 5];\n\nconst sum = numbers.reduce((acc, curr) =&gt; acc + curr, 0);\n\nconsole.log(sum); // Output: 15\n</code></pre>"},{"location":"js/advanced/reducer/intro/#using-reducers-in-react-or-redux","title":"Using Reducers in React (or Redux)","text":"<p>In React (with Redux, for example), a reducer function is typically used to manage the application state by responding to different action types. The reducer returns a new state object based on the action type.</p> ExampleExplanation <pre><code>// Initial state\nconst initialState = {\n    count: 0,\n    user: null,\n};\n\n// Reducer function\nfunction reducer(state = initialState, action) {\n    switch (action.type) {\n        case \"INCREMENT\":\n            return { ...state, count: state.count + 1 };\n        case \"DECREMENT\":\n            return { ...state, count: state.count - 1 };\n        case \"SET_USER\":\n            return { ...state, user: action.payload };\n        default:\n            return state;\n    }\n}\n</code></pre> <ul> <li>The reducer function handles three different types of actions: increment, decrement, and set user.</li> <li>The state is immutable: a new state is returned on each action.</li> </ul> Example in a Redux Store<pre><code>import { createStore } from \"redux\";\n\n// The same reducer from above\nconst store = createStore(reducer);\n\n// Dispatching actions\nstore.dispatch({ type: \"INCREMENT\" });\nconsole.log(store.getState()); // { count: 1, user: null }\n\nstore.dispatch({ type: \"SET_USER\", payload: { name: \"John Doe\" } });\nconsole.log(store.getState()); // { count: 1, user: { name: 'John Doe' } }\n</code></pre>"},{"location":"js/advanced/reducer/intro/#4-why-do-we-need-a-reducer","title":"4. Why Do We Need a Reducer?","text":"<p>Reducers help you manage and update application state in a predictable and maintainable way. Here\u2019s why they are useful:</p> <ul> <li>Predictability: Reducers ensure that state transitions happen in a consistent and predictable manner, which is especially important when your app grows in complexity.</li> <li>Immutability: By always returning a new state rather than mutating the old state, reducers help maintain immutability, which reduces bugs and makes your code easier to reason about.</li> <li>Separation of concerns: Reducers allow you to isolate how state is updated based on specific actions, making your application logic more modular and easier to test.</li> <li>Composability: Reducers can be combined (using functions like <code>combineReducers</code> in Redux), allowing you to manage complex states in a modular way.</li> </ul>"},{"location":"js/advanced/reducer/intro/#5-summary","title":"5. Summary:","text":"<ul> <li>Reducer is a function that takes in state and an action, and returns a new state.</li> <li>Use a reducer when you need to manage complex or mutable state, especially with actions that modify the state in different ways.</li> <li>In JavaScript, reducers are often used with <code>reduce()</code> for arrays or in state management libraries (like Redux in React).</li> <li>Why use it? Reducers provide predictable state transitions, maintain immutability, allow modular code, and ensure that application state updates are traceable and easy to manage.</li> </ul>"},{"location":"js/advanced/reducer/intro/#additional","title":"Additional","text":"<p>In JavaScript and React, the concept of a \"reducer\" primarily comes from Redux, a popular state management library. It is a key part of managing and updating application state in a predictable way.</p>"},{"location":"js/advanced/reducer/intro/#reducer-in-javascript","title":"Reducer in JavaScript","text":"<p>A reducer is a function that takes the current state of an application and an action, and returns a new state based on that action. It follows a predictable pattern for managing state updates.</p> Syntax of a Reducer<pre><code>function reducer(state, action) {\n  switch (action.type) {\n    case \"ACTION_TYPE_1\":\n      return { ...state, someProperty: action.payload };\n    case \"ACTION_TYPE_2\":\n      return { ...state, anotherProperty: action.payload };\n    default:\n      return state;\n  }\n}\n</code></pre> <ul> <li>state: The current state of the application or the specific part of the state that this reducer manages.</li> <li>action: An object describing the change, typically containing a <code>type</code> field (to describe the action) and optionally a <code>payload</code> field (to pass additional data).</li> </ul> <p>In the context of React and Redux, this function does not mutate the original state directly; instead, it returns a new state.</p>"},{"location":"js/advanced/reducer/intro/#reducer-pattern-in-react-and-redux","title":"Reducer Pattern in React and Redux","text":"<p>The Reducer pattern in Redux (and by extension, React) is a way to manage state using pure functions. The pattern is inspired by the reduce function in functional programming, which applies a series of transformations to an initial value.</p> <ul> <li>State is treated as an immutable object, and actions trigger changes to the state.</li> <li>The reducer pattern helps in keeping state transitions predictable and traceable.</li> </ul> Example in Redux <p>Here is a simple Redux-like example to illustrate the reducer pattern:</p> <pre><code>// Initial state\nconst initialState = {\n    count: 0,\n};\n\n// Reducer function\nfunction counterReducer(state = initialState, action) {\n    switch (action.type) {\n        case \"INCREMENT\":\n            return { ...state, count: state.count + 1 };\n        case \"DECREMENT\":\n            return { ...state, count: state.count - 1 };\n        default:\n            return state;\n    }\n}\n\n// Example actions\nconst incrementAction = { type: \"INCREMENT\" };\nconst decrementAction = { type: \"DECREMENT\" };\n\n// Using the reducer to update state\nlet state = counterReducer(undefined, incrementAction); // { count: 1 }\nstate = counterReducer(state, decrementAction); // { count: 0 }\n</code></pre>"},{"location":"js/advanced/reducer/intro/#how-it-works-in-react-with-usereducer","title":"How it works in React with <code>useReducer</code>","text":"<p>In React, you can use the <code>useReducer</code> hook, which is a way to manage local component state in a manner similar to how Redux works. <code>useReducer</code> is typically used when state logic is complex (e.g., involves multiple sub-values or conditions).</p> ExampleExplanation <pre><code>import React, { useReducer } from \"react\";\n\n// Initial state\nconst initialState = { count: 0 };\n\n// Reducer function\nfunction counterReducer(state, action) {\n    switch (action.type) {\n        case \"INCREMENT\":\n            return { ...state, count: state.count + 1 };\n        case \"DECREMENT\":\n            return { ...state, count: state.count - 1 };\n        default:\n            return state;\n    }\n}\n\nfunction Counter() {\n    const [state, dispatch] = useReducer(counterReducer, initialState);\n\n    return (\n        &lt;div&gt;\n            &lt;p&gt;Count: {state.count}&lt;/p&gt;\n            &lt;button onClick={() =&gt; dispatch({ type: \"INCREMENT\" })}&gt;Increment&lt;/button&gt;\n            &lt;button onClick={() =&gt; dispatch({ type: \"DECREMENT\" })}&gt;Decrement&lt;/button&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default Counter;\n</code></pre> <p><code>useReducer</code> returns two values:</p> <ul> <li><code>state</code>: The current state.</li> <li><code>dispatch</code>: A function that allows you to send actions to the reducer.</li> </ul>"},{"location":"js/advanced/reducer/intro/#key-characteristics-of-the-reducer-pattern","title":"Key Characteristics of the Reducer Pattern","text":"<ol> <li> <p>Pure Function: A reducer is a pure function that depends solely on its inputs (current state and action). It does not have side effects, and it returns a new state without modifying the existing one.</p> </li> <li> <p>Immutability: Reducers should not mutate the existing state. Instead, they return a new state object, which is a copy of the old one with the necessary updates.</p> </li> <li> <p>State Transition: The reducer determines how the state changes in response to different actions, keeping the application\u2019s state transition predictable.</p> </li> <li> <p>Centralized State Management: In libraries like Redux, the reducer pattern is used to maintain a centralized state, making it easier to manage, debug, and test application state.</p> </li> </ol>"},{"location":"js/advanced/reducer/intro/#when-to-use-a-reducer","title":"When to Use a Reducer","text":"<ul> <li> <p>Complex State: Use a reducer when your state management logic is too complex for simple <code>useState</code> or <code>setState</code>. For example, when you need to manage multiple variables that depend on each other or when you need to handle different actions for updating state.</p> </li> <li> <p>Predictability and Debugging: Since reducers are pure functions, the state transitions are predictable and easier to debug, especially when combined with tools like Redux DevTools.</p> </li> </ul>"},{"location":"js/advanced/reducer/intro/#conclusion","title":"Conclusion","text":"<p>The reducer pattern is a fundamental concept in JavaScript, particularly in state management with Redux and React's <code>useReducer</code>. It provides a structured and predictable way to manage complex state transitions by using pure functions to handle state changes based on dispatched actions. While Redux popularized the reducer pattern, React's <code>useReducer</code> allows you to use this pattern in local component state as well.</p>"},{"location":"js/advanced/reducer/intro/#reference","title":"Reference","text":"<ul> <li>Reducers in JavaScript</li> </ul>"},{"location":"js/advanced/reducer/syntax/","title":"Syntax","text":""},{"location":"js/advanced/reducer/syntax/#example","title":"Example","text":""},{"location":"js/advanced/reducer/syntax/#additional","title":"Additional","text":""},{"location":"js/advanced/reducer/syntax/#reference","title":"Reference","text":"<ul> <li>Reducers in JavaScript</li> <li>Understanding React Reducer in JavaScript for State Management</li> <li>The State Reducer Pattern with React Hooks</li> <li>JavaScript Reducer (origin React/Redux)</li> <li>Redux Ducks: Restructure your Redux App with Ducks</li> <li>Understanding Reducers in JavaScript</li> </ul>"},{"location":"js/coercion/common-pitfalls/","title":"Common Pitfalls","text":"<p>Common Pitfalls with Falsy Values in JavaScript</p>"},{"location":"js/coercion/common-pitfalls/#common-pitfalls-with-falsy-values-in-javascript","title":"Common Pitfalls with Falsy Values in JavaScript","text":"<p>Implicit type coercion can lead to unintended behavior if you're not aware of how falsy values work. Here are some common pitfalls and how to handle them:</p>"},{"location":"js/coercion/common-pitfalls/#1-mistaking-0-as-falsy-in-conditions","title":"1. Mistaking <code>0</code> as Falsy in Conditions","text":"<p>The number <code>0</code> is a valid value but is considered falsy in conditional statements.</p> Example<pre><code>let count = 0;\n\nif (count) {\n  console.log(\"Count exists\");\n} else {\n  console.log(\"Count is falsy\");\n}\n</code></pre> Output <ul> <li><code>Count is falsy</code></li> <li>This might be unexpected because <code>0</code> often indicates a valid state.</li> </ul> Fix <p>Explicitly check for <code>undefined</code> or <code>null</code> instead:</p> <pre><code>if (count !== undefined &amp;&amp; count !== null) {\n    console.log('Count exists');\n}\n</code></pre>"},{"location":"js/coercion/common-pitfalls/#2-empty-strings-as-falsy","title":"2. Empty Strings as Falsy","text":"<p>An empty string (<code>\"\"</code>) is falsy, which can cause issues when checking user input.</p> Example<pre><code>let username = \"\";\n\nif (username) {\n  console.log(\"Valid username\");\n} else {\n  console.log(\"Username is required\");\n}\n</code></pre> Output <ul> <li><code>Username is required</code></li> <li>Even if the user intends to input an empty string, the logic might fail.</li> </ul> Fix <p>Use explicit checks:</p> <pre><code>if (username.length &gt; 0) {\n    console.log('Valid username');\n}\n</code></pre> Best Approach (for handling empty/required username)<pre><code>let username = \"\";\n\nif (username.trim() === \"\") {\n    console.log(\"Username is required\");\n} else {\n    console.log(\"Valid username\");\n}\n</code></pre>"},{"location":"js/coercion/common-pitfalls/#3-null-or-undefined-in-logical-operators","title":"3. <code>null</code> or <code>undefined</code> in Logical Operators","text":"<p>When using logical operators (<code>||</code> or <code>&amp;&amp;</code>), <code>null</code> or <code>undefined</code> might lead to unexpected results.</p> Example<pre><code>let defaultName = \"Guest\";\nlet userName = null;\n\nconsole.log(userName || defaultName); // \"Guest\"\n</code></pre> Bug <p>This works as expected, but if <code>userName</code> were an empty string (<code>\"\"</code>), it would also default:</p> <pre><code>let userName = \"\";\nconsole.log(userName || defaultName); // \"Guest\"\n</code></pre> Fix <p>Use <code>??</code> (Nullish Coalescing Operator) to handle only <code>null</code> or <code>undefined</code>:</p> <pre><code>console.log(userName ?? defaultName); // \"\"\n</code></pre>"},{"location":"js/coercion/common-pitfalls/#4-nan-as-falsy","title":"4. <code>NaN</code> as Falsy","text":"<p><code>NaN</code> is falsy, but it\u2019s tricky to detect since it\u2019s not equal to itself (<code>NaN !== NaN</code>).</p> Example<pre><code>let value = NaN;\n\nif (value) {\n  console.log(\"Valid number\");\n} else {\n  console.log(\"Invalid number\");\n}\n</code></pre> Output <ul> <li>Invalid number</li> </ul> Fix <p>Use <code>isNaN()</code> or <code>Number.isNaN()</code>:</p> <pre><code>if (!isNaN(value)) {\n    console.log('Valid number');\n} else {\n    console.log('Invalid number');\n}\n</code></pre>"},{"location":"js/coercion/common-pitfalls/#5-objects-and-arrays-as-truthy","title":"5. Objects and Arrays as Truthy","text":"<p>Even empty objects (<code>{}</code>) or arrays (<code>[]</code>) are truthy, which might lead to logical errors.</p> Example<pre><code>let config = {};\n\nif (config) {\n  console.log(\"Config exists\");\n}\n</code></pre> Output <ul> <li><code>Config exists</code></li> <li>This might mislead you into thinking <code>config</code> has meaningful properties.</li> </ul> Fix <p>Check for properties explicitly:</p> <pre><code>if (Object.keys(config).length &gt; 0) {\n    console.log('Config has properties');\n}\n</code></pre>"},{"location":"js/coercion/common-pitfalls/#6-implicit-conversion-in-comparisons","title":"6. Implicit Conversion in Comparisons (<code>==</code>)","text":"<p>Using loose equality (<code>==</code>) can lead to unexpected results due to type coercion.</p> Example<pre><code>console.log(false == 0); // true\nconsole.log(\"\" == 0); // true\nconsole.log(null == undefined); // true\n</code></pre> Fix <p>Always use strict equality (<code>===</code>):</p> <pre><code>console.log(false === 0);  // false\nconsole.log(\"\" === 0);     // false\nconsole.log(null === undefined); // false\n</code></pre>"},{"location":"js/coercion/common-pitfalls/#7-forgetting-about-default-parameters","title":"7. Forgetting About Default Parameters","text":"<p>Falsy values can override default parameters in functions.</p> Output Example<pre><code>function greet(name = \"Guest\") {\nconsole.log(`Hello, ${name}`);\n}\n\ngreet(\"\"); // \"Hello, \" (unexpected)\n</code></pre> Fix <p>Use <code>name ?? \"Guest\"</code> to handle only null or undefined:</p> <pre><code>function greet(name) {\n    console.log(`Hello, ${name ?? \"Guest\"}`);\n}\n</code></pre>"},{"location":"js/coercion/common-pitfalls/#8-arrays-with-falsy-elements","title":"8. Arrays with Falsy Elements","text":"<p>When using array methods like <code>filter</code>, falsy elements might unintentionally get removed.</p> Output Example<pre><code>let data = [0, 1, 2, \"\", false, null];\nlet filteredData = data.filter(Boolean);\n\nconsole.log(filteredData); // [1, 2]\n</code></pre> Fix <p>Be explicit about what you want to <code>filter</code>.</p> <pre><code>let filteredData = data.filter(item =&gt; item !== null &amp;&amp; item !== false);\n</code></pre>"},{"location":"js/coercion/common-pitfalls/#conclusion","title":"Conclusion","text":"<p>Understanding falsy values and implicit type conversion helps prevent bugs in JavaScript. Key practices include:</p> <ul> <li>Use <code>===</code> for comparisons.</li> <li>Be explicit in conditions and logical operations.</li> <li>Use <code>??</code> for nullish coalescing instead of <code>||</code> when dealing with <code>null</code> or <code>undefined</code>.</li> </ul>"},{"location":"js/coercion/how-does-it-really-works/","title":"How does it work","text":""},{"location":"js/coercion/how-does-it-really-works/#six-falsy-values-in-javascript","title":"Six falsy values in JavaScript","text":"<ul> <li>false: The boolean value <code>false</code>.</li> <li>0: The number zero.</li> <li><code>\"\"</code>: An empty string.</li> <li>null: The null keyword, representing the absence of any object value.</li> <li>undefined: The undefined keyword, representing an uninitialized value.</li> <li>NaN: Stands for \"Not a Number\". It represents a special value returned from an operation that should return a numeric value but doesn't.</li> </ul>"},{"location":"js/coercion/how-does-it-really-works/#implicit-type-conversion-type-coercion-in-javascript","title":"Implicit Type Conversion (Type Coercion) in JavaScript","text":"<p>Implicit type conversion, also known as type coercion, occurs when JavaScript automatically converts one data type to another during operations. This happens in scenarios where different types are involved in an operation, and JavaScript attempts to make the operation valid by converting one of the types.</p>"},{"location":"js/coercion/how-does-it-really-works/#types-of-type-coercion","title":"Types of Type Coercion","text":"<ol> <li> <p>To String</p> <ul> <li> <p>When a number or boolean is added to a string, JavaScript converts them to a string.</p> <pre><code>console.log(\"Hello\" + 42); // \"Hello42\"\nconsole.log(\"Value: \" + true); // \"Value: true\"\n</code></pre> </li> </ul> </li> <li> <p>To Number</p> <ul> <li> <p>When using arithmetic operators (except <code>+</code>), JavaScript converts non-numeric types to numbers.</p> <pre><code>console.log(\"5\" - 2); // 3\nconsole.log(\"10\" * 3); // 30\nconsole.log(\"100\" / 5); // 20\n</code></pre> </li> </ul> </li> <li> <p>To Boolean</p> <ul> <li>In conditional statements, non-boolean values are implicitly converted to boolean values.</li> <li>Falsy values: <code>false</code>, <code>0</code>, <code>\"\"</code>, <code>null</code>, <code>undefined</code>, <code>NaN</code></li> <li>Truthy values: Everything else</li> </ul> <pre><code>if (\"\") {\n  console.log(\"This won\u2019t run\");\n} else {\n  console.log(\"Falsy value\");\n}\n\nif (1) {\n  console.log(\"Truthy value\");\n}\n</code></pre> </li> </ol>"},{"location":"js/coercion/how-does-it-really-works/#examples-of-implicit-type-conversion","title":"Examples of Implicit Type Conversion","text":"Expression Converted To Result <code>'5' + 5</code> <code>'5' + '5'</code> <code>'55'</code> <code>'5' - 2</code> <code>5 - 2</code> <code>3</code> <code>true + 1</code> <code>1 + 1</code> <code>2</code> <code>false + 1</code> <code>0 + 1</code> <code>1</code> <code>null + 5</code> <code>0 + 5</code> <code>5</code> <code>undefined + 5</code> <code>NaN + 5</code> <code>NaN</code>"},{"location":"js/coercion/how-does-it-really-works/#avoiding-type-coercion","title":"Avoiding Type Coercion","text":"<p>To avoid implicit type coercion:</p> <ul> <li>Use strict equality (<code>===</code>) instead of loose equality (<code>==</code>).</li> <li>Explicitly convert types using <code>String()</code>, <code>Number()</code>, or <code>Boolean()</code>.</li> </ul> <pre><code>console.log(\"5\" == 5); // true (implicit conversion)\nconsole.log(\"5\" === 5); // false (no conversion)\n</code></pre>"},{"location":"js/coercion/how-does-it-really-works/#falsy-values-in-javascript","title":"Falsy Values in JavaScript","text":"<p>In JavaScript, falsy values are values that are considered <code>false</code> when evaluated in a boolean context (e.g., in <code>if</code> conditions). These values include:</p> <ol> <li><code>false</code></li> <li><code>0</code> (both <code>+0</code> and <code>-0</code>)</li> <li><code>\"\"</code> (empty string)</li> <li><code>null</code></li> <li><code>undefined</code></li> <li><code>NaN</code> (Not-a-Number)</li> </ol> <p>Everything else is considered a truthy value, including non-empty strings (<code>\"hello\"</code>), objects (<code>{}</code>), arrays (<code>[]</code>), and numbers other than <code>0</code>.</p>"},{"location":"js/coercion/how-does-it-really-works/#why-does-javascript-perform-type-conversion","title":"Why Does JavaScript Perform Type Conversion?","text":"<p>JavaScript is a loosely typed or dynamically typed language, meaning variables do not have a fixed type. The language performs type coercion to make operations valid when operands or values are of different types. Reasons:</p> Reasons <ol> <li> <p>Convenience</p> <p>To allow developers to write concise code without explicitly converting data types.</p> <pre><code>console.log('5' + 5);  // \"55\" (string concatenation)\n</code></pre> </li> <li> <p>Dynamic Behavior</p> <p>JavaScript needs to make sense of dynamic or uncertain types during execution.</p> <pre><code>if (userInput) {\n    // Automatically checks if userInput is truthy or falsy.\n}\n</code></pre> </li> <li> <p>Specification</p> <p>JavaScript follows the ECMAScript Language Specification that defines rules for implicit conversions.</p> </li> </ol>"},{"location":"js/coercion/how-does-it-really-works/#how-does-javascript-perform-implicit-conversion","title":"How Does JavaScript Perform Implicit Conversion?","text":"<p>JavaScript uses a ToBoolean abstract operation to determine whether a value is truthy or falsy. Here's how it works:</p> ToBoolean Conversion Table Value Type Converted To <code>false</code> Boolean <code>false</code> <code>0</code> Number <code>false</code> <code>\"\"</code> String <code>false</code> <code>null</code> Null <code>false</code> <code>undefined</code> Undefined <code>false</code> <code>NaN</code> Number <code>false</code> All others Various Types <code>true</code>"},{"location":"js/coercion/how-does-it-really-works/#examples-of-implicit-conversion-to-boolean","title":"Examples of Implicit Conversion to Boolean","text":"<ol> <li> <p>In <code>if</code> statements:</p> <pre><code>if (0) {\n  console.log(\"This won\u2019t run\"); // 0 is falsy\n} else {\n  console.log(\"Falsy value\");\n}\n</code></pre> </li> <li> <p>In logical operators:</p> <pre><code>console.log(0 || \"Hello\"); // \"Hello\" (0 is falsy, so it returns the second operand)\nconsole.log(1 &amp;&amp; \"World\"); // \"World\" (1 is truthy, so it evaluates the second operand)\n</code></pre> </li> </ol>"},{"location":"js/coercion/how-does-it-really-works/#conversion-mechanics","title":"Conversion Mechanics","text":"<ol> <li> <p>String to Boolean</p> <ul> <li>Non-empty strings \u2192 <code>true</code></li> <li> <p>Empty string <code>\"\"</code> \u2192 <code>false</code></p> <pre><code>console.log(Boolean(\"\")); // false\nconsole.log(Boolean(\"Hello\")); // true\n</code></pre> </li> </ul> </li> <li> <p>Number to Boolean</p> <ul> <li><code>0</code>, <code>-0</code>, <code>NaN</code> \u2192 <code>false</code></li> <li> <p>All other numbers \u2192 <code>true</code></p> <pre><code>console.log(Boolean(0)); // false\nconsole.log(Boolean(42)); // true\n</code></pre> </li> </ul> </li> <li> <p><code>null</code> and <code>undefined</code></p> <ul> <li> <p>Always false.</p> <pre><code>console.log(Boolean(null)); // false\nconsole.log(Boolean(undefined)); // false\n</code></pre> </li> </ul> </li> </ol>"},{"location":"js/coercion/how-does-it-really-works/#why-falsy-values-behave-this-way","title":"Why Falsy Values Behave This Way?","text":"<p>The interpretation of falsy values is designed to align with common programming scenarios. For example:</p> <ul> <li><code>0</code> represents \"no value\" in numerical contexts.</li> <li><code>\"\"</code> represents \"no content\" in string contexts.</li> <li><code>null</code> and <code>undefined</code> represent \"absence of value.\"</li> <li><code>NaN</code> represents invalid numerical operations.</li> </ul> <p>This makes the language flexible and expressive but can also lead to bugs if not handled carefully.</p>"},{"location":"js/coercion/how-does-it-really-works/#reference","title":"Reference","text":"<ul> <li>Six falsy values in JavaScript</li> <li>Falsy: MDN docs</li> </ul>"},{"location":"js/coercion/intro/","title":"Intro","text":""},{"location":"js/coercion/intro/#use-instead-of","title":"Use <code>===</code> Instead of <code>==</code>","text":"<p>Many JavaScript programmers, including your humble author, often repeat the mistake of comparing using ==, which is the type-coercion non-strict equality operator.</p> gotchas/double-equals.js<pre><code>//BROKEN CODE\nconst a = \"1\";\nconst b = 1;\nconst c = \"1.0\";\n\nconsole.log(a == b);\nconsole.log(b == c);\nconsole.log(a == c);\n</code></pre> <p>In the short piece of code, the constants a, b, and c have values '1', 1, and '1.0', respectively.</p> <p>One value is of number type and the other two are of string type.</p> <p>The last three lines compare each combination of the constants. Suppose <code>a</code> is equal to <code>b</code> and <code>b</code> is equal to <code>c</code>; then logically JavaScript should tell us that <code>a</code> is equal to <code>c</code>. But the JavaScript <code>==</code> operator does not honor the transitive property of equality, due to type coercion, as we see in the output produced by running the code</p> <pre><code>true;\ntrue;\nfalse;\n</code></pre> <p>When comparing <code>a</code> with <code>b</code> and <code>b</code> with <code>c</code>, type coercion was involved before the comparison. However, when <code>a</code> and <code>c</code> were compared, a lexical comparison was used. Hence we see a different result than what we may otherwise expect.</p> Note <p>In the uncommon situation where you want type coercion before comparison for equality, then <code>==</code> is your operator. One situation where <code>==</code> may be a better choice than <code>===</code> is when you want to determine if a <code>variable</code> is either <code>null</code> or <code>undefined</code> \u2014 the check <code>variable == null</code> will yield true if <code>variable</code> is <code>null</code> or <code>undefined</code> and may be used instead of <code>variable === null || variable === undefined</code>.</p> <ul> <li>Rediscovering JavaScript by Venkat Subramaniam, pg:5</li> </ul>"},{"location":"js/coercion/intro/#reference-books","title":"Reference Books","text":""},{"location":"js/coercion/intro/#reference-blogs","title":"Reference Blogs","text":"<ul> <li>Use explicit conversion over implicit coercion</li> <li>Coercion comes in two forms in JavaScript:</li> <li>Coercion is not to be confused with type conversio</li> </ul>"},{"location":"js/coercion/rules/","title":"Rules","text":"<p>Yes, there are rules and precedence that govern how JavaScript handles operations between different types, including string and number concatenation or addition. Here's a breakdown of how type coercion works and the operator precedence in JavaScript:</p>"},{"location":"js/coercion/rules/#type-coercion-rules-in-javascript","title":"Type Coercion Rules in JavaScript:","text":"<p>JavaScript automatically converts (or coerces) values from one type to another depending on the operation being performed. Here are the most common rules related to type coercion:</p> <p>1.1. String <code>+</code> Number (or any other type)</p> <p>When using the <code>+</code> operator, JavaScript checks if either operand is a <code>string</code>. If so, it converts the other operand to a string and concatenates the two.</p> <pre><code>console.log(\"5\" + 5); // '55' (number is coerced to string and concatenated)\nconsole.log(\"Hello\" + 2); // 'Hello2'\nconsole.log(3 + \" apples\"); // '3 apples'\n</code></pre> Why? <p>The <code>+</code> operator is special:</p> <ul> <li>it can either perform numeric addition (if both operands are numbers) or</li> <li>string concatenation (if one or both operands are strings).</li> </ul> <p>If there's a string involved, JavaScript prefers concatenation.</p> <p>1.2. Number + Number</p> <p>If both operands are numbers, JavaScript performs numeric addition.</p> <pre><code>console.log(5 + 5); // 10\nconsole.log(3 + 2.5); // 5.5\n</code></pre> Why? <ul> <li>Both operands are numbers, so JavaScript simply adds them.</li> </ul> <p>1.3. Other Arithmetic Operators (e.g., <code>-</code>, <code>*</code>, <code>/</code>)</p> <p>For operations like <code>-</code>, <code>*</code>, <code>/</code>, and <code>**</code> (exponentiation), JavaScript coerces values to numbers before performing the operation, even if one operand is a string.</p> <pre><code>console.log(\"5\" - 5); // 0 (string '5' is converted to number 5)\nconsole.log(\"10\" * 2); // 20\nconsole.log(\"6\" / 3); // 2\nconsole.log(\"2\" ** 3); // 8\n</code></pre> Why <p>JavaScript tries to perform numeric operations when the operator is not <code>+</code> (because <code>+</code> can also be used for string concatenation). If one of the operands is a string, it will be converted to a number.</p> <p>1.4. Non-numeric Values in Arithmetic Operations</p> <p>If non-numeric values (like <code>null</code>, <code>undefined</code>, or <code>boolean</code>) are involved in arithmetic operations, JavaScript will attempt to coerce them into numbers. However, this can lead to unexpected results.</p> <pre><code>console.log(\"5\" - null); // 5 (null coerced to 0)\nconsole.log(\"5\" - true); // 4 (true coerced to 1)\nconsole.log(\"5\" - false); // 5 (false coerced to 0)\nconsole.log(\"5\" - undefined); // NaN (undefined coerced to NaN)\n</code></pre> <p>1.5. Boolean to Number Conversion</p> <p>When a boolean is used in arithmetic or other operations, <code>true</code> becomes <code>1</code> and <code>false</code> becomes <code>0</code>.</p> <pre><code>console.log(true + 1); // 2\nconsole.log(false + 1); // 1\n</code></pre>"},{"location":"js/coercion/rules/#operator-precedence-in-javascript","title":"Operator Precedence in JavaScript:","text":"<p>JavaScript operators have precedence, meaning some operators take priority over others in an expression. Here\u2019s a summary of operator precedence in JavaScript:</p> <p>2.1. High Precedence Operators (evaluated first):</p> <ul> <li>Parentheses <code>()</code> \u2014 Used to change the order of operations.</li> <li>Exponentiation <code>**</code> \u2014 Evaluates to the power of a number (e.g., <code>2 ** 3</code> is <code>8</code>).</li> <li>Multiplication, Division, Modulus (<code>*</code>, <code>/</code>, <code>%</code>) \u2014 Evaluate from left to right.</li> </ul> <p>2.2. Lower Precedence Operators:</p> <ul> <li>Addition and Subtraction (<code>+</code>, <code>-</code>) \u2014 These operators are evaluated after multiplication, division, and exponentiation.</li> </ul> <p>2.3. Assignment Operators:</p> <ul> <li>Assignment (<code>=</code>, <code>+=</code>, <code>-=</code> etc.) \u2014 These have lower precedence than arithmetic operations.</li> </ul>"},{"location":"js/coercion/rules/#operator-precedence-table-simplified","title":"Operator Precedence Table (Simplified)","text":"Precedence Operator Description 1st <code>()</code> Parentheses (grouping) 2nd <code>**</code> Exponentiation 3rd <code>*</code>, <code>/</code>, <code>%</code> Multiplication, Division, Modulus 4th <code>+</code>, <code>-</code> Addition, Subtraction 5th <code>=</code>, <code>+=</code>, <code>-=</code>, etc. Assignment"},{"location":"js/coercion/rules/#operator-precedence-in-action","title":"Operator Precedence in Action:","text":"<pre><code>let result = 2 + 3 * 4; // 14, because multiplication (*) has higher precedence than addition (+)\nconsole.log(result);\n</code></pre> <p>If you want to change the order of operations, you can use parentheses to ensure the intended precedence:</p> <pre><code>let result = (2 + 3) * 4; // 20, because parentheses change the order\nconsole.log(result);\n</code></pre>"},{"location":"js/coercion/rules/#conclusion","title":"Conclusion:","text":"<ul> <li> <p>Type Coercion: JavaScript automatically converts types when necessary. The <code>+</code> operator triggers string concatenation if one operand is a string, otherwise, it performs numeric addition.</p> </li> <li> <p>Operator Precedence: JavaScript evaluates operators according to a set precedence. For example, multiplication and division are evaluated before addition and subtraction.</p> </li> </ul> <p>Best Practice: It's good practice to be explicit about your intent (e.g., converting values before performing operations) to avoid unexpected behavior due to JavaScript's type coercion rules. For example, if you want to ensure that both operands are treated as numbers, you can explicitly convert them using <code>Number()</code>, <code>parseInt()</code>, or <code>parseFloat()</code>.</p>"},{"location":"js/coercion/rules/#reference","title":"Reference","text":"<ul> <li>W3Schools: JavaScript Operator Precedence</li> </ul>"},{"location":"js/coercion/type-coercion/","title":"Type Coercion","text":"two forms <p>Coercion comes in two forms in JavaScript:</p> <ul> <li>explicit &amp;</li> <li>implicit</li> </ul> <ul> <li>Coercion comes in two forms in JavaScript:</li> </ul>"},{"location":"js/coercion/type-coercion/#reference-blogs","title":"Reference Blogs","text":"<ul> <li>Use explicit conversion over implicit coercion</li> <li>Coercion comes in two forms in JavaScript:</li> <li>Coercion is not to be confused with type conversio</li> </ul>"},{"location":"js/constructors/overview/","title":"Overview","text":""},{"location":"js/constructors/overview/#overview","title":"Overview","text":"Object Constructor Functions <p>Sometimes we need to create many objects of the same type.</p> <p>To create an object type we use an object constructor function.</p> <p>It is considered good practice to name constructor functions with an upper-case first letter.</p>"},{"location":"js/constructors/overview/#did-you-know","title":"Did You Know?","text":"<ul> <li>Use object literals <code>{}</code> instead of <code>new Object()</code>.</li> <li>Use array literals <code>[]</code> instead of <code>new Array()</code>.</li> <li>Use pattern literals <code>/()/</code> instead of <code>new RegExp()</code>.</li> <li>Use function expressions <code>() {}</code> instead of <code>new Function()</code>.</li> </ul> Example<pre><code>\"\";           // primitive string\n0;            // primitive number\nfalse;        // primitive boolean\n\n{};           // object object\n[];           // array object\n/()/          // regexp object\nfunction(){}; // function\n</code></pre> Tips <ul> <li><code>Object</code> is a constructor function in JavaScript, and <code>typeof</code> returns <code>\"function\"</code> because functions (like <code>Object</code>) are treated as a distinct type in JavaScript.</li> <li>Although <code>Object</code> is used to create objects, it is itself a function.</li> </ul> <p>So, when you use <code>typeof Object</code>, it returns <code>\"function\"</code> because <code>Object</code> is a built-in constructor function!</p>"},{"location":"js/constructors/overview/#why-typeof-object-returns-function","title":"Why <code>typeof</code> Object returns <code>\"function\"</code>:","text":"<ol> <li> <p><code>Object</code> is a constructor function: <code>Object</code> is a built-in function in JavaScript that creates new objects. It's not just an ordinary object\u2014it's a function that can be called using new to create new instances (objects).</p> </li> <li> <p><code>Functions</code> are a special type of object: In JavaScript, functions are also objects, but they have the ability to be called (invoked). The JavaScript engine distinguishes functions from regular objects by returning <code>\"function\"</code> when you use <code>typeof</code> on a function.</p> <ul> <li><code>typeof Object</code> returns <code>\"function\"</code> because <code>Object</code> is a function (specifically a constructor function).</li> <li>You can call <code>Object</code> like a function (e.g., <code>new Object()</code>), so JavaScript recognizes it as a function type</li> </ul> </li> </ol>"},{"location":"js/constructors/overview/#type-of","title":"Type of","text":"<pre><code># Primitive =&gt; Stack Memory\ntypeof Number\n\"function\"\n\ntypeof 1\n\"number\"\n\ntypeof String\n\"function\"\n\ntypeof \"name\"\n\"string\"\n\ntypeof Boolean\n\"function\"\n\ntypeof true\n\"boolean\"\n\n# Trival Data Types\ntypeof null\n\"object\"\n\ntypeof undefined\n\"undefined\"\n\n## Non Primitive =&gt; Heap Memory\ntypeof Object\n\"function\"\n\ntypeof {}\n\"object\"\n\ntypeof Array\n\"function\"\n\ntypeof []\n\"object\"\n\ntypeof RegExp\n\"function\"\n\ntypeof Date\n\"function\"\n\ntypeof Symbol\n\"function\"\n</code></pre> Summary: Ways to Check if a Function is a Constructor <ul> <li>Try using <code>new</code> with the function: If it creates a new object, it\u2019s likely a constructor.</li> <li>Check for the <code>prototype</code> property: If the function has a <code>prototype</code>, it's probably a constructor function.</li> <li>Check if the function is an instance of <code>Function</code>: Constructors are functions, so functionName instanceof Function should return true.</li> <li>Look for the <code>constructor</code> property: Objects created by constructor functions usually have a constructor property that points to the constructor.</li> <li>Follow naming conventions: Although not strictly enforced, constructors often have capitalized names (e.g., <code>Person</code>, <code>Car</code>).</li> </ul> <p>By using these methods, you can confidently determine whether a function is designed to be used as a constructor in JavaScript.</p> <ul> <li>Date: JavaScript doesn\u2019t have a \"literal\" for <code>Date</code>, but you create a <code>Date</code> object with <code>new Date()</code> or <code>new Date(\"YYYY-MM-DD\")</code>.</li> <li>Regular Expressions: You can create a regex using the literal syntax: <code>/pattern/</code>, with optional flags (like <code>i</code> for case-insensitive matching).</li> <li>Symbols: There's no literal syntax for <code>Symbol</code>; you create symbols using the <code>Symbol()</code> constructor.</li> </ul>"},{"location":"js/constructors/overview/#key-differences-between-using-new-and-literal-syntax","title":"Key Differences Between Using <code>new</code> and Literal Syntax","text":"<p>In JavaScript, you can create objects using two main approaches: using the <code>new</code> keyword or using a literal. Each has its own characteristics, and understanding the difference is key to knowing when to use which approach. Let's explore the differences:</p> Feature Using <code>new</code> Using Literal Syntax Syntax Requires the <code>new</code> keyword Directly uses <code>{}</code>, <code>[]</code>, or <code>/.../</code> Use Case For creating instances of objects, arrays, functions, and built-in types like <code>Date</code>, <code>RegExp</code>, etc. For creating simple objects, arrays, or regex Constructor Function Requires a constructor function to be invoked (e.g., <code>new Object()</code>) No constructor function is involved Prototypes Objects created with <code>new</code> inherit from the constructor's <code>prototype</code> Objects inherit from <code>Object.prototype</code> Performance Slightly more overhead due to the use of a constructor function More efficient for creating simple objects Readability Slightly more verbose and harder to read More concise and easy to understand <p>In general, unless you specifically need to use a constructor function for a built-in type (like Date, RegExp), literal syntax is simpler, more readable, and preferred for creating objects and arrays.</p> <p></p>"},{"location":"js/constructors/overview/#reference","title":"Reference","text":"<ul> <li>W3schools, Constructors</li> <li>Stackoverflow</li> <li> <p>What is a Constructor in JavaScript?</p> </li> <li> <p>Top 6 Non Primitive Data Types In JavaScript</p> </li> </ul>"},{"location":"js/core/callback/","title":"Callbacks","text":"<p>A callback function in JavaScript is a fundamental concept that plays a crucial role in handling asynchronous operations and implementing flexible code. Let\u2019s break down everything from the basics to advanced usage.</p>"},{"location":"js/core/closure/","title":"Closure","text":"<p>One of the most important concepts to learn in JavaScript is closures. Mastering closures is key to understanding many advanced JavaScript concepts such as:</p> <ol> <li> <p>Callbacks and Higher-Order Functions: Functions that return or take other functions as arguments rely heavily on closures. This is foundational for asynchronous programming, event handling, and functional programming.</p> </li> <li> <p>Lexical Scope: Closures are based on how JavaScript handles variable scoping, which is essential when writing modular, reusable code.</p> </li> <li> <p>Modules and Data Privacy: Understanding closures allows you to create private variables and implement encapsulation, which is crucial in creating well-structured, maintainable code.</p> </li> <li> <p>Asynchronous JavaScript (Promises, async/await): Closure helps in managing the state in asynchronous functions, avoiding side effects, and managing async callbacks.</p> </li> </ol> <p>By mastering closures, you'll gain a deeper understanding of how JavaScript handles function scopes, which is foundational for mastering more advanced concepts such as functional programming, asynchronous patterns, and JavaScript frameworks like React.</p> <p>A closure in JavaScript occurs when an inner function has access to the variables from its outer function, even after the outer function has finished executing. Let's break this down with an example and dive into when and why we use closures.</p> Basic ExampleHow It Works <pre><code>function outerFunction() {\n    let outerVariable = \"I am from the outer function\";\n\n    function innerFunction() {\n        console.log(outerVariable); // Accesses outerVariable from outerFunction\n    }\n\n    return innerFunction; // Return innerFunction to be used outside\n}\n\nconst closure = outerFunction(); // outerFunction is called, and it returns innerFunction\nclosure(); // Calls innerFunction, which still has access to outerVariable\n</code></pre> <ul> <li><code>outerFunction()</code> declares a variable <code>outerVariable</code> and an inner function <code>innerFunction()</code> that uses it.</li> <li><code>outerFunction()</code> returns <code>innerFunction()</code> to the outer scope.</li> <li>When <code>closure()</code> is called, even though <code>outerFunction()</code> has finished execution, <code>innerFunction()</code> still has access to <code>outerVariable</code> because of closure. The JavaScript engine remembers the scope in which <code>innerFunction()</code> was created.</li> </ul>"},{"location":"js/core/closure/#when-to-use-closures","title":"When to Use Closures","text":"<ol> <li> <p>Encapsulation / Data Privacy:</p> <p>Closures can help you create private variables that can't be accessed from outside a function.</p> <pre><code>function counter() {\n    let count = 0;\n\n    return function () {\n        count++; // count persists in memory due to closure\n        console.log(count);\n    };\n}\n\nconst increment = counter();\nincrement(); // 1\nincrement(); // 2\nincrement(); // 3\n</code></pre> <p>Here, the <code>count</code> variable is protected and can't be directly modified from outside. It can only be incremented via the returned function.</p> </li> <li> <p>Maintaining State in Asynchronous Programming:</p> <p>Closures are useful when working with asynchronous callbacks, as they maintain the state between calls.</p> <pre><code>function fetchData() {\n    const data = \"Loaded data\"; // Imagine this is fetched from an API\n\n    setTimeout(function () {\n        console.log(data); // Accesses data even after fetchData execution is done\n    }, 1000);\n}\n\nfetchData();\n</code></pre> </li> <li> <p>Function Factories:</p> <p>You can use closures to create functions dynamically based on the outer scope.</p> <pre><code>function createMultiplier(multiplier) {\n    return function (num) {\n        return num * multiplier;\n    };\n}\n\nconst double = createMultiplier(2);\nconst triple = createMultiplier(3);\n\nconsole.log(double(5)); // 10\nconsole.log(triple(5)); // 15\n</code></pre> </li> </ol>"},{"location":"js/core/closure/#why-do-we-need-closures","title":"Why Do We Need Closures?","text":"<ol> <li> <p>Data Persistence: Closures allow functions to remember the environment in which they were created. This is helpful for maintaining state, encapsulating data, or working with asynchronous code.</p> </li> <li> <p>Avoiding Global Variables: Without closures, you may resort to using global variables to retain state, which can lead to bugs and harder-to-maintain code.</p> </li> <li> <p>Higher-Order Functions &amp; Functional Programming: Closures enable more flexible, modular code by returning and passing around functions that remember their environments.</p> </li> </ol>"},{"location":"js/core/closure/#what-happens-if-we-dont-use-closures","title":"What Happens if We Don\u2019t Use Closures?","text":"<ul> <li> <p>No Encapsulation: Without closures, variables in outer functions would be inaccessible after those functions complete. You might have to use global variables, which is generally discouraged because they can lead to name conflicts and side effects in larger codebases.</p> </li> <li> <p>Loss of State: In asynchronous code, you'd lose the ability to persist data from the original function context, leading to more complex and less maintainable code.</p> </li> <li> <p>Functional Programming Limitations: You won't be able to effectively use function factories or higher-order functions, which are key to writing clean, functional JavaScript code.</p> </li> </ul> <p>Closures are a powerful tool that help in creating more modular, reusable, and maintainable code. They are especially useful in real-world scenarios like managing state in asynchronous calls, avoiding global variables, and creating private data.</p>"},{"location":"js/core/closure/#real-world-examples-of-closures-in-javascript-and-react","title":"Real-World Examples of Closures in JavaScript and React","text":"<p>Closures are widely used in JavaScript libraries, packages, and frameworks like React. Below are examples of how closures are applied in real-world scenarios.</p> <ol> <li> <p>Using Closures in JavaScript (Debouncing Example)</p> <p>In web development, debouncing is a technique used to limit the rate at which a function gets invoked. For example, when handling user input, we may want to delay execution of a function until the user stops typing.</p> ExampleExplanation <pre><code>function debounce(func, delay) {\n    let timeout;\n\n    return function(...args) {\n        const context = this;\n        clearTimeout(timeout);\n        timeout = setTimeout(() =&gt; func.apply(context, args), delay);\n    };\n}\n\n// Usage: Debouncing a search function\nconst searchInput = document.getElementById(\"search\");\n\nsearchInput.addEventListener(\"input\", debounce(function (event) {\n    console.log(\"Search query:\", event.target.value);\n}, 300));\n</code></pre> <p>How Closures Work Here:</p> <ul> <li><code>debounce()</code> returns a function that remembers the <code>timeout</code> variable from the outer function, ensuring that only the latest function call is executed after a delay.</li> <li>The inner function maintains access to the outer function's <code>timeout</code> variable across multiple calls, which is crucial to implement debouncing.</li> </ul> <p>Why It's Useful:</p> <p>Without closures, you'd need to manage the <code>timeout</code> variable globally or in another external scope, which would complicate the code and lead to potential bugs.</p> </li> <li> <p>Using Closures in React (State Management with <code>useState</code> Hook)</p> <p>React's <code>useState</code> hook indirectly relies on closures to preserve the component's state across renders. Closures help to keep the state within the scope of the functional component.</p> ExampleExplanation <pre><code>import React, { useState } from \"react\";\n\nfunction Counter() {\n    const [count, setCount] = useState(0);\n\n    function increment() {\n        setCount((prevCount) =&gt; prevCount + 1); // Closure retains access to prevCount\n    }\n\n    return (\n        &lt;div&gt;\n            &lt;p&gt;Count: {count}&lt;/p&gt;\n            &lt;button onClick={increment}&gt;Increment&lt;/button&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default Counter;\n</code></pre> <p>How Closures Work Here:</p> <ul> <li>The <code>setCount</code> function receives the current state (<code>prevCount</code>) and returns an updated state.</li> <li>Even though the <code>increment</code> function is executed on each re-render, the closure allows it to access the most recent <code>count</code> state value, thanks to the way React re-renders components and preserves state with hooks.</li> </ul> <p>Why It's Useful:</p> <p>Without closures, managing state updates in React would require much more manual work, such as handling global state or keeping track of the previous state explicitly.</p> </li> <li> <p>Using Closures in Redux Thunk (Handling Asynchronous Logic in Redux)</p> <p>In Redux, middleware like Redux Thunk uses closures to delay the dispatch of actions until after some asynchronous logic (e.g., API calls) has been completed.</p> ExampleExplanation <pre><code>// Action creator using Redux Thunk\nfunction fetchUserData(userId) {\n    return function (dispatch, getState) {\n        // Closure over dispatch and getState\n        dispatch({ type: \"FETCH_USER_REQUEST\" });\n\n        fetch(`/api/user/${userId}`)\n            .then(response =&gt; response.json())\n            .then(data =&gt; {\n                dispatch({ type: \"FETCH_USER_SUCCESS\", payload: data });\n            })\n        .catch(error =&gt; {\n            dispatch({ type: \"FETCH_USER_FAILURE\", error });\n        });\n    };\n}\n</code></pre> <p>How Closures Work Here:</p> <ul> <li>The returned function is a closure that maintains access to the <code>dispatch</code> and <code>getState</code> functions.</li> <li>Even after the outer action creator finishes executing, the inner function can still call <code>dispatch()</code> and interact with Redux's state and actions.</li> </ul> <p>Why It's Useful:</p> <p>Without closures, you\u2019d lose access to the <code>dispatch</code> and <code>getState</code> methods once the asynchronous call begins, and managing side effects like API calls would become more difficult and less clean.</p> </li> <li> <p>Custom Hook in React Using Closure</p> <p>React developers often write custom hooks to abstract complex logic. These hooks use closures to encapsulate state and behavior, providing reusable logic across components.</p> ExampleExplanation <pre><code>import { useState, useEffect } from 'react';\n\n// A custom hook that uses closure to encapsulate timer functionality\nfunction useTimer() {\n    const [seconds, setSeconds] = useState(0);\n\n    useEffect(() =&gt; {\n        const intervalId = setInterval(() =&gt; {\n            setSeconds((prevSeconds) =&gt; prevSeconds + 1); // Closure remembers previous seconds\n        }, 1000);\n\n        return () =&gt; clearInterval(intervalId);\n    }, []);\n\n    return seconds;\n}\n\n// Usage of the custom hook\nfunction TimerComponent() {\n    const secondsElapsed = useTimer();\n\n    return &lt;div&gt;Time Elapsed: {secondsElapsed} seconds&lt;/div&gt;;\n}\n</code></pre> <p>How Closures Work Here:</p> <ul> <li>The <code>setSeconds</code> function uses a closure to remember and update the previous state (<code>prevSeconds</code>) at each interval.</li> <li>The <code>useEffect</code> hook ensures that the interval runs in the background, while the closure inside <code>setSeconds</code> allows access to the most recent value of <code>seconds</code>.</li> </ul> <p>Why It's Useful:</p> <p>Without closures, updating the <code>seconds</code> state would require a more cumbersome manual approach, and the <code>useEffect</code> wouldn't be able to access the component's most recent state.</p> </li> <li> <p>Handling Event Listeners (A Closure Example in Vanilla JS)</p> <p>Event listeners often make use of closures to maintain access to the environment in which they were created.</p> ExampleExplanation <pre><code>function createEventListener(elementId, message) {\n    const element = document.getElementById(elementId);\n\n    element.addEventListener(\"click\", function () {\n        console.log(message); // Closure retains access to `message`\n    });\n}\n\ncreateEventListener(\"myButton\", \"Button was clicked!\");\n</code></pre> <p>How Closures Work Here:</p> <ul> <li>The event listener's callback function retains access to the <code>message</code> variable, even after <code>createEventListener</code> finishes execution.</li> <li>Each time the button is clicked, the inner function can still access the message it was created with.</li> </ul> <p>Why It's Useful:</p> <p>Without closures, you'd have to pass the <code>message</code> directly into the event listener at the time of the click, which would reduce the flexibility of the code.</p> </li> </ol>"},{"location":"js/core/closure/#conclusion","title":"Conclusion","text":"<p>Closures are crucial in JavaScript for:</p> <ul> <li>Encapsulating logic (as seen in the <code>debounce</code> function or custom React hooks).</li> <li>Preserving state (e.g., React's <code>useState</code> or Redux Thunk's asynchronous actions).</li> <li>Enabling modular, reusable code by maintaining access to outer variables long after the outer function has executed.</li> </ul> <p>Without closures, maintaining state and reusability would become significantly more challenging, leading to more complex, less efficient code.</p>"},{"location":"js/core/control-statement/","title":"Control Statement","text":"<p>Control statements in JavaScript allow you to control the flow of execution within your programs. They enable you to make decisions, iterate over collections, and manage complex logical operations. Here are the main control statements in JavaScript:</p> <p>Tip</p> <ul> <li>Conditional Statements: <code>if</code>, <code>if...else</code>, <code>if...else if...else</code>, <code>switch</code>.</li> <li>Looping Statements: <code>for</code>, <code>while</code>, <code>do...while</code>.</li> <li>Jump Statements: <code>break</code>, <code>continue</code>, <code>return</code>.</li> <li>Exception Handling Statements: <code>try...catch</code>, <code>try...catch...finally</code>, <code>throw</code>.</li> </ul> Looping an Array &amp; Object Looping an ArrayLooping through an Object <ol> <li> <p><code>for</code> loop:</p> <ul> <li>Does not return a new array.</li> <li> <p>It is simply a control flow statement.</p> <pre><code>const array = [1, 2, 3, 4, 5];\n\nfor (let i = 0; i &lt; array.length; i++) {\n    console.log(array[i]);\n}\n</code></pre> </li> </ul> </li> <li> <p><code>for...of</code> loop:</p> <ul> <li>Does not return a new array.</li> <li> <p>It is used to iterate over iterable objects.</p> <pre><code>const array = [1, 2, 3, 4, 5];\n\nfor (const item of array) {\n    console.log(item);\n}\n</code></pre> </li> </ul> </li> <li> <p><code>forEach</code> method:</p> <ul> <li>Does not return a new array.</li> <li> <p>It executes a provided function once for each array element.</p> <pre><code>const array = [1, 2, 3, 4, 5];\n\narray.forEach(item =&gt; {\n    console.log(item);\n});\n</code></pre> </li> </ul> </li> <li> <p><code>map</code> method:</p> <ul> <li>Returns a new array.</li> <li> <p>It creates a new array with the results of calling a provided function on every element in the calling array.</p> <pre><code>const array = [1, 2, 3, 4, 5];\n\narray.map(item =&gt; {\n    console.log(item);\n    return item;\n});\n\n// Example\nconst array = [1, 2, 3, 4, 5];\nconst newArray = array.map(item =&gt; item * 2);\nconsole.log(newArray); // [2, 4, 6, 8, 10]\n</code></pre> </li> </ul> </li> </ol> <ol> <li> <p><code>for...in</code> loop:</p> <ul> <li>Does not return a new object.</li> <li> <p>It is used to iterate over the enumerable properties of an object.</p> <pre><code>const obj = {a: 1, b: 2, c: 3};\n\nfor (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n        console.log(key, obj[key]);\n    }\n}\n</code></pre> </li> </ul> </li> <li> <p><code>Object.keys</code> method:</p> <ul> <li> <p>Returns a new array of the object\u2019s own enumerable property names (keys).</p> <pre><code>const obj = {a: 1, b: 2, c: 3};\n\nObject.keys(obj).forEach(key =&gt; {\n    console.log(key, obj[key]);\n});\n\n// Example\nconst obj = {a: 1, b: 2, c: 3};\nconst keys = Object.keys(obj);\nconsole.log(keys); // ['a', 'b', 'c']\n</code></pre> </li> </ul> </li> <li> <p><code>Object.entries</code> method:</p> <ul> <li> <p>Returns a new array of the object\u2019s own enumerable string-keyed property [key, value] pairs.</p> <pre><code>const obj = {a: 1, b: 2, c: 3};\n\nObject.entries(obj).forEach(([key, value]) =&gt; {\n    console.log(key, value);\n});\n\n// Example\nconst obj = {a: 1, b: 2, c: 3};\nconst entries = Object.entries(obj);\nconsole.log(entries); // [['a', 1], ['b', 2], ['c', 3]]\n</code></pre> </li> </ul> </li> <li> <p><code>Object.values</code> method:</p> <ul> <li> <p>Returns a new array of the object\u2019s own enumerable property values.</p> <pre><code>const obj = {a: 1, b: 2, c: 3};\n\nObject.values(obj).forEach(value =&gt; {\n    console.log(value);\n});\n\n// Example\nconst obj = {a: 1, b: 2, c: 3};\nconst values = Object.values(obj);\nconsole.log(values); // [1, 2, 3]\n</code></pre> </li> </ul> </li> </ol> <p>These methods provide flexibility depending on the specific requirements of your task. For example, <code>for...in</code> is generally used for objects, while <code>for...of</code> is typically used for arrays and iterable objects.</p> <p>In summary, among the array methods, only map returns a new array. For objects, Object.keys, Object.entries, and Object.values return new arrays. Methods like for, for...of, forEach, and for...in are used for iteration and do not inherently create new arrays or objects.</p>"},{"location":"js/core/control-statement/#for-in-vs-for-of-loop","title":"for in <code>vs</code> for of Loop","text":"<p>The <code>for...in</code> and <code>for...of</code> loops are both used for iterating over collections in JavaScript, but they serve different purposes and work with different types of collections.</p>"},{"location":"js/core/control-statement/#forin-loop","title":"<code>for...in</code> Loop","text":"<ul> <li>Purpose: Iterates over the enumerable properties of an object.</li> <li>Usage: Typically used for iterating over the keys of an object.</li> <li>Works with: Objects (though it can also be used with <code>arrays</code>, it is generally not recommended).</li> </ul> <pre><code>const obj = {a: 1, b: 2, c: 3};\n\nfor (const key in obj) {\n    console.log(key, obj[key]);\n}\n\n// Output:\n// a 1\n// b 2\n// c 3\n</code></pre> <p>When used with <code>arrays</code>, it iterates over the array indices (which are the enumerable properties of the array object).</p> <pre><code>const array = [1, 2, 3, 4, 5];\n\nfor (const index in array) {\n    console.log(index, array[index]);\n}\n\n// Output:\n// 0 1\n// 1 2\n// 2 3\n// 3 4\n// 4 5\n</code></pre>"},{"location":"js/core/control-statement/#forof-loop","title":"for...of Loop","text":"<ul> <li>Purpose: Iterates over the values of an iterable object.</li> <li>Usage: Typically used for iterating over the values of arrays, strings, maps, sets, and other iterable objects.</li> <li>Works with: Arrays, strings, maps, sets, and other iterable objects.</li> </ul> <pre><code>const array = [1, 2, 3, 4, 5];\n\nfor (const value of array) {\n    console.log(value);\n}\n\n// Output:\n// 1\n// 2\n// 3\n// 4\n// 5\n</code></pre> <p>It can also be used with other iterable objects like strings:</p> <pre><code>const string = \"hello\";\n\nfor (const char of string) {\n    console.log(char);\n}\n\n// Output:\n// h\n// e\n// l\n// l\n// o\n</code></pre>"},{"location":"js/core/control-statement/#key-differences","title":"Key Differences","text":"<ol> <li> <p>Iteration Target:</p> <ul> <li><code>for...in</code> iterates over the enumerable properties (keys) of an object.</li> <li><code>for...of</code> iterates over the values of an iterable object.</li> </ul> </li> <li> <p>Common Use Cases:</p> <ul> <li><code>for...in</code> is commonly used with objects to get the keys.</li> <li><code>for...of</code> is commonly used with <code>arrays</code>, <code>strings</code>, <code>maps</code>, <code>sets</code>, and other iterable objects to get the values.</li> </ul> </li> <li> <p>Arrays:</p> <ul> <li><code>for...in</code> should generally be avoided for arrays because it iterates over keys (indices) and can include properties from the prototype chain.</li> <li><code>for...of</code> is ideal for arrays as it directly iterates over the values.</li> </ul> </li> <li> <p>Prototype Chain:</p> <ul> <li><code>for...in</code> iterates over all enumerable properties, including those inherited from the prototype chain.</li> <li><code>for...of</code> only iterates over the values of the iterable object and does not consider properties from the prototype chain.</li> </ul> </li> </ol> <p>In summary, use <code>for...in</code> when you need to iterate over the properties of an object and use <code>for...of</code> when you need to iterate over the values of an iterable collection like an array or string.</p>"},{"location":"js/core/high-order-function/","title":"High Order Function (Hof)","text":""},{"location":"js/core/high-order-function/#higher-order-functions","title":"Higher-Order Functions","text":"<p>A higher-order function is a function that does at least one of the following:</p> <ul> <li>Takes one or more functions as arguments.</li> <li>Returns a function as its result.</li> </ul> <p>In JavaScript, many of the methods provided by the Array object are higher-order functions because they accept a function as an argument to process each element in the array. Here are a couple of examples:</p> Example map()filter()reduce()forEach()some()every()find()findIndex()sort()concat() <p>Takes a function as an argument to apply to each element and returns a new array.</p> <pre><code>const numbers = [1, 2, 3];\nconst doubled = numbers.map(num =&gt; num * 2);\nconsole.log(doubled); // [2, 4, 6]\n</code></pre> <p>Takes a function as an argument to determine which elements to include in the new array.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst evens = numbers.filter(num =&gt; num % 2 === 0);\nconsole.log(evens); // [2, 4]\n</code></pre> <p>Executes a reducer function (that you provide) on each element of the array, resulting in a single output value.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst sum = numbers.reduce((accumulator, currentValue) =&gt; accumulator + currentValue, 0);\nconsole.log(sum); // 10\n</code></pre> <p>Executes a provided function once for each array element.</p> <pre><code>const numbers = [1, 2, 3, 4];\nnumbers.forEach(num =&gt; console.log(num)); // 1 2 3 4\n</code></pre> <p>Tests whether at least one element in the array passes the test implemented by the provided function. Returns a Boolean value.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst hasEven = numbers.some(num =&gt; num % 2 === 0);\nconsole.log(hasEven); // true\n</code></pre> <p>Tests whether all elements in the array pass the test implemented by the provided function. Returns a Boolean value.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst allEven = numbers.every(num =&gt; num % 2 === 0);\nconsole.log(allEven); // false\n</code></pre> <p>Returns the value of the first element in the array that satisfies the provided testing function. Otherwise undefined is returned.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst firstEven = numbers.find(num =&gt; num % 2 === 0);\nconsole.log(firstEven); // 2\n</code></pre> <p>Returns the index of the first element in the array that satisfies the provided testing function. Otherwise, -1 is returned.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst firstEvenIndex = numbers.findIndex(num =&gt; num % 2 === 0);\nconsole.log(firstEvenIndex); // 1\n</code></pre> <p>Sorts the elements of an array in place and returns the sorted array.</p> <pre><code>const numbers = [4, 2, 3, 1];\nnumbers.sort((a, b) =&gt; a - b);\nconsole.log(numbers); // [1, 2, 3, 4]\n</code></pre> <p>Merges two or more arrays. This method does not change the existing arrays, but instead returns a new array.</p> <pre><code>const array1 = [1, 2];\nconst array2 = [3, 4];\nconst combined = array1.concat(array2);\nconsole.log(combined); // [1, 2, 3, 4]\n</code></pre> <p>These functions are \"higher-order\" because they operate on other functions, either by receiving them as arguments or by returning them.</p> what is high order function in javascript? why it is called hof? why do we need them. when does the hof comes in javascript? explain me in depth <p>A higher-order function (HOF) in JavaScript is a function that either takes one or more functions as arguments, returns a function as its result, or both. Higher-order functions are a key feature in functional programming, allowing for more flexible and reusable code.</p> <p>Why It's Called HOF</p> <p>The term \"higher-order\" comes from mathematics, where functions that operate on other functions are called higher-order functions. This terminology has been adopted in programming to describe functions that can take other functions as parameters or return functions as results.</p> <p>Why We Need Higher-Order Functions</p> <ul> <li> <p>Abstraction: Higher-order functions allow for abstraction of actions, not just values. They enable you to create more generic and reusable code by encapsulating behavior that can be varied.</p> </li> <li> <p>Code Reusability: By using HOFs, you can write more generic functions that can be reused with different behaviors, leading to less code duplication.</p> </li> <li> <p>Functional Programming: They are a cornerstone of functional programming, promoting a declarative coding style. This can make code more readable and maintainable.</p> </li> <li> <p>Composability: HOFs enable function composition, which is a way to build complex functions by combining simpler ones.</p> </li> </ul> <p>Examples of Higher-Order Functions</p> Functions as Arguments:Functions as Return Values:Both: <pre><code>function filter(array, test) {\n    let passed = [];\n    for (let element of array) {\n        if (test(element)) {\n            passed.push(element);\n        }\n    }\n    return passed;\n}\n\nconst isEven = n =&gt; n % 2 === 0;\nconst numbers = [1, 2, 3, 4, 5, 6];\nconsole.log(filter(numbers, isEven)); // [2, 4, 6]\n</code></pre> <pre><code>function createMultiplier(multiplier) {\n    return function(x) {\n        return x * multiplier;\n    };\n}\n\nconst double = createMultiplier(2);\nconsole.log(double(5)); // 10\n</code></pre> <pre><code>function repeat(n, action) {\n    for (let i = 0; i &lt; n; i++) {\n        action(i);\n    }\n}\n\nrepeat(3, console.log);\n// Output:\n// 0\n// 1\n// 2\n</code></pre> <p>Common JavaScript Higher-Order Functions</p> <ol> <li> <p>Array.prototype.map():</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst doubled = numbers.map(n =&gt; n * 2);\nconsole.log(doubled); // [2, 4, 6, 8]\n</code></pre> </li> <li> <p>Array.prototype.filter():</p> <pre><code>const numbers = [1, 2, 3, 4, 5];\nconst evens = numbers.filter(n =&gt; n % 2 === 0);\nconsole.log(evens); // [2, 4]\n</code></pre> </li> <li> <p>Array.prototype.reduce():</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst sum = numbers.reduce((acc, n) =&gt; acc + n, 0);\nconsole.log(sum); // 10\n</code></pre> </li> </ol> <p>When Do HOFs Come in JavaScript?</p> <p>HOFs come into play in various scenarios:</p> <ul> <li>Array Operations: Functions like <code>map</code>, <code>filter</code>, <code>reduce</code>, and <code>forEach</code> are higher-order functions that operate on arrays.</li> <li>Event Handling: Functions like <code>addEventListener</code> in the browser API take a callback function to be executed when an event occurs.</li> <li>Asynchronous Programming: Functions like <code>setTimeout</code>, <code>setInterval</code>, and <code>promises</code> use callbacks to handle asynchronous operations.</li> </ul> <p>Conclusion</p> <p>Higher-order functions are a powerful feature in JavaScript that allows for more flexible, reusable, and composable code. They enable a functional programming approach, promoting a declarative coding style and making complex operations more manageable. Understanding and using HOFs can greatly enhance your ability to write clean and efficient JavaScript code.</p> higher-order functions can be applied in various contexts beyond array operations? <ol> <li> <p>Event Handling</p> <p>Higher-order functions are widely used in event handling in web development.</p> <pre><code>document.getElementById(\"myButton\").addEventListener(\"click\", function() {\n    alert(\"Button was clicked!\");\n});\n</code></pre> <p>In this example, <code>addEventListener</code> is a higher-order function that takes another function (the event handler) as an argument.</p> </li> <li> <p>Asynchronous Programming</p> <p>Higher-order functions are crucial in asynchronous programming with <code>callbacks</code>, <code>promises</code>, and <code>async/await</code>.</p> Callbacks<pre><code>function fetchData(callback) {\n    setTimeout(() =&gt; {\n        const data = { name: \"John\", age: 30 };\n        callback(data);\n    }, 1000);\n}\n\nfetchData(function(data) {\n    console.log(data);\n});\n</code></pre> Promises<pre><code>function fetchData() {\n    return new Promise((resolve, reject) =&gt; {\n        setTimeout(() =&gt; {\n        const data = { name: \"John\", age: 30 };\n        resolve(data);\n        }, 1000);\n    });\n}\n\nfetchData().then(data =&gt; {\n    console.log(data);\n});\n</code></pre> </li> <li> <p>Function Composition</p> <p>Higher-order functions are used to compose functions.</p> <pre><code>const add = x =&gt; x + 1;\nconst multiply = x =&gt; x * 2;\n\nconst compose = (f, g) =&gt; x =&gt; f(g(x));\n\nconst addThenMultiply = compose(multiply, add);\n\nconsole.log(addThenMultiply(5)); // 12\n</code></pre> </li> <li> <p>Middleware</p> <p>In frameworks like <code>Express.js</code>, middleware functions are higher-order functions that process HTTP requests and responses.</p> <pre><code>const express = require(\"express\");\nconst app = express();\n\napp.use((req, res, next) =&gt; {\n    console.log(\"Middleware function\");\n    next();\n});\n\napp.get(\"/\", (req, res) =&gt; {\n    res.send(\"Hello World\");\n});\n\napp.listen(3000);\n</code></pre> </li> <li> <p>Currying</p> <p>Currying transforms a function with multiple arguments into a sequence of functions each with a single argument.</p> <pre><code>const multiply = a =&gt; b =&gt; a * b;\nconst double = multiply(2);\nconsole.log(double(5)); // 10\n</code></pre> </li> </ol> <p>Conclusion</p> <p>Higher-order functions in JavaScript are versatile and can be applied in various contexts, including but not limited to array operations. They play a significant role in event handling, asynchronous programming, function composition, middleware, and more. Understanding how to use higher-order functions effectively can greatly enhance your programming skills and enable you to write more flexible and reusable code.</p> does high order function used in object? <p>Yes, higher-order functions can be used with objects in JavaScript. While they are often associated with arrays due to methods like <code>map</code>, <code>filter</code>, and <code>reduce</code>, higher-order functions can operate on objects and be used in various object-oriented programming scenarios. Here are some examples to illustrate how higher-order functions can be used with objects:</p> <p>1. Iterating Over Object Properties</p> <p>You can create higher-order functions to iterate over an object's properties.</p> Mapping Over Object Properties<pre><code>const mapObject = (obj, fn) =&gt; {\n    const result = {};\n    for (const [key, value] of Object.entries(obj)) {\n        result[key] = fn(value);\n    }\n    return result;\n};\n\nconst user = { name: \"Alice\", age: 25, country: \"USA\" };\nconst upperCasedUser = mapObject(user, val =&gt; val.toString().toUpperCase());\nconsole.log(upperCasedUser); \n// { name: \"ALICE\", age: \"25\", country: \"USA\" }\n</code></pre> <p>2. Object Methods as Higher-Order Functions</p> <p>Objects can have methods that accept functions as arguments or return functions.</p> Configurable Logger<pre><code>const logger = {\n    log: (message) =&gt; console.log(`LOG: ${message}`),\n    error: (message) =&gt; console.error(`ERROR: ${message}`),\n    withPrefix: function(prefix) {\n        return (message) =&gt; this.log(`${prefix} ${message}`);\n    }\n};\n\nconst prefixedLogger = logger.withPrefix(\"Prefix\");\nprefixedLogger(\"This is a message.\"); \n// LOG: Prefix This is a message.\n</code></pre> <p>3. Functional Programming with Objects</p> <p>You can use higher-order functions to manipulate objects in a functional programming style.</p> Object Transformation<pre><code>const transformObject = (obj, transformFn) =&gt; {\n    return Object.keys(obj).reduce((acc, key) =&gt; {\n        acc[key] = transformFn(obj[key]);\n        return acc;\n    }, {});\n};\n\nconst user = { name: \"Alice\", age: 25, country: \"USA\" };\nconst doubledAgesUser = transformObject(user, val =&gt; typeof val === 'number' ? val * 2 : val);\nconsole.log(doubledAgesUser); \n// { name: \"Alice\", age: 50, country: \"USA\" }\n</code></pre> <p>4. Creating Fluent APIs</p> <p>Higher-order functions can help create fluent APIs, where methods can be chained together.</p> Fluent API for Object Manipulation<pre><code>const user = {\n    name: \"Alice\",\n    age: 25,\n    setName: function(newName) {\n        this.name = newName;\n        return this;\n    },\n    setAge: function(newAge) {\n        this.age = newAge;\n        return this;\n    }\n};\n\nconst updatedUser = user.setName(\"Bob\").setAge(30);\nconsole.log(updatedUser); \n// { name: \"Bob\", age: 30, setName: [Function], setAge: [Function] }\n</code></pre> <p>Conclusion</p> <p>Higher-order functions are not limited to arrays and can be effectively used with objects in JavaScript. They enable powerful patterns for iterating over object properties, transforming objects, creating methods that accept or return functions, and building fluent APIs. Understanding how to apply higher-order functions to objects can help you write more flexible, reusable, and expressive code.</p> Example <p>In JavaScript, a higher-order function is a function that either takes one or more functions as arguments or returns a function as a result. This allows for more abstract and flexible code.</p> <p>Here's a simple mathematical example using higher-order functions in JavaScript:</p> <p>Example 1: Function that multiplies numbers by a given factor</p> <p>We'll create a higher-order function called <code>createMultiplier</code> that takes a number as an argument and returns a new function. This returned function will multiply its input by the given number.</p> <pre><code>// Higher-order function\nfunction createMultiplier(factor) {\n    // Returning a new function\n    return function(number) {\n        return number * factor;\n    };\n}\n\n// Using the higher-order function to create multiplier functions\nconst double = createMultiplier(2);\nconst triple = createMultiplier(3);\n\n// Testing the created functions\nconsole.log(double(5)); // Output: 10\nconsole.log(triple(5)); // Output: 15\n</code></pre> <p>Explanation</p> <ul> <li>Higher-Order Function: <code>createMultiplier</code> is a higher-order function because it takes a number (<code>factor</code>) as an argument and returns a new function.</li> <li>Returned Function: The returned function takes another number (<code>number</code>) as an argument and multiplies it by the <code>factor</code>.</li> <li>Usage: We use <code>createMultiplier</code> to create two new functions: <code>double</code> (which multiplies by 2) and <code>triple</code> (which multiplies by 3).</li> <li>Testing: When we call <code>double(5)</code>, it returns <code>10</code> (because 5\u00d72=10). When we call <code>triple(5)</code>, it returns <code>15</code> (because 5\u00d73=15).</li> </ul> <p>Another Example: Function Composition</p> <p>Here's another mathematical example using higher-order functions for function composition:</p> <pre><code>// Higher-order function for function composition\nfunction compose(f, g) {\n    // Returning a new function\n    return function(x) {\n        return f(g(x));\n    };\n}\n\n// Simple mathematical functions\nfunction add2(x) {\n    return x + 2;\n}\n\nfunction square(x) {\n    return x * x;\n}\n\n// Using the compose function\nconst add2AndSquare = compose(square, add2);\n\n// Testing the composed function\nconsole.log(add2AndSquare(3)); // Output: 25\n</code></pre> <p>Explanation</p> <ul> <li>Higher-Order Function: <code>compose</code> is a higher-order function because it takes two functions (<code>f</code> and <code>g</code>) as arguments and returns a new function.</li> <li>Returned Function: The returned function takes a number (<code>x</code>) as an argument and applies <code>g</code> to <code>x</code>, then applies <code>f</code> to the result of <code>g(x)</code>.</li> <li>Simple Functions: <code>add2</code> adds 2 to its input, and <code>square</code> squares its input.</li> <li>Usage: We use <code>compose</code> to create a new function <code>add2AndSquare</code> which first adds 2 to the input and then squares the result.</li> <li>Testing: When we call <code>add2AndSquare(3)</code>, it returns <code>25</code> (because (3+2)\u00d7(3+2)=5\u00d75=25).</li> </ul> <p>Higher-order functions are powerful tools in functional programming, allowing you to create more flexible and reusable code by abstracting common patterns.</p> Warning <p>The two functions you've provided are quite different in both their structure and their behavior. Let's break down the differences:</p> <p>First Function: Higher-Order Function</p> <pre><code>function createMultiplier(factor) {\n    // Returning a new function\n    return function(number) {\n        return number * factor;\n    };\n}\n</code></pre> <p>Explanation:</p> <ul> <li>Higher-Order Function: This function is a higher-order function because it returns a new function.</li> <li>Returned Function: The returned function takes an argument <code>number</code> and multiplies it by factor.</li> <li>Usage: You can use this function to create specific multiplier functions that can be used multiple times with different inputs.</li> </ul> Example Usage<pre><code>const double = createMultiplier(2);\nconst triple = createMultiplier(3);\n\nconsole.log(double(5)); // Output: 10\nconsole.log(triple(5)); // Output: 15\n</code></pre> <p>Second Function: Simple Multiplication</p> <pre><code>function createMultiplier(factor) {\n    return factor * factor;\n}\n</code></pre> <p>Explanation:</p> <ul> <li>Simple Function: This function is not a higher-order function. It simply multiplies the <code>factor</code> by itself and returns the result.</li> <li>Immediate Result: The function returns the result of <code>factor * factor</code> immediately without returning another function.</li> <li>Usage: You use this function to get the square of a number.</li> </ul> Example Usage<pre><code>console.log(createMultiplier(2)); // Output: 4\nconsole.log(createMultiplier(3)); // Output: 9\n</code></pre> Differences: <ol> <li> <p>Function Type:</p> <ul> <li>First Function: A higher-order function that returns a new function.</li> <li>Second Function: A simple function that performs a calculation and returns the result immediately.</li> </ul> </li> <li> <p>Purpose:</p> <ul> <li>First Function: Designed to create and return a multiplier function that can be used to multiply different numbers by a specific factor.</li> <li>Second Function: Designed to return the square of the given factor.</li> </ul> </li> <li> <p>Usage:</p> <ul> <li>First Function: Can be used to create specific multiplier functions (e.g., doubling, tripling).</li> <li>Second Function: Can only be used to calculate the square of the given factor.</li> </ul> </li> </ol> <p>Summary:</p> <ul> <li>The first function (<code>createMultiplier(factor) { return function(number) { return number * factor; }; }</code>) is a higher-order function that returns a new function capable of multiplying a number by the specified factor.</li> <li>The second function (<code>createMultiplier(factor) { return factor * factor; }</code>) is a simple function that returns the square of the given factor.</li> </ul> <p>Each function serves a different purpose and is used in different contexts. The higher-order function is more flexible and can create various multiplier functions, while the simple function is limited to calculating the square of the input factor.</p>"},{"location":"js/core/high-order-function/#finale-example","title":"FINALE EXAMPLE","text":"javascript<pre><code>function createMultiplier(factor) {\n    // Returning a new function\n    return function(number) {\n        return number * factor;\n    };\n}\nconst double = createMultiplier(2);\nconsole.log(double(5));\n</code></pre>"},{"location":"js/core/high-order-function/#lets-clarify-where-5-and-2-fit-in","title":"Let's clarify where 5 and 2 fit in:","text":"<ul> <li> <p>Factor (<code>factor</code>): When you call <code>createMultiplier(2)</code>, <code>2</code> is passed as an argument to <code>createMultiplier</code>, which assigns it to the parameter <code>factor</code>. So, <code>factor</code> becomes <code>2</code> within the scope of the returned function.</p> </li> <li> <p>Number (<code>number</code>): When you call <code>double(5)</code>, <code>5</code> is passed as an argument to double, which is actually the function returned by <code>createMultiplier(2)</code>. Inside this function, <code>number</code> refers to <code>5</code> in this particular call.</p> </li> </ul>"},{"location":"js/core/instance-and-static-methods/","title":"Instance & Static Methods","text":""},{"location":"js/core/instance-and-static-methods/#instance-methods","title":"Instance Methods","text":"<p>What They Do:</p> <ul> <li>Require an Instance: These methods operate on instances of the class. To use them, you first need to create an instance (object) of that class.</li> <li>Example: If you have a <code>Person</code> class with an instance method <code>greet()</code>, you need to create a <code>Person</code> object to call <code>greet()</code>.</li> </ul> <p>How to Use:</p> <ul> <li> <p>Syntax: Call these methods on an instance created with the new keyword.</p> </li> <li> <p>Example:</p> <pre><code>class Person {\n    constructor(name) {\n        this.name = name;\n    }\n\n    greet() {\n        console.log(`Hello, my name is ${this.name}.`);\n    }\n}\n\nconst alice = new Person('Alice'); // Creating an instance\nalice.greet(); // Calling the instance method\n</code></pre> <p>Explanation: <code>greet()</code> is an instance method. You must create a <code>Person</code> object (<code>alice</code>) before calling <code>greet()</code>.</p> </li> </ul>"},{"location":"js/core/instance-and-static-methods/#static-methods","title":"Static Methods","text":"<p>What They Do:</p> <ul> <li>Class-Level Functions: These methods belong to the class itself rather than to any particular instance.</li> <li>Example: If you have a <code>MathHelper</code> class with a static method <code>add()</code>, you call <code>add()</code> directly on the class, not on an instance.</li> </ul> <p>How to Use:</p> <ul> <li> <p>Syntax: Call these methods directly on the class.</p> </li> <li> <p>Example:</p> <pre><code>class MathHelper {\n    static add(x, y) {\n        return x + y;\n    }\n}\n\nconsole.log(MathHelper.add(5, 3)); // Calling the static method on the class\n</code></pre> <p>Explanation: <code>add()</code> is a static method. You can call it directly on the <code>MathHelper</code> class without creating an instance.</p> </li> </ul>"},{"location":"js/core/instance-and-static-methods/#summary","title":"Summary","text":"<p>Instance Methods:</p> <ul> <li>Need an Instance: Methods defined inside the class (not static) need an object created with new to be used.</li> <li>Use Case: They operate on data specific to an instance.</li> </ul> <p>Static Methods:</p> <ul> <li>No Instance Needed: You can call them directly on the class itself.</li> <li>Use Case: They provide utility functions or class-level operations.</li> </ul> Mnemonic for Remembering <ul> <li>Instance Methods: \"I Need an Instance\" - You need to create an instance to use these methods.</li> <li>Static Methods: \"Solely on the Class\" - You use these methods directly on the class, without creating an instance.</li> </ul> <p>By using these mnemonics, you can easily remember the difference between instance methods and static methods and know when and how to use each.</p>"},{"location":"js/core/js-exception-handling/","title":"Exception Handling","text":"<p>In JavaScript, the throw new Error(errorMessage); statement does not display the error on the web by itself. Instead, it creates an Error object with the provided errorMessage and then throws that error. This error will be caught by the nearest catch block in a try...catch structure.</p> Here\u2019s a breakdown of how it works: <ol> <li> <p>Error Creation and Throwing:</p> <ul> <li><code>throw new Error(errorMessage)</code>; creates a new <code>Error</code> object with the specified errorMessage.</li> <li>The <code>throw</code> statement then throws this Error object, which immediately exits the current function and passes the error to the nearest <code>catch</code> block.</li> </ul> </li> <li> <p>Error Handling in <code>catch</code>:</p> <ul> <li>If there is a <code>catch</code> block that matches this <code>Error</code>, the error is caught and can be handled appropriately (e.g., logging the error, dispatching an error action, displaying an error message to the user).</li> </ul> </li> <li> <p>Error Display on the Web:</p> <ul> <li>To show an error message to the user, you must explicitly handle and display it. This usually involves:<ul> <li>Catching the error and then displaying a message in the UI.</li> <li>Using a library or UI component to show user-friendly error messages (e.g., alert, modal, or notification).</li> </ul> </li> </ul> </li> </ol> <pre><code>// Action creator with error handling\nexport const actionForUpdateDailyDairy = (id, body) =&gt; {\n    return async(dispatch) =&gt; {\n        dispatch(init(DAILY_DAIRY.UPDATE_DAILY_DIARY));\n\n        try {\n            const response = await dailyDairyService.apiForDailyDiaryUpdate(id, body);\n            if(response.isSuccess) {\n                dispatch(success(DAILY_DAIRY.UPDATE_DAILY_DIARY, response.data));\n                return response.data;\n            } else {\n                const errorMessage = response.errorMessage || 'Unknown error occurred during the update';\n                dispatch(error(errorMessage));\n                throw new Error(errorMessage); // Throwing error to be caught by catch block\n            }\n        } catch (err) {\n            // Handling the error\n            const errorMessage = err.message || 'Unknown error occurred';\n            dispatch(error(errorMessage));\n            // Optionally show the error message in the UI\n            // e.g., displayNotification(errorMessage);\n        } finally {\n            dispatch(finish(DAILY_DAIRY.UPDATE_DAILY_DIARY));\n        }\n    }\n}\n</code></pre> Points to Note: <ol> <li> <p>Error Propagation:</p> <ul> <li>The error thrown is caught by the <code>catch</code> block, where you can handle it (e.g., dispatch an error action to update the UI).</li> </ul> </li> <li> <p>UI Error Display:</p> <ul> <li>To display an error message on the web, ensure that your <code>catch</code> block (or the part of the application handling errors) updates the UI or shows a message to the user.</li> </ul> </li> <li> <p>No Automatic Display:</p> <ul> <li>JavaScript does not automatically display error messages. You need to implement a mechanism to display errors if needed.</li> </ul> </li> </ol> <p>By correctly handling errors in the <code>catch</code> block, you can manage how errors are propagated and displayed in your application.</p> <p>Mastering JavaScript exception handling involves understanding how errors work, effectively using error-handling mechanisms, and implementing best practices to ensure robust and user-friendly applications. Here\u2019s a comprehensive guide to help you master JavaScript exception handling:</p> <ol> <li> <p>Understanding JavaScript Errors</p> <p>JavaScript errors are instances of the Error class and its subclasses:</p> <ul> <li>Error: Base class for all errors.</li> <li>TypeError: Indicates an operation was performed on a value of the wrong type.</li> <li>ReferenceError: Indicates a reference to an undefined variable.</li> <li>SyntaxError: Indicates a syntax mistake in code.</li> <li>RangeError: Indicates a value is out of range.</li> <li>EvalError: Indicates an error with the <code>eval()</code> function (rarely used).</li> </ul> </li> <li> <p>Basic Exception Handling</p> <p>Use <code>try...catch</code> blocks to handle exceptions:</p> <pre><code>try {\n    // Code that may throw an error\n    let result = riskyOperation();\n} catch (error) {\n    // Handle the error\n    console.error('Error occurred:', error.message);\n} finally {\n    // Code that always executes\n    console.log('Cleanup code');\n}\n</code></pre> <ul> <li>try: Contains code that might throw an error.</li> <li>catch: Handles the error if one occurs.</li> <li>finally: Executes code regardless of whether an error occurred.</li> </ul> </li> <li> <p>Throwing Errors</p> <p>You can throw your own errors using <code>throw</code>:</p> <pre><code>function validate(value) {\n    if (value &lt; 0) {\n        throw new RangeError('Value must be non-negative');\n    }\n    return value;\n}\n</code></pre> </li> <li> <p>Custom Error Classes</p> <p>Create custom error classes to represent specific error conditions:</p> <pre><code>class CustomError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = 'CustomError';\n    }\n}\n\nfunction doSomething() {\n    throw new CustomError('Something went wrong');\n}\n</code></pre> </li> </ol> Best Practices <ul> <li>Avoid Silent Failures: Always handle errors to avoid silent failures that can lead to unexpected behavior.</li> <li>Use Specific Errors: Throw specific error types where applicable to make debugging easier.</li> <li>Avoid Overuse of <code>try...catch</code>: Only use <code>try...catch</code> where necessary, as overuse can obscure issues.</li> </ul>"},{"location":"js/core/js-exception-handling/#reducer","title":"REDUCER","text":""},{"location":"js/core/js-exception-handling/#function","title":"FUNCTION","text":""},{"location":"js/core/js-exception-handling/#question-1","title":"Question 1:","text":"Question <pre><code>const handleTodaySaveDiary = () =&gt; {\n    console.log(\"data.items\", data.items);\n}\n\n&lt;Content\n    style={{\n        display: \"flex\",\n        justifyContent: \"end\",\n        paddingTop: \"8px\",\n    }}\n&gt;\n{!loading &amp;&amp; data != null &amp;&amp; !isEmpty(data.items) &amp;&amp; (\n    &lt;Button\n        type=\"primary\"\n        // disabled\n        // loading={loading}\n        onClick={handleTodaySaveDiary}\n        style={{\n            padding: \"0px 10px\"\n        }}\n    &gt;\n        Save\n    &lt;/Button&gt;\n)}\n&lt;/Content&gt;\n\n&lt;Modal\n    title=\"Basic Modal\"\n    visible={isModalOpen}\n    onOk={handleOk}\n    onCancel={handleCancel}\n    fotter={null}\n&gt;\n    &lt;Form\n        form={formToday}\n    &gt;\n        Today Form\n    &lt;/Form&gt;\n&lt;/Modal&gt;\n\n\n// data.items value\n\n{\n    \"totalCount\": 2,\n    \"items\": [\n    {\n        \"id\": \"5a618cd6-53d8-4d49-b0b9-23f1ef72a395\",\n        \"todoEventId\": \"cafba611-b13b-4881-8639-b7715257a430\",\n        \"dailyDairyDate\": \"2024-08-15T12:07:48.1704016\",\n        \"stutusId\": \"4de2c2e9-aed1-4b28-bec0-6e52ab148f87\",\n        \"statusName\": \"Start\",\n        \"userId\": \"73fc9457-6b63-6a4a-64de-39f960722731\",\n        \"userName\": \"admin_bbask\",\n        \"title\": \"OS\",\n        \"remarks\": \"KHALAS xcccpp\",\n        \"isActive\": true,\n        \"statusDto\": {\n        \"id\": \"4de2c2e9-aed1-4b28-bec0-6e52ab148f87\",\n        \"name\": \"Start\",\n        \"colorHexValue\": \"#6a71ad\",\n        \"colorFontHexValue\": \"#ffffff\"\n        }\n    },\n    {\n        \"id\": \"84970e8e-2d55-4703-b4a8-ce118cd2a363\",\n        \"todoEventId\": \"f83a16b1-3931-4b0f-b2ea-59a123e4b2af\",\n        \"dailyDairyDate\": \"2024-08-15T09:34:31.976906\",\n        \"stutusId\": \"6a4a2e83-c05a-4134-999b-fd211a546e86\",\n        \"statusName\": \"Completed\",\n        \"userId\": \"73fc9457-6b63-6a4a-64de-39f960722731\",\n        \"userName\": \"admin_bbask\",\n        \"title\": \"NEW TASK TODAY\",\n        \"remarks\": \"fsfafsdfdsfasdf  jkhjk sadfjasdfb sadasdf\\ndsds\",\n        \"isActive\": true,\n        \"statusDto\": {\n        \"id\": \"6a4a2e83-c05a-4134-999b-fd211a546e86\",\n        \"name\": \"Completed\",\n        \"colorHexValue\": \"#cbce91\",\n        \"colorFontHexValue\": \"#ffffff\"\n        }\n    }\n    ]\n}\n</code></pre> <p>Scenario: after click the handleTodaySaveDiary button if the data.items contains object which statusName is not Completed then open the modal and list the title and remarks description box to submit. if all the statusName is completed then donot open the modal.</p>"},{"location":"js/core/js-exception-handling/#solution-1","title":"SOLUTION 1:","text":"Question <p>To ensure that <code>handleAddUpdateDairy()</code> is only called if <code>actionForUpdateDailyDairy</code> completes successfully, you need to adjust your <code>handleOnFinish</code> function to properly handle errors from the asynchronous action. Currently, <code>handleAddUpdateDairy()</code> is called unconditionally after dispatching <code>actionForUpdateDailyDairy</code>, so you should modify the function to wait for <code>actionForUpdateDailyDairy</code> to complete and handle errors properly.</p> <p>Here's how you can adjust the handleOnFinish function:</p> <ol> <li> <p>Use <code>await</code> for asynchronous operations: Since <code>dispatch</code> is returning a promise, you should await the result of <code>dispatch(actionForUpdateDailyDairy(selectedRecordData?.id, body))</code> to handle errors effectively.</p> </li> <li> <p>Check the result of dispatch before calling <code>handleAddUpdateDairy()</code>: Only call <code>handleAddUpdateDairy()</code> if the update action was successful.</p> </li> </ol> <p>Here's the updated handleOnFinish function:</p> <pre><code>const handleOnFinish = async (values) =&gt; {\n    let body = {\n        statusId: values?.todoEventStatusId,\n        remarks: values?.remarks\n    };\n\n    try {\n        // Ensure dispatch returns a promise to await it\n        const result = await dispatch(actionForUpdateDailyDairy(selectedRecordData?.id, body));\n\n        // If the result was successful, proceed with handleAddUpdateDairy\n        if (result) {\n            handleAddUpdateDairy();\n        }\n    } catch (err) {\n        console.log(\"Error: \", err);\n    }\n}\n</code></pre> Explanation <ol> <li> <p>Await Dispatch: The <code>await dispatch(actionForUpdateDailyDairy(selectedRecordData?.id, body))</code> will pause execution until <code>actionForUpdateDailyDairy</code> has finished, allowing you to catch any errors that might be thrown during the dispatch.</p> </li> <li> <p>Conditional Call: <code>handleAddUpdateDairy()</code> is only called if the result from <code>actionForUpdateDailyDairy</code> indicates success. You may need to adjust the <code>actionForUpdateDailyDairy</code> action to ensure it returns a result that you can check, such as a boolean indicating success.</p> </li> <li> <p>Error Handling: The catch block will handle any errors thrown during the dispatch or the async operation itself.</p> </li> </ol> Important Note <p>Make sure that <code>actionForUpdateDailyDairy</code>'s promise resolves with a value you can check. If the action creator does not currently return a meaningful result, you might need to adjust it so that it does. For example, you could modify <code>actionForUpdateDailyDairy</code> to return <code>response.data</code> only when the operation is successful, and ensure that the error handling logic is correctly implemented.</p>"},{"location":"js/core/js-exception-handling/#solution-2","title":"SOLUTION 2:","text":"<p>To update your <code>handleOnFinish</code> function so that <code>handleAddUpdateDairy</code> is only called if there is no error in <code>actionForUpdateDailyDairy</code>, you'll need to handle the asynchronous nature of <code>dispatch</code>. You should await the result of <code>dispatch</code> and check for errors before proceeding. Here\u2019s how you can modify your code:</p> Updated handleOnFinish Function<pre><code>const handleOnFinish = async (values) =&gt; {\n    let body = {\n        statusId: values?.todoEventStatusId,\n        remarks: values?.remarks\n    };\n\n    try {\n        if (values?.todoEventStatusId) {\n            // Await the dispatch to ensure completion\n            await dispatch(actionForUpdateDailyDairy(selectedRecordData?.id, body));\n        }\n\n        // Only call handleAddUpdateDairy if dispatch was successful\n        handleAddUpdateDairy();\n    } catch (err) {\n        // Log error and handle it appropriately\n        console.log(\"Error: \", err);\n        // Optionally handle or display the error to the user\n    }\n};\n</code></pre> Explanation: <ol> <li> <p>Await Dispatch: The <code>await dispatch(actionForUpdateDailyDairy(selectedRecordData?.id, body))</code>; line ensures that you wait for the asynchronous action to complete. This means <code>handleAddUpdateDairy()</code> will only be called after <code>actionForUpdateDailyDairy</code> has finished.</p> </li> <li> <p>Conditional Call: <code>handleAddUpdateDairy()</code> is called after the <code>dispatch</code> promise resolves successfully. If <code>dispatch</code> throws an error or fails, the catch block will handle it, and <code>handleAddUpdateDairy()</code> will not be executed.</p> </li> <li> <p>Error Handling: The <code>catch</code> block catches any errors thrown during the dispatch process. You can log or handle these errors as needed.</p> </li> </ol> Additional Considerations: <ul> <li> <p>Action Return Values: Ensure that <code>actionForUpdateDailyDairy</code> is set up to correctly handle and throw errors if necessary. The action creator should be designed to handle success and failure cases.</p> </li> <li> <p>User Feedback: Depending on your UI needs, you might want to provide feedback to the user if an error occurs. This can be done using a UI library or custom error messaging.</p> </li> </ul> <p>With this approach, your code will properly handle the asynchronous operation and ensure that subsequent actions are only taken if the update is successful.</p>"},{"location":"js/core/js-exception-handling/#example","title":"Example","text":""},{"location":"js/core/js-exception-handling/#question-2","title":"Question 2:","text":"<ul> <li><code>onClick={handleTodaySaveDiary}</code>: Directly assigns the function to the <code>onClick</code> event, so it will be called when the button is clicked.</li> <li><code>onClick={() =&gt; handleTodaySaveDiary()}</code>: Uses an arrow function to call <code>handleTodaySaveDiary()</code> when the button is clicked. This is useful if you need to perform additional logic in the future.</li> </ul>"},{"location":"js/core/js-exception-handling/#button-code-snippit-example","title":"Button Code Snippit Example","text":"Example <pre><code>{!loading &amp;&amp; data != null &amp;&amp; !isEmpty(data.items) &amp;&amp; (\n    &lt;Button\n        type=\"primary\"\n        loading={loading}\n        onClick={() =&gt; console.log(\"hello world\", data?.items)}\n        style={{\n            padding: \"0px 10px\"\n        }}\n    &gt;\n        Save\n    &lt;/Button&gt;\n)}\n\n// or\n\n&lt;Button\n    // disabled\n    type=\"primary\"\n    loading={loading}\n    onClick={() =&gt; console.log(\"hello world\", data?.items)}\n    style={{\n        padding: \"0px 10px\"\n    }}\n&gt;\n    Save\n&lt;/Button&gt;\n</code></pre>"},{"location":"js/core/js-exception-handling/#use-content-for-layout","title":"use <code>Content</code> for Layout","text":"Note <pre><code>import { Layout } from \"antd\";\n\nconst { Content } = Layout;\n\n&lt;Content\n    style={{\n        display: \"flex\",\n        justifyContent: \"end\",\n        paddingTop: \"8px\",\n    }}\n&gt;\n    &lt;Button\n        // disabled\n        type=\"primary\"\n        loading={loading}\n        onClick={() =&gt; console.log(\"hello world\", data?.items)}\n        style={{\n            padding: \"0px 10px\"\n        }}\n    &gt;\n        Save\n    &lt;/Button&gt;\n&lt;/Content&gt;\n</code></pre>"},{"location":"js/core/js-exception-handling/#office-solve","title":"Office Solve","text":""},{"location":"js/core/js-exception-handling/#question-1_1","title":"Question 1","text":"Example CodeExplanationModified <p>To implement this scenario, you can filter data.items based on the statusName. If there are any items with statusName not equal to \"Completed\", the modal will open; otherwise, it will remain closed.</p> <p>Here's how you can achieve this:</p> Updated Code:<pre><code>const handleTodaySaveDiary = () =&gt; {\n    const incompleteItems = data.items.filter(item =&gt; item.statusName !== \"Completed\");\n\n    // Log items that are not completed\n    console.log(\"Incomplete Items:\", incompleteItems);\n\n    if (incompleteItems.length &gt; 0) {\n        // Open the modal\n        setIsModalOpen(true);\n    } else {\n        // All items are completed, do not open the modal\n        console.log(\"All items are completed, no modal needed\");\n    }\n};\n\n&lt;Content\n    style={{\n        display: \"flex\",\n        justifyContent: \"end\",\n        paddingTop: \"8px\",\n    }}\n&gt;\n{!loading &amp;&amp; data != null &amp;&amp; !isEmpty(data.items) &amp;&amp; (\n    &lt;Button\n        type=\"primary\"\n        onClick={handleTodaySaveDiary}\n        style={{\n            padding: \"0px 10px\"\n        }}\n    &gt;\n        Save\n    &lt;/Button&gt;\n)}\n&lt;/Content&gt;\n\n&lt;Modal\n    title=\"Incomplete Tasks\"\n    visible={isModalOpen}\n    onOk={handleOk}\n    onCancel={handleCancel}\n    footer={null}\n&gt;\n    &lt;Form form={formToday}&gt;\n        {data.items.filter(item =&gt; item.statusName !== \"Completed\").map(item =&gt; (\n            &lt;div key={item.id}&gt;\n                &lt;h3&gt;{item.title}&lt;/h3&gt;\n                &lt;p&gt;{item.remarks}&lt;/p&gt;\n                &lt;Form.Item\n                    name={`remarks_${item.id}`}\n                    label=\"Remarks\"\n                    rules={[{ required: true, message: 'Please enter remarks' }]}\n                &gt;\n                    &lt;Input.TextArea rows={4} defaultValue={item.remarks} /&gt;\n                &lt;/Form.Item&gt;\n            &lt;/div&gt;\n        ))}\n    &lt;/Form&gt;\n&lt;/Modal&gt;\n</code></pre> <ol> <li> <p><code>handleTodaySaveDiary</code> Function:</p> <ul> <li>Filters <code>data.items</code> to find objects where <code>statusName</code> is not \"Completed\".</li> <li>If there are any such objects, it opens the modal by setting <code>setIsModalOpen(true)</code>.</li> <li>Otherwise, it logs that all items are completed and the modal doesn't open.</li> </ul> </li> <li> <p>Modal Rendering:</p> <ul> <li>Inside the modal, we map over the filtered items (those that are not completed) and display the <code>title</code> and a <code>TextArea</code> input field pre-filled with the current <code>remarks</code>.</li> </ul> </li> </ol> <p>This way, you ensure that the modal only opens when there are incomplete tasks, and it provides an interface for the user to edit the <code>remarks</code> for those tasks.</p> <pre><code>const handleOk = () =&gt; {\n    // Submit the form when Ok is clicked\n    formToday.submit();\n};\n\nconst handleCancel = () =&gt; {\n    formToday.resetFields();\n    setIsModalOpen(false);\n};\n\nconst handleOnFinishFormModal = (values) =&gt; {\n    // Log the form values on form submission\n    console.log(\"Form Values Submitted: \", values);\n\n    // Close the modal after successful submission\n    setIsModalOpen(false);\n};\n</code></pre> Explanation: <ol> <li> <p>onFinish: This function (<code>handleOnFinishFormModal</code>) will be triggered when the form is successfully submitted. The submitted form values are captured in the <code>values</code> parameter.</p> </li> <li> <p>formToday.submit(): Inside <code>handleOk()</code>, calling <code>formToday.submit()</code> ensures that the form submission is triggered when the \"Ok\" button is clicked in the modal.</p> </li> <li> <p>footer={null}: Removed the default footer of the modal to prevent the default \"Ok\" and \"Cancel\" buttons, ensuring you have full control over when the form is submitted.</p> </li> </ol> <p>With this setup, when the modal is open, and the user fills in the remarks and clicks \"Ok,\" the form values will be logged to the console, and you can handle them as needed.</p> <pre><code>if (InomplteStatusItems.length &gt; 0) {\n    // Open the modal\n    setIsModalOpen(true);\n\n    //\n    const initialFormValues = {};\n    InomplteStatusItems.forEach(item =&gt; {\n        initialFormValues[`remarks_${item.id}`] = item.remarks || '';  // Set initial remarks or empty if not available\n    });\n    formToday.setFieldsValue(initialFormValues);\n} else {\n    // All items are completed, do not open the modal\n    console.log(\"All items are completed, no modal needed\");\n}\n</code></pre>"},{"location":"js/core/js-exception-handling/#reference","title":"Reference","text":"<ul> <li>Control flow and error handling: developer.mozilla</li> <li>JavaScript Errors: w3schools</li> </ul>"},{"location":"js/core/topic/","title":"Topic","text":"<p>Mastering JavaScript requires a deep understanding of both its fundamental concepts and advanced topics. Here are some key areas to focus on, along with some hidden depths you should explore:</p>"},{"location":"js/core/topic/#core-concepts","title":"Core Concepts","text":"<ol> <li> <p>Data Types and Structures</p> <ul> <li>Primitive types and their behavior.</li> <li>Objects, arrays, and their methods.</li> <li>Map and Set objects.</li> </ul> </li> <li> <p>Functions</p> <ul> <li>Function declarations, expressions, and arrow functions.</li> <li>Scope, closures, and lexical scoping.</li> <li>Higher-order functions and callbacks.</li> <li>The <code>this</code> keyword and context binding.</li> </ul> </li> <li> <p>Asynchronous Programming</p> <ul> <li>Callbacks, promises, and async/await.</li> <li>Event loop and concurrency model.</li> <li>Error handling in asynchronous code.</li> </ul> </li> </ol>"},{"location":"js/core/topic/#advanced-topics","title":"Advanced Topics","text":"<ol> <li> <p>Prototypes and Inheritance</p> <ul> <li>Prototypal inheritance and the prototype chain.</li> <li>ES6 class syntax and how it relates to prototypes.</li> <li><code>Object.create</code> and inheritance patterns.</li> </ul> </li> <li> <p>Execution Context and Hoisting</p> <ul> <li>Execution context and the call stack.</li> <li>Variable and function hoisting.</li> <li>Temporal dead zone (TDZ) with <code>let</code> and <code>const</code>.</li> </ul> </li> <li> <p>Closures and Lexical Scope</p> <ul> <li>Understanding closures and their applications.</li> <li>Practical uses of closures in module patterns and function factories.</li> </ul> </li> <li> <p>Modules and Module Bundlers</p> <ul> <li>ES6 modules: import and export.</li> <li>Module patterns in older JavaScript (CommonJS, AMD).</li> <li>Using module bundlers like Webpack, Parcel, and Rollup.</li> </ul> </li> <li> <p>Event Handling and DOM Manipulation</p> <ul> <li>Event delegation and propagation (bubbling and capturing).</li> <li>Modern DOM APIs and manipulation techniques.</li> <li>Understanding and handling browser events.</li> </ul> </li> </ol>"},{"location":"js/core/topic/#deep-dive-topics","title":"Deep Dive Topics","text":"<ol> <li> <p>Memory Management and Performance</p> <ul> <li>Garbage collection and memory leaks.</li> <li>Optimizing performance: profiling and benchmarking.</li> <li>Understanding V8 engine optimizations.</li> </ul> </li> <li> <p>Design Patterns</p> <ul> <li>Common JavaScript design patterns (e.g., Singleton, Factory, Observer).</li> <li>Applying design patterns to real-world problems.</li> </ul> </li> <li> <p>Type Systems and Type Checking</p> <ul> <li>Dynamic vs. static typing.</li> <li>Using TypeScript for type safety.</li> <li>Flow and other type checkers.</li> </ul> </li> <li> <p>Testing</p> <ul> <li>Unit testing, integration testing, and end-to-end testing.</li> <li>Popular testing frameworks (<code>Jest</code>, <code>Mocha</code>, <code>Chai</code>, <code>Cypress</code>).</li> <li>Test-driven development (TDD) practices.</li> </ul> </li> <li> <p>Tooling and Build Processes</p> <ul> <li>Modern JavaScript tooling: ESLint, Prettier, Babel.</li> <li>Setting up and configuring build processes with tools like Webpack.</li> <li>Continuous integration and deployment (CI/CD) for JavaScript projects.</li> </ul> </li> </ol>"},{"location":"js/core/topic/#hidden-depths","title":"Hidden Depths","text":"<ol> <li> <p>Symbol and Meta-programming</p> <ul> <li>Using symbols to create unique property keys.</li> <li>Understanding well-known symbols and their uses.</li> <li>Proxy objects and the Reflect API for metaprogramming.</li> </ul> </li> <li> <p>Iterators and Generators</p> <ul> <li>Custom iterators and the iterable protocol.</li> <li>Generator functions and the yield keyword.</li> <li>Using generators for asynchronous control flow.</li> </ul> </li> <li> <p>Concurrency and Parallelism</p> <ul> <li>Web Workers for parallel processing.</li> <li>Understanding and using SharedArrayBuffer and Atomics.</li> <li>Concurrency models in JavaScript.</li> </ul> </li> <li> <p>Advanced Asynchronous Patterns</p> <ul> <li>Async iterators and generators.</li> <li>Using <code>Promise.all</code>, <code>Promise.race</code>, and <code>Promise.allSettled</code>.</li> <li>Managing complex async workflows with libraries like RxJS.</li> </ul> </li> <li> <p>Understanding the Event Loop and Microtasks</p> <ul> <li>Detailed workings of the event loop.</li> <li>Difference between macro-tasks and micro-tasks.</li> <li>Practical implications for writing efficient asynchronous code.</li> </ul> </li> </ol>"},{"location":"js/core/topic/#practical-application","title":"Practical Application","text":"<ul> <li>Building Projects: Apply what you learn by building real-world projects.</li> <li>Contributing to Open Source: Contribute to JavaScript libraries and frameworks.</li> <li>Reading and Understanding Source Code: Study the source code of popular libraries and frameworks.</li> </ul> <p>Mastering JavaScript is a journey that involves both understanding the theory and applying it in practical scenarios. By delving into these topics, you will gain a comprehensive and deep understanding of JavaScript, enabling you to write efficient, maintainable, and robust code.</p> Abstract <p>To gain a deep understanding of JavaScript, the main approach is to focus on mastering its core concepts and advanced features. Here's a structured plan to achieve that:</p> <ol> <li> <p>Fundamentals:</p> <ul> <li>Variables and Data Types: Understand var, let, const, and data types (number, string, boolean, object, undefined, null).</li> <li>Functions: Learn about function declarations, expressions, arrow functions, and IIFE (Immediately Invoked Function Expressions).</li> <li>Control Structures: Master if statements, loops (for, while, do-while), and switch statements.</li> </ul> </li> <li> <p>Advanced Concepts:</p> <ul> <li>Closures: Understand how closures work and how they enable functions to have private variables.</li> <li>Prototypes and Inheritance: Learn about prototype chains, inheritance models, and how to create objects using constructor functions and class syntax.</li> <li>Asynchronous Programming: Master callbacks, promises, async/await, and event loop mechanisms.</li> <li>Scope and Hoisting: Understand the scope (global, local, block) and hoisting behaviors in JavaScript.</li> </ul> </li> <li> <p>JavaScript in the Browser:</p> <ul> <li>DOM Manipulation: Learn how to select, traverse, and manipulate DOM elements.</li> <li>Event Handling: Understand how to handle user interactions and events.</li> <li>Browser APIs: Explore key browser APIs like fetch, localStorage, and sessionStorage.</li> </ul> </li> <li> <p>Modern JavaScript (ES6+):</p> <ul> <li>Learn new syntax and features introduced in ES6 and later versions, including template literals, destructuring, spread/rest operators, modules, and enhanced object literals.</li> </ul> </li> <li> <p>Tooling and Ecosystem:</p> <ul> <li>Node.js: Understand server-side JavaScript and how to build backend applications with Node.js.</li> <li>Build Tools: Learn about build tools like Webpack, Babel, and task runners like Gulp or Grunt.</li> <li>Testing: Master JavaScript testing frameworks like Jest, Mocha, or Jasmine.</li> </ul> </li> <li> <p>Best Practices:</p> <ul> <li>Code Organization: Learn how to write modular, maintainable, and reusable code.</li> <li>Performance Optimization: Understand techniques for optimizing JavaScript performance.</li> <li>Security: Learn common security practices to prevent vulnerabilities like XSS and CSRF.</li> </ul> </li> <li> <p>Projects and Real-world Applications:</p> <ul> <li>Build projects that challenge you to apply what you've learned.</li> <li>Contribute to open-source projects or collaborate on team projects to gain practical experience.</li> </ul> </li> </ol> <p>By systematically studying these areas, practicing through projects, and keeping up with the latest advancements in JavaScript, you'll be able to develop a deep and comprehensive understanding of the language.</p>"},{"location":"js/datatypes/data-types/","title":"Data Type","text":""},{"location":"js/datatypes/data-types/#data-types-in-js","title":"Data Types in JS","text":"<p>In JavaScript, while many things are objects, not everything is an object. JavaScript has a variety of data types, and understanding which are objects and which are not is important for grasping the language's structure.</p> <p></p>"},{"location":"js/datatypes/data-types/#javascript-data-types","title":"JavaScript Data Types","text":"<p>JavaScript has both primitive data types and objects.</p>"},{"location":"js/datatypes/data-types/#primitive-data-types","title":"Primitive Data Types","text":"<p>primitive</p> <p>Primitive data types are not objects and do not have properties or methods. They are immutable and are directly assigned and manipulated.</p> <ol> <li> <p>Number: Represents both integer and floating-point numbers.</p> <pre><code>let num = 42;\n</code></pre> </li> <li> <p>String: Represents a sequence of characters.</p> <pre><code>let str = \"Hello, world!\";\n</code></pre> </li> <li> <p>Boolean: Represents a logical entity with two values: <code>true</code> and <code>false</code>.</p> <pre><code>let bool = true;\n</code></pre> </li> <li> <p>Null: Represents the intentional absence of any object value.</p> <pre><code>let nullValue = null;\n</code></pre> </li> <li> <p>Undefined:: Represents a variable that has been declared but not assigned a value.</p> <pre><code>let undefinedValue;\n</code></pre> </li> <li> <p>Symbol: Represents a unique and immutable identifier.</p> <pre><code>let sym = Symbol('description');\n</code></pre> </li> <li> <p>BigInt: Represents integers with arbitrary precision.</p> <pre><code>let bigInt = 1234567890123456789012345678901234567890n;\n</code></pre> </li> </ol>"},{"location":"js/datatypes/data-types/#objects","title":"Objects","text":"<p>Object</p> <p>Objects are collections of properties and are more complex. <code>Arrays</code>, <code>functions</code>, and <code>objects</code> created using the Object constructor or object literals are examples of objects.</p> <ol> <li> <p>Object: General-purpose containers for named properties.</p> <pre><code>let obj = { key: 'value' };\n</code></pre> </li> <li> <p>Array: Ordered lists of values.</p> <pre><code>let arr = [1, 2, 3];\n</code></pre> </li> <li> <p>Function: Callable objects.</p> <pre><code>function func() { return 'Hello!'; }\n</code></pre> </li> <li> <p>Date: Represents dates and times.</p> <pre><code>let date = new Date();\n</code></pre> </li> <li> <p>RegExp: Represents regular expressions.</p> <pre><code>let regex = /abc/;\n</code></pre> </li> <li> <p>Map: Key-value pairs where keys can be of any type.</p> <pre><code>let map = new Map();\n</code></pre> </li> <li> <p>Set: Collections of unique values.</p> <pre><code>let set = new Set();\n</code></pre> </li> </ol> <p></p>"},{"location":"js/datatypes/data-types/#why-not-everything-is-an-object","title":"Why Not Everything is an Object","text":"<p>Primitive types are not objects because they are meant to be simple and efficient. They are stored directly in memory rather than by reference, which allows for faster access and manipulation. For example, mathematical operations on numbers or string manipulations are faster because these operations do not involve object overhead. Wrappers for Primitives</p> <p>JavaScript automatically provides temporary objects, known as wrapper objects, when methods or properties are accessed on primitive values. These objects allow primitives to behave like objects in certain contexts.</p> <pre><code>let str = \"hello\";\nconsole.log(str.toUpperCase()); // \"HELLO\"\n</code></pre> <p>In this example, <code>str</code> is a primitive string, but JavaScript temporarily wraps it in a <code>String</code> object to call the <code>toUpperCase</code> method.</p>"},{"location":"js/datatypes/data-types/#summary","title":"Summary","text":"<ul> <li>Primitive Types: <code>Number</code>, <code>String</code>, <code>Boolean</code>, <code>Null</code>, <code>Undefined</code>, <code>Symbol</code>, <code>BigInt</code>. Not objects, immutable, and have no properties or methods directly.</li> <li>Objects: More complex structures including plain <code>objects</code>, <code>arrays</code>, <code>functions</code>, etc. Have properties and methods and are stored by reference.</li> </ul> <p>While JavaScript provides a unified and flexible approach to handling various data types, understanding the distinction between primitives and objects is crucial for effective programming in JavaScript.</p> <p></p>"},{"location":"js/datatypes/data-types/#autoboxing","title":"Autoboxing","text":"<p><code>autoboxing in javascript</code></p> <p>In JavaScript, when you attempt to access a property or method on a primitive value, the language automatically wraps the primitive in a temporary object so that you can use the properties and methods that are typically available on objects. This process is known as autoboxing. Here\u2019s a detailed explanation of how this works:</p>"},{"location":"js/datatypes/data-types/#how-javascript-wraps-primitives","title":"How JavaScript Wraps Primitives","text":"<ol> <li> <p>Autoboxing: When you try to access a method or property on a primitive value, JavaScript temporarily converts (or \"boxes\") the primitive value into an object.</p> <pre><code>let str = \"hello\";\nconsole.log(str.toUpperCase()); // \"HELLO\"\n</code></pre> </li> </ol> <p>Here's what happens behind the scenes:</p> <ul> <li>JavaScript sees that you're calling <code>toUpperCase()</code> on the str variable, which is a string primitive.</li> <li>It creates a temporary <code>String</code> object from the primitive value \"hello\".</li> <li>It calls the toUpperCase method on this temporary <code>String</code> object.</li> <li>The method returns the result (\"HELLO\").</li> <li>The temporary <code>String</code> object is discarded.</li> </ul>"},{"location":"js/datatypes/data-types/#steps-involved","title":"Steps Involved","text":"<ol> <li> <p>Primitive Detection: When you try to access a property or method on a primitive value, the JavaScript engine checks the type of the value.</p> <ul> <li>If the value is a primitive type (<code>string</code>, <code>number</code>, <code>boolean</code>, <code>symbol</code>, <code>bigint</code>), the engine understands that it needs to provide access to the methods and properties that are defined on the corresponding wrapper objects (<code>String</code>, <code>Number</code>, <code>Boolean</code>, <code>Symbol</code>, <code>BigInt</code>).</li> </ul> </li> <li> <p>Temporary Object Creation: The JavaScript engine creates a temporary object of the corresponding wrapper type.</p> <ul> <li>For a string, it creates a <code>String</code> object.</li> <li>For a number, it creates a <code>Number</code> object.</li> <li>For a boolean, it creates a <code>Boolean</code> object.</li> <li>For a symbol, it creates a <code>Symbol</code> object.</li> <li>For a bigint, it creates a <code>BigInt</code> object.</li> </ul> </li> <li> <p>Method/Property Access: The engine uses this temporary object to access the desired method or property.</p> <ul> <li>In the case of \"hello\".toUpperCase(), it creates a <code>String</code> object and calls the <code>toUpperCase</code> method on it.</li> </ul> </li> <li> <p>Result Return and Discarding Temporary Object: The result of the method or property access is returned, and the temporary object is discarded.</p> <ul> <li>The temporary <code>String</code> object is no longer needed after the <code>toUpperCase</code> method is called, so it is discarded.</li> </ul> </li> </ol>"},{"location":"js/datatypes/data-types/#example-in-detail","title":"Example in Detail","text":"<p>Here\u2019s a more detailed breakdown of the example:</p> <pre><code>let str = \"hello\";\nconsole.log(str.toUpperCase()); // \"HELLO\"\n</code></pre> <ol> <li>Primitive Detection: The JavaScript engine sees that str is a primitive string.</li> <li> <p>Temporary Object Creation: The engine creates a temporary String object that represents the value \"hello\".</p> <pre><code>let tempStrObj = new String(\"hello\");\n</code></pre> </li> <li> <p>Method/Property Access: The engine calls the <code>toUpperCase</code> method on the <code>tempStrObj</code> object.</p> <pre><code>let result = tempStrObj.toUpperCase(); // \"HELLO\"\n</code></pre> </li> <li> <p>Result Return and Discarding Temporary Object: The engine returns the result (\"HELLO\") and discards the temporary <code>String</code> object.</p> </li> </ol>"},{"location":"js/datatypes/data-types/#summary_1","title":"Summary","text":"<ul> <li>JavaScript uses autoboxing to wrap primitive values in temporary objects when you try to access properties or methods on them.</li> <li>The engine checks the type of the value and creates a corresponding wrapper object (<code>String</code>, <code>Number</code>, <code>Boolean</code>, <code>Symbol</code>, <code>BigInt</code>).</li> <li>After accessing the property or method, the result is returned, and the temporary object is discarded.</li> </ul> <p>This mechanism allows primitive values to behave like objects when needed, providing a seamless and flexible programming experience.</p> <p> </p>"},{"location":"js/datatypes/data-types/#reference","title":"Reference","text":"<ul> <li>Autoboxing in JavaScript</li> <li>Top 6 Non Primitive Data Types In JavaScript</li> </ul>"},{"location":"js/datatypes/intro/","title":"Intro","text":"<p>In JavaScript, objects and arrays are reference types. This means when you assign an object or array to a variable, that variable doesn't hold the actual data but instead holds a reference (or pointer) to the original object or array in memory.</p> <p>In React, the most efficient way to detect whether a value has changed is by comparing the reference of the value, not the value itself (for non-primitive types like arrays and objects).</p> Key Concept: <ul> <li>Primitive types: (e.g., <code>number</code>, <code>string</code>, <code>boolean</code>) are compared by value.</li> <li>Reference types: (e.g., <code>array</code>, <code>object</code>) are compared by reference.</li> </ul> <p>In React, you can use shallow comparison (comparing the references) to check if something has changed, and React will re-render when the reference changes.</p> Shallow vs Deep Comparison <ul> <li> <p>Shallow Comparison: Compares only the references for objects and arrays. This is how React determines whether a state change has occurred, by comparing the <code>reference</code> of the previous and new state.</p> </li> <li> <p>Deep Comparison: Compares the actual contents of objects or arrays, which is more expensive computationally and generally not needed in React.</p> </li> </ul> <p>For React, shallow comparison is used by default. When you update state by creating a new reference (new object or array), React will re-render the component.</p>"},{"location":"js/datatypes/intro/#what-are-javascript-data-types-interview","title":"What are JavaScript data types? INTERVIEW","text":"<p>In JavaScript, there are <code>three</code> primary data types, <code>two</code> composite data types, and <code>two</code> special data types.</p> <p>Primary Data Types</p> <ul> <li>String</li> <li>Number</li> <li>Boolean</li> </ul> <p>Composite Data Types</p> <ul> <li>Object</li> <li>Array</li> </ul> <p>Special Data Types</p> <ul> <li>Null</li> <li>Undefined</li> </ul> <p>pg: 6. JavaScript Interview Questions by Fabio Cimo</p> <p></p> <p></p> <p></p> <ul> <li>Medium: JavaScript fundamentals: Variables and Data types</li> <li>Blog: Data Types in JavaScript</li> </ul>"},{"location":"js/datatypes/intro/#related-blogs","title":"Related Blogs","text":"<ul> <li>State Immutability</li> </ul>"},{"location":"js/datatypes/intro/#reference","title":"Reference","text":"<ul> <li>Orielly, Data Types and Values</li> <li>Javascript data types with examples</li> <li>Data Types in JavaScript</li> </ul>"},{"location":"js/datatypes/stack-vs-heap/","title":"Stack vs Heap","text":""},{"location":"js/datatypes/stack-vs-heap/#stack-vs-heap","title":"Stack vs Heap","text":"<p>does the stack and heap is related to primitive and non primitive in javascipt.</p> <p>In JavaScript, the concepts of \"stack\" and \"heap\" memory are not directly tied to whether a value is primitive or non-primitive (also called reference types), but they are related in how values are stored and managed in memory.</p> Types of Memory in JavaScript <p>JavaScript manages memory in two main areas:</p> <ol> <li>Stack Memory (Primitive Data Types)</li> <li>Heap Memory (Reference Data Types)</li> </ol>"},{"location":"js/datatypes/stack-vs-heap/#stack-and-heap-overview","title":"Stack and Heap Overview","text":"<ul> <li>Stack memory: It is used for storing primitive data types (like numbers, strings, booleans) and function call details (such as parameters, return addresses, and local variables).</li> <li>Heap memory: It is used for storing non-primitive (reference) types like objects, arrays, and functions. The heap allows for dynamic memory allocation, meaning memory is allocated at runtime.</li> </ul>"},{"location":"js/datatypes/stack-vs-heap/#primitive-types-stored-in-the-stack","title":"Primitive Types (Stored in the Stack)","text":"<p>Primitive types in JavaScript are:</p> <ul> <li><code>number</code></li> <li><code>string</code></li> <li><code>boolean</code></li> <li><code>undefined</code></li> <li><code>null</code></li> <li><code>symbol</code></li> <li><code>bigint</code></li> </ul> <p>When you declare a primitive variable, the value itself is directly stored in stack memory. The stack is a simple, fast memory structure. For example:</p> <pre><code>let x = 10; // x is a number, a primitive type stored on the stack\n</code></pre> <p>In this case, the value <code>10</code> is stored directly in the stack memory location associated with the variable <code>x</code>.</p>"},{"location":"js/datatypes/stack-vs-heap/#non-primitive-reference-types-stored-in-the-heap","title":"Non-Primitive (Reference) Types (Stored in the Heap)","text":"<p>Non-primitive types in JavaScript are:</p> <ul> <li><code>object</code></li> <li><code>array</code></li> <li><code>function</code></li> <li><code>date</code></li> <li><code>regexp</code></li> <li><code>map</code>, <code>set</code>, and other complex structures</li> </ul> <p>When you declare a non-primitive variable, it does not store the value directly in the stack. Instead, it stores a reference (or pointer) to the actual data, which resides in heap memory. The heap is a more flexible, slower memory structure that handles larger objects and data dynamically. For example:</p> <pre><code>let person = { name: \"Alice\", age: 25 }; // person is an object, a reference type\n</code></pre> <p>Here, the variable <code>person</code> stores a reference to the object <code>{ name: 'Alice', age: 25 }</code> that resides in the heap, not the actual object itself.</p>"},{"location":"js/datatypes/stack-vs-heap/#relationship-between-stack-heap-and-data-types","title":"Relationship Between Stack, Heap, and Data Types","text":"<ol> <li>Primitives are stored directly in the stack. Their values are copied when assigned to other variables. If you change one variable, the other won't be affected.</li> <li>Non-primitives are stored as references in the stack, but the actual data (objects, arrays, etc.) is in the heap. When a reference type is assigned to another variable, both variables point to the same memory location in the heap, meaning changes to one variable will affect the other.</li> </ol> <pre><code>let num1 = 10; // num1 is stored in the stack (primitive)\nlet num2 = num1; // num2 gets a copy of num1's value (stack)\n\nlet obj1 = { name: \"Bob\" }; // obj1 holds a reference to the heap\nlet obj2 = obj1; // obj2 now points to the same object as obj1 (heap)\nobj1.name = \"Alice\"; // Both obj1 and obj2 now refer to the same object in the heap\nconsole.log(obj2.name); // 'Alice' - changes are reflected in both variables\n</code></pre> Summary <ul> <li>Primitive types: Stored directly in stack memory.</li> <li>Non-primitive (reference) types: Stored as references in stack memory, but the actual data resides in heap memory.</li> </ul> <p>While stack and heap memory are about how values are stored and accessed in memory, the distinction between primitive and non-primitive types in JavaScript relates to whether the value is stored directly or through a reference to another memory location.</p>"},{"location":"js/datatypes/stack-vs-heap/#question","title":"Question","text":"<p>but why can you explain why primitve data are stored in stack but references are not store in stack but in heap</p> <p></p> <p>The distinction between stack and heap memory, and why primitive data are stored in the stack while reference types are stored in the heap, comes down to the nature of how data is stored and accessed.</p>"},{"location":"js/datatypes/stack-vs-heap/#1-primitive-types-simple-fixed-size-and-immutable","title":"1. Primitive Types: Simple, Fixed Size, and Immutable","text":"<p>Primitive types in JavaScript (such as numbers, strings, booleans, etc.) are simple and immutable. This means that:</p> <ul> <li>Fixed size: Each primitive type has a known, fixed size (e.g., numbers are always 8 bytes in memory, strings are a certain length, etc.).</li> <li>No references: The value is the actual data (e.g., the value <code>10</code> or <code>'hello'</code> is directly the value, not a reference to something else).</li> <li>Direct access: You can access the value directly without needing to go through any indirection.</li> </ul> <p>Because of these properties, primitives are suited for stack memory, which is fast, easy to allocate, and has a last-in-first-out (LIFO) structure. When a primitive value is created:</p> <ul> <li>The actual value is stored directly in the stack.</li> <li>Since primitives are immutable and fixed in size, there's no need for extra memory allocation or pointer management. When you copy a primitive value from one variable to another, you are just copying the actual value, which is quick and efficient.</li> </ul>"},{"location":"js/datatypes/stack-vs-heap/#2-reference-types-dynamic-complex-and-mutable","title":"2. Reference Types: Dynamic, Complex, and Mutable","text":"<p>Reference types (objects, arrays, functions, etc.) are more complex and have different behavior:</p> <ul> <li>Dynamic size: These types can grow and shrink, depending on the content. For example, an object might have a different number of properties, and an array might have a different number of elements.</li> <li>Mutable: You can modify the contents of an object or array after it has been created. This means that when you pass around a reference to an object, you could potentially change that object from multiple places.</li> <li>Indirect access: A reference type variable doesn't directly hold the data. It holds a reference (or pointer) to the actual data located elsewhere in memory (the heap).</li> </ul> <p>Since reference types can vary in size and can be modified at any time, they are stored in the heap:</p> <ul> <li>The heap is a larger, dynamic memory area where you can allocate memory at runtime. This allows for more complex data structures like objects and arrays that may change in size.</li> <li>When you create a reference type, a block of memory is allocated on the heap for the actual data. The variable itself (in the stack) just stores a reference (a memory address or pointer) to that data.</li> <li>Since reference types are mutable and can be shared across different parts of the program, the heap ensures that any changes made to an object or array are reflected globally, which wouldn\u2019t be as easy with the stack.</li> </ul>"},{"location":"js/datatypes/stack-vs-heap/#why-not-store-references-in-the-stack","title":"Why Not Store References in the Stack?","text":"<p>The key issue is that reference types need dynamic memory allocation because:</p> <ul> <li>They can grow/shrink, so their memory needs cannot be determined ahead of time (like primitive data types).</li> <li>Heap memory is designed to handle this kind of dynamic memory allocation efficiently. The stack is meant for fast, fixed-size allocations and is not ideal for objects that can change in size or need to be referenced in multiple places.</li> </ul>"},{"location":"js/datatypes/stack-vs-heap/#key-points","title":"Key Points:","text":"<p>Stack memory is used for primitive data types because:</p> <ul> <li>They have a fixed size.</li> <li>They are immutable, and their values are simple.</li> <li>Fast and direct access to values.</li> </ul> <p>Heap memory is used for reference types because:</p> <ul> <li>The size can be dynamic and unknown at compile time.</li> <li>These types are mutable (can be changed) and may need to be shared across various parts of the program.</li> <li>Indirection: Variables store references (pointers), not the actual data, so they must point to data in the heap.</li> </ul>"},{"location":"js/datatypes/stack-vs-heap/#example","title":"Example:","text":"<pre><code>let num = 42; // num is a primitive type (number)\nlet obj = { name: \"Alice\" }; // obj is a reference type (object)\n</code></pre> <ol> <li> <p><code>num</code> is a primitive:</p> <ul> <li>The value <code>42</code> is directly stored in the stack.</li> <li>If you copy <code>num</code> into another variable, you are copying the value <code>42</code>.</li> </ul> </li> <li> <p><code>obj</code> is a reference type:</p> <ul> <li>The object <code>{ name: \"Alice\" }</code> is stored in the heap.</li> <li>The variable <code>obj</code> in the stack holds a reference to the memory location of the object in the heap, not the object itself.</li> </ul> </li> </ol> <pre><code>let anotherObj = obj; // anotherObj now references the same object as obj\nobj.name = \"Bob\"; // Both obj and anotherObj refer to the same object in the heap\nconsole.log(anotherObj.name); // \"Bob\"\n</code></pre> <p>In this case, both <code>obj</code> and <code>anotherObj</code> are referencing the same object in the heap. If reference types were stored in the stack, modifying one would create a copy of the object, and changes wouldn't be shared across references. Storing references in the stack and the actual data in the heap ensures that any modifications to the object are reflected across all references.</p> <p>Conclusion:</p> <p>Primitive data types are stored in the stack because they are simple, fixed in size, and immutable, allowing for fast and efficient memory management. Reference types are stored in the heap because they are dynamic, mutable, and can grow in size, requiring more flexible and complex memory management.</p>"},{"location":"js/datatypes/stack-vs-heap/#summary-of-stack-vs-heap-in-a-browser-environment","title":"Summary of Stack vs. Heap in a Browser Environment","text":"<p>Stack:</p> <ul> <li>Small (usually 512 KB\u20131 MB).</li> <li>Stores primitive data (numbers, strings, etc.) and function call contexts.</li> <li>Limited size; deep recursion can lead to stack overflow.</li> <li>Fast allocation and deallocation of memory.</li> </ul> <p>Heap:</p> <ul> <li>Large (can range from 50 MB to several GBs depending on system memory).</li> <li>Stores reference types (objects, arrays, functions).</li> <li>Managed by the garbage collector, which automatically frees unused memory.</li> <li>Flexible size, but still constrained by system memory.</li> </ul> <p>In a browser environment, most memory-related errors are due to the heap growing too large (leading to slowdowns or crashes) or stack overflows due to deep recursion.</p>"},{"location":"js/datatypes/stack-vs-heap/#summary-of-best-practices-for-optimizing-memory-in-javascript","title":"Summary of Best Practices for Optimizing Memory in JavaScript:","text":"<ul> <li>Avoid deep recursion by using iterative solutions where possible.</li> <li>Minimize memory leaks by cleaning up references (nullifying objects when done).</li> <li>Optimize object/array usage to store only necessary data and avoid unnecessary cloning.</li> <li>Remove event listeners when no longer needed to avoid memory bloat.</li> <li>Use Web Workers for heavy computation tasks to avoid blocking the main thread.</li> <li>Lazy load and split code to load only what's necessary, reducing initial memory usage.</li> <li>Profile your code using developer tools to identify and address memory issues.</li> <li>Use efficient data structures for managing your data and optimizing performance.</li> </ul>"},{"location":"js/datatypes/stack-vs-heap/#reference","title":"Reference","text":"<ul> <li>Understanding Datatypes in JavaScript - Primitive and Non-Primitive </li> <li>Stack vs Heap Concept in Primitive and Non-primitive</li> <li> <p>Data Types in JavaScript (immutable vs mutable) </p> </li> <li> <p>Day 6:Understanding Stack and Heap in JavaScript</p> </li> <li> <p>Stack and Heap In Js</p> </li> <li> <p>Best Example: Javascript Memory Management</p> </li> <li>Memory Life Cycle in JS(Heap, Stack, Call Stack, String Pool)</li> <li> <p>Understanding Stack and Heap in JavaScript . </p> </li> <li> <p>Memory Management in JavaScript</p> </li> <li>Javascript Runtime: JS Engine, Event Loop, Call Stack, Execution Contexts, Heap, and Queues</li> </ul>"},{"location":"js/datatypes/state-immutability/","title":"Immutability","text":""},{"location":"js/datatypes/state-immutability/#state-immutability-in-javascript","title":"State Immutability in JavaScript","text":"<p>Immutability refers to the concept that once an object or data structure is created, it cannot be changed. Instead of directly modifying the original object, a new copy of the object is created with the updated values. This principle is critical in both JavaScript and React for ensuring that your code works predictably and efficiently, especially when it comes to state management.</p> <p>Immutability in JavaScript</p> <p>In JavaScript, objects and arrays are mutable by default, meaning that you can modify them directly (e.g., change a property of an object or append to an array). However, immutability means you should avoid direct modifications. For example:</p> <ul> <li> <p>Mutable Operation (Not Immutable):</p> <pre><code>let obj = { name: \"John\" };\nobj.name = \"Jane\"; // Direct modification\n</code></pre> </li> <li> <p>Immutable Operation (Using Immutability):</p> <pre><code>let obj = { name: \"John\" };\nobj = { ...obj, name: \"Jane\" }; // Create a new object with updated values\n</code></pre> </li> </ul> <p>Instead of directly modifying <code>obj</code>, you create a new object with the updated properties. This ensures that the original object remains unchanged.</p>"},{"location":"js/datatypes/state-immutability/#how-to-identify-mutable-vs-immutable-methods","title":"How to Identify Mutable vs Immutable Methods","text":""},{"location":"js/datatypes/state-immutability/#1-arrays","title":"1. Arrays","text":"<p>Mutable methods (modify the array directly):</p> <ul> <li><code>push()</code>: Adds elements to the end of an array.</li> <li><code>pop()</code>: Removes the last element.</li> <li><code>shift()</code>: Removes the first element.</li> <li><code>unshift()</code>: Adds elements to the beginning.</li> <li><code>splice()</code>: Removes or replaces elements at a specific index.</li> </ul> <p>These methods change the original array.</p> <pre><code>let arr = [1, 2, 3];\narr.push(4); // arr is now [1, 2, 3, 4] (mutated)\n</code></pre> <p>Immutable methods (return a new array):</p> <ul> <li><code>concat()</code>: Combines multiple arrays and returns a new array.</li> <li><code>slice()</code>: Returns a shallow copy of part of an array.</li> <li><code>map()</code>: Creates a new array by applying a function to each element.</li> <li><code>filter()</code>: Returns a new array containing elements that pass the test.</li> <li><code>reduce()</code>: Reduces an array to a single value, returning a new value.</li> <li><code>flat()</code>: Flattens nested arrays into a new array.</li> </ul> <p>These methods do not modify the original array; they return new arrays.</p> <pre><code>let arr = [1, 2, 3];\nlet newArr = arr.concat([4, 5]); // arr is unchanged, newArr is [1, 2, 3, 4, 5]\n</code></pre>"},{"location":"js/datatypes/state-immutability/#2-objects","title":"2. Objects","text":"<p>Mutable methods (modify the object directly):</p> <ul> <li> <p>Direct assignment: Assigning a new value to a property of an object mutates the object.</p> <pre><code>let obj = { name: \"Alice\" };\nobj.name = \"Bob\"; // This changes the original object\n</code></pre> </li> <li> <p><code>Object.assign()</code>: Copies properties from one object to another. This method is shallow and modifies the target object.</p> <pre><code>let obj1 = { name: \"Alice\" };\nlet obj2 = Object.assign({}, obj1, { age: 25 }); // obj1 is not modified, but obj2 is modified\n</code></pre> </li> </ul> <p>Immutable methods (create a new object):</p> <ul> <li> <p>Spread syntax (...): Creates a new object with the existing properties.</p> <pre><code>let obj = { name: \"Alice\", age: 25 };\nlet newObj = { ...obj, name: \"Bob\" }; // newObj is created with modified property\n</code></pre> </li> <li> <p>Object.freeze(): This method makes an object immutable by preventing modification of its properties. However, it\u2019s a shallow freeze, meaning nested objects can still be changed.</p> <pre><code>const obj = { name: \"Alice\" };\nconst newObj = { ...obj, age: 25 }; // newObj is created, obj is unchanged\n</code></pre> </li> </ul>"},{"location":"js/datatypes/state-immutability/#3-strings","title":"3. Strings","text":"<p>Strings are immutable in JavaScript, meaning you can\u2019t change a character in the string once it is created. However, many string methods return new strings based on the original one.</p> <p>Immutable string methods:</p> <ul> <li> <p>substring(), slice(), replace(), toUpperCase(), toLowerCase(), etc., all return new strings without modifying the original.</p> <pre><code>let str = \"hello\";\nlet newStr = str.toUpperCase(); // newStr is 'HELLO', str is unchanged\n</code></pre> </li> </ul> <p>Is There a Simple Rule?</p> <p>Yes, here's a simplified rule:</p> <ul> <li>If the method modifies the original object/array/variable, it is mutable.</li> <li>If the method returns a new version (copy) of the data without changing the original, it is immutable.</li> </ul> <p>Common Patterns to Recognize Mutable/Immutable Methods</p> <ol> <li>Methods that change data in-place (like <code>push()</code>, <code>pop()</code>, <code>shift()</code>, <code>unshift()</code>, <code>splice()</code> for arrays) are mutable.</li> <li>Methods that return a new version of data (like <code>concat()</code>, <code>slice()</code>, <code>map()</code>, <code>filter()</code> for arrays) are immutable.</li> <li>Direct assignment to properties (like <code>obj.property = value</code>) is mutable.</li> <li>Methods that create new objects or arrays (like <code>Object.assign()</code>, spread syntax <code>{ ...obj }</code>) are usually immutable.</li> </ol> <p>Summary</p> <ul> <li>Immutability ensures that you don\u2019t accidentally change the state/data, making your code more predictable and easier to debug.</li> <li>Mutable methods modify the original data directly.</li> <li>Immutable methods return new copies of the data, leaving the original data intact.</li> <li>To identify if a method is mutable or immutable, check if it directly modifies the data (mutable) or returns a new copy of the data (immutable).</li> </ul>"},{"location":"js/datatypes/state-immutability/#why-immutability-is-important","title":"Why Immutability is Important","text":"<p>Let me explain immutability in simpler terms and how it affects the way you write code in JavaScript, especially in frameworks like React. What Does Immutability Mean?</p> <p>Immutability means that once a value is created, it cannot be changed. Instead of changing the original value (like an object or array), you create a new value with the changes.</p>"},{"location":"js/datatypes/state-immutability/#related-blogs","title":"Related Blogs","text":"<ul> <li>State Immutability</li> </ul>"},{"location":"js/datatypes/state-immutability/#blog","title":"Blog","text":"<ul> <li>Libraries for Immutable Data Structure in React</li> </ul>"},{"location":"js/definition/best/","title":"Best","text":"<p>Get Programming with JavaScript Next: New features of ECMAScript 2015, 2016, and beyond by JD Isaacks</p>"},{"location":"js/definition/best/#declaring-variables-with-let","title":"Declaring variables with <code>let</code>","text":"<p>In the history of JavaScript, variables have always been declared using the keyword var.</p> <p>ES6 introduces two new ways to declare variables, with the <code>let</code> and <code>const</code> keywords.</p>"},{"location":"js/definition/best/#how-scope-works-with-let","title":"How Scope Works with <code>let</code>","text":"<p>Variables declared with <code>let</code> have block scope, meaning they can only be accessed within the block (or sub-blocks) they are declared in:</p> <pre><code>if (true) {\n  let foo = \"bar\";\n}\nconsole.log(foo);\n</code></pre> <ul> <li>An error is thrown because foo does not exist outside the block it was declared in.</li> </ul> <p>A block is the body of a statement or function. It is the area between the opening and closing curly braces, <code>{</code> and <code>}</code>.</p> <p>You can even use curly braces to create a free-standing block that isn\u2019t tied to a statement:</p>"},{"location":"js/definition/best/#how-hoisting-works-with-let","title":"How Hoisting works with <code>let</code>","text":"<p>Variables declared with <code>let</code> and <code>var</code> both have a behavior called <code>hoisting</code>.</p> <p>This concept of variables being in scope before they are declared, called hoisting, isn\u2019t actually new. <code>let</code> hoists to the top of the block, and <code>var</code> hoists to the top of the function.</p> Note <p>There is, however, a more important distinction here, namely what happens when a variable declared with <code>let</code> is accessed before it\u2019s declared, in contrast to <code>var</code>.</p> <p>When a <code>let</code> variable is accessed in scope before it is declared, it throws a reference error. This is unlike <code>var</code>, which allows the use but the value will always be undefined. This area or zone, in which the let variable can be accessed at a time before it is declared but will throw an error if it actually is, is called a temporal dead zone.</p> Difference between var and let <p>A <code>var</code> will be undefined if it\u2019s accessed before it\u2019s declared; a <code>let</code> throws an exception.</p>"},{"location":"js/definition/best/#declaring-constants-with-const","title":"Declaring constants with <code>const</code>","text":"<p>The keyword <code>const</code> stands for <code>constant</code>, as in never changing. Many programs have values that never change, whether by intention or by happenstance.</p>"},{"location":"js/definition/best/#how-constants-work","title":"How CONSTANTS Work","text":"<p>Constants cannot be reassigned. This means that once you assign the value of a constant, any attempt to assign a new value will result in an error:</p> <pre><code>const myConst = 5;\nmyConst = 6; // 1\n</code></pre> <ul> <li>1 Error</li> </ul> <p>Because of the inability to reassign constants with new values, they quickly became confused with being immutable. Constants are not immutable.</p> <p>So what\u2019s the difference between not being able to be reassigned and being immutable?</p> <p>Assignment has to do with variable bindings, binding a name to a piece of data.</p> <p>Immutability or mutability is a property that belongs to the actual data that the binding contains. All primitives (<code>strings</code>, <code>numbers</code>, and so on) are immutable, whereas objects are mutable.</p>"},{"location":"js/definition/best/#when-to-use-constants","title":"When to use Constants","text":"<pre><code>const ADD_ITEM = \"ADD_ITEM\";\nconst DEL_ITEM = \"DEL_ITEM\";\nlet items = [];\n\nfunction actionHandler(action) {\n  switch (action.type) {\n    case ADD_ITEM:\n      items.push(action.item);\n\n    case DEL_ITEM:\n      items.splice(items.indexOf(action.item), 1);\n      break;\n  }\n}\n</code></pre> <p>This ensures that the action flags <code>ADD_ITEM</code> and <code>DEL_ITEM</code> can never be accidentally changed.</p> Note <ul> <li>Constants are variables that can\u2019t be reassigned.</li> <li>Constants are not immutable.</li> <li>Constants have the same scoping rules as <code>let</code>.</li> </ul>"},{"location":"js/definition/definition/","title":"Intro","text":"<p>A literal is syntax that allows you to define a reference value without explicitly creating an object, using the <code>new</code> operator and the object\u2019s constructor.</p> <ul> <li> The Principles of Object-Oriented JavaScript by Nicholas C. Zakas: Literal Forms: pg-9</li> </ul> Tip <p>What Are Types?</p> <p>Although JavaScript has no concept of classes, it still uses two kinds of types: primitive and reference.</p> <ul> <li>Primitive types are stored as simple data types.</li> <li>Reference types are stored as objects, which are really just references to locations in memory.</li> </ul> <p>The tricky thing is that JavaScript lets you treat primitive types like reference types in order to make the language more consistent for the developer.</p> <p>While other programming languages distinguish between primitive and reference types by storing <code>primitives</code> on the stack and <code>references</code> in the heap, JavaScript does away with this concept completely: It tracks variables for a particular scope with a variable object. Primitive values are stored directly on the variable object, while reference values are placed as a pointer in the variable object, which serves as a reference to a location in memory where the object is stored.</p> <p>However, as you\u2019ll see later in this chapter, primitive values and reference values behave quite differently although they may initially seem the same.</p> <ul> <li> The Principles of Object-Oriented JavaScript by Nicholas C. Zakas: Literal Forms: pg-2</li> </ul> <p>Dereferencing Objects</p> <p>JavaScript is a garbage-collected language, so you don\u2019t really need to worry about memory allocations when you use reference types. However,</p> <p>it\u2019s best to dereference objects that you no longer need so that the garbage collector can free up that memory. The best way to do this is to set the object variable to <code>null</code>.</p> <pre><code>var object1 = new Object();\n\n// do something\n\nobject1 = null; // dereference\n</code></pre> <ul> <li> The Principles of Object-Oriented JavaScript by Nicholas C. Zakas: Literal Forms: pg-7</li> </ul>"},{"location":"js/definition/definition/#js-data-types","title":"JS Data Types","text":"<p>Primitive data types</p> <ol> <li>Number</li> <li>String</li> <li>Boolean</li> <li>Undefined <code>special type</code></li> <li>Null <code>special type</code></li> </ol> <p>Any value that doesn't belong to one of the five primitive types listed here is an <code>object</code>. Even <code>null</code> is considered an <code>object</code>, which is a little awkward\u2014having an object (something) that is actually nothing.</p> <p>just remember that in JavaScript the data types are either:</p> <ul> <li>Primitive (the <code>five types</code> listed previously)</li> <li>Non-primitive (<code>objects</code>)</li> </ul> <p>Finding out the value type \u2013 the typeof operator</p> <p>If you want to know the type of a variable or a value, you use the special typeof operator. This operator returns a string that represents the data type. The return values of using typeof are one of the following:</p> <ul> <li>\"number\"</li> <li>\"string\"</li> <li>\"boolean\"</li> <li>\"undefined\"</li> <li>\"object\"</li> <li>\"function\"</li> </ul> <p>Javascript: Object Oriented Programming: 2016 Packt Publishing, pg- 500</p> Primitive data types recap <p>There are five primitive data types in JavaScript:</p> <ul> <li>Number</li> <li>String</li> <li>Boolean</li> <li>Undefined</li> <li>Null</li> </ul> <p>Everything that is not a primitive data type is an <code>object</code></p> <ul> <li>Javascript: Object Oriented Programming: 2016 Packt Publishing, pg- 509</li> </ul>"},{"location":"js/definition/definition/#loops","title":"Loops","text":"<p>In JavaScript, there are four types of loops:</p> <ul> <li>while loops</li> <li>do-while loops</li> <li>for loops</li> <li>for-in loops</li> </ul> Note <ul> <li> <p>for is the most widely used type of loop</p> </li> <li> <p>The for-in loop is used to iterate over the elements of an array (or an object).</p> </li> </ul> <p>as for-in is mostly suitable for objects, and the regular for loop should be used for arrays.</p> <p>Javascript: Object Oriented Programming: 2016 Packt Publishing, pg- 528</p>"},{"location":"js/definition/definition/#hashes-and-associative-arrays","title":"Hashes and associative arrays","text":"<p>In some programming languages, there is a distinction between:</p> <ul> <li>A regular array, also called an indexed or enumerated array (the <code>keys</code> are numbers)</li> <li>An associative array, also called a hash or a dictionary (the <code>keys</code> are strings)</li> </ul> <p>JavaScript uses arrays to represent indexed arrays and objects to represent associative arrays. If you want a hash in JavaScript, you use an object.</p>"},{"location":"js/definition/definition/#accessing-an-objects-properties","title":"Accessing an object's properties","text":"<p>There are two ways to access a property of an object:</p> <ul> <li>Using the <code>square bracket notation</code>, for example <code>hero['occupation']</code></li> <li>Using the <code>dot notation</code>, for example <code>hero.occupation</code></li> </ul>"},{"location":"js/definition/definition/#the-instanceof-operator","title":"The <code>instanceof</code> operator","text":"<p>With the instanceof operator, you can test if an object was created with a specific constructor function:</p> <pre><code>&gt; function Hero() {}\n&gt; var h = new Hero();\n&gt; var o = {};\n&gt; h instanceof Hero;\ntrue\n&gt; h instanceof Object;\ntrue\n&gt; o instanceof Object;\ntrue\n</code></pre> <p>Note that you don't put parentheses after the function name (you don't use <code>h instanceof Hero()</code>). This is because you're not invoking this function, but just referring to it by name, as with any other variable.</p>"},{"location":"js/definition/definition/#null","title":"Null","text":"<p>Conceptual overview of using the <code>null</code> value</p> <p>You can use <code>null</code> to explicitly indicate that an object property does not contain a value.</p> <p>Typically, if a property is set up to contain a value, but the value is not available for some reason, the value <code>null</code> should be used to indicate that the reference property has an empty value.</p> <pre><code>// The property foo is waiting for a value, so we set its initial value\nto null.\nvar myObjectObject = { foo: null };\nconsole.log(myObjectObject.foo); // Logs 'null\n</code></pre> <p><code>typeof</code> returns <code>null</code> values as \"object\"</p> <p>For a variable that has a value of <code>null</code>, the <code>typeof</code> operator returns \"object\u201d. If you need to verify a <code>null</code> value, the ideal solution would be to see if the value you are after is equal to <code>null</code>.</p> <p>In the following sample, we use the <code>===</code> operator to specifically verify that we are dealing with a null value.</p> <pre><code>var myObject = null;\nconsole.log(typeof myObject); // Logs 'object', not exactly helpful.\nconsole.log(myObject === null); // Logs true, only for a real null value.\n</code></pre> Note <p>When verifying a <code>null</code> value, always use <code>===</code> because <code>==</code> does not distinguish between <code>null</code> and <code>undefined</code>.</p> <ul> <li>JavaScript Succinctly by Cody Lindley - 68</li> </ul>"},{"location":"js/definition/definition/#undefined","title":"Undefined","text":"<p>Conceptual overview of the undefined value</p> <p>The undefined value is used by JavaScript in two slightly different ways.</p> <ul> <li>The first way it's used is to indicate that a declared variable (e.g., var foo) has no assigned value.</li> <li>The second way it's used is to indicate that an object property you\u2019re trying to access is not defined (i.e. it has not even been named), and is not found in the prototype chain.</li> </ul> <pre><code>var initializedVariable; // Declare variable.\n\nconsole.log(initializedVariable); // Logs undefined.\nconsole.log(typeof initializedVariable); // Confirm that JavaScript returns undefined.\n\nvar foo = {};\n\nconsole.log(foo.bar); // Logs undefined, no bar property in foo object.\nconsole.log(typeof foo.bar); // Confirm that JavaScript returns undefined.\n</code></pre> Note <p>It is considered good practice to allow JavaScript alone to use <code>undefined</code>. You should never find yourself setting a value to <code>undefined</code>, as in foo = undefined. Instead, <code>null</code> should be used if you are specifying that a property or variable value is not available.</p> <ul> <li>JavaScript Succinctly by Cody Lindley - 69</li> </ul>"},{"location":"js/definition/definition/#primitive-values","title":"Primitive values","text":"<p>Primitive/literal values are converted to objects when properties are accessed</p> <p>Do not be mystified by the fact that <code>string</code>, <code>number</code>, and <code>Boolean</code> literals can be treated like an object with properties (e.g., <code>true.toString()</code>). When these primitive values are treated like objects by attempting to access their properties, JavaScript will create a wrapper object from the primitive\u2019s associated constructor, so that the properties and methods of the wrapper object can be accessed. Once the properties have been accessed, the wrapper object is discarded. This conversion allows us to write code that would make it appear as if a primitive value was, in fact, an object. Truth be told, when it is treated like an object in code, JavaScript will convert it to an object so property access will work, and then convert it back to a primitive value once a value is returned. The key thing to notice here is what is occurring, and that JavaScript is doing this for you behind the scenes.</p> <pre><code>// String object treated like an object.\nvar stringObject = new String(\"foo\");\n\nconsole.log(stringObject.length); // Logs 3.\nconsole.log(stringObject[\"length\"]); // Logs 3.\n// String literal/primitive converted to an object when treated as an object.\n\nvar stringLiteral = \"foo\";\n\nconsole.log(stringLiteral.length); // Logs 3.\nconsole.log(stringLiteral[\"length\"]); // Logs 3.\nconsole.log(\"bar\".length); // Logs 3.\nconsole.log(\"bar\"[\"length\"]); // Logs 3.\n</code></pre> <ul> <li>JavaScript Succinctly by Cody Lindley - 65</li> </ul>"},{"location":"js/definition/definition/#the-headglobal-object","title":"The Head/Global Object","text":"<p>Conceptual overview of the head object</p> <p>JavaScript code itself must be contained within an object. For example, when crafting JavaScript code for a web browser environment, JavaScript is contained and executed within the window object. This window object is considered to be the \"head object,\" or sometimes confusingly referred to as \"the global object.\" All implementations of JavaScript require the use of a single head object.</p> <pre><code>var myStringVar = \"myString\";\nvar myFunctionVar = function () {};\nmyString = \"myString\";\nmyFunction = function () {};\n\nconsole.log(\"myStringVar\" in window); // Returns true.\nconsole.log(\"myFunctionVar\" in window); // Returns true.\nconsole.log(\"myString\" in window); // Returns true.\nconsole.log(\"myFunction\" in window); // Return true.\n</code></pre> Note <p>The head object is the highest scope/context available in a JavaScript environment.</p> <ul> <li>JavaScript Succinctly by Cody Lindley - 71</li> </ul>"},{"location":"js/definition/definition/#scope-and-closures","title":"Scope and Closures","text":"<p>Conceptual overview of JavaScript scope</p> <p>In JavaScript, scope is the context in which code is executed.</p> <p>There are three types of scope:</p> <ul> <li>global scope,</li> <li>local scope (sometimes referred to as \"function scope\"), &amp;</li> <li>eval scope.</li> </ul> <pre><code>var foo = \"bar\"; // foo is a global object and a property of the head/window object.\n\nvar myApp = function () {\n  // Remember functions create scope.\n  var run = (function () {\n    // Logs bar, foo's value is found via the scope chain in the head object.\n    console.log(foo);\n  })();\n};\n\nmyApp();\n</code></pre> <ul> <li>JavaScript Succinctly by Cody Lindley - 102</li> </ul>"},{"location":"js/definition/definition/#errors-in-javascript","title":"Errors in Javascript","text":"<p>Three kinds of errors can occur in JavaScript:</p> <ul> <li>syntax errors</li> <li>runtime errors</li> <li>logic errors</li> </ul> <p>Only the first two produce error messages.</p> Note <p>Syntax Errors</p> <p>A syntax error is caused when your code violates the fundamental rules (or syntax) of the JavaScript language. It\u2019s the browser\u2019s way of saying, \u201cWhatchoo talkin\u2019 \u2019bout,</p> <p>syntax errors are the easiest to fix, but the hardest to spot in your code.</p> <p>Runtime Errors</p> <p>Runtime errors occur when a perfectly valid piece of JavaScript code tries to do something that it\u2019s not allowed to do, or that is flat out impossible. These errors are so named because they occur while the script is actually running.</p> <p>The trick is figuring out why the error occurred.</p> <p>Logic Errors</p> <p>Logic errors aren\u2019t so much errors as they are bugs in your script. The code runs fine as it was written\u2014it just doesn\u2019t behave the way you expected it to when you wrote it. These kinds of errors can be devilishly difficult to find because as far as the browser\u2019s concerned the script is working just fine, so you never see an error message.</p> <p>Debugging with Firebug</p> <p>In the past, the most common approach to resolving logic errors in JavaScript code was liberal use of the <code>alert</code> function.</p> <p>At the time of writing, a much more powerful (not to mention sane) approach is to use a JavaScript debugger, and by far the best debugger around is <code>Firebug</code>. <code>Firebug</code> is a free extension for Firefox that adds to the browser a panel containing a rich set of tools for diagnosing problems with your HTML, CSS, and JavaScript.</p> <ul> <li>Simply JavaScript by Kevin Yank and Cameron Adams - 306</li> </ul>"},{"location":"js/definition/definition/#primitive-wrapper-types","title":"Primitive Wrapper Types","text":"<p>Perhaps one of the most confusing parts of JavaScript is the concept of primitive wrapper types.</p> <p>There are three primitive wrapper types</p> <ol> <li>String</li> <li>Number</li> <li>Boolean</li> </ol> <p>These special reference types exist to make working with primitive values as easy as working with objects.</p> <p>The primitive wrapper types are reference types that are automatically created behind the scenes whenever <code>strings</code>, <code>num\u00adbers</code>, or <code>Booleans</code> are read. For example, in the first line of this listing, a primitive string value is assigned to name. The second line treats name like an object and calls <code>charAt(0)</code> using dot notation.</p> <pre><code>var name = \"Nicholas\";\nvar firstChar = name.charAt(0);\nconsole.log(firstChar);\n</code></pre> <p>This is what happens behind the scenes:</p> <pre><code>// what the JavaScript engine does\nvar name = \"Nicholas\";\nvar temp = new String(name);\nvar firstChar = temp.charAt(0);\ntemp = null;\nconsole.log(firstChar); // \"N\"\n</code></pre> <p>Because the second line uses a string (a primitive) like an object, the JavaScript engine creates an instance of String so that charAt(0) will work. The String object exists only for one statement before it\u2019s destroyed (a process called autoboxing). To test this out, try adding a property to a string as if it were a regular object:</p> <pre><code>var name = \"Nicholas\";\nname.last = \"Zakas\";\nconsole.log(name.last); // undefined\n</code></pre> <p>This code attempts to add the property last to the string name. The code itself is just fine except that the property disappears. What happened? When working with regular objects, you can add properties at any time and they stay until you manually remove them. With primitive wrapper types, properties seem to disappear because the object on which the property was assigned is destroyed immediately afterward.</p> Here\u2019s what\u2019s actually happening in the JavaScript engine:<pre><code>// what the JavaScript engine does\nvar name = \"Nicholas\";\nvar temp = new String(name);\ntemp.last = \"Zakas\";\ntemp = null; // temporary object destroyed\n\nvar temp = new String(name);\nconsole.log(temp.last);\ntemp = null; // undefined\n</code></pre> <p>Instead of assigning a new property to a string, the code actually c\u00adreates a new property on a temporary object that is then destroyed. When you try to access that property later, a different object is temporarily created and the new property doesn\u2019t exist there. Although reference values are created automatically for primitive values, when <code>instanceof</code> checks for these types of values the result is false:</p> <pre><code>var name = \"Nicholas\";\nvar count = 10;\nvar found = false;\n\nconsole.log(name instanceof String); // false\nconsole.log(count instanceof Number); // false\nconsole.log(found instanceof Boolean); // false\n</code></pre> <p>The instanceof operator returns false because a temporary object is created only when a value is read. Because <code>instanceof</code> doesn\u2019t actually read anything, no temporary objects are created, and it tells us the \u00advalues aren\u2019t instances of primitive wrapper types. You can create primitive wrapper types manually, but there are certain side effects:</p> <pre><code>var name = new String(\"Nicholas\");\nvar count = new Number(10);\nvar found = new Boolean(false);\n\nconsole.log(typeof name); // \"object\"\nconsole.log(typeof count); // \"object\"\nconsole.log(typeof found); // \"object\"\n</code></pre> <p>As you can see, creating an instance of the primitive wrapper type just creates another object, which means that typeof can\u2019t identify the type of data you intend to store.</p> <p>Summary</p> <p>While JavaScript doesn\u2019t have classes, it does have types. Each variable or piece of data is associated with a specific primitive or reference type.</p> <p>The five primitive types (<code>strings</code>, <code>numbers</code>, <code>Booleans</code>, <code>null</code>, and <code>\u00adundefined</code>) represent simple values stored directly in the variable object for a given context. You can use <code>typeof</code> to identify primitive types with the exception of <code>null</code>, which must be compared directly against the special value null.</p> <p>Reference types are the closest thing to classes in JavaScript, and objects are <code>instances</code> of reference types. You can create new objects using the <code>new</code> operator or a reference literal.</p> <p>Functions are objects in JavaScript, and you can identify them with the <code>typeof</code> operator. You should use <code>instanceof</code> with a constructor to identify objects of any other reference type.</p> <p>To make primitives seem more like <code>references</code>, JavaScript has three primitive wrapper types: <code>String</code>, <code>Number</code>, and <code>Boolean</code>. JavaScript creates these objects behind the scenes so that you can treat primitives like regular objects, but the temporary objects are destroyed as soon as the statement using them is complete. Although you can create your own instances of primitive wrappers, it\u2019s best not to do that because it can be confusing.</p> <ul> <li> The Principles of Object-Oriented JavaScript by Nicholas C. Zakas: pg-14</li> </ul>"},{"location":"js/definition/definition/#design-patterns","title":"Design patterns","text":""},{"location":"js/definition/functional/","title":"Functional","text":"<p>A paradigm is a framework that expresses a particular set of assumptions, relies on particular ways of thinking through problems, and uses particular methodologies to solve those problems.</p> Reference <ul> <li>Functional Programming For Dummies by John Paul Mueller</li> </ul>"},{"location":"js/definition/functional/#defining-functional-programming","title":"Defining Functional Programming","text":"<p>The main difference between the functional programming paradigm and other paradigms is that functional programs use math functions rather than statements to express ideas.</p> <p>This difference means that rather than write a precise set of steps to solve a problem, you use math functions, and you don\u2019t worry about how the language performs the task.</p> <p>In contrast to other paradigms, the functional programming paradigm doesn\u2019t maintain state. The use of state enables you to track values between function calls. Other paradigms use state to produce variant results based on environment, such as determining the number of existing objects and doing something different when the number of objects is zero. As a result, calling a functional program function always produces the same result given a particular set of inputs, thereby making functional programs more predictable than those that support state.</p> <p>Because functional programs don\u2019t maintain state, the data they work with is also immutable, which means that you can\u2019t change it. To change a variable\u2019s value, you must create a new variable. Again, this makes functional programs more predictable than other approaches and could make functional programs easier to run on multiple processors.</p> Reference <ul> <li>Functional Programming For Dummies by John Paul Mueller, 10</li> </ul>"},{"location":"js/definition/functional/#reference","title":"Reference","text":"<ul> <li>Programming Paradigms</li> </ul>"},{"location":"js/definition/intro/","title":"What is","text":""},{"location":"js/definition/intro/#promise","title":"Promise","text":"<p>A promise is a token object the represents the future value or exception of a function that has not yet returned.</p> <p>Click link here for simple definition</p> <p>Promises offer a clean and easy-to-read approach for wrangling asynchronous execution back into a visually sequential control flow. Any process that blocks the event loop is a candidate for the promise pattern.</p> According to the spec, a promise object is composed of the following parts: <ul> <li>Promise is an object or function with a then method whose behavior conforms to this specification.</li> <li>Thenable is an object or function that defines a then method.</li> <li>Value is any legal JavaScript value (including <code>undefined</code>, a <code>thenable</code>, or a <code>promise</code>).</li> <li>Exception is a value that is thrown using the throw statement.</li> <li>Reason is a value that indicates why a promise was rejected.</li> </ul> <ul> <li>Expert JavaScript by Mark E. Daggett, pg:88</li> </ul>"},{"location":"js/definition/memoization/","title":"Memomization","text":""},{"location":"js/definition/memoization/#memoization-with-reactmemo","title":"Memoization with <code>React.memo</code>","text":"<p>Memoization is a technique used in computer science to optimize the performance of functions by caching their previously computed results. In simple terms, memoization stores the output of a function based on its inputs so that if the function is called again with the same inputs, it returns the cached result rather than recomputing the output.</p> <p>Memoization relies on function purity, which is defined as a function predictably returning the same outputs for given inputs. An example of a pure function is:</p> <pre><code>function add(num1, num2) {\n  return num1 + num2;\n}\n</code></pre> <p>This function returns a new component that only rerenders if its props have changed.</p> <p>Memoization is particularly useful when dealing with expensive calculations or when rendering large lists of items. Consider a function:</p> <pre><code>let result = null;\nconst doHardThing = () =&gt; {\n  if (result) return result;\n  // ...do hard stuff\n  result = hardStuff;\n  return hardStuff;\n};\n</code></pre> <p>Calling <code>doHardThing</code> once might take a few minutes to do the hard thing, but calling it a second, third, fourth, or <code>nth</code> time doesn\u2019t actually do the hard thing but instead returns the stored result. This is the gist of memoization.</p> <p>In the context of React, memoization can be applied to functional components using the <code>React.memo</code> component.</p>"},{"location":"js/definition/memoization/#getting-fluent-in-reactmemo","title":"Getting Fluent in <code>React.memo</code>","text":""},{"location":"js/definition/memoization/#memoized-components-that-still-rerender","title":"Memoized Components That Still Rerender","text":""},{"location":"js/definition/memoization/#scalars-primitive-types","title":"Scalars (primitive types)","text":"<p>Scalar types, also known as primitive types, are foundational. These types represent singular, indivisible values. Unlike more complex data structures like arrays and objects, scalars do not possess properties or methods, and they are immutable by nature. This means that once a scalar value is set, it cannot be altered without creating a completely new value. JavaScript has several scalar types, including numbers, strings, booleans, and others like symbols, BigInts, undefined, and null.</p>"},{"location":"js/definition/memoization/#nonscalars-reference-types","title":"Nonscalars (reference types)","text":"<p>Moving beyond the simplicity of scalars, we encounter nonscalar or reference types. These types don\u2019t store data, but rather a reference or a pointer to where the data is stored in memory. This distinction is crucial because it impacts how these types are compared, manipulated, and interacted with in code. In JavaScript, the most common nonscalar types are <code>objects</code> and <code>arrays</code>. Objects allow us to store structured data with key-value pairs, while arrays provide ordered collections. Functions, too, are considered reference types in JavaScript. A key characteristic of nonscalars is that multiple references can point to the same memory location.</p> <p>When it comes to comparison, nonscalar types are compared by their memory reference, not by their content.</p> <pre><code>// Scalar types\n\"a\" === \"a\"; // string; true\n3 === 3; // number; true\n\n// Non-scalar types\n[1, 2, 3] === [1, 2, 3]; // array; false\n{ foo: \"bar\"} === { foo: \"bar\" } // object; false\n</code></pre> <p>With this array comparison, the arrays, objects, and other nonscalar types are compared by reference: as in, does the lefthand-side array\u2019s reference to its position in the computer\u2019s memory equal the righthand-side\u2019s memory location. This is why the comparison returns false. The same is true for objects. What we\u2019re doing with the object comparison is creating two different objects in memory on the lefthand side and the righthand side\u2014of course they\u2019re not equal, they\u2019re two different objects that live in two different places in memory! They just have the same content.</p> <p>This is why <code>React.memo</code> can be tricky to use. Consider a functional component List that takes in an array of items as a prop and renders them:</p> <pre><code>const List = React.memo(function List({ items }) {\n  return (\n    &lt;ul&gt;\n      {items.map((item) =&gt; (\n        &lt;li key={item}&gt;{item}&lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  );\n});\n</code></pre> <p>Now, imagine using this component within a parent component and passing a new array instance each time the parent renders:</p> <pre><code>function ParentComponent({ allFruits }) {\n  const [count, setCount] = React.useState(0);\n  const favoriteFruits = allFruits.filter((fruit) =&gt; fruit.isFavorite);\n  return (\n    &lt;div&gt;\n      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;\n      &lt;List items={favoriteFruits} /&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre> <p>Every time the Increment button is clicked, the ParentComponent rerenders. Even though the items passed to List haven\u2019t changed in value, a new array instance is created, with <code>['apple', 'banana', 'cherry']</code> each time. Since <code>React.memo</code> performs a shallow comparison of props, it will see this new array instance as a different prop from the previous render\u2019s array, causing the List component to rerender unnecessarily.</p> <p>To fix this, we could memoize the array using the <code>useMemo</code> hook:</p> <pre><code>function ParentComponent({ allFruits }) {\n  const [count, setCount] = React.useState(0);\n  const favoriteFruits = React.useMemo(\n    () =&gt; allFruits.filter((fruit) =&gt; fruit.isFavorite),\n    []\n  );\n  return (\n    &lt;div&gt;\n      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;\n      &lt;List items={favoriteFruits} /&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre> <p>Now, the array is only created once and retains the same reference across rerenders, preventing unnecessary rerenders of the List component.</p> <p>This example underscores the importance of understanding reference comparisons when working with <code>React.memo</code> and nonscalar props. If not used cautiously, we could inadvertently introduce performance issues instead of optimizations.</p> <p><code>React.memo</code> often also gets circumvented quite commonly by another nonscalar type: functions. Consider the following case:</p> <pre><code>&lt;MemoizedAvatar\n  name=\"Tejas\"\n  url=\"https://github.com/tejasq.png\"\n  onChange={() =&gt; save()}\n/&gt;\n</code></pre> <p>While the props don\u2019t appear to change or depend on enclosing state with props <code>name</code>, <code>url</code>, and <code>onChange</code> all having constant values, if we compare the props we see the following:</p> <pre><code>\"Tejas\" === \"Tejas\"; // &lt;- `name` prop; true\n\"https://github.com/tejasq.png\" === \"https://github.com/tejasq.png\";\n(() =&gt; save()) === (() =&gt; save()); // &lt;- `onChange` prop; false\n</code></pre> <p>Once again, this is because we\u2019re comparing functions by reference. Remember that as long as props differ, our component will not be memoized. We can combat this by using the <code>useCallback</code> hook inside MemoizedAvatar\u2019s parent:</p> <pre><code>const Parent = ({ currentUser }) =&gt; {\n  const onAvatarChange = useCallback(\n    (newAvatarUrl) =&gt; {\n      updateUserModel({ avatarUrl: newAvatarUrl, id: currentUser.id });\n    },\n    [currentUser]\n  );\n  return (\n    &lt;MemoizedAvatar\n      name=\"Tejas\"\n      url=\"https://github.com/tejasq.png\"\n      onChange={onAvatarChange}\n    /&gt;\n  );\n};\n</code></pre> <p>Now we can be confident that <code>onAvatarChange</code> will never change unless one of the things in its dependency array (second argument) changes, like the current user ID. With this, our memoization is fully complete and reliable. This is the recommended way to memoize components that have functions as props.</p> <p>Great! This now means that our memoized components will never unnecessarily rerender. Right? Wrong! There\u2019s one more thing we need to be aware of.</p>"},{"location":"js/definition/memoization/#memoization-with-usememo","title":"Memoization with <code>useMemo</code>","text":"<p><code>React.memo</code> and the <code>useMemo</code> hook are both tools for memoization, but with very different purposes. <code>React.memo</code> memoizes an entire component to keep it from rerendering. <code>useMemo</code> memoizes a specific calculation inside a component, to avoid expensive recalculations and preserve a consistent reference for the result.</p>"},{"location":"js/definition/memoization/#usememo-considered-harmful","title":"<code>useMemo</code> Considered Harmful","text":"<p>While it might be tempting to wrap all variable declarations inside a component with <code>useMemo</code>, this isn\u2019t always beneficial. <code>useMemo</code> is particularly valuable for memoizing computationally expensive operations or maintaining stable references to <code>objects</code> and <code>arrays</code>.</p> <p>For scalar values, such as <code>strings</code>, <code>numbers</code>, or <code>booleans</code>, using <code>useMemo</code> is typically unnecessary. This is because these scalar values are passed and compared by their actual value in JavaScript, not by reference. So every time you set or compare a scalar value, it\u2019s the actual value you\u2019re working with, not a reference to a memory location that might change.</p> <p></p>"},{"location":"js/definition/memoization/#reference","title":"Reference","text":"<ul> <li>Fluent React by Tejas Kumar , pg-97</li> </ul>"},{"location":"js/ecmascript/defaultParameters/","title":"defaultParameters","text":""},{"location":"js/ecmascript/defaultParameters/#defaultparameters-ecmascript-6","title":"defaultParameters (ECMAScript 6)","text":"<p>Many languages allow you to choose default values for arguments in the method signature. Finally, in <code>ECMAScript 6 (ES 6)</code>, JavaScript will be one of those languages</p> <pre><code>var join = function (\n  foo = \"foo\",\n  baz = foo === \"foo\" ? join(foo + \"!\") : \"baz\"\n) {\n  return foo + \":\" + baz;\n};\n\n// =&gt; hi:there\nconsole.log(join(\"hi\", \"there\"));\n\n// Use the default parameter when not supplied\n// =&gt; hi:baz\nconsole.log(join(\"hi\"));\n\n// Use the default parameter when undefined is supplied\n// =&gt; foo:there\n\nconsole.log(join(undefined, \"there\"));\n\n// Use an expression which has access to the current set of arguments\n// =&gt; foo:foo!:baz\nconsole.log(join(\"foo\"));\n</code></pre>"},{"location":"js/ecmascript/defaultParameters/#reference","title":"Reference","text":"<ul> <li>Expert JavaScript by Mark E. Daggett</li> </ul>"},{"location":"js/ecmascript/es6/","title":"Intro","text":""},{"location":"js/ecmascript/es6/#javascript-es6","title":"JavaScript ES6","text":"<p>ES6 is a significant update. It contains a whole host of new features for JavaScript, almost two dozen in total. JavaScript written in ES6 is tangibly different than JavaScript written in ES5.</p> <p>The most important ECMAScript version is generally considered to be <code>ECMAScript 2015 (ES6)</code>. Here are the reasons why ES6 is so significant:</p>"},{"location":"js/ecmascript/es6/#impact-of-es6","title":"Impact of ES6:","text":"<ul> <li>Modern JavaScript: ES6 transformed JavaScript into a more modern, powerful, and developer-friendly language.</li> <li>Tooling and Frameworks: Many modern JavaScript frameworks and libraries (e.g., React, Angular, Vue.js) heavily utilize ES6 features.</li> <li>Backward Compatibility: Tools like Babel allow developers to write ES6+ code while maintaining compatibility with older browsers.</li> <li>Standardization: Set the foundation for annual updates to the ECMAScript specification, ensuring continuous improvement of the language.</li> </ul> <p>Due to these significant enhancements and its foundational role in modern JavaScript development, ECMAScript 2015 (ES6) is often regarded as the most important ECMAScript version.</p>"},{"location":"js/ecmascript/es6/#key-features-of-es6","title":"Key Features of ES6:","text":"React <p>There are two ways to declare React components:</p> <ol> <li>ES6 classes</li> <li>Function components</li> </ol> <p>An example of using an ES6 class:</p> <pre><code>class HelloWorld extends React.Component {\n    render() { return &lt;p&gt;Hello, world!&lt;/p&gt;; }\n}\n</code></pre> <p>The same component written in a \u201cfunctional component\u201d style:</p> <pre><code>function HelloWorld() {\n    return &lt;p&gt;Hello, world!&lt;/p&gt;;\n}\n</code></pre> <p>At the time of writing, both types of declarations are in widespread use. </p> <p>While they both do essentially the same thing, there are some important differences that we\u2019ll get to later in the book.</p> <p>We\u2019ll be using ES6 class components through much of the book, but we\u2019ll be using function components from time-to-time as well. While it might seem cleaner to just pick one, you\u2019ll encounter (and use) both in your real-world work. So we\u2019ll cover both.</p> <ul> <li>Fullstack React The Complete Guide to ReactJS and Friends by Anthony Accomazzo :21</li> </ul>"},{"location":"js/ecmascript/spread-vs-rest-operator/","title":"Spread vs Rest Operator","text":""},{"location":"js/ecmascript/spread-vs-rest-operator/#spread-vs-rest-polar-opposite-twins","title":"Spread vs. Rest <code>\u2014 Polar Opposite Twins</code>","text":"<p>One will have observed that the syntax for the rest parameter and the spread operator is identical, but their behavior is the exact opposite of one another. The rest parameter \u201ccollects\u201d all the unaccounted arguments supplied to a function into an array, while the spread operator extracts all the elements out of an array. What differentiates what the ... syntax does depends on the invocation context. ... only acts as the rest parameter when an assignment happens, and if not, then it acts as a spread operator. This contradiction can be both interesting and disconcerting at the same time:</p> <p>Differences Between Spread and Rest</p> <ol> <li> <p>Spread Operator: Expands an array or object into individual elements.</p> <ul> <li>Example: <code>...array</code></li> </ul> </li> <li> <p>Rest Operator: Collects multiple elements into a single array.</p> <ul> <li>Example: <code>...args</code></li> </ul> </li> </ol> <p>Tip</p>"},{"location":"js/ecmascript/spread-vs-rest-operator/#destructuring","title":"Destructuring","text":"Array DestructuringObject DestructuringCombination"},{"location":"js/ecmascript/spread-vs-rest-operator/#reference","title":"Reference","text":"<ul> <li>JavaScript Next by Raju Gandhi, pg: 48</li> </ul>"},{"location":"js/essential/array-prototype/","title":"Array Prototype","text":""},{"location":"js/essential/array-prototype/#array-prototype","title":"Array Prototype","text":"<p>In JavaScript, the Array prototype is an object that contains methods and properties available to all arrays. When you create a new array, it inherits these methods and properties through its prototype chain.</p> <p>Here's how the prototype chain works for arrays:</p> <ul> <li>When you create an array like <code>let myArray = [1, 2, 3];</code>, myArray inherits from <code>Array.prototype</code>.</li> <li>Array.prototype is itself an object that inherits from Object.prototype.</li> </ul>"},{"location":"js/essential/array-prototype/#why-is-the-array-prototype-important","title":"Why is the Array Prototype Important?","text":"<ul> <li> <p>Inheritance:</p> <p>All arrays have access to the methods defined on Array.prototype. This means you can call methods like push, pop, map, filter, etc., on any array.</p> <pre><code>let myArray = [1, 2, 3];\nmyArray.push(4);\nconsole.log(myArray); // [1, 2, 3, 4]\n</code></pre> </li> <li> <p>Extensibility:</p> <p>You can add custom methods to all arrays by modifying <code>Array.prototype</code>. However, this is generally discouraged in practice because it can lead to conflicts and unexpected behavior, especially in shared environments or libraries.</p> <pre><code>Array.prototype.first = function() {\n    return this[0];\n};\n\nlet myArray = [1, 2, 3];\nconsole.log(myArray.first()); // 1\n</code></pre> </li> <li> <p>Efficiency:</p> <p>By defining methods on the prototype, JavaScript ensures that only one copy of each method exists in memory, regardless of the number of arrays you create. This is more efficient than defining the same method individually for each array instance.</p> </li> </ul>"},{"location":"js/essential/array-prototype/#example-of-adding-a-custom-method-to-array-prototype","title":"Example of Adding a Custom Method to Array Prototype","text":"<pre><code>Array.prototype.last = function() {\n  return this[this.length - 1];\n};\n\nlet myArray = [1, 2, 3, 4];\nconsole.log(myArray.last()); // 4\n</code></pre> <p>In this example:</p> <ul> <li>We add a last method to <code>Array.prototype</code>, which returns the last element of the array.</li> <li>All arrays now have access to this <code>last</code> method.</li> </ul>"},{"location":"js/essential/array-prototype/#summary","title":"Summary","text":"<ul> <li> <p>Higher-order functions are functions that operate on other functions, either by taking them as arguments or by returning them. Many array methods in JavaScript are higher-order functions.</p> </li> <li> <p>The Array prototype is an object from which all arrays inherit their methods and properties. It allows for method sharing and efficient memory use, as well as extensibility by adding custom methods.</p> </li> </ul>"},{"location":"js/essential/array-prototype/#most-important-about-array","title":"Most Important about Array","text":"<p>One of the most important things to learn about arrays in JavaScript to master advanced programming is understanding and effectively utilizing higher-order functions provided by the Array prototype. These functions include methods like <code>map()</code>, <code>filter()</code>, <code>reduce()</code>, <code>forEach()</code>, <code>find()</code>, <code>some()</code>, and <code>every()</code>. Mastering these functions allows you to write concise, expressive, and efficient code for manipulating and processing arrays</p> Example and Explanation of Key Higher-Order Functions: <ol> <li> <p>map():</p> <p>Creates a new array populated with the results of calling a provided function on every element in the calling array.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst doubled = numbers.map(num =&gt; num * 2);\nconsole.log(doubled); // [2, 4, 6, 8]\n</code></pre> </li> <li> <p>filter():</p> <p>Creates a new array with all elements that pass the test implemented by the provided function.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst evens = numbers.filter(num =&gt; num % 2 === 0);\nconsole.log(evens); // [2, 4]\n</code></pre> </li> <li> <p>reduce():</p> <p>Executes a reducer function on each element of the array, resulting in a single output value.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst sum = numbers.reduce((accumulator, currentValue) =&gt; accumulator + currentValue, 0);\nconsole.log(sum); // 10\n</code></pre> </li> <li> <p>forEach():</p> <p>Executes a provided function once for each array element.</p> <pre><code>const numbers = [1, 2, 3, 4];\nnumbers.forEach(num =&gt; console.log(num));\n// Outputs: 1, 2, 3, 4\n</code></pre> </li> <li> <p>find():</p> <p>Returns the value of the first element in the provided array that satisfies the provided testing function.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst firstEven = numbers.find(num =&gt; num % 2 === 0);\nconsole.log(firstEven); // 2\n</code></pre> </li> <li> <p>some():</p> <p>Tests whether at least one element in the array passes the test implemented by the provided function. It returns a Boolean value.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst hasEven = numbers.some(num =&gt; num % 2 === 0);\nconsole.log(hasEven); // true\n</code></pre> </li> <li> <p>every():</p> <p>Tests whether all elements in the array pass the test implemented by the provided function. It returns a Boolean value.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst allEven = numbers.every(num =&gt; num % 2 === 0);\nconsole.log(allEven); // false\n</code></pre> </li> </ol>"},{"location":"js/essential/array-prototype/#why-mastering-these-functions-is-important","title":"Why Mastering These Functions is Important:","text":"<ul> <li>Expressiveness: They allow you to express complex operations on arrays concisely and declaratively.</li> <li>Readability: Code written with these methods is often more readable and easier to understand, as it closely matches the high-level description of the logic.</li> <li>Functional Programming: These methods are fundamental to functional programming techniques, which are powerful for writing clean, maintainable, and bug-resistant code.</li> <li>Efficiency: They are optimized for performance in most JavaScript engines, making them efficient for large datasets.</li> </ul> <p>Understanding and mastering these higher-order functions will significantly enhance your ability to write advanced and efficient JavaScript code.</p>"},{"location":"js/essential/array/","title":"Array","text":""},{"location":"js/essential/array/#array","title":"Array","text":""},{"location":"js/essential/array/#why-is-an-array-an-object-in-javascript","title":"Why is an Array an Object in JavaScript?","text":"<p>In JavaScript, arrays are a type of object because the language is designed around the concept of objects as the fundamental building blocks. Here are a few reasons why arrays are implemented as objects in JavaScript:</p> <ul> <li> <p>Unified Data Structure: JavaScript is a language designed to be flexible and dynamic. By treating arrays as objects, JavaScript can leverage the existing object infrastructure, providing a unified way to handle collections of data.</p> </li> <li> <p>Dynamic Properties and Methods: As objects, arrays can have properties and methods. This allows for powerful features like dynamic resizing, and built-in methods (e.g., <code>push</code>, <code>pop</code>, <code>map</code>, <code>filter</code>) that make working with arrays convenient.</p> </li> <li> <p>Flexibility: Arrays being objects allow them to be extended and manipulated in ways that more rigid, statically-typed arrays in other languages might not support. This fits well with JavaScript's dynamic and loosely-typed nature.</p> </li> </ul>"},{"location":"js/essential/array/#are-arrays-objects-in-other-programming-languages","title":"Are Arrays Objects in Other Programming Languages?","text":"<p>The treatment of arrays varies across different programming languages:</p> <ul> <li> <p>C/C++: In languages like <code>C</code> and <code>C++</code>, arrays are not objects. They are contiguous blocks of memory with a fixed size. Arrays in these languages are more primitive and have limited functionality compared to JavaScript arrays.</p> </li> <li> <p>Java: In Java, arrays are objects. They are instances of a class and have a fixed size once created. They also have properties (like <code>length</code>) and methods.</p> </li> <li> <p>Python: In Python, the closest equivalent to JavaScript arrays is the list. Lists are objects in Python, with dynamic sizing and many built-in methods, similar to JavaScript arrays.</p> </li> <li> <p>Ruby: In Ruby, arrays are also objects. They are instances of the Array class and come with a rich set of methods for manipulation.</p> </li> </ul>"},{"location":"js/essential/array/#reason-behind-the-design-choice","title":"Reason Behind the Design Choice","text":"<p>The decision to make arrays objects in JavaScript (and other high-level languages) often comes down to the following reasons:</p> <ul> <li> <p>Consistency: By making arrays objects, the language maintains a consistent approach to data structures. Everything is an object, which simplifies the language model and makes it easier to learn and use.</p> </li> <li> <p>Extensibility: Arrays as objects can be easily extended with new properties and methods. This allows for more powerful and flexible programming paradigms.</p> </li> <li> <p>Ease of Use: Built-in methods and properties provided by the array object simplify many common tasks, reducing the need for boilerplate code and making the language more expressive and productive for developers.</p> </li> </ul>"},{"location":"js/essential/array/#summary","title":"Summary","text":"<ul> <li>In JavaScript: Arrays are objects to provide a consistent, flexible, and powerful way to handle collections of data.</li> <li>In Other Languages: The treatment of arrays varies, with some languages treating them as primitive types and others as objects.</li> <li>Design Reasons: Making arrays objects allows for extensibility, ease of use, and a unified data structure model.</li> </ul> <p>This design choice reflects JavaScript's overall philosophy of being a flexible and dynamic language, aiming to simplify and enhance the developer experience.</p> what is exactly an array in javascript. <p>Yes, in JavaScript, an array is indeed a type of object. Here's a more detailed explanation:</p> is array an object in javascript <p>In JavaScript, arrays are a type of object. Specifically, they are a specialized type of object designed to store indexed collections of data. Arrays in JavaScript can hold various types of data (such as <code>numbers</code>, <code>strings</code>, <code>objects</code>, or even other <code>arrays</code>) and provide methods for manipulating those data elements.</p> <pre><code>let myArray = [1, 2, 3, 4, 5]; // An array of numbers\n\nconsole.log(typeof myArray); // Outputs: object\nconsole.log(Array.isArray(myArray)); // Outputs: true\n</code></pre> <p>Even though <code>typeof myArray</code> returns \"object\", you can use Array.isArray() to specifically check if a variable is an array. Arrays have additional properties and methods compared to regular objects, such as length for the number of elements and methods like <code>push</code>, <code>pop</code>, <code>forEach</code>, etc., for array manipulation.</p> what do you mean by type of object. is it exactly object? what is it? if it is an object then why do we need isArray <p>In JavaScript, the <code>typeof</code> operator can return several values, including \"object\" for objects and arrays. However, arrays are a specialized type of object with additional features and behaviors tailored specifically for handling ordered collections of data.</p> <p>Here's why <code>Array.isArray()</code> is useful:</p> <ul> <li> <p>Clarity: Arrays and objects are both considered \"object\" types by <code>typeof</code>, so Array.isArray() provides a clear and specific way to determine if a variable is an array.</p> </li> <li> <p>Behavior: Arrays in JavaScript have specialized methods and properties (length, push, pop, etc.) that make them distinct from regular objects. Using Array.isArray() ensures that you are working with an array and can safely use array-specific methods without encountering unexpected behavior.</p> </li> <li> <p>Compatibility: In older versions of JavaScript, before Array.isArray() was introduced in ECMAScript 5 (2009), checking if an object was an array was less straightforward. Array.isArray() provides a reliable cross-browser way to perform this check.</p> </li> </ul> <p>Here\u2019s an example of how you might use Array.isArray():</p> <pre><code>let myArray = [1, 2, 3];\nlet myObject = { key: 'value' };\n\nconsole.log(Array.isArray(myArray)); // true\nconsole.log(Array.isArray(myObject)); // false\n\n// Using typeof\nconsole.log(typeof myArray); // \"object\"\nconsole.log(typeof myObject); // \"object\"\n</code></pre> <p>So, while arrays are objects in JavaScript, Array.isArray() is necessary to distinguish arrays from other types of objects and ensure correct behavior when working with arrays.</p> so why do we need array object type and Array.isArray() <p>The distinction between arrays and regular objects in JavaScript, as well as the use of Array.isArray(), serves several important purposes:</p> <ol> <li> <p>Specialized Functionality:</p> <p>Arrays are specialized objects designed specifically for storing ordered collections of data. They come with built-in methods (push, pop, forEach, etc.) that make it easy to manipulate and iterate over their elements. This specialization allows for efficient handling of sequential data, which is common in programming tasks.</p> </li> <li> <p>Type Checking:</p> <p>JavaScript's typeof operator returns \"object\" for both arrays and regular objects. However, arrays have distinct behavior and capabilities compared to generic objects. Array.isArray() provides a reliable way to specifically check if a variable is an array, ensuring that you can safely use array-specific methods without encountering errors or unexpected behavior.</p> </li> <li> <p>Compatibility:</p> <p>Prior to the introduction of Array.isArray() in ECMAScript 5 (2009), developers often used less reliable methods to check if an object was an array (such as checking for the presence of array-specific methods like push). Array.isArray() provides a standardized and cross-browser-compatible approach to this check.</p> </li> <li> <p>Code Readability:</p> <p>Explicitly using Array.isArray() improves the readability and maintainability of your code. It clearly communicates your intention to check whether a variable is an array, making the code easier to understand for other developers who may work with or maintain it in the future.</p> </li> </ol> <p>In essence, while arrays are objects in JavaScript, they have specialized features that distinguish them from regular objects. Array.isArray() is a utility function that ensures clarity, reliability, and compatibility when working with arrays, helping developers write more robust and understandable code.</p>"},{"location":"js/essential/array/#what-is-an-array","title":"What is an Array?","text":"<p>An array in JavaScript is a special type of object used to store multiple values in a single variable. Unlike regular objects, which use named keys to store values, arrays use numeric indices.</p>"},{"location":"js/essential/array/#characteristics-of-arrays","title":"Characteristics of Arrays","text":"<ol> <li>Indexed Collection: Arrays are indexed, meaning each element in the array has a numbered position (starting from 0).</li> <li>Dynamic Size: Arrays can grow and shrink in size dynamically as elements are added or removed.</li> <li>Zero-based Index: The index of the first element is 0, the second element is 1, and so on.</li> <li>Heterogeneous Elements: Arrays can store elements of different types (numbers, strings, objects, other arrays, etc.).</li> </ol> Example of an Array<pre><code>let fruits = ['Apple', 'Banana', 'Cherry'];\n</code></pre> <p>In this example, <code>fruits</code> is an array containing three string elements.</p>"},{"location":"js/essential/array/#arrays-are-objects","title":"Arrays are Objects","text":"<p>Internally, arrays are a specialized type of object. You can verify this by using the typeof operator:</p> javascript<pre><code>console.log(typeof fruits); // \"object\"\n</code></pre> <p>Despite being objects, arrays have special properties and methods that make them particularly useful for working with ordered collections of data. For example:</p> <ul> <li>length property: Returns the number of elements in the array.</li> <li>push method: Adds one or more elements to the end of the array.</li> <li>pop method: Removes the last element from the array.</li> <li>map method: Creates a new array with the results of calling a provided function on every element in the array.</li> </ul>"},{"location":"js/essential/array/#key-differences-between-arrays-and-objects","title":"Key Differences Between <code>Arrays</code> and <code>Objects</code>","text":"<ul> <li>Indexing: Arrays are indexed using numeric indices, while objects use named keys.</li> <li>Length Property: Arrays have a <code>length</code> property that keeps track of the number of elements. Objects do not have a built-in <code>length</code> property.</li> <li>Iteration: Arrays can be easily iterated using loops (like <code>for</code>, <code>for...of</code>, <code>forEach</code>). Iterating over an object typically requires using a <code>for...in</code> loop or <code>Object.keys()</code>.</li> </ul>"},{"location":"js/essential/array/#summary_1","title":"Summary","text":"<ul> <li>Arrays are objects with additional functionality suited for storing ordered collections of data.</li> <li>They provide methods and properties that make it easier to manipulate sequences of values.</li> </ul> Example: some common array operations<pre><code>let numbers = [1, 2, 3, 4, 5];\n\nconsole.log(numbers.length); // 5\nnumbers.push(6);\nconsole.log(numbers); // [1, 2, 3, 4, 5, 6]\nnumbers.pop();\nconsole.log(numbers); // [1, 2, 3, 4, 5]\n\nnumbers.forEach(num =&gt; console.log(num * 2)); // 2, 4, 6, 8, 10\n</code></pre>"},{"location":"js/essential/array/#example","title":"Example","text":"<p>Tip</p> <p>Certainly! Here are basic and advanced examples demonstrating the usage of <code>Array.isArray()</code> in JavaScript:</p> Basic ExampleAdvanced Example javascript<pre><code>// Basic example\nlet arr = [1, 2, 3];\n\nconsole.log(Array.isArray(arr)); // true\n\nlet obj = { name: 'John', age: 30 };\n\nconsole.log(Array.isArray(obj)); // false\n</code></pre> <p>In this basic example:</p> <ul> <li>Array.isArray(arr) returns true because arr is an array.</li> <li>Array.isArray(obj) returns false because obj is a plain object, not an array.</li> </ul> javascript<pre><code>function processArray(input) {\n    if (Array.isArray(input)) {\n        input.forEach(item =&gt; console.log(item));\n    } else {\n        console.log(\"Input is not an array.\");\n    }\n}\n\nlet arr = [1, 2, 3];\nlet obj = { name: 'Jane', age: 25 };\n\nprocessArray(arr); // Outputs: 1, 2, 3\nprocessArray(obj); // Outputs: \"Input is not an array.\"\n</code></pre> <p>In this advanced example:</p> <ul> <li>The <code>processArray</code> function takes <code>input</code> as a parameter.</li> <li>Inside the function, <code>Array.isArray(input)</code> checks if <code>input</code> is an array.</li> <li>If <code>input</code> is an array, it iterates over its elements using <code>forEach</code>.</li> <li>If <code>input</code> is not an array, it outputs a message indicating that it's not an array.</li> </ul> <p>These examples illustrate how <code>Array.isArray()</code> can be used to safely and reliably determine whether a variable is an array before performing operations specific to arrays. This helps prevent errors and ensures that your code behaves as expected in different scenarios.</p>"},{"location":"js/essential/object-object.prototype/","title":"Object & Object.Prototype","text":"<p>The difference between <code>Object</code> and <code>Object.prototype</code> in JavaScript lies in their roles and usage within the language. Here's an in-depth explanation:</p>"},{"location":"js/essential/object-object.prototype/#1-object","title":"1. Object","text":"<ul> <li>Definition: Object is a built-in global constructor function in JavaScript.</li> <li>Purpose: It is used to create and manage objects, and it also provides utility methods for working with objects.</li> </ul> Key Characteristics <ul> <li>It's a function that serves as the parent of all objects in JavaScript.</li> <li>Provides static methods like <code>Object.keys()</code>, <code>Object.values()</code>, <code>Object.entries()</code>, etc.</li> <li>You can use it to create objects explicitly: <code>new Object()</code> (though <code>Object.create()</code> or object literals <code>{}</code> are more common).</li> </ul> <pre><code>// Using Object as a constructor\nconst obj1 = new Object();\nobj1.name = \"Alice\";\nconsole.log(obj1); // { name: 'Alice' }\n\n// Using static methods provided by Object\nconst obj2 = { a: 1, b: 2 };\nconsole.log(Object.keys(obj2)); // ['a', 'b']\nconsole.log(Object.values(obj2)); // [1, 2]\nconsole.log(Object.entries(obj2)); // [['a', 1], ['b', 2]]\n</code></pre>"},{"location":"js/essential/object-object.prototype/#2-objectprototype","title":"2. Object.prototype","text":"<ul> <li>Definition: <code>Object.prototype</code> is the prototype object from which all JavaScript objects inherit properties and methods.</li> <li>Purpose: It acts as the base object, and every object created in JavaScript implicitly links to <code>Object.prototype</code> (or a prototype that inherits from it).</li> </ul> Key Characteristics <ul> <li>Contains instance methods like <code>.toString()</code>, <code>.hasOwnProperty()</code>, <code>.isPrototypeOf()</code>, etc.</li> <li>When you create an object, its prototype chain ultimately leads to <code>Object.prototype</code>.</li> <li>It defines the default behavior for all objects unless overridden.</li> </ul> <pre><code>const obj3 = { a: 1 };\n\n// Accessing methods from Object.prototype\nconsole.log(obj3.hasOwnProperty(\"a\")); // true\nconsole.log(obj3.toString()); // [object Object]\n\n// Adding a custom method to Object.prototype\nObject.prototype.greet = function () {\n  return \"Hello from Object.prototype!\";\n};\nconsole.log(obj3.greet()); // \"Hello from Object.prototype!\"\n\n// Caution: Modifying Object.prototype affects all objects\n</code></pre>"},{"location":"js/essential/object-object.prototype/#3-key-differences-between-object-and-objectprototype","title":"3. Key Differences Between <code>Object</code> and <code>Object.prototype</code>","text":"Feature <code>Object</code> <code>Object.prototype</code> Type Constructor function Prototype object Purpose Used to create objects and access static methods Provides default methods and properties to all objects Access Static methods like <code>Object.keys()</code> Instance methods like <code>.toString()</code> Inheritance Does not inherit from anything Root of the prototype chain Extensibility Adding properties or methods is uncommon Can extend to modify behavior of all objects Example Methods <code>Object.keys()</code>, <code>Object.create()</code> <code>.hasOwnProperty()</code>, <code>.toString()</code>"},{"location":"js/essential/object-object.prototype/#4-how-they-work-together","title":"4. How They Work Together","text":"<p>When you create an object, it inherits from <code>Object.prototype</code>. For example:</p> <pre><code>const myObj = { a: 1 };\n\n// Prototype chain\nconsole.log(Object.getPrototypeOf(myObj) === Object.prototype); // true\n</code></pre>"},{"location":"js/essential/object-object.prototype/#5-visualizing-the-relationship","title":"5. Visualizing the Relationship","text":"<pre><code>Object\n \u2514\u2500&gt; Object.prototype\n       \u2514\u2500&gt; myObj\n</code></pre> <ul> <li><code>Object.prototype</code> is the prototype of all plain objects.</li> <li><code>Object</code> is the global constructor function that creates objects and provides static methods.</li> </ul>"},{"location":"js/essential/object-object.prototype/#also-similar-to-array-function","title":"Also Similar to Array &amp; Function","text":"<pre><code>Array\n \u2514\u2500&gt; Array.prototype\n       \u2514\u2500&gt; myArray\n</code></pre> <pre><code>Function\n \u2514\u2500&gt; Function.prototype\n       \u2514\u2500&gt; myFunction\n</code></pre>"},{"location":"js/essential/object-object.prototype/#constructor","title":"Constructor","text":"<ul> <li>Number() constructor function</li> <li>String() constructor function</li> <li>Boolean() constructor function</li> <li>Object() constructor function</li> <li>Array() constructor function</li> <li>Function() constructor function</li> </ul>"},{"location":"js/essential/object-object.prototype/#array","title":"Array","text":"<p>An array is an ordered list of values typically created with the intention of looping through numerically indexed values, beginning with the index zero.</p> <p>What you need to know is that arrays are numerically ordered sets, as opposed to objects which have property names associated with values in non-numeric order.</p> <p>Essentially, arrays use numbers as a lookup key, while objects have user-defined property names. JavaScript does not have true associative arrays, but objects can be used to achieve the functionality of associative arrays.</p> <pre><code>var myArray = [\"blue\", \"green\", \"orange\", \"red\"];\nconsole.log(myArray[0]); // Logs blue using the 0 index to access the string in myArray.\n\n// Versus\n\nvar myObject = {\n  // aka an associative array/hash, known as an object in JavaScript.\n  blue: \"blue\",\n  green: \"green\",\n  orange: \"orange\",\n  red: \"red\",\n};\n</code></pre> Note <p>Arrays can hold any type of values, and these values can be updated or deleted at any time.</p> <p>If you need a hash (aka associative array), an object is the closest solution.</p> <p>An Array() is just a special type of Object(). That is, Array() instances are basically Object() instances with a couple of extra functions (e.g., <code>.length</code> and a built-in numeric index).</p> <p><code>Values</code> contained in an array are commonly referred to as <code>elements</code>.</p> <ul> <li>JavaScript Succinctly by Cody Lindley - 119</li> </ul> <p>In JavaScript, objects are king: Almost everything is an object or acts like an object. Understand objects and you will understand JavaScript.</p> <ul> <li>JavaScript Succinctly by Cody Lindley - 16</li> </ul>"},{"location":"js/essential/object-prototype/","title":"Object Prototype","text":""},{"location":"js/essential/object-prototype/#objectprototype","title":"Object.prototype","text":"<p>In JavaScript, Object.prototype is the prototype object from which all other objects inherit their properties and methods, unless explicitly specified otherwise. It is the top of the prototype chain, meaning that any object created using a constructor function or an object literal will have Object.prototype in its prototype chain.</p>"},{"location":"js/essential/object-prototype/#what-is-objectprototype","title":"What is Object.prototype?","text":"<ul> <li> <p>Prototype Chain:</p> <p>In JavaScript, objects can have a prototype, which is another object from which they inherit properties. The prototype of an object is accessible through the <code>__proto__</code> property (or <code>[[Prototype]]</code> in more formal terms).</p> </li> <li> <p>Inheritance:</p> <p><code>Object.prototype</code> is the final object in the prototype chain. It means that all properties and methods defined on <code>Object.prototype</code> are available to all other objects, unless those properties and methods are overridden further down the prototype chain.</p> </li> </ul>"},{"location":"js/essential/object-prototype/#common-properties-and-methods-from-objectprototype","title":"Common Properties and Methods from <code>Object.prototype</code>","text":"<p>Object.prototype includes several methods and properties that are useful and commonly used:</p> <ol> <li> <p>hasOwnProperty:</p> <p>Checks if a property is a direct property of the object (not inherited).</p> <pre><code>const obj = { a: 1 };\nconsole.log(obj.hasOwnProperty('a')); // true\nconsole.log(obj.hasOwnProperty('toString')); // false\n</code></pre> </li> <li> <p>isPrototypeOf:</p> <p>Checks if an object exists in another object's prototype chain.</p> <pre><code>function Person() {}\nconst person = new Person();\nconsole.log(Person.prototype.isPrototypeOf(person)); // true\n</code></pre> </li> <li> <p>toString:</p> <p>Returns a string representation of the object.</p> <pre><code>const obj = { a: 1 };\nconsole.log(obj.toString()); // \"[object Object]\"\n</code></pre> </li> <li> <p>valueOf:</p> <p>Returns the primitive value of the specified object.</p> <pre><code>const obj = { a: 1 };\nconsole.log(obj.valueOf()); // { a: 1 }\n</code></pre> </li> </ol> <p>Prototype Chain Example</p>"},{"location":"js/essential/object-prototype/#prototype-chain-example","title":"Prototype Chain Example","text":"<p>To better understand Object.prototype and the prototype chain, consider the following example:</p> <pre><code>const person = {\n    name: 'John',\n    greet: function() {\n        console.log('Hello, ' + this.name);\n    }\n};\n\n// Create a new object that inherits from person\nconst anotherPerson = Object.create(person);\nanotherPerson.name = 'Jane';\n\nanotherPerson.greet(); // Hello, Jane\n\n// Check the prototype chain\nconsole.log(Object.getPrototypeOf(anotherPerson) === person); // true\nconsole.log(Object.getPrototypeOf(person) === Object.prototype); // true\n</code></pre> <p>In this example:</p> <ol> <li>We define an object <code>person</code> with a property <code>name</code> and a method <code>greet</code>.</li> <li>We create a new object <code>anotherPerson</code> that inherits from person using Object.create.</li> <li>The <code>anotherPerson</code> object can access properties and methods from <code>person</code> because <code>person</code> is in its prototype chain.</li> <li>We verify the prototype chain using Object.getPrototypeOf.</li> </ol>"},{"location":"js/essential/object-prototype/#customizing-objectprototype","title":"Customizing Object.prototype","text":"<p>While it is possible to add properties or methods to Object.prototypeit is generally discouraged== because it can lead to unexpected behavior and conflicts in your code, especially when working with third-party libraries. Modifying Object.prototype affects all objects, which can have unintended side effects.</p> <pre><code>Object.prototype.customMethod = function() {\n  console.log('This is a custom method.');\n};\n\nconst obj = {};\nobj.customMethod(); // This is a custom method.\n</code></pre> <p>In this example, the <code>customMethod</code> is added to Object.prototype, making it available to all objects. However, this practice should be used with caution.</p>"},{"location":"js/essential/object-prototype/#summary","title":"Summary","text":"<ul> <li>Object.prototype is the top-level prototype object from which all other objects inherit properties and methods.</li> <li>It provides several built-in methods like <code>hasOwnProperty</code>, <code>isPrototypeOf</code>, <code>toString</code>, and <code>valueOf</code>.</li> <li>All objects in JavaScript have Object.prototype in their prototype chain unless explicitly specified otherwise.</li> <li>Modifying Object.prototype is possible but generally discouraged due to the potential for unintended side effects.</li> </ul>"},{"location":"js/essential/object/","title":"Object","text":""},{"location":"js/essential/object/#object","title":"Object","text":""},{"location":"js/essential/object/#question","title":"Question","text":"<p>what is exactly object in programming language. why it is called the king in programming language. where does it exist. where does not it exist. how does it transfer in http protocal.\"</p> <p>An object in programming is an instance of a class that encapsulates both data and methods that operate on that data. Objects are fundamental building blocks in object-oriented programming (OOP) and represent real-world entities and concepts within the code.</p> <p>Tip</p> <p>Success</p> <p>Danger</p> <p>Example</p>"},{"location":"js/essential/object/#why-is-an-object-called-the-king-in-programming","title":"Why is an Object Called the \"King\" in Programming?","text":"<ul> <li>Encapsulation: Objects bundle data and methods that operate on the data, ensuring a modular and organized code structure.</li> <li>Abstraction: Objects provide a simplified interface to interact with complex systems, hiding unnecessary details.</li> <li>Inheritance: Objects can inherit properties and methods from other objects, promoting code reuse and efficiency.</li> <li>Polymorphism**: Objects can take many forms, allowing methods to be used interchangeably across different classes.</li> </ul> <p>These principles make objects central to OOP, hence they are often referred to as the \"king\" in programming.</p>"},{"location":"js/essential/object/#where-do-objects-exist","title":"Where Do Objects Exist?","text":"<ul> <li>Object-Oriented Programming Languages: Objects are fundamental in languages like <code>Java</code>, <code>C++</code>, <code>Python</code>, <code>Ruby</code>, and <code>JavaScript</code>.</li> <li>In Memory: At runtime, objects exist in a computer's memory, where they are instantiated, manipulated, and used by the program.</li> </ul>"},{"location":"js/essential/object/#where-do-objects-not-exist","title":"Where Do Objects Not Exist?","text":"<ul> <li>Non-OOP Languages: In procedural programming languages like <code>C</code> (not C++), there is no concept of objects. Code is organized around procedures or functions.</li> <li>Static Resources: Objects do not exist in static resources like <code>plain text files</code>, simple scripts, or configuration files, which do not use OOP principles.</li> </ul>"},{"location":"js/essential/object/#how-do-objects-transfer-in-http-protocol","title":"How Do Objects Transfer in HTTP Protocol?","text":"<p>Objects transfer in HTTP protocol typically <code>through serialization</code>, where the object's state is converted into a format that can be transmitted over the network. Common serialization formats include:</p> <ol> <li> <p>JSON (<code>JavaScript Object Notation</code>): Widely used due to its simplicity and readability.</p> json<pre><code>{\n    \"name\": \"Alice\",\n    \"age\": 30,\n    \"isMember\": true\n}\n</code></pre> </li> <li> <p>XML (<code>Extensible Markup Language</code>): More verbose than JSON but still commonly used.</p> xml<pre><code>&lt;person&gt;\n    &lt;name&gt;Alice&lt;/name&gt;\n    &lt;age&gt;30&lt;/age&gt;\n    &lt;isMember&gt;true&lt;/isMember&gt;\n&lt;/person&gt;\n</code></pre> </li> <li> <p>Binary Formats: <code>Protocol Buffers</code>, <code>Apache Avro</code>, or <code>MessagePack</code>, which are more efficient for data transfer but less human-readable.</p> </li> </ol> <p>The serialized object is included in the HTTP request or response body and transferred between the client and server.</p> HTTP Request Example:<pre><code>POST /api/users HTTP/1.1\nHost: example.com\nContent-Type: application/json\n\n{\n    \"name\": \"Alice\",\n    \"age\": 30,\n    \"isMember\": true\n}\n</code></pre> HTTP Response Example:<pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n    \"status\": \"success\",\n    \"data\": {\n        \"id\": 123,\n        \"name\": \"Alice\"\n    }\n}\n</code></pre>"},{"location":"js/essential/object/#dynamically-selecting-a-methodproperty","title":"Dynamically Selecting a Method/Property","text":"<p>JavaScript offers a simple syntax for dynamically selecting methods and properties, all relying on the square brackets (<code>[ ]</code>) operator. You see JavaScript has two interchangeable syntaxes for member access (that is a common dynamic language trait):</p> <pre><code>obj[expressionResultingInMemberName] == obj.memberName;\n</code></pre> <p>If you\u2019ve ever plucked a value from an Array cell using its integer index, you\u2019ve already used the square brackets operator for dynamic member selection! This is because Array objects have properties named after their numerical indices (plus the length property). However, in this case, JavaScript won\u2019t let you use the dot operator (<code>.</code>) for direct access. <code>myArray.0</code> is invalid syntax (too bad, that would have made a good nerd trick).</p> <p>Here\u2019s why using the square brackets operator (<code>[ ]</code>) is more powerful than dot notation: you can put anything in between the brackets to obtain the name of the member (property or method) that you want to access.</p> <p>Common cases include literals, variables holding the member name, name composition expressions (mostly string concatenations), and quick <code>if/then</code> choices in the form of a ternary operator (<code>condition ? valueIfTrue : valueIfFalse</code>). It\u2019ll all be turned into a string first and then used to look up the member you want to use.</p> <ul> <li>Pragmatic Guide to JavaScript by Christophe Porteneuve :pg - 18</li> </ul>"},{"location":"js/essential/object/#summary","title":"Summary","text":"<p>Objects are essential in OOP, providing a structured way to represent and manipulate data. They exist in memory and within OOP languages but not in non-OOP contexts. They transfer over HTTP through serialization into formats like JSON, XML, or binary.</p>"},{"location":"js/essential/prototype/","title":"Prototype","text":""},{"location":"js/essential/prototype/#prototype","title":"Prototype","text":""},{"location":"js/essential/prototype/#objectprototype","title":"Object.prototype","text":"<ul> <li> <p>Base Prototype:</p> <p>Object.prototype is the prototype object from which all other objects inherit, unless explicitly specified otherwise. It is the root of the prototype chain for most objects.</p> </li> <li> <p>Properties and Methods:</p> <p>It includes methods and properties that are common to all objects, such as <code>toString()</code>, <code>valueOf()</code>, <code>hasOwnProperty()</code>, <code>isPrototypeOf()</code>, and <code>propertyIsEnumerable()</code>.</p> </li> <li> <p>Role:</p> <p>Any object created using an object literal or the Object constructor will have Object.prototype in its prototype chain.</p> </li> </ul> <p>Example</p> Function.prototypeString.prototypeNumber.prototypeBoolean.prototypeDate.prototypeRegExp.prototype <p>The prototype for all function objects. It includes methods like <code>apply()</code>, <code>call()</code>, and <code>bind()</code>.</p> <pre><code>function sayHello() {\n    console.log('Hello');\n}\n\nsayHello.call(); // Hello\n</code></pre> <p>The prototype for all string objects. It includes methods like <code>charAt()</code>, <code>indexOf()</code>, <code>toUpperCase()</code>, <code>toLowerCase()</code>, <code>substring()</code>, <code>slice()</code>, and <code>replace()</code>.</p> <pre><code>const str = 'hello';\nconsole.log(str.toUpperCase()); // HELLO\n</code></pre> <p>The prototype for all number objects. It includes methods like <code>toFixed()</code>, <code>toExponential()</code>, and <code>toPrecision()</code>.</p> <pre><code>const num = 123.456;\nconsole.log(num.toFixed(2)); // 123.46\n</code></pre> <p>The prototype for all boolean objects. It has methods like <code>toString()</code> and <code>valueOf()</code>.</p> <pre><code>const bool = true;\nconsole.log(bool.toString()); // true\n</code></pre> <p>The prototype for all date objects. It includes methods like <code>getDate()</code>, <code>getDay()</code>, <code>getFullYear()</code>, <code>getHours()</code>, and <code>toISOString()</code>.</p> <pre><code>const date = new Date();\nconsole.log(date.toISOString()); // Current date in ISO format\n</code></pre> <p>The prototype for all regular expression objects. It includes methods like <code>exec()</code>, <code>test()</code>, and properties like source.</p> <pre><code>const regex = /hello/;\nconsole.log(regex.test('hello world')); // true\n</code></pre>"},{"location":"js/essential/prototype/#key-differences-and-summary","title":"Key Differences and Summary","text":"<ul> <li> <p>Purpose:</p> <p><code>Object.prototype</code> provides generic methods and properties for all objects, while Array.prototype provides specific methods and properties for array instances.</p> </li> <li> <p>Inheritance:</p> <p>All objects inherit from <code>Object.prototype</code>, but array instances additionally inherit from <code>Array.prototype</code>.</p> </li> <li> <p>Methods and Properties:</p> <p>The methods and properties on <code>Object.prototype</code>are applicable to all objects, whereas those on Array.prototype are specifically for arrays.</p> </li> </ul> <p>Understanding the prototype chain and how different prototypes provide different methods and properties is crucial for effective JavaScript programming. It helps in leveraging the full power of built-in objects and creating custom objects with shared behaviors.</p>"},{"location":"js/essential/prototype/#prototype-chain-illustration","title":"Prototype Chain Illustration","text":"<p>Here\u2019s a simplified illustration of the prototype chain for these <code>built-in</code> objects:</p> <ol> <li> <p>Function:</p> <ul> <li><code>example.__proto__ === Function.prototype</code></li> <li><code>Function.prototype.__proto__ === Object.prototype</code></li> </ul> </li> <li> <p>String:</p> <ul> <li><code>str.__proto__ === String.prototype</code></li> <li><code>String.prototype.__proto__ === Object.prototype</code></li> </ul> </li> <li> <p>Array:</p> <ul> <li><code>arr.__proto__ === Array.prototype</code></li> <li><code>Array.prototype.__proto__ === Object.prototype</code></li> </ul> </li> <li> <p>Boolean:</p> <ul> <li><code>bool.__proto__ === Boolean.prototype</code></li> <li><code>Boolean.prototype.__proto__ === Object.prototype</code></li> </ul> </li> </ol> <p>Example of Prototype Chain</p> <pre><code>function example() {}\nconst str = 'hello';\nconst arr = [1, 2, 3];\nconst bool = true;\n\n// Checking the prototype chain\nconsole.log(Object.getPrototypeOf(example) === Function.prototype); // true\nconsole.log(Object.getPrototypeOf(Function.prototype) === Object.prototype); // true\n\nconsole.log(Object.getPrototypeOf(str) === String.prototype); // true\nconsole.log(Object.getPrototypeOf(String.prototype) === Object.prototype); // true\n\nconsole.log(Object.getPrototypeOf(arr) === Array.prototype); // true\nconsole.log(Object.getPrototypeOf(Array.prototype) === Object.prototype); // true\n\nconsole.log(Object.getPrototypeOf(bool) === Boolean.prototype); // true\nconsole.log(Object.getPrototypeOf(Boolean.prototype) === Object.prototype); // true\n</code></pre>"},{"location":"js/essential/prototype/#__proto__","title":"<code>__proto__</code>","text":"<p>A hidden link that lets an object inherit properties and methods from another object.</p>"},{"location":"js/function/arrow-example/","title":"Example","text":"<p>In React, whether you use direct function references or arrow functions for event handlers can impact performance and behavior in different ways.</p> <p>Here\u2019s a breakdown of why you might choose one approach over the other:</p> Direct Reference<pre><code>const handleClickButton1 = () =&gt; console.log(\"Button 1 clicked\");\nconst handleClickButton2 = () =&gt; console.log(\"Button 2 clicked\");\n\nreturn (\n  &lt;div&gt;\n    &lt;button onClick={handleClickButton1}&gt;Button 1&lt;/button&gt;\n    &lt;button onClick={handleClickButton2}&gt;Button 2&lt;/button&gt;\n  &lt;/div&gt;\n);\n</code></pre> Arrow Function for Argument Passing<pre><code>const handleClickButtonWithData = (data) =&gt;\n  console.log(\"Button clicked with data:\", data);\n\nreturn (\n  &lt;div&gt;\n    &lt;button onClick={() =&gt; handleClickButtonWithData(recordData)}&gt;\n      Button with Data\n    &lt;/button&gt;\n  &lt;/div&gt;\n);\n</code></pre>"},{"location":"js/function/arrow-example/#summary","title":"Summary","text":"<ul> <li>Use direct function references for simplicity and better performance if no arguments are needed.</li> <li>Use arrow functions when you need to pass arguments or need more dynamic behavior for the handler.   This approach ensures that your code remains efficient and maintainable while accommodating different use cases for event handling.</li> </ul> <pre><code>import React from \"react\";\n\nconst MyComponent = () =&gt; {\n  // General function that takes data as a parameter\n  const handleClickButtonWithData = (data) =&gt; {\n    console.log(\"Button clicked with data:\", data);\n  };\n\n  // Example data\n  const recordData = { id: 1, name: \"Sample Record\" };\n\n  return (\n    &lt;div&gt;\n      {/* Using an arrow function to pass data to the general function */}\n      &lt;button onClick={() =&gt; handleClickButtonWithData(recordData)}&gt;\n        Button with Data\n      &lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default MyComponent;\n</code></pre>"},{"location":"js/function/arrow-function/","title":"Intro","text":""},{"location":"js/function/arrow-function/#arrow-functions-and-this-a-comprehensive-guide-to-context-in-modern-javascript","title":"Arrow Functions and <code>this</code>: A Comprehensive Guide to Context in Modern JavaScript","text":"<p>Understanding how arrow functions affect the this context in JavaScript is crucial for writing accurate and effective code.</p> <p>Here\u2019s a deep dive into the topic:</p> Key Concept to Remember <p>Arrow functions lexically bind <code>this</code> from their surrounding scope. This means they do not have their own <code>this</code> context, making them ideal for preserving this in callbacks and asynchronous code without additional binding.</p> <p>In traditional (general) functions, the binding of <code>this</code> depends on the context in which the function is invoked.</p>"},{"location":"js/function/arrow-function/#what-is-this","title":"What is this?","text":"<p>In JavaScript, this is a special keyword that refers to the context in which a function is executed. Its value depends on how the function is called.</p>"},{"location":"js/function/arrow-function/#in-different-contexts","title":"In Different Contexts:","text":"<ul> <li>Global Context: In the global context, <code>this</code> refers to the global object (<code>window</code> in browsers, <code>global</code> in Node.js).</li> <li>Object Method: When a function is a method of an object, <code>this</code> refers to the object the method is called on.</li> <li>Constructor Function: When a function is used as a constructor (with the <code>new</code> keyword), <code>this</code> refers to the newly created instance.</li> <li>Event Handlers: In event handlers, <code>this</code> refers to the element that triggered the event.</li> <li>Arrow Functions: Arrow functions have a unique behavior regarding <code>this</code>.</li> </ul>"},{"location":"js/function/arrow-function/#arrow-functions-and-this","title":"Arrow Functions and this","text":"<p>Arrow functions were introduced in ECMAScript 6 (ES6) and have a distinct behavior compared to regular functions:</p> <ol> <li> <p>Lexical <code>this</code> Binding: Arrow functions do not have their own <code>this</code> context. Instead, they inherit <code>this</code> from the surrounding (lexical) scope at the time they are defined.</p> <pre><code>function Timer() {\n  this.seconds = 0;\n  setInterval(() =&gt; {\n    this.seconds += 1;\n    console.log(this.seconds);\n  }, 1000);\n}\n\nconst timer = new Timer();\n// Logs: 1, 2, 3, ...\n</code></pre> <p>In this example, the arrow function inside <code>setInterval</code> uses <code>this</code> from the <code>Timer</code> function scope. If we used a regular function instead, <code>this</code> would refer to the global object or be undefined in strict mode, not the <code>Timer</code> instance.</p> </li> <li> <p>No <code>this</code> Binding Override: Unlike regular functions, arrow functions cannot have their <code>this</code> value overridden with methods like call, apply, or bind.</p> <pre><code>const obj = {\n  value: 10,\n  regularFunction: function () {\n    console.log(this.value);\n  },\n  arrowFunction: () =&gt; {\n    console.log(this.value);\n  },\n};\n\nobj.regularFunction(); // Logs: 10\nobj.arrowFunction(); // Logs: undefined (or the value of `this.value` in the global scope, which is likely `undefined`)\n</code></pre> <p>Here, <code>regularFunction</code> has <code>this</code> bound to <code>obj</code>, whereas <code>arrowFunction</code> has <code>this</code> bound to the <code>surrounding context</code> (which is the global scope in this case).</p> </li> </ol>"},{"location":"js/function/arrow-function/#why-do-we-need-arrow-functions","title":"Why Do We Need Arrow Functions?","text":"<ol> <li> <p>Simplify Code: Arrow functions provide a more concise syntax, especially useful for small functions.</p> <pre><code>const add = (a, b) =&gt; a + b;\n</code></pre> </li> <li> <p>Preserve <code>this</code> Context: In scenarios where <code>this</code> needs to be consistent across nested functions (like callbacks or event handlers), arrow functions are helpful.</p> <pre><code>class MyClass {\n  constructor() {\n    this.value = 5;\n  }\n\n  increment() {\n    setTimeout(() =&gt; {\n      this.value += 1;\n      console.log(this.value); // Correctly logs updated value\n    }, 1000);\n  }\n}\n\nconst instance = new MyClass();\ninstance.increment();\n</code></pre> </li> <li> <p>Avoid Common Pitfalls: Traditional functions can cause confusion when used as methods or callbacks due to <code>this</code> binding issues. Arrow functions mitigate these issues by keeping the <code>this</code> context consistent with the lexical scope.</p> </li> <li> <p>Functional Programming: Arrow functions align with functional programming practices by allowing cleaner and more predictable function behavior.</p> </li> </ol> Key Points to Remember <ul> <li>No Own <code>this</code>: Arrow functions do not create their own <code>this</code>. They inherit <code>this</code> from the surrounding context at the time they are defined.</li> <li>Use Cases: Use arrow functions when you need a short function with no special <code>this</code> context or when you want to preserve the <code>this</code> value from the outer scope.</li> <li>Limitations: Avoid using arrow functions as methods in objects or constructors where you need <code>this</code> to refer to the object or the instance.</li> </ul>"},{"location":"js/function/arrow-function/#summary","title":"Summary","text":"<p>Arrow functions provide a more predictable and concise way to handle <code>this</code> in JavaScript, making them especially useful in scenarios involving callbacks and asynchronous code. They simplify function syntax while preserving the lexical scope of <code>this</code>, avoiding common pitfalls associated with traditional function behavior. Understanding and leveraging these characteristics can help you write more maintainable and bug-free code.</p>"},{"location":"js/function/arrow-function/#hidden-facts-of-arrow-function","title":"Hidden Facts of Arrow Function","text":"<ol> <li> <p>No <code>prototype</code> Property</p> <p>Arrow functions do not have a <code>prototype</code> property. This means you cannot use them to create prototype-based inheritance.</p> <pre><code>const MyFunction = () =&gt; {};\nconsole.log(MyFunction.prototype); // Logs: undefined\n</code></pre> </li> </ol> Hidden Facts About Arrow Functions <ol> <li> <p>Lexical <code>this</code> Binding**: Arrow functions inherit <code>this</code> from their surrounding context, meaning they don\u2019t have their own <code>this</code>. Useful for preserving <code>this</code> in callbacks.</p> </li> <li> <p>No <code>arguments</code> Object: Arrow functions don\u2019t have their own <code>arguments</code> object. They inherit <code>arguments</code> from their outer function.</p> </li> <li> <p>Not Constructors: Arrow functions cannot be used as constructors and cannot be called with <code>new</code>.</p> </li> <li> <p>No <code>super</code> Keyword: Arrow functions do not have a <code>super</code> keyword, so they can\u2019t be used to call methods from a superclass.</p> </li> <li> <p>No <code>prototype</code> Property: Arrow functions do not have a prototype property, so they can\u2019t be used for prototypal inheritance.</p> </li> <li> <p>Not Suitable for Object Methods: Arrow functions are not ideal for defining methods on objects where <code>this</code> needs to refer to the object itself.</p> </li> <li> <p>Syntax Simplicity: They offer a concise syntax but lack flexibility in some complex scenarios, such as method chaining.</p> </li> <li> <p><code>this</code> Context in Classes: Arrow functions can be used in class constructors to preserve the <code>this</code> context, but not for all class-specific operations.</p> </li> </ol> <p>These points highlight the unique behavior and limitations of arrow functions, helping you use them effectively in JavaScript.</p>"},{"location":"js/function/defining-functions/","title":"Defining Function","text":""},{"location":"js/function/defining-functions/#defining-functions","title":"Defining Functions","text":"Defining Functions <p>This section describes three ways to create a function:</p> <ul> <li>Via a function expression</li> <li>Via a function declaration</li> <li>Via the constructor <code>Function()</code></li> </ul> <p>All functions are objects, instances of <code>Function</code>:</p> <pre><code>function id(x) {\n    return x;\n}\n\nconsole.log(id instanceof Function); // true\n</code></pre> <p>Therefore, functions get their methods from <code>Function.prototype</code>.</p> <ul> <li>Speaking JavaScript by Dr. Axel Rauschmayer</li> </ul>"},{"location":"js/function/defining-functions/#from-anonymous-to-arrow-functions","title":"From Anonymous to Arrow Functions","text":"<p>JavaScript has three different ways to define a function.</p>"},{"location":"js/function/defining-functions/#named-function","title":"Named Function","text":"<p>A named function uses the <code>function</code> keyword followed by the name of the function. For example, the following code defines a function named <code>sqr</code>:</p> <pre><code>function sqr(n) {\n  return n * n;\n}\n</code></pre>"},{"location":"js/function/defining-functions/#anonymous-function","title":"Anonymous Function","text":"<p>An anonymous function has the same structure, except it does not have a name\u2014it\u2019s anonymous. An anonymous function can be passed to another function as an argument or stored into a variable. For example, here\u2019s an anonymous function that is stored into a variable named sqr:</p> <pre><code>const sqr = function (n) {\n  return n * n;\n};\n</code></pre>"},{"location":"js/function/defining-functions/#arrow-function","title":"Arrow Function","text":"<p>The third relatively new function form that JavaScript supports is an arrow function. An arrow (<code>=&gt;</code>) separates the parameter list from the short body of the function. An arrow function, like an anonymous function, can also be passed as argument to another function or can be stored into a variable. For example, let\u2019s rewrite the previous anonymous function as an arrow function:</p> <pre><code>const sqr = (n) =&gt; n * n;\n</code></pre> <p>Arrow functions do not have a name and are a lot more concise than anonymous functions.</p> <p>The structure of a short, single-line, anonymous function is</p> <pre><code>function(parameter1, parameter2, ...) { return ...body... }\n</code></pre> <p>The structure of the corresponding arrow function is</p> <pre><code>(parameter1, parameter2, ...) =&gt; ...body...;\n</code></pre> <p>Arrow functions have a parenthesized parameter list, an arrow, <code>=&gt;</code>, and either a single-line body or a compound multiline body surrounded by <code>{}</code>. The <code>return</code> keyword is implicit and should be omitted if the body is not surrounded by <code>{}</code>.</p>"},{"location":"js/function/defining-functions/#dropping-the-parentheses","title":"Dropping the Parentheses","text":""},{"location":"js/function/defining-functions/#multiline-arrow-functions","title":"Multiline Arrow Functions","text":"<p>Arrow functions are not restricted to having a single-line body. JavaScript permits arrow functions to be multiline.</p> <p>Multiline arrow functions are not as crisp, concise, and expressive as single-line arrow functions. The multiple lines in the body should be enclosed within <code>{}</code>, each statement or expression is expected to end with <code>;</code>, and if the body intends to <code>return</code> a value, then the <code>return</code> keyword is required.</p> <p>Here\u2019s a piece of code that computes a factorial, defined as an anonymous function:</p> <pre><code>const factorial = function (number) {\n  let product = 1;\n  for (let i = 1; i &lt;= number; i++) {\n    product *= i;\n  }\n  return product;\n};\n</code></pre> <p>We may write this function as a multiline arrow function if we desire, like so:</p> <pre><code>const factorial = (number) =&gt; {\n  let product = 1;\n  for (let i = 1; i &lt;= number; i++) {\n    product *= i;\n  }\n  return product;\n};\n</code></pre> <p>Compared to writing as an anonymous function, we merely replaced</p> <pre><code>function(number)\n</code></pre> <p>with</p> <pre><code>(number) =&gt;\n</code></pre> <p>There was hardly any benefit, other than less typing.</p> <p>In appearance, the body of a multiline arrow function is no different from the body of the corresponding <code>regular/anonymous</code> function, but semantic differences do exist.</p>"},{"location":"js/function/defining-functions/#anonymous-vs-arrow-functions","title":"Anonymous vs. Arrow Functions","text":"<p>At first sight, it may appear that arrow functions are direct replacements for anonymous functions. You may be tempted to readily replace anonymous functions with arrow functions. But that may result in code that behaves differently than you intend. There are many semantic differences between anonymous functions and arrow functions, and we have to carefully choose between them based on the context. Learning about the key differences between the two types of functions will help you pick the right one.</p>"},{"location":"js/function/defining-functions/#lexical-vs-dynamic-scoping","title":"Lexical vs. Dynamic Scoping","text":"<p>Most variables used in any function either come from the parameters or are defined locally. However, some variables can be defined in an external context.</p> <pre><code>[1, 2, 3].map(function (e) {\n  return e * 2;\n});\n</code></pre> <p>However, within the anonymous function we use two variables, <code>e</code> and <code>factor</code>. The <code>e</code> variable is still the parameter passed to the function. However, the factor variable is neither a parameter nor a locally defined variable.</p> <p>Where does that come from?*</p> <p>There are two possibilities.</p> <ol> <li> <p>The variable may come from the scope where the function using the variable is defined\u2014that\u2019s called lexical scoping.</p> </li> <li> <p>Alternatively, the variable may be provided by the caller for the function\u2014that\u2019s called dynamic scoping.</p> </li> </ol> Note <p>Most programming languages favor lexical scoping. A few languages use dynamic scoping. JavaScript is special\u2014it does both, depending on the variable and that has been a source of errors in anonymous functions.</p> Tip <p>JavaScript scopes all non-parameter, non-local variables to lexical scope for anonymous functions, except for <code>this</code> and <code>arguments</code>. Arrow functions have consistent lexical scoping for all non-parameter, non-local variables.</p>"},{"location":"js/function/defining-functions/#lexically-scoped-this-and-arguments","title":"Lexically Scoped <code>this</code> and <code>arguments</code>","text":"<pre><code>this.stuff = \"from lexical scope\";\nconst someValue = 4;\nconst self = this;\n\nsetTimeout(function () {\n  console.log(\"someValue is \" + someValue); //lexical scope for someValue\n  console.log(\"this...\" + this.stuff); //dynamic scope for this\n  console.log(\"self...\" + self.stuff); //lexical scope for self\n}, 1000);\n</code></pre> <pre><code>someValue is 4\nthis...undefined\nself...from lexical scope\n</code></pre> <p>Since this has a different scope compared to other variables, programmers often have to use workarounds like <code>self</code> to access <code>this</code> from the outside scope.</p> <p>It\u2019s easy to miss and use this directly without the intention of using dynamic scoping, and that leads to errors in programming.</p> <p>Arrow functions keep scope consistent for this.</p> <pre><code>setTimeout(() =&gt; {\n  console.log(\"someValue is \" + someValue); //lexical scope for someValue\n  console.log(\"this...\" + this.stuff); //lexical scope for this\n  console.log(\"self...\" + self.stuff); //lexical scope for self\n}, 1000);\n</code></pre> <pre><code>someValue is 4\nthis...from lexical scope\nself...from lexical scope\n</code></pre> <ul> <li>If your function relies on using arguments, then stick with the anonymous function instead of converting it to an arrow function.</li> <li>If you do decide to convert to an arrow function, then change arguments to a rest parameter.</li> </ul>"},{"location":"js/function/defining-functions/#reference","title":"Reference","text":"<ul> <li>Rediscovering JavaScript by Venkat Subramaniam, pg:70</li> </ul>"},{"location":"js/function/implicit-explicit-return/","title":"Implicit & Explicit","text":""},{"location":"js/function/implicit-explicit-return/#overview","title":"Overview","text":"<p>The concepts of implicit return and explicit return are important in JavaScript, especially when dealing with functions, especially arrow functions and regular functions. Let me explain these concepts and show you examples using your <code>createMeal</code> function.</p>"},{"location":"js/function/implicit-explicit-return/#1-explicit-return","title":"1. Explicit Return","text":"<p>An explicit return happens when you use the <code>return</code> keyword in the body of a function to specify what the function should return.</p> <p>In your <code>createMeal</code> example, the function has an explicit return because you're explicitly using the <code>return</code> keyword to return the function result:</p> CodeExplanation <pre><code>function createMeal(type) {\n    return function () {\n        // Explicit return\n        if (type === \"veg\") {\n            return \"I'm Veg\"; // Explicit return\n        } else {\n            return \"I'm non Veg\"; // Explicit return\n        }\n    };\n}\n\nconst vegMeal = createMeal(\"veg\");\nconsole.log(vegMeal()); // \"I'm Veg\"\n\nconst nonVegMeal = createMeal(\"nonVeg\");\nconsole.log(nonVegMeal()); // \"I'm non Veg\"\n</code></pre> <p>In the example above:</p> <ul> <li>The <code>createMeal</code> function explicitly returns a new function (an anonymous function).</li> <li>Inside that returned function, each <code>return</code> statement explicitly tells the function what to return based on the <code>type</code> argument.</li> </ul>"},{"location":"js/function/implicit-explicit-return/#2-implicit-return","title":"2. Implicit Return","text":"<p>An implicit return occurs when you do not need to use the <code>return</code> keyword in the function body, often used in arrow functions. It's when a function immediately returns a value without needing curly braces <code>{}</code>.</p> <p>For example, an implicit return can be used in arrow functions where you can omit the <code>return</code> keyword and the curly braces if the function is simple enough (i.e., it has a single expression).</p> CodeExplanation Here's an example of implicit return<pre><code>const createMeal = (type) =&gt; (type === \"veg\" ? \"I'm Veg\" : \"I'm non Veg\");\n\nconst vegMeal = createMeal(\"veg\");\nconsole.log(vegMeal); // \"I'm Veg\"\n\nconst nonVegMeal = createMeal(\"nonVeg\");\nconsole.log(nonVegMeal); // \"I'm non Veg\"\n</code></pre> <ul> <li>In the <code>createMeal</code> function (using arrow syntax), there are no curly braces <code>{}</code> around the function body, and there's no <code>return</code> keyword. The expression after the <code>=&gt;</code> is implicitly returned.</li> <li>The ternary operator (<code>condition ? expr1 : expr2</code>) is used to decide the return value based on the <code>type</code> argument. This is a very concise way to return values conditionally.</li> </ul>"},{"location":"js/function/implicit-explicit-return/#key-differences","title":"Key Differences:","text":"<ol> <li> <p>Explicit return: Requires the <code>return</code> keyword and curly braces <code>{}</code> around the function body (for regular functions).</p> <pre><code>function createMeal(type) {\n  if (type === \"veg\") {\n    return \"I'm Veg\";\n  } else {\n    return \"I'm non Veg\";\n  }\n}\n</code></pre> </li> <li> <p>Implicit return: No <code>return</code> keyword is needed, and curly braces <code>{}</code> are optional if there's just one expression to evaluate. The function implicitly returns the result of that expression.</p> <pre><code>const createMeal = (type) =&gt; (type === \"veg\" ? \"I'm Veg\" : \"I'm non Veg\");\n</code></pre> </li> </ol>"},{"location":"js/function/implicit-explicit-return/#when-to-use","title":"When to use","text":"<p>The choice between using explicit return and implicit return in JavaScript depends on factors like clarity, readability, and function complexity. Below, I'll outline scenarios where each approach is commonly used and discuss when you might prefer one over the other.</p>"},{"location":"js/function/implicit-explicit-return/#1-implicit-return","title":"1. Implicit Return","text":"Use implicit return when <ul> <li>The function is short and simple, containing a single expression that can be immediately returned.</li> <li>You want to write concise code and improve readability for simple operations.</li> <li>The function does not require multiple statements or logic before returning a value.</li> <li>You are using arrow functions, as implicit returns are often preferred for shorter expressions.</li> </ul> Typical scenarios for implicit return <ul> <li>One-liner functions, especially for operations like mapping, filtering, or reducing.</li> <li>Simple conditional expressions or return values that don\u2019t require extra logic.</li> <li>Functional programming styles, where you want functions to be short and expressive.</li> </ul> Example 1: Simple function with a single return value<pre><code>const double = (x) =&gt; x * 2; // Implicit return\nconsole.log(double(5)); // 10\n</code></pre> Example 2: Using implicit return in map()<pre><code>const numbers = [1, 2, 3];\nconst doubled = numbers.map((x) =&gt; x * 2); // Implicit return\nconsole.log(doubled); // [2, 4, 6]\n</code></pre> Example 3: Conditional check with ternary operator<pre><code>const mealType = (type) =&gt; (type === \"veg\" ? \"I'm Veg\" : \"I'm non Veg\"); // Implicit return\nconsole.log(mealType(\"veg\")); // \"I'm Veg\"\n</code></pre> Why use implicit return here? <ul> <li>It's a concise and clear way to express simple logic.</li> <li>The function is a single expression, so the implicit return makes the code cleaner and easier to read.</li> </ul>"},{"location":"js/function/implicit-explicit-return/#2-explicit-return","title":"2. Explicit Return","text":"Use explicit return when <ul> <li>The function is complex and contains multiple statements or logic that needs to be processed before returning a value.</li> <li>You need to perform more detailed operations, such as loops, conditionals, or multiple steps before returning a value.</li> <li>You want to improve clarity in situations where the function has multiple branches or complex logic.</li> <li>You are dealing with functions that return objects or larger data structures where readability is key.</li> </ul> Typical scenarios for explicit return <ul> <li>Functions with more than one line of code that involve multiple operations.</li> <li>Functions that need to mutate variables, call other functions, or have other side effects.</li> <li>More complex conditional logic, such as <code>if-else</code> statements, multiple returns, or loops.</li> </ul> <p>Example 1: Multiple conditions or logic</p> CodeExplanation <pre><code>function getMeal(type) {  // Explicit return\n    if (type === 'veg') {\n        return \"I'm Veg\";\n    } else if (type === 'nonVeg') {\n        return \"I'm non Veg\";\n    } else {\n        return \"Unknown Meal\";\n    }\n}\nconsole.log(getMeal('veg'));  // \"I'm Veg\"\nconsole.log(getMeal('nonVeg'));  // \"I'm non Veg\"\nconsole.log(getMeal('fruit'));  // \"Unknown Meal\"\n</code></pre> <p>Why use explicit return here?</p> <ul> <li>The function has multiple conditional branches (<code>if-else</code>), so it's clearer and more readable with explicit returns.</li> <li>It would be hard to express this logic cleanly in a single line with an implicit return.</li> </ul> <p>Example 2: Returning an object or more complex data</p> CodeExplanation <pre><code>function createPerson(name, age) {\n    // Explicit return\n    return {\n        name: name,\n        age: age,\n\n        greet: function () {\n            return `Hello, ${name}!`;\n        },\n    };\n}\n\nconst person = createPerson(\"John\", 30);\nconsole.log(person.greet()); // \"Hello, John!\"\n</code></pre> <p>Why use explicit return here?</p> <ul> <li>Returning an object with multiple properties requires an explicit <code>return</code> statement for clarity.</li> <li>The function involves more logic than just returning a single expression, so it's clearer to use an explicit return.</li> </ul> <p>Example 3: Handling complex operations with loops</p> CodeExplanation <pre><code>function sumNumbers(arr) {\n    // Explicit return\n    let total = 0;\n    for (let i = 0; i &lt; arr.length; i++) {\n        total += arr[i];\n    }\n    return total;\n    }\n\nconsole.log(sumNumbers([1, 2, 3, 4])); // 10\n</code></pre> <p>Why use explicit return here?</p> <ul> <li>The function contains a loop and involves a cumulative operation, so it needs multiple statements to compute the result before returning it.</li> </ul>"},{"location":"js/function/implicit-explicit-return/#when-to-choose-explicit-return-vs-implicit-return","title":"When to choose explicit return vs. implicit return:","text":"Use implicit return <ul> <li>When the function is simple and can be expressed as a single expression.</li> <li>For arrow functions that don't require multiple lines of code.</li> <li>When you're writing concise, functional code, e.g., with <code>map()</code>, <code>filter()</code>, or <code>reduce()</code>.</li> </ul> Use explicit return <ul> <li>When the function is complex, with multiple statements, conditional logic, or side effects.</li> <li>When the return value requires multiple calculations, data manipulations, or handling more complex data structures.</li> <li>To improve clarity and readability when the function's behavior is not straightforward.</li> </ul>"},{"location":"js/function/implicit-explicit-return/#summary-table","title":"Summary Table","text":"Scenario Use Implicit Return Use Explicit Return Simple expressions \u2705 <code>const double = (x) =&gt; x * 2;</code> \u274c (use implicit for conciseness) Single conditional return \u2705 <code>const mealType = (type) =&gt; type === 'veg' ? \"I'm Veg\" : \"I'm non Veg\";</code> \u274c (use implicit for clarity and simplicity) Multiple conditions or branches \u274c (not recommended for complex logic) \u2705 <code>function getMeal(type) { ... }</code> Returning objects or data \u274c (explicit return is better for objects) \u2705 <code>function createPerson(name, age) { return {...} }</code> Looping or iteration-based logic \u274c (not suitable for loops or multiple steps) \u2705 <code>function sumNumbers(arr) { ... }</code>"},{"location":"js/function/implicit-explicit-return/#conclusion","title":"Conclusion:","text":"<ul> <li>Implicit return works best for short, single-expression functions, especially when you're using arrow functions.</li> <li>Explicit return should be used for complex functions with multiple statements, conditionals, loops, or data manipulations.</li> </ul> <p>This helps to maintain both conciseness and clarity depending on the function's complexity.</p> <p>what do you mean by urly braces {} are optional in implicit return</p>"},{"location":"js/function/intro/","title":"Intro","text":"<p>In JavaScript, a function is a fundamental building block of the language. It is a reusable piece of code that performs a specific task. Functions help in organizing code, improving reusability, and making programs easier to understand and maintain.</p>"},{"location":"js/function/intro/#what-is-a-function","title":"What is a Function?","text":"<p>A function in JavaScript is a block of code designed to perform a particular task. It can take inputs, called parameters, and return an output. Functions help you encapsulate code into a single, manageable unit.</p> SyntaxExplanation <pre><code>function functionName(parameters) {\n  // Code to execute\n  return value; // Optional\n}\n</code></pre> Why Do We Need Functions? <ol> <li>Code Reusability: Write once, use multiple times. Functions help avoid code duplication.</li> <li>Modularity: Break down complex problems into smaller, manageable parts.</li> <li>Maintainability: Changes to functionality can be made in one place rather than throughout your codebase.</li> <li>Abstraction: Hide implementation details and expose only what\u2019s necessary.</li> <li>Testing: Functions can be tested independently for better reliability.</li> </ol> What Does a Function Do? <p>A function performs a specific action based on the logic defined within it. When you call a function, it executes the code inside its body, using any parameters you pass to it and potentially returning a result.</p>"},{"location":"js/function/intro/#question","title":"Question","text":"<p>What Happens When <code>return</code> Is Not Used?</p> <p>In JavaScript, not every function has to return a value. If a function doesn't explicitly use the <code>return</code> statement, it will return <code>undefined</code> by default.</p> <p>When a function does not have a <code>return</code> statement, or if the <code>return</code> statement is used without an explicit value, JavaScript automatically returns <code>undefined</code>. This is useful for cases where a function performs an action but does not need to produce a result.</p> Example Example 1Example 2Example 3 <p>Function with No <code>return</code> Statement</p> <pre><code>function sayHello() {\n    console.log(\"Hello!\");\n}\n\nconst result = sayHello(); // Logs \"Hello!\" to the console\nconsole.log(result); // Outputs: undefined\n</code></pre> <p>In this example:</p> <ul> <li><code>sayHello</code> logs a message to the console but does not return a value.</li> <li>When <code>sayHello</code> is called, it returns <code>undefined</code> because there is no <code>return</code> statement.</li> </ul> <p>Function with <code>return</code> Statement But No Value</p> <pre><code>function logAndReturn() {\n    console.log(\"Logging something.\");\n    return; // Explicitly returns undefined\n}\n\nconst result = logAndReturn(); // Logs \"Logging something.\" to the console\nconsole.log(result); // Outputs: undefined\n</code></pre> <p>In this example:</p> <ul> <li><code>logAndReturn</code> includes a <code>return</code> statement but does not specify a value.</li> <li>The function still returns <code>undefined</code> because that is the default behavior when no value is provided in the <code>return</code> statement.</li> </ul> <p>Example with Return Value</p> <pre><code>function add(a, b) {\n    return a + b;\n}\n\nconst sum = add(3, 4); // sum will be 7\nconsole.log(sum); // Outputs: 7\n</code></pre> <p>Here, the function <code>add</code> returns the result of adding <code>a</code> and <code>b</code>, and this value is captured in the <code>sum</code> variable.</p>"},{"location":"js/function/intro/#key-points","title":"Key Points","text":"<ol> <li> <p>Explicit Return: If you want your function to return a specific value, you need to include a return statement with that value.</p> </li> <li> <p>Implicit Return: If the <code>return</code> statement is omitted or if it is used without a value, the function will return <code>undefined</code>.</p> </li> <li> <p>Useful for Side Effects: Functions that perform actions (like logging, modifying global state, or interacting with the DOM) without returning a value are often referred to as procedures or actions. They focus on side effects rather than producing a value.</p> </li> </ol> <p>In summary, a function in JavaScript that does not use a <code>return</code> statement will return <code>undefined</code> by default. This behavior is often useful for functions that are intended to perform actions rather than calculate and return a value.</p>"},{"location":"js/function/intro/#function-types","title":"Function Types","text":"<p>let\u2019s dive deeper into <code>function declarations</code> and <code>function expressions</code>, the two types of functions used in JavaScript. To the casual reader, the two appear very similar:</p> <pre><code>// Function Declaration\nfunction isLie(cake) {\n  return cake === true;\n}\n\n// Function Expression\nvar isLie = function (cake) {\n  return cake === true;\n};\n</code></pre> <p>The only real difference between the two is when they are evaluated.</p> <p>A function declaration can be accessed by the interpreter as it is being parsed. The function expression, on the other hand, is part of an assignment expression, which prevents JavaScript from evaluating it until the program has completed the assignment. This difference may seem minor, but implications are huge; consider the following example:</p> <pre><code>// =&gt; Hi, I'm a function declaration!\ndeclaration();\n\nfunction declaration() {\n  console.log(\"Hi, I'm a function declaration!\");\n}\n\n// =&gt; Uncaught TypeError: undefined is not a function\nexpression();\n\nvar expression = function () {\n  console.log(\"Hi, I'm a function expression!\");\n};\n</code></pre> <p>As you can see in the previous example, the function expression threw an exception when it was invoked, but the function declaration executed just fine. This exception gets to the heart of the difference between declaration and expression functions. JavaScript knows about the declaration function and can parse it before the program executes. Therefore, it doesn\u2019t matter if the program invokes the function before it is defined because JavaScript has hoisted the function to the top of the current scope behind the scenes. The function expression is not evaluated until it is assigned to a variable; therefore, it is still undefined when invoked. This is why good code style is to define all variables at the top of the current scope. Had you done this then, your script would visually match what JavaScript is doing during parse time.</p> Tip <p>The concept to take away is that during parse time, JavaScript moves all function declarations to the top of the current scope. This is why it doesn\u2019t matter where declarative functions appear in the script body</p> <p>The key to remember here is that function declarations cannot be conditionally defined. If you need conditional definition use a function expression.</p> <p>Furthermore, function declarations should never be made inside a control flow statement, due to the different ways interpreters handle it</p> <ul> <li>Expert JavaScript by Mark E. Daggett, pg:37</li> </ul>"},{"location":"js/function/intro/#related-blogs","title":"Related Blogs","text":"<ul> <li>Why Mastering These Functions is Important</li> <li>High Order Function</li> <li>Javascript Arrow Functions</li> <li>Control Statement</li> <li>Understanding JavaScript Array Methods: Mutating vs. Non-Mutating</li> <li>Languages That Return Default Values</li> <li>Mastering JavaScript Array</li> <li>Why React is Both Declarative and Functional</li> </ul>"},{"location":"js/function/pure-and-impure/","title":"Pure & Impure Function","text":""},{"location":"js/function/pure-and-impure/#pure-function","title":"Pure Function","text":"<p>A pure function in JavaScript is a function that:</p> <ol> <li>Always produces the same <code>output</code> for the same <code>input</code>: No matter how many times you call the function with the same arguments, the result will always be the same.</li> <li>Has no side effects: It does not modify external variables, data, or state.</li> </ol>"},{"location":"js/function/pure-and-impure/#key-characteristics-of-pure-functions","title":"Key Characteristics of Pure Functions","text":"<ul> <li>Deterministic: Output depends solely on input.</li> <li>No Side Effects: Does not interact with or modify anything outside of its scope (e.g., no I/O operations, no modifying global variables).</li> </ul>"},{"location":"js/function/pure-and-impure/#example-of-a-pure-function","title":"Example of a Pure Function","text":"Example<pre><code>function add(a, b) {\n  return a + b;\n}\n\n// Example usage\nconsole.log(add(2, 3)); // Output: 5\nconsole.log(add(2, 3)); // Output: 5 (always the same output for the same inputs)\n</code></pre>"},{"location":"js/function/pure-and-impure/#what-makes-a-function-pure","title":"What Makes a Function Pure","text":"<p>No Dependency on External State:</p> <p>The function must not rely on or modify variables outside of its scope.</p> Impure ExamplePure Alternative Impure Example:<pre><code>let x = 10;\nfunction addToX(y) {\n    return x + y; // Impure because it uses external variable x\n}\n</code></pre> Pure Alternative:<pre><code>function add(x, y) {\n    return x + y; // Pure because it only depends on input arguments\n}\n</code></pre> <p>No Side Effects:</p> <p>It must not modify anything outside itself (e.g., DOM, global state, etc.).</p> Impure ExamplePure Alternative <pre><code>function incrementArray(arr) {\n    arr.push(arr.length); // Impure because it modifies the input array\n    return arr;\n}\n</code></pre> <pre><code>function getIncrementedArray(arr) {\n    return [...arr, arr.length]; // Pure because it returns a new array without modifying the original\n}\n</code></pre>"},{"location":"js/function/pure-and-impure/#impure-function","title":"Impure Function","text":""},{"location":"js/function/pure-and-impure/#reference","title":"Reference","text":"<ul> <li>What are Pure and Impure functions in JavaScript</li> <li>Pure vs Impure Functions </li> <li>Understanding Pure and Impure Functions</li> <li>Pure Functions</li> </ul>"},{"location":"js/function/return-statement/","title":"Return Statement","text":"<p>All functions return a value whether the original developer intended it or not.</p> <p>If a value was defined and passed back to the function caller, it can be assigned to a variable or used directly.</p> <p>A function returns <code>undefined</code> if a value was not returned, or the return statement inside a function is empty.</p> Determining If a Function Defines and Returns a Value<pre><code>// A function with an empty return-statement returns undefined\nfunction function1() {\n  return;\n}\n\n// A function with no return-statement returns undefined\nfunction function2() {}\n\nfunction function3() {\n  return 2 + 2;\n}\n\nfunction function4() {\n  return true;\n}\n\nfunction function5() {\n  return {};\n}\n\nvar fn1 = function1();\nconsole.log(\"Function1 returns: \" + fn1); // undefined\n\nvar fn2 = function2();\nconsole.log(\"Function2 returns: \" + fn2); // undefined\n\nvar fn3 = function3();\nconsole.log(\"Function3 returns: \" + fn3); // 4\n\nvar fn4 = function4();\nconsole.log(\"Function4 returns: \" + fn4); // true\n\nvar fn5 = function5();\nconsole.log(\"Function5 returns: \" + fn5); // Object{}\n</code></pre> <ul> <li>JavaScript Recipes: A Problem-Solution Approach by Russ Ferguson, Keith Cirkel - pg: 13</li> </ul>"},{"location":"js/function/types/","title":"Types","text":""},{"location":"js/function/types/#function-types","title":"Function Types","text":"<p>JavaScript functions can be broadly categorized based on their syntax, usage, and characteristics.</p> <p>Here's a summary of the main categories of functions in JavaScript:</p>"},{"location":"js/function/types/#1-function-declarations","title":"1. Function Declarations","text":"<p>Functions defined using the <code>function</code> keyword followed by the function name. These functions are hoisted, meaning they can be called before their definition in the code.</p> Usage SyntaxExample <pre><code>function functionName(parameters) {\n    // function body\n}\n</code></pre> <pre><code>function greet(name) {\n    return `Hello, ${name}!`;\n}\n</code></pre>"},{"location":"js/function/types/#2-function-expressions","title":"2. Function Expressions","text":"<p>Functions that are defined within an expression and assigned to a variable. They are not hoisted, so they must be defined before they are used.</p> <p>a. Anonymous Function Expressions</p> Usage SyntaxExample <pre><code>const functionName = function(parameters) {\n    // function body\n};\n</code></pre> <pre><code>const add = function(a, b) {\n    return a + b;\n};\n</code></pre> <p>b. Named Function Expressions</p> Usage SyntaxExample <pre><code>const functionName = function functionName(parameters) {\n    // function body\n};\n</code></pre> <pre><code>const subtract = function subtract(a, b) {\n    return a - b;\n};\n</code></pre> <p>c. Arrow Functions</p> Usage SyntaxCharacteristicsExample <pre><code>const functionName = (parameters) =&gt; {\n    // function body\n};\n</code></pre> <ul> <li>Concise syntax.</li> <li>Lexical <code>this</code>, meaning <code>this</code> is inherited from the surrounding context.</li> <li>Not hoisted.</li> </ul> <pre><code>const multiply = (x, y) =&gt; x * y;\n\nconst square = x =&gt; x * x;\n\nconst greet = name =&gt; {\n    return `Hello, ${name}!`;\n};\n</code></pre>"},{"location":"js/function/types/#3-immediately-invoked-function-expressions-iife","title":"3. Immediately Invoked Function Expressions (IIFE)","text":"<p>Functions that are defined and executed immediately. Used to create a local scope and avoid polluting the global namespace.</p> SyntaxExample <pre><code>(function() {\n    // function body\n})();\n</code></pre> <pre><code>(function() {\n    const message = 'Hello, World!';\n    console.log(message);\n})();\n</code></pre>"},{"location":"js/function/types/#4-generator-functions","title":"4. Generator Functions","text":"<p>Functions that can pause execution and resume later. Defined using the <code>function*</code> syntax and <code>yield</code> keyword.</p> SyntaxExample <pre><code>function* generatorFunction() {\n    // function body\n}\n</code></pre> <pre><code>function* countUpTo(max) {\n    let count = 1;\n    while (count &lt;= max) {\n        yield count++;\n    }\n}\n</code></pre>"},{"location":"js/function/types/#5-async-functions","title":"5. Async Functions","text":"<p>Functions designed for handling asynchronous operations. They return a <code>Promise</code> and allow the use of <code>await</code> to pause execution until a <code>Promise</code> is resolved.</p> SyntaxExample <pre><code>async function functionName(parameters) {\n    // function body\n}\n</code></pre> <pre><code>async function fetchData() {\n    const response = await fetch('https://api.example.com/data');\n    const data = await response.json();\n    return data;\n}\n</code></pre>"},{"location":"js/function/types/#6-method-definitions","title":"6. Method Definitions","text":"<p>Functions defined within objects or classes. They use shorthand syntax in object literals and class definitions.</p> <p>a. Object Methods</p> SyntaxExample <pre><code>const obj = {\n    methodName(parameters) {\n        // function body\n    }\n};\n</code></pre> <pre><code>const person = {\n    greet() {\n        return 'Hello!';\n    }\n};\n</code></pre> <p>b. Class Methods</p> SyntaxExample <pre><code>class ClassName {\n    methodName(parameters) {\n        // function body\n    }\n}\n</code></pre> <pre><code>class Person {\n    greet() {\n        return 'Hello!';\n    }\n}\n</code></pre> Summary <ul> <li>Function Declarations: Traditional named functions, hoisted.</li> <li>Function Expressions: Functions assigned to variables, not hoisted. Includes anonymous, named, and arrow functions.</li> <li>IIFE: Immediately executed function expressions, used for local scope.</li> <li>Generator Functions: Functions that can yield multiple values over time.</li> <li>Async Functions: Functions for asynchronous operations, using <code>async/await</code>.</li> <li>Method Definitions: Functions defined within objects or classes.</li> </ul> <p>Each of these function types serves different purposes and is used in various scenarios in JavaScript programming.</p>"},{"location":"js/function/types/#reference","title":"Reference","text":"<ul> <li>8 Types of JavaScript Functions</li> <li>What are the different types of functions in JavaScript?</li> <li>Functions in JavaScript</li> <li>Different ways of writing functions in JavaScript</li> <li>Functions in JavaScript: Important Things To Know 2024</li> </ul>"},{"location":"js/function/advanced/advanced-concept/","title":"Concept","text":"Key Concept to Remember <p>Arrow functions lexically bind <code>this</code> from their surrounding scope. This means they do not have their own <code>this</code> context, making them ideal for preserving this in callbacks and asynchronous code without additional binding.</p> <p>In traditional (general) functions, the binding of <code>this</code> depends on the context in which the function is invoked.</p>"},{"location":"js/function/advanced/advanced-concept/#advanced-concepts","title":"Advanced Concepts","text":"<p>Here are some advanced function-related topics in JavaScript:</p> <ol> <li> <p>Anonymous Functions and Function Expressions</p> <p>Functions don\u2019t always need names. An anonymous function can be used in situations where a function doesn\u2019t need to be reused.</p> <pre><code>const greet = function (name) {\n  return `Hello, ${name}!`;\n};\nconsole.log(greet(\"Alice\")); // Outputs: Hello, Alice!\n</code></pre> </li> <li> <p>Arrow Functions</p> <p>Arrow functions offer a shorter syntax and do not bind their own this. They are especially useful for simple functions.</p> <pre><code>const multiply = (x, y) =&gt; x * y;\nconsole.log(multiply(4, 5)); // Outputs: 20\n</code></pre> <p>Note: Arrow functions do not have their own this context.</p> </li> <li> <p>Higher-Order Functions</p> <p>A higher-order function is a function that takes another function as an argument or returns a function.</p> <pre><code>function higherOrderFunction(callback) {\n  return function (value) {\n    return callback(value);\n  };\n}\n\nconst square = higherOrderFunction((x) =&gt; x * x);\nconsole.log(square(5)); // Outputs: 25\n</code></pre> </li> <li> <p>Closures</p> <p>Closures are functions that capture the lexical environment in which they are defined, allowing them to access variables from an outer scope even after that outer function has finished executing.</p> <pre><code>function createCounter() {\n  let count = 0;\n  return function () {\n    count += 1;\n    return count;\n  };\n}\n\nconst counter = createCounter();\nconsole.log(counter()); // Outputs: 1\nconsole.log(counter()); // Outputs: 2\n</code></pre> </li> <li> <p>Currying and Partial Application</p> <p><code>Currying</code> transforms a function that takes multiple arguments into a sequence of functions each taking a single argument. <code>Partial</code> application involves fixing some arguments of a function and generating a new function.</p> Currying<pre><code>function multiply(a) {\n  return function (b) {\n    return a * b;\n  };\n}\n\nconst multiplyBy2 = multiply(2);\nconsole.log(multiplyBy2(5)); // Outputs: 10\n</code></pre> Partial Application<pre><code>function add(a, b, c) {\n  return a + b + c;\n}\n\nfunction partialAdd(a) {\n  return function (b, c) {\n    return add(a, b, c);\n  };\n}\n\nconst add5 = partialAdd(5);\nconsole.log(add5(3, 2)); // Outputs: 10\n</code></pre> </li> <li> <p>Generators</p> <p>Generators are functions that can be paused and resumed, allowing for more complex iteration patterns.</p> <pre><code>function* countUpTo(max) {\n  let count = 1;\n  while (count &lt;= max) {\n    yield count++;\n  }\n}\n\nconst counter = countUpTo(3);\nconsole.log(counter.next().value); // Outputs: 1\nconsole.log(counter.next().value); // Outputs: 2\nconsole.log(counter.next().value); // Outputs: 3\nconsole.log(counter.next().value); // Outputs: undefined\n</code></pre> </li> <li> <p>Async Functions and Promises</p> <p>Async functions simplify working with asynchronous code by allowing you to use <code>await</code> to pause execution until a promise is resolved.</p> <pre><code>async function fetchData() {\n  const response = await fetch(\"https://api.example.com/data\");\n  const data = await response.json();\n  return data;\n}\n\nfetchData().then((data) =&gt; console.log(data));\n</code></pre> </li> </ol>"},{"location":"js/function/advanced/advanced-concept/#hidden-facts","title":"Hidden Facts","text":"<ul> <li>Functions Are Objects: Functions in JavaScript are first-class objects, meaning they can have properties and methods.</li> <li>Function Hoisting: Function declarations are hoisted to the top of their scope, meaning they can be used before they are defined.</li> <li><code>arguments</code> Object: Regular functions have access to an <code>arguments</code> object that contains all the passed arguments.</li> <li>Function Constructor: Functions can also be created using the <code>Function</code> constructor, though it's less common and can be less secure.</li> </ul> <pre><code>const sum = new Function(\"a\", \"b\", \"return a + b;\");\nconsole.log(sum(1, 2)); // Outputs: 3\n</code></pre> <p>Mastering these concepts will greatly enhance your JavaScript skills and help you write more efficient, elegant code.</p> Implement in Real Projects <p>Apply your knowledge in real-world projects:</p> <ol> <li>Refactor Code: Use advanced functions to improve existing codebases. For instance, refactor callback-heavy code to use Promises and async/await.</li> <li>Build Libraries: Create libraries or utilities that leverage these advanced concepts. For example, build a custom function library using higher-order functions and currying.</li> <li>Contribute to Open Source: Work on open-source projects where these concepts are used. This will expose you to practical use cases and diverse coding styles.</li> </ol>"},{"location":"js/function/advanced/advanced-concept/#why-these-concepts-are-important","title":"Why These Concepts Are Important","text":"<p>Performance Optimization: Advanced functions like currying and partial application can optimize performance by reducing redundant computations. Enhanced Code Readability: Functions like arrow functions and higher-order functions can make code more concise and easier to understand. Maintainability: Closures and generators help manage state and handle complex logic in a manageable way, making the codebase easier to maintain. Improved Asynchronous Handling: Async/await provides a more straightforward way to handle asynchronous operations compared to traditional callback methods. Functional Programming Paradigms: Embracing functional programming techniques can lead to more predictable, reliable, and testable code.</p>"},{"location":"js/function/advanced/function-categories/","title":"Function Categories","text":""},{"location":"js/function/advanced/function-categories/#overview","title":"Overview","text":"<p>In JavaScript, functions can be categorized based on various factors, such as their syntax, behavior, and usage within the program. Below are some common categories of functions in JavaScript:</p>"},{"location":"js/function/advanced/function-categories/#1-based-on-function-syntax","title":"1. Based on Function Syntax","text":"<ul> <li> <p>Function Declaration (Named Function): A function that is declared with a name. It can be invoked before its declaration due to hoisting.</p> <pre><code>function sayHello() {\n  console.log(\"Hello, World!\");\n}\nsayHello();\n</code></pre> </li> <li> <p>Function Expression: A function that is defined as part of an expression. It can be anonymous or named.</p> <pre><code>const greet = function () {\n  console.log(\"Hello!\");\n};\ngreet();\n</code></pre> </li> <li> <p>Arrow Function: A shorthand syntax for writing functions. Arrow functions have lexical scoping for <code>this</code> and are often used for concise function expressions.</p> <pre><code>const add = (a, b) =&gt; a + b;\nconsole.log(add(5, 10));\n</code></pre> </li> <li> <p>Anonymous Function: A function without a name. Often used in places where functions are passed as arguments (like callbacks).</p> <pre><code>setTimeout(function () {\n  console.log(\"This is an anonymous function!\");\n}, 1000);\n</code></pre> </li> <li> <p>Named Function Expression: A function expression where the function has a name, but it's still defined as part of an expression.</p> <pre><code>const factorial = function fact(n) {\n  if (n === 0) return 1;\n  return n * fact(n - 1);\n};\nconsole.log(factorial(5)); // Output: 120\n</code></pre> </li> </ul>"},{"location":"js/function/advanced/function-categories/#2-based-on-function-behavior","title":"2. Based on Function Behavior","text":"<ul> <li> <p>Pure Function: A function that, given the same input, always produces the same output and has no side effects (it does not modify any external state).</p> <pre><code>const add = (a, b) =&gt; a + b; // Pure function\n</code></pre> </li> <li> <p>Impure Function: A function that may rely on or modify external state, or produce different outputs for the same inputs.</p> <pre><code>let counter = 0;\nconst increment = () =&gt; counter++; // Impure function, modifies external state\n</code></pre> </li> <li> <p>Recursive Function: A function that calls itself in order to solve smaller instances of a problem.</p> <pre><code>const factorial = (n) =&gt; {\n  if (n === 0) return 1;\n  return n * factorial(n - 1);\n};\nconsole.log(factorial(5)); // Output: 120\n</code></pre> </li> </ul>"},{"location":"js/function/advanced/function-categories/#3-based-on-return-type","title":"3. Based on Return Type","text":"<ul> <li> <p>Void Function: A function that does not return any value. It performs an action but doesn't produce a return value.</p> <pre><code>function logMessage() {\n  console.log(\"This function does not return anything.\");\n}\nlogMessage();\n</code></pre> </li> <li> <p>Value-returning Function: A function that returns a value after performing some operations.</p> <pre><code>function add(a, b) {\n  return a + b;\n}\nconsole.log(add(2, 3)); // Output: 5\n</code></pre> </li> </ul>"},{"location":"js/function/advanced/function-categories/#4-based-on-function-invocation","title":"4. Based on Function Invocation","text":"<ul> <li> <p>Callback Function: A function that is passed as an argument to another function and is executed at a later time (usually after some asynchronous operation).</p> <pre><code>function fetchData(callback) {\n  setTimeout(() =&gt; {\n    callback(\"Data loaded\");\n  }, 1000);\n}\n\nfetchData((message) =&gt; {\n  console.log(message);\n});\n</code></pre> </li> <li> <p>Higher-order Function: A function that takes one or more functions as arguments, returns a function, or both. This is a key concept in functional programming.</p> <pre><code>const multiplyBy = (factor) =&gt; {\n  return (number) =&gt; number * factor;\n};\n\nconst double = multiplyBy(2);\nconsole.log(double(5)); // Output: 10\n</code></pre> </li> <li> <p>Immediately Invoked Function Expression (IIFE): A function that is defined and executed immediately after being declared.</p> <pre><code>(function () {\n  console.log(\"I am executed immediately!\");\n})();\n</code></pre> </li> </ul>"},{"location":"js/function/advanced/function-categories/#5-based-on-scope-and-context","title":"5. Based on Scope and Context","text":"<ul> <li> <p>Global Function: A function that is defined in the global scope and is accessible throughout the program.</p> <pre><code>function globalFunction() {\n  console.log(\"I am a global function!\");\n}\n</code></pre> </li> <li> <p>Local Function: A function defined within another function, having access only within that function.</p> <pre><code>function outerFunction() {\n  function innerFunction() {\n    console.log(\"I am a local function!\");\n  }\n  innerFunction();\n}\nouterFunction();\n</code></pre> </li> <li> <p>Method (Object Function): A function that is a property of an object. It is called a method when defined inside an object.</p> <pre><code>const person = {\n  name: \"John\",\n  greet: function () {\n    console.log(`Hello, my name is ${this.name}`);\n  },\n};\nperson.greet(); // Output: Hello, my name is John\n</code></pre> </li> </ul>"},{"location":"js/function/advanced/function-categories/#6-functional-programming-concepts","title":"6. Functional Programming Concepts","text":"<ul> <li> <p>Lambda Function: A small, anonymous function that is often used in functional programming. In JavaScript, it's commonly implemented using arrow functions.</p> <pre><code>const square = (x) =&gt; x * x;\nconsole.log(square(4)); // Output: 16\n</code></pre> </li> <li> <p>Currying: A technique where a function takes multiple arguments one by one, returning new functions until all arguments are received.</p> <pre><code>const multiply = (a) =&gt; (b) =&gt; a * b;\nconst double = multiply(2);\nconsole.log(double(5)); // Output: 10\n</code></pre> </li> <li> <p>Partial Application: A form of currying where some arguments of the function are pre-filled.</p> <pre><code>const add = (a, b, c) =&gt; a + b + c;\nconst addFive = add.bind(null, 5); // Partial application\nconsole.log(addFive(3, 2)); // Output: 10\n</code></pre> </li> </ul>"},{"location":"js/function/advanced/function-categories/#7-based-on-asynchronous-behavior","title":"7. Based on Asynchronous Behavior","text":"<ul> <li>Synchronous Function: A function that runs and completes execution before allowing the program to move to the next line of code.</li> </ul> <pre><code>function syncFunction() {\n  console.log(\"This is a synchronous function.\");\n}\nsyncFunction();\n</code></pre> <ul> <li> <p>Asynchronous Function: A function that executes asynchronously, allowing other operations to continue while it completes.</p> <ol> <li> <p>Callback-based Asynchronous Function:</p> <pre><code>setTimeout(() =&gt; {\n    console.log(\"Executed after 2 seconds.\");\n}, 2000);\n</code></pre> </li> <li> <p>Promise-based Asynchronous Function:</p> <pre><code>function fetchData() {\n    return new Promise((resolve, reject) =&gt; {\n        setTimeout(() =&gt; {\n            resolve(\"Data fetched\");\n        }, 2000);\n    });\n}\n\nfetchData().then((message) =&gt; {\n    console.log(message);  // Output: Data fetched\n});\n</code></pre> </li> <li> <p>Async/Await: A syntax to work with promises in a more synchronous-like manner.</p> <pre><code>async function fetchData() {\n    let data = await new Promise((resolve) =&gt; {\n        setTimeout(() =&gt; resolve(\"Data fetched\"), 2000);\n    });\n    console.log(data);  // Output: Data fetched\n}\n\nfetchData();\n</code></pre> </li> </ol> </li> </ul> <p>These categories help us understand the flexibility and capabilities of functions in JavaScript, making it possible to handle various programming paradigms, including imperative, functional, and object-oriented programming.</p>"},{"location":"js/function/advanced/function-categories/#programming-functions","title":"Programming Functions","text":"<ol> <li> <p>Based on Return Type:</p> <ul> <li>Void Function: A function that does not return any value. It simply performs an action (e.g., printing output).</li> <li>Value-returning Function: A function that returns a value after execution (e.g., a function that adds two numbers and returns the result).</li> </ul> </li> <li> <p>Based on Number of Parameters:</p> <ul> <li>No-argument Function: A function that takes no input parameters.</li> <li>Single-argument Function: A function that takes one input parameter.</li> <li>Multiple-argument Function: A function that takes multiple input parameters.</li> </ul> </li> <li> <p>Based on Scope and Lifetime:</p> <ul> <li>Global Function: A function defined outside of any classes or methods, accessible from anywhere in the program.</li> <li>Local Function: A function defined within another function or block, typically having a limited scope.</li> <li>Recursive Function: A function that calls itself in order to solve smaller instances of the problem.</li> </ul> </li> <li> <p>Based on Usage:</p> <ul> <li>Pure Function: A function that always produces the same output for the same input and has no side effects.</li> <li>Impure Function: A function that may produce different outputs for the same input or has side effects (e.g., modifying a global variable).</li> </ul> </li> <li> <p>Based on Invocation:</p> <ul> <li>Built-in Function: Functions that are pre-defined in the programming language (e.g., <code>print()</code> in Python, <code>sqrt()</code> in C++).</li> <li>User-defined Function: Functions created by the programmer to perform specific tasks.</li> </ul> </li> <li> <p>Functional Programming Categories:</p> <ul> <li>Higher-order Function: A function that takes one or more functions as arguments or returns a function as its result.</li> <li>Anonymous Function (Lambda Function): A function that is defined without a name, often used for short, one-time operations.</li> </ul> </li> </ol> <p>These are just a few of the main categories and types of functions that appear across different areas of mathematics and programming. The categorization can be further refined depending on the specific context in which the functions are applied.</p> <ul> <li>A Guaranteed Method for Writing Testable Code in JavaScript</li> <li>Understanding State Batching in React: A Simple Explanation</li> </ul>"},{"location":"js/function/hof/intro/","title":"Intro","text":"<p>Higher-order functions (HOFs) \u2014 that is, functions that take functions as <code>parameters</code>, such as the following</p> <ul> <li><code>reduce()</code> and <code>reduceRight()</code> to apply an operation to a whole array, reducing it to a single result</li> <li><code>map()</code> to transform one array into another by applying a function to each of its elements</li> <li><code>flat()</code> to make a single array out of an array of arrays</li> <li><code>flatMap()</code> to mix together mapping and flattening</li> <li><code>forEach()</code> to simplify writing loops by abstracting the necessary looping code</li> </ul> <p>We\u2019ll also be able to perform searches and selections with the following:</p> <ul> <li><code>filter()</code> to pick some elements from an array</li> <li><code>find()</code> and <code>findIndex()</code> to search for elements that satisfy a condition</li> <li>A pair of predicates, <code>every()</code> and <code>some()</code>, to check an array for a Boolean test</li> </ul> <p>Using these functions will let you work more declaratively, and you\u2019ll see that your focus will shift to what you need to do and not so much to how it\u2019s going to be done; the dirty details are hidden inside our functions. Instead of writing a series of possibly nested loops, we\u2019ll focus on using functions as building blocks to specify our desired result.</p>"},{"location":"js/function/hof/intro/#overview","title":"Overview","text":"<p>JS Online Compiler</p> <pre><code>function veg() {\n  return \"I'm Veg\";\n}\n\nfunction nonVege() {\n  return \"I'm non Veg\";\n}\n\nfunction Meal(veg) {\n  return veg();\n}\n\n// Meal(veg);\n\nconsole.log(Meal(veg));\n</code></pre> <p>A higher-order function (HOF) in JavaScript is defined as a function that:</p> <ul> <li>Accepts a function as an argument, or</li> <li>Returns a function.</li> </ul> <p>Your original Meal function only meets the first criterion, because it accepts a function (veg) as an argument and calls it.</p> <p>Let's break down your two criteria:</p> <p>1. Function that accepts another function as an argument</p> <p>Your <code>Meal</code> function does this:</p> <pre><code>function Meal(veg) {\n  return veg(); // 'veg' is a function passed as an argument.\n}\n</code></pre> <p>In this case, <code>veg</code> is passed as an argument to the <code>Meal</code> function. When <code>Meal</code> is called with the <code>veg</code> function as an argument, it calls <code>veg()</code> inside it, which makes it a higher-order function (HOF).</p> <p>2. Function that returns another function</p> <p>Here's an example where the <code>Meal</code> function returns another function:</p> <pre><code>function createMeal(type) {\n  return function () {\n    if (type === \"veg\") {\n      return \"I'm Veg\";\n    } else {\n      return \"I'm non Veg\";\n    }\n  };\n}\n\nconst vegMeal = createMeal(\"veg\");\nconsole.log(vegMeal()); // Prints: \"I'm Veg\"\n\nconst nonVegMeal = createMeal(\"nonVeg\");\nconsole.log(nonVegMeal()); // Prints: \"I'm non Veg\"\n</code></pre> <p>In this example, <code>createMeal</code> is a higher-order function because it returns a new function based on the argument (<code>'veg'</code> or <code>'nonVeg'</code>). The returned function then contains the logic for the meal type.</p> Summary <ul> <li>In your original example, <code>Meal</code> qualifies as a higher-order function because it accepts a function as an argument (<code>veg</code>).</li> <li>If the <code>Meal</code> function had returned a function (rather than just calling <code>veg</code>), it would also qualify as a higher-order function for returning a function.</li> </ul> <p>So, you are correct in both cases:</p> <ul> <li>If a function accepts another function as an argument (like your <code>Meal</code> function), it is a higher-order function.</li> <li>If a function returns a function, it is also a higher-order function.</li> </ul> <p>Your initial code fits the definition of a higher-order function because it takes a function (<code>veg</code>) as an argument and calls it, which is why it qualifies as a higher-order function in JavaScript.</p>"},{"location":"js/function/hof/intro/#why-can-we-also-call-it-hoc","title":"Why can we also call it HOC?","text":"<p>The term HOC (Higher-Order Component) is generally used in the context of React, which is a JavaScript library for building user interfaces. In React, Higher-Order Components are a specific type of higher-order function that takes a component as an argument and returns a new component, typically with enhanced functionality.</p> <pre><code>function withEnhancement(Component) {\n  return function EnhancedComponent(props) {\n    // Add some additional behavior here\n    return &lt;Component {...props} /&gt;;\n  };\n}\n</code></pre> <p>Higher-Order Component (HOC) is a term specific to React and is a type of higher-order function that operates on React components.</p>"},{"location":"js/function/hof/intro/#reference","title":"Reference","text":""},{"location":"js/function/hof/map/","title":"Map","text":"<p>In JavaScript, <code>.map</code> is considered a higher-order function because it meets the definition of a higher-order function: it takes a function as an argument and/or returns a function. Here's how this works:</p>"},{"location":"js/function/hof/map/#what-is-map","title":"What is <code>.map</code>?","text":"<p>The <code>.map()</code> method is used on arrays to create a new array by applying a given function to each element of the original array. The key aspect is that the function passed to <code>.map()</code> does not modify the original array but instead returns a new array based on the function's transformation.</p>"},{"location":"js/function/hof/map/#why-is-map-a-higher-order-function","title":"Why is <code>.map</code> a Higher-Order Function?","text":"<p>A higher-order function is a function that either:</p> <ol> <li>Takes one or more functions as arguments, or</li> <li>Returns a function as a result.</li> </ol> <p>In the case of <code>.map()</code>, it takes a function as an argument. Here's a breakdown of how that makes <code>.map</code> a higher-order function:</p> <ol> <li> <p>It accepts a callback function as an argument: When you use <code>.map()</code>, you provide a function that will be applied to each element of the array.</p> </li> <li> <p>The callback function can be defined inline: This means you can pass an anonymous function (also called a callback function) directly within the <code>.map()</code> method.</p> </li> </ol> Example of .map() as a Higher-Order Function<pre><code>// An example array\nconst numbers = [1, 2, 3, 4];\n\n// .map() takes a function as an argument\nconst doubledNumbers = numbers.map(function (num) {\n  return num * 2; // Callback function transforms each element\n});\n\nconsole.log(doubledNumbers); // Output: [2, 4, 6, 8]\n</code></pre> <p>In this example:</p> <ul> <li>The <code>.map()</code> method is called on the <code>numbers</code> array.</li> <li>We pass a callback function <code>function(num) { return num * 2; }</code> to <code>.map()</code>. This function is applied to each element of the array.</li> <li>The callback function transforms each element, and <code>.map()</code> returns a new array with the transformed elements.</li> </ul>"},{"location":"js/function/hof/map/#more-examples","title":"More Examples","text":"<p>Using Arrow Function Syntax</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst squaredNumbers = numbers.map((num) =&gt; num ** 2);\nconsole.log(squaredNumbers); // Output: [1, 4, 9, 16]\n</code></pre> <p>Using <code>.map()</code> to Create Objects</p> <pre><code>const names = [\"Alice\", \"Bob\", \"Charlie\"];\nconst nameObjects = names.map((name) =&gt; ({ name: name }));\nconsole.log(nameObjects);\n// Output: [{ name: \"Alice\" }, { name: \"Bob\" }, { name: \"Charlie\" }]\n</code></pre>"},{"location":"js/function/hof/map/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Function as Argument: <code>.map()</code> is a higher-order function because it accepts a function as an argument.</li> <li>Returns a New Array: It applies the given function to each element and returns a new array.</li> <li>No Side Effects: It doesn't modify the original array; it creates a new one.</li> </ul> <p>In summary, <code>.map()</code> is a higher-order function in JavaScript because it accepts a function as an argument and applies it to each element in an array, returning a new array with the transformed results.</p>"},{"location":"js/function/hof/map/#object-oriented-design-oop-patterns","title":"Object-oriented design (OOP) patterns","text":"<p><code>pg: 412</code></p>"},{"location":"js/function/hof/map/#functional-design-patterns","title":"Functional design patterns","text":"<p><code>pg: 417</code></p> <p>Having seen several OOP design patterns, it may seem a cheat to say that there\u2019s no approved, official, or even remotely generally accepted similar list of patterns for FP.</p>"},{"location":"js/function/hof/map/#processing-collections-using-filtermapreduce","title":"Processing collections using filter/map/reduce:","text":"<p>Whenever you have to process a data collection, using declarative higher-order functions such as <code>filter()</code>, <code>map()</code>, and <code>reduce()</code>.</p>"},{"location":"js/function/hof/map/#lazy-evaluation-with-thunks","title":"Lazy evaluation with thunks:","text":"<p>The idea of lazy evaluation is not doing any calculations until they are actually needed. In some programming languages, this is built in. However, in JavaScript (and most imperative languages), eager evaluation is applied, in which an expression is evaluated as soon as it is bound to some variable. (Another way of saying this is that JavaScript is a strict programming language, with a strict paradigm, which only allows calling a function if all of its parameters have been completely evaluated.) This sort of evaluation is required when you need to specify the order of evaluation with precision, mainly because such evaluations may have side effects.</p>"},{"location":"js/function/hof/map/#persistent-data-structures-for-immutability","title":"Persistent data structures for immutability","text":"<p>Having immutable data structures, is mandatory when working with certain frameworks, and in general, it is recommended because it helps to reason about a program or to debug it.</p>"},{"location":"js/function/hof/map/#wrapped-values-for-checks-and-operations","title":"Wrapped values for checks and operations:","text":"<p>If you directly work with variables or data structures, you can modify them at will (possibly violating any restrictions), or you may need to do many checks before using them (such as verifying that a value is not null before trying to access the corresponding object). This pattern aims to wrap a value within an object or function, so direct manipulation won\u2019t be possible, and checks can be managed more functionally.</p>"},{"location":"js/function/hof/question-answer/","title":"Q&A","text":"<p>Here's a set of Higher-Order Function (HOF) practice questions in JavaScript, ranging from beginner to intermediate level. These questions will help you improve your understanding and use of higher-order functions like <code>map()</code>, <code>filter()</code>, <code>reduce()</code>, and custom HOFs.</p>"},{"location":"js/function/hof/question-answer/#beginner-level-understanding-basic-hofs","title":"Beginner Level (Understanding Basic HOFs)","text":"1. What is a higher-order function in JavaScript? <ul> <li> <p>Cognitive Skill: Comprehension</p> </li> <li> <p>Explanation:</p> <p>Define a higher-order function and provide an example (e.g., <code>map()</code>, <code>filter()</code>, r<code>educe()</code>).</p> </li> </ul> 2. Given an array of numbers, use <code>map()</code> to create a new array where each number is squared. <ul> <li> <p>Cognitive Skill: Application</p> </li> <li> <p>Example:</p> <pre><code>let numbers = [1, 2, 3, 4];\n// Use map to square the numbers\n</code></pre> </li> </ul> 3. Use <code>filter()</code> to create a new array containing only the numbers greater than 10 from the following array: <code>[5, 12, 7, 30, 8, 2]</code>. <ul> <li> <p>Cognitive Skill: Application</p> </li> <li> <p>Example:</p> <pre><code>let numbers = [5, 12, 7, 30, 8, 2];\n// Use filter to select numbers greater than 10\n</code></pre> </li> </ul> 4. Using the <code>reduce()</code> method, calculate the sum of an array of numbers. <ul> <li> <p>Cognitive Skill: Application</p> </li> <li> <p>Example:</p> <pre><code>let numbers = [1, 2, 3, 4, 5];\n// Use reduce to sum the numbers\n</code></pre> </li> </ul> 5. Create a higher-order function that takes a function as an argument and returns a new function that calls the original function twice. <ul> <li> <p>Cognitive Skill: Synthesis</p> </li> <li> <p>Example:</p> <pre><code>function callTwice(fn) {\n    return function(...args) {\n        fn(...args);\n        fn(...args);\n    };\n}\n</code></pre> </li> </ul>"},{"location":"js/function/hof/question-answer/#intermediate-level-advanced-use-of-hofs","title":"Intermediate Level (Advanced Use of HOFs)","text":"6. Write a function that accepts an array and a callback, and uses map() to apply the callback to each element of the array. <ul> <li> <p>Cognitive Skill: Application</p> </li> <li> <p>Example:</p> <pre><code>function mapArray(arr, callback) {\n    return arr.map(callback);\n}\n\nlet result = mapArray([1, 2, 3, 4], num =&gt; num * 2); // [2, 4, 6, 8]\n</code></pre> </li> </ul> 7. Create a higher-order function that accepts an array and returns a new array with only the odd numbers, using <code>filter()</code>. <ul> <li> <p>Cognitive Skill: Application</p> </li> <li> <p>Example:</p> <pre><code>function filterOdds(arr) {\n    return arr.filter(num =&gt; num % 2 !== 0);\n}\n</code></pre> </li> </ul> 8. Write a function that returns the average of an array of numbers using reduce(). <ul> <li> <p>Cognitive Skill: Problem Solving</p> </li> <li> <p>Example:</p> <pre><code>function average(arr) {\n    return arr.reduce((acc, num) =&gt; acc + num, 0) / arr.length;\n}\n</code></pre> </li> </ul> 9. Create a function that accepts two arrays of numbers and returns an array of numbers that are present in both arrays, using <code>filter()</code> and <code>includes()</code>. <ul> <li> <p>Cognitive Skill: Application</p> </li> <li> <p>Example:</p> <pre><code>function intersection(arr1, arr2) {\n    return arr1.filter(num =&gt; arr2.includes(num));\n}\n</code></pre> </li> </ul> 10. Write a higher-order function <code>compose()</code> that allows you to compose multiple functions together. <ul> <li> <p>Cognitive Skill: Synthesis</p> </li> <li> <p>Example:</p> <pre><code>function compose(...fns) {\n    return function (value) {\n        return fns.reduceRight((acc, fn) =&gt; fn(acc), value);\n    };\n}\n\nlet add = (x) =&gt; x + 1;\nlet multiply = (x) =&gt; x * 2;\nlet addThenMultiply = compose(multiply, add);\nconsole.log(addThenMultiply(2)); // 6 (add 1, then multiply by 2)\n</code></pre> </li> </ul>"},{"location":"js/function/hof/question-answer/#intermediate-to-advanced-level-custom-higher-order-functions","title":"Intermediate to Advanced Level (Custom Higher-Order Functions)","text":"11. Create a function <code>debounce()</code> that accepts a function and a delay, and ensures the function is called only after the specified delay and only if the last call occurred after the delay. <ul> <li> <p>Cognitive Skill: Problem Solving/Optimization</p> </li> <li> <p>Example:</p> <pre><code>function debounce(fn, delay) {\n    let timeout;\n    return function(...args) {\n        clearTimeout(timeout);\n        timeout = setTimeout(() =&gt; fn(...args), delay);\n    };\n}\n</code></pre> </li> </ul> 12. Write a function <code>once()</code> that ensures a given function can only be called once, no matter how many times it is invoked. <ul> <li> <p>Cognitive Skill: Problem Solving/Abstraction</p> </li> <li> <p>Example:</p> <pre><code>function once(fn) {\n    let called = false;\n    return function(...args) {\n        if (!called) {\n            called = true;\n            return fn(...args);\n        }\n    };\n}\n</code></pre> </li> </ul> 13. Write a <code>memoize()</code> function that caches the results of a function based on its arguments. If the same arguments are provided again, it should return the cached result instead of recalculating it. <ul> <li> <p>Cognitive Skill: Problem Solving/Optimization</p> </li> <li> <p>Example:</p> <pre><code>function memoize(fn) {\n    let cache = {};\n    return function(...args) {\n        const key = JSON.stringify(args);\n        if (cache[key]) {\n            return cache[key];\n        }\n        const result = fn(...args);\n        cache[key] = result;\n        return result;\n    };\n}\n</code></pre> </li> </ul> 14. Write a function <code>repeat()</code> that takes a string and a number as arguments and returns the string repeated that many times. Use <code>Array.from()</code> with <code>map()</code> to accomplish this. <ul> <li> <p>Cognitive Skill: Application</p> </li> <li> <p>Example:</p> <pre><code>function repeat(str, num) {\n    return Array.from({ length: num }, () =&gt; str).join('');\n}\n</code></pre> </li> </ul> 15. Write a function <code>groupBy()</code> that groups an array of objects by a property. The function should return an object where the keys are the unique values of that property, and the values are arrays of objects. <ul> <li> <p>Cognitive Skill: Problem Solving/Abstraction</p> </li> <li> <p>Example:</p> <pre><code>function groupBy(arr, key) {\n    return arr.reduce((acc, obj) =&gt; {\n        const groupKey = obj[key];\n        if (!acc[groupKey]) {\n            acc[groupKey] = [];\n        }\n\n        acc[groupKey].push(obj);\n        return acc;\n    }, {});\n}\n</code></pre> </li> </ul>"},{"location":"js/function/hof/question-answer/#advanced-level-complex-hofs-composition","title":"Advanced Level (Complex HOFs &amp; Composition)","text":"16. Implement a function <code>pipe()</code> that allows you to apply multiple functions from left to right. <ul> <li> <p>Cognitive Skill: Composition/Synthesis</p> </li> <li> <p>Example:</p> <pre><code>function pipe(...fns) {\n    return function(value) {\n        return fns.reduce((acc, fn) =&gt; fn(acc), value);\n    };\n}\n\nconst add2 = x =&gt; x + 2;\nconst multiplyBy3 = x =&gt; x * 3;\nconst pipeExample = pipe(add2, multiplyBy3);\nconsole.log(pipeExample(4)); // 18 (4 + 2, then * 3)\n</code></pre> </li> </ul> 17. Write a function <code>flatten()</code> that flattens a nested array using recursion and <code>reduce()</code>. <ul> <li> <p>Cognitive Skill: Problem Solving/Recursion</p> </li> <li> <p>Example:</p> <pre><code>function flatten(arr) {\n    return arr.reduce((acc, val) =&gt; Array.isArray(val) ? acc.concat(flatten(val)) : acc.concat(val), []);\n}\n</code></pre> </li> </ul> 18. Create a function <code>oncePerInterval()</code> that allows a function to be called only once within a given time interval (e.g., 2000ms). <ul> <li> <p>Cognitive Skill: Problem Solving/Abstraction</p> </li> <li> <p>Example:</p> <pre><code>function oncePerInterval(fn, interval) {\n    let lastCall = 0;\n\n    return function(...args) {\n        const now = Date.now();\n\n        if (now - lastCall &gt;= interval) {\n            lastCall = now;\n            fn(...args);\n        }\n    };\n}\n</code></pre> </li> </ul> 19. Write a <code>partial()</code> function that allows you to pre-fill some arguments for a function, and then apply the remaining arguments later. <ul> <li> <p>Cognitive Skill: Abstraction/Synthesis</p> </li> <li> <p>Example:</p> <pre><code>function partial(fn, ...args1) {\n    return function(...args2) {\n        return fn(...args1, ...args2);\n    };\n}\n</code></pre> </li> </ul> 20. Write a function <code>asyncMap()</code> that works like <code>map()</code>, but it works with asynchronous functions and returns a promise of the mapped results. <ul> <li> <p>Cognitive Skill: Asynchronous Programming/Abstraction</p> </li> <li> <p>Example:</p> <pre><code>function asyncMap(arr, asyncFn) {\n    return Promise.all(arr.map(asyncFn));\n}\n</code></pre> </li> </ul>"},{"location":"js/function/hof/question-answer/#tips-for-practicing-hofs-in-javascript","title":"Tips for Practicing HOFs in JavaScript:","text":"<ul> <li>Practice using built-in HOFs like <code>map()</code>, <code>filter()</code>, and <code>reduce()</code>. They're powerful and frequently used in real-world code.</li> <li>Experiment with custom HOFs: Start building your own higher-order functions to modify or enhance behavior.</li> <li>Combine HOFs: Get comfortable chaining and composing multiple HOFs together for more powerful solutions.</li> <li>Understand the inner workings: Think about closures, scope, and how HOFs allow you to abstract behavior in clean and reusable ways.</li> </ul> <p>These questions will help you deepen your understanding of higher-order functions in JavaScript and improve your ability to use them in real-world scenarios!</p> <p></p> <p></p>"},{"location":"js/hoisting/intro/","title":"Hoisting","text":""},{"location":"js/hoisting/intro/#hoisting","title":"Hoisting","text":"<p>Hoisting means \u201cmoving to the beginning of a scope.\u201d Function declarations are hoisted completely, variable declarations only partially.</p> <p>Function declarations are completely hoisted. That allows you to call a function before it has been declared:</p> <pre><code>foo();\n\nfunction foo() { // this function is hoisted\n    ...\n}\n</code></pre> <p>The reason the preceding code works is that JavaScript engines move the declaration of <code>foo</code> to the beginning of the scope. They execute the code as if it looked like this:</p> <pre><code>function foo() {\n    ...\n}\n\nfoo();\n</code></pre> <p><code>var</code> declarations are hoisted, too, but only the declarations, not assignments made with them. Therefore, using a <code>var</code> declaration and a function expression similarly to the previous example results in an error:</p>"},{"location":"js/hoisting/intro/#reference","title":"Reference","text":"<ul> <li>Speaking JavaScript by Dr. Axel Rauschmayer</li> </ul>"},{"location":"js/httprequest/cancellation-mechanisms/","title":"Cancellation Mechanisms","text":"<p>The AbortController in JavaScript is part of the modern Web APIs, specifically introduced to help manage and control asynchronous operations, particularly when dealing with tasks that may need to be <code>cancelled</code> or <code>terminated</code>.</p>"},{"location":"js/httprequest/cancellation-mechanisms/#most-used-cancellation-mechanisms","title":"Most used <code>cancellation mechanisms</code>","text":"<p>In React applications, handling asynchronous operations and cancellations is crucial for preventing memory leaks, avoiding unnecessary API calls, and improving user experience. When working with <code>axios</code> for HTTP requests, several cancellation mechanisms are commonly used. </p> <p>Here\u2019s a breakdown of the most commonly used approaches:</p> <ol> <li> <p>Axios Cancellation Token</p> <p><code>axios</code> provides built-in support for request cancellation via a cancellation token. This mechanism is straightforward and effective for handling cancellations in a React environment.</p> Basic Example <pre><code>import axios from 'axios';\nimport { useEffect, useState } from 'react';\n\nconst MyComponent = () =&gt; {\n    const [data, setData] = useState(null);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n\n    useEffect(() =&gt; {\n        // Create a CancelToken source\n        const source = axios.CancelToken.source();\n\n        const fetchData = async () =&gt; {\n            try {\n                const response = await axios.get('https://api.example.com/data', {\n                    cancelToken: source.token\n                });\n                setData(response.data);\n            } catch (err) {\n                if (axios.isCancel(err)) {\n                    console.log('Request canceled', err.message);\n                } else {\n                    setError(err);\n                }\n            } finally {\n                setLoading(false);\n            }\n        };\n\n        fetchData();\n\n        // Cleanup function to cancel the request\n        return () =&gt; {\n            source.cancel('Operation canceled by the user.');\n        };\n    }, []);\n\n    if (loading) return &lt;p&gt;Loading...&lt;/p&gt;;\n    if (error) return &lt;p&gt;Error: {error.message}&lt;/p&gt;;\n\n    return &lt;div&gt;Data: {JSON.stringify(data)}&lt;/div&gt;;\n};\n\nexport default MyComponent;\n</code></pre> </li> <li> <p><code>AbortController</code> with Fetch API</p> <p>While <code>axios</code> has its own cancellation mechanism, you might sometimes use the <code>Fetch</code> API with <code>AbortController</code> for cancellation. This approach can be used when you're not specifically using <code>axios</code> but need to handle fetch requests.</p> Basic Example <pre><code>import { useEffect, useState } from 'react';\n\nconst MyComponent = () =&gt; {\nconst [data, setData] = useState(null);\nconst [loading, setLoading] = useState(true);\nconst [error, setError] = useState(null);\n\nuseEffect(() =&gt; {\n    const controller = new AbortController();\n    const { signal } = controller;\n\n    const fetchData = async () =&gt; {\n        try {\n            const response = await fetch('https://api.example.com/data', { signal });\n            if (!response.ok) {\n                throw new Error('Network response was not ok');\n            }\n            const result = await response.json();\n            setData(result);\n        } catch (err) {\n            if (err.name === 'AbortError') {\n                console.log('Fetch aborted');\n            } else {\n                setError(err);\n            }\n        } finally {\n            setLoading(false);\n        }\n    };\n\n    fetchData();\n\n    return () =&gt; {\n        controller.abort();\n    };\n}, []);\n\nif (loading) return &lt;p&gt;Loading...&lt;/p&gt;;\nif (error) return &lt;p&gt;Error: {error.message}&lt;/p&gt;;\n\nreturn &lt;div&gt;Data: {JSON.stringify(data)}&lt;/div&gt;;\n};\n\nexport default MyComponent;\n</code></pre> </li> <li> <p>Using <code>react-query</code></p> <p><code>react-query</code> is a popular library for managing server state in React applications. It includes built-in support for request cancellation, caching, and other advanced features. It is particularly useful for managing asynchronous data fetching in a more declarative way.</p> Basic Example <pre><code>import { useQuery } from 'react-query';\nimport axios from 'axios';\n\nconst fetchData = async () =&gt; {\n    const response = await axios.get('https://api.example.com/data');\n    return response.data;\n};\n\nconst MyComponent = () =&gt; {\n    const { data, error, isLoading } = useQuery('fetchData', fetchData);\n\n    if (isLoading) return &lt;p&gt;Loading...&lt;/p&gt;;\n    if (error) return &lt;p&gt;Error: {error.message}&lt;/p&gt;;\n    return &lt;div&gt;Data: {JSON.stringify(data)}&lt;/div&gt;;\n};\n\nexport default MyComponent;\n</code></pre> </li> <li> <p>Using Libraries for Cancellations</p> <p>Libraries such as <code>axios-cancel</code> provide additional features for handling cancellations and other advanced patterns. These libraries can be integrated with <code>axios</code> for more control over cancellation.</p> </li> </ol> Summary <ul> <li>Axios Cancellation Token: Directly supported by <code>axios</code>, easy to implement and widely used.</li> <li>AbortController with Fetch API: Useful for native fetch requests, provides a standard way to handle cancellations.</li> <li>react-query: Offers advanced features for data fetching, caching, and cancellation with built-in support for request management.</li> <li>Additional Libraries: Provide enhanced features and patterns for managing cancellations and asynchronous operations.</li> </ul> <p>In a real-world React application, the choice of cancellation mechanism often depends on the libraries and tools in use, as well as the specific requirements of the project.</p>"},{"location":"js/httprequest/cancellation-mechanisms/#categorized","title":"categorized","text":"<p>Certainly! Here's a categorized overview of the important concepts related to asynchronous operations in JavaScript:</p>"},{"location":"js/httprequest/cancellation-mechanisms/#1-basic-asynchronous-handling","title":"1. Basic Asynchronous Handling","text":"<ul> <li> <p>Callbacks</p> <ul> <li>Definition: Functions passed as arguments to other functions, executed after the first function completes.</li> <li>Example: <code>setTimeout(callback, delay)</code></li> </ul> </li> <li> <p>Promises</p> <ul> <li>Definition: Objects representing the eventual completion or failure of an asynchronous operation.</li> <li>Methods: <code>.then()</code>, <code>.catch()</code>, <code>.finally()</code></li> <li>Example: <code>new Promise((resolve, reject) =&gt; {...})</code></li> </ul> </li> <li> <p>Async/Await</p> <ul> <li>Definition: Syntax for working with promises that makes asynchronous code look synchronous.</li> <li>Keywords: <code>async</code>, <code>await</code></li> <li>Example: <code>async function fetchData() {...}</code></li> </ul> </li> </ul>"},{"location":"js/httprequest/cancellation-mechanisms/#2-cancellation-mechanisms","title":"2. Cancellation Mechanisms","text":"<ul> <li> <p>AbortController</p> <ul> <li>Definition: Allows you to abort ongoing asynchronous operations.</li> <li>Usage: Provides an <code>AbortSignal</code> to communicate cancellation.</li> <li>Example: <code>fetch(url, { signal: controller.signal })</code></li> </ul> </li> <li> <p>Custom Cancellation Logic</p> <ul> <li>Definition: Implementing your own cancellation mechanism, often using flags.</li> <li>Example: Using a flag variable to signal cancellation.</li> </ul> </li> </ul>"},{"location":"js/httprequest/cancellation-mechanisms/#3-timing-and-scheduling","title":"3. Timing and Scheduling","text":"<ul> <li> <p>setTimeout / setInterval</p> <ul> <li>Definition: Schedule tasks to execute after a delay or at regular intervals.</li> <li>Methods: <code>setTimeout(callback, delay), setInterval(callback, interval)</code></li> <li>Example: <code>setTimeout(() =&gt; {...}, 1000)</code></li> </ul> </li> </ul>"},{"location":"js/httprequest/cancellation-mechanisms/#4-background-processing","title":"4. Background Processing","text":"<ul> <li> <p>Web Workers</p> <ul> <li>Definition: Allow scripts to run in background threads, enabling concurrent execution.</li> <li>Usage: Separate scripts for worker logic.</li> <li>Example: <code>new Worker('worker.js')</code></li> </ul> </li> </ul>"},{"location":"js/httprequest/cancellation-mechanisms/#5-promise-combinators","title":"5. Promise Combinators","text":"<ul> <li> <p>Promise.all</p> <ul> <li>Definition: Waits for all promises to be fulfilled or any to be rejected.</li> <li>Example: <code>Promise.all([promise1, promise2])</code></li> </ul> </li> <li> <p>Promise.any</p> <ul> <li>Definition: Waits for any promise to be fulfilled, ignoring rejections.</li> <li>Example: <code>Promise.any([promise1, promise2])</code></li> </ul> </li> <li> <p>Promise.race</p> <ul> <li>Definition: Returns the result of the first promise that resolves or rejects.</li> <li>Example: <code>Promise.race([promise1, promise2])</code></li> </ul> </li> <li> <p>Promise.allSettled</p> <ul> <li>Definition: Waits for all promises to be settled (fulfilled or rejected) and returns their results.</li> <li>Example: <code>Promise.allSettled([promise1, promise2])</code></li> </ul> </li> </ul>"},{"location":"js/httprequest/cancellation-mechanisms/#6-execution-management","title":"6. Execution Management","text":"<ul> <li> <p>Event Loop</p> <ul> <li>Definition: Manages the execution of code, handling asynchronous operations and callbacks.</li> <li>Function: Processes the call stack and handles tasks in the callbacks queue.</li> </ul> </li> <li> <p>Callbacks Queue</p> <ul> <li>Definition: A queue where functions to be executed are placed, managed by the event loop.</li> </ul> </li> </ul> Summary <p>Here\u2019s a quick reference categorization:</p> <p>Basic Asynchronous Handling:</p> <ul> <li>Callbacks</li> <li>Promises</li> <li>Async/Await</li> </ul> <p>Cancellation Mechanisms:</p> <ul> <li>AbortController</li> <li>Custom Cancellation Logic</li> </ul> <p>Timing and Scheduling:</p> <ul> <li>setTimeout / setInterval</li> </ul> <p>Background Processing:</p> <ul> <li>Web Workers</li> </ul> <p>Promise Combinators:</p> <ul> <li>Promise.all</li> <li>Promise.any</li> <li>Promise.race</li> <li>Promise.allSettled</li> </ul> <p>Execution Management:</p> <ul> <li>Event Loop</li> <li>Callbacks Queue</li> </ul> <p>By categorizing these concepts, you can more easily remember and apply them in different scenarios when dealing with asynchronous operations in JavaScript.</p> <pre><code>Practical Applications and Patterns\n\n    Common Patterns for Asynchronous Code\n        Error Handling Strategies\n        Avoiding Callback Hell\n        Optimizing Performance with Asynchronous Code\n\nAdvanced Topics and Libraries\n\n    Cancelable Promises\n    Using Third-Party Libraries for Asynchronous Operations\n        Libraries like `axios`, `bluebird`, or `async.js`\n\nSummary and Best Practices\n\n    Review of Key Concepts\n    Best Practices for Writing Asynchronous Code\n    Performance Considerations\n</code></pre>"},{"location":"js/httprequest/cancellation-mechanisms/#debugging-or-logging","title":"Debugging or Logging","text":"BasicAdvanced <pre><code>useEffect(() =&gt; {\n    console.log('useEffect triggered at', new Date().toISOString()); // Log when useEffect is triggered\n    const controller = new AbortController();\n    const signal = controller.signal;\n\n    const API_URL = process.env.REACT_APP_API_URL;\n    const API_KEY = process.env.REACT_APP_API_KEY;\n\n    console.log('Starting fetch at', new Date().toISOString()); // Log fetch start time\n    fetchData(API_URL, API_KEY, signal);\n\n    return () =&gt; {\n        console.log('Cleaning up at', new Date().toISOString()); // Log cleanup time\n        controller.abort();\n    };\n}, []);\n</code></pre> <pre><code>const fetchData = async (url, apiKey, signal) =&gt; {\n    console.log('Starting fetch request at', new Date().toISOString()); // Log fetch start\n\n    try {\n        const response = await fetch(url, {\n            method: 'GET',\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Api-Key ${apiKey}`,\n            },\n            signal, // Pass the signal to fetch\n        });\n\n        if (!response.ok) {\n            throw new Error('Network response was not ok');\n        }\n        const data = await response.json();\n        console.log('Fetch successful at', new Date().toISOString()); // Log success\n        setData(data);\n    } catch (error) {\n        if (error.name === 'AbortError') {\n            console.log('Fetch request was aborted at', new Date().toISOString()); // Log abort\n        } else {\n            setError(error);\n        }\n    } finally {\n        setLoading(false);\n    }\n};\n</code></pre>"},{"location":"js/httprequest/cancellation-mechanisms/#diagnostic-steps","title":"Diagnostic Steps","text":"<pre><code>import React, { useEffect, useState } from 'react';\n\nconst YourComponent = () =&gt; {\n    const [data, setData] = useState(null);\n    const [error, setError] = useState(null);\n    const [loading, setLoading] = useState(true);\n\n    const fetchData = async (url, apiKey, signal) =&gt; {\n        console.log('Starting fetch...'); // Debug log\n        try {\n            const response = await fetch(url, {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Api-Key ${apiKey}`,\n                },\n                signal, // Pass the signal to fetch\n            });\n\n            if (!response.ok) {\n                throw new Error('Network response was not ok');\n            }\n            const data = await response.json();\n            setData(data);\n        } catch (error) {\n            if (error.name === 'AbortError') {\n                console.log('Fetch request was aborted');\n            } else {\n                setError(error);\n            }\n        } finally {\n            setLoading(false);\n        }\n    };\n\n    useEffect(() =&gt; {\n        console.log('useEffect triggered'); // Debug log\n        const controller = new AbortController(); // Create a new AbortController\n        const signal = controller.signal;\n\n        const API_URL = process.env.REACT_APP_API_URL;\n        const API_KEY = process.env.REACT_APP_API_KEY;\n\n        fetchData(API_URL, API_KEY, signal);\n\n        // Cleanup function to abort the request if the component unmounts\n        return () =&gt; {\n            console.log('Cleaning up...'); // Debug log\n            controller.abort();\n        };\n    }, []); // Empty dependency array means this effect runs once when the component mounts\n\n    return (\n        &lt;div&gt;\n            {loading &amp;&amp; &lt;p&gt;Loading...&lt;/p&gt;}\n            {error &amp;&amp; &lt;p&gt;Error: {error.message}&lt;/p&gt;}\n            {data &amp;&amp; &lt;div&gt;{/* Render your data here */}&lt;/div&gt;}\n        &lt;/div&gt;\n    );\n};\n\nexport default YourComponent;\n</code></pre>"},{"location":"js/httprequest/intro/","title":"Intro","text":""},{"location":"js/httprequest/intro/#intro","title":"Intro","text":"<p>Here's a list of popular React fetching libraries along with brief descriptions and example usage for each:</p>"},{"location":"js/httprequest/intro/#1-fetch-api","title":"1. Fetch API","text":"<p>The native way to make HTTP requests in JavaScript.</p> <pre><code>useEffect(() =&gt; {\n  fetch('https://api.example.com/data')\n    .then(response =&gt; response.json())\n    .then(data =&gt; console.log(data))\n    .catch(error =&gt; console.error('Error:', error));\n}, []);\n</code></pre>"},{"location":"js/httprequest/intro/#2-axios","title":"2. Axios","text":"<p>A promise-based HTTP client for the browser and Node.js.</p> <pre><code>import axios from 'axios';\n\nuseEffect(() =&gt; {\n  axios.get('https://api.example.com/data')\n    .then(response =&gt; console.log(response.data))\n    .catch(error =&gt; console.error('Error:', error));\n}, []);\n</code></pre>"},{"location":"js/httprequest/intro/#3-superagent","title":"3. SuperAgent","text":"<p>A small, progressive HTTP request library.</p> <pre><code>import superagent from 'superagent';\n\nuseEffect(() =&gt; {\n  superagent.get('https://api.example.com/data')\n    .then(response =&gt; console.log(response.body))\n    .catch(error =&gt; console.error('Error:', error));\n}, []);\n</code></pre>"},{"location":"js/httprequest/intro/#4-swr","title":"4. SWR","text":"<p>A React Hooks library for remote data fetching developed by Vercel.</p> <pre><code>import useSWR from 'swr';\n\nconst fetcher = url =&gt; fetch(url).then(res =&gt; res.json());\n\nfunction Component() {\n  const { data, error } = useSWR('https://api.example.com/data', fetcher);\n\n  if (error) return &lt;div&gt;Error loading data&lt;/div&gt;;\n  if (!data) return &lt;div&gt;Loading...&lt;/div&gt;;\n\n  return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n</code></pre>"},{"location":"js/httprequest/intro/#5-react-query","title":"5. React Query","text":"<p>A powerful data-fetching and state management library for React.</p> <pre><code>import { useQuery } from 'react-query';\n\nconst fetcher = async () =&gt; {\n  const response = await fetch('https://api.example.com/data');\n  return response.json();\n};\n\nfunction Component() {\n  const { data, error, isLoading } = useQuery('dataKey', fetcher);\n\n  if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;\n  if (error) return &lt;div&gt;Error loading data&lt;/div&gt;;\n\n  return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n</code></pre>"},{"location":"js/httprequest/intro/#6-apollo-client","title":"6. Apollo Client","text":"<p>A comprehensive solution for managing GraphQL data.</p> <pre><code>import { useQuery, gql } from '@apollo/client';\n\nconst GET_DATA = gql`\n  query GetData {\n    data {\n      id\n      name\n    }\n  }\n`;\n\nfunction Component() {\n  const { data, loading, error } = useQuery(GET_DATA);\n\n  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n  if (error) return &lt;div&gt;Error loading data&lt;/div&gt;;\n\n  return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n</code></pre>"},{"location":"js/httprequest/intro/#7-relay","title":"7. Relay","text":"<p>A JavaScript framework for building data-driven React applications using GraphQL.</p> <pre><code>import {\n  RelayEnvironmentProvider,\n  loadQuery,\n  usePreloadedQuery,\n  graphql,\n} from 'react-relay/hooks';\nimport RelayEnvironment from './RelayEnvironment';\n\nconst { PreloadedQuery, PreloadableQuery } = loadQuery(\n  RelayEnvironment,\n  graphql`\n    query AppQuery {\n      viewer {\n        name\n      }\n    }\n  `\n);\n\nfunction Component(props) {\n  const data = usePreloadedQuery(PreloadableQuery, props.preloadedQuery);\n  return &lt;div&gt;{data.viewer.name}&lt;/div&gt;;\n}\n\nfunction App() {\n  return (\n    &lt;RelayEnvironmentProvider environment={RelayEnvironment}&gt;\n      &lt;Component preloadedQuery={PreloadedQuery} /&gt;\n    &lt;/RelayEnvironmentProvider&gt;\n  );\n}\n</code></pre>"},{"location":"js/httprequest/intro/#8-urql","title":"8. Urql","text":"<p>A highly customizable and versatile GraphQL client for React.</p> <pre><code>import { createClient, Provider, useQuery } from 'urql';\n\nconst client = createClient({\n  url: 'https://api.example.com/graphql',\n});\n\nconst GET_DATA = `\n  query {\n    data {\n      id\n      name\n    }\n  }\n`;\n\nfunction Component() {\n  const [result] = useQuery({ query: GET_DATA });\n  const { data, fetching, error } = result;\n\n  if (fetching) return &lt;div&gt;Loading...&lt;/div&gt;;\n  if (error) return &lt;div&gt;Error loading data&lt;/div&gt;;\n\n  return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n\nfunction App() {\n  return (\n    &lt;Provider value={client}&gt;\n      &lt;Component /&gt;\n    &lt;/Provider&gt;\n  );\n}\n</code></pre> <p>These libraries cover a range of use cases from basic HTTP requests to advanced GraphQL queries, allowing you to choose the one that best fits your project's needs.</p> Tips <ol> <li> <p>JavaScript Fundamentals</p> <ul> <li>Promises and Async/Await: Understanding how promises work and how to use async/await syntax for handling asynchronous code is crucial.</li> <li>Error Handling: Knowing how to handle errors properly in asynchronous code.</li> </ul> </li> <li> <p>Data Fetching</p> <ul> <li>Fetch API: Basic understanding of the native Fetch API as a starting point.</li> <li>Axios: Learning how to use Axios for more advanced use cases.</li> </ul> </li> <li> <p>Error Handling</p> <ul> <li>Properly handle errors in data fetching.</li> <li>Display appropriate error messages to users.</li> </ul> </li> </ol>"},{"location":"js/httprequest/intro/#setup-and-installation","title":"Setup and Installation:","text":"<ol> <li> <p>Practical Steps to Get Started</p> <ul> <li>Install the chosen library using npm or yarn.</li> </ul> <pre><code>npm install axios\nnpm install swr\nnpm install @apollo/client graphql\nnpm install react-query\n</code></pre> </li> <li> <p>Basic Fetching:</p> <ul> <li>Write a simple data-fetching component.</li> </ul> <pre><code>import axios from 'axios';\nimport { useEffect, useState } from 'react';\n\nfunction DataFetchingComponent() {\nconst [data, setData] = useState(null);\n\nuseEffect(() =&gt; {\n    axios.get('https://api.example.com/data')\n    .then(response =&gt; setData(response.data))\n    .catch(error =&gt; console.error(error));\n}, []);\n\nif (!data) return &lt;div&gt;Loading...&lt;/div&gt;;\n\nreturn &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n</code></pre> </li> <li> <p>Error Handling:</p> <ul> <li>Implement proper error handling.</li> </ul> <pre><code>useEffect(() =&gt; {\naxios.get('https://api.example.com/data')\n    .then(response =&gt; setData(response.data))\n    .catch(error =&gt; {\n    console.error(error);\n    setError('Failed to fetch data');\n    });\n}, []);\n</code></pre> </li> <li> <p>Using Hooks:</p> <ul> <li>For libraries like SWR or React Query, understand and use their custom hooks.</li> </ul> <pre><code>import useSWR from 'swr';\nconst fetcher = url =&gt; fetch(url).then(res =&gt; res.json());\n\nfunction DataFetchingComponent() {\nconst { data, error } = useSWR('https://api.example.com/data', fetcher);\n\nif (error) return &lt;div&gt;Error loading data&lt;/div&gt;;\nif (!data) return &lt;div&gt;Loading...&lt;/div&gt;;\n\nreturn &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n</code></pre> </li> <li> <p>Advanced Usage:</p> <ul> <li>Explore more advanced features such as pagination, caching, and optimistic updates provided by libraries like React Query and SWR.</li> </ul> </li> </ol> <p>By understanding these core concepts and gradually building upon them, you will be well-prepared to effectively use any data-fetching library in React.</p> <p>In JavaScript, there are several traditional ways to fetch API data, including:</p>"},{"location":"js/httprequest/intro/#traditional-methods-in-javascript","title":"Traditional Methods in JavaScript:","text":"<ol> <li> <p>XMLHttpRequest:</p> <pre><code>var xhr = new XMLHttpRequest();\nxhr.open('GET', 'https://api.example.com/data', true);\nxhr.onload = function () {\n    if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) {\n        console.log(JSON.parse(xhr.responseText));\n    } else {\n        console.error('Request failed');\n    }\n};\nxhr.send();\n</code></pre> </li> <li> <p>Fetch API:</p> <pre><code>fetch('https://api.example.com/data')\n.then(response =&gt; response.json())\n.then(data =&gt; console.log(data))\n.catch(error =&gt; console.error('Error:', error));\n</code></pre> </li> <li> <p>Async/Await with Fetch API:</p> <pre><code>async function fetchData() {\n    try {\n        const response = await fetch('https://api.example.com/data');\n        const data = await response.json();\n        console.log(data);\n    } catch (error) {\n        console.error('Error:', error);\n    }\n}\nfetchData();\n</code></pre> </li> </ol>"},{"location":"js/httprequest/intro/#packages-in-react-to-fetch-api-data","title":"Packages in React to Fetch API Data:","text":"<ol> <li> <p>Axios:</p> <pre><code>import axios from 'axios';\n\naxios.get('https://api.example.com/data')\n    .then(response =&gt; console.log(response.data))\n    .catch(error =&gt; console.error('Error:', error));\n</code></pre> <p>Using Axios with async/await:</p> <pre><code>import axios from 'axios';\n\nasync function fetchData() {\n    try {\n        const response = await axios.get('https://api.example.com/data');\n        console.log(response.data);\n    } catch (error) {\n        console.error('Error:', error);\n    }\n}\nfetchData();\n</code></pre> </li> <li> <p>React Query:</p> <pre><code>import { useQuery } from 'react-query';\n\nfunction MyComponent() {\n    const { isLoading, error, data } = useQuery('fetchData', () =&gt;\n        fetch('https://api.example.com/data').then(res =&gt; res.json())\n    );\n\n    if (isLoading) return 'Loading...';\n    if (error) return 'An error has occurred: ' + error.message;\n\n    return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n</code></pre> </li> <li> <p>SWR (stale-while-revalidate):</p> <pre><code>import useSWR from 'swr';\n\nconst fetcher = url =&gt; fetch(url).then(res =&gt; res.json());\n\nfunction MyComponent() {\n    const { data, error } = useSWR('https://api.example.com/data', fetcher);\n\n    if (error) return &lt;div&gt;Failed to load&lt;/div&gt;;\n    if (!data) return &lt;div&gt;Loading...&lt;/div&gt;;\n\n    return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n</code></pre> </li> <li> <p>useEffect with Fetch API:</p> <pre><code>import { useEffect, useState } from 'react';\n\nfunction MyComponent() {\n    const [data, setData] = useState(null);\n    const [isLoading, setIsLoading] = useState(true);\n    const [error, setError] = useState(null);\n\n    useEffect(() =&gt; {\n        fetch('https://api.example.com/data')\n            .then(response =&gt; response.json())\n            .then(data =&gt; {\n                setData(data);\n                setIsLoading(false);\n            })\n            .catch(error =&gt; {\n                setError(error);\n                setIsLoading(false);\n            });\n    }, []);\n\n    if (isLoading) return 'Loading...';\n    if (error) return 'An error has occurred: ' + error.message;\n\n    return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n</code></pre> </li> </ol> <p>These methods and packages cover a range of use cases and preferences for fetching API data in JavaScript and React applications.</p>"},{"location":"js/httprequest/core/api-response-object/","title":"Response Object","text":"when we fetch the api endpoint, the reponse data is in which format do we get? object or string <p>When you fetch data from an API endpoint, the response data is typically received as a <code>string</code>. This string needs to be parsed into an object to be usable within your application.</p> Is the json response format is <code>object</code> or <code>string</code> ? <p>When you receive a JSON response from an API, the data is initially received as a string. This string represents the JSON data. To work with this data as a JavaScript object, you need to parse the JSON string into an object.</p> <p>Here's a detailed explanation:</p> so what is the difference between <code>.json()</code> method and <code>JSON.parse</code> when to use. is it the same <p>The <code>.json()</code> method and <code>JSON.parse()</code> serve similar purposes but are used in different contexts. Here's a breakdown of the differences and when to use each:</p> <code>.json()</code> MethodJSON.parse()Key Differences <ul> <li>Context: Used with the <code>fetch</code> API to read and parse the response body as JSON.</li> <li>Functionality: The <code>.json()</code> method is called on a Response object. It reads the response stream to completion and parses it as JSON.</li> <li>Return Value: Returns a promise that resolves with the result of parsing the response body text as JSON.</li> <li>Usage: Use <code>.json()</code> when dealing with the response from a fetch request.</li> </ul>"},{"location":"js/httprequest/core/api-response-object/#fetching-api-data-in-javascript","title":"Fetching API Data in JavaScript","text":"<p>When using the <code>fetch</code> API in JavaScript, the response is received as a raw stream of data, which is then processed into a string and parsed as needed. Here's the process:</p> <ol> <li>Fetching the Data:</li> </ol> javascript<pre><code>fetch('https://api.example.com/data')\n.then(response =&gt; response.json())  // Parses the response as JSON\n.then(data =&gt; {\n    console.log(data);  // The data is now a JavaScript object\n})\n.catch(error =&gt; console.error('Error:', error));\n</code></pre> <p>In this example, the <code>response.json()</code> method is called on the response object. This method reads the response stream to completion and parses it as JSON. The result is a JavaScript object.</p> Response Data Formats <ol> <li> <p>JSON (Most Common)</p> <ul> <li>Received as: String</li> <li>Parsed to: JavaScript object</li> <li>Example:</li> </ul> <pre><code>fetch('https://api.example.com/data')\n.then(response =&gt; response.json())  // Converts JSON string to JavaScript object\n.then(data =&gt; {\n    console.log(data);\n});\n</code></pre> </li> <li> <p>Text</p> <ul> <li>Received as: String</li> <li>Example:</li> </ul> <pre><code>fetch('https://api.example.com/text')\n.then(response =&gt; response.text())  // Reads response as plain text\n.then(data =&gt; {\n    console.log(data);\n});\n</code></pre> </li> <li> <p>Blob (Binary Large Object)</p> <ul> <li>Received as: Binary data</li> <li>Example:</li> </ul> <pre><code>fetch('https://api.example.com/image')\n.then(response =&gt; response.blob())  // Reads response as binary data (Blob)\n.then(blob =&gt; {\n    console.log(blob);\n});\n</code></pre> </li> <li> <p>FormData</p> <ul> <li>Received as: Form data</li> <li>Example:</li> </ul> <pre><code>fetch('https://api.example.com/formdata')\n.then(response =&gt; response.formData())  // Reads response as FormData\n.then(formData =&gt; {\n    console.log(formData);\n});\n</code></pre> </li> <li> <p>ArrayBuffer</p> <ul> <li>Received as: Binary data</li> <li>Example:</li> </ul> <pre><code>fetch('https://api.example.com/binary')\n.then(response =&gt; response.arrayBuffer())  // Reads response as ArrayBuffer\n.then(buffer =&gt; {\n    console.log(buffer);\n});\n</code></pre> </li> </ol>"},{"location":"js/httprequest/core/api-response-object/#summary","title":"Summary","text":"<p>When fetching data from an API endpoint, the response is initially received as a string or binary data. For JSON responses, which are most common, the string is parsed into a JavaScript object using the <code>response.json()</code> method. Other methods like <code>response.text()</code>, <code>response.blob()</code>, <code>response.formData()</code>, and <code>response.arrayBuffer()</code> are used to handle different types of response data. The parsed data can then be used within your application as needed.</p>"},{"location":"js/httprequest/core/api-response-object/#process-of-fetching-and-parsing-json-data","title":"Process of Fetching and Parsing JSON Data","text":"<ol> <li> <p>Fetching the Data:</p> <p>When you use the fetch API to make a request, the response body is a readable stream. This stream needs to be read to obtain the actual data.</p> </li> <li> <p>Response as JSON:</p> <p>The <code>response.json()</code> method reads the response stream to completion and parses the text as JSON. This method returns a promise that resolves with the result of parsing the body text as JSON.</p> </li> </ol>"},{"location":"js/httprequest/core/api-response-object/#example-in-javascript","title":"Example in JavaScript","text":"<ol> <li> <p>Fetching and Parsing JSON Data:</p> javascript<pre><code>fetch('https://api.example.com/data')\n.then(response =&gt; response.json())  // Parses the response text as JSON\n.then(data =&gt; {\n    console.log(data);  // 'data' is now a JavaScript object\n})\n.catch(error =&gt; console.error('Error:', error));\n</code></pre> </li> </ol> <p>In this example:</p> <ul> <li><code>fetch('https://api.example.com/data')</code> sends a request to the API.</li> <li><code>response.json()</code> reads the response stream and parses it as JSON, converting it from a string to a JavaScript object.</li> <li>The resulting data is a JavaScript object that can be used in your code.</li> </ul>"},{"location":"js/httprequest/core/api-response-object/#clarification-on-json-response","title":"Clarification on JSON Response","text":"<ul> <li>Initial Format: When the JSON response is received from the API, it is in string format.</li> <li>After Parsing: The JSON string is parsed into a JavaScript object using response.json().</li> </ul>"},{"location":"js/httprequest/core/api-response-object/#example-of-json-response","title":"Example of JSON Response","text":"<ol> <li> <p>Raw JSON Response (String):</p> json<pre><code>{\n    \"name\": \"Alice\",\n    \"age\": 30,\n    \"isMember\": true\n}\n</code></pre> </li> <li> <p>Parsed JavaScript Object:</p> javascript<pre><code>{\n    name: \"Alice\",\n    age: 30,\n    isMember: true\n}\n</code></pre> </li> </ol> <ul> <li>Context: Used to parse a JSON string into a JavaScript object.</li> <li>Functionality: <code>JSON.parse()</code> takes a JSON string and parses it to produce a JavaScript object.</li> <li>Return Value: Returns a JavaScript object.</li> <li>Usage: Use <code>JSON.parse()</code> when you have a JSON string (e.g., stored in a variable) and need to convert it to a JavaScript object.</li> </ul> javascript<pre><code>let jsonString = '{\"name\": \"Alice\", \"age\": 30, \"isMember\": true}';\nlet data = JSON.parse(jsonString);  // Parses JSON string into JavaScript object\nconsole.log(data.name);  // Output: Alice\n</code></pre> <ol> <li> <p>Source of Data:</p> <ul> <li><code>.json()</code>: Used directly on the Response object returned by the fetch API to handle the response stream.</li> <li><code>JSON.parse()</code>: Used on a JSON string that you already have (e.g., from a variable, local storage, etc.).</li> </ul> </li> <li> <p>Return Type:</p> <ul> <li><code>.json()</code>: Returns a promise that resolves with the parsed JavaScript object.</li> <li><code>JSON.parse()</code>: Directly returns the parsed JavaScript object.</li> </ul> </li> <li> <p>Common Usage:</p> <ul> <li><code>.json()</code>: Commonly used in asynchronous operations involving fetching data from APIs.</li> <li><code>JSON.parse()</code>: Used whenever you have a JSON string and need to convert it to a JavaScript object, irrespective of how you obtained the string.</li> </ul> </li> </ol>"},{"location":"js/httprequest/core/api-response-object/#summary_1","title":"Summary","text":"<p>While JSON responses from an API are initially received as strings, they are typically parsed into JavaScript objects using methods like <code>response.json()</code>. This parsing process is necessary to convert the string representation of the JSON data into a format (JavaScript object) that can be easily manipulated in your code.</p>"},{"location":"js/httprequest/core/api-response-object/#example","title":"Example","text":"JavaScript<pre><code>fetch('https://api.example.com/data')\n.then(response =&gt; response.json())  // Reads and parses response body as JSON\n.then(data =&gt; {\n    console.log(data);  // 'data' is now a JavaScript object\n})\n.catch(error =&gt; console.error('Error:', error));\n</code></pre>"},{"location":"js/httprequest/core/api-response-object/#summary_2","title":"Summary","text":"<ul> <li>Use <code>.json()</code>: When handling responses from fetch API requests to read and parse the JSON response.</li> <li>Use <code>JSON.parse()</code>: When you have a JSON string and need to convert it to a JavaScript object in other contexts.</li> </ul> <p>Both methods are essential for working with JSON data, but they are applied in different scenarios to achieve similar results: converting JSON-formatted data into JavaScript objects.</p>"},{"location":"js/httprequest/core/api-response-object/#what-is-reponse-api-object","title":"what is reponse API object","text":"<p>The Response object in the Fetch API represents the response to a request. It contains information about the response, including the status code, status text, headers, and the body of the response. This object is returned as a promise when a fetch request is made.</p> <p>Key Properties and Methods of the Response Object</p> PropertiesMethodsExampleExplanation <ul> <li>type: Indicates the type of the response (e.g., \"basic\", \"cors\", \"error\", \"opaque\").</li> <li>url: The URL of the response.</li> <li>redirected: Indicates whether the response is the result of a redirect.</li> <li>status: The status code of the response (e.g., 200 for a successful request).</li> <li>statusText: The status message corresponding to the status code (e.g., \"OK\" for status 200).</li> <li>ok: A boolean indicating whether the response was successful (status in the range 200-299).</li> <li>headers: The <code>Headers</code> object associated with the response.</li> <li>body: A <code>ReadableStream</code> of the body contents.</li> <li>bodyUsed: A boolean indicating whether the body has been read.</li> </ul> <ul> <li>arrayBuffer(): Reads the response body and returns it as a promise that resolves with an ArrayBuffer.</li> <li>blob(): Reads the response body and returns it as a promise that resolves with a Blob.</li> <li>formData(): Reads the response body and returns it as a promise that resolves with FormData.</li> <li>json(): Reads the response body and parses it as JSON, returning a promise that resolves with a JavaScript object.</li> <li>text(): Reads the response body and returns it as a promise that resolves with a string.</li> </ul> javascript<pre><code>fetch('https://api.example.com/data')\n.then(response =&gt; {\n    // Check if the request was successful\n    if (!response.ok) {\n    throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    // Access response properties\n    console.log(response.status);      // e.g., 200\n    console.log(response.statusText);  // e.g., \"OK\"\n    console.log(response.headers.get('Content-Type'));  // e.g., \"application/json\"\n\n    // Read and parse the response body\n    return response.json();  // Returns a promise that resolves with the JSON-parsed body\n})\n.then(data =&gt; {\n    // 'data' is now a JavaScript object\n    console.log(data);\n})\n.catch(error =&gt; {\n    console.error('Fetch error:', error);\n});\n</code></pre> <ol> <li><code>fetch('https://api.example.com/data')</code>: Initiates a request to the specified URL and returns a promise that resolves to a Response object.</li> <li><code>response.ok</code>: Checks if the response status code indicates a successful request.</li> <li><code>response.status</code>: Accesses the status code of the response.</li> <li><code>response.statusText</code>: Accesses the status text of the response.</li> <li><code>response.headers.get('Content-Type')</code>: Accesses the Content-Type header of the response.</li> <li><code>response.json()</code>: Reads and parses the response body as JSON, returning a promise that resolves to a JavaScript object.</li> <li>Handling the parsed data: The parsed JSON data is logged to the console.</li> <li>Error handling: Catches and logs any errors that occur during the fetch or parsing process.</li> </ol>"},{"location":"js/httprequest/core/api-response-object/#summary_3","title":"Summary","text":"<p>The Response object in the Fetch API encapsulates the response to a request, providing access to the status, headers, and body of the response. You use various methods like <code>.json()</code>, <code>.text()</code>, and others to read and parse the response body, converting it into a usable format such as a JavaScript object or string. This process is essential for working with API responses in web development.</p>"},{"location":"js/httprequest/core/axios/","title":"Axios","text":""},{"location":"js/httprequest/core/axios/#mastering-axios","title":"Mastering Axios","text":""},{"location":"js/httprequest/core/axios/#1-understanding-the-basics","title":"1. Understanding the Basics","text":"<ul> <li> <p>What is Axios?</p> <p>Axios is a promise-based HTTP client for the browser and Node.js. It provides a more feature-rich and flexible way to handle HTTP requests compared to Fetch API.</p> </li> <li> <p>Basic Syntax:</p> <pre><code>axios.get(url, config)\n    .then(response =&gt; console.log(response.data))\n    .catch(error =&gt; console.error('Error:', error));\n</code></pre> </li> <li> <p>Basic Example:</p> <pre><code>axios.get('https://api.example.com/data')\n    .then(response =&gt; console.log(response.data))\n    .catch(error =&gt; console.error('Error:', error));\n</code></pre> </li> </ul>"},{"location":"js/httprequest/core/axios/#2-handling-responses-and-errors","title":"2. Handling Responses and Errors","text":"<ul> <li> <p>Error Handling:</p> <pre><code>axios.get('https://api.example.com/data')\n    .then(response =&gt; console.log(response.data))\n    .catch(error =&gt; {\n        if (error.response) {\n            console.error('Response error:', error.response);\n        } else if (error.request) {\n            console.error('Request error:', error.request);\n        } else {\n            console.error('Error:', error.message);\n        }\n    });\n</code></pre> </li> </ul>"},{"location":"js/httprequest/core/axios/#3-making-different-types-of-requests","title":"3. Making Different Types of Requests","text":"<ul> <li> <p>GET Request:</p> <pre><code>axios.get('https://api.example.com/data')\n    .then(response =&gt; console.log(response.data));\n</code></pre> </li> <li> <p>POST Request with Body:</p> <pre><code>axios.post('https://api.example.com/data', { key: 'value' })\n    .then(response =&gt; console.log(response.data));\n</code></pre> </li> <li> <p>PUT Request:</p> <pre><code>axios.put('https://api.example.com/data/1', { key: 'new value' })\n    .then(response =&gt; console.log(response.data));\n</code></pre> </li> <li> <p>DELETE Request:</p> <pre><code>axios.delete('https://api.example.com/data/1')\n    .then(response =&gt; console.log(response.data));\n</code></pre> </li> </ul>"},{"location":"js/httprequest/core/axios/#4-advanced-features","title":"4. Advanced Features","text":"<ul> <li> <p>Request and Response Interceptors:</p> <pre><code>// Add a request interceptor\naxios.interceptors.request.use(config =&gt; {\n    console.log('Request:', config);\n    return config;\n}, error =&gt; {\n    return Promise.reject(error);\n});\n\n// Add a response interceptor\naxios.interceptors.response.use(response =&gt; {\n    console.log('Response:', response);\n    return response;\n}, error =&gt; {\n    return Promise.reject(error);\n});\n</code></pre> </li> <li> <p>Cancel Requests:</p> <pre><code>const source = axios.CancelToken.source();\n\naxios.get('https://api.example.com/data', { cancelToken: source.token })\n    .then(response =&gt; console.log(response.data))\n    .catch(error =&gt; {\n        if (axios.isCancel(error)) {\n            console.log('Request canceled:', error.message);\n        } else {\n            console.error('Axios error:', error);\n        }\n    });\n\n// To cancel the request\nsource.cancel('Operation canceled by the user.');\n</code></pre> </li> <li> <p>Concurrent Requests:</p> <pre><code>axios.all([\n    axios.get('https://api.example.com/data1'),\n    axios.get('https://api.example.com/data2')\n])\n    .then(axios.spread((response1, response2) =&gt; {\n        console.log('Response 1:', response1.data);\n        console.log('Response 2:', response2.data);\n    }));\n</code></pre> </li> </ul>"},{"location":"js/httprequest/core/axios/#practical-steps-to-master-both","title":"Practical Steps to Master Both","text":"<ol> <li>Start with Basic Examples: Implement simple GET and POST requests using both Fetch API and Axios.</li> <li>Explore Error Handling: Write code to handle various types of errors and status codes.</li> <li>Work with Different Request Methods: Practice using GET, POST, PUT, and DELETE methods.</li> <li>Dive into Advanced Features: Explore features like request/response interceptors, request cancellation, and concurrent requests.</li> <li>Build Real Projects: Apply what you've learned in real-world scenarios by building projects or contributing to open-source.</li> <li>Review and Refactor: Continuously review your code and refactor it to use best practices and make the most of the features provided by Fetch and Axios.</li> </ol> <p>By following this structured approach, you\u2019ll gain a deep understanding of both Fetch API and Axios, equipping you to use them effectively in various scenarios.</p>"},{"location":"js/httprequest/core/chaining/","title":"Chaning","text":"<p>Chaining multiple API calls sequentially can be done using <code>.then</code>, <code>async/await</code>, or directly with <code>promises</code>.</p> <p>Here\u2019s a breakdown of the differences between these approaches:</p>"},{"location":"js/httprequest/core/chaining/#1-using-then","title":"1. Using <code>.then</code>","text":"ApproachExampleExplanation <ul> <li>Sequential Chaining: Each <code>.then</code> is executed only after the previous promise has resolved.</li> <li>Error Handling: Errors are handled using <code>.catch</code> at the end of the chain or within individual .then blocks.</li> </ul> <pre><code>fetch('https://api.example.com/first')\n    .then(response1 =&gt; response1.json())\n    .then(data1 =&gt; {\n        // This code will not execute if the first request fails\n        return fetch(`https://api.example.com/second/${data1.id}`);\n    })\n    .then(response2 =&gt; response2.json())\n    .then(data2 =&gt; {\n        console.log(data2);\n    })\n    .catch(error =&gt; {\n        // This will handle errors from any of the promises in the chain\n        console.error('Error:', error);\n    });\n</code></pre> <p>Advantages:</p> <ul> <li>Readable for Simple Chains: <code>.then</code> works well for simple sequences of operations.</li> <li>Promise-Based: Explicitly shows promise handling.</li> </ul> <p>Disadvantages:</p> <ul> <li>Callback Hell: For very complex chains, nested <code>.then</code> calls can become difficult to read and manage.</li> </ul>"},{"location":"js/httprequest/core/chaining/#2-using-asyncawait","title":"2. Using <code>async/await</code>","text":"ApproachExampleExplanation <ul> <li>Sequential Execution: <code>await</code> pauses the function execution until the promise resolves, making the code look synchronous.</li> <li>Error Handling: Errors are handled using <code>try/catch</code> blocks.</li> </ul> <pre><code>async function fetchData() {\n    try {\n        const response1 = await fetch('https://api.example.com/first');\n        const data1 = await response1.json();\n\n        // This code will not execute if the first request fails\n        const response2 = await fetch(`https://api.example.com/second/${data1.id}`);\n        const data2 = await response2.json();\n\n        console.log(data2);\n    } catch (error) {\n        // This will handle errors from any of the await statements\n        console.error('Error:', error);\n    }\n}\n\nfetchData();\n</code></pre> <p>Advantages:</p> <ul> <li>Readability: Code is more readable and resembles synchronous code.</li> <li>Error Handling: More intuitive and easier to manage errors with <code>try/catch</code>.</li> </ul> <p>Disadvantages:</p> <ul> <li>Requires Async Functions: You must use <code>async</code> functions, which may require more refactoring if integrating into existing code.</li> </ul>"},{"location":"js/httprequest/core/chaining/#3-using-promises-directly","title":"3. Using Promises Directly","text":"ApproachExampleExplanation <ul> <li>Manual Promise Creation: Promises are created and resolved/rejected manually using the <code>Promise</code> constructor.</li> <li>Chaining: Promises can be chained using <code>.then</code>.</li> </ul> <pre><code>const fetchFirst = () =&gt; {\n    return new Promise((resolve, reject) =&gt; {\n        fetch('https://api.example.com/first')\n            .then(response =&gt; response.json())\n            .then(data =&gt; resolve(data))\n            .catch(error =&gt; reject(error));\n    });\n};\n\nconst fetchSecond = (id) =&gt; {\n    return new Promise((resolve, reject) =&gt; {\n        fetch(`https://api.example.com/second/${id}`)\n            .then(response =&gt; response.json())\n            .then(data =&gt; resolve(data))\n            .catch(error =&gt; reject(error));\n    });\n};\n\nfetchFirst()\n    .then(data1 =&gt; fetchSecond(data1.id))\n    .then(data2 =&gt; console.log(data2))\n    .catch(error =&gt; console.error('Error:', error));\n</code></pre> <p>Advantages:</p> <ul> <li>Control: Provides explicit control over promise creation and resolution.</li> <li>Flexible: Useful for custom promise handling or integrating with existing promise-based code.</li> </ul> <p>Disadvantages:</p> <ul> <li>Boilerplate Code: More verbose and manual compared to .then or async/await.</li> </ul>"},{"location":"js/httprequest/core/chaining/#comparison-summary","title":"Comparison Summary","text":"<p><code>.then</code> Chaining:</p> <ul> <li>Best for simple sequences of asynchronous operations.</li> <li>Can become unwieldy with complex chains.</li> </ul> <p><code>async/await</code>:</p> <ul> <li>Best for readability and managing complex asynchronous workflows.</li> <li>Makes the code look synchronous and is easier to debug with try/catch.</li> </ul> <p>Direct Promises:</p> <ul> <li>Provides control over promise creation.</li> <li>Useful when you need custom promise logic or are integrating with existing promise-based systems.</li> </ul> <p>In practice, <code>async/await</code> is often preferred for its clarity and ease of use, especially in complex scenarios. However, <code>.then</code> chaining and direct promises are also valid approaches depending on the specific needs and context of the codebase.</p> <p>so if the first api response error or unsuccessfull does the second hit or not</p> <p>If the first API request fails or returns an error, the second API request will not be initiated. This is true whether you are using <code>.then</code> chaining, <code>async/await</code>, or direct promises.</p> <p>Summary</p> <p>In all three methods, if the first API call fails:</p> <ul> <li>With <code>.then</code>: The subsequent .then calls are skipped, and the .catch block is executed.</li> <li>With <code>async/await</code>: The catch block handles the error, and subsequent await statements are not executed.</li> <li>With direct promises: The .then calls after a failed promise are skipped, and the .catch block handles the error.</li> </ul> <p>This behavior ensures that if one step in a chain of asynchronous operations fails, the remaining steps dependent on that result are not executed, maintaining the integrity of the process.</p>"},{"location":"js/httprequest/core/chaining/#api-call","title":"API Call","text":""},{"location":"js/httprequest/core/chaining/#1-dependent-api-calls-with-asyncawait","title":"1. Dependent API Calls with <code>async/await</code>","text":"<p>In this case, the second API call depends on the success of the first call. If the first call fails, the second call should be skipped.</p> ExampleExplanation <pre><code>async function fetchData() {\n    try {\n        // Make the first API call\n        const response1 = await fetch('https://api.example.com/user');\n        if (!response1.ok) {\n            throw new Error('Failed to fetch user');\n        }\n        const userData = await response1.json();\n\n        // Use the result from the first API call to make the second call\n        const response2 = await fetch(`https://api.example.com/user/${userData.id}/details`);\n        if (!response2.ok) {\n            throw new Error('Failed to fetch user details');\n        }\n        const userDetails = await response2.json();\n\n        // Use the result from the second API call\n        console.log('User Details:', userDetails);\n    } catch (error) {\n        // Handle any errors that occurred during the API calls\n        console.error('Error:', error);\n    }\n}\n\nfetchData();\n</code></pre> <ul> <li>First API Call: <code>await fetch('https://api.example.com/user')</code> waits for the first API call to complete.</li> <li>Error Handling: If the first call fails (response is not OK), an error is thrown, and the second call is not made.</li> <li>Second API Call: Only made if the first call succeeds, using the data from the first call.</li> <li>Catch Block: Handles any errors that occur during the process.</li> </ul>"},{"location":"js/httprequest/core/chaining/#2-independent-api-calls-with-asyncawait","title":"2. Independent API Calls with <code>async/await</code>","text":"<p>n this case, the second API call is independent of the first, so you can make both calls regardless of whether the first call succeeds or fails.</p> ExampleExplanation <pre><code>async function fetchData() {\n    try {\n        // Make the first API call\n        const response1 = await fetch('https://api.example.com/data1').catch(() =&gt; null);\n        const data1 = response1 ? await response1.json() : null;\n        console.log('Data1:', data1);\n\n        // Make the second API call independently\n        const response2 = await fetch('https://api.example.com/data2');\n        if (!response2.ok) {\n            throw new Error('Failed to fetch data2');\n        }\n        const data2 = await response2.json();\n        console.log('Data2:', data2);\n\n    } catch (error) {\n        // Handle any errors that occurred during the API calls\n        console.error('Error:', error);\n    }\n}\n\nfetchData();\n</code></pre> <ul> <li>First API Call: <code>await fetch('https://api.example.com/data1').catch(() =&gt; null)</code> makes the first call and catches any errors, setting <code>data1</code> to <code>null</code> if the call fails.</li> <li>Second API Call: Made independently, regardless of whether the first call succeeds or fails.</li> <li>Error Handling: Errors from either API call are handled in the <code>catch</code> block.</li> </ul> Summary <ul> <li>Dependent Calls: Use <code>async/await</code> to ensure that the second call is only made if the first call succeeds. Handle errors with a <code>try/catch</code> block.</li> <li>Independent Calls: You can make both API calls independently and handle their results separately, while still managing errors gracefully.</li> </ul> <p>These patterns using <code>async/await</code> help manage asynchronous operations in a readable and structured way.</p>"},{"location":"js/httprequest/core/chaining/#api-excecution","title":"API Excecution","text":"Sequential Execution async/awaitExplanation <p>Example: Sequential Tasks with <code>async/await</code></p> <pre><code>async function fetchDataSequentially() {\n    try {\n        const response1 = await fetch('https://api.example.com/first');\n        const data1 = await response1.json();\n\n        const response2 = await fetch(`https://api.example.com/second/${data1.id}`);\n        const data2 = await response2.json();\n\n        console.log('Data1:', data1);\n        console.log('Data2:', data2);\n    } catch (error) {\n        console.error('Error:', error);\n    }\n}\n\nfetchDataSequentially();\n</code></pre> <p>Best For:</p> <ul> <li>Sequential Execution: When you need to perform asynchronous tasks in a specific order, where each task depends on the result of the previous one.</li> <li>Error Handling: When you want to handle errors from multiple asynchronous tasks in a centralized way.</li> </ul> <p>Advantages:</p> <ul> <li>Readability: Code looks synchronous and is easier to read and understand.</li> <li>Error Handling: Allows you to use <code>try/catch</code> blocks to handle errors, making it simpler to manage exceptions. Control Flow: Better suited for scenarios where each asynchronous operation depends on the previous one.</li> </ul> <p>Disadvantages:</p> <ul> <li>Sequential Execution: If tasks are independent, using <code>async/await</code> might not be as efficient as <code>Promise.all</code> because tasks are executed one after the other.</li> </ul> Parallel Execution Promise.allExplanation <p>Example: Parallel Tasks with Promise.all</p> <pre><code>async function fetchDataInParallel() {\n    try {\n        const [response1, response2] = await Promise.all([\n            fetch('https://api.example.com/first'),\n            fetch('https://api.example.com/second')\n            ]);\n\n        const data1 = await response1.json();\n        const data2 = await response2.json();\n\n        console.log('Data1:', data1);\n        console.log('Data2:', data2);\n    } catch (error) {\n        console.error('Error:', error);\n    }\n}\n\nfetchDataInParallel();\n</code></pre> <p>Best For:</p> <ul> <li>Parallel Execution: When you have multiple asynchronous tasks that can be performed simultaneously and don\u2019t depend on each other\u2019s results.</li> <li>Performance: When you want to execute multiple tasks in parallel to reduce total execution time.</li> </ul> <p>Advantages:</p> <ul> <li>Efficiency: Executes multiple promises in parallel, which can be faster if tasks are independent.</li> <li>Handles Multiple Promises: Easily handles and waits for all promises to resolve or for any to reject.</li> </ul> <p>Disadvantages:</p> <ul> <li>Error Handling: If any promise in the array rejects, <code>Promise.all</code> immediately rejects, and handling errors requires additional logic to manage partial success.</li> </ul> Comparison Summary <p>Use <code>async/await</code> When:</p> <ul> <li>Tasks need to be executed in a specific order.</li> <li>You need to handle errors in a single <code>try/catch</code> block.</li> <li>You are performing operations that depend on the results of previous operations.</li> </ul> <p>Use <code>Promise.all</code> When:</p> <ul> <li>Tasks can be executed in parallel.</li> <li>You want to perform multiple independent asynchronous operations concurrently.</li> <li>You need to wait for all promises to complete, or any to fail, in a single operation.</li> </ul> <p>Choosing the Right Approach:</p> <ul> <li>For Sequential Dependencies: Use <code>async/await</code> to handle tasks in a specific order and manage errors gracefully.</li> <li>For Parallel Tasks: Use <code>Promise.all</code> to run multiple independent tasks concurrently for better performance.</li> </ul> <p>In practice, you might use a combination of both. For example, you could use <code>async/await</code> for sequential tasks and <code>Promise.all</code> for parallel tasks within the same async function, depending on the requirements of your application.</p>"},{"location":"js/httprequest/core/chaining/#plan-your-data-fetching-strategy","title":"Plan Your Data Fetching Strategy","text":"Decide how you want to fetch the data <ul> <li>Sequential Fetching: Fetch data one after the other. Useful if the order matters or if you want to avoid hitting too many APIs simultaneously.</li> <li>Parallel Fetching: Fetch data for all components simultaneously. This is more efficient but requires managing multiple loading states.</li> </ul>"},{"location":"js/httprequest/core/fetch-api/","title":"Fetch API","text":"<p>Mastering Fetch API and Axios involves understanding both basic concepts and advanced features.</p> <p>Here's a structured guide to help you master them, starting from the basics and moving to more advanced techniques.</p>"},{"location":"js/httprequest/core/fetch-api/#mastering-fetch-api","title":"Mastering Fetch API","text":""},{"location":"js/httprequest/core/fetch-api/#1-understanding-the-basics","title":"1. Understanding the Basics","text":"<ul> <li> <p>What is Fetch API?</p> <p>Fetch API is a modern JavaScript API used to make HTTP requests. It is built into most modern browsers and provides a more powerful and flexible feature set compared to older methods like <code>XMLHttpRequest</code>.</p> </li> <li> <p>Basic Syntax:</p> <pre><code>fetch(url, options)\n    .then(response =&gt; response.json())  // or response.text() / response.blob() etc.\n    .then(data =&gt; console.log(data))\n    .catch(error =&gt; console.error('Error:', error));\n</code></pre> </li> <li> <p>Basic Example:</p> <pre><code>fetch('https://api.example.com/data')\n    .then(response =&gt; response.json())\n    .then(data =&gt; console.log(data))\n    .catch(error =&gt; console.error('Error:', error));\n</code></pre> </li> </ul>"},{"location":"js/httprequest/core/fetch-api/#2-handling-responses-and-errors","title":"2. Handling Responses and Errors","text":"<ul> <li> <p>Checking Response Status:</p> <pre><code>fetch('https://api.example.com/data')\n    .then(response =&gt; {\n        if (!response.ok) {\n            throw new Error(`HTTP error! Status: ${response.status}`);\n        }\n        return response.json();\n    })\n    .then(data =&gt; console.log(data))\n    .catch(error =&gt; console.error('Fetch error:', error));\n</code></pre> </li> <li> <p>Parsing Different Types of Responses:</p> <pre><code>// JSON\nfetch('https://api.example.com/data')\n    .then(response =&gt; response.json())\n    .then(data =&gt; console.log(data));\n\n// Text\nfetch('https://api.example.com/text')\n    .then(response =&gt; response.text())\n    .then(text =&gt; console.log(text));\n</code></pre> </li> </ul>"},{"location":"js/httprequest/core/fetch-api/#3-making-different-types-of-requests","title":"3. Making Different Types of Requests","text":"<ul> <li> <p>GET Request:</p> <pre><code>fetch('https://api.example.com/data')\n    .then(response =&gt; response.json())\n    .then(data =&gt; console.log(data));\n</code></pre> </li> <li> <p>POST Request with Body:</p> <pre><code>fetch('https://api.example.com/data', {\n    method: 'POST',\n    headers: {\n        'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({ key: 'value' })\n})\n    .then(response =&gt; response.json())\n    .then(data =&gt; console.log(data));\n</code></pre> </li> <li> <p>PUT Request:</p> <pre><code>fetch('https://api.example.com/data/1', {\n    method: 'PUT',\n    headers: {\n        'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({ key: 'new value' })\n})\n    .then(response =&gt; response.json())\n    .then(data =&gt; console.log(data));\n</code></pre> </li> <li> <p>DELETE Request:</p> <pre><code>fetch('https://api.example.com/data/1', {\n    method: 'DELETE'\n})\n    .then(response =&gt; response.json())\n    .then(data =&gt; console.log(data));\n</code></pre> </li> </ul>"},{"location":"js/httprequest/core/fetch-api/#4-advanced-features","title":"4. Advanced Features","text":"<ul> <li> <p>Using <code>AbortController</code> for Request Cancellation:</p> <pre><code>const controller = new AbortController();\nconst signal = controller.signal;\n\nfetch('https://api.example.com/data', { signal })\n    .then(response =&gt; response.json())\n    .then(data =&gt; console.log(data))\n    .catch(error =&gt; {\n        if (error.name === 'AbortError') {\n            console.log('Fetch request canceled');\n        } else {\n            console.error('Fetch error:', error);\n        }\n    });\n\n// To cancel the request\ncontroller.abort();\n</code></pre> </li> <li> <p>Streaming:</p> <pre><code>fetch('https://api.example.com/stream')\n    .then(response =&gt; {\n        const reader = response.body.getReader();\n        return reader.read();\n    })\n    .then(result =&gt; console.log(new TextDecoder().decode(result.value)));\n</code></pre> </li> </ul>"},{"location":"js/httprequest/core/overview/","title":"Overview","text":""},{"location":"js/httprequest/core/overview/#overview","title":"Overview","text":"<p>Great question! Both Fetch API and Axios are popular tools for making HTTP requests in JavaScript, but they have some key differences.</p>"},{"location":"js/httprequest/core/overview/#fetch-api","title":"Fetch API","text":"<p>Fetch API is a modern JavaScript API built into browsers for making HTTP requests. It\u2019s part of the standard Web API and doesn\u2019t require any external libraries.</p> ExampleKey Features <pre><code>fetch('https://api.example.com/data')\n    .then(response =&gt; response.json())\n    .then(data =&gt; console.log(data))\n    .catch(error =&gt; console.error('Error:', error));\n</code></pre> <ol> <li>Built-In: Fetch is natively supported in most modern browsers, so there's no need for additional libraries.</li> <li>Promises-Based: Fetch uses promises, making it easier to handle asynchronous operations.</li> <li>Configurable: You have to manually handle some aspects like response parsing, headers, and status codes.</li> <li>No Built-In Support for Older Browsers: For browsers that don't support Fetch, you might need a polyfill.</li> </ol>"},{"location":"js/httprequest/core/overview/#axios","title":"Axios","text":"<p>Axios is a third-party library for making HTTP requests. It\u2019s popular in both browser and Node.js environments.</p> ExampleKey Features <pre><code>axios.get('https://api.example.com/data')\n    .then(response =&gt; console.log(response.data))\n    .catch(error =&gt; console.error('Error:', error));\n</code></pre> <ol> <li>Promises-Based: Like Fetch, Axios uses promises.</li> <li>Automatic JSON Data Transformation: Axios automatically transforms JSON data into JavaScript objects.</li> <li>Request and Response Interceptors: Axios allows you to define interceptors to modify requests or responses before they are handled by <code>.then</code> or <code>.catch</code>.</li> <li>Error Handling: Axios provides a more refined error handling mechanism, including status codes and error messages.</li> <li>Older Browser Support: Axios works in older browsers without needing a polyfill.</li> </ol>"},{"location":"js/httprequest/core/overview/#mastering-fetch-and-axios","title":"Mastering Fetch and Axios","text":"<ol> <li> <p>Understand the Basics: Make sure you\u2019re comfortable with basic HTTP concepts (GET, POST, PUT, DELETE) and how to handle responses and errors.</p> </li> <li> <p>Read Documentation: Familiarize yourself with the official documentation for Fetch API and Axios.</p> </li> <li> <p>Practice Error Handling:</p> <ul> <li>Fetch: Check the <code>response.ok</code> property and handle HTTP errors explicitly.</li> <li>Axios: Use <code>.catch</code> to handle errors and access more detailed error information.</li> </ul> </li> <li> <p>Use Advanced Features:</p> <ul> <li>Fetch: Learn to use the AbortController for request cancellation and handle streams.</li> <li>Axios: Explore request/response interceptors, <code>axios.create</code> for custom instances, and <code>axios.all</code> for concurrent requests.</li> </ul> </li> <li> <p>Consider Use Cases:</p> <ul> <li>Use Fetch for simple cases or when working in environments with native support.</li> <li>Use Axios if you need advanced features like interceptors or are working in older browsers.</li> </ul> </li> <li> <p>Build Projects: Implement both Fetch and Axios in various projects to see their strengths and weaknesses in real-world scenarios.</p> </li> <li> <p>Stay Updated: Libraries and standards evolve. Follow updates to the Fetch API and Axios to keep your knowledge current.</p> </li> </ol> <p>By exploring these aspects, you'll gain a solid understanding and become proficient in using both Fetch API and Axios!</p>"},{"location":"js/httprequest/core/overview/#detailed-differences","title":"Detailed Differences","text":"<p>Absolutely, let's dive deeper into the differences between Fetch API and Axios, and examine scenarios where one might be preferable over the other.</p>"},{"location":"js/httprequest/core/overview/#1-error-handling","title":"1.  Error Handling:","text":"<p>Fetch API:</p> ExampleExplanation <pre><code>fetch('https://api.example.com/data')\n    .then(response =&gt; {\n        if (!response.ok) {\n            throw new Error('Network response was not ok');\n        }\n        return response.json();\n    })\n    .then(data =&gt; console.log(data))\n    .catch(error =&gt; console.error('Fetch error:', error));\n</code></pre> <ul> <li>Fetch does not reject the promise on HTTP error status codes (like 404 or 500). It only rejects on network errors or issues that prevent the request from completing.</li> <li>You need to manually check <code>response.ok</code> or <code>response.status</code> to handle HTTP errors.</li> </ul> <p>Axios:</p> ExampleExplanation <pre><code>axios.get('https://api.example.com/data')\n    .then(response =&gt; console.log(response.data))\n    .catch(error =&gt; {\n        if (error.response) {\n            // Server responded with a status other than 2xx\n            console.error('Response error:', error.response);\n        } else if (error.request) {\n            // Request was made but no response received\n            console.error('Request error:', error.request);\n        } else {\n            // Something else caused an error\n            console.error('Error:', error.message);\n        }\n    });\n</code></pre> <ul> <li>Axios automatically rejects the promise for HTTP status codes that fall outside the range of <code>2xx</code>. It provides a more straightforward way to handle errors with the <code>catch</code> block.</li> </ul>"},{"location":"js/httprequest/core/overview/#2-json-transformation","title":"2.  JSON Transformation:","text":"<p>Fetch API:</p> ExampleExplanation <pre><code>fetch('https://api.example.com/data')\n    .then(response =&gt; response.json())\n    .then(data =&gt; console.log(data));\n</code></pre> <ul> <li>Fetch requires you to explicitly call <code>.json()</code> to parse the JSON response.</li> </ul> <p>Axios:</p> ExampleExplanation <pre><code>axios.get('https://api.example.com/data')\n    .then(response =&gt; console.log(response.data));\n</code></pre> <ul> <li>Axios automatically transforms the response data to JSON if the response header <code>Content-Type</code> is set to <code>application/json</code>.</li> </ul>"},{"location":"js/httprequest/core/overview/#2-request-and-response-interceptors","title":"2. Request and Response Interceptors:","text":"<p>Fetch API:</p> Explanation <ul> <li>Fetch does not have built-in support for interceptors. You have to manually handle request and response modification in each request.</li> </ul> <p>Axios:</p> ExampleExplanation <pre><code>// Request interceptor\naxios.interceptors.request.use(config =&gt; {\n    // Modify request config\n    return config;\n}, error =&gt; {\n    return Promise.reject(error);\n});\n\n// Response interceptor\naxios.interceptors.response.use(response =&gt; {\n    // Modify response data\n    return response;\n}, error =&gt; {\n    return Promise.reject(error);\n});\n</code></pre> <ul> <li>Axios supports interceptors for both requests and responses, allowing you to modify or log them before they are handled by <code>.then</code> or <code>.catch</code>.</li> </ul>"},{"location":"js/httprequest/core/overview/#3-cancellation","title":"3. Cancellation:","text":"<p>Fetch API:</p> ExampleExplanation <pre><code>const controller = new AbortController();\nconst signal = controller.signal;\n\nfetch('https://api.example.com/data', { signal })\n    .then(response =&gt; response.json())\n    .then(data =&gt; console.log(data))\n    .catch(error =&gt; {\n        if (error.name === 'AbortError') {\n            console.log('Fetch request canceled');\n        } else {\n            console.error('Fetch error:', error);\n        }\n    });\n\n// To cancel the request\ncontroller.abort();\n</code></pre> <ul> <li>Fetch supports request cancellation using AbortController.</li> </ul> <p>Axios:</p> ExampleExplanation <pre><code>const CancelToken = axios.CancelToken;\nconst source = CancelToken.source();\n\naxios.get('https://api.example.com/data', { cancelToken: source.token })\n    .then(response =&gt; console.log(response.data))\n    .catch(error =&gt; {\n        if (axios.isCancel(error)) {\n            console.log('Request canceled:', error.message);\n        } else {\n            console.error('Axios error:', error);\n        }\n    });\n\n// To cancel the request\nsource.cancel('Operation canceled by the user.');\n</code></pre> <ul> <li>Axios supports request cancellation via cancel tokens.</li> </ul>"},{"location":"js/httprequest/core/overview/#5-browser-support","title":"5. Browser Support:","text":"<p>Fetch API:</p> <pre><code>-   Fetch is natively supported in modern browsers but may require a polyfill for older browsers.\n</code></pre> <p>Axios:</p> <ul> <li>Axios works in both modern and older browsers without additional polyfills, and also supports Node.js environments.</li> </ul>"},{"location":"js/httprequest/core/overview/#when-to-use-each","title":"When to Use Each","text":"Use Fetch API When: <ol> <li>You prefer native browser support and want to avoid including external libraries.</li> <li>You need a lightweight solution for basic HTTP requests without advanced features.</li> <li>You want fine-grained control over error handling and parsing responses.</li> </ol> Use Axios When: <ol> <li>You need advanced features like request and response interceptors, or need to handle concurrent requests.</li> <li>You want simplified error handling, especially when dealing with different types of errors.</li> <li>You\u2019re working with older browsers or need compatibility with both Node.js and browser environments.</li> <li>You need automatic JSON data transformation and would benefit from built-in request and response manipulation.</li> </ol> <p>Summary</p> <p>Both Fetch and Axios have their strengths. Fetch is ideal for simpler use cases or when avoiding additional dependencies is crucial. Axios is more feature-rich and suitable for complex scenarios involving interceptors, cancellation, and universal support across environments. Understanding these differences will help you choose the right tool for your needs and become more effective at managing HTTP requests in your projects.</p>"},{"location":"js/httprequest/core/overview/#major-difference","title":"Major Difference","text":"<p>The major difference to remember between Fetch API and Axios is:</p>"},{"location":"js/httprequest/core/overview/#error-handling","title":"Error Handling:","text":"<ul> <li> <p>Fetch API:</p> <p>Does not reject the promise on HTTP error status codes (like 404 or 500). You need to manually check <code>response.ok</code> or <code>response.status</code> to handle these errors.</p> <p>Example:</p> <pre><code>fetch('https://api.example.com/data')\n    .then(response =&gt; {\n        if (!response.ok) {\n            throw new Error('Network response was not ok');\n        }\n        return response.json();\n    })\n    .then(data =&gt; console.log(data))\n    .catch(error =&gt; console.error('Fetch error:', error));\n</code></pre> </li> <li> <p>Axios:</p> <p>Automatically rejects the promise for HTTP status codes that fall outside the range of 2xx, making error handling more straightforward and consistent.</p> <p>Example:</p> <pre><code>axios.get('https://api.example.com/data')\n    .then(response =&gt; console.log(response.data))\n    .catch(error =&gt; {\n        if (error.response) {\n        console.error('Response error:', error.response);\n        } else if (error.request) {\n        console.error('Request error:', error.request);\n        } else {\n        console.error('Error:', error.message);\n        }\n    });\n</code></pre> </li> </ul> <p>Summary: Axios handles HTTP errors automatically by rejecting the promise for non-2xx status codes, whereas Fetch API requires you to manually check for errors and handle them.</p>"},{"location":"js/httprequest/core/then-and-asyncwait/","title":"Then and async await","text":""},{"location":"js/httprequest/core/then-and-asyncwait/#choosing","title":"Choosing","text":"<p>Choosing between <code>.then</code> and <code>async/await</code> for handling asynchronous operations often comes down to readability and personal preference. Here\u2019s a guide to help you decide when to use each approach:</p>"},{"location":"js/httprequest/core/then-and-asyncwait/#using-then","title":"Using <code>.then</code>","text":"When to UseExample <ul> <li>Chaining Promises: If you need to chain multiple asynchronous operations together, <code>.then</code> can be a clear way to handle this. Each <code>.then</code> can handle the result of the previous promise.</li> <li>Simple Cases: For straightforward cases where you just need to perform actions based on the result of a promise, <code>.then</code> can be simple and effective.</li> <li>Older Codebases: If you're working with legacy code that uses <code>.then</code>, it might be easier to stay consistent with that style.</li> </ul> <pre><code>fetch(url)\n    .then(response =&gt; response.json())\n    .then(data =&gt; console.log(data))\n    .catch(error =&gt; console.error('Error:', error));\n</code></pre>"},{"location":"js/httprequest/core/then-and-asyncwait/#using-asyncawait","title":"Using <code>async/await</code>","text":"When to UseExample <ul> <li>Readability and Maintenance: <code>async/await</code> often makes asynchronous code look more like synchronous code, which can be easier to read and maintain, especially for complex sequences of operations.</li> <li>Error Handling: <code>async/await</code> allows you to use <code>try/catch</code> blocks for error handling, which can be more intuitive and cleaner compared to chaining <code>.catch</code> with <code>.then</code>.</li> <li>Complex Logic: If you have complex logic involving multiple asynchronous operations, <code>async/await</code> can make your code more organized and easier to understand.</li> </ul> <pre><code>async function fetchData() {\n    try {\n        const response = await fetch(url);\n        const data = await response.json();\n        console.log(data);\n    } catch (error) {\n        console.error('Error:', error);\n    }\n}\n\nfetchData();\n</code></pre>"},{"location":"js/httprequest/core/then-and-asyncwait/#key-differences","title":"Key Differences:","text":"SyntaxError Handling <ul> <li><code>.then</code> uses a callback-based approach, which can lead to \"callback hell\" or nested <code>.then</code> chains.</li> <li><code>async/await</code> provides a cleaner, synchronous-looking syntax that avoids nested callbacks.</li> </ul> <ul> <li>With <code>.then</code>, you handle errors using <code>.catch</code> at the end of the chain.</li> <li>With <code>async/await</code>, you handle errors using <code>try/catch</code>, which can be more intuitive for handling multiple potential points of failure.</li> </ul>"},{"location":"js/httprequest/core/then-and-asyncwait/#summary","title":"Summary:","text":"<ul> <li>Use <code>.then</code> for simpler cases or when working with codebases that already use it.</li> <li>Use <code>async/await</code> for more readable and maintainable code, especially when dealing with complex logic or when you prefer synchronous-looking code.</li> </ul> <p>In general, <code>async/await</code> is often preferred for its clarity and ease of handling complex asynchronous logic. However, both approaches are valid and choosing between them can depend on the specific needs and context of your code.</p>"},{"location":"js/httprequest/core/then-and-asyncwait/#now-explain-to-5-years-old","title":"now explain to 5 years old","text":"<p>now explain to 5 years old</p> <p>Imagine you\u2019re waiting for two different friends to give you two different toys.</p> Using <code>.then</code>Using <code>async/await</code>The Main Difference <ul> <li><code>.then</code> is like asking your first friend to give you a toy, and then, once you have that toy, you ask your second friend to give you another one. You have to wait and check each time to see if they did what they promised.</li> </ul> <p>Example:</p> <ul> <li>First, you get a toy from your friend.</li> <li>Then you ask, \u201cDid you bring another toy?\u201d</li> </ul> <p>If your friend says, \u201cYes,\u201d you play with the toys. If something goes wrong, you have to deal with it then.</p> <ul> <li><code>async/await</code> is like waiting for both friends to give you their toys all at once and checking them together. It\u2019s like you sit and wait for all toys to come before you start playing, and if something goes wrong, you can fix it right then and there.</li> </ul> <p>Example:</p> <ul> <li>You wait and ask your first friend and your second friend to give you the toys.</li> <li>If both toys are okay, you start playing.</li> <li>If there\u2019s a problem with any toy, you fix it immediately.</li> </ul> <ul> <li><code>.then</code> is like taking turns with your friends, waiting for each toy before asking for the next one.</li> <li><code>async/await</code> is like waiting for everything to be ready before you start playing, which can be easier and faster to handle.</li> </ul> <p>In general, <code>async/await</code> makes things simpler and more organized, just like waiting until everything is ready before starting to play.</p>"},{"location":"js/httprequest/example/axios-api-example/","title":"Axios Api Example","text":""},{"location":"js/httprequest/example/axios-api-example/#overview","title":"Overview","text":"<p>To convert your React component to use <code>axios</code> instead of fetch, you can follow these steps:</p> <ol> <li> <p>Install <code>axios</code> if you haven\u2019t already:</p> <pre><code>npm install axios\n</code></pre> </li> <li> <p>Import <code>axios</code> and modify the <code>fetchData</code> function to use <code>axios</code> for making the API request.</p> CodeKey Changes <p>Here\u2019s how your updated component would look:</p> <pre><code>import React, { useState, useEffect } from 'react';\nimport axios from 'axios'; // Import axios\n\nfunction FetchExample() {\n    // State to hold data and loading status\n    const [data, setData] = useState(null);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n\n    // Define the fetch function inside the component\n    const fetchData = async (url, apiKey) =&gt; {\n        try {\n            const response = await axios.get(url, {\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${apiKey}`, // Include the API key in headers\n                },\n            });\n\n            setData(response.data); // Axios wraps the data in `response.data`\n        } catch (error) {\n            setError(error);\n        } finally {\n            setLoading(false);\n        }\n    };\n\n    useEffect(() =&gt; {\n        // Define your API endpoint and API key\n        const API_URL = 'https://api.example.com/data'; // Replace with your API URL\n        const API_KEY = 'your-api-key'; // Replace with your API key\n\n        fetchData(API_URL, API_KEY);\n    }, []); // Empty dependency array means this runs once when the component mounts\n\n    // Render loading, error, or data\n    if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Data from API&lt;/h1&gt;\n            &lt;pre&gt;{JSON.stringify(data, null, 2)}&lt;/pre&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default FetchExample;\n</code></pre> <ul> <li>Import <code>axios</code>: Added <code>import axios from 'axios';</code>.</li> <li>Use <code>axios.get</code>: Replaced the <code>fetch</code> call with <code>axios.get</code>, passing headers in the configuration object.</li> <li>Handle <code>response.data</code>: Axios provides the response data directly in the data property of the response object, so you use <code>response.data</code> instead of parsing the response as JSON.</li> </ul> <p>This refactor maintains the same functionality but uses axios for HTTP requests, which can simplify error handling and data extraction.</p> </li> </ol>"},{"location":"js/httprequest/example/axios-api-example/#difference-between-fetch-and-axios","title":"Difference between <code>fetch</code> and <code>axios</code>","text":"<p>what is the main difference between to fetch and axios to remember and why</p> <p>When choosing between <code>fetch</code> and <code>axios</code> for making HTTP requests in JavaScript, there are several key differences to remember:</p>"},{"location":"js/httprequest/example/axios-api-example/#1-error-handling","title":"1. Error Handling","text":"<ul> <li> <p><code>fetch</code>: Only rejects the promise on network errors (e.g., failed network requests). It does not reject for HTTP errors (e.g., 404 or 500). You need to manually check <code>response.ok</code> to handle HTTP errors.</p> <pre><code>fetch(url)\n    .then(response =&gt; {\n        if (!response.ok) {\n        throw new Error('Network response was not ok');\n        }\n        return response.json();\n    })\n    .then(data =&gt; console.log(data))\n    .catch(error =&gt; console.error('Error:', error));\n</code></pre> </li> <li> <p><code>axios</code>: Automatically rejects the promise for HTTP errors (status codes outside the range 200\u2013299). This simplifies error handling as you don\u2019t need to manually check for <code>response.ok</code>.</p> <pre><code>axios.get(url)\n    .then(response =&gt; console.log(response.data))\n    .catch(error =&gt; console.error('Error:', error));\n</code></pre> </li> </ul>"},{"location":"js/httprequest/example/axios-api-example/#2-response-parsing","title":"2. Response Parsing","text":"<ul> <li> <p><code>fetch</code>: Requires manual parsing of the response. You have to call <code>response.json()</code>, <code>response.text()</code>, or similar methods based on the expected response type.</p> <pre><code>fetch(url)\n    .then(response =&gt; response.json())\n    .then(data =&gt; console.log(data));\n</code></pre> </li> <li> <p><code>axios</code>: Automatically parses the response based on the <code>Content-Type</code> header. JSON responses are parsed directly into JavaScript objects, so you don\u2019t need to call a parsing method.</p> <pre><code>axios.get(url)\n    .then(response =&gt; console.log(response.data));\n</code></pre> </li> </ul>"},{"location":"js/httprequest/example/axios-api-example/#3-request-configuration","title":"3. Request Configuration","text":"<ul> <li> <p><code>fetch</code>: Uses a configuration object with a <code>method</code> key for specifying request methods, and you need to handle configuration options (e.g., headers, body) in the same object.</p> <pre><code>fetch(url, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(data)\n});\n</code></pre> </li> <li> <p><code>axios</code>: Uses a simpler, more flexible configuration object that can be spread out into a method call. Configuration is generally more straightforward and readable.</p> <pre><code>axios.post(url, data, { headers: { 'Content-Type': 'application/json' } });\n</code></pre> </li> </ul>"},{"location":"js/httprequest/example/axios-api-example/#4-interceptors","title":"4. Interceptors","text":"<ul> <li> <p><code>fetch</code>: Does not support request or response interceptors out-of-the-box. Interceptors need to be manually implemented with custom wrappers or middleware.</p> </li> <li> <p><code>axios</code>: Supports request and response interceptors, which can be used to modify requests or responses before they are handled.</p> <pre><code>axios.interceptors.request.use(config =&gt; {\n    // Modify request config\n    return config;\n}, error =&gt; {\n    return Promise.reject(error);\n});\n\naxios.interceptors.response.use(response =&gt; {\n    // Modify response data\n    return response;\n}, error =&gt; {\n    return Promise.reject(error);\n});\n</code></pre> </li> </ul>"},{"location":"js/httprequest/example/axios-api-example/#5-browser-support-and-polyfills","title":"5. Browser Support and Polyfills","text":"<ul> <li> <p><code>fetch</code>: Not supported in Internet Explorer and requires a polyfill for older browsers.</p> </li> <li> <p><code>axios</code>: Works in older browsers without needing a polyfill, making it more suitable for projects requiring broader browser support.</p> </li> </ul>"},{"location":"js/httprequest/example/axios-api-example/#summary","title":"Summary","text":"<ul> <li> <p>Use <code>fetch</code> if you need a lightweight solution and are comfortable handling response parsing and error checking manually. It\u2019s built into modern browsers and has a straightforward API.</p> </li> <li> <p>Use <code>axios</code> if you prefer built-in error handling, automatic response parsing, request/response interceptors, and support for older browsers. It provides additional features and can simplify code, especially for complex scenarios.</p> </li> </ul> <p>Choosing between <code>fetch</code> and <code>axios</code> often comes down to personal preference and project requirements. Both are capable tools, but <code>axios</code> generally provides a more feature-rich experience out of the box.</p>"},{"location":"js/httprequest/example/axios-api-example/#one-thing-to-remember","title":"One thing to <code>Remember</code>","text":"<p>what is the one main thing to remember?</p> <p>The one main thing to remember when choosing between fetch and axios is:</p>"},{"location":"js/httprequest/example/axios-api-example/#error-handling","title":"Error Handling","text":"<p><code>axios</code> automatically rejects the promise for HTTP errors, meaning you don\u2019t have to manually check for HTTP status codes or handle network errors separately. This can significantly simplify error handling in your code.</p> <p>In contrast, <code>fetch</code> does not reject the promise for HTTP errors. You need to explicitly check if the response was successful using <code>response.ok</code> or by checking the status code, and handle any parsing errors or network issues separately.</p> <p>This built-in error handling in <code>axios</code> can make your code cleaner and easier to manage, especially when dealing with various types of errors and responses.</p>"},{"location":"js/httprequest/example/axios-api-example/#explain-to-5-years-old","title":"Explain to 5 years old","text":"<p>now explain to 5 years old</p> <p>Imagine you have two toy robots that help you with your homework: Fetch and Axios.</p>"},{"location":"js/httprequest/example/axios-api-example/#fetch-robot","title":"Fetch Robot","text":"<ul> <li>Fetch is like a robot that brings you a box from the kitchen. If the box has something wrong, like it's empty or broken, Fetch will still give it to you, and you\u2019ll have to check inside to see if it\u2019s okay or not.</li> </ul>"},{"location":"js/httprequest/example/axios-api-example/#axios-robot","title":"Axios Robot","text":"<ul> <li>Axios is like a robot that checks the box for you before giving it to you. If something\u2019s wrong with the box, Axios will tell you right away that there\u2019s a problem.</li> </ul>"},{"location":"js/httprequest/example/axios-api-example/#the-main-thing","title":"The Main Thing","text":"<p>The big thing to remember is that Axios is better at telling you when there\u2019s a problem right away. Fetch will just hand you the box, and you have to check for problems yourself.</p>"},{"location":"js/httprequest/example/cancel-axios-api/","title":"Cancel Axios","text":"<p>In React 18, when using <code>StrictMode</code>, components may mount and unmount multiple times during development. This can lead to requests being canceled frequently, which can result in <code>CanceledError</code> messages in the console. While this is expected behavior in development, you might want to suppress or handle these errors more gracefully.</p>"},{"location":"js/httprequest/example/cancel-axios-api/#in-development","title":"In Development","text":""},{"location":"js/httprequest/example/cancel-axios-api/#heres-how-to-manage-it","title":"Here's how to manage it:","text":"<ul> <li>Ignore Canceled Errors: You can filter out <code>CanceledError</code> in your error handling.</li> <li>Use <code>isCancel</code> Method: This allows you to differentiate between a cancellation and an actual error.</li> </ul> <p>Here's how you can modify your code to implement this:</p> ExampleKey ChangesAdditional Considerations <pre><code>import React, { useState, useEffect } from 'react';\nimport axios from 'axios';\nimport './App.css';\n\nfunction App() {\n    const [data, setData] = useState(null);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n\n    const fetchData = async (url, apiKey, cancelToken) =&gt; {\n        try {\n            const response = await axios.get(url, {\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${apiKey}`,\n                },\n                cancelToken: cancelToken,\n            });\n\n            setData(response.data);\n        } catch (error) {\n            if (axios.isCancel(error)) {\n                // Ignore canceled requests in development mode\n                console.log('Request canceled:', error.message);\n            } else {\n                // Set actual error state for other types of errors\n                setError(error);\n            }\n        } finally {\n            setLoading(false);\n        }\n    };\n\n    useEffect(() =&gt; {\n        const API_URL = 'https://jsonplaceholder.typicode.com/posts';\n        const API_KEY = '';\n\n        const source = axios.CancelToken.source();\n\n        fetchData(API_URL, API_KEY, source.token);\n\n        return () =&gt; {\n            source.cancel('Operation canceled by the user.');\n        };\n    }, []);\n\n    if (loading) return &lt;div&gt;Loading ...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error... {error.message}&lt;/div&gt;;\n\n    return (\n        &lt;div className=\"App\"&gt;\n            &lt;h1&gt;Data From API&lt;/h1&gt;\n            {data &amp;&amp; (\n                &lt;ul&gt;\n                {data.map((post) =&gt; (\n                    &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;\n                ))}\n                &lt;/ul&gt;\n            )}\n        &lt;/div&gt;\n    );\n}\n\nexport default App;\n</code></pre> <ul> <li>Error Handling: Inside the catch block, the <code>if (axios.isCancel(error))</code> check is used to ignore canceled requests. Only actual errors will update the error state.</li> <li>Logging: You can log the canceled request for debugging purposes but avoid setting it in the state.</li> </ul> <ul> <li>Development vs. Production: This handling is especially important in development with React Strict Mode, but in production, you shouldn't see frequent unmounts unless your app is designed that way.</li> <li>Testing: Make sure to test your application in a non-Strict mode to verify that it behaves as expected without frequent cancellations.</li> </ul> <p>By applying these changes, you should be able to suppress unnecessary CanceledError messages while still managing your API requests effectively.</p>"},{"location":"js/httprequest/example/cancel-axios-api/#in-production","title":"In production","text":"<p>In production, the handling of canceled requests can be a bit different. While you generally want to keep your error handling clean, it\u2019s still useful to acknowledge canceled requests. However, you might not want to log them or show any user-facing messages unless there's a specific reason to do so.</p>"},{"location":"js/httprequest/example/cancel-axios-api/#production-handling-of-canceled-requests","title":"Production Handling of Canceled Requests","text":"<ul> <li> <p>Silence Logs: You typically don\u2019t need to log canceled requests in production, as they are usually a normal part of application behavior (e.g., user navigating away).</p> </li> <li> <p>Display Errors: Only display actual errors to the user. If the request was canceled due to navigation or unmounting, there's no need to set an error state.</p> </li> <li> <p>Error Monitoring: If you're using error tracking tools (like Sentry), you might want to configure them to ignore canceled requests.</p> </li> </ul>"},{"location":"js/httprequest/example/cancel-axios-api/#example-for-production","title":"Example for Production","text":"<p>Here\u2019s how you might adjust your code for production:</p> <pre><code>import React, { useState, useEffect } from 'react';\nimport axios from 'axios';\nimport './App.css';\n\nfunction App() {\n    const [data, setData] = useState(null);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n\n    const fetchData = async (url, apiKey, cancelToken) =&gt; {\n        try {\n            const response = await axios.get(url, {\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${apiKey}`,\n                },\n                cancelToken: cancelToken,\n            });\n\n            setData(response.data);\n        } catch (error) {\n            if (axios.isCancel(error)) {\n                // Optionally, you can log this in production for monitoring, but often it's unnecessary\n                // console.log('Request canceled:', error.message); // Commented out for production\n            } else {\n                setError(error);\n            }\n        } finally {\n            setLoading(false);\n        }\n    };\n\n    useEffect(() =&gt; {\n        const API_URL = 'https://jsonplaceholder.typicode.com/posts';\n        const API_KEY = '';\n\n        const source = axios.CancelToken.source();\n\n        fetchData(API_URL, API_KEY, source.token);\n\n        return () =&gt; {\n            source.cancel('Operation canceled by the user.');\n        };\n    }, []);\n\n  if (loading) return &lt;div&gt;Loading ...&lt;/div&gt;;\n  if (error) return &lt;div&gt;Error... {error.message}&lt;/div&gt;;\n\n  return (\n    &lt;div className=\"App\"&gt;\n        &lt;h1&gt;Data From API&lt;/h1&gt;\n        {data &amp;&amp; (\n            &lt;ul&gt;\n                {data.map((post) =&gt; (\n                &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        )}\n    &lt;/div&gt;\n  );\n}\n\nexport default App;\n</code></pre>"},{"location":"js/httprequest/example/cancel-axios-api/#summary","title":"Summary","text":"<ul> <li>Development: Log canceled requests for debugging purposes.</li> <li>Production: Generally ignore canceled requests unless there's a specific need. Focus on displaying actual errors to users.</li> </ul> <p>This approach keeps your error handling clean and user-friendly in a production environment while still allowing you to debug effectively during development.</p>"},{"location":"js/httprequest/example/cancel-axios-api/#additional","title":"Additional","text":"ExmapleScenarioExplanation <pre><code>import React, { useEffect, useState } from \"react\";\nimport axios from \"axios\";\n\nconst MyComponent = () =&gt; {\n    const [data, setData] = useState(null);\n    const [error, setError] = useState(null);\n\n    useEffect(() =&gt; {\n        // Create a cancel token source\n        const source = axios.CancelToken.source();\n\n        const fetchData = async () =&gt; {\n            try {\n                const response = await axios.get(\"https://api.example.com/data\", {\n                    cancelToken: source.token,\n                });\n                setData(response.data);\n            } catch (err) {\n                if (axios.isCancel(err)) {\n                    console.log(\"Request canceled\", err.message);\n                } else {\n                    setError(err);\n                }\n            }\n        };\n\n        fetchData();\n\n        // Cleanup function to cancel the request\n        return () =&gt; {\n            source.cancel(\"Operation canceled by the user.\");\n        };\n    }, []);\n\n    return (\n        &lt;div&gt;\n            {error &amp;&amp; &lt;p&gt;Error: {error.message}&lt;/p&gt;}\n            {data ? &lt;pre&gt;{JSON.stringify(data, null, 2)}&lt;/pre&gt; : &lt;p&gt;Loading...&lt;/p&gt;}\n        &lt;/div&gt;\n    );\n};\n\nexport default MyComponent;\n</code></pre> <p>To cancel an Axios HTTP request in a cleanup function, you can use the CancelToken feature provided by Axios. This is useful in React components, especially when making requests in effects. Here's a step-by-step guide:</p> <ol> <li>Create a Cancel Token: Use <code>axios.CancelToken.source()</code> to create a cancel token source.</li> <li>Make the request with the token: Pass the token to your Axios request.</li> <li>Cancel the request in cleanup: In the cleanup function of your <code>useEffect</code>, call the <code>cancel</code> method on the cancel token.</li> </ol> <ul> <li>Cancel Token Creation: <code>const source = axios.CancelToken.source();</code> creates a new cancel token.</li> <li>Making the Request: The cancel token is passed to the request via <code>cancelToken: source.token</code>.</li> <li>Cleanup: In the cleanup function returned from <code>useEffect</code>, you call <code>source.cancel(...)</code> to cancel the request if the component unmounts before the request completes.</li> </ul> <p>This approach helps avoid potential memory leaks and unnecessary state updates if the component is unmounted during the request.</p>"},{"location":"js/httprequest/example/cancel-fetch-api/","title":"Cancel Fetch","text":"<pre><code>import React, { useEffect, useState } from 'react';\nimport './App.css';\nimport { Button } from 'antd';\n\nfunction App() {\n  const [data, setData] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  const fetchData = async (url, apiKey, signal) =&gt; {\n    try {\n      const response = await fetch(url, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        signal,\n      });\n\n      if (!response.ok) {\n        throw new Error('Network response was not ok');\n      }\n      const data = await response.json();\n      setData(data);\n    } catch (error) {\n      // setError(error);\n      if (error.name !== 'AbortError') { // Ignore AbortError errors\n        setError(error.message);\n        console.error('Fetch error:', error);\n      }\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  useEffect(() =&gt; {\n    const API_URL = process.env.REACT_APP_API_URL;\n    const API_KEY = process.env.REACT_APP_API_KEY;\n\n    const controller = new AbortController();\n    const signal = controller.signal;\n\n    fetchData(API_URL, API_KEY, signal);\n\n    return () =&gt; {\n      controller.abort();\n    };\n  }, [])\n\n  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n  if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;\n\n  return (\n    &lt;div className=\"App\"&gt;\n      &lt;Button\n          type=\"primary\"\n        &gt;Hello&lt;/Button&gt;\n      &lt;h1&gt;Data from API&lt;/h1&gt;\n      {/* &lt;pre&gt;{JSON.stringify(data, null, 2)}&lt;/pre&gt; */}\n    &lt;/div&gt;\n  );\n}\n\nexport default App;\n</code></pre>"},{"location":"js/httprequest/example/fetch-api-example/","title":"Fetch Api Example","text":""},{"location":"js/httprequest/example/fetch-api-example/#overview","title":"Overview","text":"<p>In this scenario, I'll show you how to make a request to an API, including the API key in the headers.</p>"},{"location":"js/httprequest/example/fetch-api-example/#example-react-component-using-fetch","title":"Example React Component Using <code>fetch</code>","text":"<p>Here's a simple React component that fetches data from an API that requires an API key:</p> ExampleExplanationCustomizing <pre><code>import React, { useState, useEffect } from 'react';\n\nfunction FetchExample() {\n    // State to hold data and loading status\n    const [data, setData] = useState(null);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n\n    useEffect(() =&gt; {\n        // Define your API endpoint and API key\n        const API_URL = 'https://api.example.com/data'; // Replace with your API URL\n        const API_KEY = 'your-api-key'; // Replace with your API key\n\n        // Fetch data from API\n        fetch(API_URL, {\n            method: 'GET',\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Bearer ${API_KEY}`, // Include the API key in headers\n            },\n            })\n            .then(response =&gt; {\n                if (!response.ok) {\n                throw new Error('Network response was not ok');\n                }\n                return response.json();\n            })\n            .then(data =&gt; {\n                setData(data);\n                setLoading(false);\n            })\n            .catch(error =&gt; {\n                setError(error);\n                setLoading(false);\n            });\n    }, []); // Empty dependency array means this runs once when the component mounts\n\n    // Render loading, error, or data\n    if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Data from API&lt;/h1&gt;\n            &lt;pre&gt;{JSON.stringify(data, null, 2)}&lt;/pre&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default FetchExample;\n</code></pre> <ol> <li> <p>State Management:</p> <ul> <li><code>data</code> is used to store the API response.</li> <li><code>loading</code> is used to indicate if the data is still being fetched.</li> <li><code>error</code> is used to store any error that occurs during the fetch.</li> </ul> </li> <li> <p><code>useEffect</code> Hook:</p> <ul> <li>The <code>useEffect</code> hook is used to perform the side effect of fetching data when the component mounts. The empty dependency array <code>[]</code> ensures this effect runs only once.</li> </ul> </li> <li> <p>Fetching Data:</p> <ul> <li><code>fetch(API_URL, { ... })</code> is used to make the GET request to the API.</li> <li>The <code>Authorization</code> header is used to include the API key. Replace <code>Bearer ${API_KEY}</code> with the appropriate header format if your API uses a different scheme.</li> <li>The response is checked for success and converted to JSON.</li> </ul> </li> <li> <p>Error Handling:</p> <ul> <li>If the response is not ok, an error is thrown. Any errors during the fetch process are caught and stored in the <code>error</code> state.</li> </ul> </li> <li> <p>Rendering:</p> <ul> <li>The component conditionally renders based on the state: showing loading, error, or the fetched data.</li> </ul> </li> </ol> <ul> <li>Replace <code>https://api.example.com/data</code> with your actual API endpoint.</li> <li>Replace <code>your-api-key</code> with your actual API key.</li> <li>Modify the headers as needed based on the requirements of your API.</li> </ul> <p>This example provides a basic structure for making API requests with <code>fetch</code> in a React component and should be adaptable to most scenarios where an API key is required.</p>"},{"location":"js/httprequest/example/fetch-api-example/#optimized-example-react-component","title":"Optimized Example React Component","text":"ExampleImprovements and ExplanationsAdditional Considerations <pre><code>import React, { useState, useEffect } from 'react';\n\nfunction FetchExample() {\n    const [data, setData] = useState(null);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n\n    useEffect(() =&gt; {\n        // Define the API request function\n        const fetchData = async () =&gt; {\n        const API_URL = 'https://api.example.com/data'; // Replace with your API URL\n        const API_KEY = 'your-api-key'; // Replace with your API key\n\n        try {\n            const response = await fetch(API_URL, {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${API_KEY}`, // Include the API key in headers\n                },\n            });\n\n            if (!response.ok) {\n                throw new Error('Network response was not ok');\n            }\n\n            const result = await response.json();\n            setData(result);\n        } catch (err) {\n            setError(err);\n        } finally {\n            setLoading(false);\n        }\n        };\n\n        fetchData();\n    }, []); // Empty dependency array means this runs once when the component mounts\n\n    // Render loading, error, or data\n    if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Data from API&lt;/h1&gt;\n            &lt;pre&gt;{JSON.stringify(data, null, 2)}&lt;/pre&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default FetchExample;\n</code></pre> <ol> <li> <p>Async/Await Syntax:</p> <ul> <li>Using <code>async/await</code> makes the code cleaner and easier to read compared to using <code>.then()</code> and <code>.catch()</code>.</li> </ul> </li> <li> <p>Error Handling:</p> <ul> <li>The <code>try/catch</code> block handles errors from both the network request and JSON parsing. This makes the error handling more robust.</li> </ul> </li> <li> <p>Loading State:</p> <ul> <li>The <code>finally</code> block ensures that the <code>loading</code> state is set to <code>false</code> whether the request succeeds or fails.</li> </ul> </li> <li> <p>API Request Function:</p> <ul> <li>Extracting the API request logic into a separate <code>fetchData</code> function inside <code>useEffect</code> helps to keep the effect clean and more readable.</li> </ul> </li> </ol> <ol> <li> <p>Environment Variables:</p> <ul> <li>For security, consider using environment variables to store sensitive information like API keys. Create a <code>.env</code> file in the root of your project and add your API key there:</li> </ul> <pre><code>REACT_APP_API_KEY=your-api-key\n</code></pre> <p>Access this variable in your component:</p> <pre><code>const API_KEY = process.env.REACT_APP_API_KEY;\n</code></pre> </li> <li> <p>Abort Controller:</p> <ul> <li> <p>If your component might unmount before the fetch completes, consider using an <code>AbortController</code> to cancel the request. Here\u2019s how to integrate it:</p> <pre><code>useEffect(() =&gt; {\n    const controller = new AbortController();\n    const signal = controller.signal;\n\n    const fetchData = async () =&gt; {\n        const API_URL = 'https://api.example.com/data';\n        const API_KEY = process.env.REACT_APP_API_KEY;\n\n        try {\n            const response = await fetch(API_URL, {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${API_KEY}`,\n                },\n                signal,\n            });\n\n            if (!response.ok) {\n                throw new Error('Network response was not ok');\n            }\n\n            const result = await response.json();\n            setData(result);\n        } catch (err) {\n            if (err.name === 'AbortError') {\n                console.log('Fetch aborted');\n            } else {\n                setError(err);\n            }\n        } finally {\n            setLoading(false);\n        }\n    };\n\n    fetchData();\n\n    return () =&gt; controller.abort();\n}, []);\n</code></pre> </li> <li> <p>This way, if the component unmounts before the fetch is completed, the request will be aborted, preventing potential memory leaks.</p> </li> </ul> </li> </ol> <p>By incorporating these optimizations, your code will be more maintainable, readable, and robust.</p>"},{"location":"js/httprequest/example/fetch-api-example/#cleaner-code","title":"Cleaner Code","text":"ExampleExplanationSummary <pre><code>import React, { useState, useEffect } from 'react';\n\nfunction FetchExample() {\n    // State to hold data and loading status\n    const [data, setData] = useState(null);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n\n    // Define the fetch function inside the component\n    const fetchData = async (url, apiKey) =&gt; {\n        try {\n            const response = await fetch(url, {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${apiKey}`, // Include the API key in headers\n                },\n            });\n\n            if (!response.ok) {\n                throw new Error('Network response was not ok');\n            }\n\n            const data = await response.json();\n            setData(data);\n        } catch (error) {\n            setError(error);\n        } finally {\n            setLoading(false);\n        }\n    };\n\n    useEffect(() =&gt; {\n        // Define your API endpoint and API key\n        const API_URL = 'https://api.example.com/data'; // Replace with your API URL\n        const API_KEY = 'your-api-key'; // Replace with your API key\n\n        fetchData(API_URL, API_KEY);\n    }, []); // Empty dependency array means this runs once when the component mounts\n\n    // Render loading, error, or data\n    if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Data from API&lt;/h1&gt;\n            &lt;pre&gt;{JSON.stringify(data, null, 2)}&lt;/pre&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default FetchExample;\n</code></pre> <ol> <li> <p>Function Definition Inside Component:</p> <ul> <li>The <code>fetchData</code> function is defined inside the <code>FetchExample</code> component. This approach makes sense when the function is closely tied to the component\u2019s logic and isn\u2019t reused elsewhere.</li> </ul> </li> <li> <p>Encapsulation:</p> <ul> <li>Keeping the <code>fetchData</code> function within the component encapsulates its behavior and dependencies. This can be useful for maintaining a clear connection between the function and the component state it operates on.</li> </ul> </li> <li> <p>Cleaner and More Readable:</p> <ul> <li>Defining the function inside keeps related code together, which can be beneficial for readability and maintainability, especially for simpler components.</li> </ul> </li> <li> <p>Code Organization:</p> <ul> <li>If the <code>fetchData</code> function were to become more complex or be used across multiple components, you might consider moving it to a separate file or utility module. For now, defining it inside the component is suitable.</li> </ul> </li> <li> <p>React Best Practices:</p> <ul> <li>Both approaches (defining the function inside or outside the component) are valid. Choosing between them depends on factors like the complexity of the function, code reusability, and personal or team coding preferences.</li> </ul> </li> </ol> <p>For the given example, defining the <code>fetchData</code> function inside the <code>FetchExample</code> component keeps the code compact and easier to understand, especially if the function is specific to that component. It\u2019s a matter of balancing between code clarity, modularity, and maintainability based on the context and complexity of the function.</p>"},{"location":"js/httprequest/example/overview/","title":"Overview","text":"<p>fsdafdf</p>"},{"location":"js/httprequest/example/useReducer/","title":"useReducer","text":"<p>Using <code>useReducer</code> instead of <code>useState</code> hooks.</p> fetchasync/await <pre><code>import { useReducer, useEffect } from 'react';\n\nconst initialState = { data: null, loading: true, error: null };\n\nfunction reducer(state, action) {\n    switch (action.type) {\n        case 'FETCH_SUCCESS':\n            return { ...state, data: action.payload, loading: false };\n        case 'FETCH_ERROR':\n            return { ...state, error: action.payload, loading: false };\n        default:\n            throw new Error();\n    }\n}\n\nfunction Example() {\n    const [state, dispatch] = useReducer(reducer, initialState);\n\n    useEffect(() =&gt; {\n        fetch('https://api.example.com/data')\n            .then(response =&gt; response.json())\n            .then(data =&gt; dispatch({ type: 'FETCH_SUCCESS', payload: data }))\n            .catch(error =&gt; dispatch({ type: 'FETCH_ERROR', payload: error }));\n    }, []);\n\n    if (state.loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (state.error) return &lt;div&gt;Error: {state.error.message}&lt;/div&gt;;\n\n    return &lt;div&gt;{JSON.stringify(state.data)}&lt;/div&gt;;\n}\n</code></pre> ExampleExplanationChanges Made <pre><code>import { useReducer, useEffect } from 'react';\n\nconst initialState = { data: null, loading: true, error: null };\n\nfunction reducer(state, action) {\n    switch (action.type) {\n        case 'FETCH_SUCCESS':\n            return { ...state, data: action.payload, loading: false };\n        case 'FETCH_ERROR':\n            return { ...state, error: action.payload, loading: false };\n        default:\n            throw new Error();\n    }\n}\n\nfunction Example() {\n    const [state, dispatch] = useReducer(reducer, initialState);\n\n    useEffect(() =&gt; {\n        // Define an async function inside useEffect\n        const fetchData = async () =&gt; {\n            try {\n                const response = await fetch('https://api.example.com/data');\n                if (!response.ok) {\n                    throw new Error('Network response was not ok');\n                }\n                const data = await response.json();\n                dispatch({ type: 'FETCH_SUCCESS', payload: data });\n            } catch (error) {\n                dispatch({ type: 'FETCH_ERROR', payload: error });\n            }\n        };\n\n        fetchData(); // Call the async function\n    }, []);\n\n    if (state.loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (state.error) return &lt;div&gt;Error: {state.error.message}&lt;/div&gt;;\n\n    return &lt;div&gt;{JSON.stringify(state.data)}&lt;/div&gt;;\n}\n\nexport default Example;\n</code></pre> <p>Certainly! To convert the code to use <code>async/await</code>, you'll need to make some adjustments to the <code>useEffect</code> hook. Here\u2019s how you can update it:</p> <ul> <li>Define an <code>async</code> function inside <code>useEffect</code> to handle the asynchronous fetch operation.</li> <li>Call this <code>async</code> function immediately within <code>useEffect</code>.</li> </ul> <ul> <li>Added an <code>async</code> function inside the <code>useEffect</code> hook to perform the fetch operation.</li> <li>Called <code>await</code> on the fetch function and <code>.json()</code> to handle promises with <code>async/await</code>.</li> <li>Added a check to throw an error if the response is not ok (to handle HTTP errors).</li> </ul> <p>This approach makes the asynchronous code cleaner and easier to read compared to using <code>.then</code> and <code>.catch</code>.</p>"},{"location":"js/httprequest/example/useReducer/#making-code-modular","title":"Making Code Modular","text":"<p>can we separate the api call to api folder</p> <p>Yes, separating the API call into a dedicated file or folder is a great idea for better organization and maintainability. You can create a separate module for the API call and then import it into your component. Here\u2019s how you can do that:</p> Step 1: Create an API UtilityStep 2: Update Your Component <ol> <li>Create a new file in your project, for example, <code>api.js</code> or <code>api.ts</code> if you're using TypeScript. You might place it in an <code>api</code> folder or similar.</li> <li>Define the API call function in this file. For instance, you can create a function that fetches data from the API:</li> </ol> <pre><code>// api/api.js\n\nexport async function fetchData() {\n    const response = await fetch('https://api.example.com/data');\n    if (!response.ok) {\n        throw new Error('Network response was not ok');\n    }\n    const data = await response.json();\n    return data;\n}\n</code></pre> <ol> <li>Import the API function into your component file.</li> <li>Use the imported function inside the <code>useEffect</code> hook.</li> </ol> <p>Here\u2019s how you can modify your <code>Example</code> component:</p> <pre><code>import { useReducer, useEffect } from 'react';\nimport { fetchData } from './api/api'; // Adjust the import path according to your folder structure\n\nconst initialState = { data: null, loading: true, error: null };\n\nfunction reducer(state, action) {\n    switch (action.type) {\n        case 'FETCH_SUCCESS':\n            return { ...state, data: action.payload, loading: false };\n        case 'FETCH_ERROR':\n            return { ...state, error: action.payload, loading: false };\n        default:\n            throw new Error();\n    }\n}\n\nfunction Example() {\n    const [state, dispatch] = useReducer(reducer, initialState);\n\n    useEffect(() =&gt; {\n        // Define an async function inside useEffect\n        const fetchDataFromAPI = async () =&gt; {\n            try {\n                const data = await fetchData();\n                dispatch({ type: 'FETCH_SUCCESS', payload: data });\n            } catch (error) {\n                dispatch({ type: 'FETCH_ERROR', payload: error });\n            }\n        };\n\n        fetchDataFromAPI(); // Call the async function\n    }, []);\n\n    if (state.loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (state.error) return &lt;div&gt;Error: {state.error.message}&lt;/div&gt;;\n\n    return &lt;div&gt;{JSON.stringify(state.data)}&lt;/div&gt;;\n}\n\nexport default Example;\n</code></pre>"},{"location":"js/httprequest/example/useReducer/#summary","title":"Summary","text":"<ul> <li><code>api/api.js</code>: Contains the <code>fetchData</code> function that performs the API request.</li> <li>Component: Imports <code>fetchData</code> and uses it within the <code>useEffect</code> hook.</li> </ul> <p>This separation makes your component code cleaner and adheres to the principle of separation of concerns.</p>"},{"location":"js/httprequest/example/useReducer/#reducerjs","title":"<code>reducer.js</code>","text":"<p>can we use <code>reducer.js</code> without using redux</p> <p>Yes, you can use a reducer pattern without Redux. The reducer concept is a fundamental part of state management in JavaScript, often associated with the \"Reducer\" pattern used in libraries like Redux. However, you can implement similar functionality directly in your components or custom hooks.</p> <p>Using Reducers Without Redux</p> <p>You can utilize the <code>useReducer</code> hook provided by React to manage complex state logic without Redux. Here's a simple example:</p> <ol> <li>Basic Example of useReducer</li> </ol> ExampleExplanationAdvantages of Using <code>useReducer</code> <pre><code>import React, { useReducer } from \"react\";\n\n// Define the initial state\nconst initialState = {\n  loading: false,\n  data: null,\n  error: null,\n};\n\n// Define the reducer function\nconst reducer = (state, action) =&gt; {\n  switch (action.type) {\n    case \"FETCH_DATA_REQUEST\":\n      return { ...state, loading: true, error: null };\n    case \"FETCH_DATA_SUCCESS\":\n      return { ...state, loading: false, data: action.payload };\n    case \"FETCH_DATA_FAILURE\":\n      return { ...state, loading: false, error: action.payload };\n    default:\n      return state;\n  }\n};\n\nconst MyComponent = () =&gt; {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  const fetchData = async () =&gt; {\n    dispatch({ type: \"FETCH_DATA_REQUEST\" });\n    try {\n      const response = await fetch(\"https://api.example.com/data\");\n      const data = await response.json();\n      dispatch({ type: \"FETCH_DATA_SUCCESS\", payload: data });\n    } catch (error) {\n      dispatch({ type: \"FETCH_DATA_FAILURE\", payload: error.message });\n    }\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;button onClick={fetchData}&gt;Fetch Data&lt;/button&gt;\n\n      {state.loading &amp;&amp; &lt;p&gt;Loading...&lt;/p&gt;}\n      {state.error &amp;&amp; &lt;p&gt;Error: {state.error}&lt;/p&gt;}\n      {state.data &amp;&amp; &lt;pre&gt;{JSON.stringify(state.data, null, 2)}&lt;/pre&gt;}\n    &lt;/div&gt;\n  );\n};\n\nexport default MyComponent;\n</code></pre> <ul> <li>Initial State: You define an initial state object to represent your component's state.</li> <li>Reducer Function: The <code>reducer</code> function processes actions and returns a new state based on the action type.</li> <li>useReducer Hook: The <code>useReducer</code> hook is used to initialize state and provide a dispatch function to send actions.</li> <li>Fetch Logic: The <code>fetchData</code> function handles the API call and dispatches actions based on the result.</li> </ul> <ul> <li>State Management: It provides a way to manage complex state logic without external libraries.</li> <li>Clear Structure: It organizes state transitions clearly with a central reducer function.</li> <li>Component Scope: The state is scoped to the component, avoiding potential conflicts with other components.</li> </ul> Summary <p>You can absolutely use a reducer pattern with <code>useReducer</code> in React without Redux. This approach is particularly useful for managing local state in a component, especially when dealing with complex state transitions or multiple related state variables.</p>"},{"location":"js/httprequest/example/useReducer/#reducer-pattern","title":"reducer pattern","text":"<p>The reducer pattern is a design pattern commonly used in state management to handle state changes in a predictable way. It is particularly well-known in libraries like Redux but can be applied in various contexts, including React\u2019s <code>useReducer</code> hook. Here\u2019s a breakdown of the reducer pattern:</p> Key Concepts of the Reducer Pattern <ol> <li> <p>Pure Function:</p> <ul> <li>A reducer is a pure function that takes the current state and an action as arguments and returns a new state.</li> <li>It does not mutate the existing state; instead, it creates a new state object based on the provided action.</li> </ul> </li> <li> <p>State Management:</p> <ul> <li>The reducer handles the state transitions of an application or component based on the actions dispatched to it.</li> <li>Each action represents a specific type of change (e.g., fetching data, updating values, handling errors).</li> </ul> </li> <li> <p>Actions:</p> <ul> <li>Actions are plain JavaScript objects that describe what happened in the application. Each action typically has a <code>type</code> property (a string) and may have a <code>payload</code> containing additional data.</li> </ul> </li> <li> <p>Initial State:</p> <ul> <li>The reducer starts with an initial state that defines the starting conditions for the application or component.</li> </ul> </li> </ol> Structure of a Reducer <p>A typical reducer looks like this:</p> <pre><code>const initialState = {\n    count: 0,\n    loading: false,\n    error: null,\n};\n\nconst reducer = (state, action) =&gt; {\n    switch (action.type) {\n        case 'INCREMENT':\n            return { ...state, count: state.count + 1 };\n        case 'DECREMENT':\n            return { ...state, count: state.count - 1 };\n        case 'FETCH_REQUEST':\n            return { ...state, loading: true, error: null };\n        case 'FETCH_SUCCESS':\n            return { ...state, loading: false, data: action.payload };\n        case 'FETCH_FAILURE':\n            return { ...state, loading: false, error: action.payload };\n        default:\n            return state;\n    }\n};\n</code></pre> <p>Example of Using a Reducer</p> ExampleAdvantages of the Reducer Pattern <p>Here\u2019s an example using the <code>useReducer</code> hook in a React component:</p> <pre><code>import React, { useReducer } from \"react\";\n\nconst initialState = { count: 0 };\n\nconst reducer = (state, action) =&gt; {\n    switch (action.type) {\n        case \"INCREMENT\":\n            return { ...state, count: state.count + 1 };\n        case \"DECREMENT\":\n            return { ...state, count: state.count - 1 };\n        default:\n            return state;\n    }\n};\n\nconst Counter = () =&gt; {\n    const [state, dispatch] = useReducer(reducer, initialState);\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;{state.count}&lt;/h1&gt;\n            &lt;button onClick={() =&gt; dispatch({ type: \"INCREMENT\" })}&gt;Increment&lt;/button&gt;\n            &lt;button onClick={() =&gt; dispatch({ type: \"DECREMENT\" })}&gt;Decrement&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Counter;\n</code></pre> <ul> <li>Predictability: Since the reducer is a pure function, given the same input (state and action), it will always produce the same output. This makes debugging and testing easier.</li> <li>Separation of Concerns: The reducer separates the logic for updating the state from the UI components, improving code organization and maintainability.</li> <li>Centralized State Management: By using a reducer, you centralize the state management logic, making it easier to understand and modify.</li> </ul> Conclusion <p>The reducer pattern is a powerful tool for managing state in applications, especially when state logic is complex. It promotes a clear and predictable way to handle state transitions and is widely used in modern JavaScript frameworks and libraries.</p>"},{"location":"js/httprequest/http/api/","title":"API","text":"<p>Understanding the Difference Between Response Object and Parsed Data in API Fetch Requests</p> Quote <pre><code>\"Decoding API Responses: Response Object vs. Parsed Data\"\n\"How to Differentiate Between API Response Metadata and Data\"\n\"Understanding Fetch API: Inspecting Response Objects and JSON Data\"\n\"API Fetch Explained: Distinguishing Between Response and Data\"\n\"From Response Object to JSON Data: A Guide to Handling API Fetch Results\"\n\"Fetching Data from APIs: Parsing Responses and Understanding Output\"\n\"Navigating API Responses: What the Response Object and Data Represent\"\n\"Unpacking API Fetch Responses: Insights into Response Objects and Data Extraction\"\n\"Fetching and Parsing API Data: A Closer Look at Response vs. JSON Content\"\n\"API Fetch Demystified: Differences Between the Response Object and Parsed Data\"\n</code></pre>"},{"location":"js/httprequest/http/api/#overview","title":"Overview","text":"<p>Let\u2019s break down what\u2019s happening step-by-step in your code:</p> <ol> <li> <p>Fetching Data:</p> ExampleExplanation <pre><code>const response = await fetch(apiUrl, {\n    method: 'GET', // or 'POST', 'PUT', etc. depending on your API\n    headers: {\n        'Authorization': `Api-Key ${apiKey}`,\n        'Content-Type': 'application/json'\n    }\n});\n</code></pre> <p>This code sends a request to the specified <code>apiUrl</code> with the method 'GET' and the specified headers. <code>await</code> pauses the execution of the function until the fetch operation is complete, and the result is assigned to <code>response</code>.</p> </li> <li> <p>Handling Response:</p> ExampleExplanation <pre><code>if (!response.ok) {\n    throw new Error('Network response was not ok');\n}\nconsole.log(\"RESPONSE: \", response)\n</code></pre> <p><code>response.ok</code> checks if the HTTP status code is in the range 200-299, indicating a successful request. If the response is not ok, an error is thrown. The <code>console.log(\"RESPONSE: \", response)</code> prints the <code>response</code> object to the console.</p> <ul> <li> <p>What is <code>response</code> ?</p> <p>The <code>response</code> object represents the response to the request and contains metadata like status codes and headers. It does not directly contain the response data; rather, it provides methods to retrieve it.</p> </li> </ul> </li> <li> <p>Extracting JSON Data:</p> ExampleExplanation <pre><code>const data = await response.json();\nconsole.log(\"data: \", data)\n</code></pre> <p><code>response.json()</code> reads the response stream to completion and parses it as JSON. This method returns a promise that resolves with the result of parsing the body text as JSON. Using <code>await</code> here, the execution pauses until the JSON is fully parsed and assigned to <code>data</code>.</p> <ul> <li> <p>What is <code>data</code> ?</p> <p><code>data</code> contains the actual data returned from the API in JSON format. This is the useful information you're interested in, such as an object or array of values, depending on what the API returns.</p> </li> </ul> </li> <li> <p>Explanation of Console Logs:</p> <ul> <li> <p><code>console.log(\"RESPONSE: \", response)</code> This logs the <code>response</code> object itself. This object includes various properties like <code>status</code>, <code>statusText</code>, <code>headers</code>, and methods to read the response body (like <code>response.json()</code>, <code>response.text()</code>, etc.). It doesn't show the actual data content from the response directly but rather information about the response.</p> </li> <li> <p><code>console.log(\"data: \", data)</code> This logs the content of the response after it has been parsed from JSON. This is the actual data returned by the API.</p> </li> </ul> </li> </ol> <p>In summary, <code>response</code> is the raw response object from the API call, which contains metadata and methods for extracting the data. <code>data</code> is the parsed JSON content of the response, representing the actual data returned by the API.</p>"},{"location":"js/httprequest/http/api/#understanding-the-response-object","title":"Understanding the <code>response</code> Object","text":"<p>When you make a network request using the <code>fetch</code> API, the <code>response</code> object that you receive contains metadata about the request and methods to retrieve the response body. However, the raw response body is not automatically in the format you might expect. Here\u2019s why:</p> <ol> <li> <p>Raw Response Body: The <code>response</code> object contains a stream of data, not the parsed data itself. This means that the body of the response is just a raw stream of bytes, and you need to explicitly extract and interpret this data.</p> </li> <li> <p>Response Methods: The <code>response</code> object provides several methods to read the response body:</p> <ul> <li><code>response.text()</code>: Reads the body as a string.</li> <li><code>response.json()</code>: Parses the body as JSON.</li> <li><code>response.blob()</code>: Reads the body as a <code>Blob</code> (binary large object).</li> <li><code>response.formData()</code>: Reads the body as <code>FormData</code>.</li> </ul> </li> </ol> The Role of <code>response.json()</code> <p>The <code>response.json()</code> method is used specifically to parse the response body as JSON. Here\u2019s a step-by-step explanation of what happens:</p> <ol> <li> <p>Fetching Data: When you make a fetch request, the response body is delivered as a raw stream. This stream contains the data in its original format, which is often JSON, but not necessarily so until it is processed.</p> </li> <li> <p>Parsing JSON: JSON (JavaScript Object Notation) is a text-based format for representing structured data. The response.json() method performs the following tasks:</p> <ul> <li>Reads the Response: It reads the entire body of the response stream.</li> <li>Parses JSON: It then parses the body text as JSON, which converts the JSON text into a JavaScript object or array that you can work with directly.</li> </ul> </li> <li> <p>Return Value: <code>response.json()</code> returns a promise that resolves to the parsed JavaScript object. This means that once you call <code>await response.json()</code>, you get the data in a usable format.</p> </li> </ol> Why Not Use the Raw Response Directly? <ul> <li> <p>Data Interpretation: The raw response body is just a series of bytes. It needs to be interpreted (or decoded) to be usable. For JSON data, this means converting the raw JSON text into a JavaScript object or array.</p> </li> <li> <p>Error Handling: <code>response.json()</code> also helps with error handling. If the response body is not valid JSON, calling <code>response.json()</code> will throw an error, which you can catch and handle.</p> </li> </ul>"},{"location":"js/httprequest/http/api/#example","title":"Example","text":"CodeExplanation <pre><code>try {\n    const response = await fetch(apiUrl);\n\n    if (!response.ok) {\n        throw new Error('Network response was not ok');\n    }\n\n    // Attempting to parse the response as JSON\n    const data = await response.json();\n    console.log(\"Parsed Data: \", data);\n} catch (error) {\n    console.error('Error fetching or parsing data:', error);\n}\n</code></pre> <ul> <li><code>await response.json()</code> reads the response body stream, parses it as JSON, and converts it into a JavaScript object or array.</li> <li>Without using <code>response.json()</code>, you would not get the JSON data directly; you would have the raw response body that needs to be explicitly parsed</li> </ul>"},{"location":"js/httprequest/http/api/#summary","title":"Summary","text":"<ul> <li>Raw Response: The <code>response</code> object contains the raw response stream, not the parsed data.</li> <li><code>response.json()</code>: This method reads the raw stream, parses it as JSON, and returns a JavaScript object or array.</li> <li>Parsing Necessity: Parsing is necessary to convert the raw JSON text into a format that you can easily manipulate in JavaScript.</li> </ul> <p>Using <code>response.json()</code> ensures you get the JSON data correctly parsed and ready for use, which is essential for working with APIs that return data in JSON format.</p>"},{"location":"js/httprequest/http/api/#properties-methods-of-response-object-can-vary","title":"Properties &amp; Methods of <code>response</code> object can vary","text":"<p>The <code>response</code> object is central to handling HTTP responses when using modern web APIs, such as the Fetch API in JavaScript. It provides various properties and methods to access and manipulate the details of an HTTP response.</p> <p>Yes, the properties and methods of the <code>response</code> object can vary depending on the environment, library, or framework you are using.</p> <p>While there are common concepts and functionalities, the exact implementation details might differ. Here\u2019s a comparison of how different environments and libraries handle HTTP responses:</p>"},{"location":"js/httprequest/http/api/#1-fetch-api-browser","title":"1. Fetch API (Browser)","text":"<p>In the Fetch API, the <code>Response</code> object includes several standardized properties and methods:</p> PropertiesMethods <ul> <li><code>status</code>: The HTTP status code of the response.</li> <li><code>statusText</code>: The status message corresponding to the status code.</li> <li><code>headers</code>: An instance of the <code>Headers</code> class representing the response headers.</li> <li><code>url</code>: The URL of the response.</li> <li><code>type</code>: The type of the response (e.g., \"basic\", \"cors\", \"default\", \"error\", \"opaque\").</li> </ul> <ul> <li><code>text()</code>: Reads the response body as a string.</li> <li><code>json()</code>: Reads the response body and parses it as JSON.</li> <li><code>blob()</code>: Reads the response body as a <code>Blob</code> (binary data).</li> <li><code>formData()</code>: Reads the response body and parses it as <code>FormData</code>.</li> <li><code>arrayBuffer()</code>: Reads the response body as an <code>ArrayBuffer</code>.</li> </ul>"},{"location":"js/httprequest/http/api/#2-axios-javascript-library","title":"2. Axios (JavaScript Library)","text":"<p>Axios handles HTTP responses slightly differently, as it is built on top of <code>XMLHttpRequest</code> or Node.js <code>http</code> module. The <code>response</code> object in Axios includes:</p> PropertiesMethods <ul> <li><code>data</code>: The response body, automatically parsed according to the response content type (e.g., JSON).</li> <li><code>status</code>: The HTTP status code of the response.</li> <li><code>statusText</code>: The status message corresponding to the status code.</li> <li><code>headers</code>: The headers of the response.</li> <li><code>config</code>: The configuration object used for the request.</li> <li><code>request</code>: The request object (in some environments).</li> </ul> <ul> <li>Axios does not provide methods to transform the response body; instead, the <code>data</code> property is already in the parsed format (e.g., JSON).</li> </ul>"},{"location":"js/httprequest/http/api/#3-node-fetch-nodejs-library","title":"3. Node-Fetch (Node.js Library)","text":"<p>Node-Fetch closely resembles the Fetch API in browsers, but there are minor differences due to the Node.js environment:</p> PropertiesMethods <ul> <li>Similar to Fetch API with <code>status</code>, <code>statusText</code>, <code>headers</code>, <code>url</code>, and <code>type</code>.</li> </ul> <ul> <li>Similar to Fetch API with <code>text()</code>, <code>json()</code>, <code>blob()</code>, <code>formData()</code>, and <code>arrayBuffer()</code>.</li> </ul>"},{"location":"js/httprequest/http/api/#4-python-requests-library","title":"4. Python (Requests Library)","text":"<p>In the requests library for Python, the Response object has:</p> PropertiesMethods <ul> <li><code>status_code</code>: The HTTP status code of the response.</li> <li><code>headers</code>: The headers of the response.</li> <li><code>url</code>: The URL of the response.</li> <li><code>content</code>: The raw content of the response as bytes.</li> <li><code>text</code>: The content of the response decoded as a string.</li> <li><code>json()</code>: Method to parse the response body as JSON.</li> </ul> <ul> <li><code>json()</code>: Parses the response body as JSON.</li> </ul>"},{"location":"js/httprequest/http/api/#5-java-httpclient","title":"5. Java (HttpClient)","text":"<p>In Java's HttpClient:</p> PropertiesMethods <ul> <li><code>statusCode()</code>: The HTTP status code of the response.</li> <li><code>headers()</code>: The headers of the response.</li> <li><code>body()</code>: The body of the response (as a <code>BodyHandler</code> type).</li> </ul> <ul> <li>Java's HttpClient does not have direct methods like <code>text()</code> or <code>json()</code>. You handle the response body through the <code>BodyHandler</code> (e.g., <code>BodyHandlers.ofString()</code>, <code>BodyHandlers.ofByteArray()</code>).</li> </ul>"},{"location":"js/httprequest/http/api/#6-c-net-httpclient","title":"6. C# (.NET HttpClient)","text":"<p>In .NET's HttpClient:</p> PropertiesMethods <ul> <li><code>StatusCode</code>: The HTTP status code of the response.</li> <li><code>Headers</code>: The headers of the response.</li> <li><code>Content</code>: The content of the response.</li> </ul> <ul> <li>Methods for handling content, such as <code>ReadAsStringAsync()</code> for reading as a string and <code>ReadAsJsonAsync&lt;T&gt;()</code> for JSON parsing (using <code>System.Text.Json</code> or <code>Newtonsoft.Json</code>).</li> </ul>"},{"location":"js/httprequest/http/api/#summary_1","title":"Summary","text":"<ul> <li>Consistency: While there are consistent concepts (status code, headers, body content), the exact properties and methods can vary.</li> <li>Library/Environment Specifics: Each environment or library has its own way of representing and interacting with the HTTP response object.</li> <li>Adaptation: Understanding how to work with the response object depends on the specific API or library you are using, and it\u2019s important to refer to the documentation of that environment for detailed information.</li> </ul> <p>By understanding the specific details of how HTTP responses are handled in your environment, you can effectively work with responses, handle data, and manage errors.</p>"},{"location":"js/httprequest/http/http-request/","title":"HTTP Request","text":"<p>An HTTP request is a message sent from a client (such as a web browser or application) to a server to request data or perform an action. HTTP (Hypertext Transfer Protocol) is the foundation of data communication on the web.</p>"},{"location":"js/httprequest/http/http-request/#types-of-http-requests","title":"Types of HTTP Requests","text":"<ol> <li>GET: Requests data from a specified resource.</li> <li>POST: Submits data to be processed to a specified resource.</li> <li>PUT: Updates a specified resource with new data.</li> <li>DELETE: Deletes a specified resource.</li> <li>PATCH: Applies partial modifications to a resource.</li> </ol>"},{"location":"js/httprequest/http/http-request/#understanding-http-requests-in-javascript","title":"Understanding HTTP Requests in JavaScript","text":"<p>To master HTTP requests in JavaScript, you'll want to be familiar with the different methods for making requests, handling responses, and dealing with various scenarios like error handling and asynchronous operations. Here's a structured approach to mastering HTTP requests:</p> <ol> <li> <p>Learn the Basics</p> <ul> <li>HTTP Methods: Understand what each HTTP method does and when to use it.</li> <li>Status Codes: Learn common status codes like 200 (OK), 404 (Not Found), and 500 (Internal Server Error).</li> <li>Headers: Understand headers and their role in requests and responses (e.g., Content-Type, Authorization).</li> </ul> </li> <li> <p>Use <code>Built-in</code> APIs</p> <p>Fetch API</p> Basic UsageAdvanced Usage <pre><code>fetch('https://api.example.com/data')\n    .then(response =&gt; {\n        if (!response.ok) {\n            throw new Error('Network response was not ok');\n        }\n        return response.json();\n    })\n    .then(data =&gt; {\n        console.log(data);\n    })\n    .catch(error =&gt; {\n        console.error('Fetch error:', error);\n    });\n</code></pre> <pre><code>fetch('https://api.example.com/data', {\n    method: 'POST',\n    headers: {\n        'Content-Type': 'application/json',\n        'Authorization': 'Bearer token'\n    },\n    body: JSON.stringify({ key: 'value' })\n})\n.then(response =&gt; response.json())\n.then(data =&gt; console.log(data))\n.catch(error =&gt; console.error('Fetch error:', error));\n</code></pre> <p>XMLHttpRequest</p> Basic Usage <pre><code>var xhr = new XMLHttpRequest();\nxhr.open('GET', 'https://api.example.com/data', true);\nxhr.onload = function () {\n    if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) {\n        console.log(JSON.parse(xhr.responseText));\n    } else {\n        console.error('Request failed with status:', xhr.status);\n    }\n};\nxhr.onerror = function () {\n    console.error('Request error');\n};\nxhr.send();\n</code></pre> </li> <li> <p>Use Libraries</p> <p>Axios</p> <ul> <li>Installation: <code>npm install axios</code></li> </ul> Basic UsageAdvanced Usage <pre><code>axios.get('https://api.example.com/data')\n    .then(response =&gt; console.log(response.data))\n    .catch(error =&gt; console.error('Axios error:', error));\n</code></pre> <pre><code>axios.post('https://api.example.com/data', { key: 'value' }, {\n    headers: {\n        'Content-Type': 'application/json',\n        'Authorization': 'Bearer token'\n    }\n})\n.then(response =&gt; console.log(response.data))\n.catch(error =&gt; console.error('Axios error:', error));\n</code></pre> <p>jQuery AJAX</p> <ul> <li>Installation: Include jQuery via CDN or npm install jquery</li> </ul> Basic Usage <pre><code>$.ajax({\n    url: 'https://api.example.com/data',\n    method: 'GET',\n    success: function(data) {\n        console.log(data);\n    },\n    error: function(xhr, status, error) {\n        console.error('AJAX error:', error);\n    }\n});\n</code></pre> </li> <li> <p>Master Error Handling and Asynchronous Operations</p> <ul> <li>Handle Errors: Learn how to handle network errors, server errors, and handle cases when the response is not as expected.</li> <li> <p>Async/Await: Use async/await syntax for better readability and error handling in asynchronous code.</p> <pre><code>async function fetchData() {\n    try {\n        const response = await fetch('https://api.example.com/data');\n        if (!response.ok) {\n            throw new Error('Network response was not ok');\n        }\n        const data = await response.json();\n        console.log(data);\n    } catch (error) {\n        console.error('Fetch error:', error);\n    }\n}\n\nfetchData();\n</code></pre> </li> </ul> </li> <li> <p>Practice and Experiment</p> <ul> <li>Build Projects: Create small projects or features that require making HTTP requests.</li> <li>Explore APIs: Work with different public APIs to understand how to handle various types of data and responses.</li> </ul> </li> </ol> <p>By mastering these concepts and practices, you'll become proficient in making and handling HTTP requests in JavaScript.</p>"},{"location":"js/httprequest/http/http-response/","title":"HTTP Reponse","text":""},{"location":"js/httprequest/http/http-response/#1-http-response-overview","title":"1. HTTP Response Overview","text":"<p>An HTTP response is essentially a message sent by a server in response to a client request. It contains:</p> <ul> <li>Status Line: Includes the status code and status text.</li> <li>Headers: Metadata about the response.</li> <li>Body: The main content of the response (which could be in various formats such as <code>text</code>, <code>JSON</code>, <code>HTML</code>, <code>XML</code>, etc.).</li> </ul>"},{"location":"js/httprequest/http/http-response/#2-representation-across-different-platforms","title":"2. Representation Across Different Platforms","text":"<p>While the structure of an HTTP response is consistent (status line, headers, body), its representation can differ based on the programming language, library, or environment. Here\u2019s how it varies:</p> <p>JavaScript (Fetch API):</p> <ul> <li>Response Object: Represents the HTTP response and includes properties like status, headers, and methods like <code>json()</code>, <code>text()</code>, <code>blob()</code>.</li> <li>Data Types: The body can be read as text, JSON, or other formats depending on the method used (<code>response.json()</code>, <code>response.text()</code>, etc.).</li> </ul> <p>Python (Requests Library):</p> <ul> <li>Response Object: Contains attributes such as <code>status_code</code>, <code>headers</code>, and methods like <code>text</code> and <code>json()</code>.</li> <li>Data Types: The body can be accessed as text or parsed as JSON using <code>response.json()</code>.</li> </ul> <p>Node.js (Node-Fetch):</p> <ul> <li>Response Object: Similar to the Fetch API, with properties like status and methods like <code>json()</code>, <code>text()</code>.</li> <li>Data Types: The body can be read and parsed into various formats depending on the method used.</li> </ul> <p>Java (HttpClient):</p> <ul> <li>HttpResponse Object: Includes methods like <code>statusCode()</code>, <code>headers()</code>, and <code>body()</code>.</li> <li>Data Types: The body is accessed through <code>HttpResponse.BodyHandlers</code> and can be processed as a string or other types.</li> </ul> <p>C# (.NET HttpClient):</p> <ul> <li>HttpResponseMessage Object: Includes properties like <code>StatusCode</code>, <code>Headers</code>, and <code>Content</code>.</li> <li>Data Types: The body is accessed through the <code>Content</code> property and can be read as a string, JSON, or other formats.</li> </ul>"},{"location":"js/httprequest/http/http-response/#3-underlying-data-types","title":"3. Underlying Data Types","text":"<p>Body Content: The actual data in the body of the HTTP response can be in various formats:</p> <ul> <li><code>Text</code>: Plain text, HTML.</li> <li><code>JSON</code>: JavaScript Object Notation.</li> <li><code>Binary</code>: Images, files (handled as blobs or array buffers).</li> <li><code>FormData</code>: Key-value pairs from forms.</li> </ul>"},{"location":"js/httprequest/http/http-response/#4-summary","title":"4. Summary","text":"<ul> <li> <p>Response Representation: While the HTTP response concept is universal, its representation varies by platform or library. Each platform provides its own way to access and manipulate the response data.</p> </li> <li> <p>Data Type Consistency: The body of the response is not strictly a single data type; it can be text, JSON, binary data, etc. The platform or library you use will determine how you interact with and convert this data.</p> </li> <li> <p>Understanding the Platform: To effectively work with HTTP responses, you need to understand the specifics of the response object in the context of the platform or library you're using. This involves knowing how to access the status, headers, and body of the response, and how to handle the body in the appropriate format.</p> </li> </ul> <p>In summary, while the fundamental concept of an HTTP response is consistent across platforms, the way it is represented and the data types used can vary. The key is to understand how to work with the response object provided by the specific environment you're working in.</p>"},{"location":"js/iterables/intro/","title":"Intro","text":"<p>JavaScript iterators can seem tricky at first, but once you break them down, they are quite simple! Let\u2019s walk through the concept to make it clearer.</p>"},{"location":"js/iterables/intro/#what-is-an-iterator","title":"What is an Iterator?","text":"<p>In JavaScript, an iterator is an object that allows you to traverse or \"iterate\" over a collection, like an array or object, one element at a time.</p>"},{"location":"js/iterables/intro/#key-concepts","title":"Key Concepts:","text":"<ol> <li> <p>Iterator:</p> <pre><code>- An iterator is an object that has a `next()` method.\n- The `next()` method returns an object with two properties:\n\n    - value: the current value being iterated over.\n    - done: a boolean that indicates if the iteration has finished.\n</code></pre> </li> <li> <p>Iterable:</p> <ul> <li>An iterable is any object that can return an iterator. Arrays, Strings, Maps, Sets, and even custom objects can be made iterable.   These objects implement the iterable protocol, meaning they have a <code>[Symbol.iterator]()</code> method that returns an iterator.</li> </ul> </li> </ol>"},{"location":"js/iterables/intro/#example-iterating-over-an-array","title":"Example: Iterating Over an Array","text":"<p>Let's look at a basic example of iterating over an array using an iterator.</p> ExampleExplanation <pre><code>const numbers = [1, 2, 3];\n\n// Get the iterator from the array\nconst iterator = numbers[Symbol.iterator]();\n\n// Use the iterator to go through the array\nconsole.log(iterator.next()); // { value: 1, done: false }\nconsole.log(iterator.next()); // { value: 2, done: false }\nconsole.log(iterator.next()); // { value: 3, done: false }\nconsole.log(iterator.next()); // { value: undefined, done: true }\n</code></pre> <ul> <li>We get the iterator by calling <code>numbers[Symbol.iterator]()</code>.</li> <li>We call <code>next()</code> on the iterator to get the next value in the array.</li> <li>The first time we call <code>next()</code>, we get <code>{ value: 1, done: false }</code>, indicating that the value is <code>1</code> and the iteration is not done yet.</li> <li>When <code>next()</code> is called after reaching the end of the array, we get <code>{ value: undefined, done: true }</code>, which indicates the end of the collection.</li> </ul>"},{"location":"js/iterables/intro/#using-iterators-with-forof-loop","title":"Using Iterators with <code>for...of</code> Loop","text":"<p>JavaScript provides the <code>for...of</code> loop, which automatically uses the iterator under the hood.</p> <pre><code>const numbers = [1, 2, 3];\n\nfor (let number of numbers) {\n  console.log(number); // 1, 2, 3\n}\n</code></pre> <p>In this example, you don't need to explicitly call the iterator. The <code>for...of</code> loop does it for you and stops once it reaches the end of the collection.</p>"},{"location":"js/iterables/intro/#custom-iterators-for-objects","title":"Custom Iterators for objects","text":"<p>You can also create your own custom iterators for objects. Here\u2019s how:</p> <pre><code>const myObject = {\n  values: [10, 20, 30],\n\n  // Make the object iterable\n  [Symbol.iterator]() {\n    let index = 0;\n    const values = this.values;\n\n    return {\n      next() {\n        if (index &lt; values.length) {\n          return { value: values[index++], done: false };\n        } else {\n          return { value: undefined, done: true };\n        }\n      },\n    };\n  },\n};\n\nfor (let value of myObject) {\n  console.log(value); // 10, 20, 30\n}\n</code></pre> <p>In this case, the <code>myObject</code> has a <code>[Symbol.iterator]()</code> method that returns an iterator for the <code>values</code> array. The <code>next()</code> method is used to iterate through the array, just like the built-in array iterator.</p>"},{"location":"js/iterables/intro/#summary","title":"Summary","text":"<ul> <li>Iterator is an object that allows sequential access to items in a collection.</li> <li>Iterable is an object that implements the iterable protocol (like arrays).</li> </ul> <p>The iterator's <code>next()</code> method returns an object with <code>value</code> (the current element) and <code>done</code> (whether the iteration is complete). You can use the <code>for...of</code> loop to iterate over collections without manually calling <code>next()</code>.</p> <pre><code>// const array = [1, 2, 3, 2, 4, 5, 5]\n\nconst array = [\"apple\", \"banana\", \"mango\", \"pineapple\", \"mango\"];\n\nlet empty = [];\n\nfor (let i = 0; i &lt; array.length; i++) {\n  if (!empty.includes(array[i])) {\n    empty.push(array[i]);\n    console.log(\"EMPTY:\", empty, empty === empty);\n  } else {\n    console.log(\"ALREADY THERE: \", array[i]);\n  }\n}\n\nconst num = [1, 6, 9, 1];\nconst uniqueValue = new Set(array);\nconsole.log(uniqueValue);\nconsole.log([...uniqueValue]);\n</code></pre>"},{"location":"js/iterables/types/","title":"Types","text":""},{"location":"js/iterables/types/#object-are-not-iterable","title":"Object are not iterable","text":"<p>In JavaScript, by default, plain objects are not iterable. That means you can't directly use a <code>for...of</code> loop on a regular object like you can with <code>arrays</code>, <code>strings</code>, <code>maps</code>, or <code>sets</code>.</p> <p>However, you can make an object iterable by defining a custom iterator using the Symbol.iterator method.</p>"},{"location":"js/iterables/types/#why-is-an-object-not-iterable-by-default","title":"Why is an Object Not Iterable by Default?","text":"<p>Objects do not implement the iterable protocol (which requires a <code>[Symbol.iterator]()</code> method). As a result, trying to use a <code>for...of</code> loop directly on an object will result in an error.</p> <pre><code>const obj = { a: 1, b: 2, c: 3 };\n\n// This will throw an error because objects are not iterable by default\nfor (let value of obj) {\n  console.log(value); // Error: obj is not iterable\n}\n</code></pre>"},{"location":"js/iterables/types/#making-an-object-iterable","title":"Making an Object Iterable","text":"<p>If you want to make an object iterable, you can define the <code>[Symbol.iterator]()</code> method on the object. This allows the object to work with <code>for...of</code> loops.</p> <p>Here's an example of how to make an object iterable by defining a custom iterator:</p> Example <pre><code>const obj = {\n  a: 1,\n  b: 2,\n  c: 3,\n\n  // Custom iterator to make the object iterable\n  [Symbol.iterator]() {\n    const entries = Object.entries(this); // Convert object to array of [key, value] pairs\n    let index = 0;\n\n    return {\n      next() {\n        if (index &lt; entries.length) {\n          return { value: entries[index++], done: false }; // Return key-value pair\n        } else {\n          return { done: true }; // Indicate that iteration is complete\n        }\n      },\n    };\n  },\n};\n\n// Now you can iterate over the object\nfor (let [key, value] of obj) {\n  console.log(`${key}: ${value}`);\n}\n// Output:\n// a: 1\n// b: 2\n// c: 3\n</code></pre> Explanation <ul> <li><code>Object.entries(this)</code>: Converts the object's key-value pairs into an array of arrays (e.g., <code>[['a', 1], ['b', 2], ['c', 3]]</code>).</li> <li><code>Symbol.iterator</code>: Defines the custom iterator on the object.</li> <li><code>next()</code>: This method returns the next key-value pair until the object has been fully traversed.</li> </ul> Summary <ul> <li>Plain objects are not iterable by default in JavaScript.</li> <li>You can make an object iterable by implementing the <code>[Symbol.iterator]()</code> method.</li> <li>Once an object is iterable, you can use a <code>for...of</code> loop to iterate over it.</li> </ul>"},{"location":"js/iterables/types/#how-to-iterate-over-an-object","title":"How to Iterate Over an Object","text":"<p>To iterate over a regular JavaScript object (which is not iterable by default), you can use the following approaches:</p> <ol> <li>Using <code>for...in</code> Loop</li> </ol> <p>The <code>for...in</code> loop is specifically designed to iterate over the keys of an object. It will loop through all the enumerable properties of the object (including those that are part of the object's prototype chain, unless you filter them out with <code>hasOwnProperty</code>).</p> <pre><code>const obj = { a: 1, b: 2, c: 3 };\n\nfor (let key in obj) {\n  if (obj.hasOwnProperty(key)) {\n    // This ensures we are only iterating over the object's own properties\n    console.log(key, obj[key]); // Outputs the key and corresponding value\n  }\n}\n// Output:\n// a 1\n// b 2\n// c 3\n</code></pre> <ol> <li>Using <code>Object.keys()</code>, <code>Object.values()</code>, or <code>Object.entries()</code></li> </ol> <p>You can convert the object into an array and then iterate over it using a <code>for...of</code> loop or methods like <code>forEach()</code>.</p> <ul> <li><code>Object.keys()</code>: Returns an array of the object's keys.</li> <li><code>Object.values()</code>: Returns an array of the object's values.</li> <li><code>Object.entries()</code>: Returns an array of the object's key-value pairs.</li> </ul> <pre><code>const obj = { a: 1, b: 2, c: 3 };\n\n// Using Object.keys() to iterate over the keys\nObject.keys(obj).forEach((key) =&gt; {\n  console.log(key, obj[key]);\n});\n// Output:\n// a 1\n// b 2\n// c 3\n\n// Using Object.values() to iterate over the values\nObject.values(obj).forEach((value) =&gt; {\n  console.log(value);\n});\n// Output:\n// 1\n// 2\n// 3\n\n// Using Object.entries() to iterate over the key-value pairs\nObject.entries(obj).forEach(([key, value]) =&gt; {\n  console.log(key, value);\n});\n// Output:\n// a 1\n// b 2\n// c 3\n</code></pre>"},{"location":"js/iterables/types/#how-to-know-which-types-are-iterable","title":"How to Know Which Types Are Iterable","text":"<p>The following types are iterable in JavaScript, meaning you can use the <code>for...of</code> loop on them (or use their iterators):</p> <ol> <li>Arrays: Arrays are iterable by default.</li> <li>Strings: Strings are iterable by default (you can loop over each character).</li> <li>Maps: Maps are iterable by default and iterate over key-value pairs.</li> <li>Sets: Sets are iterable by default and iterate over unique values.</li> <li>Typed Arrays (like <code>Uint8Array</code>, <code>Float32Array</code>, etc.) are iterable.</li> <li>Generators: Generator functions return iterable objects.</li> <li>Custom Iterable Objects: Any object that implements the <code>[Symbol.iterator]()</code> method is iterable.</li> </ol> <p>You can check if an object is iterable using the following approach:</p>"},{"location":"js/iterables/types/#check-if-an-object-is-iterable","title":"Check if an Object is Iterable","text":"<p>To check if a given object is iterable, you can check if it has the <code>[Symbol.iterator]()</code> method:</p> <pre><code>function isIterable(obj) {\n  return obj != null &amp;&amp; typeof obj[Symbol.iterator] === \"function\";\n}\n\nconsole.log(isIterable([1, 2, 3])); // true (Array is iterable)\nconsole.log(isIterable(\"hello\")); // true (String is iterable)\nconsole.log(isIterable(new Map())); // true (Map is iterable)\nconsole.log(isIterable({ a: 1 })); // false (Object is not iterable by default)\nconsole.log(isIterable(null)); // false (null is not iterable)\n</code></pre> Summary of Iterable Types <ul> <li>Iterable types include: Arrays, Strings, Maps, Sets, Typed Arrays, and anything with a <code>[Symbol.iterator]</code> method.</li> <li>Non-iterable types include: Plain Objects, <code>null</code>, <code>undefined</code>, and most other objects unless they implement <code>[Symbol.iterator]</code>.</li> </ul>"},{"location":"js/iterables/types/#how-to-make-non-iterable-objects-iterable","title":"How to Make Non-Iterable Objects Iterable","text":"<p>If you want to make your own custom object iterable (like the <code>obj</code> in the example), you need to implement the <code>[Symbol.iterator]()</code> method, which returns an iterator that defines how to traverse the object.</p> Example of Making a Custom Object Iterable<pre><code>const customObject = {\n  a: 1,\n  b: 2,\n  c: 3,\n\n  [Symbol.iterator]() {\n    const entries = Object.entries(this); // Convert object to array of key-value pairs\n    let index = 0;\n\n    return {\n      next() {\n        if (index &lt; entries.length) {\n          return { value: entries[index++], done: false };\n        } else {\n          return { done: true };\n        }\n      },\n    };\n  },\n};\n\nfor (let [key, value] of customObject) {\n  console.log(key, value);\n}\n// Output:\n// a 1\n// b 2\n// c 3\n</code></pre> <p>In this example, we added the <code>[Symbol.iterator]()</code> method to <code>customObject</code>, allowing it to be iterated with a <code>for...of</code> loop.</p> Summary of Key Points <ul> <li>Objects are not iterable by default, but you can iterate over their keys, values, or entries using methods like <code>Object.keys()</code>, <code>Object.values()</code>, and <code>Object.entries()</code>.</li> <li>Iterable types in JavaScript include arrays, strings, maps, sets, and custom objects that implement <code>[Symbol.iterator]</code>.</li> <li>Non-iterable types include plain objects (unless modified to implement the iterable protocol).</li> </ul>"},{"location":"js/iterables/types/#reference","title":"Reference","text":"<ul> <li>Iterables in JS</li> </ul>"},{"location":"js/json/intro/","title":"Intro","text":"<p>JSON or JavaScript Object Notation is a very popular data interchange format. It was developed by Douglas Crockford. JSON is text-based, lightweight, and a human-readable format for data exchange between clients and servers. JSON is derived from JavaScript and bears a close resemblance to JavaScript objects, but it is not dependent on JavaScript. JSON is language-independent, and support for the JSON data format is available in all the popular languages, some of which are C#, PHP, Java, C++, Python, and Ruby.</p> <p>JSON is a format and not a language.</p> <p>JSON can be used in web applications for data transfer. Prior to JSON, XML was considered to be the chosen data interchange format. </p>"},{"location":"js/json/intro/#datatypes-in-json","title":"Datatypes in JSON","text":"<p>Tip</p> <p>JSON supports six datatypes: </p> <ol> <li>strings, </li> <li>numbers, </li> <li>Booleans, </li> <li>arrays, </li> <li>objects, &amp; </li> <li>null.</li> </ol> <ul> <li>JavaScript and JSON Essentials by Sai Srinivas Sriparasa: 2013 Packt Publishing</li> </ul>"},{"location":"js/json/json5/","title":"Json and .Json5","text":"<p>The main difference between <code>.json</code> and <code>.json5</code> lies in their syntax and flexibility:</p> <ol> <li> <p>JSON (<code>.json</code>):</p> <ul> <li>Stands for JavaScript Object Notation.</li> <li>It is a strict, lightweight data-interchange format.</li> <li>Syntax rules are rigid, requiring:<ul> <li>Double quotes around property names.</li> <li>No trailing commas.</li> <li>No comments allowed.</li> <li>Only strings, numbers, arrays, booleans, null, and objects are valid.</li> </ul> </li> </ul> <pre><code>{\n    \"name\": \"John\",\n    \"age\": 30,\n    \"isStudent\": false\n}\n</code></pre> </li> <li> <p>JSON5 (<code>.json5</code>):</p> <ul> <li>Stands for JSON for Humans, an extension of JSON.</li> <li>It is more flexible and user-friendly, allowing:<ul> <li>Single quotes for strings.</li> <li>Trailing commas.</li> <li>Unquoted property names if valid identifiers.</li> <li>Comments (both single-line <code>//</code> and multi-line <code>/* */</code>).</li> <li>Support for additional data types like <code>Infinity</code>, <code>NaN</code>, and hexadecimal numbers.</li> </ul> </li> </ul> <pre><code>{\n    name: 'John',  // Unquoted property names, single quotes\n    age: 30,       // Trailing commas allowed\n    isStudent: false,  // Comments allowed\n}\n</code></pre> </li> </ol> <p>In summary, JSON5 relaxes some of the strict rules of JSON, making it more human-friendly for editing, while <code>.json</code> is more standardized and widely supported.</p>"},{"location":"js/json/json5/#json-interesting-topic","title":"JSON interesting topic","text":"<p>Here are some interesting aspects of JSON and how you can maximize its usage:</p> <ol> <li> <p>JSON Schema Validation</p> <ul> <li>What it is: JSON Schema is a powerful tool for validating the structure of JSON data.</li> <li>Why it's interesting: It ensures that your JSON data conforms to a specific format, making it easier to validate inputs and outputs in APIs.</li> <li>How to use it: You can define a schema and use libraries like <code>Ajv</code> (in JavaScript) to validate your data.</li> </ul> <pre><code>{\n    \"type\": \"object\",\n    \"properties\": {\n        \"name\": { \"type\": \"string\" },\n        \"age\": { \"type\": \"integer\" }\n    },\n    \"required\": [\"name\", \"age\"]\n}\n</code></pre> </li> <li> <p>JSON Web Tokens (JWT)</p> <ul> <li>What it is: JWT is a compact, URL-safe means of representing claims to be transferred between two parties.</li> <li>Why it's interesting: JWTs are widely used for authentication and authorization in web applications.</li> <li>How to use it: You can encode and decode JWTs using libraries like <code>jsonwebtoken</code> in Node.js, sending tokens in HTTP headers to secure APIs.</li> </ul> <pre><code>{\n    \"alg\": \"HS256\",\n    \"typ\": \"JWT\"\n}\n{\n    \"sub\": \"1234567890\",\n    \"name\": \"John Doe\",\n    \"iat\": 1516239022\n}\n</code></pre> </li> <li> <p>JSON with Local Storage</p> <ul> <li>What it is: Storing data in a browser's localStorage or sessionStorage.</li> <li>Why it's interesting: You can persist JSON data locally, making it useful for offline applications or user preferences.</li> <li> <p>How to use it:</p> <pre><code>// Storing\nconst user = { name: \"John\", age: 30 };\nlocalStorage.setItem('user', JSON.stringify(user));\n\n// Retrieving\nconst storedUser = JSON.parse(localStorage.getItem('user'));\n</code></pre> </li> </ul> </li> <li> <p>JSON with IndexedDB</p> <ul> <li>What it is: A client-side database that stores complex data (like JSON objects).</li> <li>Why it's interesting: IndexedDB allows you to store and retrieve large amounts of structured data, which is more powerful than localStorage.</li> <li>How to use it: You can store complex data like objects and arrays natively.</li> </ul> <pre><code>const dbRequest = indexedDB.open(\"MyDatabase\");\ndbRequest.onsuccess = function(event) {\n    const db = event.target.result;\n    const transaction = db.transaction(\"myStore\", \"readwrite\");\n    const store = transaction.objectStore(\"myStore\");\n    store.add({ id: 1, name: \"John\", age: 30 });\n};\n</code></pre> </li> <li> <p>JSON Patch (RFC 6902)</p> <ul> <li>What it is: JSON Patch is a format for expressing a list of operations to apply to a JSON document.</li> <li>Why it's interesting: It\u2019s used for efficient partial updates, especially in scenarios where you only want to update specific fields.</li> <li>How to use it: Using libraries like <code>fast-json-patch</code> in JavaScript to apply patches.</li> </ul> <pre><code>[\n    { \"op\": \"replace\", \"path\": \"/name\", \"value\": \"Jane\" },\n    { \"op\": \"remove\", \"path\": \"/age\" }\n]\n</code></pre> </li> <li> <p>JSON Streaming</p> <ul> <li>What it is: JSON Streaming allows large JSON datasets to be processed in chunks rather than loading the entire document at once.</li> <li>Why it's interesting: It's useful for handling big data without crashing the browser or server due to memory overload.</li> <li>How to use it: Tools like <code>stream-json</code> in Node.js can parse large JSON datasets in chunks.</li> </ul> <pre><code>const { parser } = require('stream-json');\nconst fs = require('fs');\nfs.createReadStream('large-file.json').pipe(parser()).on('data', (chunk) =&gt; {\n    console.log(chunk);\n});\n</code></pre> </li> <li> <p>JSON with GraphQL</p> <ul> <li>What it is: JSON is the default format for sending and receiving data in GraphQL APIs.</li> <li>Why it's interesting: GraphQL APIs allow clients to request specific data in JSON format, reducing over-fetching common in REST APIs.</li> <li>How to use it: You define queries in GraphQL, and responses are returned as JSON.</li> </ul> <pre><code>query {\n    user(id: 1) {\n        name\n        age\n    }\n}\n</code></pre> JSON Response:<pre><code>{\n    \"data\": {\n        \"user\": {\n        \"name\": \"John\",\n        \"age\": 30\n        }\n    }\n}\n</code></pre> </li> <li> <p>JSONPath for Querying JSON</p> <ul> <li>What it is: JSONPath is a query language for extracting values from JSON documents (similar to XPath for XML).</li> <li>Why it's interesting: JSONPath allows for complex querying of deeply nested JSON objects.</li> <li>How to use it: Using libraries like <code>jsonpath</code> in JavaScript.</li> </ul> <pre><code>{\n    \"store\": {\n        \"book\": [\n            { \"category\": \"fiction\", \"title\": \"The Great Gatsby\" },\n            { \"category\": \"drama\", \"title\": \"Hamlet\" }\n        ]\n    }\n}\n</code></pre> Query:<pre><code>jsonpath.query(data, '$.store.book[?(@.category==\"fiction\")]');\n</code></pre> </li> <li> <p>JSON Serialization and Deserialization</p> <ul> <li>What it is: Converting objects to JSON format (serialization) and parsing JSON back into objects (deserialization).</li> <li>Why it's interesting: Most web APIs rely on this mechanism for data interchange.</li> <li> <p>How to use it:</p> <pre><code>const obj = { name: \"John\", age: 30 };\nconst jsonStr = JSON.stringify(obj);  // Serialize\nconst parsedObj = JSON.parse(jsonStr);  // Deserialize\n</code></pre> </li> </ul> </li> <li> <p>JSON Transformations with Lodash</p> <ul> <li>What it is: Using utility libraries like Lodash to manipulate JSON objects efficiently.</li> <li>Why it's interesting: Lodash offers powerful tools for querying, filtering, and transforming JSON data.</li> <li> <p>How to use it:</p> <pre><code>const data = [{ name: 'John', age: 30 }, { name: 'Jane', age: 25 }];\nconst adults = _.filter(data, user =&gt; user.age &gt;= 18);\n</code></pre> </li> </ul> </li> <li> <p>JSON for Configuration Files</p> <ul> <li>What it is: JSON is often used as a format for configuration files, especially in web development (<code>package.json</code>, <code>.babelrc</code>).</li> <li>Why it's interesting: Storing settings and configurations in JSON is easy to read, write, and manipulate programmatically.</li> <li>How to use it: You can use JSON in Node.js or other backends to dynamically load and parse configuration settings.</li> </ul> </li> <li> <p>JSON with REST APIs</p> <ul> <li>What it is: JSON is the most common data format used for sending and receiving data via REST APIs.</li> <li>Why it's interesting: Knowing how to effectively work with JSON in REST APIs ensures you build scalable, maintainable systems.</li> <li> <p>How to use it:  </p> <pre><code>fetch('https://api.example.com/data')\n.then(response =&gt; response.json())\n.then(data =&gt; console.log(data));\n</code></pre> </li> </ul> </li> </ol> <p>By learning these techniques, you can leverage the full potential of JSON in various real-world applications, from API development to efficient data management and beyond.</p>"},{"location":"js/json/json5/#js-topic","title":"JS Topic","text":"<p>Here are some interesting topics you might want to explore as you continue deepening your knowledge, especially considering your focus on becoming a top-tier developer:</p> <ol> <li> <p>Advanced JavaScript Concepts</p> <ul> <li>Closures and Currying: Understanding these will help you write more efficient and readable code.</li> <li>Event Loop and Async/Await: Mastering how JavaScript handles asynchronous operations can enhance performance in complex applications.</li> <li>Prototypes and Inheritance: Dig deeper into object-oriented principles in JavaScript.</li> <li>Functional Programming: Concepts like immutability, pure functions, and higher-order functions can transform how you approach problems.</li> </ul> </li> <li> <p>React Ecosystem</p> <ul> <li>React Performance Optimization: Learn techniques such as memoization (useMemo, useCallback), lazy loading, and code splitting.</li> <li>React Hooks: Mastering custom hooks and using built-in hooks like useReducer for complex state management.</li> <li>React Suspense and Concurrent Mode: These will shape the future of React apps, enabling better UX with async data fetching.</li> <li>Server-Side Rendering (SSR) with Next.js: Explore Next.js for building SEO-friendly React apps.</li> </ul> </li> <li> <p>State Management (Advanced Redux)</p> <ul> <li>Redux Toolkit: Learn the modern way to manage state with Redux's streamlined syntax and enhanced development experience.</li> <li>Context API: It\u2019s lightweight compared to Redux but excellent for certain types of global state management.</li> <li>Middleware in Redux: Thunk, Saga, and custom middleware for managing side effects.</li> </ul> </li> <li> <p>TypeScript</p> <ul> <li>Type Inference &amp; Generics: Learn how to leverage TypeScript's static typing for cleaner, more maintainable code.</li> <li>TypeScript in React and Node.js: Understanding how to use TypeScript in both frontend and backend can be a game changer.</li> </ul> </li> <li> <p>Advanced APIs &amp; Web Technologies</p> <ul> <li>GraphQL: A flexible, efficient alternative to REST APIs. Learn about querying and mutations with GraphQL.</li> <li>WebSockets: Real-time communication for applications like chats, notifications, or live updates.</li> <li>Service Workers: Understanding how to implement Progressive Web Apps (PWAs) with offline capabilities.</li> </ul> </li> <li> <p>Full-Stack Development</p> <ul> <li>Django with React/Next.js: Explore integrating frontend frameworks with powerful backends like Django.</li> <li>Microservices Architecture: Learn how to split large applications into smaller, independent services for scalability and maintainability.</li> <li>API Design Principles: RESTful APIs, versioning, and security considerations like JWT (JSON Web Token).</li> </ul> </li> <li> <p>Databases and Data Management</p> <ul> <li>NoSQL vs. SQL: Learn the differences and when to use MongoDB vs PostgreSQL/MySQL.</li> <li>Database Indexing and Optimization: Mastering these techniques will enhance database performance.</li> <li>Graph Databases: Explore databases like Neo4j for relationship-heavy data (e.g., for your dating app).</li> </ul> </li> <li> <p>Advanced DevOps and CI/CD</p> <ul> <li>Containerization with Docker: Packaging applications into containers for easier deployment.</li> <li>Kubernetes: Managing containerized applications at scale using Kubernetes clusters.</li> <li>CI/CD Pipelines: Automate testing, integration, and deployment with tools like GitLab CI, Jenkins, or GitHub Actions.</li> </ul> </li> <li> <p>Cloud and Serverless Computing</p> <ul> <li>AWS, Google Cloud, or Azure: Master cloud platforms to deploy, manage, and scale applications.</li> <li>Serverless Functions (AWS Lambda, Firebase Functions): Writing and deploying code without managing servers.</li> <li>Cloud Databases and Storage: Using cloud services for data persistence and management.</li> </ul> </li> <li> <p>Software Architecture &amp; Design Patterns</p> <ul> <li>SOLID Principles: These principles will help in writing scalable and maintainable code.</li> <li>Design Patterns: Explore patterns like Singleton, Factory, Observer, etc.</li> <li>Monolithic vs Microservices: Understand when to use each approach.</li> </ul> </li> <li> <p>Security Best Practices</p> <ul> <li>OWASP Top 10: Understanding the most common security vulnerabilities in web applications.</li> <li>Encryption and Authentication: JWT, OAuth2, and bcrypt for hashing passwords.</li> <li>Security in APIs: Preventing XSS, CSRF, and implementing secure HTTP headers.</li> </ul> </li> <li> <p>Mobile App Development</p> <ul> <li>React Native: Since you are already working on a dating app, mastering React Native will help build cross-platform mobile applications.</li> <li>Mobile Optimization: Techniques for performance and UX improvements on mobile devices.</li> <li>Firebase or Traditional Database for Mobile: Integrating real-time databases and authentication in mobile apps.</li> </ul> </li> <li> <p>Machine Learning Basics for Web Developers</p> <ul> <li>TensorFlow.js: Learn how to run machine learning models in the browser.</li> <li>Basic Data Science Concepts: Learn about linear regression, decision trees, and clustering algorithms.</li> <li>Recommendation Systems: Especially useful for personalized applications like a dating app.</li> </ul> </li> <li> <p>GraphQL with Apollo Client</p> <ul> <li>Advanced Querying: Learn about fragments, inline arguments, and directives.</li> <li>Cache Management: Understanding Apollo Client's caching strategies.</li> </ul> </li> <li> <p>Testing and Quality Assurance</p> <ul> <li>Unit, Integration, and E2E Testing: Master tools like Jest, Mocha, Cypress, and React Testing Library.</li> <li>TDD and BDD: Learn Test-Driven Development and Behavior-Driven Development to write better, bug-free code.</li> </ul> </li> <li> <p>Code Management and Collaboration</p> <ul> <li>Git Workflows: Learn about different Git workflows like GitFlow, feature branching, and rebasing.</li> <li>Monorepos: How large companies use tools like Lerna and Nx to manage multiple projects in a single repository.</li> </ul> </li> </ol> <p>These topics can significantly boost your understanding and skillset across modern development paradigms. You can explore them based on your interests and project needs!</p> what is difference between conntecting mysql and postgress. in ubuntu in need to install to connect django with mysql what i need to do in postgress <p>When setting up Django with MySQL versus PostgreSQL on Ubuntu, the installation and configuration processes differ slightly due to the differences in the database systems.</p> <p>Here\u2019s a breakdown of what you need to do for each:</p>"},{"location":"js/json/json5/#connecting-django-to-mysql","title":"Connecting Django to MySQL","text":"<ol> <li> <p>Install MySQL Server:</p> <ul> <li> <p>Open a terminal and install MySQL server with the following command:</p> <pre><code>sudo apt update\nsudo apt install mysql-server\n</code></pre> </li> </ul> </li> <li> <p>Install MySQL Client Libraries:</p> <ul> <li> <p>You need the MySQL client libraries to interface with MySQL from Python. Install them with:</p> <pre><code>sudo apt install libmysqlclient-dev\n</code></pre> </li> </ul> </li> <li> <p>Install Django MySQL Adapter:</p> <ul> <li> <p>You need the <code>mysqlclient</code> package for Django to connect to MySQL. Install it using pip:</p> <pre><code>pip install mysqlclient\n</code></pre> </li> </ul> </li> <li> <p>Configure Django Settings:</p> <ul> <li> <p>In your <code>settings.py</code>, configure the database settings for <code>MySQL</code>:</p> <pre><code>    DATABASES = {\n        'default': {\n            'ENGINE': 'django.db.backends.mysql',\n            'NAME': 'your_database_name',\n            'USER': 'your_username',\n            'PASSWORD': 'your_password',\n            'HOST': 'localhost',\n            'PORT': '3306',\n        }\n    }\n</code></pre> </li> </ul> </li> </ol> <p>Summary</p> <ul> <li>MySQL: You need to install <code>mysql-server</code>, <code>libmysqlclient-dev</code>, and <code>mysqlclient</code>.</li> </ul> <p>In both cases, after setting up the database server and installing the required Python packages, you'll configure your <code>settings.py</code> file in Django to connect to the database you have chosen.</p>"},{"location":"js/math/overview/","title":"Overview","text":""},{"location":"js/math/overview/#overview","title":"Overview","text":"<p>The Math Object</p> <p>Unlike other objects, the Math object has no constructor.</p> <p>The Math object is static.</p> <p>All methods and properties can be used without creating a Math object first.</p>"},{"location":"js/math/overview/#reference","title":"Reference","text":"<ul> <li>W3schools, Math</li> </ul>"},{"location":"js/miscellaneous/books/","title":"Books","text":""},{"location":"js/miscellaneous/cognitive-skills/","title":"Coginitive Skills","text":""},{"location":"js/miscellaneous/cognitive-skills/#overview","title":"Overview","text":"<p>Cognitive skills refer to the mental abilities used to acquire knowledge, think, understand, and solve problems. They play a critical role in learning and cognitive development. In the context of education, programming, and problem-solving (like in JavaScript or any other domain), cognitive skills can be categorized into different types based on the depth of thinking involved. The most widely recognized framework for cognitive skills comes from Bloom's Taxonomy, which classifies cognitive skills into different levels.</p> <p>Here are the key Cognitive Skill Types:</p>"},{"location":"js/miscellaneous/cognitive-skills/#1-remembering-knowledge-recall","title":"1. Remembering (Knowledge Recall)","text":"<p>This is the most basic cognitive skill, where you retrieve information from memory.</p> <ul> <li>Key Actions: Recalling facts, terms, basic concepts, definitions, or details.</li> <li>Questions: What is\u2026? Who was\u2026? When did\u2026? Define\u2026</li> </ul> <p>Example in Programming:</p> <ul> <li>What is the <code>map()</code> function in JavaScript?</li> <li>Define a JavaScript object.</li> </ul>"},{"location":"js/miscellaneous/cognitive-skills/#2-understanding-comprehension","title":"2. Understanding (Comprehension)","text":"<p>This skill involves grasping the meaning of information, interpreting data, or explaining concepts in your own words.</p> <ul> <li>Key Actions: Interpreting, summarizing, explaining, describing.</li> <li>Questions: How would you explain\u2026? What is the meaning of\u2026? Can you summarize\u2026?</li> </ul> <p>Example in Programming:</p> <ul> <li>Explain how the <code>filter()</code> method works in JavaScript.</li> <li>What happens when you call <code>addEventListener</code> in JavaScript?</li> </ul>"},{"location":"js/miscellaneous/cognitive-skills/#3-applying-application","title":"3. Applying (Application)","text":"<p>This involves using knowledge and understanding in a new or practical situation. You take what you've learned and apply it to solve problems or perform tasks.</p> <ul> <li>Key Actions: Using learned concepts in new situations, solving problems, demonstrating skills.</li> <li>Questions: How would you use\u2026? Can you apply the concept of\u2026?</li> </ul> <p>Example in Programming:</p> <ul> <li>Write a function to calculate the sum of all elements in an array.</li> <li>Use the <code>reduce()</code> method to find the average of an array.</li> </ul>"},{"location":"js/miscellaneous/cognitive-skills/#4-analyzing-analysis","title":"4. Analyzing (Analysis)","text":"<p>This is the ability to break down information into parts and understand its structure. It involves examining relationships, patterns, and organizing ideas or concepts.</p> <ul> <li>Key Actions: Comparing, contrasting, identifying patterns, organizing information.</li> <li>Questions: What is the difference between\u2026? How does X relate to Y? What are the components of\u2026?</li> </ul> <p>Example in Programming:</p> <ul> <li>What are the differences between <code>var</code>, <code>let</code>, and <code>const</code> in JavaScript?</li> <li>Analyze how a recursive function works compared to an iterative function.</li> </ul>"},{"location":"js/miscellaneous/cognitive-skills/#5-evaluating-evaluation","title":"5. Evaluating (Evaluation)","text":"<p>This involves making judgments about the value of ideas, solutions, or methods. It requires forming an opinion or decision based on criteria.</p> <ul> <li>Key Actions: Critiquing, judging, justifying, supporting, defending.</li> <li>Questions: Which solution is better? How would you defend\u2026? What would be the impact of\u2026?</li> </ul> <p>Example in Programming:</p> <ul> <li>Which sorting algorithm is more efficient for large datasets, and why?</li> <li>Evaluate the pros and cons of using Promises vs. async/await in JavaScript.</li> </ul>"},{"location":"js/miscellaneous/cognitive-skills/#6-creating-synthesis","title":"6. Creating (Synthesis)","text":"<p>This is the highest level of cognitive skills, where you combine elements to form a new whole. It involves innovation, constructing new solutions, or designing something original.</p> <ul> <li>Key Actions: Designing, constructing, inventing, synthesizing information to create new ideas.</li> <li>Questions: How could you design\u2026? What could you create if\u2026? How can you combine\u2026?</li> </ul> <p>Example in Programming:</p> <ul> <li>Design a RESTful API that allows users to perform CRUD operations on a database.</li> <li>Create a custom higher-order function in JavaScript that handles asynchronous actions in a more efficient way.</li> </ul>"},{"location":"js/miscellaneous/cognitive-skills/#summary-of-cognitive-skill-levels-in-blooms-taxonomy","title":"Summary of Cognitive Skill Levels in Bloom's Taxonomy:","text":"Cognitive Skill Type Description Action Words/Verbs 1. Remembering Recall facts, basic concepts, and definitions Recall, recognize, list, identify, describe 2. Understanding Grasp meaning, interpret, explain Explain, summarize, interpret, describe, discuss 3. Applying Use knowledge in new situations Use, solve, implement, demonstrate, apply 4. Analyzing Break down information, identify relationships Compare, contrast, analyze, categorize, examine 5. Evaluating Make judgments based on criteria Evaluate, justify, defend, critique, assess 6. Creating Combine elements to form new ideas or solutions Design, construct, develop, invent, create"},{"location":"js/miscellaneous/cognitive-skills/#other-cognitive-skills-in-problem-solving-beyond-blooms-taxonomy","title":"Other Cognitive Skills in Problem Solving (Beyond Bloom\u2019s Taxonomy):","text":"<p>Some additional cognitive skills include:</p> <ul> <li>Critical Thinking: This skill involves analyzing and evaluating information objectively, often to make decisions or form conclusions.</li> <li>Problem-Solving: The ability to identify solutions to a challenge or problem. In programming, this includes debugging, algorithm design, and troubleshooting.</li> <li>Logical Reasoning: Applying deductive or inductive reasoning to assess situations or problems.</li> <li>Metacognition: Awareness and control over one\u2019s own learning process. It involves self-monitoring and adjusting strategies to improve learning outcomes.</li> </ul>"},{"location":"js/miscellaneous/cognitive-skills/#application-to-programming-and-javascript","title":"Application to Programming and JavaScript:","text":"<p>In programming, cognitive skills are essential for writing efficient code, debugging, understanding new concepts, and creating innovative solutions. For example:</p> <ul> <li>Remembering: Recognizing syntax or recalling a standard function.</li> <li>Understanding: Explaining how a <code>forEach</code> loop works in JavaScript.</li> <li>Applying: Using a higher-order function like <code>map()</code> to manipulate data in an array.</li> <li>Analyzing: Breaking down complex code to find the root cause of a bug.</li> <li>Evaluating: Deciding which data structure (e.g., arrays vs. objects) is optimal for a given problem.</li> <li>Creating: Designing a full-stack web application, using JavaScript for both frontend and backend.</li> </ul> <p>Understanding these cognitive skills can help you deepen your learning, especially when tackling programming challenges or complex technical problems.</p>"},{"location":"js/miscellaneous/guard-clause/","title":"Guard Clause","text":""},{"location":"js/miscellaneous/guard-clause/#what-is-a-guard-clause","title":"\u2705 What is a Guard Clause?","text":"<p>A guard clause is a programming pattern where you return early from a function if a condition is met, instead of using nested <code>if</code> statements. It helps to keep code clean, avoid unnecessary nesting, and improve readability.</p>"},{"location":"js/miscellaneous/guard-clause/#why-is-it-called-a-guard-clause","title":"\ud83d\udee1\ufe0f Why is it Called a \"Guard Clause\"?","text":"<p>The term \"guard\" comes from the idea that these conditions \"guard\" the main logic of the function by stopping execution early if certain conditions aren't met. It acts like a gatekeeper, ensuring that only valid input passes through to the core logic.</p>"},{"location":"js/miscellaneous/guard-clause/#example-of-guard-clause","title":"\ud83d\udcd6 Example of Guard Clause:","text":"<p>Without Guard Clause (Nested <code>if</code> Statements):</p> <pre><code>function processOrder(order) {\n  if (order) {\n    if (!order.isCanceled) {\n      shipOrder(order);\n    }\n  }\n}\n</code></pre> <p>With Guard Clause (Cleaner and More Readable):</p> <pre><code>function processOrder(order) {\n  if (!order) return;\n  if (order.isCanceled) return;\n\n  shipOrder(order);\n}\n</code></pre>"},{"location":"js/miscellaneous/guard-clause/#when-to-use-a-guard-clause","title":"\u2705 When to Use a Guard Clause","text":"Use a guard clause when you want to: <ol> <li> <p>Avoid Nested Conditions</p> <p>Guard clauses prevent deeply nested <code>if</code> statements, making your code cleaner.</p> </li> <li> <p>Validate Input at the Start</p> <p>Validate input early and return immediately if it's invalid.</p> </li> <li> <p>Handle Edge Cases</p> <p>Deal with error cases upfront and keep the main logic focused.</p> </li> <li> <p>Shorten Function Logic</p> <p>Guard clauses help keep functions short and to the point by returning early.</p> </li> </ol>"},{"location":"js/miscellaneous/guard-clause/#example-in-react","title":"\ud83d\udcd6 Example in React:","text":"<pre><code>function UserProfile({ user }) {\n  if (!user) return &lt;p&gt;No user data&lt;/p&gt;;\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;{user.name}&lt;/h1&gt;\n      &lt;p&gt;{user.email}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre> <ul> <li>Why use a guard clause?</li> </ul> <p>It handles the edge case where <code>user</code> is null or undefined upfront, so the main component logic is not cluttered.</p>"},{"location":"js/miscellaneous/guard-clause/#when-not-to-use-a-guard-clause","title":"\u274c When Not to Use a Guard Clause","text":"Avoid guard clauses if: <ol> <li> <p>Conditions Are Mutually Exclusive</p> <p>If conditions are mutually exclusive, use <code>if-else</code> instead to avoid redundant checks.</p> </li> <li> <p>You Need a Single Return Point</p> <p>In some cases, having multiple <code>return</code> statements can make debugging harder. Use guard clauses carefully in complex functions.</p> </li> <li> <p>The Function Logic Is Simple</p> <p>If a function is very short and straightforward, a guard clause might be unnecessary.</p> </li> </ol>"},{"location":"js/miscellaneous/guard-clause/#example-when-not-to-use-a-guard-clause","title":"\ud83d\udcdd Example: When Not to Use a Guard Clause","text":"<p>Better to Use <code>if-else</code>:</p> <pre><code>function getDiscount(price) {\n  if (price &gt; 100) {\n    return \"20% Discount\";\n  } else {\n    return \"No Discount\";\n  }\n}\n</code></pre>"},{"location":"js/miscellaneous/guard-clause/#guard-clause-vs-traditional-if-else","title":"\u2705 Guard Clause vs. Traditional <code>if-else</code>","text":"Guard Clause Traditional <code>if-else</code> Returns early Uses nested logic Keeps the main logic clean Can make functions longer Ideal for error handling Ideal for mutually exclusive conditions"},{"location":"js/miscellaneous/guard-clause/#in-summary","title":"In summary:","text":"<ul> <li>Use a guard clause to handle early returns and edge cases.</li> <li>Avoid it when conditions are mutually exclusive or you prefer a single return point.</li> </ul>"},{"location":"js/miscellaneous/guard-clause/#question","title":"Question","text":"<p>Is <code>return</code> the same as return <code>undefined</code>?</p>"},{"location":"js/miscellaneous/guard-clause/#is-return-the-same-as-return-undefined","title":"\u2705 Is <code>return</code> the same as return <code>undefined</code>?","text":"<p>Yes, <code>return</code> and <code>return undefined</code> are effectively the same in JavaScript. Both return <code>undefined</code> from a function, but there are slight differences in how they are used and perceived in the code.</p>"},{"location":"js/miscellaneous/guard-clause/#why-are-they-considered-the-same","title":"\ud83e\udde9 Why Are They Considered the Same?","text":"<p>In JavaScript:</p> <ul> <li>If a function does not return any value, it implicitly returns <code>undefined</code>.</li> <li>Using <code>return</code> without any value is the same as returning <code>undefined</code>.</li> </ul> Example<pre><code>function noValueReturn() {\n  return;\n}\n\nfunction explicitUndefinedReturn() {\n  return undefined;\n}\n\nconsole.log(noValueReturn()); // Output: undefined\nconsole.log(explicitUndefinedReturn()); // Output: undefined\n</code></pre> <p>Both functions return <code>undefined</code>.</p>"},{"location":"js/miscellaneous/guard-clause/#what-happens-internally","title":"\u2699\ufe0f What Happens Internally?","text":"<ul> <li><code>return</code> without a value means the function stops execution and returns <code>undefined</code> by default.</li> <li><code>return undefined</code> explicitly tells the function to return the <code>undefined</code> value.</li> </ul>"},{"location":"js/miscellaneous/guard-clause/#when-to-use-return-vs-return-undefined","title":"\ud83d\udca1 When to Use return vs. return undefined","text":"Use Case Use <code>return</code> Use <code>return undefined</code> General case \u2705 \ud83d\udeab (not necessary) For clarity in logic \ud83d\udeab \u2705 (when you want to be explicit) To indicate an intentional <code>undefined</code> \ud83d\udeab \u2705"},{"location":"js/miscellaneous/guard-clause/#practical-example-in-code","title":"\ud83d\udcd6 Practical Example in Code","text":"<p>\u2705 Using Guard Clause with <code>return</code> (Preferred)</p> <pre><code>function getUserData(user) {\n  if (!user) return; // Implicitly returns undefined\n  return user.name;\n}\n</code></pre> <p>\u2705 Using <code>return undefined</code> for Explicitness</p> <pre><code>function getUserData(user) {\n  if (!user) return undefined; // Explicitly returns undefined\n  return user.name;\n}\n</code></pre>"},{"location":"js/miscellaneous/guard-clause/#key-difference-when-it-matters","title":"\ud83d\udea8 Key Difference (When It Matters)","text":"<p>The difference matters when you check for <code>undefined</code> explicitly.</p> Example<pre><code>function checkValue() {\n  return; // Implicit undefined\n}\n\nconsole.log(checkValue() === undefined); // true\nconsole.log(checkValue() === null); // false\n</code></pre> <p>In both cases, the function returns <code>undefined</code>.</p>"},{"location":"js/miscellaneous/guard-clause/#when-not-to-use-return-undefined","title":"\u274c When Not to Use return undefined","text":"<p>In most cases, using <code>return undefined</code> is redundant because JavaScript already returns <code>undefined</code> by default. Using it can make the code more verbose without adding clarity.</p>"},{"location":"js/miscellaneous/guard-clause/#when-to-use-return-undefined","title":"\u2705 When to Use return undefined","text":"<p>Use <code>return undefined</code> only when you want to be explicit about returning <code>undefined</code> for clarity or when it\u2019s part of your coding style.</p> Example<pre><code>function fetchData(apiResponse) {\n  if (!apiResponse) return undefined; // Making it clear that it's intentional\n  return apiResponse.data;\n}\n</code></pre>"},{"location":"js/miscellaneous/guard-clause/#summary","title":"Summary","text":"Aspect <code>return</code> <code>return undefined</code> Implicit return Returns <code>undefined</code> Explicitly returns <code>undefined</code> Preferred usage Most cases For clarity, if needed Verbosity Less verbose More verbose <p>In most cases, use <code>return</code> without a value unless you need to explicitly return <code>undefined</code> for clarity or intention.</p>"},{"location":"js/mnemonic/js-array/","title":"JS Array","text":""},{"location":"js/mnemonic/js-array/#overview","title":"Overview","text":"<p>To get a deep understanding of JavaScript arrays and remember key concepts, you can use mnemonics to simplify and retain the information. Here\u2019s a guide to understanding JavaScript arrays with some mnemonic aids:</p>"},{"location":"js/mnemonic/js-array/#1-basics-of-arrays","title":"1. Basics of Arrays","text":"<ul> <li> <p>Mnemonic: \"A Big Car Drives Everywhere\" (A-B-C-D-E)</p> <p>A - Arrays: Data structures to store multiple values.</p> <p>B - Basic operations: Initialization, accessing, and updating elements.</p> <p>C - Common methods: <code>.push()</code>, <code>.pop()</code>, <code>.shift()</code>, <code>.unshift()</code>.</p> <p>D - Dynamic size: Arrays can grow or shrink in size.</p> <p>E - Element types: Can store different types (numbers, strings, objects, etc.).</p> </li> </ul>"},{"location":"js/mnemonic/js-array/#2-common-methods-and-properties","title":"2 . Common Methods and Properties","text":"<ul> <li> <p>Mnemonic: \"Please Set Prime Fridays Carefully\" (P-S-P-F-C)</p> <p>P - <code>.push()</code>: Add elements to the end of the array.</p> <p>S - <code>.shift()</code>: Remove the first element.</p> <p>P - <code>.pop()</code>: Remove the last element.</p> <p>F - <code>.forEach()</code>: Iterate through elements.</p> <p>C - <code>.concat()</code>: Merge arrays.</p> </li> </ul>"},{"location":"js/mnemonic/js-array/#3-iteration-methods","title":"3. Iteration Methods","text":"<ul> <li> <p>Mnemonic: \"Most Fish Require Tasty Food\" (M-F-R-T-F)</p> <p>M - <code>.map()</code>: Transform each element.</p> <p>F - <code>.filter()</code>: Select elements based on a condition.</p> <p>R - <code>.reduce()</code>: Accumulate values.</p> <p>T - <code>.some()</code>: Check if any element meets a condition.</p> <p>F - <code>.every()</code>: Check if all elements meet a condition.</p> </li> </ul>"},{"location":"js/mnemonic/js-array/#4-array-properties","title":"4. Array Properties","text":"<ul> <li> <p>Mnemonic: \"Length Is Determined By All\" (L-I-D-B-A)</p> <p>L - <code>.length</code>: Number of elements.</p> <p>I - <code>.indexOf()</code>: Position of an element.</p> <p>D - <code>.delete</code>: Use delete to remove elements but doesn\u2019t change length.</p> <p>B - <code>.back()</code>: Non-standard, for last element (<code>.at(-1)</code> in modern JS).</p> <p>A - <code>.at()</code>: Access elements with negative indexing.</p> </li> </ul>"},{"location":"js/mnemonic/js-array/#5-multi-dimensional-arrays","title":"5. Multi-dimensional Arrays","text":"<ul> <li> <p>Mnemonic: \"Nested Elements Always Remain Rich\" (N-E-A-R-R)</p> <p>N - Nested: Arrays within arrays.</p> <p>E - Each dimension: Indexed independently.</p> <p>A - Accessing: Use nested loops or <code>.flat()</code> for simplification.</p> <p>R - Reshape: Use methods like <code>.map()</code> for transformations.</p> <p>R - Reorganize: Manipulate structure as needed.</p> </li> </ul>"},{"location":"js/mnemonic/js-array/#6-advanced-techniques","title":"6. Advanced Techniques","text":"<ul> <li> <p>Mnemonic: \"Strong Support Delivers Reliable Learning\" (S-S-D-R-L)</p> <p>S - Spread operator (<code>...</code>): Expand elements in a new array.</p> <p>S - Slice: Create sub-arrays.</p> <p>D - Destructuring: Extract values from arrays.</p> <p>R - Rest parameters: Handle variable numbers of elements.</p> <p>L - length property: Manage array size.</p> </li> </ul> <p>Using these mnemonics, you can more easily remember and recall various aspects of JavaScript arrays.</p>"},{"location":"js/mnemonic/js-array/#associations","title":"Associations","text":"<p>To remember information about JavaScript arrays for the long term, it helps to use a combination of mnemonic devices, active learning techniques, and contextual application. Here\u2019s a strategy to deeply associate and retain the knowledge:</p> <ol> <li> <p>Create Strong Associations</p> <p>Use Analogies:</p> <p>Think of arrays like a row of mailboxes (each index is a mailbox) where you can put letters (values).</p> <ul> <li><code>.push()</code> adds a letter to the end.</li> <li><code>.pop()</code> removes the letter from the end.</li> <li><code>.shift()</code> removes the letter from the beginning.</li> <li><code>.unshift()</code> adds a letter to the beginning.</li> </ul> <p>Relate Methods to Real-Life Actions:</p> <ul> <li><code>.map()</code>: Imagine you\u2019re putting a sticker on each item (transforming each element).</li> <li><code>.filter()</code>: Picture sifting through a pile to keep only certain items.</li> <li><code>.reduce()</code>: Think of combining a bunch of ingredients into a single dish.</li> </ul> </li> <li> <p>Engage in Active Learning</p> <p>Practice Coding Regularly:</p> <ul> <li>Write code snippets that use different array methods. Practice is crucial for retention.</li> <li>Build small projects or solve coding challenges that require you to manipulate arrays.</li> </ul> <p>Teach Others:</p> <ul> <li>Explain array concepts and methods to a friend or write a blog post/tutorial. Teaching helps solidify your understanding.</li> </ul> <p>Create Visual Aids:</p> <ul> <li>Draw diagrams of array operations or create flashcards with array methods and their descriptions. Visual memory can be powerful.</li> </ul> </li> <li> <p>Apply the Concepts Contextually</p> <p>Work on Real Projects:</p> <ul> <li>Integrate arrays into projects you're passionate about. Whether it\u2019s a to-do list app, a game, or data visualization, applying arrays in a real context helps reinforce the concepts.</li> </ul> <p>Use Arrays in Everyday Coding:</p> <ul> <li>Whenever you encounter a problem that can be solved with arrays, make a habit of using them. This practice helps cement your understanding.</li> </ul> </li> <li> <p>Leverage Mnemonics and Repetition</p> <p>Revisit Mnemonics Regularly:</p> <ul> <li>Periodically review the mnemonics you created. Spaced repetition (reviewing information at increasing intervals) helps move knowledge from short-term to long-term memory.</li> </ul> <p>Create a Cheat Sheet:</p> <ul> <li>Have a quick reference guide with key array methods and their uses. Regularly glance at it until the information is second nature.</li> </ul> </li> <li> <p>Use Interactive Learning Tools</p> <p>Interactive Platforms:</p> <ul> <li>Utilize coding platforms like Codecademy, freeCodeCamp, or LeetCode that offer interactive exercises and challenges related to arrays.</li> </ul> <p>Visual Learning Tools:</p> <ul> <li>Websites like JavaScript.info or MDN Web Docs provide interactive examples and explanations.</li> </ul> </li> <li> <p>Connect Concepts Together</p> <p>Build Concept Maps:</p> <ul> <li>Draw a map connecting different array methods, their purposes, and how they interact. For example, link <code>.map()</code> with <code>.filter()</code> to show how they can be used together in a data processing pipeline.</li> </ul> <p>Relate to Similar Concepts:</p> <ul> <li>Compare arrays with other data structures you know, like objects or sets. Understanding the similarities and differences helps reinforce your knowledge.</li> </ul> Example Mnemonic Practice <p>Mnemonic for Common Methods:</p> <ul> <li>Remember \"Please Set Prime Fridays Carefully\" to recall <code>.push()</code>, <code>.shift()</code>, <code>.pop()</code>, <code>.forEach()</code>, and <code>.concat()</code>.</li> </ul> <p>Practice with Mnemonics:</p> <ul> <li>Write short stories or sentences using these mnemonics to visualize what each method does in different scenarios.</li> </ul> </li> </ol> <p>By integrating these techniques into your learning routine, you'll build a robust, long-term understanding of JavaScript arrays.</p>"},{"location":"js/mnemonic/js-array/#data-processing-pipeline","title":"Data Processing Pipeline","text":"<p>A data processing pipeline is a sequence of operations or transformations applied to data to achieve a desired result. In programming, particularly with arrays in JavaScript, a pipeline often involves applying a series of functions to process or analyze the data step-by-step.</p> Data Processing Pipeline Concept <ol> <li>Input Data: Start with a dataset or an array of values.</li> <li>Transformation Steps: Apply various functions to process the data.</li> <li>Output Data: End with the final processed data.</li> </ol> <p>Each step in the pipeline takes input data, applies a transformation, and passes the result to the next step.</p>"},{"location":"js/mnemonic/js-array/#using-map-with-filter-together","title":"Using <code>.map()</code> with <code>.filter()</code> Together","text":"<p>You can use <code>.map()</code> and <code>.filter()</code> together in a data processing pipeline to transform and then filter data. Here's how:</p> <ol> <li> <p><code>.filter()</code>:</p> <p>This method is used to select elements that meet a certain condition. It creates a new array with only the elements that pass the test implemented by the provided function.</p> </li> <li> <p><code>.map()</code>:</p> <p>This method is used to transform elements. It creates a new array with the results of calling a provided function on every element in the calling array.</p> </li> </ol> Steps to Use <code>.map()</code> with <code>.filter()</code> Together** <ol> <li>Filter the Data: First, use <code>.filter()</code> to narrow down the dataset based on a condition.</li> <li>Transform the Data: Then, use <code>.map()</code> to transform the filtered dataset.</li> </ol> Example 1Example 2Example 3 <p>Let's say you have an array of objects representing people, and you want to filter out only the adults (age 18 or older) and then create a list of their names.</p> <pre><code>const people = [\n    { name: 'Alice', age: 25 },\n    { name: 'Bob', age: 17 },\n    { name: 'Charlie', age: 30 },\n    { name: 'David', age: 15 }\n];\n\n// First, filter out the adults (age 18 or older)\nconst adults = people.filter(person =&gt; person.age &gt;= 18);\n\n// Then, map to get an array of their names\nconst adultNames = adults.map(person =&gt; person.name);\n\nconsole.log(adultNames); // Output: ['Alice', 'Charlie']\n</code></pre> <p>Explanation:</p> <ol> <li>Filtering: <code>.filter(person =&gt; person.age &gt;= 18)</code> creates a new array that only includes people who are 18 or older.</li> <li>Mapping: <code>.map(person =&gt; person.name)</code> creates a new array containing the names of those filtered people.</li> </ol> Visualizing the Pipeline <p>You can visualize the pipeline as a sequence of operations:</p> <ol> <li>Input: <code>people</code></li> <li>Filter Step: <code>people.filter(person =&gt; person.age &gt;= 18)</code></li> <li>Transformation Step: <code>.map(person =&gt; person.name)</code></li> <li>Output: <code>['Alice', 'Charlie']</code></li> </ol> <p>This approach of chaining methods allows for clean, readable code and a logical flow of data transformation.</p> <p>Example: Processing Product Data</p> <p>Assume you have an array of product objects, each containing information about the product\u2019s name, price, and category. You want to filter out products that are in the \"Electronics\" category and then create a list of the names of these products with their prices increased by 10%.</p> <pre><code>const products = [\n    { name: 'Smartphone', price: 699, category: 'Electronics' },\n    { name: 'Laptop', price: 999, category: 'Electronics' },\n    { name: 'Coffee Maker', price: 89, category: 'Home Appliances' },\n    { name: 'Headphones', price: 199, category: 'Electronics' },\n    { name: 'Blender', price: 129, category: 'Home Appliances' }\n];\n\n// Step 1: Filter out products in the 'Electronics' category\nconst electronics = products.filter(product =&gt; product.category === 'Electronics');\n\n// Step 2: Map to increase price by 10% and get names with updated prices\nconst updatedElectronics = electronics.map(product =&gt; ({\n    name: product.name,\n    updatedPrice: product.price * 1.10 // Increase price by 10%\n}));\n\nconsole.log(updatedElectronics);\n// Output: [\n//   { name: 'Smartphone', updatedPrice: 768.9 },\n//   { name: 'Laptop', updatedPrice: 1098.9 },\n//   { name: 'Headphones', updatedPrice: 218.9 }\n// ]\n</code></pre> <p>Explanation:</p> <ol> <li> <p>Filtering: <code>.filter(product =&gt; product.category === 'Electronics')</code> creates a new array that includes only the products from the \"Electronics\" category.</p> </li> <li> <p>Mapping: <code>.map(product =&gt; ({ name: product.name, updatedPrice: product.price * 1.10 }))</code> creates a new array where each product\u2019s price is increased by 10%, and the result is a list of objects containing the product name and the updated price.</p> </li> </ol> <pre><code>const users = [\n    { username: 'john_doe', posts: 15, active: true },\n    { username: 'jane_smith', posts: 22, active: false },\n    { username: 'sam_jones', posts: 10, active: true },\n    { username: 'lisa_williams', posts: 35, active: true },\n    { username: 'michael_brown', posts: 8, active: false }\n];\n\n// Step 1: Filter out active users\nconst activeUsers = users.filter(user =&gt; user.active);\n\n// Step 2: Map to get usernames and increase their post count by 5\nconst updatedUsers = activeUsers.map(user =&gt; ({\nusername: user.username,\nupdatedPosts: user.posts + 5 // Increase post count by 5\n}));\n\nconsole.log(updatedUsers);\n// Output: [\n//   { username: 'john_doe', updatedPosts: 20 },\n//   { username: 'sam_jones', updatedPosts: 15 },\n//   { username: 'lisa_williams', updatedPosts: 40 }\n// ]\n</code></pre> <p>Explanation:</p> <ol> <li>Filtering: <code>.filter(user =&gt; user.active)</code> creates a new array that includes only active users. 2   Mapping: <code>.map(user =&gt; ({ username: user.username, updatedPosts: user.posts + 5 }))</code> creates a new array where each user\u2019s post count is increased by 5, and the result is a list of objects containing the username and the updated post count.</li> </ol> <p>These examples show how you can use <code>.filter()</code> to narrow down your dataset based on specific criteria and then use <code>.map()</code> to transform the filtered data. This approach is useful for a variety of data processing tasks and helps keep your code clean and readable.</p>"},{"location":"js/mnemonic/js-array/#javascript-iteration-methods","title":"JavaScript Iteration Methods","text":"<ol> <li> <p><code>.forEach()</code>: Executes a provided function once for each array element.</p> <pre><code>array.forEach(element =&gt; console.log(element));\n</code></pre> </li> <li> <p><code>.map()</code>: Creates a new array with the results of applying a function to each element.</p> <pre><code>const doubled = array.map(x =&gt; x * 2);\n</code></pre> </li> <li> <p><code>.filter()</code>: Creates a new array with elements that pass a test implemented by a function.</p> <pre><code>const evenNumbers = array.filter(x =&gt; x % 2 === 0);\n</code></pre> </li> <li> <p><code>.reduce()</code>: Applies a function against an accumulator and each element to reduce it to a single value.</p> <pre><code>const sum = array.reduce((acc, curr) =&gt; acc + curr, 0);\n</code></pre> </li> <li> <p><code>.some()</code>: Tests if at least one element in the array passes the test implemented by a function.</p> <pre><code>const hasNegative = array.some(x =&gt; x &lt; 0);\n</code></pre> </li> <li> <p><code>.every()</code>: Tests if all elements in the array pass the test implemented by a function.</p> <pre><code>const allPositive = array.every(x =&gt; x &gt; 0);\n</code></pre> </li> <li> <p><code>.find()</code>: Returns the first element that satisfies the provided testing function.</p> <pre><code>const firstNegative = array.find(x =&gt; x &lt; 0);\n</code></pre> </li> <li> <p><code>.findIndex()</code>: Returns the index of the first element that satisfies the provided testing function.</p> <pre><code>const index = array.findIndex(x =&gt; x === 5);\n</code></pre> </li> <li> <p><code>.sort()</code>: Sorts the elements of an array in place according to a provided comparison function.</p> <pre><code>const sorted = array.sort((a, b) =&gt; a - b);\n</code></pre> </li> <li> <p><code>.flatMap()</code>: Maps each element to a new array and then flattens the result by one level.</p> <pre><code>const flatMapped = array.flatMap(x =&gt; [x, x * 2]);\n</code></pre> </li> </ol>"},{"location":"js/mnemonic/js-array/#mnemonic-for-iteration-methods","title":"Mnemonic for Iteration Methods","text":"<p>Use the mnemonic \"Funky Map Friends Really Seek Every Fun Fun Seekers\" (F-M-F-R-S-E-F-F-S)</p> <ul> <li>F - <code>.forEach()</code>: Execute function for each element.</li> <li>M - <code>.map()</code>: Create new array with results of function.</li> <li>F - <code>.filter()</code>: Create new array with elements passing a test.</li> <li>R - <code>.reduce()</code>: Reduce array to a single value.</li> <li>S - <code>.some()</code>: Test if at least one element passes the test.</li> <li>E - <code>.every()</code>: Test if all elements pass the test.</li> <li>F - <code>.find()</code>: Find the first element that satisfies the test.</li> <li>F - <code>.findIndex()</code>: Find the index of the first element that satisfies the test.</li> <li>S - <code>.sort()</code>: Sort the array elements.</li> <li>F - <code>.flatMap()</code>: Map each element to a new array and flatten.</li> </ul> <p>Using this mnemonic helps in recalling the names and purposes of the iteration methods, making it easier to choose the right method for your needs.</p>"},{"location":"js/mnemonic/js-functions/","title":"JS Function","text":""},{"location":"js/mnemonic/js-functions/#different-types-of-function-in-javascript","title":"Different types of Function in Javascript","text":"<p>Here are a few tips to help you remember the different types of functions in JavaScript:</p>"},{"location":"js/mnemonic/js-functions/#1-use-acronyms","title":"1.  Use Acronyms","text":"<p>Create acronyms or mnemonics to remember the key categories. For example:</p> <ul> <li>\"R-A-A\": Regular, Anonymous, Arrow (for how functions are defined).</li> <li>\"I-H-C\": IIFE, Higher-Order, Callback (for when and how functions interact).</li> </ul>"},{"location":"js/mnemonic/js-functions/#2-visual-associations","title":"2.  Visual Associations","text":"<p>Associate each function type with a visual or real-world analogy:</p> <ul> <li>Regular Function: Think of it as a person with a name. You can call them (invoke them) anytime.</li> <li>Anonymous Function: A person without a name, useful for quick tasks or passing around without long-term use.</li> <li>Arrow Function: A speed arrow or shortcut to show it's a quicker way to write functions.</li> <li>IIFE: Imagine pressing a button that immediately triggers an action, like starting a stopwatch.</li> <li>Async Function: Think of a to-do list where you wait for things to be completed (like waiting for an email to arrive).</li> <li>Constructor Function: Think of a factory that builds objects.</li> </ul>"},{"location":"js/mnemonic/js-functions/#3-group-by-usage","title":"3.  Group By Usage","text":"<p>Categorize functions based on how you use them:</p> <ul> <li>Reusable Functions: Regular, Arrow</li> <li>One-time Use Functions: Anonymous, IIFE</li> <li>Advanced Usage: Higher-Order, Async, Constructor</li> </ul>"},{"location":"js/mnemonic/js-functions/#4-practice-using-them","title":"4.  Practice Using Them","text":"<p>The best way to remember is by practicing:</p> <ul> <li>Write examples of each function type.</li> <li>Use them in small coding challenges or real projects.</li> <li>Try to write code using different function types and see how they work in real scenarios.</li> </ul>"},{"location":"js/mnemonic/js-functions/#5-storytelling","title":"5.  Storytelling","text":"<p>Create a simple story or scenario to tie the functions together. For example:</p> <ul> <li>You have a Regular friend (Regular Function), who helps you anytime.</li> <li>Sometimes, you need help from a stranger (Anonymous Function) who doesn't have a name.</li> <li>You find a shortcut (Arrow Function) to get things done faster.</li> <li>You press a button (IIFE) to instantly start something.</li> <li>You call a helper (Callback Function) and ask them to do a task later.</li> <li>When waiting for something, you use Async (Async Function).</li> <li>And when you need to build something, you go to a factory (Constructor Function).</li> </ul> <p>By making it personal or memorable, you\u2019ll be able to recall the types more easily!</p>"},{"location":"js/mnemonic/js-object-iterating-method/","title":"Object Iterating Method","text":""},{"location":"js/mnemonic/js-object-iterating-method/#example-in-react","title":"Example in React","text":"<p>Scenario: User Profile Component</p> <p>Imagine you\u2019re building a React component that displays a user\u2019s profile information. You want to iterate over the profile data to dynamically render the information in the component.</p> for...inObject.keys()Object.values()Object.entries()for...of <p>Using <code>for...in</code> Loop</p> <p>Scenario: You need to display all the profile attributes in a list.</p> <pre><code>import React from 'react';\n\nconst UserProfile = ({ profile }) =&gt; {\n    return (\n        &lt;div&gt;\n        &lt;h1&gt;User Profile&lt;/h1&gt;\n            &lt;ul&gt;\n                {Object.keys(profile).map(key =&gt; (\n                &lt;li key={key}&gt;\n                    &lt;strong&gt;{key}:&lt;/strong&gt; {profile[key]}\n                &lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nconst profile = {\n    name: 'Alice',\n    age: 30,\n    email: 'alice@example.com',\n    isActive: true\n};\n\nexport default function App() {\n    return &lt;UserProfile profile={profile} /&gt;;\n}\n</code></pre> <p>Using <code>Object.keys()</code></p> <p>Scenario: Similar to the previous example, you want to render each key-value pair from the profile object.</p> <pre><code>import React from 'react';\n\nconst UserProfile = ({ profile }) =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;User Profile&lt;/h1&gt;\n            &lt;ul&gt;\n                {Object.keys(profile).map(key =&gt; (\n                &lt;li key={key}&gt;\n                    &lt;strong&gt;{key}:&lt;/strong&gt; {profile[key].toString()}\n                &lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nconst profile = {\n    name: 'Alice',\n    age: 30,\n    email: 'alice@example.com',\n    isActive: true\n};\n\nexport default function App() {\n    return &lt;UserProfile profile={profile} /&gt;;\n}\n</code></pre> <p>Using <code>Object.values()</code></p> <p>Scenario: You only want to display the values, ignoring the keys.</p> <pre><code>import React from 'react';\n\nconst UserProfile = ({ profile }) =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;User Profile&lt;/h1&gt;\n            &lt;ul&gt;\n                {Object.values(profile).map((value, index) =&gt; (\n                &lt;li key={index}&gt;{value.toString()}&lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nconst profile = {\n    name: 'Alice',\n    age: 30,\n    email: 'alice@example.com',\n    isActive: true\n};\n\nexport default function App() {\n    return &lt;UserProfile profile={profile} /&gt;;\n}\n</code></pre> <p>Using Object.entries()</p> <p>Scenario: Display both the key and the value of each profile attribute.</p> <pre><code>import React from 'react';\n\nconst UserProfile = ({ profile }) =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;User Profile&lt;/h1&gt;\n            &lt;ul&gt;\n                {Object.entries(profile).map(([key, value]) =&gt; (\n                &lt;li key={key}&gt;\n                    &lt;strong&gt;{key}:&lt;/strong&gt; {value.toString()}\n                &lt;/li&gt;\n            ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nconst profile = {\n    name: 'Alice',\n    age: 30,\n    email: 'alice@example.com',\n    isActive: true\n};\n\nexport default function App() {\n    return &lt;UserProfile profile={profile} /&gt;;\n}\n</code></pre> <p>Using <code>for...of</code> with <code>Object.entries()</code></p> <p>Scenario: Use the for...of loop to iterate over the entries and render them.</p> <pre><code>import React from 'react';\n\nconst UserProfile = ({ profile }) =&gt; {\n    const entries = Object.entries(profile);\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;User Profile&lt;/h1&gt;\n            &lt;ul&gt;\n                {entries.map(([key, value]) =&gt; (\n                &lt;li key={key}&gt;\n                    &lt;strong&gt;{key}:&lt;/strong&gt; {value.toString()}\n                &lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nconst profile = {\n    name: 'Alice',\n    age: 30,\n    email: 'alice@example.com',\n    isActive: true\n};\n\nexport default function App() {\n    return &lt;UserProfile profile={profile} /&gt;;\n}\n</code></pre> Summary <p>In these React components:</p> <ul> <li><code>for...in</code> and <code>Object.keys()</code>: Useful for iterating over object keys. You can use them to render both keys and values or perform other operations.</li> <li><code>Object.values()</code>: Use when you only need the values from the object.</li> <li><code>Object.entries()</code>: Use when you need both keys and values together for rendering or other operations.</li> <li><code>for...of</code> with <code>Object.entries()</code>: Offers a concise way to loop over key-value pairs.</li> </ul> <p>These methods help you dynamically generate UI elements based on the data in your React components, allowing for flexible and reusable code.</p>"},{"location":"js/mnemonic/js-object-iterating-method/#example-exclude-keys","title":"Example Exclude keys","text":"<p>If you want to exclude certain keys from being displayed, such as isActive, you can use various methods to filter out these keys before rendering the data. Here\u2019s how you can modify each of the previous examples to exclude specific keys from the display:</p> Object.keys()Object.entries()for...of <p>Scenario: Exclude <code>isActive</code> and <code>age</code> from being displayed.</p> <pre><code>import React from 'react';\n\nconst UserProfile = ({ profile }) =&gt; {\n    // List of keys to exclude\n    const keysToExclude = ['isActive', 'age'];\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;User Profile&lt;/h1&gt;\n            &lt;ul&gt;\n                {Object.keys(profile)\n                    .filter(key =&gt; !keysToExclude.includes(key)) // Filter out excluded keys\n                    .map(key =&gt; (\n                        &lt;li key={key}&gt;\n                        &lt;strong&gt;{key}:&lt;/strong&gt; {profile[key].toString()}\n                        &lt;/li&gt;\n                    ))\n                }\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nconst profile = {\n    name: 'Alice',\n    age: 30,\n    email: 'alice@example.com',\n    isActive: true\n};\n\nexport default function App() {\n    return &lt;UserProfile profile={profile} /&gt;;\n}\n</code></pre> <p>Scenario: Exclude <code>isActive</code> and <code>age</code> from being displayed.</p> <pre><code>import React from 'react';\n\nconst UserProfile = ({ profile }) =&gt; {\n    // List of keys to exclude\n    const keysToExclude = ['isActive', 'age'];\n\n    return (\n        &lt;div&gt;\n        &lt;h1&gt;User Profile&lt;/h1&gt;\n            &lt;ul&gt;\n                {Object.entries(profile)\n                    .filter(([key]) =&gt; !keysToExclude.includes(key)) // Filter out excluded entries\n                    .map(([key, value]) =&gt; (\n                        &lt;li key={key}&gt;\n                        &lt;strong&gt;{key}:&lt;/strong&gt; {value.toString()}\n                        &lt;/li&gt;\n                    ))\n                }\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nconst profile = {\n    name: 'Alice',\n    age: 30,\n    email: 'alice@example.com',\n    isActive: true\n};\n\nexport default function App() {\n    return &lt;UserProfile profile={profile} /&gt;;\n}\n</code></pre> <p>Scenario: Exclude <code>isActive</code> and <code>age</code> from being displayed.</p> <pre><code>import React from 'react';\n\nconst UserProfile = ({ profile }) =&gt; {\n    // List of keys to exclude\n    const keysToExclude = ['isActive', 'age'];\n    const entries = Object.entries(profile)\n        .filter(([key]) =&gt; !keysToExclude.includes(key)); // Filter out excluded entries\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;User Profile&lt;/h1&gt;\n            &lt;ul&gt;\n                {entries.map(([key, value]) =&gt; (\n                &lt;li key={key}&gt;\n                    &lt;strong&gt;{key}:&lt;/strong&gt; {value.toString()}\n                &lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nconst profile = {\n    name: 'Alice',\n    age: 30,\n    email: 'alice@example.com',\n    isActive: true\n};\n\nexport default function App() {\n    return &lt;UserProfile profile={profile} /&gt;;\n}\n</code></pre> Summary <p>To exclude multiple keys (e.g., <code>isActive</code> and <code>age</code>):</p> <ol> <li>Create an array of keys to exclude, such as <code>const keysToExclude = ['isActive', 'age'];</code>.</li> <li>Use <code>filter()</code> on the list of keys or entries to remove any key-value pairs where the key is in the keysToExclude array.</li> <li>Render the filtered keys or entries in your component.</li> </ol> <p>By applying this approach, you ensure that only the desired attributes are displayed in your React application, allowing for a clean and focused user interface.</p>"},{"location":"js/mnemonic/js-objects/","title":"JS Object","text":"<p>js objects</p>"},{"location":"js/mnemonic/object-array-iteration-methods/","title":"Iterating Method","text":"<p>JavaScript provides various methods for iterating over arrays and objects. Understanding these methods helps in effectively working with data structures. Here\u2019s a comprehensive overview of iteration methods for both arrays and objects in JavaScript.</p>"},{"location":"js/mnemonic/object-array-iteration-methods/#javascript-iteration-methods-for-objects","title":"JavaScript Iteration Methods for Objects","text":""},{"location":"js/mnemonic/object-array-iteration-methods/#methods","title":"Methods","text":"<ol> <li> <p><code>for...in</code> Loop</p> <pre><code>\n</code></pre> </li> <li> <p><code>Object.keys()</code></p> </li> <li> <p><code>Object.values()</code></p> </li> <li> <p><code>Object.entries()</code></p> </li> <li> <p><code>for...of Loop</code> with <code>Object.entries()</code></p> </li> </ol>"},{"location":"js/mnemonic/object-array-iteration-methods/#categorize","title":"Categorize","text":"<p>Certainly! To help you categorize and remember JavaScript iteration methods for objects, you can group them based on their primary functions and purposes. Here's a breakdown:</p> <ol> <li> <p>Iterating Over Keys</p> <p>These methods focus on accessing the keys (property names) of an object:</p> <ul> <li> <p><code>for...in</code> Loop</p> ExampleOverview <pre><code>const person = { name: 'Alice', age: 30 };\nfor (const key in person) {\n    console.log(key); // Output: name, age\n}\n</code></pre> <ul> <li>Purpose: Iterates over the enumerable properties of an object.</li> <li>Use Case: When you want to loop through all enumerable properties, including those inherited from the prototype chain.</li> </ul> </li> <li> <p><code>Object.keys()</code></p> ExampleOveriew <pre><code>const person = { name: 'Alice', age: 30 };\nconst keys = Object.keys(person); // ['name', 'age']\n</code></pre> <ul> <li>Purpose: Returns an array of the object's own enumerable property names.</li> <li>Use Case: When you need an array of keys to use with array methods.</li> </ul> </li> </ul> </li> <li> <p>Iterating Over Values</p> <p>These methods focus on accessing the values of an object:</p> <ul> <li> <p><code>Object.values()</code></p> ExampleOverview <pre><code>const person = { name: 'Alice', age: 30 };\nconst values = Object.values(person); // ['Alice', 30]\n</code></pre> <ul> <li>Purpose: Returns an array of the object's own enumerable property values.</li> <li>Use Case: When you need an array of values to work with.</li> </ul> </li> </ul> </li> <li> <p>Iterating Over Entries (Key-Value Pairs)</p> <p>These methods are useful for iterating over both keys and values simultaneously:</p> <ul> <li> <p><code>Object.entries()</code></p> ExampleOverview <pre><code>const person = { name: 'Alice', age: 30 };\nconst entries = Object.entries(person); // [['name', 'Alice'], ['age', 30]]\n</code></pre> <ul> <li>Purpose: Returns an array of the object's own enumerable <code>[key, value]</code> pairs.</li> <li>Use Case: When you need to iterate over both keys and values together.</li> </ul> </li> <li> <p><code>for...of</code> Loop with <code>Object.entries()</code></p> ExampleOverview <pre><code>const person = { name: 'Alice', age: 30 };\nfor (const [key, value] of Object.entries(person)) {\n    console.log(`${key}: ${value}`); // Output: name: Alice, age: 30\n}\n</code></pre> <ul> <li>Purpose: Iterates over <code>[key, value]</code> pairs using <code>for...of</code> combined with <code>Object.entries()</code>.</li> <li>Use Case: A concise and readable way to loop over both keys and values.</li> </ul> </li> </ul> </li> </ol> Summary of Categorization <ol> <li> <p>Keys Iteration:</p> <ul> <li><code>for...in</code> (iterates over all enumerable properties including inherited ones)</li> <li><code>Object.keys()</code> (returns an array of the object's own enumerable property names)</li> </ul> </li> <li> <p>Values Iteration:</p> <ul> <li><code>Object.values()</code> (returns an array of the object's own enumerable property values)</li> </ul> </li> <li> <p>Entries Iteration:</p> <ul> <li><code>Object.entries()</code> (returns an array of <code>[key, value]</code> pairs)</li> <li><code>for...of</code> loop with <code>Object.entries()</code> (iterates over <code>[key, value]</code> pairs in a readable way)</li> </ul> </li> </ol> <p>By grouping these methods into categories based on their purposes, you can more easily recall and use them depending on whether you need to work with keys, values, or both.</p>"},{"location":"js/mnemonic/object-array-iteration-methods/#mnemonic","title":"Mnemonic","text":"<p>Mnemonics can be a helpful tool for memorizing and recalling concepts. Here\u2019s a mnemonic to help remember the JavaScript iteration methods for objects, categorized by their purpose:</p> Mnemonic: \"Keep Value Everything\" <p>K eep (Keys Iteration)</p> <ul> <li>K - <code>for...in</code> (think of \"Keep going through properties\")</li> <li>K - <code>Object.keys()</code> (think of \"Key list\")</li> </ul> <p>V alue (Values Iteration)</p> <ul> <li>V - <code>Object.values()</code> (think of \"Values list\")</li> </ul> <p>E verything (Entries Iteration)</p> <ul> <li>E - <code>Object.entries()</code> (think of \"Everything together as key-value pairs\")</li> <li>E - <code>for...of</code> loop with <code>Object.entries()</code> (think of \"Each pair in a loop\")</li> </ul> Expanded Mnemonic <ol> <li> <p>Keep:</p> <ul> <li><code>for...in</code>: \"Keep going through all enumerable properties.\"</li> <li><code>Object.keys()</code>: \"Key list\" - think of it as a list of keys you can work with.</li> </ul> </li> <li> <p>Value:</p> <ul> <li><code>Object.values()</code>: \"Value list\" - think of it as a list of values extracted from the object.</li> </ul> </li> <li> <p>Everything:</p> <ul> <li><code>Object.entries()</code>: \"Everything together\" - think of it as pairing up keys and values.</li> <li><code>for...of</code> loop with <code>Object.entries()</code>: \"Each pair in a loop\" - remember that it loops over each key-value pair.</li> </ul> </li> </ol>"},{"location":"js/mnemonic/object-array-iteration-methods/#example-of-using-the-mnemonic","title":"Example of Using the Mnemonic","text":"<p>Imagine you\u2019re working on a JavaScript project and need to iterate over an object. You can use the mnemonic as a checklist:</p> <ol> <li>Keep - Do you need to iterate over keys? Use <code>for...in</code> or <code>Object.keys()</code>.</li> <li>Value - Do you need to get values? Use <code>Object.values()</code>.</li> <li>Everything - Do you need both keys and values? Use <code>Object.entries()</code> or loop through entries with <code>for...of</code>.</li> </ol>"},{"location":"js/mnemonic/object-array-iteration-methods/#visual-mnemonic","title":"Visual Mnemonic","text":"<p>To visualize this, you might picture a \u201cKVE\u201d checklist:</p> <ul> <li>Keep (Keys) -&gt; <code>for...in</code>, <code>Object.keys()</code></li> <li>Value (Values) -&gt; <code>Object.values()</code></li> <li>Everything (Entries) -&gt; <code>Object.entries()</code>, <code>for...of</code> with <code>Object.entries()</code></li> </ul> <p>Using mnemonics like this can simplify remembering the methods and their purposes, making it easier to choose the right tool for your task.</p>"},{"location":"js/mnemonic/object-array-iteration-methods/#summary","title":"Summary","text":"<ul> <li> <p>Array Iteration Methods: Include <code>forEach</code>, <code>map</code>, <code>filter</code>, <code>reduce</code>, <code>some</code>, <code>every</code>, <code>find</code>, <code>findIndex</code>, and <code>for...of</code>, each serving specific purposes related to transforming, accumulating, or processing array elements.</p> </li> <li> <p>Object Iteration Methods: Include <code>for...in</code>, <code>Object.keys()</code>, <code>Object.values()</code>, <code>Object.entries()</code>, and <code>for...of</code> with <code>Object.entries()</code>, focusing on iterating over object properties and their values.</p> </li> </ul> <p>By leveraging these methods, you can efficiently work with arrays and objects, perform transformations, handle side effects, and manage state in your applications.</p>"},{"location":"js/operator/details/","title":"Details","text":""},{"location":"js/operator/details/#1-arithmetic-operators","title":"1. Arithmetic Operators","text":"<p>These operators perform mathematical operations like addition, subtraction, multiplication, division, etc.</p> <ul> <li><code>+</code> (Addition)</li> <li><code>-</code> (Subtraction)</li> <li><code>*</code> (Multiplication)</li> <li><code>/</code> (Division)</li> <li><code>%</code> (Remainder, Modulo)</li> <li><code>++</code> (Increment)</li> <li> <p><code>--</code> (Decrement)</p> <pre><code>let a = 5;\nlet b = 2;\nconsole.log(a + b); // 7\nconsole.log(a - b); // 3\nconsole.log(a * b); // 10\nconsole.log(a / b); // 2.5\nconsole.log(a % b); // 1\n</code></pre> </li> </ul>"},{"location":"js/operator/details/#2-assignment-operators","title":"2. Assignment Operators","text":"<p>These are used to assign values to variables.</p> <ul> <li><code>=</code> (Assignment)</li> <li><code>+=</code> (Add and assign)</li> <li><code>-=</code> (Subtract and assign)</li> <li><code>*=</code> (Multiply and assign)</li> <li><code>/=</code> (Divide and assign)</li> <li> <p><code>%=</code> (Modulo and assign)</p> <pre><code>let x = 5;\nx += 3; // x = x + 3 (x becomes 8)\n</code></pre> </li> </ul>"},{"location":"js/operator/details/#3-comparison-operators","title":"3. Comparison Operators","text":"<p>These are used to compare two values and return a Boolean result (<code>true</code> or <code>false</code>).</p> <ul> <li><code>==</code> (Equal to)</li> <li><code>===</code> (Strict equal to: checks both value and type)</li> <li><code>!=</code> (Not equal to)</li> <li><code>!==</code> (Strict not equal to)</li> <li><code>&gt;</code> (Greater than)</li> <li><code>&lt;</code> (Less than)</li> <li><code>&gt;=</code> (Greater than or equal to)</li> <li> <p><code>&lt;=</code> (Less than or equal to)</p> <pre><code>console.log(5 == \"5\"); // true (due to type coercion)\nconsole.log(5 === \"5\"); // false (strict comparison)\n</code></pre> </li> </ul>"},{"location":"js/operator/details/#4-logical-operators","title":"4. Logical Operators","text":"<p>These are used to perform logical operations, typically with boolean values.</p> <ul> <li><code>&amp;&amp;</code> (Logical AND)</li> <li><code>||</code> (Logical OR)</li> <li> <p><code>!</code> (Logical NOT)</p> <pre><code>let a = true;\nlet b = false;\nconsole.log(a &amp;&amp; b); // false\nconsole.log(a || b); // true\nconsole.log(!a); // false\n</code></pre> </li> </ul>"},{"location":"js/operator/details/#5-bitwise-operators","title":"5. Bitwise Operators","text":"<p>These perform operations on the binary representations of numbers.</p> <ul> <li><code>&amp;</code> (AND)</li> <li><code>|</code> (OR)</li> <li><code>^</code> (XOR)</li> <li><code>~</code> (NOT)</li> <li><code>&lt;&lt;</code> (Left shift)</li> <li><code>&gt;&gt;</code> (Right shift)</li> <li> <p><code>&gt;&gt;&gt;</code> (Unsigned right shift)</p> <pre><code>let a = 5; // 0101 in binary\nlet b = 3; // 0011 in binary\nconsole.log(a &amp; b); // 1 (0001 in binary)\n</code></pre> </li> </ul>"},{"location":"js/operator/details/#6-ternary-conditional-operator","title":"6. Ternary (Conditional) Operator","text":"<p>This is a shorthand for the <code>if-else</code> statement.</p> <ul> <li> <p><code>condition ? expr1 : expr2</code></p> <p>If the condition is true, <code>expr1</code> is executed; otherwise, <code>expr2</code> is executed.</p> <pre><code>let age = 20;\nlet isAdult = age &gt;= 18 ? \"Yes\" : \"No\"; // 'Yes'\n</code></pre> </li> </ul>"},{"location":"js/operator/details/#7-type-operators","title":"7. Type Operators","text":"<p>These operators deal with data types.</p> <ul> <li><code>typeof</code> (Returns the type of a variable or expression)</li> <li> <p><code>instanceof</code> (Checks if an object is an instance of a particular class)</p> <pre><code>let num = 5;\nconsole.log(typeof num); // 'number'\n\nlet str = \"hello\";\nconsole.log(str instanceof String); // false\n</code></pre> </li> </ul>"},{"location":"js/operator/details/#8-spread-and-rest-operators","title":"8. Spread and Rest Operators","text":"<p>These are used in function calls and object manipulations.</p> <ul> <li> <p><code>...</code> (Spread / Rest Operator)</p> Example (Spread in array)<pre><code>let arr = [1, 2, 3];\nlet newArr = [...arr, 4, 5];\nconsole.log(newArr); // [1, 2, 3, 4, 5]\n</code></pre> Example (Rest in function parameters)<pre><code>function sum(...numbers) {\n  return numbers.reduce((acc, num) =&gt; acc + num, 0);\n}\nconsole.log(sum(1, 2, 3)); // 6\n</code></pre> </li> </ul>"},{"location":"js/operator/details/#9-unary-operators","title":"9. Unary Operators","text":"<p>These operators operate on a single operand.</p> <ul> <li><code>+</code> (Unary plus: converts the operand to a number)</li> <li><code>-</code> (Unary negation: negates the operand)</li> <li><code>++</code> (Increment: increases the operand by 1)</li> <li><code>--</code> (Decrement: decreases the operand by 1)</li> <li><code>typeof</code> (Returns the type of the operand)</li> <li> <p><code>delete</code> (Deletes a property of an object)</p> <pre><code>let x = 5;\nconsole.log(++x); // 6 (pre-increment)\nconsole.log(x--); // 6 (post-decrement)\n</code></pre> </li> </ul>"},{"location":"js/operator/details/#10-nullish-coalescing-operator","title":"10. Nullish Coalescing Operator (<code>??</code>)","text":"<p>This returns the right-hand operand when the left-hand operand is <code>null</code> or <code>undefined</code>.</p> <pre><code>let foo = null;\nlet bar = \"Hello\";\nconsole.log(foo ?? bar); // 'Hello'\n</code></pre>"},{"location":"js/operator/details/#11-optional-chaining","title":"11. Optional Chaining (<code>?.</code>)","text":"<p>This allows you to access deeply nested properties without having to check if each reference in the chain is valid.</p> <pre><code>let user = { name: \"Alice\", address: { city: \"New York\" } };\nconsole.log(user?.address?.city); // 'New York'\nconsole.log(user?.phone?.number); // undefined (does not throw an error)\n</code></pre> <p>These are the primary categories of operators in JavaScript, each serving a unique purpose to manipulate data and perform calculations.</p>"},{"location":"js/operator/overview/","title":"Overview","text":""},{"location":"js/operator/overview/#overview","title":"Overview","text":"<p>In JavaScript, operators are special symbols or keywords used to perform operations on values and variables. There are several types of operators, each serving a different purpose. Here are the main categories of JavaScript operators:</p> <ul> <li>1. Arithmetic Operators</li> <li>2. Assignment Operators</li> <li>3. Comparison Operators</li> <li>4. Logical Operators</li> <li>5. Bitwise Operators</li> <li>6. Ternary (Conditional) Operators</li> <li>7. Type Operators</li> <li>8. Spread and Rest Operators</li> <li>9. Unary Operators</li> <li>10. Nullish Coalescing Operator (<code>??</code>)</li> <li>11. Optional Chaining (<code>?.</code>)</li> </ul> <ul> <li>Arithmetic Operators</li> <li>Assignment Operators</li> <li>Comparison Operators</li> <li>Logical Operators</li> <li>Bitwise Operators</li> <li>Ternary (Conditional) Operator</li> <li>Type Operators</li> <li>Spread / Rest Operators</li> <li>Unary Operators</li> <li>Nullish Coalescing Operator (<code>??</code>)</li> <li>Optional Chaining (<code>?.</code>)</li> </ul>"},{"location":"js/terminology/intro/","title":"Terminology","text":""},{"location":"js/terminology/intro/#terminology","title":"Terminology","text":""},{"location":"js/terminology/intro/#parameter-versus-argument","title":"\u201cParameter\u201d Versus \u201cArgument\u201d","text":"<p>The terms <code>parameter</code> and <code>argument</code> are often used interchangeably, because the context usually makes it clear what the intended meaning is. The following is a rule of thumb for distinguishing them.</p> <ul> <li> <p>Parameters are used to define a function. They are also called formal parameters and formal arguments. In the following example, <code>param1</code> and <code>param2</code> are parameters:</p> <pre><code>function foo(param1, param2) {\n  ...\n}\n</code></pre> </li> <li> <p>Arguments are used to invoke a function. They are also called actual parameters and actual arguments. In the following example, <code>3</code> and <code>7</code> are   arguments:</p> <pre><code>foo(3, 7);\n</code></pre> </li> </ul>"},{"location":"js/terminology/intro/#reference","title":"Reference","text":"<ul> <li>Speaking JavaScript by Dr. Axel Rauschmayer</li> </ul>"},{"location":"js/weird-parts/bug-in-js/","title":"Bug in JS","text":""},{"location":"js/weird-parts/bug-in-js/#weird-bug-in-js","title":"Weird bug in jS","text":"<p>typeof null is an interesting case because it errantly returns \"<code>object</code>\" when you\u2019d expect it to return \"<code>null</code>\".</p> Tip <p>This is a long-standing bug in JS, but one that is likely never going to be fixed. Too much code on the Web relies on the bug, and thus fixing it would cause a lot more bugs!</p> <ul> <li>Up &amp; Going by Kyle Simpson, pg - 31</li> </ul>"},{"location":"js/weird-parts/bug-in-js/#values-types","title":"Values &amp; Types","text":"<p>JavaScript has typed values, not typed variables.</p> <p>The following built-in types are available:</p> <ul> <li>string</li> <li>number</li> <li>boolean</li> <li>null and undefined</li> <li>object</li> <li>symbol (new to ES6)</li> </ul> <p>JavaScript provides a <code>typeof</code> operator that can examine a value and tell you what type it is:</p> <pre><code>var a;\ntypeof a; // \"undefined\"\n\na = \"hello world\";\ntypeof a; // \"string\"\n\na = 42;\ntypeof a; // \"number\"\n\na = true;\ntypeof a; // \"boolean\"\n\na = null;\ntypeof a; // \"object\"--weird, bug\n\na = undefined;\ntypeof a; // \"undefined\"\n\na = { b: \"c\" };\ntypeof a; // \"object\"\n</code></pre> <p>The return value from the <code>typeof</code> operator is always one of six (seven as of ES6!) string values. That is, <code>typeof</code> \"abc\" returns \"<code>string</code>\", not string.</p> Note <p>Notice how in this snippet the a variable holds every different type of value, and that despite appearances, typeof a is not asking for the \u201ctype of a,\u201d but rather for the \u201ctype of the value currently in a.\u201d Only values have types in JavaScript; variables are just simple containers for those values.</p> <ul> <li>Up &amp; Going by Kyle Simpson, pg - 30</li> </ul>"},{"location":"js/weird-parts/bug-in-js/#arrays","title":"Arrays","text":"<p>An array is an object that holds values (of any type) not particularly in named properties/keys, but rather in numerically indexed positions. For example:</p> <pre><code>var arr = [\"hello world\", 42, true];\narr[0]; // \"hello world\"\narr[1]; // 42\narr[2]; // true\narr.length; // 3\n\ntypeof arr; // \"object\"\n</code></pre> <p>Because arrays are special objects (as typeof implies), they can also have properties, including the automatically updated length property.</p> Tip <p>The best and most natural approach is to use arrays for numerically positioned values and use objects for named properties.</p> <ul> <li>Up &amp; Going by Kyle Simpson, pg - 30</li> </ul>"},{"location":"js/weird-parts/bug-in-js/#comparing-values","title":"Comparing Values","text":"<p>There are two main types of value comparison that you will need to make in your JS programs:</p> <ol> <li>equality &amp;</li> <li>inequality.</li> </ol>"},{"location":"js/weird-parts/bug-in-js/#equality","title":"Equality","text":"<p>There are four equality operators:</p> <ol> <li><code>==</code>,</li> <li><code>===</code>,</li> <li><code>!=</code>,</li> <li><code>!==</code></li> </ol> <p>Consider the implicit coercion that\u2019s allowed by the <code>==</code> loose-equality comparison and not allowed with the <code>===</code> strict-equality:</p> <pre><code>var a = \"42\";\nvar b = 42;\n\na == b; // true\na === b; // false\n</code></pre> <p>The <code>a === b</code> produces <code>false</code>, because the coercion is not allowed,</p>"},{"location":"js/weird-parts/bug-in-js/#inequality","title":"Inequality","text":"<p>The <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code> operators are used for inequality, referred to in the specification as \u201crelational comparison.\u201d Typically they will be used with ordinally comparable values like numbers. It\u2019s easy to understand that 3 &lt; 4.</p> <ul> <li>Up &amp; Going by Kyle Simpson, pg - 30</li> </ul>"},{"location":"js/weird-parts/bug-in-js/#coercion","title":"Coercion","text":"<p>Coercion comes in two forms in JavaScript:</p> <ol> <li>explicit &amp;</li> <li>implicit</li> </ol> <p>Explicit coercion is simply that you can see from the code that a conversion from one type to another will occur, whereas implicit coercion is when the type conversion can happen as more of a non-obvious side effect of some other operation.</p> <ul> <li>Up &amp; Going by Kyle Simpson, pg - 30</li> </ul>"},{"location":"js/weird-parts/bug-in-js/#reference","title":"Reference","text":"<ul> <li>Weird JavaScript things</li> <li>\ud83e\udd2a A list of funny and tricky JavaScript examples: github</li> </ul>"},{"location":"js/weird-parts/js-missing-parts/","title":"JS Missing Part","text":"<p>In JavaScript, all types of functions, arrays, key/value pairs, and data structures in general are really objects. Even primitive types get the object treatment when you refer to them with the property access notations. They get automatically wrapped with an object so that you can call their prototype methods. For example:</p> <pre><code>\"tonya@example.com\".split(\"@\")[1]; // =&gt; example.com\n</code></pre> Tip <p>Primitive types behave like objects when you use the property access notations, but you can\u2019t assign new properties to them. Primitives get wrapped with an object temporarily, and then that object is immediately thrown away. Any attempt to assign values to properties will seem to succeed, but subsequent attempts to access that new property will fail.</p> <p>Programming Javascript Applications by Eric Elliott - Orielly - pg: 47</p>"},{"location":"memory-management/memory-types/","title":"Memory Types","text":""},{"location":"memory-management/memory-types/#memory-types","title":"Memory Types","text":"<p>The memory model in JavaScript defines how the language allocates, manages, and deallocates memory during the execution of programs. Here's an in-depth explanation of JavaScript's memory model:</p>"},{"location":"memory-management/memory-types/#1-types-of-memory-in-javascript","title":"1. Types of Memory in JavaScript","text":"<p>JavaScript uses two types of memory to manage data:</p> <ol> <li> <p>Stack (for static memory):</p> <ul> <li>Stores primitive values (e.g., <code>number</code>, <code>string</code>, <code>boolean</code>, <code>undefined</code>, <code>null</code>, <code>symbol</code>, <code>bigint</code>).</li> <li>Used for function calls and local variables.</li> <li>Operates in a Last-In-First-Out (LIFO) manner.</li> <li> <p>Memory allocation is automatic and fast because sizes of primitive types are fixed.</p> <pre><code>let a = 10; // 'a' is stored in the stack\n</code></pre> </li> </ul> <p></p> </li> <li> <p>Heap (for dynamic memory):</p> <ul> <li>Stores objects (e.g., <code>arrays</code>, <code>functions</code>, <code>objects</code>).</li> <li>Allocated for data that has variable size or is more complex than primitives.</li> <li> <p>Objects in the heap are accessed by references stored in the stack.</p> <pre><code>let obj = { name: \"John\" }; // 'obj' reference is in the stack, the actual object is in the heap\n</code></pre> </li> </ul> <p></p> </li> </ol>"},{"location":"memory-management/memory-types/#2-memory-allocation","title":"2. Memory Allocation","text":"<p>When variables or data structures are declared, JavaScript allocates memory:</p> <ol> <li> <p>Primitive Types:</p> <ul> <li>Stored directly in the stack.</li> <li> <p>Values are immutable (e.g., modifying a string creates a new value).</p> <pre><code>let x = 5;\nlet y = x; // y gets a copy of x\ny = 10; // modifying y does not affect x\n</code></pre> </li> </ul> </li> <li> <p>Reference Types:</p> <ul> <li>A reference (pointer) is stored in the stack, but the actual data resides in the heap.</li> <li> <p>When assigning one object to another, only the reference is copied, not the data.</p> <pre><code>let a = { value: 10 };\nlet b = a; // b points to the same object as a\nb.value = 20; // changes also reflect in a\n</code></pre> </li> </ul> </li> </ol>"},{"location":"memory-management/memory-types/#3-garbage-collection","title":"3. Garbage Collection","text":"<p>JavaScript uses an automatic garbage collection mechanism to free up memory that is no longer in use. The garbage collector (GC) periodically checks for unreferenced objects in the heap and removes them.</p> How GC works <ol> <li> <p>Reachability:</p> <ul> <li>Objects are considered \"reachable\" if they can be accessed via the global scope, the call stack, or references from other reachable objects.</li> </ul> </li> <li> <p>Mark-and-Sweep Algorithm:</p> <ul> <li>The GC starts from roots (e.g., global objects) and marks all reachable objects. Unmarked (unreachable) objects are then removed from the heap.</li> </ul> </li> </ol> Example<pre><code>let obj = { name: \"Alice\" };\nobj = null; // The object becomes unreachable and is eventually removed by GC\n</code></pre>"},{"location":"memory-management/memory-types/#4-common-memory-issues","title":"4. Common Memory Issues","text":"<p>Understanding memory management helps avoid issues such as:</p> <ol> <li> <p>Memory Leaks:</p> <ul> <li>Occurs when objects are no longer needed but are still referenced, preventing garbage collection.</li> </ul> Causes <ul> <li> <p>Unintended global variables: Forgetting to use <code>let</code>, <code>const</code>, or <code>var</code>.</p> <pre><code>function leak() {\n    leakedVar = \"I'm global\"; // This becomes a global variable\n}\n</code></pre> </li> <li> <p>Event listeners not removed.</p> </li> <li> <p>Circular references:</p> <pre><code>let a = {};\nlet b = {};\na.ref = b;\nb.ref = a; // GC can't clean this up\n</code></pre> </li> </ul> </li> <li> <p>Excessive Memory Usage:</p> <ul> <li>Large data structures in the heap not being cleaned up.</li> </ul> </li> </ol>"},{"location":"memory-management/memory-types/#5-memory-lifecycle","title":"5. Memory Lifecycle","text":"<p>The lifecycle of memory in JavaScript involves:</p> <ol> <li> <p>Allocation:</p> <ul> <li>Happens when variables, functions, or objects are created.</li> </ul> </li> <li> <p>Usage:</p> <ul> <li>Variables are read or written during execution.</li> </ul> </li> <li> <p>Deallocation:</p> <ul> <li>Garbage collection automatically reclaims memory for objects that are no longer reachable.</li> </ul> </li> </ol>"},{"location":"memory-management/memory-types/#6-tips-for-optimizing-memory-management","title":"6. Tips for Optimizing Memory Management","text":"<ol> <li> <p>Avoid Global Variables:</p> <ul> <li>Use block scope (<code>let</code>, <code>const</code>) to ensure variables don't persist longer than necessary.</li> </ul> </li> <li> <p>Use Weak References:</p> <ul> <li> <p>Use <code>WeakMap</code> or <code>WeakSet</code> for objects where you don\u2019t want to prevent garbage collection.</p> <pre><code>let wm = new WeakMap();\n</code></pre> </li> </ul> </li> <li> <p>Remove Event Listeners:</p> <ul> <li> <p>Always clean up event listeners to prevent memory leaks.</p> <pre><code>button.addEventListener(\"click\", handler);\nbutton.removeEventListener(\"click\", handler);\n</code></pre> </li> </ul> </li> <li> <p>Use Tools to Monitor Memory:</p> <ul> <li>Use browser developer tools to check for memory leaks or high memory usage.</li> <li>Chrome: <code>Performance</code> and <code>Memory</code> tabs.</li> </ul> </li> <li> <p>Break Circular References:</p> <ul> <li>Set object references to <code>null</code> explicitly if no longer needed.</li> </ul> </li> </ol>"},{"location":"memory-management/memory-types/#7-stack-vs-heap-example","title":"7. Stack vs Heap Example","text":"<pre><code>function example() {\n  let primitive = 42; // stored in stack\n  let obj = { key: \"value\" }; // reference stored in stack, actual object in heap\n}\nexample(); // After execution, the stack memory is cleared, but the heap may remain until GC runs.\n</code></pre> <p>Understanding JavaScript's memory model helps write efficient, bug-free code, especially for large-scale or performance-critical applications.</p>"},{"location":"memory-management/memory-types/#reference","title":"Reference","text":"<ul> <li>Memory Management in JavaScript \u2013 Complete guide</li> </ul>"},{"location":"memory-management/overview/","title":"Overview","text":""},{"location":"memory-management/overview/#overview","title":"Overview","text":""},{"location":"memory-management/overview/#memory-life-cycle-in-javascript","title":"Memory life cycle in JavaScript","text":"<p>The memory life cycle defines a JavaScript variable or object\u2019s journey from initialization to removal. JavaScript and all the other programming languages have a similar memory life cycle, as depicted below.</p> <p></p>"},{"location":"memory-management/overview/#how-does-javascript-store-variables","title":"How does JavaScript store variables?","text":"<p>We talked about allocation and deallocation, but the question is that where do these allocations and deallocation happen?</p> <p></p> <p>more...</p>"},{"location":"memory-management/overview/#blog","title":"Blog","text":"<ul> <li>Memory Management in JavaScript \u2013 Complete guide</li> </ul>"},{"location":"memory-management/serialization/","title":"Serialization","text":""},{"location":"memory-management/serialization/#temp-very-important","title":"TEMP VERY IMPORTANT","text":"<p>I want to understand deep about objects in javascript how to console memory locations of objects in js</p> <p>In JavaScript, objects are stored in memory as references, rather than by value. This means when you assign an object to a variable, you're not copying the object itself but a reference to its location in memory. However, JavaScript does not provide direct access to the memory addresses of objects in the same way lower-level languages like C or C++ would.</p> <p>Still, there are ways to examine and work with objects to understand their structure and behavior. Below are a few concepts and tools that might help you:</p> <p>1. Understanding Object References</p> <p>When you create an object in JavaScript, you're working with a reference to a location in memory, not the actual value of the object. If you assign the object to another variable, that second variable holds the reference to the same memory location, not a copy of the object itself.</p> Example<pre><code>const obj1 = { a: 1, b: 2 };\nconst obj2 = obj1;\n\nconsole.log(obj1 === obj2); // true, both point to the same reference\n</code></pre> <p>In this example, <code>obj1</code> and <code>obj2</code> reference the same object in memory.</p> <p>2. Comparing Object References</p> <p>You can check if two variables reference the same object by using the strict equality operator (<code>===</code>):</p> Example<pre><code>const obj1 = { name: \"Alice\" };\nconst obj2 = { name: \"Alice\" };\n\nconsole.log(obj1 === obj2); // false, different references\n\nconst obj3 = obj1;\nconsole.log(obj1 === obj3); // true, same reference\n</code></pre> <p>3. Tracking Objects in Chrome DevTools (or any Browser DevTools)</p> <p>In browsers like Chrome, you can inspect objects and their memory usage through the developer tools. You can use the console to view and explore objects:</p> <ul> <li>In the Console tab, you can simply <code>console.log</code> objects, and inspect them in the \"Objects\" or \"Memory\" panels.</li> <li>You can use <code>console.dir()</code> for a more detailed view of an object.</li> </ul> Example<pre><code>const obj = { foo: \"bar\" };\nconsole.dir(obj); // This will show the object properties in a navigable format\n</code></pre> <p>4. Memory Profiling</p> <p>To track memory usage or inspect the memory locations where objects are stored:</p> <ol> <li>Open Chrome DevTools.</li> <li>Go to the Memory tab.</li> <li>Use the Heap snapshot to view the objects in memory and analyze their references.</li> <li>You can also use Allocation instrumentation on timeline for real-time tracking.</li> </ol> <p>5. WeakMap for Memory Management</p> <p>JavaScript has <code>WeakMap</code> that allows you to associate objects with values but does not prevent those objects from being garbage-collected. This is useful for cases where you want to track objects but not prevent them from being garbage-collected when they are no longer in use.</p> Example<pre><code>const weakMap = new WeakMap();\nlet obj = { name: \"John\" };\n\nweakMap.set(obj, \"Some data\");\nconsole.log(weakMap.get(obj)); // 'Some data'\n\nobj = null; // obj is eligible for garbage collection\n</code></pre> <p>6. Reflection: <code>Reflect</code> API</p> <p>JavaScript's <code>Reflect</code> API allows you to interact with objects at a deeper level, though it doesn't expose memory locations directly. You can perform things like reading and writing properties dynamically, which might help in debugging or exploring objects in more detail.</p> Example<pre><code>const obj = { name: \"Alice\" };\nReflect.set(obj, \"age\", 25);\nconsole.log(obj); // { name: 'Alice', age: 25 }\n</code></pre> <p>7. Console Logs and References</p> <p>To see where an object is being used in your code, you can simply log it to the console. However, it will show the structure of the object, not the memory location:</p> Example<pre><code>const obj = { a: 1, b: 2 };\nconsole.log(obj);\n</code></pre> <p>Summary</p> <p>JavaScript doesn't provide direct memory addresses, but you can work with object references, inspect objects in DevTools, and use various tools like <code>WeakMap</code> and <code>Reflect</code> to manage and understand objects more deeply.</p> <p>If you need to track memory usage or locate objects, your best bet is using browser developer tools to analyze heap snapshots and allocations.</p>"},{"location":"memory-management/serialization/#question","title":"Question","text":"<p>so object only stores the memory location object. is that why while passing the object data through http or networks we need to serialise the data because the memory location cannot be sent.</p> <p>Yes, exactly! When you pass an object through HTTP or over a network, you're not able to directly transmit the object itself because JavaScript objects are stored in memory as references (i.e., memory locations). When you try to send the object as-is over the network, you're essentially trying to transmit a memory reference, which doesn\u2019t make sense in the context of a network request because the reference would only be valid in the local environment, not on the remote machine.</p> <p>This is why serialization is necessary.</p>"},{"location":"memory-management/serialization/#serialization","title":"Serialization","text":"<p>Serialization is the process of converting an object into a format that can be easily transmitted or stored, typically into a string format (like JSON), so that it can later be deserialized back into the original object on the receiving end.</p> <p>When you send an object over HTTP (e.g., via an API), you need to convert it into a data format like JSON (or sometimes XML), which is a text-based format. This allows the object to be transferred as a string. Upon arrival at the destination, the string can be deserialized back into an object.</p> <p>Example: Serialization with JSON</p> <p>Here's an example using JSON serialization:</p> <ol> <li> <p>Serialization (Converting an object to JSON):</p> <pre><code>const obj = { name: \"Alice\", age: 25 };\n\n// Convert the object to a JSON string\nconst jsonString = JSON.stringify(obj);\n\n// You can now send `jsonString` over HTTP, as it's a plain string.\nconsole.log(jsonString); // '{\"name\":\"Alice\",\"age\":25}'\n</code></pre> </li> <li> <p>Deserialization (Reconstructing the object from JSON):</p> <pre><code>// Assume jsonString is received from the network\nconst receivedJsonString = '{\"name\":\"Alice\",\"age\":25}';\n\n// Convert the JSON string back into an object\nconst deserializedObj = JSON.parse(receivedJsonString);\n\nconsole.log(deserializedObj); // { name: 'Alice', age: 25 }\n</code></pre> </li> </ol> Why Serialization? <ul> <li>Memory Reference Cannot Be Sent: As you mentioned, JavaScript objects are stored as memory references, and sending the reference wouldn't make sense in a different environment.</li> <li>Data Integrity: Serialization ensures that only the object data is transmitted, not the references or internal memory structure. The receiving end gets a copy of the object data that it can then work with independently.</li> <li>Standardized Format: JSON is widely supported across different platforms and languages. By serializing the data into JSON format, the data can be sent and received seamlessly, even if the receiving system is running a different programming language (e.g., Python, Java, etc.).</li> </ul> Additional Notes <ul> <li>Deep Copy vs Shallow Copy: Serialization and deserialization also have the effect of creating a \"deep copy\" of the object. In this case, the object is no longer a reference to the original, but rather a copy that can be manipulated independently.</li> <li>Complex Objects: Some objects (like functions, <code>Date</code> objects, or instances of custom classes) don't serialize as easily into JSON. You'd need to handle these cases manually if necessary.</li> </ul> <p>In short, <code>serialization</code> is necessary for sending objects over the network because memory references can't be passed between different systems, and serialization converts those objects into a transmittable format like JSON.</p>"},{"location":"memory-management/serialization/#javascript-memory-model","title":"JavaScript Memory Model","text":"<p>Sure! Let's pick up right from Memory Model in JavaScript (point 1) and continue exploring the deeper aspects of JavaScript objects, references, serialization, and their real-world applications.</p> <p>1. Memory Model in JavaScript (Continued)</p> <p>In JavaScript, understanding the difference between how primitive types and reference types are stored and passed around in memory is crucial for managing objects effectively. Here's a deeper dive into the memory model and how it relates to object references:</p> <p>Primitive Types vs. Reference Types</p> <ul> <li>Primitive types (like <code>number</code>, <code>string</code>, <code>boolean</code>, <code>undefined</code>, <code>null</code>, <code>symbol</code>, <code>bigint</code>) are immutable and are stored by value. When you assign a primitive type to a variable, it holds the actual value.</li> </ul> Example<pre><code>let a = 10;\nlet b = a; // b gets a copy of a's value, independent of a\nb = 20; // b changes, a remains 10\nconsole.log(a); // 10\nconsole.log(b); // 20\n</code></pre> <ul> <li>Reference types (like <code>object</code>, <code>array</code>, <code>function</code>, <code>date</code>) are mutable and are stored by reference. When you assign a reference type to a variable, that variable holds a reference (or memory address) pointing to the actual data in memory, not the value itself.</li> </ul> <pre><code>const obj1 = { name: \"Alice\" };\nconst obj2 = obj1; // obj2 is just another reference to the same object in memory\nobj2.name = \"Bob\"; // modifying the object through obj2 affects obj1 as well\nconsole.log(obj1.name); // 'Bob'\nconsole.log(obj2.name); // 'Bob'\n</code></pre> <p>In the above example, <code>obj1</code> and <code>obj2</code> are just references pointing to the same object in memory. Modifying the object via one reference affects the other because they are pointing to the same memory location.</p> <p>2. What Happens When You Pass an Object?</p> <p>When you pass an object to a function or assign it to another variable, you're not copying the actual object but rather passing the reference to the object. This is called pass-by-reference behavior.</p> Example<pre><code>function modifyObject(obj) {\n  obj.name = \"Charlie\"; // Modifies the object at the reference location\n}\nconst person = { name: \"Alice\" };\nmodifyObject(person);\nconsole.log(person.name); // 'Charlie'\n</code></pre> <p>Here, <code>modifyObject</code> doesn\u2019t get a copy of the object; it gets a reference to the <code>person</code> object. Hence, any change inside the function will directly affect the original object.</p> <p>3. Why Serialization is Necessary</p> <p>The reason you need to serialize objects when transmitting them over a network (e.g., HTTP requests) is that objects are stored as references in JavaScript. When you try to send an object via a network, you can't send the reference because it only works in the local environment.</p> <p>For example, suppose you want to send an object from a client (your browser) to a server (using HTTP). The object you\u2019re passing contains a reference to a memory location in your browser\u2019s memory. The server, however, will not be able to access that exact memory location. The solution to this is serialization: you convert the object into a format that can be transmitted over the network (like a string in JSON format).</p> <p>Serialization: Converting Objects into Transmittable Data</p> <p>Serialization refers to the process of converting an object into a format (like JSON or XML) that can be easily transmitted and later restored (deserialized) into the original object.</p> <p>Example of Serialization:</p> <pre><code>const user = { name: \"Alice\", age: 30 };\n// Serialize the object into a JSON string\nconst jsonString = JSON.stringify(user);\nconsole.log(jsonString); // '{\"name\":\"Alice\",\"age\":30}'\n// Send the JSON string via an HTTP request, e.g., using Fetch API\nfetch(\"https://example.com\", {\n  method: \"POST\",\n  headers: {\n    \"Content-Type\": \"application/json\",\n  },\n  body: jsonString,\n});\n</code></pre> <p>In this case, the object { name: 'Alice', age: 30 } is serialized into the string {\"name\":\"Alice\",\"age\":30}. The string can then be sent over the network (as part of an HTTP request). The server will receive the string and deserialize it back into an object.</p> <p>Deserialization:</p> <pre><code>// Suppose we receive the JSON string from the server\nconst receivedJson = '{\"name\":\"Alice\",\"age\":30}';\n// Deserialize the JSON string back into an object\nconst receivedObject = JSON.parse(receivedJson);\nconsole.log(receivedObject); // { name: 'Alice', age: 30 }\n</code></pre> <p>4. Why Can't We Send the Object Reference Directly?</p> <p>When you pass an object in JavaScript, you're passing a reference to it, not the actual object. This is fine when you're working within a single JavaScript environment (browser or Node.js).</p> <p>However, when you try to send the object over a network (e.g., via HTTP), you're essentially trying to transmit the memory reference. Since the receiving system (like a server or another browser) doesn\u2019t share the same memory space, it can\u2019t access the object at that reference.</p> <p>Serialization solves this problem by converting the object into a portable format that can be transmitted as text or binary data. When the object is received, the receiving system can reconstruct the object (via deserialization) and use it as if it were the original object, without needing access to the original memory address.</p> <p>5. JSON Serialization and its Benefits</p> <p>The most commonly used serialization format in JavaScript is JSON (JavaScript Object Notation). JSON is lightweight, easy to read, and easy to parse into JavaScript objects. It is also supported in almost every programming language, making it ideal for cross-platform communication.</p> <p>Advantages of JSON:</p> <ul> <li>Human-readable: JSON is easy to read and write, which makes debugging simpler.</li> <li>Language-agnostic: JSON can be easily parsed and generated in most programming languages, not just JavaScript.</li> <li>Standard format: JSON has become the de facto standard for transmitting data between a client and a server in web applications.</li> </ul> <p>Limitations of JSON:</p> <ul> <li>Loss of functions: JSON does not serialize methods (functions) inside objects. When you serialize an object with methods, those methods will be lost. You will only serialize data (properties).</li> <li>Circular references: JSON cannot serialize objects with circular references. If an object contains a reference to itself (either directly or indirectly), JSON.stringify() will throw a TypeError.</li> <li>Type loss (Date, RegExp, etc.): Some JavaScript types, like Date or RegExp, are converted to simple strings during serialization. When you deserialize them, you lose the specific type, which could result in data inconsistency unless manually handled.</li> </ul> <p>6. Other Serialization Formats (Protobuf, MessagePack, etc.)</p> <p>While JSON is the most commonly used format, there are other serialization formats that can be more efficient for certain use cases. Let\u2019s look at a few alternatives:</p> <p>Protocol Buffers (Protobuf):</p> <p>Protobuf is a binary serialization format developed by Google. It's designed to be more compact and faster than JSON, making it suitable for high-performance applications where size and speed are crucial. It's widely used in systems that require fast communication with minimal overhead, like mobile apps or large-scale web applications.</p> <p>Advantages:</p> <ul> <li>More compact than JSON, resulting in smaller payloads.</li> <li>Faster to serialize/deserialize compared to JSON.</li> <li>Supports strong typing, so data types (like integers, floats, strings, etc.) are more explicitly defined.</li> </ul> <p>Disadvantages:</p> <ul> <li>Not human-readable.</li> <li>Requires generating code from .proto files.</li> </ul> <p>MessagePack:</p> <p>MessagePack is another binary format that is more compact than JSON and supports faster parsing. It can serialize and deserialize objects quickly, making it suitable for performance-sensitive applications. Unlike Protobuf, MessagePack doesn\u2019t require predefined schema.</p> <p>Advantages:</p> <ul> <li>Smaller payload size compared to JSON.</li> <li>Easy to use, with libraries available for many languages.</li> <li>Supports a variety of types, including Map, Set, and Date</li> </ul> <p>XML:</p> <p>XML (Extensible Markup Language) was once widely used for web services and data exchange, but it has largely been replaced by JSON due to JSON\u2019s simplicity and efficiency. However, XML may still be used in legacy systems or when working with some specialized APIs.</p> <p>7. Serialization in Distributed Systems</p> <p>In a distributed system (where different parts of your application might be running on different servers or even in different programming languages), serialization becomes critical for communication. For example, if you're building a microservices architecture, each service may need to communicate with others using serialized data, often over HTTP, gRPC, or message queues.</p> <ul> <li>Data Consistency: Ensuring that data is serialized and deserialized correctly across different services or environments is crucial. For example, if a service is sending a Date object to another service, both services need to understand how to interpret that object.</li> <li>Cross-language Communication: Serialization formats like Protobuf and MessagePack are especially useful in multi-language environments, as they offer cross-platform compatibility, whereas JSON might require additional processing in non-JavaScript environments (though it's still widely supported).</li> </ul> <p>8. Performance and Efficiency Considerations</p> <p>In large-scale applications or performance-critical systems, serialization efficiency is a major concern. Here are a few things to consider:</p> <ul> <li>Payload Size: If you\u2019re transmitting a large amount of data, the size of the serialized data can have a significant impact on performance. Binary formats like Protobuf or MessagePack offer more compact representations of objects, which can reduce network bandwidth usage.</li> <li>Serialization Speed: Binary formats are generally faster to serialize and deserialize than JSON because they don\u2019t involve parsing text. JSON, while human-readable, introduces some overhead due to text encoding and decoding.</li> <li>Asynchronous Processing: In web applications, large or complex objects being serialized and deserialized on the main thread can block the UI. Offloading serialization to Web Workers or background processes can improve the responsiveness of your application.</li> </ul> <p>Conclusion</p> <p>Understanding the underlying memory model and reference behavior in JavaScript is key to grasping why serialization is essential for transmitting objects over a network. Objects in JavaScript are stored as references, so you can\u2019t directly transmit them across environments or systems.</p> <p>Instead, you need to serialize the objects into a transmittable format (such as JSON, Protobuf, or MessagePack), and later deserialize them into their original structure.</p> <p>While JSON is the most commonly used serialization format, performance, data types, and cross-platform compatibility might lead you to consider other serialization formats like Protobuf or MessagePack for more complex or performance-critical scenarios.</p> <p>In summary:</p> <ul> <li>Serialization: Converts complex objects into a format suitable for transmission.</li> <li>JSON: The most common format, suitable for most web applications.</li> <li>Other formats (Protobuf, MessagePack, etc.): Ideal for performance-sensitive applications where compactness and speed matter.</li> </ul> <p>By understanding these concepts, you can make more informed decisions when designing systems that require object serialization, data transmission, and cross-platform communication.</p>"},{"location":"modules/overview/","title":"Overview","text":""},{"location":"modules/overview/#overview","title":"Overview","text":"<p>import and export are standard JavaScript keywords that help with splitting related code across multiple files. Things like <code>variables</code>, <code>constants</code>, <code>classes</code>, or <code>functions</code> can be exported via export or export default so that they can then be used in other files after importing them there.</p> Note <p>Modules only work with the HTTP(s) protocol.</p> <p>A web-page opened via the <code>file://</code> protocol cannot use <code>import</code> / <code>export</code>.</p>"},{"location":"modules/overview/#what-is-es-modules","title":"What is ES Modules?","text":"<p>ES Modules is a modern module system that is built into the JavaScript language. ES Modules was created to solve the problem of managing dependencies in JavaScript projects, both on the client-side and server-side.</p> <p>Origins and history of ES Modules</p> <p>ES Modules was introduced in <code>ECMAScript 6</code> in 2015. It was created to provide a standardized way to modularize JavaScript code. ES Modules is now widely supported by modern web browsers and Node.js.</p> <p>Key features and characteristics of ES Modules</p> <p>ES Modules represents a more modern approach to JavaScript module management, using an asynchronous model for loading modules. Let\u2019s see this in action through a practical example.</p>"},{"location":"modules/overview/#export","title":"Export","text":"<p>Modules with functions or variables can be stored in any external file.</p> <p>There are two types of exports:</p> <ol> <li>Named Exports &amp;</li> <li>Default Exports.</li> </ol>"},{"location":"modules/overview/#named-exports","title":"Named Exports","text":"<p>Let us create a file named <code>person.js</code>, and fill it with the things we want to export.</p> <p>You can create named exports two ways. In-line individually, or all at once at the bottom.</p> Tip <p>In-line individually:</p> person.js<pre><code>export const name = \"Jesse\";\nexport const age = 40;\n</code></pre> <p>All at once at the bottom:</p> person.js<pre><code>const name = \"Jesse\";\nconst age = 40;\n\nexport {name, age};\n</code></pre>"},{"location":"modules/overview/#default-exports","title":"Default Exports","text":"<p>Let us create another file, named <code>message.js</code>, and use it for demonstrating default export.</p> <p>You can only have one <code>default export</code> in a file.</p> message.js<pre><code>const message = () =&gt; {\n  const name = \"Jesse\";\n  const age = 40;\n  return name + \" is \" + age + \"years old.\";\n};\n\nexport default message;\n</code></pre>"},{"location":"modules/overview/#import","title":"Import","text":"<p>You can import modules into a file in two ways, based on if they are <code>named exports</code> or <code>default exports</code>.</p> Import from named exports <p>Import named exports from the file <code>person.js</code>:</p> <pre><code>import { name, age } from \"./person.js\";\n</code></pre> Import from default exports <p>Import a default export from the file <code>message.js</code>:</p> <pre><code>import message from \"./message.js\";\n</code></pre>"},{"location":"modules/overview/#reference","title":"Reference","text":"<ul> <li>MDN: Javascript Modules</li> <li>JavaScript Module Cheatsheet \ud83d\udcc4</li> <li>Understanding CommonJS vs. ES Modules in JavaScript</li> <li> <p>W3Schools: </p> </li> <li> <p>Modules Export and Import</p> </li> <li>JavaScript Modules \u2013 How to Create, Import, and Export a Module in JS</li> <li>module.exports \u2013 How to Export in Node.js and JavaScript</li> <li>How to export a Class in JavaScript </li> <li>How to Use ES Modules in Node.js</li> </ul>"},{"location":"scope/chatgpt/","title":"ChatGpt","text":""},{"location":"scope/chatgpt/#scope","title":"Scope","text":""},{"location":"scope/chatgpt/#types-of-scope-in-javascript","title":"Types of Scope in JavaScript:","text":"<p>In JavaScript, scope refers to the context in which variables and functions are accessible. It determines the visibility and lifetime of variables and functions in different parts of the code. Scope helps prevent naming conflicts and allows the proper management of variables within specific sections of the code.</p>"},{"location":"scope/chatgpt/#1-global-scope","title":"1. Global Scope:","text":"<ul> <li>Variables <code>or</code> functions declared outside of any function <code>or</code> block are in the global scope.</li> <li>These variables are accessible throughout the entire program, including inside functions (unless shadowed by a local variable).</li> <li> <p>In a browser, global variables are properties of the <code>window</code> object.</p> <pre><code>let globalVar = \"I am a global variable\"; // Global scope\n\nfunction checkGlobal() {\n  console.log(globalVar); // Accessible here\n}\n</code></pre> </li> </ul>"},{"location":"scope/chatgpt/#2-function-scope-local-scope","title":"2. Function Scope (Local Scope):","text":"<ul> <li>Variables declared inside a function are in the function scope.</li> <li>These variables are only accessible within that function.</li> <li> <p>JavaScript traditionally had function scope, meaning variables are scoped to the function in which they are declared.</p> <pre><code>function myFunction() {\n  let localVar = \"I am a local variable\"; // Function scope\n  console.log(localVar); // Accessible here\n}\n// console.log(localVar); // Error: localVar is not defined\n</code></pre> </li> </ul>"},{"location":"scope/chatgpt/#3-block-scope","title":"3. Block Scope:","text":"<ul> <li>Variables declared with <code>let</code> or <code>const</code> inside a block (e.g., a loop or <code>if</code> statement) have block scope.</li> <li>They are only accessible within that block of code.</li> <li> <p><code>var</code>, however, does not have block scope and is function-scoped instead.</p> <pre><code>if (true) {\n  let blockScopedVar = \"I am block-scoped\";\n  const anotherBlockScopedVar = \"I am also block-scoped\";\n}\n// console.log(blockScopedVar); // Error: blockScopedVar is not defined\n// console.log(anotherBlockScopedVar); // Error: anotherBlockScopedVar is not defined\n</code></pre> </li> </ul>"},{"location":"scope/chatgpt/#4-lexical-scope","title":"4. Lexical Scope:","text":"<ul> <li>Lexical scope refers to the way in which the scope is determined by the location of variables and functions when they are written in the code (not when they are executed).</li> <li> <p>It means that functions can access variables that are defined in their outer (enclosing) scopes.</p> <pre><code>function outer() {\n  let outerVar = \"I am outer\";\n\n  function inner() {\n    console.log(outerVar); // Lexical scope: inner() can access outerVar\n  }\n\n  inner();\n}\n\nouter(); // Logs: I am outer\n</code></pre> </li> </ul>"},{"location":"scope/chatgpt/#5-module-scope-es6-modules","title":"5. Module Scope (ES6 Modules):","text":"<ul> <li>In JavaScript ES6 (ECMAScript 2015) modules, variables declared in a module are scoped to that module.</li> <li>This is a new type of scope that helps encapsulate code in modules, preventing accidental global variable leakage.</li> <li> <p>Variables and functions must be explicitly exported to be accessible from other modules.</p> <pre><code>// In a file called 'module.js'\nexport let moduleVar = \"I am module-scoped\";\n\n// In another file\nimport { moduleVar } from \"./module.js\"; // You can access moduleVar after importing\n</code></pre> </li> </ul>"},{"location":"scope/chatgpt/#summary-of-scope-types","title":"Summary of Scope Types","text":"<ul> <li>Global scope: Accessible everywhere.</li> <li>Function scope: Variables are scoped to the function.</li> <li>Block scope: Variables declared with <code>let</code> or <code>const</code> are scoped to the nearest block (like <code>if</code> or <code>for</code>).</li> <li>Lexical scope: The scope is determined by the location in the code where the function was defined.</li> <li>Module scope: Scope specific to JavaScript modules, preventing global leakage.</li> </ul> <p>Understanding scopes is essential for managing variable lifetimes and avoiding unintended bugs in JavaScript code!</p>"},{"location":"scope/deepseek/","title":"DeepSeek","text":""},{"location":"scope/deepseek/#scope","title":"Scope","text":"<p>In JavaScript, scope defines the accessibility or visibility of variables, functions, and objects in different parts of your code during runtime. It determines where a variable can be accessed or modified. JavaScript has the following types of scopes:</p>"},{"location":"scope/deepseek/#types-of-scopes","title":"Types of Scopes","text":""},{"location":"scope/deepseek/#1-global-scope","title":"1. Global Scope","text":"<ul> <li>Variables declared outside any function or block (e.g., <code>{}</code>) are in the global scope.</li> <li>Accessible everywhere in the code (including functions and blocks).</li> <li>Avoid overusing global variables to prevent naming collisions and unintended side effects.</li> </ul> <pre><code>const globalVar = \"I'm global\"; // Global scope\n\nfunction printGlobal() {\n  console.log(globalVar); // Accessible\n}\nprintGlobal(); // Output: \"I'm global\"\n</code></pre>"},{"location":"scope/deepseek/#2-function-scope-local-scope","title":"2. Function Scope (Local Scope)","text":"<ul> <li>Variables declared inside a function using <code>var</code> are function-scoped.</li> <li>Accessible only within the function where they are declared.</li> </ul>"},{"location":"scope/deepseek/#3-block-scope","title":"3. Block Scope","text":"<ul> <li>Introduced in ES6 with <code>let</code> and <code>const</code>.</li> <li>Variables declared inside a block (e.g., <code>{}</code>, <code>if</code>, <code>for</code>, <code>while</code>) are only accessible within that block.</li> <li><code>var</code> does not have block scope (it is function-scoped).</li> </ul> <pre><code>if (true) {\n  let blockVar = \"I'm block-scoped\"; // Block scope\n  const anotherBlockVar = \"Me too!\";\n  console.log(blockVar); // Works\n}\nconsole.log(blockVar); // Error: blockVar is not defined\n</code></pre>"},{"location":"scope/deepseek/#4-module-scope","title":"4. Module Scope","text":"<ul> <li>In ES6 modules, variables declared in a module are scoped to that module unless explicitly exported.</li> <li>Prevents pollution of the global scope in modular codebases.</li> </ul> <pre><code>// module.js\nconst moduleVar = \"I'm module-scoped\"; // Module scope\nexport default moduleVar;\n\n// main.js\nimport moduleVar from \"./module.js\";\nconsole.log(moduleVar); // Works (imported)\n// console.log(moduleVar); // Error if not imported\n</code></pre>"},{"location":"scope/deepseek/#lexical-scope-closures","title":"Lexical Scope (Closures)","text":"<ul> <li>Not a separate scope type, but a behavior where nested functions retain access to variables from their outer (enclosing) scope.</li> <li>Enables closures, where a function \"remembers\" its lexical environment.</li> </ul> <pre><code>function outer() {\n  const outerVar = \"Outer\";\n  function inner() {\n    console.log(outerVar); // Accesses outerVar via lexical scope\n  }\n  return inner;\n}\nconst closure = outer();\nclosure(); // Output: \"Outer\"\n</code></pre>"},{"location":"scope/deepseek/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Use <code>let/const</code> for block scoping (ES6+).</li> <li>Avoid polluting the global scope.</li> <li>Prefer modules (<code>import</code>/<code>export</code>) for large applications.</li> <li><code>var</code> is function-scoped, while <code>let</code>/<code>const</code> are block-scoped.</li> </ul>"},{"location":"scope/mkdocs-warning-solved/","title":"Mkdocs Issue Solved","text":""},{"location":"scope/mkdocs-warning-solved/#issue-1","title":"Issue 1","text":"<pre><code>INFO    -  DeprecationWarning: To replace an existing file, call `remove` before `append`.\nFile \"/home/{{name}}/.local/lib/python3.10/site-packages/material/plugins/tags/plugin.py\", line 129, in _get_tags_file\nfiles.append(file)\nFile \"/home/{{name}}/.local/lib/python3.10/site-packages/mkdocs/structure/files.py\", line 100, in append\nwarnings.warn(\n</code></pre> <p>Solved</p> <p>pip install --upgrade mkdocs mkdocs-material</p>"},{"location":"scope/mkdocs-warning-solved/#issue-2","title":"Issue 2","text":"<p>WARNING - Config value 'plugins': Plugin <code>'material/tags'</code> option <code>'tags_file'</code>: This setting is not required anymore</p> Current configuration<pre><code>plugins:\n  - search\n  - blog\n  - glightbox\n  - mkdocs-video\n  - tags:\n      tags_file: tags.md\n</code></pre> How to Fix the Warning <p>To resolve this, you simply need to remove the <code>tags_file</code> option from your configuration file. Here's what you need to change:</p> Updated configuration (remove tags_file)<pre><code>plugins:\n    - search\n    - blog\n    - glightbox\n    - mkdocs-video\n    - tags\n</code></pre> <p>Explanation:</p> <p>The <code>tags</code> plugin is now capable of automatically handling tags without requiring a <code>tags.md</code> file to be specified in the configuration. Removing this setting will eliminate the warning, and the plugin will continue to work as expected.</p>"},{"location":"style-guide/coercion/","title":"Coercion","text":"<p>In JavaScript, there are three components of the language that especially lend themselves to the creation of jargon:</p> <ol> <li>coercion,</li> <li>logical operators, &amp;</li> <li>bitwise manipulations (pejoratively known as bit twiddling.)</li> </ol>"},{"location":"style-guide/coercion/#coercion","title":"Coercion","text":"<p>In JavaScript as in most other languages, coercion is the act of forcing an object or entity of one type into another. This is not to be confused with type conversion, which is the explicit transformation between types. In JavaScript, explicit type conversion would look like this:</p> <pre><code>// =&gt; \"1\"\nvar a = (1).toString();\nconsole.log(a);\n\n// However, the number can also be implicitly coerced into a string this way:\n// =&gt; \"1\"\nvar a = 1 + \"\";\nconsole.log(a);\n</code></pre>"},{"location":"style-guide/intro/","title":"Intro","text":""},{"location":"style-guide/intro/#a-meta-code-style-guide","title":"A Meta Code Style Guide","text":"<p>JavaScript has many great style guides. Thus, there is no need to write yet another one. Instead, this chapter describes meta style rules and surveys existing style guides and established best practices. It also mentions practices I like that are more controversial. The idea is to complement existing style guides rather than to replace them.</p>"},{"location":"style-guide/intro/#existing-style-guides","title":"Existing Style Guides","text":"<p>These are style guides that I like:</p> <ul> <li>Idiomatic.js: Principles of Writing Consistent, Idiomatic JavaScript</li> <li>Google JavaScript Style Guide</li> <li>jQuery JavaScript Style Guide</li> <li>Airbnb JavaScript Style Guide</li> </ul> <p>Additionally, there are two style guides that go meta:</p> <ul> <li>Popular Conventions on GitHub analyzes GitHub code to find out which coding conventions are most frequently used.</li> <li>JavaScript, the winning style examines what the majority of several popular style guides recommend.</li> </ul>"},{"location":"style-guide/intro/#reference","title":"Reference","text":"<ul> <li>Book: Speaking JavaScript by Dr. Axel Rauschmayer</li> <li>9 Most Useful JavaScript Style Guides To Write Better Code</li> </ul>"},{"location":"style-guide/js-array/","title":"Array","text":""},{"location":"style-guide/js-array/#arrays","title":"Arrays","text":""},{"location":"style-guide/js-array/#multidimensional-arrays","title":"Multidimensional Arrays","text":"<p>If you need multiple dimensions for elements, you must nest arrays.</p>"},{"location":"style-guide/js-array/#sorting-and-reversing-elements-destructive","title":"Sorting and Reversing Elements (<code>Destructive</code>)","text":"<p>These methods are also destructive:</p> <ul> <li>Array.prototype.reverse()</li> <li>Array.prototype.sort(compareFunction?)</li> </ul>"},{"location":"style-guide/js-array/#concatenating-slicing-joining-nondestructive","title":"Concatenating, Slicing, Joining (<code>Nondestructive</code>)","text":"<p>The following methods perform various nondestructive operations on arrays:</p> <ul> <li>Array.prototype.concat(arr1?, arr2?, ...)</li> <li>Array.prototype.slice(begin?, end?)</li> <li>Array.prototype.join(separator?)</li> </ul>"},{"location":"style-guide/js-array/#searching-for-values-nondestructive","title":"Searching for Values (<code>Nondestructive</code>)","text":"<p>The following methods search for values in arrays:</p> <ul> <li>Array.prototype.indexOf(searchValue, startIndex?)</li> <li>Array.prototype.lastIndexOf(searchElement, startIndex?)</li> </ul>"},{"location":"style-guide/js-array/#iteration-nondestructive","title":"Iteration (<code>Nondestructive</code>)","text":"<p>Iteration methods use a function to iterate over an array. I distinguish three kinds of iteration methods, all of which are nondestructive:</p> <ul> <li>examination methods mainly observe the content of an array;</li> <li>transformation methods derive a new array from the receiver; &amp;</li> <li>reduction methods compute a result based on the receiver\u2019s elements.</li> </ul>"},{"location":"style-guide/js-array/#examination-methods","title":"Examination Methods","text":"<ul> <li>Array.prototype.forEach(callback, thisValue?)</li> <li>Array.prototype.every(callback, thisValue?)</li> <li>Array.prototype.some(callback, thisValue?)</li> </ul>"},{"location":"style-guide/js-array/#transformation-methods","title":"Transformation Methods","text":"<p>There are two transformation methods:</p> <ul> <li>Array.prototype.map(callback, thisValue?)</li> <li>Array.prototype.filter(callback, thisValue?)</li> </ul>"},{"location":"style-guide/js-array/#reduction-methods","title":"Reduction Methods","text":"<p>There are two reduction methods:</p> <ul> <li>Array.prototype.reduce(callback, initialValue?)</li> <li>Array.prototype.reduceRight(callback, initialValue?)</li> </ul>"},{"location":"style-guide/js-array/#best-practices-iterating-over-arrays","title":"Best Practices: Iterating over Arrays","text":"<p>To iterate over an array <code>arr</code>, you have two options:</p> <ul> <li> <p>A simple for loop (see for):</p> <pre><code>for (var i = 0; i &lt; arr.length; i++) {\n  console.log(arr[i]);\n}\n</code></pre> </li> <li> <p>One of the array iteration methods (see <code>Iteration (Nondestructive)</code>). For example, <code>forEach()</code>:</p> <pre><code>arr.forEach(function (elem) {\n  console.log(elem);\n});\n</code></pre> </li> </ul> <p>Do not use the <code>for-in</code> loop (see for-in) to iterate over arrays. It iterates over indices, not over values. And it includes the keys of normal properties while doing so, including inherited ones.</p>"},{"location":"style-guide/js-array/#reference","title":"Reference","text":"<ul> <li>Book: Speaking JavaScript by Dr. Axel Rauschmayer</li> </ul>"},{"location":"style-guide/js-constants/","title":"JS CONSTANT","text":""},{"location":"style-guide/js-constants/#naming-conventions","title":"Naming Conventions","text":"<p>The naming conventions for constant files and their values inside generally follow best practices for clarity, readability, and consistency in the codebase. Here's a recommended approach to naming constants, particularly in JavaScript and React applications:</p>"},{"location":"style-guide/js-constants/#1-file-naming-convention","title":"1. File Naming Convention","text":"<ul> <li> <p>Use Uppercase for Constant Files: Constant files are typically named in all uppercase letters, often using underscores to separate words (snake_case). This makes it clear that the file contains constant values that should not change.</p> <ul> <li>Example: <code>FOREX_DEAL.js</code>, <code>CURRENCY_CONSTANTS.js</code>, <code>FORM_CONSTANTS.js</code></li> </ul> </li> <li> <p>Avoid Special Characters: Stick with letters, numbers, and underscores (_) to make the filenames easily readable and compatible with different systems.</p> </li> <li> <p>Group Constants Based on Context: If your project has multiple areas with constants, consider organizing them into different files based on their relevance (e.g., one file for form constants, one for API URLs, etc.).</p> </li> </ul> Example <ul> <li><code>USER_CONSTANTS.js</code> for user-related constants</li> <li><code>API_URLS.js</code> for API endpoint constants</li> <li><code>FORM_CONSTANTS.js</code> for form-related constants like your <code>FOREX_DEAL</code></li> </ul>"},{"location":"style-guide/js-constants/#2-constant-naming-convention-inside-the-file","title":"2. Constant Naming Convention Inside the File","text":"<ul> <li> <p>Uppercase Snake Case for Constants: Constants are often written in all uppercase letters with underscores separating words. This clearly distinguishes constants from variables and regular functions.</p> <ul> <li>Example: <code>BUYING_CURRENCY</code>, <code>SELLING_CURRENCY</code>, <code>COUNTERPARTY</code></li> </ul> </li> <li> <p>Descriptive and Meaningful Names: Constant names should describe what the constant represents. Use clear, self-explanatory names to improve readability.</p> <ul> <li>Instead of generic names like <code>VALUE1</code> or <code>KEY_A</code>, use something more meaningful, like <code>MAX_RETRY_ATTEMPTS</code> or <code>DEFAULT_LANGUAGE</code>.</li> </ul> </li> <li> <p>Group Related Constants: For objects or grouped values, use camel case for keys and avoid adding \"constants\" to the variable names as it\u2019s implied.</p> </li> </ul> Example <p><code>const FOREX_DEAL = { ... }</code> instead of <code>const FOREX_DEAL_CONSTANTS = { ... }</code></p> <ul> <li> <p>Booleans: For boolean constants, use is, has, can, should, etc., as prefixes to make their purpose clearer.</p> <ul> <li>Example: <code>IS_ENABLED</code>, <code>HAS_PERMISSION</code></li> </ul> </li> </ul>"},{"location":"style-guide/js-constants/#3-example-of-constant-file-forex_dealjs","title":"3. Example of Constant File: <code>FOREX_DEAL.js</code>","text":"<pre><code>// FOREX_DEAL.js\n\nexport const FOREX_DEAL = {\n  BUYING_CURRENCY: \"\", // Currency that is being bought\n  SELLING_CURRENCY: \"\", // Currency that is being sold\n  COUNTERPARTY: \"\", // The party you're dealing with\n  COUNTERPARTY_DEALER: \"\", // The specific dealer in the counterparty\n  BUYING_AMOUNT: \"\", // Amount of buying currency\n  RATE: \"\", // Exchange rate\n  SELLING_AMOUNT: \"\", // Amount of selling currency\n  WE_PAY_FORM: \"\", // Payment form used\n  THEY_RECEIVED_AT: \"\", // Time at which they received the amount\n  WE_RECEIVED_AT: \"\", // Time at which we received the amount\n  APPROVAL_PERSON: \"\", // Person who approves the deal\n  REMARKS: \"\", // Additional remarks\n};\n</code></pre>"},{"location":"style-guide/js-constants/#4-key-practices-for-constants","title":"4. Key Practices for Constants:","text":"<ul> <li> <p>Do Not Use Mutable Values: Constants should never hold mutable values, like arrays or objects that can be modified unless they're explicitly meant to store unchanging data.</p> </li> <li> <p>Avoid Magic Numbers: Constants are useful for representing values that would otherwise be magic numbers or strings in your code (e.g., <code>3</code>, <code>45</code>, <code>true</code>). Assign them a meaningful name.</p> </li> <li> <p>Example: Instead of <code>if (status === 1)</code>, use <code>const STATUS_ACTIVE = 1;</code> and then <code>if (status === STATUS_ACTIVE)</code>.</p> </li> <li> <p>Document Complex Constants: If you have complex constants, especially objects, consider adding comments to explain their purpose, especially when the structure is not self-evident.</p> </li> </ul>"},{"location":"style-guide/js-constants/#5-example-file-and-structure-in-a-react-project","title":"5. Example File and Structure in a React Project","text":"<p>Here\u2019s a directory structure for an organized set of constants in a React project:</p> <pre><code>/src\n  /constants\n    FOREX_DEAL.js           // Forex related constants (e.g., initial form values)\n    CURRENCY_CONSTANTS.js   // Constants for different currencies\n    API_URLS.js             // API URLs for making network requests\n    ERROR_MESSAGES.js       // Constants for error messages\n    FORM_CONSTANTS.js       // General form constants (e.g., validation rules)\n</code></pre> <p>Each of these files would define constants that are specific to their respective context. For example:</p> <pre><code>// CURRENCY_CONSTANTS.js\nexport const CURRENCY_TYPES = {\n  USD: \"USD\",\n  EUR: \"EUR\",\n  GBP: \"GBP\",\n  JPY: \"JPY\",\n};\n</code></pre> <p>By using these practices, you\u2019ll maintain a clean, organized codebase that makes it easy for anyone (including future you) to understand the structure and purpose of your constants.</p>"},{"location":"style-guide/js-constants/#using-constants","title":"Using CONSTANTS","text":"<p>To use constants defined in another file, you'll need to import them properly into the file where you're using them. Here's how you can do that:</p>"},{"location":"style-guide/js-constants/#1-create-a-constants-file-eg-forex_dealjs","title":"1. Create a Constants File (e.g., <code>FOREX_DEAL.js</code>)","text":"<p>First, create a file where you define your constants, such as <code>FOREX_DEAL.js</code>.</p> <pre><code>// FOREX_DEAL.js\n\nexport const FOREX_DEAL = {\n  BUYING_CURRENCY: \"buyingCurrency\", // String value of the field name\n  SELLING_CURRENCY: \"sellingCurrency\",\n  COUNTERPARTY: \"counterparty\",\n  COUNTERPARTY_DEALER: \"counterPartyDealer\",\n  BUYING_AMOUNT: \"buyingAmount\",\n  RATE: \"rate\",\n  SELLING_AMOUNT: \"sellingAmount\",\n  WE_PAY_FORM: \"wePayForm\",\n  THEY_RECEIVED_AT: \"theyReceivedAt\",\n  WE_RECEIVED_AT: \"weReceivedAt\",\n  APPROVAL_PERSON: \"approvalPerson\",\n  REMARKS: \"remarks\",\n};\n</code></pre>"},{"location":"style-guide/js-constants/#2-import-the-constants-into-your-component-file","title":"2. Import the Constants into Your Component File","text":"<p>Next, import the <code>FOREX_DEAL</code> constant into the component file where you're using the <code>useEffect</code>.</p> <pre><code>import React, { useEffect } from \"react\";\nimport { Form } from \"antd\";\nimport { FOREX_DEAL } from \"./FOREX_DEAL\"; // Import the constants\n\nconst YourComponent = () =&gt; {\n  const [form] = Form.useForm();\n\n  useEffect(() =&gt; {\n    // Get the value of the buyingCurrency field\n    let buyingCurrency = form.getFieldValue(FOREX_DEAL.BUYING_CURRENCY);\n\n    if (buyingCurrency) {\n      // Set WE_RECEIVED_AT and THEY_RECEIVED_AT fields to null\n      form.setFieldsValue({\n        [FOREX_DEAL.WE_RECEIVED_AT]: null,\n        [FOREX_DEAL.THEY_RECEIVED_AT]: null,\n      });\n\n      // Assuming deleteFromItem is a utility to remove the field, it should be called with the field names\n      deleteFromItem(FOREX_DEAL.WE_RECEIVED_AT);\n      deleteFromItem(FOREX_DEAL.THEY_RECEIVED_AT);\n    }\n  }, [form.getFieldValue(FOREX_DEAL.BUYING_CURRENCY)]); // Trigger the effect when buyingCurrency changes\n\n  return &lt;Form form={form}&gt;{/* Form Items go here */}&lt;/Form&gt;;\n};\n\nexport default YourComponent;\n</code></pre> Key Points: <p>1. Import the Constants:</p> <ul> <li>Use the <code>import</code> statement to bring in the constants defined in another file (<code>FOREX_DEAL</code> in this case).</li> <li>In the <code>useEffect</code>, we now reference <code>FOREX_DEAL.BUYING_CURRENCY</code>, <code>FOREX_DEAL.WE_RECEIVED_AT</code>, and other constants instead of hardcoding the field names.</li> </ul> <p>2. Use Constants in Dynamic Field References:</p> <ul> <li>You can use constants to dynamically access or set field values in the <code>form.setFieldsValue</code> and <code>form.getFieldValue</code>.</li> <li>When you set or get a field value, use the bracket notation (<code>[]</code>) to reference the field names dynamically from the constants object.</li> </ul> Benefits of This Approach: <ul> <li>Centralized Field Names: If the field names ever change, you only need to update them in one place (<code>FOREX_DEAL.js</code>), and all components using those constants will automatically reflect the changes.</li> <li>Improved Readability: Using constants makes the code easier to read and maintain because it avoids hardcoded strings scattered throughout the codebase.</li> <li>Reusability: You can reuse the constants across multiple components without repeating the same field names, improving consistency.</li> </ul> <p>By following this approach, you can organize your constants and keep the logic of your form clean and manageable.</p>"},{"location":"style-guide/js-constants/#improvements","title":"Improvements","text":""},{"location":"style-guide/js-constants/#code","title":"Code","text":"<pre><code>// Constants for Forex Deal fields\nexport const FOREX_DEAL = {\n  BUYING_CURRENCY: \"currencyBoughtId\", // The currency being bought\n  SELLING_CURRENCY: \"currencySoldId\", // The currency being sold\n  COUNTERPARTY: \"counterPartyId\", // The other party in the transaction\n  COUNTERPARTY_DEALER: \"counterPartyDealerId\", // The dealer on the counterparty side\n  BUYING_AMOUNT: \"amountBought\", // The amount of currency bought\n  SELLING_AMOUNT: \"amountSold\", // The amount of currency sold\n  RATE: \"rate\", // The exchange rate for the deal\n  WE_PAY_FORM: \"ourPayBankAccountId\", // Our bank account for payment\n  THEY_RECEIVED_AT: \"counterpartyReceiveBankAccountId\", // The counterparty's receiving bank account\n  WE_RECEIVED_AT: \"ourReceiveBankAccountId\", // Our receiving bank account\n  APPROVAL_PERSON: \"approverId\", // Person who approves the transaction\n  REMARKS: \"remarks\", // Any remarks or comments about the deal\n  TRANSACTION_TYPE: \"transactionType\", // Type of the transaction (Buy/Sell)\n  DEAL_MODE: \"dealMode\", // Mode of the deal (Electronic/Manual)\n};\n\n// Constants for transaction types\nexport const TRANSACTION_TYPE = {\n  BUY: 1, // Buy transaction\n  SELL: 2, // Sell transaction\n};\n\n// Constants for deal modes\nexport const DEAL_MODE = {\n  ELECTRONIC: 1, // Electronic deal\n  MANUAL: 2, // Manual deal\n};\n\n// Utility function to get the transaction type label\nexport const getTransactionTypeLabel = (type) =&gt; {\n  switch (type) {\n    case TRANSACTION_TYPE.BUY:\n      return \"Buy\";\n    case TRANSACTION_TYPE.SELL:\n      return \"Sell\";\n    default:\n      return \"Unknown\";\n  }\n};\n\n// Utility function to get the deal mode label\nexport const getDealModeLabel = (mode) =&gt; {\n  switch (mode) {\n    case DEAL_MODE.ELECTRONIC:\n      return \"Electronic\";\n    case DEAL_MODE.MANUAL:\n      return \"Manual\";\n    default:\n      return \"Unknown\";\n  }\n};\n</code></pre>"},{"location":"style-guide/js-constants/#improvements_1","title":"Improvements:","text":"<ul> <li>Commenting: Added descriptive comments to the fields, making it easier for developers to understand the purpose of each constant.</li> <li>Naming Conventions: The constants are already quite clear, but I added <code>\"approverId\"</code> for <code>APPROVAL_PERSON</code> to make it more intuitive.</li> <li>Utility Functions: Added two utility functions <code>getTransactionTypeLabel</code> and <code>getDealModeLabel</code> to convert the numeric codes into human-readable labels. This will improve the usability of the code when you need to display these values.</li> <li>Consistency: Structured the constants and functions logically for better readability and maintainability.</li> </ul>"},{"location":"style-guide/js-constants/#dot-notation-vs-bracket-notation","title":"Dot Notation <code>vs</code> Bracket Notation","text":"<p>In JavaScript, you can access object properties in two ways:</p> <ol> <li>Dot Notation: This is used when you know the property name in advance (e.g., <code>object.property</code>).</li> <li>Bracket Notation: This is used when you want to access a property dynamically, or when the property name contains special characters (like spaces or hyphens) or starts with a number. You use bracket notation to access properties via variables or expressions.</li> </ol> <pre><code>const FOREX_DEAL = {\n  SELLING_CURRENCY: \"currencySoldId\", // This is the string we want to use as a property name\n};\n\nconst formValues = {\n  FOREX_DEAL: {\n    currencySoldId: \"USD\", // The value we want to access\n  },\n};\n\n// This will NOT work, because `formValues?.FOREX_DEAL.SELLING_CURRENCY` is not a valid property\nconst sellingCurrency1 = formValues?.FOREX_DEAL.SELLING_CURRENCY;\nconsole.log(sellingCurrency1); // undefined, because there's no property called `SELLING_CURRENCY` on `FOREX_DEAL`\n\n// This will work, because it accesses the property `currencySoldId` dynamically using the string value stored in `FOREX_DEAL.SELLING_CURRENCY`\nconst sellingCurrency2 = formValues?.[FOREX_DEAL.SELLING_CURRENCY];\nconsole.log(sellingCurrency2); // \"USD\", because `FOREX_DEAL.SELLING_CURRENCY` is \"currencySoldId\"\n</code></pre>"},{"location":"style-guide/js-style-guide/","title":"Style","text":""},{"location":"style-guide/js-style-guide/#javascript-style-guide","title":"JavaScript Style Guide","text":"<p>Style guides are just that, guides. They are meant to point you in the right direction, but they are, at best, a mutable truth. Coding theory changes constantly and it is important not to lock yourself into a dogmatic approach to the application of these rules.</p>"},{"location":"style-guide/js-style-guide/#rules-for-visual-clarity","title":"Rules for Visual Clarity","text":"<ul> <li> <p>Write clearly and expressively: While thinking about good guidelines for visual clarity in your code, it\u2019s important to keep this rule in mind. When naming variables and functions, or organizing code, remember that you are writing for humans, not compilers.</p> </li> <li> <p>Follow existing conventions: If you work on a team or are hired to write code, you are not writing for yourself. Therefore, you should conform your style to co-exist in the existing ecosystem, but without sacrificing quality.</p> </li> <li> <p>Write in only one language: Where possible, don\u2019t use JavaScript as a transport for other languages. This means resisting the urge to write inline HTML or CSS. Clear code enforces a separation of concerns.</p> </li> <li> <p>Enforce a uniform column width: Strive for consistent line lengths in source code. Long lines tire the eyes, which reduces comprehension. Long lines also cause needless horizontal scrolling. An industry standard is 80 characters per line.</p> </li> </ul>"},{"location":"style-guide/js-style-guide/#document-formatting","title":"Document Formatting","text":"<p>Understanding a program\u2019s source often requires the reader to mentally compile the code. This process needs sustained focus from readers, and any distraction can eject readers from their mental flow. Improperly or inconsistently formatted sources act as visual noise to the source\u2019s signal. This section offers conventions and guides that allows the formatting to support the source instead of weighing it down.</p>"},{"location":"style-guide/js-style-guide/#rules-for-computational-effectiveness","title":"Rules for Computational Effectiveness","text":"<p>Computational effectiveness is important to consider as well as visual clarity. Keep the following examples in mind:</p> <ul> <li> <p>Write for concatenation: Modern applications often munge the JavaScript source into a streamlined file for production. You should defensively program your scripts to protect from switches in operation context and scope corruption.</p> </li> <li> <p>Keep your code browser agnostic: Keep your business logic free of browser-specific code by abstracting them into interfaces. This will keep your code on a clean upgrade path as browsers fall in and out of fashion.</p> </li> <li> <p>Resist the use of <code>eval()</code>: It can often be an injection point for malicious code execution.</p> </li> <li> <p>Resist the use of <code>with()</code>: It can make the implications of the code hard to understand.</p> </li> <li> <p>Keep prototype pristine: Never modify the prototype of a built-in such as Array.prototype because it can silently break other\u2019s code, which expects standard behavior.</p> </li> </ul>"},{"location":"style-guide/js-style-guide/#equality-comparisons-and-conditional-evaluation","title":"Equality Comparisons and Conditional Evaluation","text":"<p>Use <code>===</code> instead of <code>==</code> and use <code>!==</code> instead of <code>!=</code> because the dynamic nature of JavaScript means that it is sometimes overly loose when testing equality. When just testing for \u201ctruthiness,\u201d you can coerce the values:</p> <p>Function Expressions</p> <p>Function expressions are function objects that are linked to variables. As such, they can be written more ways than a function declaration:</p> <pre><code>// Anonymous Function\nvar anon = function () {\n  return true;\n};\n\n// Named Function\nvar named = function named() {\n  return true;\n};\n\n// Immediately-invoked function, hides its contents from the executing scope.\n(function main() {\n  return true;\n})();\n</code></pre> <p>Function expressions are defined at parse-time. Therefore, do not have their names hoisted to the top of the scope. However, function expressions are preferred over function declarations because of certain bugs in older browsers.</p> <pre><code>// Bad - Runtime Error\niGoBoom();\nvar iGoBoom = function () {\n  alert(\"boom\");\n};\n\n// Good\niGoBoom();\nfunction iGoBoom() {\n  alert(\"boom\");\n}\n</code></pre> <p>Do not use function declarations within block statements; they are not part of ECMAScript. Use a function expression instead:</p> <pre><code>// Bad\nif (ball.is(round)) {\n  function bounce() {\n    // Statements Continue\n  }\n  return bounce();\n}\n\n// Good\nif (ball.is(round)) {\n  var bounce = function () {\n    // Statements Continue\n  };\n}\n</code></pre> <p>Do not hide the native arguments object by using the same name in a function:</p> <pre><code>// Bad\nvar foo = function (arguments) {\n  alert(arguments.join(\" \"));\n};\n\n// Good\nvar foo = function (args) {\n  alert(args.join(\" \"));\n};\n</code></pre> <p>Coercion</p> <p>Use explicit conversion over implicit coercion because it makes the code base more declarative:</p> <pre><code>var num = \"1\";\n// Bad implicit coercion\nnum = +num;\n// Good expressive conversion\nnum = Number(num);\n</code></pre>"},{"location":"style-guide/naming-convention/","title":"Naming Covention","text":"<p>JavaScript is a terse language of brackets numbers and letters. One of the only ways to make your code expressive to humans is through naming your variables, functions, and properties meaningfully. When choosing a name, it should describe the role and responsibilities of that object. Using vague or obtuse names such as doStuff or item1 is like telling the reader to figure it out, which they often won\u2019t</p> <p>Choose variables and functions with meaningful, expressive, and descriptive names. Write for the reader, not the compiler.</p> <pre><code>// Bad\nvar a = 1,\n  aa = function (aaa) {\n    return \"\" + aaa;\n  };\n\n// Good\nvar count = 1,\n  toString = function (num) {\n    return \"\" + num;\n  };\n</code></pre>"},{"location":"style-guide/naming-convention/#constants","title":"Constants","text":"<p>Constant should be written in uppercase with spaces replaced with underscores.</p> <pre><code>// Bad\nMEANING_OF_LIFE = 43;\n\n// Good\nconst MEANING_OF_LIFE = 43;\n\n// Good\ncom.humansized.MEANING_OF_LIFE = 42;\n\n// Good\nMath.PI;\n</code></pre>"},{"location":"style-guide/naming-convention/#additional-naming-conventions","title":"Additional Naming Conventions","text":"<p>Variables should be CamelCase:</p> <pre><code>myVariableName;\n</code></pre> <p>Classes should be PascalCase:</p> <pre><code>MyAwesomeClass;\n</code></pre> <p>Functions should be CamelCase:</p> <pre><code>isLie(cake);\n</code></pre> <p>Namespaces should be CamelCase and use periods as delimiters:</p> <pre><code>com.site.namespace;\n</code></pre> <ul> <li>JavaScript Recipes: A Problem-Solution Approach by Russ Ferguson, Keith Cirkel - pg: 133</li> </ul>"},{"location":"tools/node-version-manager/","title":"Node Version Manager","text":""},{"location":"tools/node-version-manager/#install-nvm","title":"Install NVM","text":"<ol> <li> <p>Install NVM using either <code>curl</code> or <code>wget</code>:</p> cURLwget <p>To install NVM using <code>curl</code>, run the following command:</p> <pre><code>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.2/install.sh | bash\n</code></pre> <p>To install NVM using <code>wget</code>, run the following command:</p> <pre><code>wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.2/install.sh | bash\n</code></pre> </li> <li> <p>Source the new instructions NVM added to <code>.bashrc</code> during the installation process. You can either exit and re-enter the shell console, or manually source your <code>.bashrc</code> file. This file is almost always located at the root of your home directory:</p> <pre><code>source ~/.bashrc\n</code></pre> </li> <li> <p>Confirm the version of NVM that is running with the following command:</p> <pre><code>nvm --version\n</code></pre> </li> </ol>"},{"location":"tools/node-version-manager/#reference","title":"Reference","text":"<ul> <li>node version manager nvm</li> </ul>"},{"location":"tools/overview/","title":"Overview","text":""},{"location":"tools/overview/#tools-overview","title":"Tools Overview","text":"<ul> <li>\ud83c\udf3f nvm</li> <li>\ud83d\udce6 npm</li> <li>\ud83e\uddf6 yarn</li> <li>\ud83d\ude80 pnpm</li> <li>\u26a1 vite</li> <li>\ud83d\udcdd eslint</li> </ul>"},{"location":"tools/npm/alias/","title":"Alias","text":"answers <p>npm <code>install</code> and <code>add</code> are aliases. The <code>--save</code> option is deprecated.</p> <p>Since NPM 5, packages are saved automatically; there is no --save option.</p>"},{"location":"tools/npm/alias/#npm-install","title":"npm-install","text":"<p>Install a package</p> <pre><code>npm install [&lt;package-spec&gt; ...]\n\naliases: add, i, in, ins, inst, insta, instal, isnt, isnta, isntal, isntall\n</code></pre>"},{"location":"tools/npm/alias/#question","title":"Question","text":"<p>npm add --global nx@latest. does npm has subcommand called \"add\". when i npm help it doesnt show me the \"add\" subcommand</p> <p>You're right to point out that when you run <code>npm help</code>, the <code>add</code> subcommand isn't listed directly. That's because <code>npm add</code> is an alias for <code>npm install</code> in more recent versions of npm (starting from v6). So, when you use <code>npm add &lt;package&gt;</code>, it's essentially doing the same thing as <code>npm install &lt;package&gt;</code>.</p> <p>If you look at the documentation for npm, <code>install</code> is the official command, but <code>add</code> has been introduced as a shorthand to make adding dependencies feel a bit more intuitive, especially in the context of adding packages to your project.</p> <p>So, if you want to install the latest version of <code>nx</code> globally, you can use either:</p> <pre><code>npm install --global nx@latest\n</code></pre> <p>or</p> <pre><code>npm add --global nx@latest\n</code></pre> <p>Both will work the same way!</p> <ul> <li>StackOverflow: Difference between 'npm add' and 'npm install --save'?</li> </ul>"},{"location":"tools/npm/example/","title":"Example","text":"<p>npm is a powerful package manager for JavaScript and Node.js, serving as the default package manager for the <code>Node.js</code> runtime environment. It includes a command-line client (npm) and an online repository (<code>npm registry</code>) for hosting and sharing JavaScript packages.</p> Example"},{"location":"tools/npm/example/#using-npm-flags-effectively-when-to-use-d-s-and-more","title":"Using npm Flags Effectively: When to Use <code>-D</code>, <code>-S</code>, and More","text":"<ol> <li> <p>-D or --save-dev:</p> <ul> <li>Purpose: Install packages needed only for development, such as build tools, testing libraries, and linters. This means the package will be listed under the devDependencies section in the <code>package.json</code> file.</li> <li>Usage: Use this flag when adding development tools that aren\u2019t needed in production.</li> <li>Example: <code>npm install -D jest eslint webpack</code></li> </ul> </li> <li> <p>No Flag or --save or -S:</p> <ul> <li>Purpose: Install packages needed for both <code>development</code> and <code>production</code>, such as frameworks and libraries. This is the default behavior when you run <code>npm install</code> without any flags. It installs the package as a dependency and adds it to the dependencies section in <code>package.json</code>.</li> <li>Usage: Use this default behavior for core dependencies required to run your application.</li> <li>Example: <code>npm install react express axios</code></li> </ul> </li> <li> <p>-g or --global:</p> <ul> <li>Purpose: Install packages globally for system-wide access, useful for CLI tools and utilities.</li> <li>Usage: Use this flag for tools you want to use from the command line across projects.</li> <li>Example: <code>npm install -g nodemon</code></li> </ul> </li> <li> <p>--exact or -E:</p> <ul> <li>Purpose: Install packages with an exact version, avoiding automatic updates.</li> <li>Usage: Use this for version consistency in your project.</li> <li>Example: <code>npm install lodash@4.17.21 -E</code></li> </ul> </li> <li> <p>--no-save:</p> <ul> <li>Purpose: Install a package temporarily without adding it to package.json.</li> <li>Usage: Use this for testing or one-time installs.</li> <li>Example: <code>npm install some-temporary-package --no-save</code></li> </ul> </li> <li> <p>--save-optional or -O:</p> <ul> <li>Purpose: Install packages that are not essential but provide additional functionality if available.</li> <li>Usage: Use this for optional dependencies that enhance your project but aren't critical.</li> <li>Example: <code>npm install fsevents -O</code></li> </ul> </li> <li> <p>--save-peer:</p> <ul> <li>Purpose: Install packages as peer dependencies, which are meant to work alongside a specific version of another package.</li> <li>Usage: Use this for packages that should be compatible with a specific version of a core dependency.</li> <li>Example: <code>npm install react@^17.0.0 -P</code></li> </ul> </li> </ol> <p>Choosing the right flag ensures that your dependencies are managed effectively, keeping your project organized and efficient.</p> <p>Summary</p> <ul> <li>Use -D for development dependencies.</li> <li>Use without any flag for production dependencies.</li> <li>Use -g for globally installed tools.</li> <li>Use -E for exact version installations.</li> <li>Use --no-save for temporary installations.</li> <li>Use -O for optional dependencies.</li> <li>Use -P for peer dependencies.</li> </ul>"},{"location":"tools/npm/example/#deep-dive-into-packagejson","title":"Deep Dive into <code>package.json</code>","text":"<p>The <code>package.json</code> file is central to any <code>Node.js</code> project, serving as the manifest for your project. It defines project metadata, dependencies, scripts, and configurations. Here\u2019s an in-depth look at the key sections and features of package.json:</p>"},{"location":"tools/npm/example/#scripts","title":"Scripts","text":"<ul> <li>Purpose: Defines custom commands that can be run using <code>npm run &lt;script-name&gt;</code>.</li> <li>Examples:</li> </ul> <pre><code>\"scripts\": {\n    \"start\": \"node index.js\",\n    \"test\": \"jest\",\n    \"build\": \"webpack --config webpack.config.js\"\n}\n</code></pre> <ul> <li>Custom Scripts: You can create scripts for various tasks like testing, building, linting, and more. Scripts can be executed with <code>npm run &lt;script-name&gt;</code>.</li> </ul>"},{"location":"tools/npm/example/#dependencies","title":"Dependencies","text":"<ul> <li>dependencies: Packages required for the application to run in production.</li> </ul> <pre><code>\"dependencies\": {\n    \"express\": \"^4.17.1\",\n    \"axios\": \"^0.21.1\"\n}\n</code></pre> <ul> <li>devDependencies: Packages needed only during development (e.g., testing frameworks, build tools).</li> </ul> <pre><code>\"devDependencies\": {\n    \"jest\": \"^26.6.3\",\n    \"webpack\": \"^5.24.4\"\n}\n</code></pre> <ul> <li>optionalDependencies: Packages that are not essential but provide additional features if available.</li> </ul> <pre><code>\"optionalDependencies\": {\n    \"fsevents\": \"^1.2.13\"\n}\n</code></pre> <ul> <li>peerDependencies: Packages that your project needs to work alongside a specific version of another package.</li> </ul> <pre><code>\"peerDependencies\": {\n    \"react\": \"^17.0.2\"\n}\n</code></pre>"},{"location":"tools/npm/example/#configurations","title":"Configurations","text":"<ul> <li>engines: Specifies which versions of Node.js and other engines your project is compatible with.</li> </ul> <pre><code>\"engines\": {\n    \"node\": \"&gt;=12.0.0\"\n}\n</code></pre> <ul> <li>browserslist: Defines the list of browsers that your project should support, used by tools like Babel and Autoprefixer.</li> </ul> <pre><code>\"browserslist\": [\n    \"&gt; 1%\",\n    \"last 2 versions\",\n    \"not dead\"\n]\n</code></pre>"},{"location":"tools/npm/example/#scripts-configuration-hooks","title":"Scripts Configuration <code>Hooks</code>","text":"<ul> <li>pre and post Hooks: Special scripts that run before or after a specific script. For example, <code>pretest</code> runs before test, and <code>postbuild</code> runs after build.</li> </ul> <pre><code>\"scripts\": {\n    \"pretest\": \"echo Preparing for tests...\",\n    \"test\": \"jest\",\n    \"posttest\": \"echo Tests completed!\"\n}\n</code></pre>"},{"location":"tools/npm/example/#package-metadata","title":"Package Metadata","text":"<ul> <li>main: The entry point of your project or package, usually the main file.</li> </ul> <pre><code>\"main\": \"index.js\"\n</code></pre>"},{"location":"tools/npm/example/#workspaces","title":"Workspaces","text":"<ul> <li> <p>Purpose: Manage multiple packages within a single repository. Useful for monorepos.</p> </li> <li> <p>Configuration:</p> </li> </ul> <pre><code>\"workspaces\": [\n  \"packages/*\"\n]\n</code></pre>"},{"location":"tools/npm/example/#summary","title":"Summary","text":"<ul> <li><code>package.json</code> is crucial for defining project metadata, managing dependencies, configuring scripts, and setting up project settings.</li> <li>Scripts help automate development workflows.</li> <li>Dependencies are categorized into <code>dependencies</code>, <code>devDependencies</code>, <code>optionalDependencies</code>, and <code>peerDependencies</code> based on their role.</li> <li>Configurations and metadata fields help define how your project behaves and integrates with other tools.</li> </ul> <p>Mastering <code>package.json</code> allows you to effectively manage your <code>Node.js</code> projects and streamline development processes.</p>"},{"location":"tools/npm/intro/","title":"Intro","text":""},{"location":"tools/npm/intro/#overview","title":"Overview","text":"<ul> <li> <p>:simple-npm:{ .lg .middle } npm (Node Package Manager)</p> <p>Comes pre-installed with Node.js, no additional setup required.</p> <p>:octicons-arrow-right-24: Reference</p> </li> <li> <p>:simple-yarn:{ .lg .middle } Yarn</p> <p>Excellent support for monorepos and managing multiple packages within a single repository.</p> <p>:octicons-arrow-right-24: Reference</p> </li> <li> <p>:simple-pnpm:{ .lg .middle } pnpm (Performant npm)</p> <p>Uses a unique approach of symlinking packages which saves space and speeds up installations.</p> <p>:octicons-arrow-right-24: Reference</p> </li> </ul>"},{"location":"tools/npm/intro/#decision-factors","title":"Decision Factors","text":"<ol> <li>Performance Needs: If speed and efficiency are crucial, consider Yarn or pnpm.</li> <li>Monorepo Management: For projects with multiple packages, Yarn or pnpm\u2019s workspace features are beneficial.</li> <li>Team Familiarity: Choose the package manager that your team is most comfortable with to minimize the learning curve.</li> <li>Ecosystem and Tooling: Consider the compatibility of the package manager with other tools and services you use.</li> </ol>"},{"location":"tools/npm/intro/#summary","title":"Summary","text":"<ul> <li>Use npm if you prefer the default, out-of-the-box solution with Node.js.</li> <li>Use Yarn if you need faster installs, stability, and good monorepo support.</li> <li>Use pnpm if you want the best performance and disk space efficiency, and are open to adopting newer tools.</li> </ul>"},{"location":"tools/npm/intro/#npm","title":"npm","text":"<pre><code>ninja@ninja-OptiPlex-3080:/$ npm list\n/\n\u2514\u2500\u2500 (empty)\n\nninja@ninja-OptiPlex-3080:/$ npm list --depth=0\n/\n\u2514\u2500\u2500 (empty)\n\nninja@ninja-OptiPlex-3080:/$ nx --version\nNx Version:\n- Local: Not found\n- Global: v20.3.3\n\nninja@ninja-OptiPlex-3080:/$ npm list -g --depth=0\n\n/home/ninja/.nvm/versions/node/v20.17.0/lib\n\u251c\u2500\u2500 corepack@0.29.3\n\u251c\u2500\u2500 npm@10.8.2\n\u251c\u2500\u2500 nx@20.3.3\n\u2514\u2500\u2500 pnpm@9.14.2\n</code></pre> To clarify <ul> <li>Local packages (in a specific project folder) can be listed with <code>npm list</code>.</li> <li>Global packages are stored separately from the local project and need to be listed with <code>npm list -g</code>.</li> </ul> To check global packages <p>You can use this command to list all globally installed packages:</p> <pre><code>npm list -g --depth=0\n</code></pre> <ul> <li><code>npm list --depth=0</code>: This command shows the top-level dependencies in the current directory, but it only shows packages listed in the <code>node_modules</code> of the current working directory. Since you ran it at the root directory <code>/</code>, which likely doesn't have a <code>node_modules</code> folder or a local <code>package.json</code> file, it shows as empty.</li> </ul>"},{"location":"tools/pnpm/advanced/","title":"Advanced","text":""},{"location":"tools/pnpm/advanced/#pnpm-overview","title":"pnpm overview","text":"Installation<pre><code>npm install -g pnpm\n</code></pre> Scaffolding Your First Vite Project<pre><code>pnpm create vite\n</code></pre> <pre><code># Install pnpm globally if not installed\nnpm install -g pnpm\n\n# Create the project with React and TypeScript template\npnpm create vite my-react-ts-app --template react-ts\n\n# Navigate into the project directory\ncd my-react-ts-app\n\n# Install dependencies\npnpm install\n\n# Start the development server\npnpm run dev\n\n# Build the production version of the app\npnpm run build\n\n# Preview the production build\npnpm run preview\n</code></pre> 1. <code>npm list</code> Shows Local Dependencies, Not Global <p>The <code>npm list</code> command by default shows the dependencies for your current project (i.e., the local <code>node_modules</code> in the current directory). If you installed <code>pnpm</code> globally, it will not show up in the output of npm list unless you specify the global flag.</p> <p>Solution:</p> <p>To list globally installed packages with <code>npm</code>, use the following command:</p> <pre><code>npm list -g --depth=0\n</code></pre> <p>This will show all globally installed packages (including <code>pnpm</code>) at the top level.</p>"},{"location":"tools/pnpm/advanced/#pnpm-a-comprehensive-guide","title":"PNPM: A Comprehensive Guide","text":"<p>PNPM (pronounced as \"Pee-En-Pee-Em\") is a fast, disk space-efficient package manager for JavaScript, specifically designed to handle the installation of dependencies for Node.js projects. It is an alternative to other package managers like npm (Node Package Manager) and Yarn, offering better performance and disk space utilization.</p> <p>Let's break it down step by step, from basic concepts to advanced usage.</p> Tip What is PNPM?Why Do We Need PNPM?When to Use PNPM?When Not to Use PNPM <ul> <li>Package Manager: Like npm and Yarn, PNPM is a tool that helps you manage libraries and dependencies in your JavaScript or Node.js projects.</li> <li>Efficiency: What sets PNPM apart is its focus on optimizing disk space usage and speeding up dependency installation, especially in large projects.</li> <li>Global Store: Instead of downloading a package separately for each project, PNPM uses a global store where it keeps downloaded packages. It then links them to each project, minimizing duplication and reducing disk usage.</li> </ul> <ol> <li> <p>Performance:</p> <p>PNPM installs packages faster than npm and Yarn, especially in large projects. This is because it stores packages globally, avoiding redundant downloads.</p> </li> <li> <p>Disk Space Efficiency:</p> <p>PNPM uses hard links to share common dependencies between different projects. If two projects use the same package (with the same version), PNPM won\u2019t download it twice. Instead, it creates a link to the existing package in the global store, which saves disk space.</p> </li> <li> <p>Consistency:</p> <p>PNPM strictly enforces a deterministic node_modules structure. This means the dependency tree is always the same, even if you install packages on different machines. This can help avoid \"it works on my machine\" issues.</p> </li> <li> <p>Better Dependency Resolution:</p> <p>PNPM uses a strict algorithm for resolving dependencies, meaning that if a package needs a specific version of a dependency, it will only install that version (no more \"hoisting\" to higher levels of the dependency tree, which can cause issues).</p> </li> </ol> <ul> <li> <p>Performance and Efficiency Needs:</p> <p>If you\u2019re working on a large project or managing multiple projects that share dependencies, PNPM can dramatically reduce installation times and disk usage.</p> </li> <li> <p>Modern JavaScript Ecosystem:</p> <p>For frontend and backend projects, especially when you're managing monorepos or large-scale applications, PNPM\u2019s optimization features come in handy.</p> </li> <li> <p>If You're Tired of NPM's Performance and Dependency Issues:</p> <p>If you've encountered slow npm install times or inconsistencies in dependency resolutions (e.g., issues caused by hoisting in node_modules), PNPM can solve many of these problems.</p> </li> </ul> <ol> <li> <p>Legacy Projects:</p> <p>If you're working on a project that requires using npm or Yarn due to compatibility or organizational constraints, it might not be worth switching to PNPM unless there's a clear need for the benefits it offers.</p> </li> <li> <p>Third-Party Tools/Plugins:</p> <p>Some tools and integrations are still optimized for npm or Yarn. In rare cases, certain third-party tools might not support PNPM well, though this is becoming less of an issue over time.</p> </li> </ol> <p>The major benefit of using pnpm over npm is its <code>efficient disk space usage</code> and <code>performance optimization</code>, particularly when dealing with large projects or <code>monorepos</code>.</p> Difference between <code>install</code> and <code>add</code> in pnpm <p>In pnpm, both <code>add</code> and <code>install</code> are commands related to managing dependencies in a project, but they serve different purposes:</p> 1. pnpm add2. pnpm installKey Differences: <p>The pnpm add command is used to add a new dependency to your project. This will install the dependency and update the pnpm-lock.yaml and package.json files accordingly.</p> <ul> <li> <p>Usage:</p> <ul> <li><code>pnpm add &lt;package&gt;</code> \u2013 Adds a package as a regular dependency.</li> <li><code>pnpm add &lt;package&gt;@&lt;version&gt;</code> \u2013 Adds a specific version of a package.</li> <li><code>pnpm add &lt;package&gt; --dev</code> \u2013 Adds a package as a development dependency.</li> <li><code>pnpm add &lt;package&gt; --save-peer</code> \u2013 Adds a package as a peer dependency.</li> </ul> </li> <li> <p>Example:</p> <pre><code>pnpm add lodash\n</code></pre> <p>This will add <code>lodash</code> as a dependency to your <code>package.json</code> and install it into the <code>node_modules</code> folder.</p> </li> </ul> <p>The pnpm install command is used to install all dependencies listed in the package.json file. It will install both regular and development dependencies that are already specified in your project, without adding or modifying the package.json.</p> <ul> <li> <p>Usage:</p> <ul> <li><code>pnpm install</code> \u2013 Installs all dependencies in the current project.</li> <li><code>pnpm install --prod</code> \u2013 Installs only production dependencies (ignores dev dependencies).</li> <li><code>pnpm install &lt;package&gt;</code> \u2013 Installs a specific package, if you want to install without adding it to the <code>package.json</code> (essentially a one-off installation).</li> </ul> </li> <li> <p>Example:</p> <pre><code>pnpm install\n</code></pre> <p>This will install all dependencies defined in your <code>package.json</code> into the <code>node_modules</code> folder.</p> </li> </ul> <ul> <li><code>pnpm add</code>: Used to add a new dependency (and update package.json), and install it.</li> <li><code>pnpm install</code>: Used to install the dependencies already defined in package.json, including any changes to the lockfile.</li> </ul> <ul> <li> <p>In summary:</p> <ul> <li>Use <code>pnpm add</code> when you want to add a new package to the project.</li> <li>Use <code>pnpm install</code> when you want to install all the dependencies that are already listed in <code>package.json</code>.</li> </ul> </li> </ul>"},{"location":"tools/pnpm/advanced/#how-to-use-pnpm","title":"How to Use PNPM","text":"Example 1. Installation2. Basic Usage3. Advanced Usage <p>You can install PNPM globally using npm or Yarn</p> <ul> <li> <p>Via npm:</p> <pre><code>npm install -g pnpm\n</code></pre> </li> <li> <p>Via Yarn:</p> <pre><code>npm install -g pnpm\n</code></pre> </li> </ul> <p>After installation, you can check the version to confirm it worked:</p> <pre><code>pnpm --version\n</code></pre> <ul> <li> <p>Initialize a new project (<code>package.json</code>): To start using PNPM in a new project, run the following:</p> <pre><code>pnpm init\n</code></pre> <p>This will create a <code>package.json</code> file, just like npm init.</p> </li> <li> <p>Install Dependencies: To install all dependencies listed in the <code>package.json</code> file:</p> <pre><code>pnpm install\n</code></pre> <p>PNPM will install dependencies into the <code>node_modules</code> folder using hard links from the global store.</p> </li> <li> <p>Install a Package (One-time install): To install a specific package and add it to <code>dependencies</code> in <code>package.json</code></p> <pre><code>pnpm add &lt;package-name&gt;\n</code></pre> <p>You can also install development dependencies by using <code>-D</code>:</p> <pre><code>pnpm add &lt;package-name&gt; -D\n</code></pre> </li> <li> <p>Install a Specific Version of a Package:</p> <pre><code>pnpm add &lt;package-name&gt;@&lt;version&gt;\n</code></pre> <p>For example:</p> <pre><code>pnpm add lodash@4.17.21\n</code></pre> </li> <li> <p>Uninstall a Package: To remove a package:</p> <pre><code>pnpm remove &lt;package-name&gt;\n</code></pre> </li> </ul> <ul> <li> <p>Workspaces / Monorepos: PNPM supports workspaces, which is useful when you're managing multiple packages in a single repository (a monorepo). You can set up multiple packages and install them all with one command:</p> <ol> <li>Create a <code>pnpm-workspace.yaml</code> file in the root directory.</li> <li> <p>List your packages in that file:</p> <pre><code>packages:\n    - 'packages/*'\n</code></pre> </li> <li> <p>Inside your packages, use <code>pnpm</code> install to install dependencies across the entire workspace.</p> </li> </ol> <p>PNPM automatically links dependencies between your packages within the monorepo, which is a big advantage when working with large codebases that share dependencies.</p> </li> <li> <p>Run Scripts: You can use PNPM to run scripts defined in your <code>package.json</code>:</p> <pre><code>pnpm run &lt;script-name&gt;\n</code></pre> </li> <li> <p>Global Packages: To install packages globally using PNPM, use:</p> <pre><code>pnpm add -g &lt;package-name&gt;\n</code></pre> <p>This will install the package globally, and you can run it directly from the command line.</p> </li> <li> <p>Auditing Dependencies: To check for security vulnerabilities in your project\u2019s dependencies:</p> <pre><code>pnpm audit\n</code></pre> </li> <li> <p>Linking Local Packages: If you're developing multiple local packages and need to link them, you can use the <code>pnpm link</code> command to create symlinks between them:</p> <pre><code>pnpm link &lt;package-name&gt;\n</code></pre> </li> <li> <p>Custom Store: You can customize where PNPM stores its global store. For example, you can set a custom directory by adding this to your <code>.npmrc</code> or <code>pnpmfile.js</code>:</p> <pre><code>pnpm store-dir /path/to/store\n</code></pre> </li> </ul>"},{"location":"tools/pnpm/advanced/#comparing-pnpm-with-npm-and-yarn","title":"Comparing PNPM with NPM and Yarn","text":"Feature PNPM NPM Yarn Speed Fast (due to global store and hard links) Slower (redownloads dependencies for every project) Faster than npm, but not as fast as PNPM Disk Usage Low (global store, hard links) High (duplicates dependencies across projects) Lower than npm but higher than PNPM Deterministic Install Yes (strict dependency tree) No (hoisting can cause issues) Yes Workspaces Support Yes No (requires third-party tool) Yes CLI Commands Similar to npm Standard npm commands Similar to npm Community Growing rapidly Largest (since it's the default package manager for Node.js) Large, but smaller than npm"},{"location":"tools/pnpm/advanced/#conclusion","title":"Conclusion","text":"<p>PNPM is a fast, efficient, and modern alternative to npm and Yarn, offering unique advantages in performance, disk space usage, and dependency management. It's especially beneficial for large-scale projects, monorepos, or teams looking for a more efficient way of managing Node.js dependencies.</p> <p>When adopting PNPM, the transition is straightforward if you're familiar with npm or Yarn. The key advantages \u2014 faster installs, less disk usage, and strict dependency resolution \u2014 can be highly beneficial for large projects, while its simplicity and ease of use ensure it\u2019s a good fit for individual developers as well.</p>"},{"location":"tools/pnpm/advanced/#vite-overview","title":"vite overview","text":"<p>Vite, being a fast and flexible build tool, has a rich ecosystem of plugins that extend its functionality for various tasks such as code transformation, asset handling, testing, and more. Below are some of the commonly used types of plugins in the Vite ecosystem:</p>"},{"location":"tools/pnpm/advanced/#1-official-vite-plugins","title":"1. Official Vite Plugins","text":"<p>These plugins are developed and maintained by the Vite team itself and are included in the core ecosystem:</p> <ul> <li> <p>@vitejs/plugin-vue   Provides support for Vue 3 in Vite. This plugin handles .vue file parsing, component support, and more.</p> </li> <li> <p>@vitejs/plugin-react   Adds React Fast Refresh and support for React files (.jsx/.tsx).</p> </li> <li> <p>@vitejs/plugin-vue-jsx   Adds support for Vue 3 JSX syntax.</p> </li> <li> <p>@vitejs/plugin-legacy   Provides support for legacy browsers by generating polyfills and transforming code accordingly.</p> </li> <li> <p>vite-plugin-svelte   Adds support for Svelte, enabling the compilation of .svelte files.</p> </li> <li> <p>vite-plugin-static-copy   A plugin that allows you to copy static assets (files or directories) into the build output.</p> </li> </ul>"},{"location":"tools/pnpm/advanced/#2-css-related-plugins","title":"2. CSS-related Plugins","text":"<ul> <li> <p>vite-plugin-sass-dts   Generates <code>.d.ts</code> TypeScript declaration files for SASS variables, mixins, and functions.</p> </li> <li> <p>vite-plugin-postcss   Allows custom PostCSS configuration for your project.</p> </li> <li> <p>vite-plugin-sass   Enhances Vite's Sass/SCSS support.</p> </li> <li> <p>vite-plugin-tailwind   Optimizes Tailwind CSS configuration and integration.</p> </li> <li> <p>vite-plugin-stylus   Adds Stylus support for Vite projects.</p> </li> </ul>"},{"location":"tools/pnpm/advanced/#3-typescriptjsxtsx-related-plugins","title":"3. TypeScript/JSX/TSX-related Plugins","text":"<ul> <li> <p>vite-plugin-checker   Provides TypeScript type checking and ESLint checking during development.</p> </li> <li> <p>vite-plugin-tsconfig-paths   Automatically resolves TypeScript paths based on the tsconfig.json paths configuration.</p> </li> <li> <p>vite-plugin-swc   A plugin that uses swc (Speedy Web Compiler) to transpile JavaScript and TypeScript instead of Babel.</p> </li> <li> <p>vite-plugin-prettier   Integrates Prettier into the Vite build process to format files automatically.</p> </li> </ul>"},{"location":"tools/pnpm/advanced/#4-development-tools-features","title":"4. Development Tools &amp; Features","text":"<ul> <li> <p>vite-plugin-env-compatible   Provides compatibility for environment variables in Vite, ensuring that .env files and variables are correctly handled.</p> </li> <li> <p>vite-plugin-serve   Serves static files during development or production using Vite\u2019s dev server.</p> </li> <li> <p>vite-plugin-progress   Displays a progress bar in the terminal during the build process.</p> </li> <li> <p>vite-plugin-mock   Allows for easy integration of mock APIs during development.</p> </li> <li> <p>vite-plugin-html   Extends HTML handling in Vite with various enhancements, including template injections.</p> </li> </ul>"},{"location":"tools/pnpm/advanced/#5-code-splitting-optimization-plugins","title":"5. Code Splitting &amp; Optimization Plugins","text":"<ul> <li> <p>vite-plugin-prerender   Allows you to prerender specific pages during the build process, often used for static site generation.</p> </li> <li> <p>vite-plugin-import   Optimizes imports and reduces bundle size by automatically removing unused code or assets from dependencies.</p> </li> <li> <p>vite-plugin-purgecss   Integrates PurgeCSS with Vite to remove unused CSS and reduce the final bundle size.</p> </li> <li> <p>vite-plugin-bundle-visualizer   Visualizes your final bundle with detailed stats about how much space different dependencies take up.</p> </li> </ul>"},{"location":"tools/pnpm/advanced/#6-image-asset-related-plugins","title":"6. Image &amp; Asset-related Plugins","text":"<ul> <li> <p>vite-plugin-imagemin   Optimizes images in your project to reduce their size without losing quality.</p> </li> <li> <p>vite-plugin-assets   Handles static assets, including images, fonts, etc., and can bundle them efficiently in the final build.</p> </li> <li> <p>vite-plugin-optimize-images   Similar to the imagemin plugin but with additional features to optimize the handling of images.</p> </li> </ul>"},{"location":"tools/pnpm/advanced/#7-backend-api-related-plugins","title":"7. Backend &amp; API-related Plugins","text":"<ul> <li> <p>vite-plugin-graphql   Provides GraphQL-related tooling, such as schema generation and query handling.</p> </li> <li> <p>vite-plugin-cloudflare-workers   Allows you to deploy your Vite project as a Cloudflare Worker.</p> </li> <li> <p>vite-plugin-netlify   Configures your Vite project for optimal deployment on Netlify.</p> </li> </ul>"},{"location":"tools/pnpm/advanced/#8-testing-plugins","title":"8. Testing Plugins","text":"<ul> <li> <p>vite-plugin-test   A plugin for running unit tests, integration tests, or end-to-end tests with Vite.</p> </li> <li> <p>vite-plugin-jest   Integrates Jest testing framework into Vite projects for unit testing.</p> </li> <li> <p>vite-plugin-vitest   Adds Vitest, a fast unit test runner built for Vite, to your project.</p> </li> </ul>"},{"location":"tools/pnpm/advanced/#9-framework-specific-plugins","title":"9. Framework-Specific Plugins","text":"<ul> <li> <p>vite-plugin-nuxt   Adds support for Nuxt.js features in Vite.</p> </li> <li> <p>vite-plugin-next   Adds support for Next.js features, such as React Server Components, in Vite-based projects.</p> </li> <li> <p>vite-plugin-markdown   Processes Markdown files and allows importing them into your project as .md files.</p> </li> </ul>"},{"location":"tools/pnpm/advanced/#10-miscellaneous-plugins","title":"10. Miscellaneous Plugins","text":"<ul> <li> <p>vite-plugin-svgr   This plugin enables importing SVG files as React components, which is especially useful for projects with heavy SVG use.</p> </li> <li> <p>vite-plugin-mdx   Adds support for MDX (Markdown with embedded JSX) in Vite.</p> </li> <li> <p>vite-plugin-webfont-dl   Automatically downloads and serves web fonts during the build process.</p> </li> <li> <p>vite-plugin-eslint   Automatically runs ESLint in the development environment to lint files on save.</p> </li> </ul>"},{"location":"tools/pnpm/advanced/#11-custom-plugins","title":"11. Custom Plugins","text":"<ul> <li>vite-plugin-custom   If you're developing a Vite plugin for your specific use case, you can write your own custom plugin by using the Vite plugin API, which allows you to hook into Vite\u2019s lifecycle events.</li> </ul>"},{"location":"tools/pnpm/advanced/#conclusion_1","title":"Conclusion","text":"<p>The Vite plugin ecosystem is vast and continues to grow. By selecting the right plugins for your project, you can tailor Vite to suit your specific needs, whether it's optimizing your build, adding support for additional frameworks, or improving your development experience.</p> <p>If you\u2019re looking for specific plugins for your project, the Vite Plugin Catalog is a great place to start!</p> Summary of Must-Have Plugins for Your Setup React: <ul> <li>@vitejs/plugin-react \u2013 Essential for React projects.</li> <li>vite-plugin-checker \u2013 TypeScript and ESLint integration during development.</li> <li>vite-plugin-tsconfig-paths \u2013 Ensures TypeScript path aliases work seamlessly in Vite.</li> <li>vite-plugin-swc (Optional for speed) \u2013 Uses swc to speed up TypeScript compilation.</li> <li>vite-plugin-svgr (Optional) \u2013 If using SVGs as React components.</li> <li>vite-plugin-eslint (Optional) \u2013 For continuous linting during development.</li> </ul>"},{"location":"tools/pnpm/advanced/#typescript-overview","title":"TypeScript overview","text":"<ul> <li>Basic types and type annotations</li> <li>Functions, arrays, and objects</li> <li>Classes, inheritance, and generics</li> <li>Modules and TypeScript configuration</li> </ul> <pre><code>After 4 Hours: Next Steps\n\nBy the end of the 4 hours, you'll have a solid understanding of the following concepts:\n\n-   Basic types and type annotations\n-   Functions, arrays, and objects\n-   Classes, inheritance, and generics\n-   Modules and TypeScript configuration\n</code></pre>"},{"location":"tools/pnpm/advanced/#reference","title":"Reference","text":"<ul> <li>pnpm: Official Docs</li> <li>vite: Official Docs</li> </ul>"},{"location":"tools/pnpm/create/","title":"create command","text":""},{"location":"tools/pnpm/create/#create-command","title":"Create Command","text":"official <p>pnpm create</p> <p>Create a project from a <code>create-*</code> or <code>@foo/create-*</code> starter kit.</p> Example<pre><code>pnpm create react-app my-app\n</code></pre>"},{"location":"tools/pnpm/create/#question","title":"Question","text":"<p>pnpm dlx create-next-app my-next-app is same as pnpm create next-app my-next-app</p> <p>The commands <code>pnpm dlx create-next-app my-next-app</code> and <code>pnpm create next-app my-next-app</code> are functionally equivalent because <code>pnpm</code> create internally uses <code>pnpm dlx</code> to execute project scaffolding tools like <code>create-next-app</code>. Both commands download and execute the <code>create-next-app</code> package without installing it globally or adding it to your project dependencies.</p> Key Details <ol> <li> <p><code>pnpm create next-app</code>:</p> <ul> <li>A shorthand for running <code>pnpm dlx create-next-app</code>.</li> <li>Easier and more concise for creating projects.</li> <li> <p>Example:</p> <pre><code>pnpm create next-app my-next-app\n</code></pre> </li> </ul> </li> <li> <p><code>pnpm dlx create-next-app</code>:</p> <ul> <li>Explicitly invokes the dlx command, which stands for \"Download and Execute.\"</li> <li>Useful if you want to specify additional options or understand the underlying process.</li> <li> <p>Example:</p> <pre><code>pnpm dlx create-next-app my-next-app\n</code></pre> </li> </ul> </li> </ol> When to Use Each <ul> <li> <p>Use <code>pnpm create next-app</code> for simplicity.</p> </li> <li> <p>Use <code>pnpm dlx create-next-app</code> if you need more control, such as specifying a specific version of the scaffolding tool:</p> <pre><code>pnpm dlx create-next-app@14.0.4 my-next-app\n</code></pre> </li> </ul> <p>Ultimately, both commands achieve the same result, and the choice depends on your preference for shorthand or explicit syntax.</p>"},{"location":"tools/pnpm/create/#reference","title":"Reference","text":"<ul> <li>Official, pnpm create</li> </ul>"},{"location":"tools/pnpm/guide/","title":"guide","text":""},{"location":"tools/pnpm/guide/#guide","title":"Guide","text":"<p>With Create React App (CRA) officially deprecated, here are the best alternatives for setting up React projects, tailored to different use cases:</p>"},{"location":"tools/pnpm/guide/#1-vite","title":"1. Vite","text":"<ul> <li> <p>Best for: Single-page applications (SPAs), fast development, and modern tooling.</p> </li> <li> <p>Why: Vite is built on esbuild, offering lightning-fast startup times, hot module replacement (HMR), and optimized builds.</p> </li> <li> <p>How to use:</p> <pre><code>pnpm create vite my-app --template react\n</code></pre> <p>Here, you can specify templates like <code>react</code>, <code>vue</code>, <code>svelte</code>, etc., depending on your needs.</p> </li> <li> <p>Pros: Fast builds, minimal configuration, TypeScript support.</p> </li> <li> <p>Cons: No built-in server-side rendering (SSR).</p> </li> </ul>"},{"location":"tools/pnpm/guide/#2-nextjs","title":"2. Next.js","text":"<ul> <li> <p>Best for: Production-ready apps, SEO optimization, server-side rendering (SSR), and static site generation (SSG).</p> </li> <li> <p>Why: Next.js provides out-of-the-box SSR and SSG, making it ideal for scalable and SEO-friendly applications.</p> </li> <li> <p>How to use:</p> <pre><code>pnpm create next-app my-app\n</code></pre> <p>This sets up a Next.js project with all necessary configurations.</p> </li> <li> <p>Pros: SSR, SSG, great for dynamic and content-heavy apps.</p> </li> <li> <p>Cons: Overkill for small SPAs.</p> </li> </ul>"},{"location":"tools/pnpm/guide/#3-gatsby","title":"3. Gatsby","text":"<ul> <li> <p>Best for: Content-heavy websites like blogs or marketing sites.</p> </li> <li> <p>Why: Gatsby focuses on static site generation with efficient data handling and SEO features.</p> </li> <li> <p>How to use:</p> <pre><code>pnpm create gatsby my-app\n</code></pre> </li> <li> <p>Pros: Optimized for static sites, excellent plugin ecosystem.</p> </li> <li> <p>Cons: Not ideal for real-time dynamic content.</p> </li> </ul>"},{"location":"tools/pnpm/guide/#4-preact","title":"4. Preact","text":"<ul> <li> <p>Best for: Lightweight React-like apps with minimal overhead.</p> </li> <li> <p>Why: Preact offers a similar API to React but is much smaller in size, making it perfect for performance-critical projects.</p> </li> <li> <p>How to use:</p> <pre><code>pnpm create vite my-app --template preact\n</code></pre> </li> <li> <p>Pros: Small bundle size, React compatibility.</p> </li> <li> <p>Cons: Smaller ecosystem compared to React.</p> </li> </ul>"},{"location":"tools/pnpm/guide/#5-svelte","title":"5. Svelte","text":"<ul> <li> <p>Best for: High-performance apps with minimal JavaScript overhead.</p> </li> <li> <p>Why: Svelte compiles components into efficient JavaScript at build time, resulting in smaller bundles and faster runtime performance.</p> </li> <li> <p>How to use:</p> <pre><code>pnpm create vite my-app --template svelte\n</code></pre> </li> <li> <p>Pros: Excellent performance and simplicity.</p> </li> <li> <p>Cons: Smaller ecosystem and fewer libraries than React.</p> </li> </ul>"},{"location":"tools/pnpm/guide/#6-nx","title":"6. Nx","text":"<ul> <li> <p>Best for: Monorepos and enterprise-level applications.</p> </li> <li> <p>Why: Nx offers tools for managing multiple projects in a single repository with advanced build optimizations.</p> </li> <li> <p>How to use:</p> <pre><code>pnpm create nx-workspace my-workspace\n</code></pre> </li> <li> <p>Pros: Great for managing large-scale projects with shared libraries.</p> </li> <li> <p>Cons: Steeper learning curve.</p> </li> </ul>"},{"location":"tools/pnpm/guide/#summary-table-of-alternatives","title":"Summary Table of Alternatives","text":"Alternative Best For Key Features Vite SPAs Fast builds, HMR Next.js Production apps, SEO SSR, SSG Gatsby Content-heavy websites Static site generation Preact Lightweight React-like apps Small size, React API Svelte High-performance apps Compiles to efficient JS Nx Monorepos Build optimizations <p>These alternatives provide modern tooling and better performance compared to CRA. Choose based on your project requirements!</p> <p>isnt the cra is decprecate now</p> <p>Yes, Create React App (CRA) is officially deprecated as of February 14, 2025. The React team announced that CRA will no longer be actively developed or recommended for new projects. While it will remain in maintenance mode and support React 19, it won't receive new features or improvements. Developers are strongly encouraged to migrate to modern tools like Vite, Next.js, Remix, or Expo for React development.</p> Reasons for CRA's Deprecation <ol> <li>Performance and Flexibility Issues: CRA lacks advanced features like routing, optimized data-fetching strategies, and code splitting, which are essential for modern applications</li> <li>No Active Maintainers: CRA hasn't been maintained actively since 2021, making it less viable for current development needs</li> <li>Rise of Modern Frameworks: Tools like Vite, Next.js, and Remix offer better developer experience and are more suited for production-grade applications</li> </ol> Alternatives <ul> <li>Vite: Recommended for simple single-page applications.</li> <li>Next.js: Ideal for full-stack React applications.</li> <li>Remix or Gatsby: Suitable for web apps with complex data requirements or static sites</li> </ul> <p>If you're starting a new project, using CRA is not advised due to its limitations and lack of future updates.</p> <p>i have an idea to start my my online project business called assignment tracker where assigment doer can signup and create assigment title and update theier progress. and users can signup and can see their assigment progress and can chat. is there any software like this before research it. and suggest me.</p>"},{"location":"tools/pnpm/intro/","title":"Intro","text":"<p>pnpm (Performant npm):</p> <ul> <li>Focuses on efficient disk space usage and speed.</li> <li>Shares dependencies across projects without duplicating them.</li> <li>Uses a <code>pnpm-lock.yaml</code> file to lock dependencies.</li> <li>Command examples: <code>pnpm install</code>, <code>pnpm update</code>, <code>pnpm remove</code>.</li> </ul>"},{"location":"tools/pnpm/intro/#installation","title":"Installation","text":"reacttypescript <pre><code>pnpm add antd\npnpm add @ant-design/icons\n\npnpm install @reduxjs/toolkit react-redux react react-router-dom\n\npnpm create vite my-vue-app --template react\npnpm create vite . --template react\n</code></pre> <pre><code>pnpm add @reduxjs/toolkit\n</code></pre> <pre><code>pnpm add redux-persist\n</code></pre> <pre><code>pnpm add axios\n</code></pre> <pre><code>pnpm add react-redux @reduxjs/toolkit @types/react-redux\n</code></pre>"},{"location":"tools/vite/example/","title":"Example","text":"<p>Vite has built-in support for environment variables, and you don't need to install the dotenv package manually.</p> <p>Here\u2019s how you can set it up step-by-step:</p> <p>1. Create <code>.env</code> File</p> <p>In the root of your project, create a <code>.env</code> file (if it doesn't exist already). In this file, you can define environment variables like this:</p> <pre><code>VITE_REACT_APP_BASE_API_URL=https://api.example.com\nVITE_REACT_APP_BLOG_API_URL=https://blog.example.com\nVITE_REACT_APP_TEST_API_URL=https://test.example.com\n</code></pre> <ul> <li>Note: Vite requires that environment variable names start with <code>VITE_</code> to expose them to the frontend (this is different from CRA, where you use <code>REACT_APP_</code>).</li> </ul> <p>2. Using Axios with Environment Variables</p> <p>Since you\u2019re using Axios, the example code you've written should work fine after making the changes to access the variables via <code>import.meta.env</code>. For example:</p> <pre><code>import axios from \"axios\";\nimport axiosConfig from \"./axiosConfig\";\n\nconst axiosInstance = {\n  base: axios.create({\n    baseURL: import.meta.env.VITE_REACT_APP_BASE_API_URL,\n    ...axiosConfig,\n  }),\n  blog: axios.create({\n    baseURL: import.meta.env.VITE_REACT_APP_BLOG_API_URL,\n    ...axiosConfig,\n  }),\n  test: axios.create({\n    baseURL: import.meta.env.VITE_REACT_APP_TEST_API_URL,\n    ...axiosConfig,\n  }),\n};\n\nexport default axiosInstance;\n</code></pre> Summary <ol> <li>Define environment variables in the .env file with the <code>VITE_</code> prefix.</li> <li>Access those variables using <code>import.meta.env</code> in your code.</li> <li>Restart your Vite dev server after changes to <code>.env</code>.</li> <li>Use these environment variables in your Axios setup, Redux store, or any other part of your code.</li> </ol> <p>Summary of Key Vite Features:</p> <ul> <li><code>import.meta.env</code>: Access environment variables during build time.</li> <li>Hot Module Replacement (HMR): Fast, real-time updates during development.</li> <li>ESBuild: Super-fast bundling and minification during development.</li> <li>Code Splitting &amp; Dynamic Imports: Load code as needed for faster performance.</li> <li>Static Assets: Serve images, fonts, and other assets directly from the <code>public</code> directory.</li> <li>TypeScript/JSX Support: Out-of-the-box support for TypeScript, JSX, and TSX.</li> <li>Rollup for Production: Efficient, production-ready bundling.</li> <li>Custom Plugins: Extend Vite with plugins for different use cases.</li> </ul>"},{"location":"tools/vite/example/#question","title":"Question","text":"<p>so where do we need dotnet package ?</p> <p>In the context of a React project using Vite, Redux Toolkit, Axios, and pnpm, you do not need the dotenv package.</p> <p>Why you don't need dotenv with Vite:</p> <ul> <li>Vite has built-in support for environment variables and automatically loads variables from <code>.env</code> files.</li> <li>You can use environment variables in Vite by prefixing them with <code>VITE_</code>, and they will be available at build time through <code>import.meta.env</code>.</li> <li>This means that you don't have to manually use dotenv to load environment variables, because Vite handles that for you.</li> </ul> <p>When would you need the dotenv package?</p> <p>The dotenv package is generally used in Node.js back-end environments or if you're working with custom Webpack configurations (outside of Vite). It allows you to load environment variables from a <code>.env</code> file into your Node.js process during server-side code execution.</p> <p>Here\u2019s a basic use case for dotenv in a Node.js project:</p> <p>1. Install dotenv:</p> <pre><code>npm install dotenv\n</code></pre> <p>2. Create <code>.env</code>file in the root of the project:</p> env<pre><code>DB_HOST=localhost\nDB_PORT=5432\n</code></pre> <p>3. Use <code>dotenv</code> in your Node.js code:</p> <pre><code>require(\"dotenv\").config(); // This will load the environment variables\n\nconsole.log(process.env.DB_HOST); // Should print \"localhost\"\n</code></pre> Key Points: <ul> <li>React + Vite + Frontend: Use <code>VITE_</code> prefixed variables in your <code>.env</code> file. No need for dotenv because Vite automatically processes <code>.env</code> files and makes variables available through <code>import.meta.env</code>.</li> <li>Node.js (Backend) or Custom Webpack: Use dotenv to load environment variables in the backend or if you're using custom configurations (e.g., if you're manually running a server that needs environment variables).</li> </ul> <p>In Summary:</p> <p>Since you're working with Vite in a frontend React app, you do not need the dotenv package. Just ensure your environment variables are prefixed with <code>VITE_</code>, and Vite will handle them automatically. Use <code>import.meta.env</code> to access them in your React components. The dotenv package is unnecessary for your specific setup.</p>"},{"location":"tools/vite/intro/","title":"Intro","text":""},{"location":"tools/vite/intro/#overview","title":"Overview","text":"<p>Vite is primarily needed during the development phase of a project, not in production. Here\u2019s why:</p> Abstract DevelopmentProductionConclusion <ul> <li>Fast Build and HMR: Vite provides a fast and efficient development server with Hot Module Replacement (HMR), allowing you to see changes in real-time without a full page reload.</li> <li>Modern JavaScript Support: Vite leverages native ES modules in the browser for faster builds and efficient module loading during development.</li> <li>Optimized for Development: Vite is optimized to improve the development experience with features like fast refresh, instant feedback, and efficient bundling.</li> </ul> <ul> <li>Build Process: Vite is used to build the final optimized bundle of your application. It handles tasks like minification, code splitting, and other optimizations to prepare your code for production deployment.</li> <li>Static Assets Handling: Vite can process and optimize static assets such as images, stylesheets, and other resources during the build process.</li> </ul> <ul> <li>In Development: You need Vite to run your development server, utilize HMR, and benefit from its fast build times and modern JavaScript support.</li> <li>In Production: Vite is used to build and optimize your application, but it is not required to run the application in a production environment. The built and optimized output from Vite is what gets deployed, not Vite itself.</li> </ul> <p>Therefore, you should install Vite as a <code>development dependency</code> using the -D flag:</p> <pre><code>npm install -D vite\n</code></pre> <p>This ensures that Vite is only used during the development phase and build process, not in the production environment.</p>"},{"location":"tools/vite/intro/#env-files","title":".env Files","text":"<p>Vite uses dotenv to load additional environment variables from the following files in your environment directory:</p> <pre><code>.env                # loaded in all cases\n.env.local          # loaded in all cases, ignored by git\n.env.[mode]         # only loaded in specified mode\n.env.[mode].local   # only loaded in specified mode, ignored by git\n</code></pre> Env Loading Priorities <p>An env file for a specific mode (e.g. <code>.env.production</code>) will take higher priority than a generic one (e.g. <code>.env</code>).</p> <p>In addition, environment variables that already exist when Vite is executed have the highest priority and will not be overwritten by <code>.env</code> files. For example, when running <code>VITE_SOME_KEY=123 vite build</code>.</p> <p><code>.env</code> files are loaded at the start of Vite. Restart the server after making changes.</p> <p>Loaded env variables are also exposed to your client source code via <code>import.meta.env</code> as strings.</p> <p>To prevent accidentally leaking env variables to the client, only variables prefixed with <code>VITE_</code> are exposed to your Vite-processed code. e.g. for the following env variables:</p> .env<pre><code>VITE_SOME_KEY=123\nDB_PASSWORD=foobar\n</code></pre> <p>Only <code>VITE_SOME_KEY</code> will be exposed as <code>import.meta.env.VITE_SOME_KEY</code> to your client source code, but <code>DB_PASSWORD</code> will not.</p> <pre><code>console.log(import.meta.env.VITE_SOME_KEY); // \"123\"\nconsole.log(import.meta.env.DB_PASSWORD); // undefined\n</code></pre> Env parsing <p>As shown above, <code>VITE_SOME_KEY</code> is a number but returns a string when parsed. The same would also happen for boolean env variables. Make sure to convert to the desired type when using it in your code.</p> <p>Also, Vite uses dotenv-expand to expand variables written in env files out of the box. To learn more about the syntax, check out their docs.</p> <p>Note that if you want to use <code>$</code> inside your environment value, you have to escape it with <code>\\</code>.</p>"},{"location":"tools/vite/intro/#scaffolding-your-first-vite-project","title":"Scaffolding Your First Vite Project","text":"Compatibility Note <p>Vite requires <code>Node.js</code> version 18+ or 20+. However, some templates require a higher Node.js version to work, please upgrade if your package manager warns about it.</p> NPMYarnPNPMBun <pre><code>$ npm create vite@latest\n</code></pre> <pre><code>$ yarn create vite\n</code></pre> <pre><code>$ pnpm create vite\n</code></pre> <pre><code>$ bun create vite\n</code></pre> <p>Then follow the prompts!</p> <p>You can also directly specify the project name and the template you want to use via additional command line options. For example, to scaffold a Vite + Vue project, run:</p> <pre><code># npm 7+, extra double-dash is needed:\nnpm create vite@latest my-vue-app -- --template vue\n\n# yarn\nyarn create vite my-vue-app --template vue\n\n# pnpm\npnpm create vite my-vue-app --template vue\n\n# bun\nbun create vite my-vue-app --template vue\n</code></pre> <p>You can use <code>.</code> for the project name to scaffold in the current directory.</p>"},{"location":"tools/vite/intro/#supported-template","title":"Supported Template","text":"<p>The supported template presets are:</p> JavaScript TypeScript vanilla vanilla-ts vue vue-ts react react-ts preact preact-ts lit lit-ts svelte svelte-ts solid solid-ts qwik qwik-ts"},{"location":"tools/vite/intro/#viteconfigjs","title":"vite.config.js","text":"Example ViteVite <pre><code>import { defineConfig } from 'vite';\nimport vue from '@vitejs/plugin-vue'; // Example plugin for Vue\nimport path from 'path';\n\nexport default defineConfig({\n    // Basic server configuration\n    server: {\n        port: 3000, // Specify the port number\n        open: true, // Automatically open the app in the default browser\n    },\n\n    // Aliases\n    resolve: {\n        alias: {\n        '@': path.resolve(__dirname, 'src'), // Simplify import paths\n        },\n    },\n\n    // Plugins\n    plugins: [\n        vue(), // Add plugins here\n    ],\n\n    // CSS Preprocessing\n    css: {\n        preprocessorOptions: {\n            scss: {\n                additionalData: `@import \"@/styles/global.scss\";`, // Example for SCSS\n            },\n        },\n    },\n\n    // Build options\n    build: {\n        outDir: 'dist', // Output directory for the build\n        sourcemap: true, // Enable source maps for debugging\n        rollupOptions: {\n            output: {\n                // Customize the output settings\n                chunkFileNames: 'js/[name]-[hash].js',\n                entryFileNames: 'js/[name]-[hash].js',\n                assetFileNames: 'assets/[name]-[hash].[ext]',\n            },\n        },\n    },\n\n    // Environment Variables\n    define: {\n        'process.env': process.env, // Use environment variables\n    },\n});\n</code></pre> <pre><code>// vite.config.js\nimport { defineConfig } from 'vite';\n\nexport default defineConfig({\n    // Basic server configuration\n    server: {\n        port: 3000, // set the port to 3000\n        host: 'localhost', // set the host\n        https: false, // enable HTTPS\n        open: true, // automatically open the app in the browser\n        cors: true, // enable CORS\n        proxy: {\n            // configure proxy rules\n            '/api': {\n                target: 'http://localhost:5000',\n                changeOrigin: true,\n                rewrite: (path) =&gt; path.replace(/^\\/api/, '')\n            }\n        }\n    }\n});\n</code></pre>"},{"location":"tools/vite/intro/#to-automatically-open-your-app-in-the-browser","title":"To automatically open your app in the browser","text":"<p>To automatically open your app in the browser when running npm run dev, you need to configure your <code>vite.config.js</code> file appropriately and ensure your <code>package.json</code> has the correct script.</p> <pre><code>// vite.config.js\nimport { defineConfig } from \"vite\";\n\nexport default defineConfig({\n  // Basic server configuration\n  server: {\n    open: true, // automatically open the app in the default browser\n    port: 3000, // you can also set the port if needed\n  },\n});\n</code></pre> <p>Updating <code>package.json</code></p> <p>In your package.json, make sure you have a script defined to start the Vite development server. It typically looks like this:</p> <pre><code>// package.json\n{\n  \"scripts\": {\n    \"dev\": \"vite\"\n  }\n}\n</code></pre> <p>Running the Development Server</p> <p>With the above configurations in place, running npm run dev will start the Vite development server and automatically open your app in the default web browser.</p> <pre><code>npm run dev\n</code></pre>"},{"location":"tools/vite/intro/#handling-jsxtsx-in-vite","title":"Handling JSX/TSX in Vite","text":"<p>Vite needs plugins to handle frameworks like React, Vue, etc. For React, you would typically use the <code>@vitejs/plugin-react plugin</code>.</p> <p>Install Necessary Plugins</p> <pre><code>npm install @vitejs/plugin-react\n</code></pre> <p>Update <code>vite.config.js</code> with Plugins</p> <p>Here is a complete example of <code>vite.config.js</code> for a React project:</p> <pre><code>import { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\n\nexport default defineConfig({\n  plugins: [react()],\n  resolve: {\n    alias: {\n      \"@\": path.resolve(__dirname, \"src\"), // Optional alias\n    },\n    extensions: [\".js\", \".jsx\", \".ts\", \".tsx\"], // Ensure Vite resolves these extensions\n  },\n  server: {\n    port: 3000,\n    open: true,\n  },\n  build: {\n    outDir: \"dist\",\n    sourcemap: true,\n  },\n});\n</code></pre> <p>Summary</p> <ol> <li>Rename your files to have the appropriate extensions (<code>.jsx</code> for JavaScript with JSX, <code>.tsx</code> for TypeScript with JSX).</li> <li>Install necessary plugins and configure Vite to recognize these extensions.</li> <li>Update your <code>vite.config.js</code> to include plugins and resolve the appropriate extensions.</li> </ol> <p>By following these steps, you should resolve the internal server error related to invalid JS syntax in Vite.</p>"},{"location":"tools/vite/intro/#reference","title":"Reference","text":"<ul> <li>vitejs.dev</li> </ul>"},{"location":"tools/vite/mode/","title":"Mode","text":""},{"location":"tools/vite/mode/#environment-variables-and-mode","title":"Environment Variables and Mode","text":"<p>Vite also supports different <code>.env</code> files for different environments. For example, you might have:</p> <ul> <li><code>.env</code>: Default settings.</li> <li><code>.env.production</code>: Production-specific settings.</li> <li><code>.env.development</code>: Development-specific settings.</li> <li><code>.env.staging</code>: Staging-specific settings.</li> </ul> <p>When Vite is running in a specific mode (like <code>production</code> or <code>development</code>), it will automatically load the corresponding <code>.env</code> file for that mode.</p> <p>For example:</p> <ul> <li>In development mode, it will use <code>.env</code> and <code>.env.development</code>.</li> <li>In production mode, it will use <code>.env</code> and <code>.env.production</code>.</li> </ul>"},{"location":"tools/vite/mode/#example-workflow-with-modes","title":"Example Workflow with Modes","text":"Example FilesCommands <pre><code>.env\n.env.development\n.env.production\n.env.staging\n</code></pre> <ul> <li>Development: <code>vite</code> or <code>vite --mode development</code></li> <li>Production: <code>vite build</code> or <code>vite build --mode production</code></li> <li>Staging: <code>vite --mode staging</code></li> </ul> .env.staging<pre><code>VITE_API_URL=https://staging-api.example.com\n</code></pre> <pre><code>console.log(import.meta.env.VITE_API_URL); // https://staging-api.example.com (when staging mode is used)\n</code></pre>"},{"location":"tools/vite/mode/#question","title":"Question","text":"<p>so do we need to create all the modes .env files or what. and show me examples</p> <p>No, you do not need to create all the mode-specific <code>.env</code> files. Vite will automatically use the <code>.env</code> file as a fallback, and you can define environment-specific variables in files such as <code>.env.production</code>, <code>.env.development</code>, or <code>.env.staging</code> only when necessary.</p> <p>Here's a breakdown of how to use <code>.env</code> files with different modes and examples for each situation:</p> <p>1. Default <code>.env</code> File (Common for all modes)</p> <p>The <code>.env</code> file contains environment variables that apply to all modes (development, production, staging, etc.). You always have this file in the root of your project if you want to set common variables.</p> .env<pre><code>VITE_API_URL=https://api.example.com\nVITE_APP_NAME=MyViteApp\n</code></pre> <p>This file is always loaded, and its variables are available in all modes unless overridden by mode-specific files.</p> <p>2. Mode-Specific <code>.env</code> Files (Optional)</p> <p>You can create mode-specific <code>.env</code> files to override the common settings in <code>.env</code>. These files are only loaded if Vite is running in the corresponding mode.</p> Example .env.development.env.production.env.staging <p>This file will be used when running <code>vite</code> (dev server), which defaults to <code>development</code> mode.</p> .env.development<pre><code>VITE_API_URL=http://localhost:3000\nVITE_APP_NAME=MyViteApp (Development)\n</code></pre> <p>This file will be used when running <code>vite build</code>, which defaults to <code>production</code> mode.</p> .env.production<pre><code>VITE_API_URL=https://api.production.com\nVITE_APP_NAME=MyViteApp (Production)\n</code></pre> <p>This file can be used when running a custom mode, like <code>vite --mode staging</code>.</p> .env.staging<pre><code>VITE_API_URL=https://api.staging.com\nVITE_APP_NAME=MyViteApp (Staging)\n</code></pre>"},{"location":"tools/vite/mode/#reference","title":"Reference","text":"<ul> <li>Env Variables and Modes </li> </ul>"},{"location":"tools/vite/proxy/","title":"Proxy","text":""},{"location":"tools/vite/proxy/#custom-server-configurations-and-proxying-in-vite","title":"Custom Server Configurations and Proxying in Vite","text":"<p>Vite\u2019s Custom Server Configurations and Proxying features allow you to configure your development server and handle requests to external services (such as APIs, databases, or backend servers) more efficiently during the development phase. This can be particularly useful when you're developing a frontend app that interacts with a backend or an external API.</p> <p>Here's an overview of both features, and when and why you might need them.</p> <p>Vite's proxy helps by acting as a middleman (the helper) between your game (frontend) and the server (backend). It makes sure your game can get the data it needs without running into the CORS rules, making the communication smoother and easier!</p>"},{"location":"tools/vite/under-the-hood/","title":"Under the Hood","text":"<p>Vite uses both dotenv and dotenv-expand under the hood. Here's why:</p> <ul> <li><code>dotenv</code>: Loads environment variables from a <code>.env</code> file into <code>process.env</code>.</li> <li><code>dotenv-expand</code>: Expands and resolves variable references (e.g., <code>${VAR}</code>) within <code>.env</code> files.</li> </ul>"},{"location":"tools/vite/under-the-hood/#overview","title":"Overview","text":"Abstract dotenvdotenv-expand <ul> <li> <p>What It Does:</p> <p>The <code>dotenv</code> package loads environment variables from <code>.env</code> files into <code>process.env</code>.</p> </li> <li> <p>Why Vite Uses It:</p> <p>Vite relies on <code>dotenv</code> to support managing environment-specific configurations. This enables you to define variables in <code>.env</code>, <code>.env.&lt;mode&gt;</code>, or <code>.env.&lt;mode&gt;.local</code> and have them automatically available in your app when a specific mode is used.</p> </li> </ul> <p>For example:</p> <pre><code>VITE_API_URL=https://api.example.com\n</code></pre> <p>This gets loaded into <code>process.env</code> and exposed to the app as <code>import.meta.env.VITE_API_URL</code>.</p> <ul> <li> <p>What It Does:</p> <p>The dotenv-expand package extends dotenv by adding support for variable interpolation, allowing one environment variable to reference another.</p> env<pre><code>BASE_URL=https://api.example.com\nVITE_API_URL=${BASE_URL}/v1\n</code></pre> <p>Here, <code>VITE_API_URL</code> will be expanded to <code>https://api.example.com/v1</code>.</p> </li> <li> <p>Why Vite Uses It:</p> <p>Vite includes dotenv-expand to make it easier to manage complex environment setups, especially when multiple variables depend on a shared base value. Without this feature, you'd need to manually construct these dependent variables in your code.</p> </li> </ul>"},{"location":"tools/vite/under-the-hood/#how-vite-uses-them-together","title":"How Vite Uses Them Together","text":"<ol> <li> <p>Loading Environment Variables: Vite uses dotenv to load .env files into memory for the current mode.</p> <p>For example:</p> <pre><code>.env\n.env.development\n.env.production\n</code></pre> </li> <li> <p>Expanding Variables: If there are references to other variables in the <code>.env</code> files, dotenv-expand resolves those references.</p> </li> <li> <p>Exposing Variables to the App: Only variables prefixed with <code>VITE_</code> are exposed to the client-side app via <code>import.meta.env</code>. The rest remain in <code>process.env</code> for server-side usage.</p> </li> </ol>"},{"location":"tools/vite/under-the-hood/#benefits-of-using-both","title":"Benefits of Using Both","text":"<ul> <li>Flexibility: Handles both simple and complex environment setups.</li> <li>Consistency: Ensures that <code>.env</code> files are loaded in a predictable order (<code>.env</code>, <code>.env.&lt;mode&gt;</code>, <code>.env.local</code>).</li> <li>Ease of Use: Developers can leverage variable interpolation for dynamic configurations.</li> </ul>"},{"location":"tools/vite/under-the-hood/#example","title":"Example","text":"env<pre><code>BASE_API=https://api.example.com\nVITE_API_URL=${BASE_API}/v1\nVITE_APP_NAME=MyApp\n</code></pre> <pre><code>console.log(import.meta.env.VITE_API_URL); // Outputs: https://api.example.com/v1\nconsole.log(import.meta.env.VITE_APP_NAME); // Outputs: MyApp\n</code></pre>"},{"location":"tools/vite/under-the-hood/#usage-in-application","title":"Usage in Application","text":"<pre><code>project/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 utils/\n\u2502   \u2514\u2500\u2500 App.tsx\n\u251c\u2500\u2500 .env\n\u251c\u2500\u2500 .env.development\n\u251c\u2500\u2500 .env.production\n\u251c\u2500\u2500 vite.config.ts\n\u251c\u2500\u2500 package.json\n\u2514\u2500\u2500 tsconfig.json\n</code></pre> <p>Environment Files</p> .env (shared across all modes)<pre><code>APP_NAME=My Vite App\nBASE_API_URL=https://api.example.com\n</code></pre> .env.development<pre><code>VITE_API_URL=${BASE_API_URL}/dev\nVITE_LOG_LEVEL=debug\nVITE_FEATURE_TOGGLE=true\n</code></pre> .env.production<pre><code>VITE_API_URL=${BASE_API_URL}/prod\nVITE_LOG_LEVEL=error\nVITE_FEATURE_TOGGLE=false\n</code></pre>"},{"location":"tools/vite/under-the-hood/#best-practices-for-large-applications","title":"Best Practices for Large Applications","text":"<ol> <li> <p>Centralize Configs in a Utility: Instead of accessing <code>import.meta.env</code> everywhere, create a utility to centralize environment variables:</p> src/utils/config.ts<pre><code>export const Config = {\n  apiUrl: import.meta.env.VITE_API_URL,\n  appName: import.meta.env.VITE_APP_NAME,\n  logLevel: import.meta.env.VITE_LOG_LEVEL,\n  featureToggle: import.meta.env.VITE_FEATURE_TOGGLE === \"true\",\n};\n</code></pre> Usage<pre><code>import { Config } from \"./utils/config\";\n\nconsole.log(Config.apiUrl); // Access variables via a single source\n</code></pre> </li> <li> <p>Use Variable Interpolation (<code>dotenv-expand</code>): In the <code>.env</code> files, use <code>${VAR}</code> to reduce duplication and make configurations maintainable.</p> </li> <li> <p>Secure Sensitive Data: Avoid exposing sensitive data (like API keys) by not prefixing such variables with <code>VITE_</code>. They\u2019ll stay in <code>process.env</code> and not be exposed to the browser.</p> </li> <li> <p>Testing Configurations: Add <code>.env.test</code> for testing environments if needed.</p> </li> </ol> <p>Output Example (Development Mode)</p> <p>When you run <code>pnpm dev</code>, the app will log:</p> <pre><code>App Name: My Vite App\nAPI URL: https://api.example.com/dev\nLog Level: debug\n</code></pre> <p>This setup is scalable, maintainable, and fully leverages the power of <code>dotenv</code> and <code>dotenv-expand</code> with Vite in React.</p>"},{"location":"tools/yarn/intro/","title":"Intro","text":"<ul> <li>Developed by Facebook as an alternative to npm.</li> <li>Focuses on speed, reliability, and deterministic dependency resolution.</li> <li>Uses a <code>yarn.lock</code> file to lock dependencies.</li> <li>Command examples: <code>yarn add</code>, <code>yarn upgrade</code>, <code>yarn remove</code>.</li> </ul>"},{"location":"blog/archive/2025/","title":"2025","text":""},{"location":"blog/archive/2024/","title":"2024","text":""},{"location":"blog/page/2/","title":"Index","text":""},{"location":"blog/page/3/","title":"Index","text":""},{"location":"blog/archive/2024/page/2/","title":"2024","text":""},{"location":"blog/archive/2024/page/3/","title":"2024","text":""}]}