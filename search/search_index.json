{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to JSExpert","text":""},{"location":"#welcome-to-jsexpert","title":"Welcome to JSExpert","text":"<ul> <li>React - Basic Theoretical Concepts</li> <li>React Redux Immutability Guide</li> <li>Immutable Data with Immer and React setState</li> <li>Immer Resources</li> </ul> <ul> <li>egghead.io</li> <li>tutsnode.org</li> </ul> <pre><code>import * as msw from \"msw\";\n\n// Logging the Module\nconsole.log(msw);\n\n//list all the method names\nconsole.log(Object.keys(msw));\n</code></pre> <ul> <li>Holy Grail</li> </ul>"},{"location":"#react","title":"React","text":""},{"location":"blog/","title":"Index","text":""},{"location":"blog/#blog","title":"Blog","text":""},{"location":"blog/2024/06/02/advanced-tips-tricks-antd-design-table/","title":"Advanced tips tricks antd design table","text":"<p>When working with Ant Design (AntD) and particularly with its Table component, there are several advanced tips and tricks you can use to enhance your tables and improve their functionality. Here are some advanced techniques:</p>","tags":["antd","react"]},{"location":"blog/2024/06/02/advanced-tips-tricks-antd-design-table/#overview","title":"Overview","text":"","tags":["antd","react"]},{"location":"blog/2024/06/02/advanced-tips-tricks-antd-design-table/#1-custom-cell-rendering","title":"1. Custom Cell Rendering","text":"<p>You can use the <code>render</code> function to create complex cell contents. For example, you can include custom components, conditionally format data, or add interactive elements.</p> Basic <pre><code>{\n    title: 'Status',\n    render: (text, record) =&gt; (\n        &lt;span style={{ color: record.status === 'Active' ? 'green' : 'red' }}&gt;\n        {text}\n        &lt;/span&gt;\n    ),\n}\n</code></pre>","tags":["antd","react"]},{"location":"blog/2024/06/02/advanced-tips-tricks-antd-design-table/#2-expandable-rows","title":"2. Expandable Rows","text":"<p>You can add expandable rows to show additional details when a row is clicked.</p> Basic <pre><code>const expandable = {\n    expandedRowRender: record =&gt; &lt;p&gt;{record.details}&lt;/p&gt;,\n    rowExpandable: record =&gt; record.details != null,\n};\n\n// In Table component\n&lt;Table expandable={expandable} columns={columns} dataSource={data} /&gt;\n</code></pre>","tags":["antd","react"]},{"location":"blog/2024/06/02/advanced-tips-tricks-antd-design-table/#3-custom-sorting-and-filtering","title":"3. Custom Sorting and Filtering","text":"<p>Define custom sorting and filtering logic by using the <code>sorter</code> and <code>filters</code> properties in column definitions.</p> Basic <pre><code>{\n    title: 'Age',\n    dataIndex: 'age',\n\n    sorter: (a, b) =&gt; a.age - b.age,\n\n    sortDirections: ['descend', 'ascend'],\n\n    filters: [\n        { text: '20-30', value: '20-30' },\n        { text: '30-40', value: '30-40' }\n    ],\n\n    onFilter: (value, record) =&gt; {\n        const [min, max] = value.split('-').map(Number);\n        return record.age &gt;= min &amp;&amp; record.age &lt;= max;\n    },\n}\n</code></pre>","tags":["antd","react"]},{"location":"blog/2024/06/02/advanced-tips-tricks-antd-design-table/#4-pagination-and-infinite-scrolling","title":"4. Pagination and Infinite Scrolling","text":"<p>Configure pagination with custom settings or implement infinite scrolling to handle large datasets.</p> Basic <pre><code>// Pagination configuration\nconst pagination = {\n    pageSize: 10,\n    total: data.length,\n    onChange: page =&gt; console.log('Page:', page),\n};\n\n// Infinite scrolling\nconst handleScroll = e =&gt; {\n    if (e.target.scrollHeight - e.target.scrollTop === e.target.clientHeight) {\n        // Load more data\n    }\n};\n\n&lt;Table pagination={pagination} onScroll={handleScroll} columns={columns} dataSource={data} /&gt;\n</code></pre>","tags":["antd","react"]},{"location":"blog/2024/06/02/advanced-tips-tricks-antd-design-table/#5-cell-merging","title":"5. Cell Merging","text":"<p>You can merge cells in a table using the <code>rowSpan</code> and <code>colSpan</code> properties in the <code>render</code> function.</p> Basic <pre><code>{\n    title: 'Name',\n    render: (text, record, index) =&gt; ({\n        children: text,\n        props: {\n            rowSpan: index === 0 ? 2 : 0,\n            colSpan: 2,\n        },\n    }),\n}\n</code></pre>","tags":["antd","react"]},{"location":"blog/2024/06/02/advanced-tips-tricks-antd-design-table/#6-dynamic-column-visibility","title":"6. Dynamic Column Visibility","text":"<p>Allow users to toggle column visibility dynamically using state management.</p> Basic <pre><code>const [visibleColumns, setVisibleColumns] = useState(['name', 'age']);\n\nconst handleVisibilityChange = (key) =&gt; {\n    setVisibleColumns(prev =&gt; prev.includes(key) ? prev.filter(col =&gt; col !== key) : [...prev, key]);\n};\n\nconst columns = [\n    {\n        title: 'Name',\n        dataIndex: 'name',\n        key: 'name',\n        ...visibleColumns.includes('name') &amp;&amp; { visible: true },\n    },\n    {\n        title: 'Age',\n        dataIndex: 'age',\n        key: 'age',\n        ...visibleColumns.includes('age') &amp;&amp; { visible: true },\n    },\n];\n\n// Render toggle buttons for columns\n{['name', 'age'].map(key =&gt; (\n    &lt;Button key={key} onClick={() =&gt; handleVisibilityChange(key)}&gt;\n        Toggle {key}\n    &lt;/Button&gt;\n))}\n\n// Table with dynamic columns\n&lt;Table columns={columns} dataSource={data} /&gt;\n</code></pre>","tags":["antd","react"]},{"location":"blog/2024/06/02/advanced-tips-tricks-antd-design-table/#7-row-selection","title":"7. Row Selection","text":"<p>Customize row selection behavior to support multiple selection modes or custom checkboxes.</p> Basic <pre><code>const rowSelection = {\n    onChange: (selectedRowKeys, selectedRows) =&gt; {\n        console.log('Selected rows:', selectedRows);\n    },\n    getCheckboxProps: record =&gt; ({\n        disabled: record.name === 'Disabled User', // Disable selection for specific rows\n    }),\n};\n\n&lt;Table rowSelection={rowSelection} columns={columns} dataSource={data} /&gt;\n</code></pre>","tags":["antd","react"]},{"location":"blog/2024/06/02/advanced-tips-tricks-antd-design-table/#8-custom-filter-dropdowns","title":"8. Custom Filter Dropdowns","text":"<p>Create custom filter dropdowns for more advanced filtering options.</p> Basic <pre><code>import { Menu, Dropdown, Input } from 'antd';\nimport { DownOutlined } from '@ant-design/icons';\n\nconst filterDropdown = ({\n    setSelectedKeys,\n    selectedKeys,\n    confirm,\n    clearFilters,\n}) =&gt; (\n    &lt;div style={{ padding: 8 }}&gt;\n        &lt;Input\n            placeholder=\"Search...\"\n            value={selectedKeys[0]}\n            onChange={e =&gt; setSelectedKeys(e.target.value ? [e.target.value] : [])}\n            onPressEnter={() =&gt; confirm()}\n            style={{ marginBottom: 8, display: 'block' }}\n        /&gt;\n        &lt;Space&gt;\n            &lt;Button\n                type=\"primary\"\n                onClick={() =&gt; confirm()}\n                icon={&lt;SearchOutlined /&gt;}\n                size=\"small\"\n                style={{ width: 90 }}\n            &gt;\n                Search\n            &lt;/Button&gt;\n            &lt;Button onClick={() =&gt; clearFilters()} size=\"small\" style={{ width: 90 }}&gt;\n                Reset\n            &lt;/Button&gt;\n        &lt;/Space&gt;\n    &lt;/div&gt;\n);\n\n{\n    title: 'Name',\n    dataIndex: 'name',\n    filterDropdown: filterDropdown,\n    onFilter: (value, record) =&gt; record.name.toLowerCase().includes(value.toLowerCase()),\n}\n</code></pre>","tags":["antd","react"]},{"location":"blog/2024/06/02/advanced-tips-tricks-antd-design-table/#9-tree-data","title":"9. Tree Data","text":"<p>Render hierarchical data with nested rows.</p> Basic <pre><code>const treeData = [\n    {\n        title: 'Parent 1',\n        key: '0-0',\n        children: [\n            {\n                title: 'Child 1',\n                key: '0-0-0',\n            },\n            {\n                title: 'Child 2',\n                key: '0-0-1',\n            },\n        ],\n    },\n];\n\n&lt;Table treeData={treeData} columns={columns} /&gt;\n</code></pre>","tags":["antd","react"]},{"location":"blog/2024/06/02/advanced-tips-tricks-antd-design-table/#10-custom-toolbar-and-actions","title":"10. Custom Toolbar and Actions","text":"<p>Add custom toolbar actions like exporting, printing, or custom buttons.</p> Basic <pre><code>const toolbar = (\n    &lt;div&gt;\n        &lt;Button onClick={() =&gt; console.log('Export')}&gt;Export&lt;/Button&gt;\n        &lt;Button onClick={() =&gt; console.log('Print')}&gt;Print&lt;/Button&gt;\n    &lt;/div&gt;\n);\n\n// Render toolbar above the table\n&lt;&gt;\n    {toolbar}\n    &lt;Table columns={columns} dataSource={data} /&gt;\n&lt;/&gt;\n</code></pre> <p>Using these advanced tips and tricks can help you leverage the full power of Ant Design\u2019s Table component and tailor it to meet your specific needs and use cases.</p>","tags":["antd","react"]},{"location":"blog/2024/08/12/api-call-in-parent-or-child/","title":"API Call in Parent or Child","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/08/12/api-call-in-parent-or-child/#api-call-in-parent-or-child","title":"API Call in Parent or Child","text":"<p>In your provided code, the choice of where to call the API for the LogList data depends on your specific use case.</p> <p>Here\u2019s a breakdown of both approaches:</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/12/api-call-in-parent-or-child/#1-api-call-in-the-parent-component","title":"1. API Call in the Parent Component","text":"ExampleWhen to Use <pre><code>import React, { useState, useEffect } from \"react\";\nimport { Tabs } from \"antd\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { actionForCircularPlanningLog } from \"services/redux/Reference/action\"; // Adjust this import\nimport LogList from \"./LogList\";\nimport CheckListContainer from \"./CheckListContainer\"; // Assuming this is defined elsewhere\n\nconst { TabPane } = Tabs;\n\nconst MyComponent = () =&gt; {\n    const [activeKey, setActiveKey] = useState(\"1\");\n    const dispatch = useDispatch();\n    const { loading, data } = useSelector((state) =&gt; state.reference);\n\n    const handleTabChange = (key) =&gt; {\n        setActiveKey(key);\n        if (key === \"4\") {\n            dispatch(actionForCircularPlanningLog()); // Fetch data when switching to the Log List tab\n        }\n    };\n\n    return (\n        &lt;Tabs activeKey={activeKey} onChange={handleTabChange} type=\"line\"&gt;\n            &lt;TabPane tab=\"Contact Details\" key=\"1\"&gt;\n                {contactDetails()} {/* Assuming contactDetails is a function */}\n            &lt;/TabPane&gt;\n            &lt;TabPane tab=\"Tender Checklist\" key=\"2\"&gt;\n                &lt;CheckListContainer referenceId={getDetails?.referenceId} /&gt;\n            &lt;/TabPane&gt;\n            &lt;TabPane tab=\"Log List\" key=\"4\"&gt;\n                {activeKey === \"4\" &amp;&amp; &lt;LogList loading={loading} data={data} /&gt;}\n            &lt;/TabPane&gt;\n        &lt;/Tabs&gt;\n    );\n};\n\nexport default MyComponent;\n</code></pre> <ul> <li>If the data is relevant to multiple child components.</li> <li>If you want to control the loading and error states centrally.</li> <li>If the data should be fetched when switching to the \"Log List\" tab.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/12/api-call-in-parent-or-child/#2-api-call-in-the-loglist-child-component","title":"2. API Call in the LogList Child Component","text":"ImplementationWhen to Use <pre><code>import React, { useEffect } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { actionForCircularPlanningLog } from \"services/redux/Reference/action\"; // Adjust this import\nimport { Table } from \"antd\";\n\nconst LogList = () =&gt; {\n    const dispatch = useDispatch();\n    const { loading, data } = useSelector((state) =&gt; state.reference);\n\n    useEffect(() =&gt; {\n        dispatch(actionForCircularPlanningLog()); // Fetch data when LogList mounts\n    }, [dispatch]);\n\n    const columns = [\n        // Define your columns here\n    ];\n\n    const dataSource = (data || []).map((log) =&gt; ({\n        key: log.id,\n        remarks: log.remarks,\n        creationTime: log.creationTime,\n    }));\n\n    return (\n        &lt;Table\n            dataSource={dataSource}\n            loading={loading}\n            columns={columns}\n            pagination={false}\n        /&gt;\n    );\n};\n\nexport default LogList;\n</code></pre> <ul> <li>If the <code>LogList</code> is only responsible for displaying its own data.</li> <li>If the data is not needed by any other component.</li> <li>If you want the <code>LogList</code> to handle its own loading and error states independently.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/12/api-call-in-parent-or-child/#summary","title":"Summary","text":"<ul> <li>Use the Parent Component for API Calls when the data is shared or needs to be controlled globally, particularly when changing tabs.</li> <li>Use the Child Component for API Calls when the component is self-contained and only needs to manage its own data.</li> </ul> <p>In your case, if the <code>LogList</code> is the only component needing the log data, you can opt for the child component approach. If you plan on expanding the functionality or sharing data between components, fetching it in the parent might be the better route.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/","title":"Application Structure for React.js","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#application-structure-for-reactjs","title":"Application Structure for React.js","text":"<p>React.js itself does not provide a guideline on structuring projects but does suggest a few commonly used approaches.</p> <p>At the high level, you can group files in a React application in two ways:</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#1-group-by-feature","title":"1. Group by feature","text":"<ul> <li>Create folders for every application module, feature, or route.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#2-group-by-file-type","title":"2.  Group by file type","text":"<ul> <li>Create folders for different types of files.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#group-by-module-feature-or-route","title":"Group by Module, Feature, or Route","text":"<p>In this case, the file structure would mirror the business model or the application flow. For example, if you have an ecommerce application, you will have folders for product, productlist, checkout, etc. The CSS, JSX components, tests, subcomponents, or helper libraries explicitly required for the product module reside in the product folder:</p> <pre><code>common/\n    Avatar.js\n    Avatar.css\n    ErrorUtils.js\n    ErrorUtils.test.js\n\nproduct/\n    index.js\n    product.css\n    price.js\n    product.test.js\n\ncheckout/\n    index.js\n    checkout.css\n    checkout.test.js\n</code></pre> <p>The advantage of grouping files by feature is that if there is a change to the module, all the affected files are colocated in the same folder, and the change gets localized to a specific part of the code.</p> <p>The disadvantage is common components, logic, or styles used across modules should be identified periodically to avoid repetition and promote consistency and reuse.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#group-by-file-type","title":"Group by File Type","text":"<p>In this type of grouping, you would create different folders for CSS, components, test files, images, libraries, etc. Thus, logically related files would reside in different folders based on the file type:</p> <pre><code>css/\n    global.css\n    checkout.css\n    product.css\n\nlib/\n    date.js\n    currency.js\n    gtm.js\n\npages/\n    product.js\n    productlist.js\n    checkout.js\n</code></pre> <p>The advantages of this approach are:</p> <ul> <li>You have a standard structure that you can reuse across projects.</li> <li>Newer team members with little knowledge of the application-specific logic can still find files for something like styles or tests.</li> <li>Common components (such as date pickers) and styles imported in different routes or modules can be changed once to ensure that the effect is seen across the application.</li> </ul> <p>The disadvantages are:</p> <ul> <li>A change in logic for a specific module would likely require changes in files across different folders.</li> <li>As the number of features in the application grows, the number of files in different folders would increase, making it difficult to find a specific file.</li> </ul> <p>Either of these approaches could be easy to set up for small- to mid-sized applications with a small number of files (50 to 100) per folder. For larger projects, however, you may want to go for a hybrid approach based on the logical structure of your application. Let us look at some of the possibilities.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#hybrid-grouping-based-on-domain-and-common-components","title":"Hybrid Grouping Based on Domain and Common Components","text":"<p>Here you would group all common components required across the application in a Components folder and all application flow-specific routes or features in a domain folder (the name could be domain, pages, or routes). Every folder can have subfolders for specific components and related files:</p> <pre><code>css/\n    global.css\ncomponents/\n    User/\n        profile.js\n        profile.test.js\n        avatar.js\n    date.js\n    currency.js\n    gtm.js\n    errorUtils.js\ndomain/\n    product/\n        product.js\n        product.css\n        product.test.js\n    checkout/\n        checkout.js\n        checkout.css\n        checkout.test.js\n</code></pre> <p>Thus, you can combine the advantages of both \u201cGroup by file type\u201d and \u201cGroup by feature\u201d by colocating related files, which change together frequently and common reusable components and styles used across the application. Depending on the complexity of the application, you can modify this to a flatter structure without subfolders or a more nested structure:</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#flatter-structure","title":"Flatter structure","text":"<p>The following example illustrates a flatter structure:</p> <pre><code>domain/\n    product.js\n    product.css\n    product.test.js\n    checkout.js\n    checkout.css\n    checkout.test.js\n</code></pre>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#nested-structure","title":"Nested structure","text":"<p>The following example shows a more nested structure:</p> <pre><code>domain/\n    product/\n        productType/\n            features.js\n            features.css\n            size.js\n        price/\n            listprice.js\n            discount.js\n</code></pre> <p>A variation to this approach is to create folders based on views or routes, in addition to those based on domain, as discussed here. A routing component can then coordinate the view to be displayed based on the current route. Next.js uses a similar structure.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#application-structure-for-modern-react-features","title":"Application Structure for Modern React Features","text":"<p>Modern React apps use different features such as Redux, stateful containers, Hooks, and Styled Components. Let\u2019s see where the code related to these would fit in the application structure proposed in the previous section.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#redux","title":"Redux","text":"<p>Redux documentation strongly recommends colocating logic for a given feature in one place. Within a given feature folder, the Redux logic for that feature should be written as a single \u201cslice\u201d file, preferably using the Redux Toolkit createSlice API.</p> <p>The file bundles <code>{actionTypes, actions, reducer}</code> to a self-contained, isolated module. This is also known as the \u201cducks\u201d pattern (from Redux). </p> <p>For example, as given here:</p> <pre><code>/src\n    index.tsx: Entry point file that renders the React component tree\n\n/app\n    store.ts: store setup\n    rootReducer.ts: root reducer (optional)\n    App.tsx: root React component\n\n/common: hooks, generic components, utils, etc\n\n/features: contains all \"feature folders\"\n\n/todos: a single feature folder\n    todosSlice.ts: Redux reducer logic and associated actions\n    Todos.tsx: a React component\n</code></pre> <p>Another comprehensive example that uses Redux without creating containers or Hooks is available here.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#containers","title":"Containers","text":"<p>If you have structured your code to categorize components into presentational components and stateful container components, you can create a separate folder for the container components. Containers let you separate complex stateful logic from other aspects of the component:</p> <pre><code>/src\n    /components\n        /component1\n            index.js\n            styled.js\n    /containers\n        /container1\n</code></pre> <p>You can find a complete structure for an app with containers in the same article.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#hooks","title":"Hooks","text":"<p>Hooks can fit into the hybrid structure just like any other type of code. You can have a folder at the app level for common Hooks that can be consumed by all React components. React Hooks used by only one component should remain in the component\u2019s file or a separate hooks.js file in the component\u2019s folder. You can find a sample structure here:</p> <pre><code>/components\n    /productList\n        index.js\n        test.js\n        style.css\n        hooks.js\n\n/hooks\n    /useClickOutside\n        index.js\n    /useData\n        index.js\n</code></pre>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#styled-components","title":"Styled Components","text":"<p>If you are using Styled Components instead of CSS, you can have style.js files instead of the component-level CSS files mentioned earlier. For example, if you have a titlebar component, the structure would be something like this:</p> <pre><code>/src/components/button/\n    index.js\n    style.js\n</code></pre> <p>An application-level theme.js file would contain the values for colors to be used for background and text. A globals component could include definitions for common style elements that other components can use.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#reference","title":"Reference","text":"<ul> <li>Learning JavaScript Design Patterns: 2nd edition by Addy Osmani</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/","title":"Best folder structure in Redux Toolkit","text":"","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#best-folder-structure-in-redux-toolkit","title":"Best folder structure in Redux Toolkit","text":"<p>Is this the best folder structure for a large application using Redux Toolkit, and do we still need separate actions and reducers folders?</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#overview","title":"Overview","text":"","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#1-folder-structure","title":"1. Folder Structure:","text":"<ul> <li>Your structure effectively separates concerns, which is great for maintainability.</li> <li>Using <code>/slices</code> is appropriate since Redux Toolkit encourages using \"slices\" to combine actions and reducers into one file.</li> </ul>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#2-actions-and-reducers","title":"2. Actions and Reducers:","text":"<ul> <li> <p>No Separate Folders Needed: With Redux Toolkit, you typically don't need separate <code>/actions</code> and <code>/reducers</code> folders. Each slice file contains both the actions and the reducers, which helps reduce redundancy and keeps related code together.</p> </li> <li> <p>Example Slice:</p> </li> </ul> <pre><code>// /redux/slices/exampleSlice.js\nimport { createSlice } from \"@reduxjs/toolkit\";\n\nconst exampleSlice = createSlice({\n  name: \"example\",\n  initialState: {},\n  reducers: {\n    actionOne: (state, action) =&gt; {\n      // reducer logic\n    },\n    actionTwo: (state, action) =&gt; {\n      // reducer logic\n    },\n  },\n});\n\nexport const { actionOne, actionTwo } = exampleSlice.actions;\nexport default exampleSlice.reducer;\n</code></pre>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#suggested-structure","title":"Suggested Structure:","text":"<p>You could simplify your Redux-related folder as follows:</p> <pre><code>/redux\n\u251c\u2500\u2500 /slices             // Redux slices, combining actions and reducers\n\u251c\u2500\u2500 /store.js          // Store configuration\n\u2514\u2500\u2500 /middleware         // Any custom middleware (optional)\n</code></pre>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#additional-tips","title":"Additional Tips:","text":"<ul> <li>Combine Slices: If your application grows, consider combining slices in a feature folder to keep related slices, components, and styles together.</li> <li>Testing: Maintain your <code>/tests</code> folder for unit tests that cover slices, components, and hooks.</li> <li>Documentation: As your app scales, consider documenting each folder's purpose to help onboard new developers.</li> </ul> <p>This structure and approach should enhance your application's scalability and maintainability.</p> <p>What is the /middleware folder in a Redux Toolkit application, and what does it contain, given that Redux Toolkit uses thunk by default?</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#overview_1","title":"Overview","text":"","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#1-purpose-of-the-middleware-folder","title":"1. Purpose of the <code>/middleware</code> Folder:","text":"<ul> <li>The <code>/middleware</code> folder is where you can define custom middleware that you want to use in your Redux application, beyond the default middleware provided by Redux Toolkit (like thunk).</li> <li>Middleware can be used for various purposes such as logging, error handling, analytics, or intercepting actions before they reach the reducer.</li> </ul>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#2-default-middleware","title":"2. Default Middleware:","text":"<ul> <li>Redux Toolkit comes with <code>redux-thunk</code> and some other default middleware (like <code>redux-immutable-state-invariant</code> in development) included in the store configuration. You can still add your own custom middleware alongside these.</li> </ul>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#example-middleware-file","title":"Example Middleware File:","text":"<p>Here\u2019s how you might structure a custom middleware file.</p> <p>Folder Structure:</p> <pre><code>/redux\n\u251c\u2500\u2500 /slices\n\u251c\u2500\u2500 /middleware\n\u2502   \u2514\u2500\u2500 loggerMiddleware.js\n\u251c\u2500\u2500 /store.js\n</code></pre> <p>Example Middleware: <code>loggerMiddleware.js</code></p> <pre><code>// /redux/middleware/loggerMiddleware.js\n\nconst loggerMiddleware = (store) =&gt; (next) =&gt; (action) =&gt; {\n  console.log(\"Dispatching action:\", action);\n  const result = next(action); // Pass action to the next middleware/reducer\n  console.log(\"Next state:\", store.getState());\n  return result; // Return the result of the action\n};\n\nexport default loggerMiddleware;\n</code></pre>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#integrating-middleware-in-store","title":"Integrating Middleware in Store:","text":"<p>You would then apply this middleware in your <code>store.js</code> file.</p> <p>Example <code>store.js</code></p> <pre><code>// /redux/store.js\nimport { configureStore } from \"@reduxjs/toolkit\";\nimport rootReducer from \"./slices\"; // Your root reducer\nimport loggerMiddleware from \"./middleware/loggerMiddleware\";\n\nconst store = configureStore({\n  reducer: rootReducer,\n  middleware: (getDefaultMiddleware) =&gt;\n    getDefaultMiddleware().concat(loggerMiddleware), // Adding custom middleware\n});\n\nexport default store;\n</code></pre>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#summary","title":"Summary:","text":"<ul> <li>The <code>/middleware</code> folder is for any custom middleware you want to add to your Redux setup.</li> <li>You can create middleware for logging, API error handling, analytics, etc.</li> <li>Redux Toolkit uses thunk by default, but you can augment the middleware with your own logic as needed.</li> </ul> <p>What is the purpose of adding custom middleware in Redux Toolkit, what does it do, when should it be used, and what happens if it's not included?</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#overview_2","title":"Overview","text":"","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#1-purpose-of-custom-middleware","title":"1. Purpose of Custom Middleware:","text":"<ul> <li>Custom middleware is a powerful way to enhance the Redux store's capabilities. It allows you to intercept actions before they reach the reducers, enabling you to perform side effects or additional logic.</li> </ul>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#2-what-custom-middleware-does","title":"2. What Custom Middleware Does:","text":"<ul> <li>Intercept Actions: Custom middleware can log actions, modify them, or even prevent them from reaching the reducers.</li> <li>Side Effects: You can perform asynchronous tasks, such as API calls, or other operations that are not purely related to state updates.</li> <li>Logging and Debugging: Middleware like logging can be useful during development to track dispatched actions and the resulting state.</li> </ul> Example of logging middleware:<pre><code>const loggerMiddleware = (store) =&gt; (next) =&gt; (action) =&gt; {\n  console.log(\"Dispatching action:\", action);\n  const result = next(action); // Pass the action to the next middleware/reducer\n  console.log(\"Next state:\", store.getState());\n  return result; // Return the result\n};\n</code></pre>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#3-when-to-use-custom-middleware","title":"3. When to Use Custom Middleware:","text":"<p>Use custom middleware when you need to perform:</p> <ul> <li>Logging of actions and state changes.</li> <li>Error handling for actions (e.g., capturing errors from API calls).</li> <li>Conditional action dispatching (e.g., delaying actions based on certain criteria).</li> <li>Analytics tracking to log user interactions with your app.</li> </ul>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#4-what-if-you-do-not-use-it","title":"4. What If You Do Not Use It:","text":"<ul> <li>If you don't add custom middleware, your Redux store will still function with the default middleware (like thunk), but you lose the extra capabilities that custom middleware provides.</li> <li>You might miss out on useful features like action logging, error handling, or other custom side effects that could enhance the user experience or simplify debugging.</li> </ul>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/20/best-folder-structure-in-redux-toolkit/#summary_1","title":"Summary:","text":"<p>Custom middleware extends the functionality of Redux, enabling you to intercept and manipulate actions, perform side effects, and implement features that go beyond simple state management. While not strictly necessary for every application, it can be very helpful for logging, debugging, and handling complex asynchronous logic. If omitted, your application will still work with the default middleware, but you might miss out on valuable insights and features.</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/01/22/how-to-check-the-react-version-in-your-project/","title":"How to Check the React Version in Your Project","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/01/22/how-to-check-the-react-version-in-your-project/#how-to-check-the-react-version-in-your-project","title":"How to Check the React Version in Your Project","text":"<p>React, a popular JavaScript library for building user interfaces, undergoes regular updates to introduce new features, improvements, and bug fixes. As a React developer, it's essential to know the version of React used in your project. In this short blog post, we'll explore how you can easily check the React version of your project.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/01/22/how-to-check-the-react-version-in-your-project/#methods-to-check-react-version","title":"Methods to Check React Version:","text":"<ol> <li> <p>Examine <code>package.json</code>:</p> <p>The <code>package.json</code> file is a central configuration file for Node.js projects, including React applications. Open the <code>package.json</code> file in your project's root directory using a text editor. Look for the \"dependencies\" section, where React is listed with its version.</p> <pre><code>\"dependencies\": {\n    \"react\": \"^17.0.1\",\n    \"react-dom\": \"^17.0.1\",\n\n    // other dependencies...\n}\n</code></pre> <p>In this example, the version of React is specified as \"<code>^17.0.1</code>\".</p> </li> <li> <p>Use Command Line:</p> <p>You can also use the command line to check the installed version of React. Open your terminal or command prompt, navigate to your project's root directory, and run the following command:</p> <pre><code>npm list react\n</code></pre> <p>If you're using Yarn, run:</p> <pre><code>yarn list react\n</code></pre> <p>This command will display the version of React installed in your project.</p> </li> <li> <p>Inspect the Browser Console:</p> <p>During development, you can view the React version in your browser's developer tools console. Open your application in a web browser, right-click on the page, select \"Inspect\" to open the developer tools, and navigate to the \"Console\" tab. Type the following command and press Enter:</p> <pre><code>console.log(React.version);\n</code></pre> <p>This will log the React version to the console.</p> </li> </ol>","tags":["Porgramming","React"]},{"location":"blog/2024/01/22/how-to-check-the-react-version-in-your-project/#conclusion","title":"Conclusion:","text":"<p>Knowing the React version in your project is crucial for various reasons, including understanding the available features, compatibility, and potential need for updates. By examining your <code>package.json</code> file, using command-line tools, or inspecting the browser console, you can easily check the React version and ensure your project stays up-to-date with the latest advancements in React development.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/11/checking-nodejs-versions-in-react-projects/","title":"Checking Node.js Versions in React Projects","text":"","tags":["react","js"]},{"location":"blog/2024/05/11/checking-nodejs-versions-in-react-projects/#checking-nodejs-versions-in-react-projects","title":"Checking <code>Node.js</code> Versions in React Projects","text":"<p>React itself doesn't directly depend on Node.js version. However, when you're developing a React application, you typically use Node.js and npm (Node Package Manager) to manage your project's dependencies, run development servers, and build your application for production.</p> <p>React projects typically come with a package.json file which specifies the project's dependencies, including the version of Node.js it's compatible with. You can find the required version of Node.js specified in the engines field of the package.json file.</p> package.json<pre><code>\"engines\": {\n  \"node\": \"&gt;=12.0.0\"\n}\n</code></pre> <p>This indicates that the project requires Node.js version <code>12.0.0</code> or later to run properly. You should install the specified version of Node.js on your development machine to ensure compatibility with the React project.</p> <p>You can check the <code>package.json</code> file in your React project's root directory to see which version of Node.js it requires. If you don't have a <code>package.json</code> file, it's likely that your React project hasn't been initialized properly, and you might need to set it up with npm init or yarn init to generate the file.</p>","tags":["react","js"]},{"location":"blog/2024/08/05/choosing-between-function-declarations-and-arrow-functions-for-react-components/","title":"Choosing Between Function Declarations and Arrow Functions for React Components","text":"","tags":["antd","react"]},{"location":"blog/2024/08/05/choosing-between-function-declarations-and-arrow-functions-for-react-components/#choosing-between-function-declarations-and-arrow-functions-for-react-components","title":"Choosing Between Function Declarations and Arrow Functions for React Components","text":"<p>When defining React components, you might encounter two common patterns: <code>function declarations</code> and <code>arrow functions</code>. Both approaches are valid, but they come with different nuances</p> Two common patterns <ol> <li>Function Declarations</li> <li>Arrow Functions.</li> </ol> <p>Let's explore these two styles and determine which one you might want to use in your React projects.</p>","tags":["antd","react"]},{"location":"blog/2024/08/05/choosing-between-function-declarations-and-arrow-functions-for-react-components/#1-function-declaration","title":"1. Function Declaration","text":"ExampleAdvantagesDisadvantages <pre><code>import React from 'react';\n\nfunction TestComponent() {\n    return (\n        &lt;div&gt;TestComponent&lt;/div&gt;\n    );\n}\n\nexport default TestComponent;\n</code></pre> <ol> <li> <p>Hoisting:</p> <p>Function declarations are hoisted, meaning they can be called before they are defined in the code. This can be useful in certain scenarios, though it\u2019s less of a concern with modern React development.</p> </li> <li> <p>Traditional Syntax:</p> <p>This style is familiar to many developers and fits well with older JavaScript codebases. It\u2019s clear and straightforward, particularly for those accustomed to traditional function definitions.</p> </li> </ol> <ol> <li><code>this</code> Binding: While this isn't a concern for functional components, traditional function declarations come with their own <code>this</code> context, which can be confusing if you're mixing class-based and functional components.</li> </ol>","tags":["antd","react"]},{"location":"blog/2024/08/05/choosing-between-function-declarations-and-arrow-functions-for-react-components/#2-arrow-function","title":"2. Arrow Function","text":"ExampleAdvantagesDisadvantages <pre><code>import React from 'react';\n\nconst TestComponent = () =&gt; {\n    return (\n        &lt;&gt;&lt;/&gt;\n    );\n};\n\nexport default TestComponent;\n</code></pre> <ol> <li> <p>Conciseness:</p> <p>Arrow functions provide a more modern and concise syntax. They\u2019re often preferred for their brevity, which can make code easier to read and write.</p> </li> <li> <p>Lexical <code>this</code> Binding:</p> <p>Arrow functions inherit <code>this</code> from their surrounding context, which avoids some common pitfalls related to <code>this</code> in traditional functions.</p> </li> </ol> <ol> <li>Not Hoisted: Arrow functions are not hoisted. This means they need to be defined before they are used, which can be a minor drawback if you\u2019re used to the flexibility of function declarations.</li> </ol>","tags":["antd","react"]},{"location":"blog/2024/08/05/choosing-between-function-declarations-and-arrow-functions-for-react-components/#which-one-to-choose","title":"Which One to Choose?","text":"<p>For most modern React development, arrow functions are the preferred choice. Their concise syntax, combined with lexical <code>this</code> binding, aligns well with the functional programming paradigm promoted by React. They integrate seamlessly with other modern JavaScript features and libraries, enhancing readability and maintainability.</p> <p>However, function declarations remain a solid option, especially in projects where consistency with existing code is crucial or where hoisting could be beneficial. They are also a good choice for developers who prefer traditional JavaScript syntax.</p> <p>Ultimately, the decision between the two styles may come down to personal or team preference. Both patterns are valid and can be used effectively depending on the specific needs of your project and coding style.</p>","tags":["antd","react"]},{"location":"blog/2024/08/21/combine-slices-in-a-feature-folder/","title":"Combine Slices in a Feature Folder","text":"","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/21/combine-slices-in-a-feature-folder/#combine-slices-in-a-feature-folder","title":"Combine Slices in a Feature Folder","text":"<p>This approach promotes encapsulation, improves readability, and enhances collaboration among team members, particularly in larger projects.</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/21/combine-slices-in-a-feature-folder/#overview","title":"Overview","text":"","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/21/combine-slices-in-a-feature-folder/#1-combining-slices-in-a-feature-folder","title":"1. Combining Slices in a Feature Folder:","text":"<ul> <li>As your application grows, it can become beneficial to organize related slices, components, and styles into dedicated feature folders. This approach groups all relevant files for a specific feature or domain together, making it easier to manage and navigate your codebase.</li> </ul>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/21/combine-slices-in-a-feature-folder/#2-structure-of-a-feature-folder","title":"2. Structure of a Feature Folder:","text":"<p>A feature folder typically contains:</p> <ul> <li>Slices: Redux slices that manage the state for that feature.</li> <li>Components: UI components related to that feature.</li> <li>Styles: Any styles specific to that feature (e.g., CSS or styled-components).</li> <li>Hooks: Any custom hooks that are used within the feature.</li> </ul> Example Structure:<pre><code>/src\n\u251c\u2500\u2500 /features\n\u2502   \u251c\u2500\u2500 /user\n\u2502   \u2502   \u251c\u2500\u2500 userSlice.js      // Redux slice\n\u2502   \u2502   \u251c\u2500\u2500 UserProfile.js     // User profile component\n\u2502   \u2502   \u251c\u2500\u2500 UserList.js        // User list component\n\u2502   \u2502   \u251c\u2500\u2500 userStyles.css      // Component-specific styles\n\u2502   \u2502   \u2514\u2500\u2500 useUser.js         // Custom hook for user data\n\u2502   \u2514\u2500\u2500 /posts\n\u2502       \u251c\u2500\u2500 postsSlice.js\n\u2502       \u251c\u2500\u2500 Post.js\n\u2502       \u251c\u2500\u2500 PostList.js\n\u2502       \u2514\u2500\u2500 postStyles.css\n</code></pre>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/21/combine-slices-in-a-feature-folder/#3-benefits-of-this-organization","title":"3. Benefits of This Organization:","text":"<ul> <li>Encapsulation: Keeps all files related to a feature together, reducing clutter in your codebase.</li> <li>Scalability: Makes it easier to scale features independently. New developers can focus on a specific feature without needing to understand the entire codebase.</li> <li>Readability: Improves code readability by making it clearer where to find related code. Developers can quickly locate the slice, components, and styles for a feature.</li> <li>Reusability: Encourages reusability of components and hooks within a feature.</li> </ul>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/21/combine-slices-in-a-feature-folder/#4-when-to-implement-this","title":"4. When to Implement This:","text":"<ul> <li>This organization becomes particularly valuable as your application grows in complexity or when you start working in a team. If you have multiple developers working on different features, feature folders can help avoid merge conflicts and make onboarding easier.</li> </ul>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/21/combine-slices-in-a-feature-folder/#summary","title":"Summary:","text":"<p>Combining slices in a feature folder organizes related code components, making it easier to manage, understand, and scale your application. This approach promotes encapsulation, improves readability, and enhances collaboration among team members, particularly in larger projects.</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/05/27/conditional-rendering-in-react/","title":"Conditional Rendering in React","text":"","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/27/conditional-rendering-in-react/#conditional-rendering-in-react","title":"Conditional Rendering in React","text":"Conditional Rendering in React: Using Ternary Operators vs. Logical AND <p>Both code snippets are functionally equivalent, but there are differences in style and readability. Here\u2019s a comparison of the two approaches:</p>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/27/conditional-rendering-in-react/#1-using-a-ternary-operator","title":"1.  Using a Ternary Operator","text":"<pre><code>{isCircular ? (\n&lt;&gt;\n    &lt;div style={{ display: \"flex\" }}&gt;\n        &lt;Button type=\"primary\" onClick={() =&gt; {\n            setIsTemplateModalOpen(true);\n            dispatch(actionForGetAllCircularPlanningTemplate());\n        }} style={{ marginRight: \"8px\" }}&gt;\n            Template\n        &lt;/Button&gt;\n        &lt;Button type=\"primary\" onClick={() =&gt; setIsCircularModalOpen(true)}&gt;\n            Send for Approval\n        &lt;/Button&gt;\n    &lt;/div&gt;\n&lt;/&gt;\n) : null}\n</code></pre>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/27/conditional-rendering-in-react/#2-using-logical-and-operator","title":"2.  Using Logical AND Operator","text":"<pre><code>{isCircular &amp;&amp; (\n  &lt;&gt;\n    &lt;div style={{ display: \"flex\" }}&gt;\n      &lt;Button type=\"primary\" onClick={() =&gt; {\n        setIsTemplateModalOpen(true);\n        dispatch(actionForGetAllCircularPlanningTemplate());\n      }} style={{ marginRight: \"8px\" }}&gt;\n        Template\n      &lt;/Button&gt;\n      &lt;Button type=\"primary\" onClick={() =&gt; setIsCircularModalOpen(true)}&gt;\n        Send for Approval\n      &lt;/Button&gt;\n    &lt;/div&gt;\n  &lt;/&gt;\n)}\n</code></pre>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/27/conditional-rendering-in-react/#comparison-and-recommendations","title":"Comparison and Recommendations","text":"Readability and Simplicity: <ul> <li>Logical AND (<code>&amp;&amp;</code>): This method is more concise and commonly used in React for conditional rendering. It directly expresses that the content should only render if the condition is true, making the code cleaner and easier to read.</li> <li>Ternary Operator (<code>? :</code>): This method is more explicit, showing both the <code>true</code> and <code>false</code> branches. It\u2019s useful when you need to render something when the condition is <code>false</code>, but in cases where you only care about rendering when true, it can be more verbose.</li> </ul> Use Case: <ul> <li>If you only need to render something based on a condition and don\u2019t need to handle the <code>false</code> case, the logical AND (<code>&amp;&amp;</code>) operator is typically preferred for its brevity.</li> <li>If you need to explicitly handle both <code>true</code> and <code>false</code> cases (e.g., rendering a fallback or alternative UI), the ternary operator is more appropriate.</li> </ul> Code Consistency: <ul> <li>Choose a style that is consistent with the rest of your codebase. Consistency helps maintain readability and makes it easier for others to understand and maintain the code.</li> </ul>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/27/conditional-rendering-in-react/#conclusion","title":"Conclusion","text":"<p>In most cases, using the logical AND (<code>&amp;&amp;</code>) operator is preferred for its simplicity and readability when you only need to render content conditionally:</p> <pre><code>{isCircular &amp;&amp; (\n  &lt;&gt;\n    &lt;div style={{ display: \"flex\" }}&gt;\n      &lt;Button type=\"primary\" onClick={() =&gt; {\n        setIsTemplateModalOpen(true);\n        dispatch(actionForGetAllCircularPlanningTemplate());\n      }} style={{ marginRight: \"8px\" }}&gt;\n        Template\n      &lt;/Button&gt;\n      &lt;Button type=\"primary\" onClick={() =&gt; setIsCircularModalOpen(true)}&gt;\n        Send for Approval\n      &lt;/Button&gt;\n    &lt;/div&gt;\n  &lt;/&gt;\n)}\n</code></pre> <p>This method clearly shows that the content is rendered only if <code>isCircular</code> is true, and it avoids the need to explicitly render <code>null</code> for the <code>false</code> case.</p>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/27/conditional-rendering-in-react/#question","title":"Question","text":"","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/27/conditional-rendering-in-react/#what-is-conditional-rendering","title":"What is Conditional rendering","text":"<p>Conditional rendering in React is a technique used to render different components or elements based on certain conditions. It allows you to control what is displayed to the user based on the state or props of your component. This is essential for creating dynamic and interactive user interfaces.</p>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/27/conditional-rendering-in-react/#types-of-conditional-rendering","title":"Types of Conditional Rendering","text":"<ol> <li> <p>Using if Statements:</p> <ul> <li>You can use <code>if</code> statements inside your component to conditionally render different JSX elements.</li> </ul> <pre><code>const MyComponent = ({ isLoggedIn }) =&gt; {\n  if (isLoggedIn) {\n    return &lt;h1&gt;Welcome Back!&lt;/h1&gt;;\n  } else {\n    return &lt;h1&gt;Please Log In&lt;/h1&gt;;\n  }\n};\n</code></pre> </li> <li> <p>Using Ternary Operators:</p> <ul> <li>The ternary operator is often used for inline conditional rendering within JSX.</li> </ul> <pre><code>const MyComponent = ({ isLoggedIn }) =&gt; (\n  &lt;div&gt;\n    {isLoggedIn ? &lt;h1&gt;Welcome Back!&lt;/h1&gt; : &lt;h1&gt;Please Log In&lt;/h1&gt;}\n  &lt;/div&gt;\n);\n</code></pre> </li> <li> <p>Using Logical AND (<code>&amp;&amp;</code>) Operator:</p> <ul> <li>The logical AND operator is used to render content only if a condition is true.</li> </ul> <pre><code>const MyComponent = ({ showWelcome }) =&gt; (\n  &lt;div&gt;\n    {showWelcome &amp;&amp; &lt;h1&gt;Welcome to Our Website!&lt;/h1&gt;}\n  &lt;/div&gt;\n);\n</code></pre> </li> <li> <p>Using <code>switch</code> Statements:</p> <ul> <li>For more complex scenarios, a <code>switch</code> statement can be used to render different components based on multiple conditions.</li> </ul> <pre><code>const MyComponent = ({ status }) =&gt; {\n  switch (status) {\n    case 'loading':\n      return &lt;h1&gt;Loading...&lt;/h1&gt;;\n    case 'success':\n      return &lt;h1&gt;Data Loaded Successfully!&lt;/h1&gt;;\n    case 'error':\n      return &lt;h1&gt;Error Loading Data&lt;/h1&gt;;\n    default:\n      return &lt;h1&gt;Unknown Status&lt;/h1&gt;;\n  }\n};\n</code></pre> </li> <li> <p>Using Inline Functions:</p> <ul> <li>Sometimes, especially in more complex conditions, you might use inline functions or methods.</li> </ul> <pre><code>const MyComponent = ({ user }) =&gt; {\n  const renderUserGreeting = () =&gt; {\n    if (user) {\n      return &lt;h1&gt;Hello, {user.name}!&lt;/h1&gt;;\n    }\n    return &lt;h1&gt;Hello, Guest!&lt;/h1&gt;;\n  };\n\n  return &lt;div&gt;{renderUserGreeting()}&lt;/div&gt;;\n};\n</code></pre> </li> </ol>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/27/conditional-rendering-in-react/#conclusion_1","title":"Conclusion","text":"<p>Conditional rendering is a powerful feature in React that helps you create dynamic and interactive user interfaces. Choose the method that best fits the complexity of your conditions and maintain readability and maintainability of your code.</p>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/27/conditional-rendering-in-react/#advanced-topic","title":"Advanced Topic","text":"<p>While conditional rendering is essential in React, it is not the most advanced or the sole important topic. It is a foundational concept, but mastering React involves understanding multiple advanced concepts and patterns. Here\u2019s a breakdown of where conditional rendering fits and what other advanced topics exist in React:</p> <ol> <li> <p>Conditional Rendering (Basic to Intermediate)</p> <ul> <li>Conditional rendering is important because it allows you to dynamically show or hide components based on application state, props, or user interactions.</li> <li>It\u2019s essential but relatively straightforward once you understand basic JavaScript control structures.</li> </ul> </li> <li> <p>More Advanced and Important Topics in React</p> </li> </ol> <p>2.1 State Management (Advanced)</p> <ul> <li>Managing component state with hooks (<code>useState</code>, <code>useReducer</code>).</li> <li>Using libraries like <code>Redux</code> or <code>Context API</code> for global state management.</li> <li>Understanding how to handle complex state logic, side effects (<code>useEffect</code>), and async operations (e.g., API calls).</li> </ul> <p>2.2 React Hooks (Intermediate to Advanced)</p> <ul> <li>Hooks like <code>useEffect</code>, <code>useContext</code>, <code>useMemo</code>, <code>useCallback</code>, <code>useRef</code>, etc., bring reusability and optimization.</li> <li>Custom hooks are essential for abstracting complex logic into reusable pieces.</li> </ul> <p>2.3 Component Lifecycle and Side Effects (Advanced)</p> <ul> <li>Understanding how React\u2019s rendering lifecycle works and using hooks like <code>useEffect</code> to handle side effects (data fetching, subscriptions, cleanup).</li> <li>How React optimizes rendering with virtual DOM and reconciliation processes.</li> </ul> <p>2.4 Performance Optimization (Advanced)</p> <ul> <li>Techniques like memoization (<code>React.memo</code>, <code>useMemo</code>, <code>useCallback</code>) to prevent unnecessary re-renders.</li> <li>Code splitting and lazy loading for better performance using React.lazy and Suspense.</li> <li>Dealing with large lists efficiently using react-window or react-virtualized.</li> </ul> <p>2.5 Routing and Navigation</p> <ul> <li>Handling routing with libraries like React Router.</li> <li>Dynamic route matching, route guards, and lazy-loading routes.</li> </ul> <p>2.6 Context API (Intermediate to Advanced)</p> <ul> <li>The Context API allows for state sharing between components without prop drilling.</li> <li>It's useful for handling global state or themes, but managing complex state often requires Redux or other state libraries.</li> </ul> <p>2.7 Higher-Order Components (HOCs) &amp; Render Props</p> <ul> <li>HOCs and render props are patterns used for code reuse, which is essential for maintaining clean, reusable components in large codebases.</li> </ul> <p>2.8 Custom Hooks and Reusability Patterns</p> <ul> <li>Creating custom hooks allows for reusing logic across components.</li> <li>Exploring patterns like Compound Components and Provider Pattern for scalable and reusable UI libraries.</li> </ul> <p>2.9 React Context vs Redux (Global State Management)</p> <ul> <li>Understanding when to use React Context vs. more advanced state management libraries like Redux for global app state.</li> </ul> <p>2.10 Testing (Advanced)</p> <ul> <li>Testing React components using libraries like Jest and React Testing Library for unit testing and integration testing.</li> <li>Snapshot testing, mocking APIs, and ensuring UI behaves as expected are critical in scalable applications.</li> </ul> <p>2.11 TypeScript with React</p> <ul> <li>Adding TypeScript to React for better type checking, autocompletion, and code robustness in large applications.</li> <li>Advanced types and generics in components and hooks.</li> </ul> <p>2.12 Server-Side Rendering (SSR) and Static Site Generation (SSG)</p> <ul> <li>Understanding Next.js or Gatsby for building applications with SSR or SSG, improving SEO and performance.</li> <li>Managing data fetching and page pre-rendering in SSR.</li> </ul> <p>2.13 React Native (Mobile Development)</p> <ul> <li>Transitioning from React to React Native for mobile app development using similar paradigms.</li> <li>Handling platform-specific behaviors while sharing logic across mobile and web.</li> </ul> Conclusion <p>Conditional rendering is important but is only one of the core concepts of React. More advanced topics, such as state management, hooks, performance optimization, and patterns like HOCs or custom hooks, are vital for mastering React and handling real-world, scalable applications.</p> <p>Becoming proficient in React involves learning and mastering several areas, not just conditional rendering.</p>","tags":["databse","django","postgresql"]},{"location":"blog/2024/08/11/conditinally-mounting-component/","title":"Conditinally Mounting Component","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/08/11/conditinally-mounting-component/#conditinally-mounting-component","title":"Conditinally Mounting Component","text":"<p>Yes, it's a good practice to mount the <code>LogList</code> component only when the corresponding <code>TabPane</code> is <code>active</code>. This approach can enhance performance by reducing the number of components that are rendered initially and by preventing unnecessary data fetching when the tab is not being viewed.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/11/conditinally-mounting-component/#benefits-of-conditional-mounting","title":"Benefits of Conditional Mounting:","text":"<ol> <li>Performance: It prevents the component from being mounted and the API call from being made until the tab is clicked, saving resources.</li> <li>User Experience: Users will only see relevant content when they actually navigate to that tab.</li> <li>State Management: If the component fetches data, it helps manage loading states and errors more effectively since you control when the data is fetched.</li> </ol>","tags":["Porgramming","React"]},{"location":"blog/2024/08/11/conditinally-mounting-component/#how-to-implement-conditional-mounting","title":"How to Implement Conditional Mounting:","text":"<p>You can use a combination of state to track the active tab and conditional rendering for the <code>LogList</code> component.</p> <p>Here\u2019s how you can do it:</p> ExampleExplanation <pre><code>import React, { useState } from \"react\";\nimport { Tabs } from \"antd\";\nimport LogList from \"./LogList\"; // Adjust the import according to your structure\n\nconst { TabPane } = Tabs;\n\nconst MyComponent = () =&gt; {\n  const [activeKey, setActiveKey] = useState(\"1\"); // Default active tab key\n\n  const handleTabChange = (key) =&gt; {\n    setActiveKey(key);\n  };\n\n  return (\n    &lt;Tabs\n      defaultActiveKey=\"1\"\n      activeKey={activeKey}\n      onChange={handleTabChange}\n      type=\"line\"\n    &gt;\n      &lt;TabPane tab=\"Contact Details\" key=\"1\"&gt;\n        {contactDetails()} {/* Assuming contactDetails is a function */}\n      &lt;/TabPane&gt;\n      &lt;TabPane tab=\"Tender Checklist\" key=\"2\"&gt;\n        &lt;CheckListContainer referenceId={getDetails?.referenceId} /&gt;\n      &lt;/TabPane&gt;\n      &lt;TabPane tab=\"Log List\" key=\"4\"&gt;\n        {activeKey === \"4\" &amp;&amp; &lt;LogList /&gt;}{\" \"}\n        {/* Only mount LogList when active */}\n      &lt;/TabPane&gt;\n    &lt;/Tabs&gt;\n  );\n};\n\nexport default MyComponent;\n</code></pre> <ol> <li>State Management: The <code>activeKey</code> state tracks the currently active tab.</li> <li>Event Handling: The <code>handleTabChange</code> function updates the <code>activeKey</code> when a tab is clicked.</li> <li>Conditional Rendering: The <code>LogList</code> component is only rendered when <code>activeKey</code> is <code>\"4\"</code>.</li> </ol>","tags":["Porgramming","React"]},{"location":"blog/2024/08/11/conditinally-mounting-component/#conclusion","title":"Conclusion","text":"<p>By following this pattern, you ensure that <code>LogList</code> is only mounted and rendered when the user is viewing that specific tab, enhancing performance and maintaining a better user experience.</p> <pre><code>\n</code></pre>","tags":["Porgramming","React"]},{"location":"blog/2024/05/29/deep-dive-into-map/","title":"Deep Dive into .map()","text":"","tags":["Personal"]},{"location":"blog/2024/05/29/deep-dive-into-map/#deep-dive-into-map","title":"Deep Dive into <code>.map()</code>","text":"<p>Deep Dive into <code>.map()</code>: Advanced Usage and Hidden Features in JavaScript</p> <p>Great question! These are all ways to use the <code>map()</code> function in JavaScript, but they serve slightly different purposes based on how you <code>return</code> values.</p>","tags":["Personal"]},{"location":"blog/2024/05/29/deep-dive-into-map/#1-mapitem-itemid","title":"1.  <code>.map((item) =&gt; item.id)</code>","text":"<p>This syntax is used when you're returning a single value (such as <code>item.id</code>) without wrapping it in an object or block. This is called an implicit return. It\u2019s common when you\u2019re just transforming each item to a single property.</p> <pre><code>let ids = items.map((item) =&gt; item.id);\n</code></pre> <ul> <li>This will create a new array <code>ids</code> containing only the <code>id</code> property from each <code>item</code>.</li> <li>When to use it: When you want to return a single value (a property or a simple transformation) for each element.</li> </ul>","tags":["Personal"]},{"location":"blog/2024/05/29/deep-dive-into-map/#2-mapitem","title":"2.  <code>.map((item) =&gt; ({}))</code>","text":"<p>This syntax is used when you want to return an object for each item in the array. The parentheses <code>()</code> around the curly braces <code>{}</code> are necessary to tell JavaScript that you are returning an object instead of defining a block of code.</p> <pre><code>let newObjects = items.map((item) =&gt; ({\n    id: item.id,\n    name: item.name,\n}));\n</code></pre> <ul> <li>This creates a new array <code>newObjects</code> where each element is an object with both <code>id</code> and <code>name</code> properties.</li> <li>When to use it: When you want to return an object for each item.</li> </ul>","tags":["Personal"]},{"location":"blog/2024/05/29/deep-dive-into-map/#3-mapitem-return-explicit-return","title":"3.  <code>.map((item) =&gt; { return {} })</code> (Explicit return)","text":"<p>In some cases, you may need to perform more operations or add logic before returning a value. In this case, you can use curly braces <code>{}</code> to define a block of code and explicitly use the return keyword to <code>return</code> an object or any other value.</p> <pre><code>let newArray = items.map((item) =&gt; {\n    let newItem = { id: item.id };\n\n    if (item.isActive) {\n        newItem.status = \"Active\";\n    }\n\n    return newItem;\n});\n</code></pre> <ul> <li>When to use it: When you need to do more than just return a value (such as doing calculations, adding conditions, etc.), or when you want to make your logic clearer. If you open the function body with <code>{}</code>, you need to use the return keyword to explicitly <code>return</code> something.</li> </ul>","tags":["Personal"]},{"location":"blog/2024/05/29/deep-dive-into-map/#summary","title":"Summary:","text":"<ul> <li><code>.map((item) =&gt; item.id)</code>: Use when you\u2019re returning a single value (no object or extra logic).</li> <li><code>.map((item) =&gt; ({ ... }))</code>: Use when you\u2019re returning an object directly.</li> <li><code>.map((item) =&gt; { return ... })</code>: Use when you need additional logic inside the function body before returning a value.</li> </ul>","tags":["Personal"]},{"location":"blog/2024/05/29/deep-dive-into-map/#advanced-and-hidden-usage-of-map","title":"Advanced and Hidden Usage of <code>.map()</code>","text":"<ol> <li> <p>Chaining <code>.map()</code> with Other Array Methods:</p> <ul> <li>Example: Combining <code>.map()</code> with <code>.filter()</code> or <code>.reduce()</code> for complex transformations.</li> <li>Use Case: Processing data through multiple stages of transformation and filtering.</li> </ul> <pre><code>const processedData = data\n    .filter(item =&gt; item.isActive)\n    .map(item =&gt; ({ id: item.id, name: item.name }))\n    .reduce((acc, item) =&gt; acc.concat(item.name), []);\n</code></pre> </li> <li> <p>Transforming Arrays of Objects:</p> <ul> <li>Example: Creating new objects or modifying existing ones while mapping.</li> <li>Use Case: Reshaping data structures for UI components or APIs.</li> </ul> <pre><code>const userProfiles = users.map(user =&gt; ({\n    id: user.id,\n    fullName: `${user.firstName} ${user.lastName}`,\n    isActive: user.status === 'active'\n}));\n</code></pre> </li> <li> <p>Using <code>.map()</code> for Index-Based Transformations:</p> <ul> <li>Example: Accessing the index of each element within the <code>.map()</code> function.</li> <li>Use Case: Applying logic based on the position of each item in the array.</li> </ul> <pre><code>const indexedItems = items.map((item, index) =&gt; ({ ...item, index }));\n</code></pre> </li> <li> <p>Mapping Over Non-Array Objects:</p> <ul> <li>Example: Using <code>Object.keys()</code> or <code>Object.entries()</code> with <code>.map()</code>.</li> <li>Use Case: Transforming object properties or key-value pairs.</li> </ul> <pre><code>const obj = { a: 1, b: 2, c: 3 };\nconst entries = Object.entries(obj).map(([key, value]) =&gt; `${key}: ${value}`);\n</code></pre> </li> <li> <p>Creating Nested Data Structures:</p> <ul> <li>Example: Using <code>.map()</code> to generate nested arrays or objects.</li> <li>Use Case: Preparing data for complex UI components like nested tables or trees.</li> </ul> <pre><code>const nestedData = data.map(item =&gt; ({\n    id: item.id,\n    details: {\n        name: item.name,\n        description: item.description\n    }\n}));\n</code></pre> </li> <li> <p>Transforming Arrays with Side Effects:</p> <ul> <li>Example: Performing operations that have side effects, though this is generally discouraged.</li> <li>Use Case: Logging or modifying external states during the transformation.</li> </ul> <pre><code>const updatedItems = items.map(item =&gt; {\n    console.log(`Processing item with id: ${item.id}`);\n\n    return { ...item, processed: true };\n});\n</code></pre> </li> </ol> <p>These advanced techniques and hidden usages of <code>.map()</code> can help you unlock its full potential and apply it to more complex scenarios.</p>","tags":["Personal"]},{"location":"blog/2024/08/18/what-are-the-main-differences-between-redux-thunk-and-redux-saga-and-which-one-should-i-use-and-why/","title":"What are the main differences between Redux Thunk and Redux Saga, and which one should I use and why?","text":"","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/18/what-are-the-main-differences-between-redux-thunk-and-redux-saga-and-which-one-should-i-use-and-why/#what-are-the-main-differences-between-redux-thunk-and-redux-saga-and-which-one-should-i-use-and-why","title":"What are the main differences between Redux Thunk and Redux Saga, and which one should I use and why?","text":"<p>Choosing between them depends on the complexity of your application's side effects and your team's familiarity with the respective concepts.</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/18/what-are-the-main-differences-between-redux-thunk-and-redux-saga-and-which-one-should-i-use-and-why/#1-main-differences","title":"1. Main Differences:","text":"<p>Conceptual Model:</p> <ul> <li> <p>Redux Thunk: Thunks are simple functions that return another function (the thunk) that can dispatch actions and perform asynchronous operations. It relies on promises and is more straightforward, suitable for simpler use cases.</p> </li> <li> <p>Redux Saga: Uses generator functions to manage side effects in a more declarative way. Sagas are more powerful and can handle complex asynchronous flows, allowing for more control over the execution of actions.</p> </li> </ul> <p>Ease of Use:</p> <ul> <li>Redux Thunk: Easier to learn and implement, especially for developers familiar with JavaScript Promises. It fits well for straightforward asynchronous tasks.</li> <li>Redux Saga: Has a steeper learning curve due to the concepts of generators and effects. However, it provides more advanced capabilities like canceling tasks, handling race conditions, and orchestrating complex flows.</li> </ul> <p>Testing:</p> <ul> <li>Redux Thunk: Testing thunks involves checking the dispatched actions and state changes, which can be simpler but less structured.</li> <li>Redux Saga: Sagas are easier to test due to their generator functions. You can test the effects in isolation, making the tests more predictable.</li> </ul> <p>Control Flow:</p> <ul> <li>Redux Thunk: Mostly linear and based on promise chains. It doesn't handle complex control flow well (e.g., waiting for multiple actions).</li> <li>Redux Saga: Offers powerful control flow mechanisms (e.g., <code>take</code>, <code>put</code>, <code>call</code>, <code>fork</code>, <code>race</code>) to manage concurrent actions and complex sequences.</li> </ul>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/18/what-are-the-main-differences-between-redux-thunk-and-redux-saga-and-which-one-should-i-use-and-why/#2-which-one-to-use-and-why","title":"2. Which One to Use and Why:","text":"<p>Use Redux Thunk:</p> <ul> <li>If your application has simple asynchronous needs, like fetching data from an API or submitting forms.</li> <li>When you want to keep things lightweight and straightforward without the overhead of learning generators and saga patterns.</li> </ul> <p>Use Redux Saga:</p> <ul> <li>If your application requires complex side effect management, such as handling multiple API calls simultaneously, canceling requests, or coordinating complex asynchronous workflows.</li> <li>When you need better control over side effects and want a more structured way to manage them, especially in larger applications.</li> </ul>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/18/what-are-the-main-differences-between-redux-thunk-and-redux-saga-and-which-one-should-i-use-and-why/#summary","title":"Summary","text":"<ul> <li>Redux Thunk: Simpler, easier to use for straightforward async tasks. Good for most basic needs.</li> <li>Redux Saga: More powerful and flexible for complex side effects. Better for larger applications with intricate asynchronous logic.</li> </ul>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/19/do-we-need-to-install-redux-thunk-separately-when-using-redux-toolkit/","title":"Do we need to install redux-thunk separately when using Redux Toolkit","text":"","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/19/do-we-need-to-install-redux-thunk-separately-when-using-redux-toolkit/#do-we-need-to-install-redux-thunk-separately-when-using-redux-toolkit","title":"Do we need to install redux-thunk separately when using Redux Toolkit","text":"<p>Redux Toolkit includes redux-thunk as a built-in middleware by default when you create a store using <code>configureStore</code>.</p> <p>Do we need to install redux-thunk separately when using Redux Toolkit, and how can we use Redux Saga with it?</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/19/do-we-need-to-install-redux-thunk-separately-when-using-redux-toolkit/#1-no-need-to-install-redux-thunk-separately","title":"1. No Need to Install Redux Thunk Separately:","text":"<ul> <li>Redux Toolkit includes redux-thunk as a built-in middleware by default when you create a store using <code>configureStore</code>. Therefore, you do not need to install or configure redux-thunk separately; it is ready to use out of the box.</li> </ul>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/19/do-we-need-to-install-redux-thunk-separately-when-using-redux-toolkit/#2-using-redux-saga-with-redux-toolkit","title":"2. Using Redux Saga with Redux Toolkit:","text":"<ul> <li>If you want to use Redux Saga, you will need to install it separately and configure it as middleware when setting up your store. Redux Saga is useful for managing complex side effects and asynchronous flows in your application.</li> </ul>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/19/do-we-need-to-install-redux-thunk-separately-when-using-redux-toolkit/#steps-to-use-redux-saga-with-redux-toolkit","title":"Steps to Use Redux Saga with Redux Toolkit","text":"<ol> <li> <p>Install Redux Saga</p> <p>You can install Redux Saga using npm or yarn:</p> <pre><code>npm install redux-saga\n</code></pre> </li> <li> <p>Create a Saga</p> <p>Create a saga file where you define your saga functions.</p> <pre><code>// userSaga.js\nimport { call, put, takeEvery } from \"redux-saga/effects\";\nimport axios from \"axios\";\n\n// Worker saga for fetching users\nfunction* fetchUsers() {\n  try {\n    const response = yield call(\n      axios.get,\n      \"https://jsonplaceholder.typicode.com/users\"\n    );\n    yield put({ type: \"users/fetchSuccess\", payload: response.data });\n  } catch (error) {\n    yield put({ type: \"users/fetchError\", payload: error.message });\n  }\n}\n\n// Watcher saga\nfunction* watchFetchUsers() {\n  yield takeEvery(\"users/fetchRequest\", fetchUsers);\n}\n\n// Root saga\nexport default function* rootSaga() {\n  yield watchFetchUsers();\n}\n</code></pre> </li> <li> <p>Configure the Store with Saga Middleware</p> <p>You need to set up the Redux store and apply the saga middleware.</p> <pre><code>// store.js\nimport { configureStore } from \"@reduxjs/toolkit\";\nimport createSagaMiddleware from \"redux-saga\";\nimport usersReducer from \"./usersSlice\";\nimport rootSaga from \"./userSaga\";\n\n// Create the saga middleware\nconst sagaMiddleware = createSagaMiddleware();\n\n// Configure the store\nconst store = configureStore({\n  reducer: {\n    users: usersReducer, // Add users slice reducer\n  },\n  middleware: (getDefaultMiddleware) =&gt;\n    getDefaultMiddleware().concat(sagaMiddleware), // Include saga middleware\n});\n\n// Run the root saga\nsagaMiddleware.run(rootSaga);\n\nexport default store;\n</code></pre> </li> <li> <p>Dispatch Actions from a Component</p> <p>You can dispatch actions to trigger the saga in your components.</p> <pre><code>// UsersList.js\nimport React, { useEffect } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\n\nconst UsersList = () =&gt; {\n  const dispatch = useDispatch();\n  const { users, loading, error } = useSelector((state) =&gt; state.users);\n\n  useEffect(() =&gt; {\n    dispatch({ type: \"users/fetchRequest\" }); // Dispatch action to fetch users\n  }, [dispatch]);\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;User List&lt;/h1&gt;\n      {loading &amp;&amp; &lt;p&gt;Loading...&lt;/p&gt;}\n      {error &amp;&amp; &lt;p&gt;Error: {error}&lt;/p&gt;}\n      &lt;ul&gt;\n        {users.map((user) =&gt; (\n          &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default UsersList;\n</code></pre> </li> </ol>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/19/do-we-need-to-install-redux-thunk-separately-when-using-redux-toolkit/#summary","title":"Summary","text":"<ul> <li>No Separate Installation Needed: Redux Toolkit automatically includes redux-thunk, so you don\u2019t need to install it separately.</li> <li>Using Redux Saga: To use Redux Saga, you need to install it separately, create sagas for your asynchronous logic, and configure the saga middleware in your Redux store.</li> </ul> <p>This approach allows you to choose the best side-effect management strategy for your application, whether it's using built-in thunk support or the more advanced capabilities of Redux Saga.</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/05/18/understanding-eitemprops-in-react-and-ant-designs-menu-component/","title":"Understanding e.item.props in React and Ant Design's Menu Component","text":"","tags":["react","js"]},{"location":"blog/2024/05/18/understanding-eitemprops-in-react-and-ant-designs-menu-component/#understanding-eitemprops-in-react-and-ant-designs-menu-component","title":"Understanding <code>e.item.props</code> in React and Ant Design's Menu Component","text":"<p>In the context of Ant Design's Menu component, <code>e.item.props</code> refers to the properties of the Menu.Item component that triggered the click event. When a menu item is clicked, Ant Design provides an event object e that contains various details about the event. One of these details is <code>e.item</code>, which represents the <code>Menu.Item</code> that was clicked.</p>","tags":["react","js"]},{"location":"blog/2024/05/18/understanding-eitemprops-in-react-and-ant-designs-menu-component/#how-eitemprops-works","title":"How <code>e.item.props</code> Works?","text":"<p>When you create a Menu in Ant Design, each Menu.Item can have its own properties. These properties are similar to the props you would pass to any React component. For instance, you might pass a <code>key</code>, <code>title</code>, or <code>custom data-*</code> attributes to a Menu.Item.</p> <p>Example</p> React<pre><code>import React, { useState } from 'react';\nimport { Menu } from 'antd';\n\nconst MyMenuComponent = ({ menuData, handleMenuClick }) =&gt; {\n    const [selectedTitle, setSelectedTitle] = useState('');\n\n    const handleClick = (e) =&gt; {\n        const clickedTitle = e.item.props['data-title'];\n        setSelectedTitle(clickedTitle);\n        handleMenuClick(clickedTitle);\n    };\n\n    return (\n        &lt;Menu onClick={handleClick} style={{ width: 256 }} mode=\"inline\"&gt;\n            {menuData.map((item, index) =&gt; (\n                &lt;Menu.Item\n                key={item.id}\n                data-title={item.title}\n                &gt;\n                &lt;span&gt;{index + 1}. {item.title}&lt;/span&gt;\n                &lt;/Menu.Item&gt;\n            ))}\n        &lt;/Menu&gt;\n    );\n};\n\nexport default MyMenuComponent;\n</code></pre>","tags":["react","js"]},{"location":"blog/2024/05/18/understanding-eitemprops-in-react-and-ant-designs-menu-component/#why-use-eitemprops","title":"Why Use e.item.props?","text":"<p>Using <code>e.item.props</code> is beneficial for several reasons:</p> <ol> <li> <p>Dynamic Data Access:</p> <p>It allows you to dynamically access data associated with a menu item, such as titles, IDs, or custom attributes.</p> </li> <li> <p>Simplified Event Handling:</p> <p>Instead of setting up additional state or context to manage menu item data, you can directly access the properties within the event handler.</p> </li> <li> <p>Enhanced Flexibility:</p> <p>You can pass any data you need via custom attributes, making your components more flexible and easier to manage.</p> </li> </ol>","tags":["react","js"]},{"location":"blog/2024/05/18/understanding-eitemprops-in-react-and-ant-designs-menu-component/#conclusion","title":"Conclusion","text":"<p>Whether you're building a sidebar menu or any other interactive component, understanding how to use <code>e.item.props</code> effectively will enhance your React development experience.</p>","tags":["react","js"]},{"location":"blog/2024/05/21/exploring-objectprototype-in-javascript/","title":"Exploring Object.prototype in JavaScript","text":"","tags":["js"]},{"location":"blog/2024/05/21/exploring-objectprototype-in-javascript/#exploring-objectprototype-in-javascript","title":"Exploring <code>Object.prototype</code> in JavaScript","text":"<p>You can inspect the Object.prototype in various ways depending on the environment you are working in. Here are a few methods to do this:</p>","tags":["js"]},{"location":"blog/2024/05/21/exploring-objectprototype-in-javascript/#in-a-browser-console","title":"In a Browser Console","text":"<ul> <li>Open Developer Tools: You can usually open this by pressing <code>F12</code>, <code>Ctrl+Shift+I</code>, or <code>Cmd+Option+I</code>.</li> <li>Go to the Console Tab: Here you can execute JavaScript code.</li> <li> <p>Inspect <code>Object.prototype</code>: Type the following code and press Enter:</p> <pre><code>console.dir(Object.prototype);\n</code></pre> </li> </ul>","tags":["js"]},{"location":"blog/2024/05/21/exploring-objectprototype-in-javascript/#using-nodejs","title":"Using Node.js","text":"<ul> <li>Open a Terminal: Ensure you have Node.js installed.</li> <li>Run the Node.js REPL: Type node and press Enter.</li> <li> <p>Inspect <code>Object.prototype</code>: Type the following code and press Enter:</p> <pre><code>console.dir(Object.prototype);\n</code></pre> </li> </ul>","tags":["js"]},{"location":"blog/2024/05/21/exploring-objectprototype-in-javascript/#example-output","title":"Example Output","text":"<p>When you inspect <code>Object.prototype</code>, you should see an object with various methods and properties like <code>hasOwnProperty</code>, <code>toString</code>, <code>valueOf</code>, etc. Here is a partial example of what you might see:</p> <pre><code>{\n  constructor: \u0192 Object(),\n  hasOwnProperty: \u0192 hasOwnProperty(),\n  isPrototypeOf: \u0192 isPrototypeOf(),\n  propertyIsEnumerable: \u0192 propertyIsEnumerable(),\n  toLocaleString: \u0192 toLocaleString(),\n  toString: \u0192 toString(),\n  valueOf: \u0192 valueOf()\n}\n</code></pre>","tags":["js"]},{"location":"blog/2024/05/21/exploring-objectprototype-in-javascript/#exploring-in-detail","title":"Exploring in Detail","text":"<p>You can also explore the prototype chain by accessing properties and methods directly in the console. For example:</p> <pre><code>console.log(Object.prototype.hasOwnProperty);\nconsole.log(Object.prototype.toString);\n</code></pre> <p>These methods belong to the <code>Object.prototype</code> and are inherited by all objects created in JavaScript unless explicitly overridden.</p>","tags":["js"]},{"location":"blog/2024/05/17/understanding-functional-state-updates-in-react-a-deep-dive-into-setselectedgroupdata/","title":"Understanding Functional State Updates in React: A Deep Dive into setSelectedGroupData","text":"","tags":["react","js"]},{"location":"blog/2024/05/17/understanding-functional-state-updates-in-react-a-deep-dive-into-setselectedgroupdata/#understanding-functional-state-updates-in-react-a-deep-dive-into-setselectedgroupdata","title":"Understanding Functional State Updates in React: A Deep Dive into <code>setSelectedGroupData</code>","text":"<p>When managing state in React, especially with complex objects, you often need to update just one part of the state without affecting the rest. A common pattern for this is the functional state update, which ensures your state changes are safe, predictable, and efficient.</p> <p>Let\u2019s break down the line of code:</p> <pre><code>setSelectedGroupData((prevData) =&gt; ({\n    ...prevData,\n    isReadUnread: updatedIsRead,\n}));\n</code></pre> What\u2019s Happening Here? <ol> <li> <p>Functional Update:</p> <p>The function passed to <code>setSelectedGroupData</code> receives the previous state (<code>prevData</code>) as an argument. This approach is particularly useful when your new state depends on the previous one, preventing potential bugs caused by asynchronous state updates.</p> </li> <li> <p>Immutability with the Spread Operator:</p> <p>The spread operator (<code>...prevData</code>) is used to create a shallow copy of the current state. In React, state is immutable\u2014meaning you shouldn't modify it directly. By copying the existing state into a new object, you preserve immutability, which is crucial for React to efficiently detect changes and trigger re-renders.</p> </li> <li> <p>Merging State:</p> <p>After copying the old state, the <code>isReadUnread</code> property is updated with a new value (<code>updatedIsRead</code>). This process ensures that only this specific property is changed, while all other properties remain intact.</p> </li> </ol> Why Use This Pattern? <ul> <li>Avoiding Bugs: Functional updates ensure that your state is always based on the most current data, avoiding potential race conditions.</li> <li>Performance: By only changing the necessary parts of the state, React can optimize re-renders, leading to better performance.</li> <li>Readability: This pattern makes it clear which parts of the state are being updated, making your code easier to understand and maintain.</li> </ul>","tags":["react","js"]},{"location":"blog/2024/05/17/understanding-functional-state-updates-in-react-a-deep-dive-into-setselectedgroupdata/#conclusion","title":"Conclusion","text":"<p>Understanding and utilizing functional state updates in React is essential for building reliable and performant applications. By leveraging patterns like the one we've explored, you can ensure that your state management is both efficient and robust, paving the way for a smoother development process.</p>","tags":["react","js"]},{"location":"blog/2024/08/13/a-comparative-guide-to-lodash-and-javascript/","title":"A Comparative Guide to Lodash and JavaScript","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/08/13/a-comparative-guide-to-lodash-and-javascript/#a-comparative-guide-to-lodash-and-javascript","title":"A Comparative Guide to Lodash and JavaScript","text":"<p>When it comes to working with arrays and objects in JavaScript, developers often face the decision of using utility libraries like Lodash or sticking with plain JavaScript.</p> <p>Utility Libraries vs. Native Methods: A Comparative Guide to Lodash and JavaScript</p> <p>Both have their advantages, and the choice ultimately depends on your specific needs and project requirements.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/13/a-comparative-guide-to-lodash-and-javascript/#the-case-for-lodash","title":"The Case for Lodash","text":"<p>Lodash is a powerful utility library that provides a wide array of functions to simplify common programming tasks. Here are some benefits of using Lodash:</p> <ol> <li> <p>Ease of Use: Lodash functions are often easier to read and understand. For example, using <code>_.sortBy</code> or <code>_.uniqBy</code> allows for quick and intuitive operations without having to write complex logic.</p> </li> <li> <p>Performance: Lodash is optimized for performance, especially when dealing with large datasets. It includes features like lazy evaluation, which can be beneficial for performance-sensitive applications.</p> </li> <li> <p>Cross-Browser Compatibility: Lodash handles many quirks and inconsistencies in JavaScript across different browsers, ensuring that your code works reliably everywhere.</p> </li> <li> <p>Chaining: Lodash supports method chaining, enabling a more fluid coding style that can reduce verbosity when performing multiple operations.</p> </li> </ol>","tags":["Porgramming","React"]},{"location":"blog/2024/08/13/a-comparative-guide-to-lodash-and-javascript/#the-case-for-plain-javascript","title":"The Case for Plain JavaScript","text":"<p>While Lodash offers many conveniences, there are compelling reasons to use plain JavaScript:</p> <ol> <li> <p>No Dependencies: Using plain JavaScript means you avoid adding external libraries to your project, reducing the overall size of your application and minimizing potential dependency issues.</p> </li> <li> <p>Built-in Features: Modern JavaScript (ES6 and beyond) has introduced many powerful features like <code>Array.prototype.map</code>, <code>filter</code>, and <code>reduce</code>, making it easier to perform operations without additional libraries.</p> </li> <li> <p>Learning Opportunity: Writing functions in plain JavaScript helps deepen your understanding of the language. You\u2019ll become more familiar with the core principles and best practices of JavaScript.</p> </li> <li> <p>Performance for Small Tasks: For smaller tasks or applications, plain JavaScript may perform just as well, if not better, than using a library like Lodash. The overhead of including a library can be unnecessary for simple operations.</p> </li> </ol>","tags":["Porgramming","React"]},{"location":"blog/2024/08/13/a-comparative-guide-to-lodash-and-javascript/#conclusion","title":"Conclusion","text":"<p>In the end, the choice between Lodash and plain JavaScript often comes down to the specific requirements of your project. If you need quick and robust solutions for manipulating data and want to leverage a library's features, Lodash is an excellent choice. However, for smaller projects or when aiming for minimal dependencies, plain JavaScript is perfectly capable and may be the better option.</p> <p>By understanding the strengths of both approaches, developers can make informed decisions that suit their coding style and project needs. Whether you choose Lodash or plain JavaScript, the most important factor is writing clean, efficient, and maintainable code.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/13/a-comparative-guide-to-lodash-and-javascript/#real-example","title":"Real Example","text":"lodashPlain js <pre><code>import { uniqBy, sortBy } from \"lodash\";\n\ncase REFERENCE__TYPES.REFERENCE_CIRCULAR_PLANNING_ADD_SUCCESS:\n    const updateItems = state?.referencePartyListingCircularResponse;\n\n    return {\n        ...state,\n        referenceCircularPlanningAddLoading: false,\n        referenceCircularPlanningAddResponse: action.payload,\n        // referencePartyListingCircularResponse: [...updateItems, action.payload],\n        referencePartyListingCircularResponse: sortBy(\n            [...updateItems, action.payload],\n            \"partyName\"\n    ),\n};\n</code></pre> <pre><code>// Sort by partyName in ascending order\nconst sortedItems = newItems.sort((a, b) =&gt; a.partyName.localeCompare(b.partyName));\n</code></pre> <p>lodash</p> <p>Yes, you can import multiple specific functions from Lodash in a single import statement. For example, to import both <code>uniqBy</code> and <code>sortBy</code>, you can do it like this:</p> <pre><code>import { uniqBy, sortBy } from \"lodash\";\n</code></pre> <p>With this import, you can use both functions in your code without importing the entire Lodash library. Here's how you might use both in your reducer case:</p> <pre><code>import { uniqBy, sortBy } from 'lodash';\n\ncase REFERENCE__TYPES.REFERENCE_CIRCULAR_PLANNING_ADD_SUCCESS:\n  const updateItems = state?.referencePartyListingCircularResponse || [];\n  const newItems = [...updateItems, action.payload];\n\n  // Remove duplicates if needed and then sort\n  const uniqueItems = uniqBy(newItems, 'yourUniqueKey'); // replace 'yourUniqueKey' with the key for uniqueness\n  return {\n    ...state,\n    referenceCircularPlanningAddLoading: false,\n    referenceCircularPlanningAddResponse: action.payload,\n    referencePartyListingCircularResponse: sortBy(uniqueItems, 'yourSortKey'), // replace 'yourSortKey' with the property you want to sort by\n  };\n</code></pre> <p>This approach keeps your imports clean and efficient!</p> <p>Native js Methods</p> <p>You can sort an array of objects by a specific property, such as partyName, using the built-in JavaScript <code>Array.prototype.sort</code> method. Here\u2019s how you can do it without using Lodash:</p> CodeExplanationOptimize using <code>localeCompare</code> <pre><code>case REFERENCE__TYPES.REFERENCE_CIRCULAR_PLANNING_ADD_SUCCESS:\n    const updateItems = state?.referencePartyListingCircularResponse || [];\n    const newItems = [...updateItems, action.payload];\n\n    // Sort by partyName in ascending order\n    const sortedItems = newItems.sort((a, b) =&gt; {\n        if (a.partyName &lt; b.partyName) return -1;\n        if (a.partyName &gt; b.partyName) return 1;\n        return 0; // If they're equal\n    });\n\n    return {\n        ...state,\n        referenceCircularPlanningAddLoading: false,\n        referenceCircularPlanningAddResponse: action.payload,\n        referencePartyListingCircularResponse: sortedItems,\n    };\n</code></pre> <ul> <li>The sort method modifies the original array and sorts the items based on the partyName property.</li> <li> <p>The comparison function inside sort determines the order:</p> <ul> <li>If<code>a.partyName</code> is less than <code>b.partyName</code>, it returns <code>-1</code> (meaning <code>a</code> comes first).</li> <li>If<code>a.partyName</code> is greater than <code>b.partyName</code>, it returns <code>1</code> (meaning <code>b</code> comes first).</li> <li>If they are equal, it returns <code>0</code>, leaving their order unchanged.</li> </ul> </li> </ul> <p>This will sort your items in ascending order based on partyName.</p> <p>You can simplify the sorting logic using the localeCompare method, which is more concise and handles string comparison more effectively. Here\u2019s the optimized version:</p> <pre><code>// Sort by partyName in ascending order\nconst sortedItems = newItems.sort((a, b) =&gt; a.partyName.localeCompare(b.partyName));\n</code></pre> Explanation <p><code>localeCompare</code> compares two strings in the current locale, returning:</p> <ul> <li>A negative number if <code>a.partyName</code> comes before <code>b.partyName</code>.</li> <li>A positive number if <code>a.partyName</code> comes after <code>b.partyName</code>.</li> <li><code>0</code> if they are equal.</li> </ul> <p>This single line achieves the same result as the previous implementation but is cleaner and easier to read.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/","title":"Handling Circular References in JavaScript: Avoiding 'TypeError: cyclic object value' in JSON.stringify","text":"","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify","title":"Handling Circular References in JavaScript: Avoiding 'TypeError: cyclic object value' in JSON.stringify","text":"<p>The TypeError: cyclic object value error typically occurs when trying to convert a JavaScript object that contains circular references into a JSON string. Circular references happen when an object references itself either directly or indirectly, creating an infinite loop that <code>JSON.stringify</code> cannot handle.</p> <p>Here's an example of a circular reference:</p> <pre><code>let obj = {};\nobj.self = obj;\nJSON.stringify(obj); // TypeError: cyclic object value\n</code></pre>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#how-to-solve-it","title":"How to Solve It","text":"<p>To solve this issue, you have a few options:</p> <ol> <li> <p>Remove Circular References:</p> <p>Manually ensure that your object does not have any circular references before calling <code>JSON.stringify</code>.</p> </li> <li> <p>Use a Custom Replacer Function:</p> <p>Use a replacer function with <code>JSON.stringify</code> to filter out circular references.</p> </li> <li> <p>Use a Library:</p> <p>Utilize a library designed to handle circular references, such as <code>circular-json</code>(deprecated) or <code>flatted</code>.</p> <pre><code>function getCircularReplacer() {\n    const seen = new WeakSet();\n    return (key, value) =&gt; {\n        if (typeof value === \"object\" &amp;&amp; value !== null) {\n            if (seen.has(value)) {\n                return;\n            }\n            seen.add(value);\n        }\n        return value;\n    };\n}\n\nJSON.stringify(obj, getCircularReplacer());\n</code></pre> Danger <pre><code>npm install circular-json\n</code></pre> <pre><code>const CircularJSON = require('circular-json');\nconst jsonString = CircularJSON.stringify(obj);\n</code></pre> <p>Or using flatted:</p> Success <pre><code>npm install flatted\n</code></pre> <pre><code>const { stringify, parse } = require('flatted');\nconst jsonString = stringify(obj);\n</code></pre> </li> </ol>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#example-solution","title":"Example Solution","text":"<p>Here is an example of using a custom replacer function to handle circular references:</p> <pre><code>const obj1 = {};\nconst obj2 = { obj1 };\nobj1.obj2 = obj2;\n\nfunction getCircularReplacer() {\n    const seen = new WeakSet();\n    return (key, value) =&gt; {\n        if (typeof value === \"object\" &amp;&amp; value !== null) {\n            if (seen.has(value)) {\n                return;\n            }\n            seen.add(value);\n        }\n        return value;\n    };\n}\n\nconst jsonString = JSON.stringify(obj1, getCircularReplacer());\nconsole.log(jsonString);\n</code></pre> <p>By using these methods, you can avoid the TypeError: cyclic object value error and successfully convert your object to a JSON string.</p>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#improvement","title":"Improvement","text":"Example1 Bug <pre><code>style={{\n    display: \"flex\",\n    justifyContent:\n    JSON.stringify(item?.userId)?.toUpperCase() === appUserIdUC\n        ? \"flex-end\"\n        : \"flex-start\",\n}}\n</code></pre> <p>is this correct way to stringify data</p> <p>Using <code>JSON.stringify</code> in this context is unnecessary and not the correct approach for comparing strings. Instead, you should directly compare the values after ensuring they are strings. Here's the corrected version:</p> Success <pre><code>style={{\n    display: \"flex\",\n    justifyContent: item?.userId?.toString().toUpperCase() === appUserIdUC\n        ? \"flex-end\"\n        : \"flex-start\",\n}}\n</code></pre> <p>Explanation:</p> <ul> <li>item?.userId?.toString().toUpperCase(): This ensures that <code>item?.userId</code> is converted to a string and transformed to uppercase for comparison.</li> <li>appUserIdUC: This is assumed to be already in uppercase format for comparison.</li> </ul> <p>This approach avoids unnecessary stringification and makes the code cleaner and more efficient.</p>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#when-to-use-jsonstringify","title":"When to use JSON,stringify","text":"<p>In this context, JSON.stringify might be necessary if selectedAttendees is an array or an object that needs to be sent as a string in the bodyPayload. However, if selectedAttendees is already a string or a primitive value, JSON.stringify is not needed.</p> <pre><code> const bodyPayload = {\n            companyId: selectedCompanyId,\n            circularPlanningTemplateId: selectedMenuItem,\n            remarks: values?.remarks,\n            ModeofCommunication: remarksData?.remarks,\n            attentionTo: JSON.stringify(selectedAttendees),\n            isactive: true,\n        }; \n</code></pre> <p>Here\u2019s how you can adjust it based on different scenarios:</p>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#if-selectedattendees-is-an-array-or-object","title":"If selectedAttendees is an Array or Object:","text":"<p>If <code>selectedAttendees</code> is an array or object and you need to send it as a JSON string, your current approach is correct.</p> <pre><code>const bodyPayload = {\n    companyId: selectedCompanyId,\n    circularPlanningTemplateId: selectedMenuItem,\n    remarks: values?.remarks,\n    ModeofCommunication: remarksData?.remarks,\n    attentionTo: JSON.stringify(selectedAttendees), // Correct if selectedAttendees is an array or object\n    isactive: true,\n};\n</code></pre>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#summary","title":"Summary","text":"<ul> <li>Use <code>JSON.stringify</code> if selectedAttendees is an array or object.</li> <li>Do not use <code>JSON.stringify</code> if selectedAttendees is already a string.</li> </ul> <p>This ensures that the bodyPayload is constructed correctly based on the type of selectedAttendees.</p>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#scenario-circular-references-in-nested-objects","title":"Scenario: Circular References in Nested Objects","text":"<p>Imagine you have a complex data structure representing a company with departments, and each department has a reference to the company, creating a circular reference.</p> <pre><code>// Define a company object\nconst company = {\n    name: \"TechCorp\",\n    departments: []\n};\n\n// Define a department object\nconst department = {\n    name: \"Engineering\",\n    company: company // Circular reference\n};\n\n// Add the department to the company's departments array\ncompany.departments.push(department);\n\n// Attempt to stringify the company object\ntry {\n    const jsonString = JSON.stringify(company);\n    console.log(jsonString);\n} catch (error) {\n    console.error(\"Error stringifying object:\", error);\n}\n</code></pre>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#explanation","title":"Explanation:","text":"<ul> <li> <p>Circular Reference: The <code>company</code> object contains a reference to the <code>department</code> object, which in turn has a reference back to the company object. This creates a circular reference.</p> </li> <li> <p>JSON.stringify: When you try to convert the <code>company</code> object to a JSON string using <code>JSON.stringify</code>, the process fails because <code>JSON.stringify</code> cannot handle circular references.</p> </li> </ul>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#handling-the-circular-reference","title":"Handling the Circular Reference","text":"<p>To avoid the TypeError: cyclic object value error, you can use a custom replacer function or a library like <code>circular-json</code> or <code>flatted</code>.</p>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#avoiding-circular-references","title":"Avoiding Circular References","text":"<p>To avoid circular references, you can use a custom serializer or a library like flatted to handle circular references:</p> <p>First, install <code>flatted</code>:</p> <pre><code>npm install flatted\n</code></pre> <p>Then update the component to use <code>flatted</code>:</p> <pre><code>import React, { useState, useEffect } from 'react';\nimport { stringify } from 'flatted';\n\nconst ExampleComponent = () =&gt; {\n  const [employee, setEmployee] = useState({\n    name: \"Eve\",\n    position: \"Software Engineer\",\n    department: {}\n  });\n\n  useEffect(() =&gt; {\n    // Creating a circular reference\n    const department = {\n        name: \"Engineering\",\n        employees: [employee]\n    };\n\n    setEmployee(prevEmployee =&gt; {\n        const updatedEmployee = { ...prevEmployee, department };\n        department.manager = updatedEmployee; // Adding circular reference\n        return updatedEmployee;\n    });\n\n    try {\n        // console.log(JSON.stringify(employee));\n        console.log(stringify(employee)); // Using flatted.stringify\n    } catch (error) {\n        console.error(\"Error: \", error.message);\n    }\n  }, [employee]);\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Employee Details&lt;/h1&gt;\n      &lt;p&gt;Name: {employee.name}&lt;/p&gt;\n      &lt;p&gt;Position: {employee.position}&lt;/p&gt;\n      &lt;p&gt;Department: {employee.department.name}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default ExampleComponent;\n</code></pre> <p>By using the flatted library, you can handle circular references safely and serialize your objects without encountering the <code>TypeError: cyclic object value</code>.</p>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#real-time-office-error","title":"Real-Time Office Error","text":"Danger circularTemplate.js<pre><code>const handleMenuClick = (e) =&gt; {\n    setSelectedMenuItem(e.key);\n    // error on dispatch e.key\n    dispatch(actionForGetCircularPlanningCompanyDtos(e.key))\n    setSelectedMenuItemTitle(e.item.props['value'])\n};\n\n\nconst columns = [\n    {\n        title: \"Attention to\",\n        key: \"attentionTo\",\n        render: (record) =&gt; {\n            //   try {\n            //     return JSON.parse(record?.attentionTo &amp;&amp; record?.attentionTo)\n            //       ?.map((x) =&gt; x.AttentionTo)\n            //       ?.join(\", \");\n            //   } catch (error) {\n            //     console.error(\"Error parsing JSON:\", error);\n            //   }\n\n            try {\n                const rawAttentionTo = record?.attentionTo;\n\n                if (typeof rawAttentionTo === 'string' &amp;&amp;\n                    rawAttentionTo.trim().startsWith('[') &amp;&amp;\n                    rawAttentionTo.trim().endsWith(']')) {\n\n                    const attentionToArray = JSON.parse(rawAttentionTo);\n\n                    if (Array.isArray(attentionToArray) &amp;&amp; attentionToArray.length &gt; 0) {\n                        return attentionToArray.map((x) =&gt; x.AttentionTo).join(\", \");\n                    }\n                }\n\n                return \"\";\n            } catch (error) {\n                console.error(\"Error parsing JSON:\", error);\n                return \"\";\n            }\n        }\n    }\n]\n\n&lt;Table dataSource={companyDtosData} columns={columns} loading={getCircularPlanningCompanyDtosLoading} /&gt;\n</code></pre> Success <pre><code>// UPDATED\nconst handleMenuClick = (id, title) =&gt; {\n    setSelectedMenuItem(id);\n    setSelectedMenuItemTitle(title)\n    if(!isEmpty(id))\n        dispatch(actionForGetCircularPlanningCompanyDtos(id))\n};\n\n// added\nconst utilFunc = (data) =&gt; {\n    if (!data) return [];\n\n    return data.map((item, index) =&gt; {\n        let parsedAttentionTo = [];\n        try {\n            if (typeof item.attentionTo === 'string') {\n                parsedAttentionTo = JSON.parse(item.attentionTo);\n            }\n        } catch (error) {\n            console.error(`Error parsing attentionTo for item at index ${index}:`, error);\n        }\n\n        return {\n            ...item,\n            attentionTo: parsedAttentionTo // Ensure the key matches your data structure\n        };\n    });\n};\n\n// updated\nuseEffect(() =&gt; {\n    if (getCircularPlanningCompanyDtosResp) {\n        console.log('Original Response: ', getCircularPlanningCompanyDtosResp);\n\n        // Call utilFunc to parse attentionTo and update state\n        const parsedData = utilFunc(getCircularPlanningCompanyDtosResp);\n        console.log('Parsed Data: ', parsedData);\n        setCompanyDtosData(parsedData);\n    }\n}, [getCircularPlanningCompanyDtosResp]);\n\n\n...\n&lt;Menu\n    // REMOVED\n    // onClick={handleMenuClick}\n    style={{ width: 256 }}\n    defaultSelectedKeys={['0']}\n    defaultOpenKeys={['sub1']}\n    mode=\"inline\"\n&gt;\n    {allCircularPlanningTemplateLoading ? &lt;Skeleton active /&gt; : templateData.map((item, index) =&gt; (\n        &lt;Menu.Item\n            key={item?.id}\n            value={item?.title}\n            // className=\"sidebars__menu--item\"\n            // ADDED\n            onClick={() =&gt; handleMenuClick(item?.id, item?.title)}\n            className={`sidebars__menu--item ${index % 2 === 0 ? 'even-row' : 'odd-row'}`}\n        &gt;\n            &lt;span&gt;{index + 1}. {item.title}&lt;/span&gt;\n        &lt;/Menu.Item&gt;\n    ))}\n&lt;/Menu&gt;\n</code></pre>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#reference","title":"Reference","text":"<ul> <li>circular-json: deprecated</li> <li>flatted: sucessor of circular-json</li> </ul>","tags":["js"]},{"location":"blog/2024/05/12/handling-json-parsing-errors-in-javascript-a-practical-approach/","title":"Handling JSON Parsing Errors in JavaScript: A Practical Approach","text":"","tags":["react","js"]},{"location":"blog/2024/05/12/handling-json-parsing-errors-in-javascript-a-practical-approach/#handling-json-parsing-errors-in-javascript-a-practical-approach","title":"Handling JSON Parsing Errors in JavaScript: A Practical Approach","text":"<p>Parsing JSON strings in JavaScript can sometimes lead to unexpected errors, especially when dealing with data from various sources. One common error encountered is \"Unexpected token 's', 'string' is not valid JSON,\" indicating an issue with the input string. In this blog, we'll explore a practical approach to handle such errors effectively.</p>","tags":["react","js"]},{"location":"blog/2024/05/12/handling-json-parsing-errors-in-javascript-a-practical-approach/#understanding-the-problem","title":"Understanding the Problem","text":"<p>The error typically occurs when the input string is not a valid JSON format. For instance, when the input string is plain text or improperly formatted JSON, attempting to parse it will result in a syntax error. To address this, we need to ensure the input is a valid JSON string before parsing it.</p> <p>Bug</p> TypeError: cyclic object value in ReactTypeError: o is undefined <p>Error parsing JSON: SyntaxError: Unexpected token 's', \"string\" is not valid JSON</p> <ul> <li>Error \"Uncaught SyntaxError: Unexpected token with JSON.parse\"</li> <li>How to Fix SyntaxError: Unexpected token &lt; in JSON at position 0</li> <li>JavaScript TypeError \u2013 Cyclic object value</li> <li>TypeError: cyclic object value in React</li> </ul> <ul> <li>TypeError: Cannot read property '0' of undefined in react</li> </ul>","tags":["react","js"]},{"location":"blog/2024/05/12/handling-json-parsing-errors-in-javascript-a-practical-approach/#the-solution","title":"The Solution","text":"<p>To handle this issue, we can follow a structured approach:</p> <ol> <li> <p>Log the Raw Input:</p> <p>Inspect the raw input to understand its content.</p> </li> <li> <p>Check for Valid JSON:</p> <p>Ensure the input is a valid JSON string.</p> </li> <li> <p>Parse Safely:</p> <p>Parse the JSON string and handle any errors gracefully.</p> </li> </ol> <p>Example</p> explainclean code <pre><code>render: (record) =&gt; {\n    console.log(\"Record: \", record);\n\n    try {\n        const rawAttentionTo = record?.attentionTo;\n        console.log(\"Raw attentionTo: \", rawAttentionTo);\n\n        // Check if rawAttentionTo is a valid JSON string\n        if (typeof rawAttentionTo === 'string' &amp;&amp; \n            rawAttentionTo.trim().startsWith('[') &amp;&amp; \n            rawAttentionTo.trim().endsWith(']')) {\n\n            const attentionToArray = JSON.parse(rawAttentionTo);\n            console.log(\"Parsed Array: \", attentionToArray);\n\n            // Ensure the parsed value is an array and contains data\n            if (Array.isArray(attentionToArray) &amp;&amp; attentionToArray.length &gt; 0) {\n                return attentionToArray.map((x) =&gt; x.AttentionTo).join(\", \");\n            }\n        }\n\n        // Return a fallback value if attentionToArray is empty or not an array\n        return \"\";\n    } catch (error) {\n        console.error(\"Error parsing JSON:\", error);\n        return \"\"; // Return an empty string or a fallback value in case of error\n    }\n}\n</code></pre> <pre><code>render: (record) =&gt; {\n    try {\n        const rawAttentionTo = record?.attentionTo;\n\n        if (typeof rawAttentionTo === 'string' &amp;&amp; \n            rawAttentionTo.trim().startsWith('[') &amp;&amp; \n            rawAttentionTo.trim().endsWith(']')) {\n\n            const attentionToArray = JSON.parse(rawAttentionTo);\n\n            if (Array.isArray(attentionToArray) &amp;&amp; attentionToArray.length &gt; 0) {\n                return attentionToArray.map((x) =&gt; x.AttentionTo).join(\", \");\n            }\n        }\n\n        return \"\";\n    } catch (error) {\n        console.error(\"Error parsing JSON:\", error);\n        return \"\";\n    }\n}\n</code></pre>","tags":["react","js"]},{"location":"blog/2024/05/12/handling-json-parsing-errors-in-javascript-a-practical-approach/#why-this-approach-works","title":"Why This Approach Works","text":"<p>This approach works by ensuring that only valid JSON strings are parsed, preventing unexpected errors. By validating the input and handling errors gracefully, we ensure the application remains robust and user-friendly.</p>","tags":["react","js"]},{"location":"blog/2024/05/12/handling-json-parsing-errors-in-javascript-a-practical-approach/#conclusion","title":"Conclusion","text":"<p>Handling JSON parsing errors in JavaScript requires careful validation and error handling. By following the steps outlined above, you can effectively manage and debug JSON parsing issues, ensuring a smoother user experience. Whether you're dealing with data from APIs or other sources, this approach helps maintain the integrity and reliability of your application.</p>","tags":["react","js"]},{"location":"blog/2024/05/26/handling-multiple-api-calls-with-search-input-in-react-using-debouncing-and-axios/","title":"Handling Multiple API Calls with Search Input in React using Debouncing and Axios","text":"","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/26/handling-multiple-api-calls-with-search-input-in-react-using-debouncing-and-axios/#handling-multiple-api-calls-with-search-input-in-react-using-debouncing-and-axios","title":"Handling Multiple API Calls with Search Input in React using Debouncing and Axios","text":"<p>Handling multiple API calls in React when interacting with a search input requires careful management to ensure that the results are fetched in an efficient and user-friendly way. Several techniques and tools are available to manage multiple simultaneous API calls and handle issues like race conditions, debouncing, and performance optimization.</p> <p>Here are the techniques and tools you can use:</p>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/26/handling-multiple-api-calls-with-search-input-in-react-using-debouncing-and-axios/#1-debouncing","title":"1.  Debouncing","text":"<p>Debouncing is crucial to avoid making an API request on every keystroke in the search input. Instead, wait until the user has stopped typing for a short period (e.g., 300ms).</p> <p>Example:</p> <pre><code>import { useState, useEffect } from 'react';\nimport debounce from 'lodash.debounce';\n\nconst SearchComponent = () =&gt; {\n  const [query, setQuery] = useState('');\n  const [results, setResults] = useState([]);\n\n  const handleSearch = debounce(async (searchTerm) =&gt; {\n    if (searchTerm) {\n      const response1 = fetch(`https://api.example.com/search1?q=${searchTerm}`);\n      const response2 = fetch(`https://api.example.com/search2?q=${searchTerm}`);\n\n      const [result1, result2] = await Promise.all([response1, response2]);\n      const data1 = await result1.json();\n      const data2 = await result2.json();\n\n      // Combine results or handle them separately\n      setResults([...data1, ...data2]);\n    }\n  }, 300);\n\n  useEffect(() =&gt; {\n    handleSearch(query);\n  }, [query]);\n\n  return (\n    &lt;input \n      type=\"text\" \n      value={query} \n      onChange={(e) =&gt; setQuery(e.target.value)} \n      placeholder=\"Search...\"\n    /&gt;\n  );\n};\n</code></pre> <ul> <li>Tools: You can use libraries like <code>lodash.debounce</code> to debounce the search function.</li> <li>Why: This reduces unnecessary API calls and improves performance.</li> </ul>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/26/handling-multiple-api-calls-with-search-input-in-react-using-debouncing-and-axios/#2-cancelling-previous-requests-using-abortcontroller","title":"2.  Cancelling Previous Requests (Using AbortController)","text":"<p>When making multiple API calls, you should cancel the previous request if a new one is initiated, especially in scenarios like search inputs. This avoids race conditions where a slower previous call might overwrite a more recent one.</p> <pre><code>import { useState, useEffect } from 'react';\n\nconst SearchComponent = () =&gt; {\n  const [query, setQuery] = useState('');\n  const [results, setResults] = useState([]);\n\n  useEffect(() =&gt; {\n    const controller = new AbortController();\n    const signal = controller.signal;\n\n    const fetchData = async () =&gt; {\n      try {\n        const response1 = fetch(`https://api.example.com/search1?q=${query}`, { signal });\n        const response2 = fetch(`https://api.example.com/search2?q=${query}`, { signal });\n      }\n    }\n  })\n}\n</code></pre>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/26/handling-multiple-api-calls-with-search-input-in-react-using-debouncing-and-axios/#key-tools-and-techniques","title":"Key Tools and Techniques:","text":"<ul> <li>AbortController: For canceling ongoing API requests when a new request is made.</li> <li>Axios: To handle the HTTP requests with cancellation support.</li> <li>Lodash Debounce: To optimize API calls during search input.</li> <li>Promise.all: To handle multiple concurrent API calls.</li> </ul>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/13/history-api/","title":"History API","text":"","tags":["react","js"]},{"location":"blog/2024/05/13/history-api/#history-api","title":"History API","text":"<p>The History API in JavaScript provides methods to manipulate the browser's history stack programmatically. This allows developers to navigate back and forth between different states of the application without reloading the page. This API is particularly useful in single-page applications (SPAs) and web applications that dynamically load content without full page refreshes.</p> <p>The History interface of the History API allows manipulation of the browser session history, that is the pages visited in the tab or frame that the current page is loaded in.</p>","tags":["react","js"]},{"location":"blog/2024/05/13/history-api/#importance-of-history-api","title":"Importance of History API:","text":"<ul> <li> <p>Enhanced User Experience: Allows smoother navigation within an application without reloading the entire page, which can improve perceived performance and user experience.</p> </li> <li> <p>State Management: Enables saving and managing application state in the browser history, making it possible to bookmark or share specific states of the application.</p> </li> <li> <p>SEO Benefits: Helps in building SPAs that can still have SEO-friendly URLs and states, as the application can update the URL without reloading the page.</p> </li> </ul>","tags":["react","js"]},{"location":"blog/2024/05/13/history-api/#when-to-use-the-history-api","title":"When to Use the History API:","text":"<ul> <li> <p>Single-Page Applications (SPAs): When building applications where page transitions and state changes occur without full page reloads.</p> </li> <li> <p>Enhancing Navigation: When you want to enable back and forward navigation within your application's states or pages.</p> </li> <li> <p>Managing Application State: When you need to manage and update the browser URL to reflect different states or sections of your application.</p> </li> </ul> <p>Tip</p> Instance propertiesInstance methods <ul> <li>length</li> <li>scrollRestoration</li> <li>state</li> </ul> <ul> <li>back()</li> <li>forward()</li> <li>go()</li> <li>pushState()</li> <li>replaceState()</li> </ul> <p>Example</p> <pre><code>// Adding a new state to the history\nhistory.pushState({ page: 'home' }, \"Home\", \"/\");\n\n// Handling popstate event to detect back/forward navigation\nwindow.onpopstate = function(event) {\nconsole.log('Navigated to state:', event.state);\n// Code to update UI based on the state object\n};\n</code></pre> <p>In this simple example:</p> <ul> <li>history.pushState() adds a new state to the history stack with the specified state object <code>({ page: 'home' })</code>, a title (\"Home\"), and URL (\"/\").</li> <li>window.onpopstate listens for back/forward navigation events (popstate), allowing you to handle these events and update your UI accordingly.</li> </ul>","tags":["react","js"]},{"location":"blog/2024/05/13/history-api/#reference","title":"Reference","text":"<ul> <li>History: mozilla</li> <li>Working_with_the_History_API: mozzila</li> <li>api-reference history :github</li> </ul>","tags":["react","js"]},{"location":"blog/2024/08/06/how-many-concurrent-requests-can-a-web-browser-handle/","title":"How Many Concurrent Requests Can a Web Browser Handle?","text":"","tags":["antd","react"]},{"location":"blog/2024/08/06/how-many-concurrent-requests-can-a-web-browser-handle/#how-many-concurrent-requests-can-a-web-browser-handle","title":"How Many Concurrent Requests Can a Web Browser Handle?","text":"<p>The number of concurrent requests a web browser can handle depends on several factors including the browser type, version, and whether <code>HTTP/1.1</code> or <code>HTTP/2</code> is being used. </p> <p>Here's a general overview:</p> <ol> <li> <p>HTTP/1.1:</p> <ul> <li>Standard Limit: Most browsers traditionally limit the number of concurrent connections per domain to around 6. This limit is set to prevent overwhelming the server and to manage resources efficiently.</li> </ul> </li> <li> <p>HTTP/2:</p> <ul> <li>Improved Handling: HTTP/2 allows multiplexing, meaning multiple requests and responses can be sent over a single connection simultaneously. This significantly improves performance and reduces the need for multiple connections.</li> <li> <p>Connection Limit: With HTTP/2, browsers are more efficient in handling many concurrent requests as it uses a single connection to manage multiple streams.</p> </li> <li> <p>HTTP/3:</p> </li> <li> <p>Further Improvements: HTTP/3, which is based on QUIC (Quick UDP Internet Connections), offers even better performance and handles multiple requests efficiently over a single connection with reduced latency and improved speed.</p> </li> </ul> </li> </ol>","tags":["antd","react"]},{"location":"blog/2024/08/06/how-many-concurrent-requests-can-a-web-browser-handle/#standard-approach-for-managing-requests","title":"Standard Approach for Managing Requests:","text":"<ol> <li> <p>Throttle Requests:</p> <ul> <li>Purpose: To prevent overwhelming the browser or server with too many requests at once.</li> <li>How: Implement request throttling techniques where you control the rate of outgoing requests. This can be done using libraries or custom logic in your code.</li> </ul> </li> <li> <p>Use of HTTP/2 or HTTP/3:</p> <ul> <li>Purpose: To improve performance by allowing multiple requests over a single connection.</li> <li>How: Ensure your server supports HTTP/2 or HTTP/3 and that your application benefits from the multiplexing and efficiency provided by these protocols.</li> </ul> </li> <li> <p>Batch Requests:</p> <ul> <li>Purpose: To reduce the number of individual network requests by combining multiple requests into a single batch.</li> <li>How: Use techniques such as GraphQL to fetch multiple pieces of data in a single request or combine related REST API calls into a single request if supported by the API.</li> </ul> </li> <li> <p>Debounce and Throttle API Calls:</p> <ul> <li>Purpose: To avoid making excessive requests, especially in scenarios where users trigger requests rapidly (e.g., search suggestions).</li> <li>How: Implement debouncing (waiting a short time after the last user action before making a request) and throttling (limiting the number of requests over a certain period).</li> </ul> </li> <li> <p>Use Caching:</p> <ul> <li>Purpose: To reduce the number of requests sent to the server and improve performance by reusing previously fetched data.</li> <li>How: Implement client-side caching mechanisms, such as <code>Cache-Control</code> headers and local storage, to store and reuse data.</li> </ul> </li> <li> <p>Monitor and Optimize:</p> <ul> <li>Purpose: To ensure that your application remains performant and within the limits of browser capabilities.</li> <li>How: Use tools like browser developer tools, performance monitoring, and analytics to track and optimize the number of requests and their impact on performance.</li> </ul> </li> </ol>","tags":["antd","react"]},{"location":"blog/2024/08/06/how-many-concurrent-requests-can-a-web-browser-handle/#practical-example","title":"Practical Example:","text":"<p>If you have multiple independent API calls, you might handle them in parallel to optimize performance. Here\u2019s a simple example using <code>Promise.all</code> with <code>async/await</code>:</p> ExampleExplanation <pre><code>async function fetchMultipleData() {\n    try {\n        // Use Promise.all to handle multiple requests in parallel\n        const [response1, response2, response3] = await Promise.all([\n            fetch('https://api.example.com/data1'),\n            fetch('https://api.example.com/data2'),\n            fetch('https://api.example.com/data3')\n        ]);\n\n        // Convert responses to JSON\n        const data1 = await response1.json();\n        const data2 = await response2.json();\n        const data3 = await response3.json();\n\n        console.log('Data1:', data1);\n        console.log('Data2:', data2);\n        console.log('Data3:', data3);\n    } catch (error) {\n        console.error('Error:', error);\n    }\n}\n\nfetchMultipleData();\n</code></pre> <ul> <li>Parallel Requests: <code>Promise.all</code> runs all the fetch requests in parallel, efficiently handling multiple requests.</li> <li>Error Handling: Any errors in any of the requests are caught in the <code>catch</code> block.</li> </ul>","tags":["antd","react"]},{"location":"blog/2024/08/06/how-many-concurrent-requests-can-a-web-browser-handle/#summary","title":"Summary","text":"<ul> <li>Browser Limits: Browsers handle around 6 concurrent connections per domain with HTTP/1.1 and can handle many more with HTTP/2 and HTTP/3 due to multiplexing.</li> <li>Standard Approach: Use HTTP/2 or HTTP/3, implement request throttling and debouncing, batch requests, use caching, and monitor performance for optimal handling of requests.</li> </ul> <p>By following these practices, you can effectively manage concurrent requests and optimize the performance of your web applications.</p>","tags":["antd","react"]},{"location":"blog/2024/06/01/optimizing-javascript-object-manipulation-with-destructuring/","title":"Optimizing JavaScript Object Manipulation with Destructuring","text":"","tags":["Personal"]},{"location":"blog/2024/06/01/optimizing-javascript-object-manipulation-with-destructuring/#optimizing-javascript-object-manipulation-with-destructuring","title":"Optimizing JavaScript Object Manipulation with Destructuring","text":"<p>When working with objects in JavaScript, we often need to create a new object by including certain properties while omitting others. A common approach is to use the spread operator to copy the properties and then manually delete the unwanted ones. </p> <p>However, this can be optimized using destructuring.</p>","tags":["Personal"]},{"location":"blog/2024/06/01/optimizing-javascript-object-manipulation-with-destructuring/#the-problem","title":"The Problem","text":"<p>Here\u2019s a common pattern we often see when manipulating objects:</p> <pre><code>let apiPayload = {\n  ...updateApiData,\n  id: updateApiData?.referenceTemplateId,\n};\n\ndelete apiData?.referenceId;\ndelete apiData?.referenceTemplateId;\n</code></pre> <p>In this case, we\u2019re creating a new object (<code>apiPayload</code>) by copying all properties from <code>updateApiData</code> and then deleting two properties (<code>referenceId</code> and <code>referenceTemplateId</code>). While this works, it's not the most efficient way.</p>","tags":["Personal"]},{"location":"blog/2024/06/01/optimizing-javascript-object-manipulation-with-destructuring/#the-optimized-approach","title":"The Optimized Approach","text":"<p>Instead of creating an object and then using <code>delete</code> to remove properties, we can use object destructuring to omit properties we don't need and build the new object in one step:</p> <pre><code>let { referenceTemplateId, referenceId, ...rest } = updateApiData;\n\nlet apiPayload = {\n  ...rest,\n  id: referenceTemplateId\n};\n</code></pre>","tags":["Personal"]},{"location":"blog/2024/06/01/optimizing-javascript-object-manipulation-with-destructuring/#how-it-works","title":"How It Works:","text":"<ul> <li>Destructuring: In the first line, <code>referenceTemplateId</code> and <code>referenceId</code> are extracted from <code>updateApiData</code>, and <code>rest</code> contains the remaining properties.</li> <li>Spread Operator: The <code>rest</code> object is spread into the new <code>apiPayload</code>, and we explicitly set the <code>id</code> property to <code>referenceTemplateId</code>.</li> </ul>","tags":["Personal"]},{"location":"blog/2024/06/01/optimizing-javascript-object-manipulation-with-destructuring/#why-this-is-better","title":"Why This Is Better:","text":"<ul> <li>Cleaner Code: You avoid modifying the original object after its creation.</li> <li>More Efficient: Using destructuring is more declarative, making the intent of your code clearer.</li> <li>Immutable Approach: By avoiding <code>delete</code>, you\u2019re following a more functional approach to immutability, which is a best practice in many programming paradigms.</li> </ul>","tags":["Personal"]},{"location":"blog/2024/06/01/optimizing-javascript-object-manipulation-with-destructuring/#conclusion","title":"Conclusion","text":"<p>Destructuring is a powerful feature in JavaScript that allows us to write cleaner and more efficient code when manipulating objects. By using destructuring and the spread operator, we can optimize our code for readability and performance, making it more maintainable in the long run.</p>","tags":["Personal"]},{"location":"blog/2024/04/01/understanding-javascript-array-methods-mutating-vs-non-mutating/","title":"Understanding JavaScript Array Methods: Mutating vs. Non-Mutating","text":"","tags":["Programming"]},{"location":"blog/2024/04/01/understanding-javascript-array-methods-mutating-vs-non-mutating/#understanding-javascript-array-methods-mutating-vs-non-mutating","title":"Understanding JavaScript Array Methods: Mutating vs. Non-Mutating","text":"<p>When working with arrays in JavaScript, it's crucial to understand the distinction between mutating and non-mutating array methods. This differentiation plays a significant role in how arrays are manipulated and can greatly impact the behavior of your code.</p>","tags":["Programming"]},{"location":"blog/2024/04/01/understanding-javascript-array-methods-mutating-vs-non-mutating/#mutating-array-methods","title":"Mutating Array Methods:","text":"<p>Mutating array methods are those that modify the original array directly. They alter the array's contents in place, without creating a new array.</p> <p>Some commonly used mutating array methods include:</p> <ol> <li> <p><code>push()</code> and <code>pop()</code>: These methods add and remove elements from the end of the array, respectively.</p> </li> <li> <p><code>shift()</code> and <code>unshift()</code>: They add and remove elements from the beginning of the array, respectively.</p> </li> <li> <p><code>splice()</code>: This method can add, remove, or replace elements at any position within the array.</p> </li> <li> <p><code>sort()</code> and <code>reverse()</code>: These methods reorder the elements of the array.</p> </li> <li> <p><code>fill()</code> and <code>copyWithin()</code>: They modify elements within the array based on specified criteria.</p> </li> <li> <p><code>forEach()</code>: It iterates over each element of the array and allows you to perform actions on them.</p> </li> </ol>","tags":["Programming"]},{"location":"blog/2024/04/01/understanding-javascript-array-methods-mutating-vs-non-mutating/#non-mutating-array-methods","title":"Non-Mutating Array Methods:","text":"<p>Non-mutating array methods, on the other hand, do not modify the original array. Instead, they return a new array with the desired modifications, leaving the original array unchanged.</p> <p>Some common non-mutating array methods include:</p> <ol> <li> <p><code>concat()</code>:     This method combines two or more arrays and returns a new array.</p> </li> <li> <p><code>slice()</code>:     It returns a portion of the array without modifying the original array (returns a new array).</p> </li> <li> <p><code>filter()</code> and <code>map()</code>:     These methods create new arrays based on specific criteria or transformations applied to the original array's elements.</p> </li> <li> <p><code>reduce()</code> and <code>reduceRight()</code>:     They reduce the array to a single value based on a provided function.</p> </li> <li> <p><code>some()</code> and <code>every()</code>:     These methods check if certain conditions are met by at least one or all elements in the array, respectively.</p> </li> <li> <p><code>indexOf()</code> and <code>lastIndexOf()</code>:     They find the index of a specified element within the array.</p> </li> </ol> <p>Understanding the difference between <code>mutating</code> and <code>non-mutating</code> array methods is crucial for writing efficient and bug-free JavaScript code. Choosing the appropriate method based on your requirements can lead to cleaner, more maintainable code and prevent unintended side effects.</p>","tags":["Programming"]},{"location":"blog/2024/04/01/understanding-javascript-array-methods-mutating-vs-non-mutating/#conclusion","title":"Conclusion","text":"<p>In summary, mutating array methods directly modify the original array, while non-mutating array methods return a new array without altering the original one. By leveraging these methods effectively, you can harness the full power of JavaScript arrays in your projects.</p>","tags":["Programming"]},{"location":"blog/2024/05/15/javascript-arrow-functions/","title":"JavaScript Arrow Functions","text":"","tags":["js","arrow"]},{"location":"blog/2024/05/15/javascript-arrow-functions/#javascript-arrow-functions","title":"JavaScript Arrow Functions","text":"<p>Modern JavaScript introduced arrow functions as alternatives to regular functions. \u00adThere are two concepts you need to know about arrow functions.</p> <p>First, they use a dif\u00adfer\u00adent syntax than regular functions. Defining an arrow function is much quicker, requiring just a few characters and one line of code. The second impor\u00adt ant, but not so obvious, change is that they use something called a lexical scope, making them more intuitive and less error prone.</p>","tags":["js","arrow"]},{"location":"blog/2024/05/15/javascript-arrow-functions/#writing-arrow-functions","title":"Writing Arrow Functions","text":"<p>Instead of using the function keyword to declare an arrow function, we use the equal-to and greater-\u00adthan signs to form an arrow (=&gt;). This syntax, also called the fat arrow, reduces noise and results in more compact code.</p> <p>Therefore, modern JavaScript prefers this syntax when passing functions as arguments.</p> <p>In addition, if an arrow function has only one \u00adparameter and one statement, we can omit the curly brackets and the return keyword. In this compact form, we call the function a concise body function. Listing 2-10 shows the definition of a traditional function followed by an arrow function.</p> <pre><code>const traditional = function (x) {\n    return x * x;\n}\nconst conciseBody = x =&gt; x * x;\n</code></pre> <p>Listing 2-10: A traditional function and an arrow function with the concise body syntax </p> <p>We first define a standard function with the function keyword and familiar return statement. Then we write the same functionality as an arrow function with the concise body syntax. Here we omit the curly brackets and use an implied return statement, without the return keyword.</p>","tags":["js","arrow"]},{"location":"blog/2024/05/15/javascript-arrow-functions/#reference","title":"Reference","text":"<ul> <li>The complete developer by Martin Krause : pg-20</li> </ul>","tags":["js","arrow"]},{"location":"blog/2024/05/20/js-objects/","title":"JS objects","text":"","tags":["js"]},{"location":"blog/2024/05/20/js-objects/#js-objects","title":"JS objects","text":"<p>In JavaScript, every object inherits properties and methods from its prototype. The base object from which all other objects derive, Object.prototype, includes several built-in methods and properties that are fundamental to working with objects. Here are some of the most commonly used ones:</p> Built-ins PropertiesMethodsPrototypal Methods <ul> <li> <p>constructor</p> <ul> <li>Refers to the function that created the instance's prototype.</li> <li>Example: <code>obj.constructor</code></li> </ul> </li> <li> <p>proto</p> <ul> <li>Refers to the prototype of the object.</li> <li>Example: <code>obj.__proto__</code></li> </ul> </li> </ul> <ol> <li> <p>hasOwnProperty()</p> <ul> <li>Determines if an object has a property as its own (not inherited).</li> <li>Example: <code>obj.hasOwnProperty('propertyName')</code></li> </ul> </li> <li> <p>isPrototypeOf()</p> <ul> <li>Checks if an object exists in another object's prototype chain.</li> <li>Example: <code>prototypeObject.isPrototypeOf(obj)</code></li> </ul> </li> <li> <p>propertyIsEnumerable()</p> <ul> <li>Checks if a property is enumerable.</li> <li>Example: <code>obj.propertyIsEnumerable('propertyName')</code></li> </ul> </li> <li> <p>toString()</p> <ul> <li>Returns a string representation of the object.</li> <li>Example: <code>obj.toString()</code></li> </ul> </li> <li> <p>valueOf()</p> <ul> <li>Returns the primitive value of the specified object.</li> <li>Example: <code>obj.valueOf()</code></li> </ul> </li> <li> <p>toLocaleString()</p> <ul> <li>Returns a string representation of the object, localized according to the locale settings.</li> <li>Example: <code>obj.toLocaleString()</code></li> </ul> </li> </ol> <p>Static Methods</p> <ol> <li> <p>defineProperty() (added in ES5)</p> <ul> <li>Defines a new property directly on an object, or modifies an existing property on an object, and returns the object.</li> <li>Example: <code>Object.defineProperty(obj, 'newProp', { value: 42 })</code></li> </ul> </li> <li> <p>defineProperties() (added in ES5)</p> <ul> <li>Defines new or modifies existing properties directly on an object, returning the object.</li> <li>Example: <code>Object.defineProperties(obj, { 'prop1': { value: 42 }, 'prop2': { value: 43 } })</code></li> </ul> </li> <li> <p>getOwnPropertyDescriptor() (added in ES5)</p> <ul> <li>Returns a property descriptor for a named property on an object.</li> <li>Example: <code>Object.getOwnPropertyDescriptor(obj, 'propertyName')</code></li> </ul> </li> <li> <p>getOwnPropertyNames() (added in ES5)</p> <ul> <li>Returns an array of all properties (enumerable or not) found directly upon a given object.</li> <li>Example: <code>Object.getOwnPropertyNames(obj)</code></li> </ul> </li> <li> <p>keys() (added in ES5)</p> <ul> <li>Returns an array of a given object's own enumerable property names.</li> <li>Example: <code>Object.keys(obj)</code></li> </ul> </li> <li> <p>entries() (added in ES8)</p> <ul> <li>Returns an array of a given object's own enumerable string-keyed property [key, value] pairs.</li> <li>Example: <code>Object.entries(obj)</code></li> </ul> </li> <li> <p>values() (added in ES8)</p> <ul> <li>Returns an array of a given object's own enumerable property values.</li> <li>Example: <code>Object.values(obj)</code></li> </ul> </li> <li> <p>fromEntries() (added in ES10)</p> <ul> <li>Transforms a list of key-value pairs into an object.</li> <li>Example: <code>Object.fromEntries([['key1', 'value1'], ['key2', 'value2']])</code></li> </ul> </li> </ol> <p>JavaScript objects can also inherit methods from their prototypes. For example, arrays inherit methods from Array.prototype, strings from String.prototype, etc.</p> <p>Here's an example with arrays:</p> <ol> <li> <p>push()</p> <ul> <li>Adds one or more elements to the end of an array and returns the new length of the array.</li> <li>Example: <code>arr.push(element)</code></li> </ul> </li> <li> <p>pop()</p> <ul> <li>Removes the last element from an array and returns that element.</li> <li>Example: <code>arr.pop()</code></li> </ul> </li> <li> <p>map()</p> <ul> <li>Creates a new array populated with the results of calling a provided function on every element in the calling array.</li> <li>Example: <code>arr.map(function(element) { return element * 2; })</code></li> </ul> </li> </ol> <p>These are some of the core <code>methods</code> and <code>properties</code> that are built into JavaScript objects. The language also provides a robust set of methods and properties for specialized objects like <code>arrays</code>, <code>strings</code>, and <code>functions</code>.</p>","tags":["js"]},{"location":"blog/2024/05/20/js-objects/#prototype-constructor-methods","title":"Prototype &amp; Constructor Methods","text":"","tags":["js"]},{"location":"blog/2024/05/20/js-objects/#prototype-methods","title":"Prototype Methods","text":"<p>Prototype methods are defined on the constructor's prototype. All instances of the object share the same method.</p> <pre><code>function Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\n// Shared method (prototype method)\nPerson.prototype.sayHello = function() {\n  console.log('Hello, my name is ' + this.name);\n};\n\nlet person1 = new Person('Alice', 25);\nlet person2 = new Person('Bob', 30);\n\nperson1.sayHello(); // \"Hello, my name is Alice\"\nperson2.sayHello(); // \"Hello, my name is Bob\"\n\n// Both instances share the same sayHello method\nconsole.log(person1.sayHello === person2.sayHello); // true\n</code></pre> <p>In this example, <code>sayHello</code> is a prototype method, meaning <code>person1</code> and <code>person2</code> share the same <code>sayHello</code> method.</p>","tags":["js"]},{"location":"blog/2024/05/20/js-objects/#instance-specific-constructor-methods","title":"Instance-Specific (Constructor) Methods","text":"<p>Instance-specific methods are defined inside the constructor function. Each instance of the object will have its own copy of these methods.</p> <pre><code>function Person(name, age) {\n  this.name = name;\n  this.age = age;\n\n  // Instance-specific method (constructor method)\n  this.describe = function() {\n    console.log(this.name + ' is ' + this.age + ' years old.');\n  };\n}\n\nlet person1 = new Person('Alice', 25);\nlet person2 = new Person('Bob', 30);\n\nperson1.describe(); // \"Alice is 25 years old.\"\nperson2.describe(); // \"Bob is 30 years old.\"\n\n// Each instance has its own copy of describe\nconsole.log(person1.describe === person2.describe); // false\n</code></pre> <p>In this example, <code>describe</code> is a constructor method, meaning <code>person1</code> and <code>person2</code> each have their own copy of the describe method.</p>","tags":["js"]},{"location":"blog/2024/05/20/js-objects/#key-differences","title":"Key Differences","text":"<ul> <li> <p>Memory Efficiency:</p> <ul> <li>Constructor Methods: Each instance gets its own copy of the method, which can consume more memory.</li> <li>Prototype Methods: All instances share the same method, which is more memory-efficient.</li> </ul> </li> <li> <p>Usage:</p> <ul> <li>Constructor Methods: Use when each instance needs its own unique version of the method, often because the method relies on instance-specific data or state.</li> <li>Prototype Methods: Use when the method's behavior should be the same across all instances, to save memory and maintain consistency.</li> </ul> </li> </ul> Example <pre><code>function Person(name, age) {\n    this.name = name;\n    this.age = age;\n\n    // Instance-specific method (constructor method)\n    this.describe = function() {\n        console.log(this.name + ' is ' + this.age + ' years old.');\n    };\n}\n\n// Shared method (prototype method)\nPerson.prototype.sayHello = function() {\n    console.log('Hello, my name is ' + this.name);\n};\n\nlet person1 = new Person('Alice', 25);\nlet person2 = new Person('Bob', 30);\n\nperson1.describe(); // \"Alice is 25 years old.\"\nperson2.describe(); // \"Bob is 30 years old.\"\n\nperson1.sayHello(); // \"Hello, my name is Alice\"\nperson2.sayHello(); // \"Hello, my name is Bob\"\n\n// Each instance has its own copy of describe\nconsole.log(person1.describe === person2.describe); // false\n\n// Both instances share the same sayHello method\nconsole.log(person1.sayHello === person2.sayHello); // true\n</code></pre> <p>In this example:</p> <ul> <li><code>describe</code> is a constructor method, so each instance (<code>person1</code> and <code>person2</code>) has its own copy.</li> <li><code>sayHello</code> is a prototype method, so <code>person1</code> and <code>person2</code> share the same method.</li> </ul>","tags":["js"]},{"location":"blog/2024/05/20/js-objects/#terminology","title":"Terminology","text":"<p>Static methods and constructor methods are not the same in JavaScript. Let's delve into their differences with clear examples.</p>","tags":["js"]},{"location":"blog/2024/05/20/js-objects/#static-methods","title":"Static Methods","text":"<p>Static methods are methods defined on the constructor function itself. They are not available on instances of the constructor. Static methods are called directly on the constructor.</p> <pre><code>class Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n\n  // Static method\n  static compareAge(person1, person2) {\n    return person1.age - person2.age;\n  }\n}\n\nconst alice = new Person('Alice', 25);\nconst bob = new Person('Bob', 30);\n\n// Calling the static method on the constructor\nconsole.log(Person.compareAge(alice, bob)); // -5\n\n// Static method is not available on instances\nconsole.log(alice.compareAge); // undefined\n</code></pre> <p>In this example, <code>compareAge</code> is a static method defined on the <code>Person</code> constructor. It is called directly on <code>Person</code> and not on the instances (<code>alice</code> and <code>bob</code>).</p>","tags":["js"]},{"location":"blog/2024/05/20/js-objects/#constructor-methods-instance-methods","title":"Constructor Methods (Instance Methods)","text":"<p>Constructor methods are methods defined inside the constructor function. Each instance of the object will have its own copy of these methods.</p> <p>Constructor methods are defined inside the constructor function using this. They are specific to each instance of the object and are accessed through instances of the constructor.</p> <pre><code>class Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n\n    // Constructor method (instance method)\n    this.describe = function() {\n      console.log(`${this.name} is ${this.age} years old.`);\n    };\n  }\n}\n\nconst alice = new Person('Alice', 25);\nconst bob = new Person('Bob', 30);\n\n// Calling the constructor method on instances\nalice.describe(); // \"Alice is 25 years old.\"\nbob.describe(); // \"Bob is 30 years old.\"\n\n// Each instance has its own copy of describe\nconsole.log(alice.describe === bob.describe); // false\n</code></pre> <p>In this example, <code>describe</code> is a constructor method. Each instance (<code>alice</code> and <code>bob</code>) has its own copy of the <code>describe</code> method.</p>","tags":["js"]},{"location":"blog/2024/05/20/js-objects/#summary-of-differences","title":"Summary of Differences","text":"<ol> <li> <p>Definition and Availability:</p> <ul> <li>Static Methods: Defined on the constructor function itself. Available on the constructor, not on instances.</li> <li>Constructor Methods: Defined inside the constructor function. Each instance gets its own copy of the method.</li> </ul> </li> <li> <p>Calling:</p> <ul> <li>Static Methods: Called on the constructor itself.</li> <li>Constructor Methods: Called on instances of the constructor.</li> </ul> </li> </ol> Example Combining Both <pre><code>class Person {\n    constructor(name, age) {\n        this.name = name;\n        this.age = age;\n\n        // Constructor method\n        this.describe = function() {\n        console.log(`${this.name} is ${this.age} years old.`);\n        };\n    }\n\n    // Static method\n    static compareAge(person1, person2) {\n        return person1.age - person2.age;\n    }\n}\n\nconst alice = new Person('Alice', 25);\nconst bob = new Person('Bob', 30);\n\n// Calling the constructor method on instances\nalice.describe(); // \"Alice is 25 years old.\"\nbob.describe(); // \"Bob is 30 years old.\"\n\n// Calling the static method on the constructor\nconsole.log(Person.compareAge(alice, bob)); // -5\n\n// Static method is not available on instances\nconsole.log(alice.compareAge); // undefined\n\n// Each instance has its own copy of describe\nconsole.log(alice.describe === bob.describe); // false\n</code></pre> <p>In this example:</p> <ul> <li><code>compareAge</code> is a static method and is called on the Person constructor.</li> <li><code>describe</code> is a constructor method and is called on instances of Person.</li> </ul> how to know or check if it is contructor methods or static methods in javascript? <p>In JavaScript, whether a method is a constructor method (instance method) or a static method depends on where it is defined and how it is accessed. Here\u2019s how you can identify and distinguish between them:</p> Constructor Methods (Instance Methods)Static Methods <p>Constructor methods are defined inside the constructor function using this. They are specific to each instance of the object and are accessed through instances of the constructor.</p> <pre><code>class Person {\n    constructor(name, age) {\n        this.name = name;\n        this.age = age;\n\n        // Constructor method (instance method)\n        this.describe = function() {\n        console.log(`${this.name} is ${this.age} years old.`);\n        };\n    }\n}\n\nconst alice = new Person('Alice', 25);\n\n// Check if describe is a constructor method\nconsole.log(alice.describe); // function\n\n// Verify it's not available on the constructor itself\nconsole.log(Person.describe); // undefined\n</code></pre> <p>Static methods are defined on the constructor function directly using the static keyword. They are called on the constructor function itself, not on instances of the constructor.</p> <pre><code>class Person {\n    constructor(name, age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    // Static method\n    static compareAge(person1, person2) {\n        return person1.age - person2.age;\n    }\n}\n\nconst alice = new Person('Alice', 25);\n\n// Check if compareAge is a static method\nconsole.log(Person.compareAge); // function\n\n// Verify it's not available on instances of the constructor\nconsole.log(alice.compareAge); // undefined\n</code></pre> How to Identify Them <ul> <li> <p>Location of Definition:</p> <ul> <li>Constructor Methods: Defined inside the constructor function using this.</li> <li>Static Methods: Defined outside the constructor, prefixed with the static keyword within the class.</li> </ul> </li> <li> <p>Access Method:</p> <ul> <li>Constructor Methods: Accessed through instances of the constructor (<code>instance.method()</code>).</li> <li>Static Methods: Accessed directly on the constructor function itself (<code>Constructor.method()</code>).</li> </ul> </li> <li> <p>Usage:</p> <ul> <li>Constructor Methods: Typically used when each instance needs its own copy of the method, often to operate on instance-specific data.</li> <li>Static Methods: Used when the method does not depend on instance-specific data and is more utility-like, applying broadly to the constructor itself or its class.</li> </ul> </li> </ul> Checking in Practice <p>To check if a method is a constructor method or a static method in JavaScript:</p> <ol> <li> <p>Look at where the method is defined:</p> <ul> <li>Inside the constructor function (<code>this.method = function() {...}</code>): It\u2019s a constructor method.</li> <li>Using static keyword (<code>static methodName() {...}</code>): It\u2019s a static method.</li> </ul> </li> <li> <p>Verify how the method is accessed:</p> <ul> <li>Through instances (<code>instance.method()</code>): It\u2019s likely a constructor method.</li> <li>On the constructor itself (<code>Constructor.method()</code>): It\u2019s likely a static method.</li> </ul> </li> </ol> <p>By understanding these distinctions, you can effectively identify and differentiate between constructor methods and static methods in JavaScript classes.</p>","tags":["js"]},{"location":"blog/2024/05/20/js-objects/#reference","title":"Reference","text":"<ul> <li>multipart requests</li> <li>What does enctype='multipart/form-data' mean?</li> <li></li> </ul>","tags":["js"]},{"location":"blog/2024/08/16/libraries-for-immutable-data-structure-in-react/","title":"Libraries for Immutable Data Structure in React","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/08/16/libraries-for-immutable-data-structure-in-react/#libraries-for-immutable-data-structure-in-react","title":"Libraries for Immutable Data Structure in React","text":"<p>Immer and Immutable.js are libraries that help manage immutable data in JavaScript, but they do so in different ways.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/16/libraries-for-immutable-data-structure-in-react/#1-immer","title":"1. Immer","text":"<p>Immer is great when you want immutability but don't want to change your code style too much. It lets you write code that looks like you\u2019re mutating state directly, but under the hood, it\u2019s creating a new state for you. Immer is often used in projects like Redux because it simplifies updating nested state without mutating it.</p> <p>When to use Immer?</p> <ul> <li>When you want simple syntax for managing immutable state.</li> <li>When you have deeply nested data and don\u2019t want to write repetitive code for immutability.</li> <li>It's particularly handy in state management (like Redux reducers).</li> </ul> Example using Immer <pre><code>import produce from 'immer';\n\n// Initial state\nconst state = {\n    user: {\n        name: 'John',\n        address: {\n            city: 'New York',\n            zip: '10001'\n        }\n    }\n};\n\n// Reducer with Immer\nconst newState = produce(state, draft =&gt; {\n    draft.user.address.city = 'San Francisco'; // Looks like mutation, but Immer makes this immutable.\n});\n\nconsole.log(newState);\n// {\n//   user: {\n//     name: 'John',\n//     address: {\n//       city: 'San Francisco',\n//       zip: '10001'\n//     }\n//   }\n// }\n</code></pre> <p>Why use Immer?</p> <p>Immer reduces the complexity of maintaining immutability, especially when dealing with deeply nested structures. It\u2019s easy to read and maintain since the code looks like you're directly mutating the data.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/16/libraries-for-immutable-data-structure-in-react/#2-immutablejs","title":"2. Immutable.js","text":"<p>Immutable.js is a more functional and strict approach to immutability. It provides immutable versions of JavaScript's common data structures (Lists, Maps, Sets, etc.) and guarantees immutability at the data structure level. However, it requires you to use Immutable.js specific APIs, which can make the code less readable for some developers who are not familiar with it.</p> <p>When to use Immutable.js?</p> <ul> <li>When you need a strict, performance-optimized immutable data structure.</li> <li>When working in a large-scale application where immutability is crucial, and you want to avoid accidental mutations.</li> <li>If you prefer working with functional programming paradigms.</li> </ul> Example using Immutable.js <pre><code>import { Map } from 'immutable';\n\n// Initial state as an Immutable Map\nconst state = Map({\n    user: Map({\n        name: 'John',\n        address: Map({\n            city: 'New York',\n            zip: '10001'\n        })\n    })\n});\n\n// Update state immutably\nconst newState = state.setIn(['user', 'address', 'city'], 'San Francisco');\n\nconsole.log(newState.toJS()); // Convert to plain JavaScript object\n// {\n//   user: {\n//     name: 'John',\n//     address: {\n//       city: 'San Francisco',\n//       zip: '10001'\n//     }\n//   }\n// }\n</code></pre> <p>Why use Immutable.js?</p> <p>Immutable.js ensures complete immutability and provides a rich API for working with immutable data structures. It\u2019s highly performant for large collections, but it has a steeper learning curve and can require more boilerplate than Immer.</p> Comparison of Immer vs. Immutable.js <ul> <li>Ease of Use Immer is easier to use and integrate into existing codebases since it allows you to work with plain JavaScript objects. Immutable.js requires learning a new API.</li> <li>Performance: Immutable.js may offer better performance for large datasets due to its structural sharing, but for most applications, Immer\u2019s performance is more than sufficient.</li> <li>Code Readability: Immer allows code that looks like mutable code (but is actually immutable), making it more readable, while Immutable.js requires its own methods, which can be less intuitive.</li> </ul> <p>When to choose one over the other:</p> <ul> <li>Use Immer when you want a simple, easy-to-adopt solution and are working with nested state in frameworks like Redux.</li> <li>Use Immutable.js when you need strict immutability enforcement, especially in larger-scale applications where performance on large datasets is a concern.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/16/libraries-for-immutable-data-structure-in-react/#additional","title":"Additional","text":"<p>is immer is used under the hood in redux. so we don't need to use immer in redux. is that correct?</p> <p>Yes, you're partially correct! Here's how it works:</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/16/libraries-for-immutable-data-structure-in-react/#immer-in-redux","title":"Immer in Redux:","text":"<ul> <li>Since Redux Toolkit (RTK) was introduced, Immer has been used under the hood by default for handling state updates in reducers. This means that when you use <code>createSlice</code>, <code>createReducer</code>, or similar utility functions provided by Redux Toolkit, you can write reducers that look like they are mutating the state, but Redux Toolkit ensures immutability using Immer behind the scenes.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/16/libraries-for-immutable-data-structure-in-react/#so-do-you-need-to-use-immer-explicitly-in-redux-toolkit","title":"So, do you need to use Immer explicitly in Redux Toolkit?","text":"<p>No, you don't need to explicitly use Immer in Redux Toolkit. The toolkit takes care of immutability for you, and you can safely write \"mutative\" logic inside reducers as if you are modifying the state directly.</p> <p>However:</p> <ul> <li>If you're using plain Redux (not Redux Toolkit), you will need to manage immutability yourself. In that case, using Immer explicitly in reducers can be very helpful to simplify managing immutable state.</li> </ul> Example with Redux Toolkit (Immer is built-in): <pre><code>import { createSlice } from '@reduxjs/toolkit';\n\nconst userSlice = createSlice({\n    name: 'user',\n    initialState: { name: 'John', city: 'New York' },\n    reducers: {\n        updateCity(state, action) {\n            state.city = action.payload; // Looks like mutation, but Immer handles immutability\n        }\n    }\n});\n\nexport const { updateCity } = userSlice.actions;\nexport default userSlice.reducer;\n</code></pre> <p>In the above code, Immer is used under the hood to handle immutability, even though the <code>updateCity</code> reducer seems to modify the state directly.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/16/libraries-for-immutable-data-structure-in-react/#if-youre-using-plain-redux-without-redux-toolkit","title":"If you're using plain Redux (without Redux Toolkit):","text":"<p>If you\u2019re working with plain Redux and writing reducers manually, you'll have to either enforce immutability yourself (e.g., using <code>Object.assign</code> or the spread operator) or you can explicitly use Immer to simplify the process.</p> <pre><code>import produce from \"immer\";\n\nconst userReducer = (state = { name: \"John\", city: \"New York\" }, action) =&gt; {\n  switch (action.type) {\n    case \"UPDATE_CITY\":\n      return produce(state, (draft) =&gt; {\n        draft.city = action.payload; // Immer ensures immutability here\n      });\n    default:\n      return state;\n  }\n};\n</code></pre>","tags":["Porgramming","React"]},{"location":"blog/2024/08/16/libraries-for-immutable-data-structure-in-react/#summary","title":"Summary:","text":"<ul> <li>Redux Toolkit: Uses Immer under the hood, so you don\u2019t need to worry about immutability.</li> <li>Plain Redux: You have to enforce immutability yourself, but you can use Immer explicitly to make it easier.</li> </ul> <p>If you're using Redux Toolkit, you don't need to explicitly use Immer for immutability.</p> Title <ul> <li>Understanding Immutable State in Redux: How Immer Simplifies Your Code</li> <li>Immer in Redux Toolkit: The Secret to Easy State Management</li> <li>Why You Don\u2019t Need to Worry About Immutability with Redux Toolkit and Immer</li> <li>Redux Toolkit\u2019s Hidden Power: How Immer Handles State Mutations</li> <li>Simplify Your Redux Reducers with Immer and Redux Toolkit</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/16/libraries-for-immutable-data-structure-in-react/#additional-2","title":"Additional 2","text":"<p>The most widely used library for immutability in React is Immer. It has gained popularity due to its simplicity and ease of use, especially in conjunction with state management libraries like Redux.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/16/libraries-for-immutable-data-structure-in-react/#when-to-use-each-library","title":"When to Use Each Library","text":"<ol> <li> <p>Immutable.js</p> <ul> <li>Use When: You need complex data structures and want a comprehensive solution for immutability (e.g., large-scale applications with performance concerns).</li> <li>Pros: Offers rich data types (<code>Map</code>, <code>List</code>, <code>Set</code>) and optimizations for large data sets.</li> <li>Cons: Larger bundle size and steeper learning curve.</li> </ul> </li> <li> <p>Immer</p> <ul> <li>Use When: You want to simplify state management while maintaining immutability, especially in Redux or React state.</li> <li>Pros: Allows you to write mutable-like code, which is intuitive and easy to understand.</li> <li>Cons: Slightly less control over performance optimizations compared to Immutable.js.</li> </ul> </li> <li> <p>Immerable</p> <ul> <li>Use When: You want to make class instances immutable easily, while still using your own class methods.</li> <li>Pros: Integrates seamlessly with class-based components.</li> <li>Cons: More niche use case; not as widely adopted.</li> </ul> </li> <li> <p>Immutable-assign</p> <ul> <li>Use When: You need a lightweight solution for making simple updates to objects/arrays immutably.</li> <li>Pros: Simple API, minimal overhead.</li> <li>Cons: Limited functionality compared to other libraries.</li> </ul> </li> <li> <p>Seamless-immutable</p> <ul> <li>Use When: You want a straightforward library for creating immutable objects and arrays without additional complexity.</li> <li>Pros: Very easy to use and integrate.</li> <li>Cons: Lacks advanced data structures.</li> </ul> </li> <li> <p>Ramda</p> <ul> <li>Use When: You need a full-fledged functional programming library with immutability utilities.</li> <li>Pros: Comprehensive set of utilities for functional programming and immutability.</li> <li>Cons: Larger library; may be overkill if you only need immutability.</li> </ul> </li> <li> <p>Redux Toolkit</p> <ul> <li>Use When: You are using Redux for state management and want to leverage Immer\u2019s capabilities without adding another dependency.</li> <li>Pros: Built-in support for immutability, simplified setup for Redux.</li> <li>Cons: Only useful within the context of Redux.</li> </ul> </li> </ol> Summary <ul> <li>Choose Immer for most React state management scenarios.</li> <li>Choose Immutable.js for complex data structures and performance-critical applications.</li> <li>Use Redux Toolkit if you're already working with Redux and want to simplify state updates.</li> <li>Use simpler libraries (like seamless-immutable or immutable-assign) for lightweight projects or specific use cases.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/09/loglist/","title":"Loglist","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/08/09/loglist/#loglist","title":"Loglist","text":"Companies.jsapi.jsaction.jsreducer.jsComponent <pre><code>import LogList from \"./LogList\";\n\nconst Companies = ({\n    searchEmailTender,\n    rowEventhandlers,\n    companyId,\n    emailReferenceId,\n    getDetails,\n    selectedTenderRowId,\n    isCircular,\n    showProjectTab,\n    selectedBusinessTabPaneKey,\n    selectedCompanyAttentionToIds,\n}) =&gt; {\n    {\n        /* added */\n    }\n    const {\n        getCircularPlanningResp,\n        getCircularPlanningLoading,\n    } = useSelector((state) =&gt; state.reference);\n\n    const [activeKey, setActiveKey] = useState(\"1\");\n\n    const handleTabChange = (key) =&gt; {\n        setActiveKey(key);\n\n        if (key === \"4\") {\n        dispatch(actionForCircularPlanningLog());\n        }\n    };\n\n    useEffect(() =&gt; {\n        setActiveKey(\"1\");\n        setCompanyDetails();\n        setContactPerson();\n        setRemarksHistory();\n    }, [selectedTenderRowId]);\n\n    return (\n        &lt;&gt;\n        {/* ........ */}\n        &lt;Tabs\n            // defaultActiveKey=\"1\"\n            activeKey={activeKey}\n            type=\"line\"\n            className=\"circularplanning__tabs--contact\"\n            onChange={handleTabChange}\n        &gt;\n            &lt;TabPane tab=\"Contact Details\" key=\"1\"&gt;\n                {contactDetails()}\n            &lt;/TabPane&gt;\n            &lt;TabPane tab=\"Tender Checklist\" key=\"2\"&gt;\n            &lt;div className=\"person_info tender-checklist\"&gt;\n                &lt;div className=\"company_header\"&gt;\n                &lt;div\n                    className=\"referenceDetails__label\"\n                    style={{\n                        display: \"flex\",\n                        width: \"100%\",\n                        justifyContent: \"space-between\",\n                    }}\n                &gt;\n                    &lt;button className=\"referenceDetails--title header_print_btn\"&gt;\n                    Tender Checklist\n                    &lt;/button&gt;\n                    &lt;Button\n                        style={{ height: \"28px\", lineHeight: \"21px\" }}\n                        type=\"primary\"\n                        onClick={() =&gt; setModalVisible(true)}\n                    &gt;\n                    Circular Content\n                    &lt;/Button&gt;\n                &lt;/div&gt;\n                &lt;/div&gt;\n                &lt;CheckListContainer referenceId={getDetails?.referenceId} /&gt;\n            &lt;/div&gt;\n            &lt;/TabPane&gt;\n            &lt;TabPane tab=\"Log List\" key=\"4\"&gt;\n                {/* ADDED */}\n                {activeKey === \"4\" &amp;&amp; (\n                    &lt;LogList\n                        loading={getCircularPlanningLoading}\n                        data={getCircularPlanningResp}\n                    /&gt;\n                )}\n                &lt;LogList /&gt;\n            &lt;/TabPane&gt;\n        &lt;/Tabs&gt;;\n        &lt;/&gt;\n    );\n};\n</code></pre> <pre><code>import queryString from \"query-string\";\nimport { appBaseUrl, baseUrl, cqBaseUrl } from \"utils/config\";\nimport { getService, postService, putService } from \"../../commonServices\";\n\nexport class ReferencesService {\n    // loglist\n    getCircularPlanningLog(body) {\n        // let url = `${appBaseUrl}/referenceManagement/circularplanninglogsGetAllData`;\n        let url = `https://my-json-server.typicode.com/Bishow-Thapa/my-json-server/items`;\n        console.log(\"im callled\");\n        let data = getService(url, body);\n        return data;\n    }\n}\n</code></pre> <pre><code>// log\nexport const actionForCircularPlanningLog = (body) =&gt; {\n    console.log(\"Fetching log list...\"); // Debugging log\n    return async (dispatch) =&gt; {\n        dispatch(init(REFERENCE__TYPES.GET_CIRCULAR_PLANNING_LOG));\n        const response = await referencesService.getCircularPlanningLog(body);\n\n        if (response.isSuccess) {\n            dispatch(\n                success(REFERENCE__TYPES.GET_CIRCULAR_PLANNING_LOG, response.data)\n            );\n        } else if (!response.isSuccess) {\n            dispatch(error(response.errorMessage));\n        }\n        dispatch(finish(REFERENCE__TYPES.GET_CIRCULAR_PLANNING_LOG));\n    };\n};\n</code></pre> <pre><code>import { CALENDAR_EVENTS_TYPES, GLOBAL, REFERENCE__TYPES } from \"../../types\";\nimport { uniqBy } from \"lodash\";\n\nconst INITIAL_STATE = {\n    {/* ... */}\n    getCircularPlanningResp: [],\n    getCircularPlanningLoading: false,\n    {/* ... */}\n};\n\nexport default function referenceReducer(state = INITIAL_STATE, action) {\n    switch (action.type) {\n        // log\n        case REFERENCE__TYPES.GET_CIRCULAR_PLANNING_LOG_INIT:\n            return {\n                ...state,\n                getCircularPlanningResp: [],\n                getCircularPlanningLoading: true,\n            };\n\n        case REFERENCE__TYPES.GET_CIRCULAR_PLANNING_LOG_SUCCESS:\n            return {\n                ...state,\n                getCircularPlanningResp: action.payload,\n                getCircularPlanningLoading: false,\n            };\n\n        case REFERENCE__TYPES.GET_CIRCULAR_PLANNING_LOG_FINISH:\n            return {\n                ...state,\n                getCircularPlanningLoading: false,\n            };\n    }\n}\n</code></pre> LogList/index.js<pre><code>import React, { useEffect, useReducer } from \"react\";\nimport { Table } from \"antd\";\nimport moment from \"moment\";\n\nconst LogList = (props) =&gt; {\n    let { loading, data } = props;\n\n    const columns = [\n        {\n            title: \"S.N\",\n            dataIndex: \"key\",\n            render: (_, __, index) =&gt; index + 1,\n        },\n        {\n            title: \"Remarks\",\n            dataIndex: \"remarks\",\n            key: \"remarks\",\n        },\n        {\n            title: \"Creation Time\",\n            dataIndex: \"creationTime\",\n            key: \"creationTime\",\n            render: (text) =&gt; moment(text).format(\"YYYY-MM-DD\"),\n        },\n    ];\n\n    //   const dataSource =\n    //     data.map((log) =&gt; ({\n    //       key: log.id,\n    //       remarks: log.remarks,\n    //       creationTime: log.creationTime,\n    //     })) || [];\n    const dataSource = (data || []).map((log) =&gt; ({\n        key: log.id,\n        remarks: log.remarks,\n        creationTime: log.creationTime,\n    }));\n\n    return (\n        &lt;Table\n            dataSource={dataSource}\n            loading={loading}\n            columns={columns}\n            pagination={false}\n        /&gt;\n    );\n};\n\nexport default LogList;\n</code></pre>","tags":["Porgramming","React"]},{"location":"blog/2024/06/03/mastering-object-destructuring-rest-and-spread-operators-in-javascript/","title":"Mastering Object Destructuring, Rest, and Spread Operators in JavaScript","text":"","tags":["react"]},{"location":"blog/2024/06/03/mastering-object-destructuring-rest-and-spread-operators-in-javascript/#mastering-object-destructuring-rest-and-spread-operators-in-javascript","title":"Mastering <code>Object Destructuring</code>, <code>Rest</code>, and <code>Spread</code> Operators in JavaScript","text":"<p>JavaScript\u2019s modern syntax enhancements make working with objects and arrays cleaner and more intuitive. Among these features, object destructuring, the rest operator, and the spread operator stand out. Let\u2019s dive into each of these, understand their use cases, and learn how to wield them like a pro.</p>","tags":["react"]},{"location":"blog/2024/06/03/mastering-object-destructuring-rest-and-spread-operators-in-javascript/#overview","title":"Overview","text":"","tags":["react"]},{"location":"blog/2024/06/03/mastering-object-destructuring-rest-and-spread-operators-in-javascript/#object-destructuring","title":"Object Destructuring","text":"<p>Object destructuring allows you to extract values from objects and assign them to variables in a concise way. This not only makes your code cleaner but also helps in avoiding repetitive code.</p> ExampleWhen to UseWhen Not to Use <pre><code>const person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"Wonderland\"\n};\n\n// Traditional access\nconst name = person.name;\nconst age = person.age;\n\n// Destructuring\nconst { name, age } = person;\n\nconsole.log(name); // Alice\nconsole.log(age);  // 30\n</code></pre> <ul> <li>Extracting Multiple Properties: Use destructuring when you need to pull multiple properties from an object.</li> <li>Renaming Variables: When you need different variable names, destructuring allows you to rename properties during extraction.</li> <li>Providing Default Values: Destructuring lets you set default values for properties that may be undefined.</li> </ul> <ul> <li>If Not Extracting Multiple Properties: If you're only accessing one or two properties, the traditional way might be simpler.</li> <li>For Deeply Nested Properties: For deeply nested objects, destructuring can become cumbersome. Use it judiciously.</li> </ul>","tags":["react"]},{"location":"blog/2024/06/03/mastering-object-destructuring-rest-and-spread-operators-in-javascript/#rest-operator","title":"Rest Operator","text":"<p>The rest operator allows you to collect the remaining properties of an object (or elements of an array) into a new object (or array). It\u2019s perfect for scenarios where you need to handle some properties separately while keeping the rest.</p> ExampleWhen to UseWhen Not to Use <pre><code>const person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"Wonderland\",\n    profession: \"Engineer\"\n};\n\n// Destructuring with rest\nconst { name, ...rest } = person;\n\nconsole.log(name);   // Alice\nconsole.log(rest);   // { age: 30, city: 'Wonderland', profession: 'Engineer' }\n</code></pre> <ul> <li>Separating Properties: When you want to isolate specific properties and work with the rest.</li> <li>Managing Dynamic Data: For scenarios where the number of properties can change and you want to handle them flexibly.</li> </ul> <ul> <li>If You Need All Properties: If you need to work with all properties, the rest operator might add unnecessary complexity.</li> </ul>","tags":["react"]},{"location":"blog/2024/06/03/mastering-object-destructuring-rest-and-spread-operators-in-javascript/#spread-operator","title":"Spread Operator","text":"<p>The spread operator allows you to create a new object or array by copying properties or elements from an existing one. It\u2019s ideal for merging objects, cloning, or adding new elements.</p> ExampleWhen to UseWhen Not to Use <pre><code>const person = {\n    name: \"Alice\",\n    age: 30\n};\n\n// Cloning and extending an object\nconst updatedPerson = {\n    ...person,\n    city: \"Wonderland\"\n};\n\nconsole.log(updatedPerson);\n// { name: 'Alice', age: 30, city: 'Wonderland' }\n</code></pre> <ul> <li>Merging Objects or Arrays: When you need to combine objects or arrays without mutating the originals.</li> <li>Cloning: To create a shallow copy of an object or array, ensuring immutability.</li> <li>Adding or Modifying Elements: When you want to add new properties or elements while retaining the existing ones.</li> </ul> <ul> <li>Deep Cloning Needed: The spread operator only performs a shallow copy. For deep cloning, consider other methods.</li> <li>Performance Concerns: For very large objects or arrays, spreading might impact performance, so be mindful of its use in performance-critical code.</li> </ul>","tags":["react"]},{"location":"blog/2024/06/03/mastering-object-destructuring-rest-and-spread-operators-in-javascript/#conclusion","title":"Conclusion","text":"<p>Mastering these three features will make you a more efficient and expressive JavaScript developer. Use object destructuring for cleaner code and variable extraction, the rest operator to handle remaining data, and the spread operator to combine and clone objects and arrays effortlessly. With practice, these tools will become second nature, helping you write cleaner, more maintainable code.</p>","tags":["react"]},{"location":"blog/2024/08/16/difference-between-mutable-and-immutable-data-in-react/","title":"Difference between mutable and immutable data in react","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/08/16/difference-between-mutable-and-immutable-data-in-react/#difference-between-mutable-and-immutable-data-in-react","title":"Difference between mutable and immutable data in react","text":"<p>In React, understanding the difference between mutable and immutable data is key to managing state and optimizing performance.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/16/difference-between-mutable-and-immutable-data-in-react/#mutable-data","title":"Mutable Data:","text":"<ul> <li>Mutable data means the data can be changed directly after it's created.</li> <li>Example: Arrays and objects in JavaScript are mutable by default. You can modify their values directly without creating a new instance.</li> <li>Why it's problematic in React: If you mutate the state directly, React won't detect the change because React relies on immutability to determine if an update is needed (through shallow comparison). This can lead to bugs where the UI doesn't re-render when you expect it to.</li> </ul> <pre><code>const arr = [1, 2, 3];\narr.push(4); // This mutates the original array\n</code></pre>","tags":["Porgramming","React"]},{"location":"blog/2024/08/16/difference-between-mutable-and-immutable-data-in-react/#immutable-data","title":"Immutable Data:","text":"<ul> <li>Immutable data cannot be modified after it's created. Instead, any change creates a new instance of the data with the modification.</li> <li>Example: You can treat arrays and objects as immutable by using methods that return a new array or object instead of modifying the original one.</li> <li>Why it's important in React: Immutability allows React to track changes efficiently. When state is updated immutably, React can easily determine if a component needs to re-render by comparing the old and new states.</li> </ul> <pre><code>const arr = [1, 2, 3];\nconst newArr = [...arr, 4]; // Creates a new array instead of mutating the original one\n</code></pre> <p>In React, working with immutable data helps ensure that updates to the state trigger a re-render of components when necessary. This is particularly important for performance optimization and managing complex UIs. Libraries like Immer and Immutable.js are often used to enforce immutability in larger projects.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/28/order-of-operations-in-ant-design-forms-ensuring-proper-form-resetting/","title":"Order of Operations in Ant Design Forms: Ensuring Proper Form Resetting","text":"","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/28/order-of-operations-in-ant-design-forms-ensuring-proper-form-resetting/#order-of-operations-in-ant-design-forms-ensuring-proper-form-resetting","title":"Order of Operations in Ant Design Forms: Ensuring Proper Form Resetting","text":"<p>When working with forms in Ant Design, managing the state and interactions effectively is crucial for a smooth user experience. One common scenario involves resetting the form fields when a modal is closed. To achieve this successfully, understanding and applying the correct order of operations is essential.</p>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/28/order-of-operations-in-ant-design-forms-ensuring-proper-form-resetting/#why-order-of-operations-matters","title":"Why Order of Operations Matters","text":"<p>The order in which you execute operations can impact the behavior of your form. Specifically, if you're resetting the form fields when a modal closes, the sequence of operations matters because:</p> <ol> <li> <p>Reset Fields Before Closing Modal:</p> <p>To ensure that the form fields are cleared properly, you should call the <code>resetFields()</code> method before changing the modal visibility state. If you change the state first, the modal might close before the form has a chance to reset, leading to unexpected results.</p> </li> <li> <p>Avoid State Mismatch:</p> <p>Changing the modal state (e.g., setting <code>visible</code> to <code>false</code>) before resetting the form could lead to inconsistencies or race conditions where the form reset does not happen as expected.</p> </li> </ol>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/28/order-of-operations-in-ant-design-forms-ensuring-proper-form-resetting/#best-practices","title":"Best Practices","text":"<p>Here\u2019s a simple example illustrating the correct order of operations:</p> <pre><code>import React, { useState } from 'react';\nimport { Modal, Form, Input, Button } from 'antd';\n\nconst ExampleModal = () =&gt; {\n    const [form] = Form.useForm();\n    const [isModalVisible, setIsModalVisible] = useState(false);\n\n    const handleCloseModal = () =&gt; {\n        // Ensure fields are reset before hiding the modal\n        form.resetFields();\n        setIsModalVisible(false);\n    };\n\n    const handleOpenModal = () =&gt; {\n        setIsModalVisible(true);\n    };\n\n    const onFinish = (values) =&gt; {\n        console.log('Form values:', values);\n    };\n\n    return (\n        &lt;&gt;\n            &lt;Button type=\"primary\" onClick={handleOpenModal}&gt;\n                Open Modal\n            &lt;/Button&gt;\n            &lt;Modal\n                title=\"Example Modal\"\n                visible={isModalVisible}\n                onCancel={handleCloseModal}\n                footer={null}\n            &gt;\n                &lt;Form\n                    form={form}\n                    onFinish={onFinish}\n                &gt;\n                    &lt;Form.Item\n                        name=\"exampleField\"\n                        label=\"Example Field\"\n                        rules={[{ required: true, message: 'Please input a value!' }]}\n                    &gt;\n                        &lt;Input /&gt;\n                    &lt;/Form.Item&gt;\n                    &lt;Form.Item&gt;\n                        &lt;Button type=\"primary\" htmlType=\"submit\"&gt;\n                            Submit\n                        &lt;/Button&gt;\n                    &lt;/Form.Item&gt;\n                &lt;/Form&gt;\n            &lt;/Modal&gt;\n        &lt;/&gt;\n    );\n};\n\nexport default ExampleModal;\n</code></pre> Key Takeaways <ol> <li> <p>Reset Form Fields First: Always reset the form fields before updating the state that controls the modal\u2019s visibility. This ensures that the form is cleared properly before the modal closes.</p> </li> <li> <p>Consistent State Management: Keep the state management for form visibility and form data handling consistent to avoid unexpected behaviors.</p> </li> </ol> <p>By adhering to this order of operations, you can ensure a seamless user experience, with forms resetting as expected when modals are closed. This approach minimizes bugs and provides a predictable behavior for users interacting with your forms.</p>","tags":["databse","django","postgresql"]},{"location":"blog/2024/08/08/principle-of-least-privilege-polp/","title":"Principle of Least Privilege (PoLP)","text":"","tags":["Programming","React"]},{"location":"blog/2024/08/08/principle-of-least-privilege-polp/#principle-of-least-privilege-polp","title":"Principle of Least Privilege (PoLP)","text":"<p>The Principle of Least Privilege (PoLP) is a security concept that dictates that any user, program, or system should have the minimum level of access\u2014or privileges\u2014necessary to perform its tasks. This principle helps minimize the potential damage in the event of a security breach or misuse.</p>","tags":["Programming","React"]},{"location":"blog/2024/08/08/principle-of-least-privilege-polp/#in-the-context-of-tokens","title":"In the Context of Tokens:","text":"<ol> <li> <p>Limited Scope:</p> <ul> <li>Access Control: When issuing tokens (like access tokens), restrict their permissions to only what is necessary for the specific action or resource. For example, if a user only needs to read data from an API, the token should not grant permission to modify or delete that data.</li> <li>Granular Permissions: Use scopes to define what actions can be performed with the token. For instance, in an OAuth system, you might have different scopes for read and write access.</li> </ul> </li> <li> <p>Temporary Access:</p> <ul> <li>Short-Lived Tokens: Use short-lived access tokens that expire quickly. This limits the window of opportunity for an attacker if a token is compromised.</li> <li>Refresh Tokens: Use longer-lived refresh tokens to obtain new access tokens as needed, rather than extending the lifetime of access tokens.</li> </ul> </li> <li> <p>Role-Based Access Control (RBAC):</p> <ul> <li>Role Definition: Define roles within your application and grant permissions based on those roles. For example, a regular user might have different permissions than an admin user.</li> <li>Fine-Tuning Access: Adjust the permissions associated with roles to ensure they align with the principle of least privilege.</li> </ul> </li> </ol>","tags":["Programming","React"]},{"location":"blog/2024/08/08/principle-of-least-privilege-polp/#benefits-of-applying-polp","title":"Benefits of Applying PoLP:","text":"<ul> <li>Reduced Attack Surface: By limiting access, you reduce the number of potential vulnerabilities an attacker can exploit.</li> <li>Containment: If an account or token is compromised, the damage is contained to only the specific permissions granted, rather than allowing full access.</li> <li>Easier Auditing: With well-defined roles and permissions, it becomes easier to audit access and monitor for suspicious activity.</li> </ul>","tags":["Programming","React"]},{"location":"blog/2024/08/08/principle-of-least-privilege-polp/#example-scenario","title":"Example Scenario:","text":"<p>Suppose you have an application with two types of users: regular users and administrators.</p> <ul> <li>Regular User Token: This token might only have permissions to read their own data and perform specific actions like updating their profile.</li> <li>Administrator Token: This token would have broader permissions, such as creating, reading, updating, and deleting any user data.</li> </ul> <p>By ensuring that tokens are scoped appropriately based on the user's role, you minimize the risk associated with token misuse or theft, effectively implementing the Principle of Least Privilege.</p>","tags":["Programming","React"]},{"location":"blog/2024/08/08/principle-of-least-privilege-polp/#example","title":"Example","text":"<p>Sure! Here\u2019s an example of how to scope user tokens in a typical web application using OAuth 2.0 as a reference. This will illustrate how to manage permissions based on user roles.</p> <p>Example: Scoping User Tokens</p> <p>In this example, we'll consider a simple scenario where we have two roles: User and Admin. Each role will have different permissions, and we'll implement a system to issue scoped tokens accordingly.</p>","tags":["Programming","React"]},{"location":"blog/2024/08/08/principle-of-least-privilege-polp/#step-1-define-scopes","title":"Step 1: Define Scopes","text":"<p>First, let's define the scopes for our application:</p> <ul> <li> <p>User Scopes</p> </li> <li> <p><code>read:profile</code>: Permission to read user profile data.</p> </li> <li> <p><code>update:profile</code>: Permission to update user profile data.</p> </li> <li> <p>Admin Scopes:</p> </li> <li> <p><code>read:all_users</code>: Permission to read all users' data.</p> </li> <li><code>write:all_users</code>: Permission to create, update, or delete any user data.</li> </ul>","tags":["Programming","React"]},{"location":"blog/2024/08/08/principle-of-least-privilege-polp/#step-2-implement-token-generation","title":"Step 2: Implement Token Generation","text":"<p>Here's a simplified example of how you might generate tokens with scopes using a hypothetical API in Node.js with Express:</p> ExpressExplanation <pre><code>// server.js\nconst express = require('express');\nconst jwt = require('jsonwebtoken');\n\nconst app = express();\nconst PORT = 3000;\n\n// Example users with roles\nconst users = {\n    user1: { role: 'user', scopes: ['read:profile', 'update:profile'] },\n    admin1: { role: 'admin', scopes: ['read:all_users', 'write:all_users'] },\n};\n\n// Generate JWT Token\nconst generateToken = (username) =&gt; {\n    const user = users[username];\n    if (!user) throw new Error('User not found');\n\n    const token = jwt.sign(\n        {\n            username,\n            role: user.role,\n            scopes: user.scopes,\n        },\n        'your_secret_key', // Use a strong secret key in production\n        { expiresIn: '1h' } // Token expires in 1 hour\n    );\n\n    return token;\n};\n\n// Login Endpoint\napp.post('/login', (req, res) =&gt; {\n    const { username } = req.body; // Assume we get username from request body\n\n    try {\n        const token = generateToken(username);\n        res.json({ token });\n    } catch (error) {\n        res.status(401).send(error.message);\n    }\n});\n\n// Middleware to Protect Routes\nconst authenticate = (requiredScope) =&gt; {\n    return (req, res, next) =&gt; {\n        const token = req.headers['authorization']?.split(' ')[1]; // Bearer token\n        if (!token) return res.status(401).send('Unauthorized');\n\n        jwt.verify(token, 'your_secret_key', (err, decoded) =&gt; {\n            if (err) return res.status(403).send('Token is invalid');\n\n            // Check for required scope\n            if (!decoded.scopes.includes(requiredScope)) {\n                return res.status(403).send('Insufficient permissions');\n            }\n\n            req.user = decoded; // Attach user info to request\n            next();\n        });\n    };\n};\n\n// Protected Routes\napp.get('/profile', authenticate('read:profile'), (req, res) =&gt; {\n    res.json({ message: 'User profile data', user: req.user.username });\n});\n\napp.get('/admin/users', authenticate('read:all_users'), (req, res) =&gt; {\n    res.json({ message: 'All users data' });\n});\n\napp.listen(PORT, () =&gt; {\n    console.log(`Server running on http://localhost:${PORT}`);\n});\n</code></pre> <ol> <li> <p>User Definition: We define users with their roles and associated scopes.</p> </li> <li> <p>Token Generation:</p> <ul> <li>When a user logs in, a token is generated using JWT (JSON Web Tokens).</li> <li>The token contains the username, role, and scopes, and it expires after 1 hour.</li> </ul> </li> <li> <p>Authentication Middleware:</p> <ul> <li>The <code>authenticate</code> middleware checks if the token is present and valid.</li> <li>It also verifies that the user has the required scope to access the protected route.</li> </ul> </li> <li> <p>Protected Routes:</p> <ul> <li>The <code>/profile</code> route requires the <code>read:profile</code> scope.</li> <li>The <code>/admin/users</code> route requires the <code>read:all_users</code> scope</li> </ul> </li> </ol>","tags":["Programming","React"]},{"location":"blog/2024/08/08/principle-of-least-privilege-polp/#step-3-client-side-usage","title":"Step 3: Client Side Usage","text":"<p>Here\u2019s a basic example of how a client might use the token:</p> <pre><code>// Client.js\nconst loginUser = async (username) =&gt; {\n  const response = await fetch(\"http://localhost:3000/login\", {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify({ username }),\n  });\n\n  const data = await response.json();\n  localStorage.setItem(\"token\", data.token); // Store the token\n};\n\nconst getProfile = async () =&gt; {\n  const token = localStorage.getItem(\"token\");\n\n  const response = await fetch(\"http://localhost:3000/profile\", {\n    method: \"GET\",\n    headers: {\n      Authorization: `Bearer ${token}`, // Include the token\n    },\n  });\n\n  const data = await response.json();\n  console.log(data);\n};\n\n// Example Usage\nloginUser(\"user1\").then(() =&gt; getProfile());\n</code></pre>","tags":["Programming","React"]},{"location":"blog/2024/08/08/principle-of-least-privilege-polp/#conclusion","title":"Conclusion","text":"<p>This example demonstrates how to scope user tokens based on roles and permissions using JWT. By implementing the Principle of Least Privilege, you can enhance security by ensuring that users only have access to the resources necessary for their role, minimizing potential damage from a compromised token.</p>","tags":["Programming","React"]},{"location":"blog/2024/08/17/predefined-functions-in-redux-toolkit/","title":"Predefined Functions in Redux Toolkit","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/08/17/predefined-functions-in-redux-toolkit/#predefined-functions-in-redux-toolkit","title":"Predefined Functions in Redux Toolkit","text":"<p>In Redux Toolkit, several functions are commonly used to simplify state management.</p> <p>Here are the most used components:</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/17/predefined-functions-in-redux-toolkit/#1-configurestore","title":"1. configureStore","text":"<ul> <li>Purpose: Sets up the Redux store with sensible defaults, including middleware and DevTools.</li> <li>Usage: Simplifies store creation compared to the traditional <code>createStore</code>.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/17/predefined-functions-in-redux-toolkit/#2-createslice","title":"2. createSlice","text":"<ul> <li>Purpose: Generates actions and reducers based on a slice of the state.</li> <li>Usage: Reduces boilerplate by combining action creators and reducers into a single function.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/17/predefined-functions-in-redux-toolkit/#3-createasyncthunk","title":"3. createAsyncThunk","text":"<ul> <li>Purpose: Simplifies handling asynchronous logic in Redux.</li> <li>Usage: Automatically dispatches actions for the lifecycle of a promise (pending, fulfilled, rejected).</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/17/predefined-functions-in-redux-toolkit/#4-createentityadapter","title":"4. createEntityAdapter","text":"<ul> <li>Purpose: Helps manage normalized state for collections of items, such as a list of users or products.</li> <li>Usage: Provides methods for adding, updating, and removing items from the state.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/17/predefined-functions-in-redux-toolkit/#5-createselector","title":"5. createSelector","text":"<ul> <li>Purpose: Allows you to create memoized selectors to efficiently derive state.</li> <li>Usage: Helps in optimizing performance by preventing unnecessary re-renders.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/17/predefined-functions-in-redux-toolkit/#6-createreducer","title":"6. createReducer","text":"<ul> <li>Purpose: Provides a simpler way to create reducers with a more concise syntax, allowing for \"mutative\" logic.</li> <li>Usage: Similar to <code>createSlice</code>, but without generating actions.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/17/predefined-functions-in-redux-toolkit/#7-createaction","title":"7. createAction","text":"<ul> <li>Purpose: Creates an action creator function that returns an action object.</li> <li>Usage: Useful for defining actions outside of a slice.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/17/predefined-functions-in-redux-toolkit/#8-createreducer","title":"8. createReducer","text":"<ul> <li>Purpose: Provides a function to create reducers with the ability to write \"mutative\" logic.</li> <li>Usage: Can be used for simple cases where you want to avoid the complexity of slices.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/05/14/prettier-formatter-for-visual-studio-code/","title":"Prettier Formatter for Visual Studio Code","text":"","tags":["vscode","formatting"]},{"location":"blog/2024/05/14/prettier-formatter-for-visual-studio-code/#prettier-formatter-for-visual-studio-code","title":"Prettier Formatter for Visual Studio Code","text":"<p>Prettier is an opinionated code formatter. It enforces a consistent style by parsing your code and re-printing it with its own rules that take the maximum line length into account, wrapping code when necessary.</p> <p></p> <p></p>","tags":["vscode","formatting"]},{"location":"blog/2024/01/18/react-router-v6-guide/","title":"React Router v6 Guide","text":"","tags":["Programming"]},{"location":"blog/2024/01/18/react-router-v6-guide/#react-router-v6-guide","title":"React Router v6 Guide","text":"<p>React Router is a popular library for handling navigation and routing in React applications. It enables the creation of single-page applications (SPAs) by allowing developers to define the navigation structure of their applications, rendering different components based on the URL, and managing browser history.</p> <ol> <li> <p>Installation:</p> <p>Make sure you have React and React DOM installed, and then install React Router:</p> bash<pre><code>npm install react-router-dom\n</code></pre> </li> <li> <p>Basic Usage:</p> <p>Import necessary components:</p> jsx<pre><code>import { BrowserRouter as Router, Routes, Route, Link } from 'react-router-dom';\n</code></pre> <p>Wrap your application with the <code>Router</code> component:</p> jsx<pre><code>function App() {\n    return (\n        &lt;Router&gt;\n        &lt;Routes&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n        &lt;/Routes&gt;\n        &lt;/Router&gt;\n    );\n}\n</code></pre> </li> <li> <p>Nested Routes:</p> <p>You can nest Route components to create nested routes:</p> jsx<pre><code>function App() {\n    return (\n        &lt;Router&gt;\n        &lt;Routes&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/dashboard\" element={&lt;Dashboard /&gt;}&gt;\n            &lt;Route path=\"profile\" element={&lt;Profile /&gt;} /&gt;\n            &lt;Route path=\"settings\" element={&lt;Settings /&gt;} /&gt;\n            &lt;/Route&gt;\n        &lt;/Routes&gt;\n        &lt;/Router&gt;\n    );\n}\n</code></pre> </li> <li> <p>Route Parameters:</p> <p>You can capture parameters from the URL using <code>`:param</code> syntax:</p> jsx<pre><code>&lt;Route path=\"/user/:id\" element={&lt;UserProfile /&gt;} /&gt;\n</code></pre> <p>Access the parameter in the component:</p> jsx<pre><code>import { useParams } from 'react-router-dom';\n\nfunction UserProfile() {\nconst { id } = useParams();\n\n// Use the id parameter\n// ...\n}\n</code></pre> </li> <li> <p>Navigating Between Routes:</p> <p>Use the <code>Link</code> component for navigation:</p> jsx<pre><code>&lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n</code></pre> </li> <li> <p>Navigation Lifecycle Events:</p> <p>React Router v6 introduces the <code>useNavigate</code> hook for programmatic navigation:</p> jsx<pre><code>import { useNavigate } from 'react-router-dom';\n\nfunction MyComponent() {\nconst navigate = useNavigate();\n\nconst handleClick = () =&gt; {\n    // Navigate to a specific route\n    navigate('/new-route');\n};\n\n// ...\n}\n</code></pre> </li> <li> <p>Route Guards:</p> <p>Use the <code>useEffect</code> hook to guard against unauthorized access:</p> jsx<pre><code>import { useEffect } from 'react';\nimport { useNavigate } from 'react-router-dom';\n\nfunction PrivateRoute() {\nconst navigate = useNavigate();\n\nuseEffect(() =&gt; {\n    // Check if the user is authenticated\n    const isAuthenticated = // Your authentication logic here\n\n    if (!isAuthenticated) {\n    // Redirect to the login page\n    navigate('/login');\n    }\n}, [navigate]);\n\n// Render your private route content\nreturn &lt;div&gt;Private Route Content&lt;/div&gt;;\n}\n</code></pre> </li> <li> <p>Query Parameters:</p> <p>Access and manipulate query parameters using the <code>useSearchParams</code> hook:</p> jsx<pre><code>import { useSearchParams } from 'react-router-dom';\n\nfunction MyComponent() {\nconst [searchParams, setSearchParams] = useSearchParams();\n\n// Access and manipulate search parameters\nconst paramValue = searchParams.get('paramName');\nsetSearchParams({ paramName: 'newValue' });\n\n// ...\n}\n</code></pre> </li> <li> <p>Custom Route Matching:</p> <p>You can define custom route matching logic using the <code>path</code> prop and the <code>element</code> prop of the <code>Route</code> component:</p> jsx<pre><code>&lt;Route\n    path=\"/custom-route\"\n    element={&lt;CustomComponent /&gt;}\n    caseSensitive={true}\n/&gt;\n</code></pre> </li> <li> <p>Error Boundary for Routes:</p> <p>Wrap your route components with an error boundary:</p> jsx<pre><code>function ErrorBoundary() {\n    // Your error handling logic\n\n    return (\n        &lt;div&gt;\n        &lt;h1&gt;Something went wrong!&lt;/h1&gt;\n        &lt;/div&gt;\n    );\n}\n\n&lt;Route\n    path=\"/error-boundary\"\n    element={&lt;ErrorBoundary&gt;&lt;ErrorProneComponent /&gt;&lt;/ErrorBoundary&gt;}\n/&gt;\n</code></pre> </li> </ol> <p>This advanced guide covers some key concepts of React Router v6. Remember to refer to the official documentation for the most accurate and up-to-date information.</p>","tags":["Programming"]},{"location":"blog/2024/01/18/react-router-v6-guide/#reference","title":"Reference","text":"","tags":["Programming"]},{"location":"blog/2024/05/30/efficiently-removing-a-property-from-an-object-while-retaining-its-value/","title":"Efficiently Removing a Property from an Object While Retaining Its Value","text":"","tags":["Personal"]},{"location":"blog/2024/05/30/efficiently-removing-a-property-from-an-object-while-retaining-its-value/#efficiently-removing-a-property-from-an-object-while-retaining-its-value","title":"Efficiently Removing a Property from an Object While Retaining Its Value","text":"<p>When working with JavaScript objects, there are cases where you might want to remove a property from an object but still retain its value for later use. This is common when preparing payloads for API requests. In this blog, we'll explore how to efficiently delete a property and still make use of its value, along with some advanced alternatives.</p> <p>Scenario:</p> <p>You have an object <code>updatePayload</code>, which contains an <code>id</code> property. You need to delete the <code>id</code> from <code>updatePayload</code> but still retain the value of <code>id</code> for further use. Here\u2019s the basic solution:</p>","tags":["Personal"]},{"location":"blog/2024/05/30/efficiently-removing-a-property-from-an-object-while-retaining-its-value/#basic-approach","title":"Basic Approach","text":"CodeExplanation <pre><code>let updatePayload = {\n...newValues,\nid: updateTaskRecord?.id\n};\n\n// Store the ID in a separate variable\nconst idToSend = updatePayload.id;\n\n// Delete `id` from updatePayload\ndelete updatePayload.id;\n\n// Dispatch the action with `idToSend`\ndispatch(updateToDoEvent(updatePayload, idToSend));\n</code></pre> <ul> <li>The <code>id</code> is saved in <code>idToSend</code> before deleting it from <code>updatePayload</code>.</li> <li>After deleting the <code>id</code> from the object, you still have the value available for use in your dispatch or function calls.</li> </ul>","tags":["Personal"]},{"location":"blog/2024/05/30/efficiently-removing-a-property-from-an-object-while-retaining-its-value/#advanced-alternatives","title":"Advanced Alternatives","text":"<ol> <li> <p>Destructuring Assignment</p> <p>You can leverage destructuring to pull out the <code>id</code> while spreading the rest of the object\u2019s properties into a new one:</p> <pre><code>const { id: idToSend, ...restOfPayload } = {\n    ...newValues,\n    id: updateTaskRecord?.id\n};\n\n// Dispatch the action\ndispatch(updateToDoEvent(restOfPayload, idToSend));\n</code></pre> In this approach <ul> <li>We use object destructuring to extract the <code>id</code> into <code>idToSend</code>, and at the same time, we create a new object <code>restOfPayload</code> with the remaining properties.</li> <li>This method is cleaner and doesn't require manually deleting properties.</li> </ul> </li> <li> <p>Using <code>lodash.omit</code> (Utility Library)</p> <p>Another advanced method is to use the lodash library, which provides a utility function omit for removing properties from objects.</p> <pre><code>import omit from 'lodash/omit';\n\nlet updatePayload = {\n...newValues,\nid: updateTaskRecord?.id\n};\n\n// Use `omit` to create a new object without the `id` property\nconst restOfPayload = omit(updatePayload, 'id');\n\n// Dispatch the action with `idToSend`\ndispatch(updateToDoEvent(restOfPayload, updatePayload.id));\n</code></pre> <p>The <code>omit</code> function returns a new object without the specified properties, making this approach concise and readable.</p> </li> <li> <p>Using Proxies for Dynamic Property Removal</p> <p>If you want more control, you can use a Proxy to dynamically manage how the object behaves when accessed, including removing properties conditionally.</p> <pre><code>let updatePayload = new Proxy({ ...newValues, id: updateTaskRecord?.id }, {\nget: (target, prop) =&gt; prop === 'id' ? undefined : target[prop]\n});\n\n// The proxy automatically excludes `id`\ndispatch(updateToDoEvent(updatePayload, updateTaskRecord?.id));\n</code></pre> <p>This method can be overkill for simple cases but gives a lot of power in scenarios where property access needs to be customized dynamically.</p> </li> </ol>","tags":["Personal"]},{"location":"blog/2024/05/30/efficiently-removing-a-property-from-an-object-while-retaining-its-value/#conclusion","title":"Conclusion","text":"<p>While the basic method of storing the <code>id</code> in a separate variable and deleting it from the object works, advanced techniques like <code>destructuring</code>, utility libraries like <code>lodash</code>, or even JavaScript proxies offer clean and efficient ways to handle property deletion while retaining values.</p>","tags":["Personal"]},{"location":"blog/2024/05/10/understanding-the-difference-between-response-object-and-parsed-data-object/","title":"Understanding the Difference Between Response Object and Parsed Data Object","text":"","tags":["js"]},{"location":"blog/2024/05/10/understanding-the-difference-between-response-object-and-parsed-data-object/#understanding-the-difference-between-response-object-and-parsed-data-object","title":"Understanding the Difference Between Response Object and Parsed Data Object","text":"<p>When working with APIs in JavaScript, particularly with the Fetch API, it's crucial to distinguish between the Response object and the parsed data object obtained from API responses. </p> <p>Here\u2019s a concise breakdown to clarify these concepts:</p>","tags":["js"]},{"location":"blog/2024/05/10/understanding-the-difference-between-response-object-and-parsed-data-object/#response-object","title":"Response Object","text":"<ul> <li>Definition: The Response object is provided by the Fetch API to represent the entire HTTP response received from an API endpoint.</li> <li>Contents: It includes metadata such as headers, status codes, and methods to access the response body (e.g., <code>.json()</code>, <code>.text()</code>).</li> <li>Type: When checking its type with <code>typeof</code>, it returns \"object\".</li> <li>Usage: You use the Response object to check the status of the request, access headers, and initiate methods to read and parse the response body content.</li> </ul>","tags":["js"]},{"location":"blog/2024/05/10/understanding-the-difference-between-response-object-and-parsed-data-object/#parsed-data-object","title":"Parsed Data Object","text":"<ul> <li>Definition: After parsing the response body using methods like <code>.json()</code> or <code>.text()</code> on the Response object, you obtain a parsed JavaScript object or string.</li> <li>Contents: This object represents the actual data content received from the API in a usable format within JavaScript.</li> <li>Type: When checking its type with <code>typeof</code>, it typically returns \"object\" (for JSON data) or \"string\" (for text data).</li> <li>Usage: It allows you to directly manipulate and use the data obtained from the API response within your application logic, such as rendering UI components or processing further.</li> </ul> <p>Example Scenario</p> javascript<pre><code>fetch('https://api.example.com/data')\n.then(response =&gt; {\n    if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    return response.json(); // Parse JSON response body\n})\n.then(data =&gt; {\n    // Response object\n    console.log(typeof response); // Outputs: \"object\"\n\n    // Parsed data object\n    console.log(typeof data); // Outputs: \"object\" (if parsed as JSON)\n\n    // Further process 'data' as needed\n    console.log(data); // Parsed JSON data object\n})\n.catch(error =&gt; {\n    console.error('Fetch error:', error);\n});\n</code></pre>","tags":["js"]},{"location":"blog/2024/05/10/understanding-the-difference-between-response-object-and-parsed-data-object/#conclusion","title":"Conclusion","text":"<p>Understanding the distinction between the Response object and the parsed data object is fundamental for effective API integration in JavaScript. The Response object encapsulates the entire HTTP response, while the parsed data object represents the meaningful content of that response in a format suitable for application logic. This clarity enables developers to handle API responses efficiently and leverage data seamlessly in their web applications.</p>","tags":["js"]},{"location":"blog/2024/01/29/understanding-the-impact-of-the-return-statement-in-javascripts-map-function/","title":"Understanding the Impact of the Return Statement in JavaScript's Map Function","text":""},{"location":"blog/2024/01/29/understanding-the-impact-of-the-return-statement-in-javascripts-map-function/#understanding-the-impact-of-the-return-statement-in-javascripts-map-function","title":"Understanding the Impact of the Return Statement in JavaScript's Map Function","text":"<p>In JavaScript, the <code>map</code> function is a powerful tool for transforming arrays by applying a function to each element. However, the presence or absence of the <code>return</code> statement within this function can significantly affect its behavior and the resulting output.</p> <p>Consider the following code snippet:</p> javascript<pre><code>const participantIds = test?.applicationTypeDetails?.tos?.map((item) =&gt; {\n  console.log(\"Ttos: \", item?.participantId);\n  return item?.participantId;\n});\n</code></pre> <p>In this snippet, <code>participantIds</code> is generated by mapping over the tos array, and for each item, we log \"Ttos: \" along with the participantId value. But crucially, we also use the <code>return</code> statement to explicitly specify that the <code>participantId</code> value should be included in the resulting array.</p> <p>Using the <code>return</code> statement ensures that each element processed by the <code>map</code> function contributes a specific value to the resulting array. This clarity is especially important when dealing with potentially <code>undefined</code> values, as it allows for consistent handling.</p> <p>However, if we were to omit the return statement, JavaScript would implicitly add <code>undefined</code> values to the resulting array for each item processed. While this may not always be desirable, it illustrates how the absence of the <code>return</code> statement impacts the function's behavior.</p>"},{"location":"blog/2024/01/29/understanding-the-impact-of-the-return-statement-in-javascripts-map-function/#conclusion","title":"Conclusion","text":"<p>In conclusion, the choice of using or not using the <code>return</code> statement within the <code>map</code> function depends on the desired outcome. Explicitly using return offers clarity and control over the resulting array, especially when dealing with potentially undefined values, while omitting it may lead to implicit <code>undefined</code> values being included in the output. Understanding this distinction empowers JavaScript developers to wield the <code>map</code> function effectively in their code.</p>"},{"location":"blog/2024/05/25/role-based-vs-permission-based-access-control-in-react/","title":"Role-Based vs Permission-Based Access Control in React","text":"","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/25/role-based-vs-permission-based-access-control-in-react/#role-based-vs-permission-based-access-control-in-react","title":"Role-Based vs Permission-Based Access Control in React","text":"Role-Based vs Permission-Based Access Control in React: Which is Better for Displaying Elements? <p>When deciding between permission-based or role-based access control (RBAC) for showing certain elements in a React application, both approaches have their pros and cons, depending on the complexity of your system. Here's a comparison to help decide which approach suits your needs:</p>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/25/role-based-vs-permission-based-access-control-in-react/#1-role-based-access-control-rbac","title":"1.  Role-Based Access Control (RBAC)","text":"<p>In RBAC, users are assigned roles, and each role has permissions to access certain features. For example, an \"Admin\" role might have access to more elements than a \"User\" role.</p> Pros: <ul> <li>Simpler to manage: Assign roles once, and permissions are derived from the role.</li> <li>Less configuration: You only need to define roles and check them, reducing complexity.</li> <li>Scalability: Easier to scale for smaller apps where roles are clearly defined (e.g., Admin, User, Guest).</li> </ul> Cons: <ul> <li>Limited granularity: You can't easily fine-tune permissions within roles (e.g., two Admins with different permissions).</li> </ul> <pre><code>const userRole = 'Admin'; // This would come from your state or API\n\nconst AdminElement = () =&gt; &lt;div&gt;Admin Content&lt;/div&gt;;\nconst UserElement = () =&gt; &lt;div&gt;User Content&lt;/div&gt;;\n\nreturn (\n  &lt;&gt;\n    {userRole === 'Admin' &amp;&amp; &lt;AdminElement /&gt;}\n    {userRole === 'User' &amp;&amp; &lt;UserElement /&gt;}\n  &lt;/&gt;\n);\n</code></pre>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/25/role-based-vs-permission-based-access-control-in-react/#2-permission-based-access-control","title":"2. Permission-Based Access Control","text":"<p>In permission-based control, users are granted individual permissions directly (e.g., \"canViewDashboard\", \"canEditProfile\"). Permissions are more granular and allow for fine-tuning access control.</p> Pros: <ul> <li>More flexibility: Permissions can be applied to specific features regardless of roles, allowing fine-grained control.</li> <li>Complex scenarios: Suitable for larger apps with multiple permission needs across various features.</li> </ul> Cons: <ul> <li>Harder to manage: Managing individual permissions for every feature can become complex, especially as the app grows.</li> <li>Overhead: More API calls and logic to check each specific permission.</li> </ul> <pre><code>const userPermissions = ['canViewDashboard', 'canEditProfile']; // Fetched from API or state\n\nconst DashboardElement = () =&gt; &lt;div&gt;Dashboard&lt;/div&gt;;\nconst EditProfileElement = () =&gt; &lt;div&gt;Edit Profile&lt;/div&gt;;\n\nreturn (\n  &lt;&gt;\n    {userPermissions.includes('canViewDashboard') &amp;&amp; &lt;DashboardElement /&gt;}\n    {userPermissions.includes('canEditProfile') &amp;&amp; &lt;EditProfileElement /&gt;}\n  &lt;/&gt;\n);\n</code></pre>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/25/role-based-vs-permission-based-access-control-in-react/#3-hybrid-approach","title":"3. Hybrid Approach:","text":"<p>Many systems use a hybrid of both methods, where roles define broad access and permissions are used for finer control.</p> <pre><code>const userRole = 'Admin';\nconst userPermissions = ['canViewSettings'];\n\nconst SettingsElement = () =&gt; &lt;div&gt;Settings&lt;/div&gt;;\n\nreturn (\n  &lt;&gt;\n    {userRole === 'Admin' &amp;&amp; userPermissions.includes('canViewSettings') &amp;&amp; &lt;SettingsElement /&gt;}\n  &lt;/&gt;\n);\n</code></pre> <p>This allows roles to handle major access control while permissions handle finer details.</p>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/25/role-based-vs-permission-based-access-control-in-react/#choosing-the-right-approach","title":"Choosing the Right Approach:","text":"<ul> <li>Small apps: If your app has a clear set of predefined roles (e.g., Admin, Editor, Viewer), role-based access control is simpler and faster to implement.</li> <li>Large apps or complex permission needs: For larger applications where users need fine-grained control over different features (e.g., granular permissions across multiple areas), permission-based control will be more flexible.</li> </ul>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/25/role-based-vs-permission-based-access-control-in-react/#in-summary","title":"In summary:","text":"<ul> <li>Role-based control is good for simplicity and clear boundaries.</li> <li>Permission-based control is good for complex systems with more granular needs.</li> </ul>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/25/role-based-vs-permission-based-access-control-in-react/#question","title":"Question","text":"<p>Access control is a critical aspect of web application security, ensuring that users only have access to the data and features they are authorized to use. There are several different types of access control mechanisms commonly used in web applications:</p> <ol> <li> <p>Role-Based Access Control (RBAC)</p> <p>In RBAC, access to resources and features is granted based on roles assigned to users. Each role has predefined permissions, and users are assigned roles depending on their responsibilities.</p> Characteristics: <ul> <li>Roles like \"Admin,\" \"Editor,\" and \"Viewer\" are created.</li> <li>Users are assigned one or more roles.</li> <li>Permissions are attached to roles, not individual users.</li> </ul> Example: <ul> <li>Admin can access all pages.</li> <li>Editor can modify content but not user settings.</li> <li>Viewer can only view content.</li> </ul> Common Use Cases: <ul> <li>Content Management Systems (CMS)</li> <li>Enterprise Resource Planning (ERP) systems</li> </ul> </li> <li> <p>Permission-Based Access Control</p> <p>In Permission-Based control, permissions are granted to individual users or groups based on specific actions, rather than roles. Permissions allow more fine-grained control, often granting access to individual resources or features.</p> Characteristics: <ul> <li>Users have explicit permissions like \"canViewDashboard\" or \"canEditProfile.\"</li> <li>Permissions are more granular and provide better flexibility.</li> </ul> Example: <ul> <li>A user might have permission to view the dashboard but not edit their profile.</li> </ul> Common Use Cases: <ul> <li>SaaS platforms with flexible access controls.</li> <li>Applications with complex permissions across features.</li> </ul> </li> <li> <p>Discretionary Access Control (DAC)</p> <p>In DAC, the owner of the data or resource decides who can access it. The access control decision is made based on user identity and group membership. The resource owner can modify permissions, granting or restricting access to other users.</p> Characteristics: <p>The owner (user or admin) has full control over the access rights of others. Flexible but potentially less secure than mandatory access control.</p> Example: <p>A file owner can choose who can read or edit their file.</p> Common Use Cases: <p>File-sharing systems. Personal data control in collaborative platforms.</p> </li> <li> <p>Mandatory Access Control (MAC)</p> <p>In MAC, access control policies are enforced by the system and are not controlled by individual users. The system assigns security labels to users and data, and access decisions are made based on these labels.</p> Characteristics: <ul> <li>Access is granted based on clearance levels.</li> <li>The system administrator defines the rules; users have no control over who can access the data.</li> </ul> <p>???+ example \"Example:</p> <pre><code>-   Classified government systems where access is based on security clearances (e.g., Confidential, Secret, Top Secret).\n</code></pre> Common Use Cases: <ul> <li>Military or governmental systems.</li> <li>High-security environments requiring strict controls.</li> </ul> </li> <li> <p>Attribute-Based Access Control (ABAC)</p> <p>In ABAC, access decisions are made based on user attributes (e.g., department, job title, location), resource attributes, and environmental conditions (e.g., time of day). It allows for highly dynamic and context-aware access control.</p> Characteristics: <ul> <li>Rules are based on attributes rather than predefined roles or permissions.</li> <li>Policies can specify who has access under certain conditions.</li> </ul> Example: <ul> <li>Only employees in the \"HR\" department can access employee records during office hours.</li> </ul> Common Use Cases: <ul> <li>Dynamic systems like cloud services or IoT systems.</li> <li>Systems requiring granular and context-aware access control.</li> </ul> </li> <li> <p>Identity-Based Access Control (IBAC)</p> <p>In IBAC, access is determined by the individual identity of the user. Each user has specific access to certain resources based on their personal identification.</p> Characteristics: <ul> <li>Personalized access control for each user.</li> <li>Access control decisions are made based on the user's identity.</li> </ul> Example: <ul> <li>A specific user has access to their own documents but not others'.</li> </ul> Common Use Cases: <ul> <li>Personalized dashboards.</li> <li>Applications where each user manages their own data.</li> </ul> </li> <li> <p>Token-Based Access Control (e.g., OAuth, JWT)</p> <p>Token-Based Access Control is widely used in modern web applications where users are authenticated via tokens (like JWT). The token carries information about the user\u2019s permissions and is used to verify access.</p> Characteristics: <ul> <li>Stateless authentication where tokens are passed with each request.</li> <li>Can be used for Single Sign-On (SSO) and third-party API access.</li> </ul> Example: <ul> <li>OAuth tokens grant access to resources on behalf of users.</li> <li>JWT tokens are used to authenticate and authorize users in a web app.</li> </ul> Common Use Cases: <ul> <li>RESTful APIs.</li> <li>Single Sign-On (SSO) systems.</li> </ul> </li> <li> <p>Context-Based Access Control (CBAC)</p> <p>In CBAC, access control is based on the context of the request, including factors like the user's location, device, and time of access.</p> Characteristics: <ul> <li>Highly dynamic access control, taking into account external factors.</li> <li>Context can change access permissions in real time.</li> </ul> Example: <ul> <li>A user can access a system only during working hours and from an approved device.</li> </ul> Common Use Cases: <ul> <li>Enterprise systems with location and time-based access controls.</li> <li>IoT systems with real-time environmental conditions.</li> </ul> </li> <li> <p>Rule-Based Access Control</p> <p>Rule-Based Access Control defines access rules that the system follows. These rules determine who has access to which resources and under what conditions.</p> Characteristics: <ul> <li>Rules are predefined based on specific conditions.</li> <li>Offers flexibility, as rules can be customized for various situations.</li> </ul> Example: <ul> <li>A user can access a report if they have completed a mandatory training course.</li> </ul> Common Use Cases: <ul> <li>Automated systems requiring complex rules.</li> <li>Security systems with specific conditional access requirements.</li> </ul> </li> </ol> Conclusion: <ul> <li>RBAC is simple and widely used for role-based access across different user types.</li> <li>Permission-Based control offers more flexibility with finer control over resources.</li> <li>ABAC is best for dynamic, attribute-driven environments like cloud or IoT.</li> <li>Token-Based control is essential for stateless systems and API access.</li> </ul> <p>Choose the model based on the complexity and security needs of your application!</p> <pre><code>Summary\n\nRBAC: Based on roles.\nPermission-Based: Based on specific permissions.\nDAC: Resource owners define access.\nMAC: System-enforced access policies.\nABAC: Based on attributes like department or time.\nIBAC: Based on user identity.\nToken-Based: Uses tokens (e.g., JWT) for stateless authentication.\nCBAC: Access based on context like location or time.\nRule-Based: Rules define access criteria.\n</code></pre>","tags":["databse","django","postgresql"]},{"location":"blog/2024/08/23/the-role-of-reducers-in-async-logic/","title":"The Role of Reducers in Async Logic","text":"","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/23/the-role-of-reducers-in-async-logic/#the-role-of-reducers-in-async-logic","title":"The Role of Reducers in Async Logic","text":"<p>In the <code>authSlice.js</code> example provided, the <code>reducers: {}</code> object is left empty because the authentication logic primarily relies on asynchronous actions (thunks) created using <code>createAsyncThunk</code>.</p> <p>Understanding Redux Toolkit: The Role of Reducers in Async Logic</p> <p>Here\u2019s a deeper look into why that is and when you might want to include synchronous reducers:</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/23/the-role-of-reducers-in-async-logic/#why-keep-reducers-empty","title":"Why Keep <code>reducers: {}</code> Empty?","text":"<ol> <li> <p>Asynchronous Actions: The primary functionality (like logging in and registering) is handled through <code>createAsyncThunk</code>. This automatically generates action types for pending, fulfilled, and rejected states:</p> </li> <li> <p>login/pending</p> </li> <li>login/fulfilled</li> <li>login/rejected</li> </ol> <p>Since these are handled in the <code>extraReducers</code>, there\u2019s no need for synchronous reducers for login, registration, or logout.</p> <ol> <li>Simplicity: Keeping the <code>reducers</code> object empty reduces complexity in the slice definition, especially if you're mainly working with async logic.</li> </ol>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/23/the-role-of-reducers-in-async-logic/#when-to-use-synchronous-reducers","title":"When to Use Synchronous Reducers","text":"<p>You might want to include synchronous reducers in the <code>reducers</code> object when:</p> <ol> <li> <p>Managing Local State: If you need to manage local state or handle actions that don't involve asynchronous operations, such as toggling a loading state or updating user preferences.</p> </li> <li> <p>Handling Non-Async Actions: If you have actions that should directly mutate the state without waiting for an API response (like resetting the state or updating a field).</p> </li> </ol>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/23/the-role-of-reducers-in-async-logic/#example-with-synchronous-reducers","title":"Example with Synchronous Reducers","text":"<p>Here\u2019s how you might include synchronous reducers in the authSlice.js:</p> Example <pre><code>// src/features/auth/authSlice.js\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { authService } from '../../services/authService';\n\nexport const login = createAsyncThunk('auth/login', async (credentials) =&gt; {\n    const data = await authService.login(credentials);\n    return data;\n});\n\nexport const register = createAsyncThunk('auth/register', async (userInfo) =&gt; {\n    const data = await authService.register(userInfo);\n    return data;\n});\n\nexport const logout = createAsyncThunk('auth/logout', async () =&gt; {\n    await authService.logout();\n});\n\nconst authSlice = createSlice({\n    name: 'auth',\n    initialState: {\n        user: null,\n        isLoading: false,\n        error: null,\n    },\n    reducers: {\n        resetError: (state) =&gt; {\n            state.error = null; // Reset error state\n        },\n        setUser: (state, action) =&gt; {\n            state.user = action.payload; // Directly set user data\n        }\n    },\n    extraReducers: (builder) =&gt; {\n        builder\n            .addCase(login.pending, (state) =&gt; {\n                state.isLoading = true;\n                state.error = null;\n            })\n            .addCase(login.fulfilled, (state, action) =&gt; {\n                state.isLoading = false;\n                state.user = action.payload;\n            })\n            .addCase(login.rejected, (state, action) =&gt; {\n                state.isLoading = false;\n                state.error = action.error.message;\n            })\n            .addCase(logout.fulfilled, (state) =&gt; {\n                state.user = null; // Clear user on logout\n            });\n    },\n});\n\nexport const { resetError, setUser } = authSlice.actions; // Export actions\nexport default authSlice.reducer;\n</code></pre>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/23/the-role-of-reducers-in-async-logic/#summary","title":"Summary","text":"<ul> <li>Empty <code>reducers</code>: Good for slices primarily using async actions via <code>createAsyncThunk</code>.</li> <li>Include <code>reducers</code>: Useful for managing local state, resetting errors, or directly setting data.</li> </ul> <p>This approach keeps your slice clean and focused on handling asynchronous operations while allowing for flexibility when you need to manage synchronous actions.</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/05/19/saving-base64-data-into-an-excel-file-in-a-react-application/","title":"Saving base64 data into an Excel file in a React application","text":"","tags":["react","base64"]},{"location":"blog/2024/05/19/saving-base64-data-into-an-excel-file-in-a-react-application/#saving-base64-data-into-an-excel-file-in-a-react-application","title":"Saving base64 data into an Excel file in a React application","text":"<p>To save base64 data into an Excel file in a React application, you can use the FileSaver library to handle the file download and the xlsx library to convert the base64 data into a format that can be saved as an Excel file.</p> <p>Here's a step-by-step guide on how to do this:</p> <ol> <li> <p>Install the necessary libraries:</p> <pre><code>npm install file-saver xlsx\n</code></pre> </li> <li> <p>Create a function to handle the download:</p> <pre><code>import { saveAs } from 'file-saver';\nimport * as XLSX from 'xlsx';\n\nconst saveBase64AsExcel = (base64Data, fileName) =&gt; {\n    // Convert base64 string to ArrayBuffer\n    const binaryString = window.atob(base64Data);\n    const len = binaryString.length;\n    const bytes = new Uint8Array(len);\n    for (let i = 0; i &lt; len; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n    }\n    const blob = new Blob([bytes], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });\n\n    // Use FileSaver to save the file\n    saveAs(blob, fileName);\n    };\n\n    // Example usage\n    const handleDownload = () =&gt; {\n    if (isDownloadStatus) {\n        let data = 'your_base64_data_here'; // Replace with your actual base64 data\n        saveBase64AsExcel(data, 'example.xlsx');\n    }\n};\n</code></pre> </li> <li> <p>Call the <code>handleDownload</code> function when you need to trigger the download:</p> <pre><code>import React from 'react';\n\nconst YourComponent = () =&gt; {\n    return (\n        &lt;div&gt;\n        &lt;button onClick={handleDownload}&gt;Download Excel&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default YourComponent;\n</code></pre> <p>This code snippet shows how to convert base64-encoded data into an <code>ArrayBuffer</code>, create a Blob from it, and use the <code>FileSaver</code> library to download it as an Excel file. You can replace 'your_base64_data_here' with your actual base64 data variable.</p> <p>Remember to import and use handleDownload in your component as shown in the example. This should allow you to download the base64 data as an Excel file when <code>isDownloadStatus</code> is true.</p> </li> </ol>","tags":["react","base64"]},{"location":"blog/2024/04/23/formsetfieldsvalue-vs-defaultvalue-in-react/","title":"form.setFieldsValue vs defaultValue in react","text":""},{"location":"blog/2024/04/23/formsetfieldsvalue-vs-defaultvalue-in-react/#formsetfieldsvalue-vs-defaultvalue-in-react","title":"form.setFieldsValue <code>vs</code> defaultValue in react","text":"<p>Whether to set the default value using form.setFieldsValue or by using the defaultValue prop in <code>&lt;Select&gt;</code> depends on your specific use case and preference.</p> <p>Here's a breakdown of each approach:</p> <ol> <li> <p>Setting Default Value with <code>form.setFieldsValue</code>:</p> <p>Tip</p> jsx<pre><code>import { useEffect } from 'react';\nimport { Form, Select } from 'antd';\n\nconst YourComponent = ({ form, details, remainingLeaveApplicationTypesListing }) =&gt; {\n    useEffect(() =&gt; {\n        form.setFieldsValue({\n            leaveApplicationTypeId: details?.leaveApplicationTypeDto?.id\n        });\n    }, [form, details]);\n\n    return (\n        &lt;Form form={form}&gt;\n            &lt;Form.Item name=\"leaveApplicationTypeId\"&gt;\n                &lt;Select\n                    placeholder=\"Please select\"\n                    autoComplete=\"off\"\n                    // Define a function to handle selection changes\n                    onChange={(value) =&gt; handleSelect(value)}\n                &gt;\n                    {!isEmpty(remainingLeaveApplicationTypesListing) &amp;&amp;\n                    remainingLeaveApplicationTypesListing.map((leaveType, i) =&gt; (\n                        &lt;Select.Option\n                            value={leaveType.leaveApplicationTypeId}\n                            title={leaveType?.leaveApplicationTypeDto?.leaveTypeName}\n                            key={i}\n                        &gt;\n                            {leaveType?.leaveApplicationTypeDto?.leaveTypeName}\n                        &lt;/Select.Option&gt;\n                    ))}\n                &lt;/Select&gt;\n            &lt;/Form.Item&gt;\n        &lt;/Form&gt;\n    );\n};\n</code></pre> <p>With this approach, the default value is set programmatically using form.setFieldsValue inside a useEffect hook. This allows you to set the default value dynamically based on the details object. </p> <p>This approach is suitable when you need to calculate the default value or when the default value depends on asynchronous data fetching.</p> </li> <li> <p>Setting Default Value with <code>defaultValue</code> prop:</p> <p>Tip</p> jsx<pre><code>&lt;Select\n    placeholder=\"Please select\"\n    autoComplete=\"off\"\n    // Set the default value\n    defaultValue={details?.leaveApplicationTypeDto?.id}\n    // Define a function to handle selection changes\n    onChange={(value) =&gt; handleSelect(value)}\n&gt;\n    {!isEmpty(remainingLeaveApplicationTypesListing) &amp;&amp;\n        remainingLeaveApplicationTypesListing.map((leaveType, i) =&gt; (\n            &lt;Select.Option\n                value={leaveType.leaveApplicationTypeId}\n                title={leaveType?.leaveApplicationTypeDto?.leaveTypeName}\n                key={i}\n            &gt;\n                {leaveType?.leaveApplicationTypeDto?.leaveTypeName}\n            &lt;/Select.Option&gt;\n        ))}\n&lt;/Select&gt;\n</code></pre> <p>With this approach, you directly set the default value using the defaultValue prop of the <code>&lt;Select&gt;</code> component. </p> <p>This approach is simpler and more straightforward when you have a static default value or when the default value doesn't depend on other factors.</p> </li> </ol>"},{"location":"blog/2024/04/23/formsetfieldsvalue-vs-defaultvalue-in-react/#which-approach-to-choose","title":"Which Approach to Choose:","text":"<ul> <li>If the default value depends on dynamic data or needs to be calculated based on other state/props, using <code>form.setFieldsValue</code> inside a <code>useEffect</code> hook is more appropriate.</li> <li>If the default value is static or doesn't depend on other factors, using the <code>defaultValue</code> prop directly in the <code>&lt;Select&gt;</code> component is simpler and cleaner.</li> </ul>"},{"location":"blog/2024/08/24/simplifying-error-management-in-react-a-deep-dive-into-component-decomposition/","title":"Simplifying Error Management in React: A Deep Dive into Component Decomposition","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/08/24/simplifying-error-management-in-react-a-deep-dive-into-component-decomposition/#simplifying-error-management-in-react-a-deep-dive-into-component-decomposition","title":"Simplifying Error Management in React: A Deep Dive into Component Decomposition","text":"<p>No, you don't need to create separate loader and error components in every component you decompose. Instead, you can follow a more centralized approach that promotes reusability and maintainability.</p> <p>do we need to make the loder and error component in every comopenet decomposition</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/24/simplifying-error-management-in-react-a-deep-dive-into-component-decomposition/#overview","title":"Overview","text":"<p>Here are some strategies:</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/24/simplifying-error-management-in-react-a-deep-dive-into-component-decomposition/#1-centralized-loader-and-error-components","title":"1. Centralized Loader and Error Components","text":"<p>Create shared Loader and ErrorMessage components that can be used across different parts of your application. This reduces duplication and keeps your components DRY (Don't Repeat Yourself).</p> Example Structure <pre><code>src/\ncomponents/\n    Loader.js\n    ErrorMessage.js\n    ImageGallery/\n    ImageGallery.js\n    ImagePreview.js\n</code></pre>","tags":["Porgramming","React"]},{"location":"blog/2024/08/24/simplifying-error-management-in-react-a-deep-dive-into-component-decomposition/#2-usage-in-different-components","title":"2. Usage in Different Components","text":"<p>You can import and use these shared components in various places. For example:</p> Component <p><code>Loader.js</code></p> <pre><code>import React from \"react\";\nimport { Spin } from \"antd\"; // or any loader you prefer\n\nconst Loader = () =&gt; (\n    &lt;div style={{ textAlign: 'center', padding: '20px' }}&gt;\n        &lt;Spin size=\"large\" /&gt;\n    &lt;/div&gt;\n);\n\nexport default Loader;\n</code></pre> <p><code>ErrorMessage.js</code></p> <pre><code>import React from \"react\";\n\nconst ErrorMessage = ({ message }) =&gt; {\n    const isProduction = process.env.NODE_ENV === 'production';\n\n    return (\n        &lt;div style={{ color: \"red\" }}&gt;\n        {isProduction\n            ? \"Something went wrong. Please try again later.\"\n            : `Error: ${message}`}\n        &lt;/div&gt;\n    );\n};\n\nexport default ErrorMessage;\n</code></pre>","tags":["Porgramming","React"]},{"location":"blog/2024/08/24/simplifying-error-management-in-react-a-deep-dive-into-component-decomposition/#3-integrating-in-other-components","title":"3. Integrating in Other Components","text":"<p>You can then use these components in your other components, such as <code>ImageGallery</code>:</p> Example <pre><code>import React, { useEffect } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport Loader from \"../Loader\";\nimport ErrorMessage from \"../ErrorMessage\";\nimport ImagePreview from \"./ImagePreview\";\nimport { getPhotosService } from \"../../../redux/features/gallery/services\";\n\nconst ImageGallery = () =&gt; {\n    const dispatch = useDispatch();\n    const { gallery, status, error } = useSelector((state) =&gt; state.gallery);\n\n    useEffect(() =&gt; {\n        const source = axios.CancelToken.source();\n        dispatch(getPhotosService(source.token));\n        return () =&gt; {\n            source.cancel();\n        };\n    }, [dispatch]);\n\n    if (status === 'loading') {\n        return &lt;Loader /&gt;;\n    }\n\n    if (error) {\n        return &lt;ErrorMessage message={error.message} /&gt;;\n    }\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Picture Gallery&lt;/h1&gt;\n            &lt;ImagePreview gallery={gallery} /&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default ImageGallery;\n</code></pre>","tags":["Porgramming","React"]},{"location":"blog/2024/08/24/simplifying-error-management-in-react-a-deep-dive-into-component-decomposition/#4-benefits-of-this-approach","title":"4. Benefits of This Approach","text":"<ul> <li>Reusability: By creating shared components, you can reuse them throughout your application without duplication.</li> <li>Consistency: This approach helps maintain a consistent look and feel for loaders and error messages across different components.</li> <li>Maintainability: If you need to change the appearance or behavior of loaders or error messages, you can do so in one place, and it will reflect everywhere.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/24/simplifying-error-management-in-react-a-deep-dive-into-component-decomposition/#5-context-or-global-state-optional","title":"5. Context or Global State (Optional)","text":"<p>If you have complex loading and error handling across many components, consider using React Context or a global state management solution (like Redux) to manage loading and error states. This can further simplify component structure and enhance scalability.</p> Using Context <ol> <li>Create a Loading Context</li> </ol> <pre><code>import React, { createContext, useContext, useState } from 'react';\n\nconst LoadingContext = createContext();\n\nexport const useLoading = () =&gt; useContext(LoadingContext);\n\nexport const LoadingProvider = ({ children }) =&gt; {\n    const [loading, setLoading] = useState(false);\n\n    const startLoading = () =&gt; setLoading(true);\n    const stopLoading = () =&gt; setLoading(false);\n\n    return (\n        &lt;LoadingContext.Provider value={{ loading, startLoading, stopLoading }}&gt;\n            {children}\n        &lt;/LoadingContext.Provider&gt;\n    );\n};\n</code></pre>","tags":["Porgramming","React"]},{"location":"blog/2024/08/24/simplifying-error-management-in-react-a-deep-dive-into-component-decomposition/#conclusion","title":"Conclusion","text":"<p>You should aim to create reusable components for loaders and error messages rather than duplicating them in every decomposed component. This makes your code cleaner, more maintainable, and easier to manage.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/24/simplifying-error-management-in-react-a-deep-dive-into-component-decomposition/#additional","title":"Additional","text":"<p>Creating a custom loader using Ant Design's <code>Skeleton</code> component is straightforward and allows for flexibility in design. Below, I\u2019ll guide you through the steps to create a custom Ant Design <code>Skeleton</code> loader with various options for customization.</p> <p>Step 1: Set Up the Custom Skeleton Loader</p> <p>You can create a custom loader component that uses Ant Design's Skeleton while allowing for customization.</p> CustomSkeletonLoader.js <pre><code>import React from 'react';\nimport { Skeleton } from 'antd';\n\nconst CustomSkeletonLoader = ({\n    active = true,\n    title = true,\n    paragraph = { rows: 2, width: '100%' },\n    avatar = false,\n    style = {},\n}) =&gt; {\n    return (\n        &lt;div style={{ padding: '20px', ...style }}&gt;\n            &lt;Skeleton\n                active={active}\n                title={title}\n                paragraph={paragraph}\n                avatar={avatar}\n            /&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default CustomSkeletonLoader;\n</code></pre> <p>Step 2: Customize the Skeleton Loader</p> <p>You can customize the Skeleton loader based on the props you pass to it. Here are some ideas for customization:</p> <ol> <li>Avatar: You can include an avatar placeholder.</li> <li>Title: Control whether to display the title placeholder.</li> <li>Paragraph: Specify the number of rows and their width.</li> </ol> <p>Step 3: Example Usage</p> <p>You can use this custom loader in various parts of your application. Here\u2019s an example of how to implement it:</p> ExampleComponent.js <pre><code>import React from 'react';\nimport CustomSkeletonLoader from './CustomSkeletonLoader';\n\nconst ExampleComponent = ({ loading, data }) =&gt; {\n    if (loading) {\n        return &lt;CustomSkeletonLoader avatar title paragraph={{ rows: 3 }} /&gt;;\n    }\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;{data.title}&lt;/h1&gt;\n            &lt;p&gt;{data.content}&lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default ExampleComponent;\n</code></pre> <p>Step 4: CSS Customization (Optional)</p> <p>You can further customize the styles of the <code>Skeleton</code> by applying additional CSS. If you want to change the background color or other styles, you can do this in your CSS file.</p> Example CSS (styles.css) <pre><code>.ant-skeleton {\n    background-color: #f0f2f5; /* Change background color */\n}\n\n.ant-skeleton-title {\n    height: 20px; /* Customize title height */\n}\n\n.ant-skeleton-paragraph {\n    height: 16px; /* Customize paragraph height */\n    margin: 5px 0; /* Add spacing */\n}\n</code></pre> <p>Step 5: Import CSS in Your Component</p> <p>Make sure to import your custom CSS in your component or at the entry point of your application.</p> <pre><code>import \"./styles.css\"; // Adjust the path as necessary\n</code></pre> <p>Conclusion</p> <p>With this setup, you have a customizable Ant Design Skeleton loader that can be easily reused throughout your application. You can adjust the properties for different loading scenarios and enhance the user experience by providing visual feedback during data fetching.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/24/simplifying-error-management-in-react-a-deep-dive-into-component-decomposition/#question","title":"Question","text":"Example of Using Custom PropsTheoryConclusion <p>Here\u2019s how you can use the <code>CustomSkeletonLoader</code> component and override its default props:</p> <pre><code>import React from 'react';\nimport CustomSkeletonLoader from './CustomSkeletonLoader';\n\nconst ExampleComponent = ({ loading, data }) =&gt; {\n    if (loading) {\n        return (\n            &lt;CustomSkeletonLoader\n                active={true}\n                title={true}\n                paragraph={{ rows: 3 }} // Override to show 3 rows\n                avatar={true} // Show avatar\n                style={{ margin: '20px' }} // Custom style\n            /&gt;\n        );\n    }\n\n    return (\n        &lt;div&gt;\n        &lt;h1&gt;{data.title}&lt;/h1&gt;\n        &lt;p&gt;{data.content}&lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default ExampleComponent;\n</code></pre> <p>Yes, in the <code>CustomSkeletonLoader</code> component, the props like <code>active</code>, <code>title</code>, <code>paragraph</code>, <code>avatar</code>, and <code>style</code> are predefined with default values. This approach allows the component to be flexible while providing sensible defaults. Here\u2019s a breakdown of each prop and why you might want to set defaults:</p> <p>Breakdown of Default Props</p> <ol> <li> <p>active:</p> <ul> <li>Default: <code>true</code></li> <li>Purpose: Indicates whether the skeleton is currently active. This helps control whether the loading animation is displayed. By default, it\u2019s set to true so the skeleton shows as a loading state.</li> </ul> </li> <li> <p>title:</p> <ul> <li>Default: <code>true</code></li> <li>Purpose: Determines if the skeleton should display a title placeholder. Setting this to true by default means that if the user doesn\u2019t specify otherwise, a title will be shown.</li> </ul> </li> <li> <p>paragraph:</p> <ul> <li>Default: <code>{ rows: 2, width: '100%' }</code></li> <li>Purpose: Configures the paragraph placeholder. The <code>rows</code> property sets how many lines of text to display, and the <code>width</code> can be adjusted if you want different widths for the skeleton. This default makes the loader suitable for most text elements.</li> </ul> </li> <li> <p>avatar:</p> <ul> <li>Default: <code>false</code></li> <li>Purpose: Controls whether an avatar placeholder is shown. It defaults to false, which means that the loader won\u2019t display an avatar unless specified by the user.</li> </ul> </li> <li> <p>style:</p> <ul> <li>Default: <code>{}</code></li> <li>Purpose: Allows additional styles to be applied to the loader component. By default, it\u2019s an empty object, so users can pass custom styles without affecting the existing ones.</li> </ul> </li> </ol> <p>Predefining props with default values in your <code>CustomSkeletonLoader</code> makes it user-friendly and easy to implement. Users can easily customize the loader as needed while benefiting from sensible defaults that suit common use cases. This approach strikes a good balance between flexibility and usability.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/22/unveiling-static-and-prototype-methods-in-javascript-built-in-objects/","title":"Unveiling Static and Prototype Methods in JavaScript Built-in Objects","text":"","tags":["js"]},{"location":"blog/2024/05/22/unveiling-static-and-prototype-methods-in-javascript-built-in-objects/#unveiling-static-and-prototype-methods-in-javascript-built-in-objects","title":"Unveiling Static and Prototype Methods in JavaScript Built-in Objects","text":"<p>To thoroughly understand and see the static methods and constructor methods in JavaScript built-in objects, you can use a combination of developer tools, documentation, and JavaScript code. Here\u2019s a detailed guide:</p>","tags":["js"]},{"location":"blog/2024/05/22/unveiling-static-and-prototype-methods-in-javascript-built-in-objects/#1-using-developer-tools","title":"1. Using Developer Tools","text":"<p>In a Browser Console</p> <ol> <li>Open Developer Tools: You can usually open this by pressing <code>F12</code>, <code>Ctrl+Shift+I</code>, or <code>Cmd+Option+I</code>.</li> <li>Go to the Console Tab: Here you can execute JavaScript code.</li> </ol>","tags":["js"]},{"location":"blog/2024/05/22/unveiling-static-and-prototype-methods-in-javascript-built-in-objects/#viewing-static-methods","title":"Viewing Static Methods","text":"<p>Static methods are functions that are called on the class itself, not on instances of the class. For example, <code>Array.from()</code> is a static method on the <code>Array</code> constructor.</p> <pre><code>console.dir(Array);\nconsole.dir(Object);\nconsole.dir(Math);\n</code></pre>","tags":["js"]},{"location":"blog/2024/05/22/unveiling-static-and-prototype-methods-in-javascript-built-in-objects/#viewing-constructor-methods","title":"Viewing Constructor Methods","text":"<p>Constructor methods (or prototype methods) are functions that are available on the instances of the objects. For example, <code>Array.prototype.push()</code> is a constructor method.</p> <pre><code>console.dir(Array.prototype);\nconsole.dir(Object.prototype);\n</code></pre>","tags":["js"]},{"location":"blog/2024/05/22/unveiling-static-and-prototype-methods-in-javascript-built-in-objects/#2-using-javascript-code","title":"2. Using JavaScript Code","text":"","tags":["js"]},{"location":"blog/2024/05/22/unveiling-static-and-prototype-methods-in-javascript-built-in-objects/#list-all-static-methods-and-properties","title":"List All Static Methods and Properties","text":"<p>To list all static methods and properties of a built-in object, you can use the following code snippet:</p> <pre><code>function listStaticMethods(obj) {\n  return Object.getOwnPropertyNames(obj).filter(prop =&gt; typeof obj[prop] === 'function');\n}\n\nconsole.log(listStaticMethods(Array)); // List static methods of Array\nconsole.log(listStaticMethods(Object)); // List static methods of Object\nconsole.log(listStaticMethods(Math));   // List static methods of Math\n</code></pre>","tags":["js"]},{"location":"blog/2024/05/22/unveiling-static-and-prototype-methods-in-javascript-built-in-objects/#list-all-prototype-methods","title":"List All Prototype Methods","text":"<p>To list all prototype methods of a built-in object, you can use the following code snippet:</p> <pre><code>function listPrototypeMethods(obj) {\n  return Object.getOwnPropertyNames(obj.prototype).filter(prop =&gt; typeof obj.prototype[prop] === 'function');\n}\n\nconsole.log(listPrototypeMethods(Array)); // List prototype methods of Array\nconsole.log(listPrototypeMethods(Object)); // List prototype methods of Object\n</code></pre>","tags":["js"]},{"location":"blog/2024/05/22/unveiling-static-and-prototype-methods-in-javascript-built-in-objects/#3-consulting-documentation","title":"3. Consulting Documentation","text":"<p>Refer to the official JavaScript documentation for comprehensive details on built-in objects, their static methods, and prototype methods:</p> <ul> <li> <p>MDN Web Docs: This is a highly recommended resource for in-depth information on JavaScript built-in objects. For example:</p> </li> <li> <p>Array</p> </li> <li>Object</li> <li>Math</li> </ul> Example Output <p>When you run the provided code snippets, you will get lists of methods:</p> <p>Static Methods of Array:</p> <pre><code>[\"from\", \"isArray\", \"of\"]\n</code></pre> <p>Prototype Methods of Array:</p> <pre><code>[\"constructor\", \"copyWithin\", \"fill\", \"find\", \"findIndex\", \"keys\", \"entries\", \"values\", \"pop\", \"push\", \"concat\", \"join\", \"reverse\", \"shift\", \"unshift\", \"slice\", \"splice\", \"sort\", \"indexOf\", \"lastIndexOf\", \"every\", \"some\", \"forEach\", \"map\", \"filter\", \"reduce\", \"reduceRight\", \"includes\", \"flat\", \"flatMap\", \"at\", \"toLocaleString\", \"toString\", \"length\"]\n</code></pre> <p>By using these methods, you can thoroughly explore and understand the static and prototype methods available in JavaScript <code>built-in</code> objects.</p>","tags":["js"]},{"location":"blog/2024/06/04/understanding-asyncawait/","title":"Understanding async/await","text":"","tags":["react"]},{"location":"blog/2024/06/04/understanding-asyncawait/#understanding-asyncawait","title":"Understanding <code>async/await</code>","text":"<p>In modern JavaScript development, managing asynchronous operations is crucial for creating responsive and efficient applications. Two key tools for handling async operations are async and await.</p> <p>Understanding <code>async/await</code>: A Guide to Managing Asynchronous Operations</p> Here\u2019s a breakdown <ul> <li> <p>Synchronous Actions: If your <code>dispatch</code> calls are for synchronous actions (simple object literals), you don\u2019t need to use <code>async/await</code>. Synchronous actions are dispatched and handled immediately.</p> </li> <li> <p>Asynchronous Actions (Thunks): If your <code>dispatch</code> calls are for asynchronous operations (like API calls), you may use <code>async/await</code> to handle these operations more effectively. This often involves using middleware like <code>redux-thunk</code> or <code>redux-saga</code>.</p> </li> </ul>","tags":["react"]},{"location":"blog/2024/06/04/understanding-asyncawait/#overview","title":"Overview","text":"<p>Here\u2019s a breakdown of what they are, when to use them, and when they might not be the best choice.</p>","tags":["react"]},{"location":"blog/2024/06/04/understanding-asyncawait/#what-is-asyncawait","title":"What is async/await?","text":"<p><code>async/await</code> is a syntactic sugar introduced in ECMAScript 2017 (ES8) that simplifies working with asynchronous code. It allows you to write asynchronous code that looks and behaves more like synchronous code, making it easier to read and maintain.</p> <ul> <li> <p><code>async</code>: This keyword is used to declare a function as asynchronous. An <code>async</code> function always returns a promise, and inside this function, you can use the await keyword.</p> </li> <li> <p><code>await</code>: This keyword is used inside async functions to pause the execution of the code until the promise is resolved or rejected. It essentially waits for the promise to complete and returns the result, allowing you to work with asynchronous code as if it were synchronous.</p> </li> </ul>","tags":["react"]},{"location":"blog/2024/06/04/understanding-asyncawait/#when-to-use-asyncawait","title":"When to Use <code>async/await</code>","text":"<ol> <li> <p>Simplifying Code: Use <code>async/await</code> to make your asynchronous code more readable and easier to maintain. It reduces the need for chaining multiple <code>.then()</code> calls and nesting callbacks, making the flow of your code more linear and intuitive.</p> </li> <li> <p>Error Handling: <code>async/await</code> allows you to use <code>try/catch</code> blocks for error handling, which is often more straightforward than handling errors with <code>.catch()</code> in promise chains. This makes it easier to manage errors in a predictable way.</p> </li> <li> <p>Sequential Asynchronous Operations: When you need to perform multiple asynchronous operations in sequence, <code>async/await</code> helps you write code that waits for each operation to complete before moving to the next one. This is useful for tasks where each step depends on the results of the previous one.</p> </li> <li> <p>Readability and Debugging: <code>async/await</code> can make debugging easier because it avoids deeply nested code and complex promise chains. Stack traces are also typically clearer, as the code looks more like synchronous code.</p> </li> </ol>","tags":["react"]},{"location":"blog/2024/06/04/understanding-asyncawait/#when-not-to-use-asyncawait","title":"When Not to Use async/await","text":"<ol> <li> <p>Parallel Asynchronous Operations: If you need to execute multiple asynchronous operations in parallel and do not need to wait for each to complete before starting the next, using <code>async/await</code> can be less efficient. Instead, you might use <code>Promise.all()</code> to run promises concurrently and handle them collectively.</p> <pre><code>// Using Promise.all for parallel execution\nconst fetchData = async () =&gt; {\n    const [data1, data2] = await Promise.all([\n        fetch('url1').then(response =&gt; response.json()),\n        fetch('url2').then(response =&gt; response.json())\n    ]);\n    // Process data1 and data2\n};\n</code></pre> </li> <li> <p>Non-Promise-Based Asynchronous Code: <code>async/await</code> is designed for handling promises. If you're dealing with callback-based asynchronous patterns (like some older APIs), you might need to use Promise wrappers or continue using callbacks. However, for new code, consider refactoring to use promises if possible.</p> </li> <li> <p>Simple Asynchronous Functions: For very simple asynchronous operations where readability and maintainability are not a concern, and where the asynchronous code is straightforward, using <code>async/await</code> might be overkill. Simple <code>.then()</code> chains might suffice.</p> </li> <li> <p>Non-Blocking Operations: In cases where the operations are non-blocking and you don\u2019t need to wait for their results, you might not need <code>async/await</code>. For instance, if you\u2019re dispatching actions or events that do not require waiting for completion, <code>async/await</code> may not be necessary.</p> </li> </ol>","tags":["react"]},{"location":"blog/2024/06/04/understanding-asyncawait/#conclusion","title":"Conclusion","text":"<p><code>async/await</code> is a powerful tool for handling asynchronous code in a clean and readable manner. It is ideal for simplifying code, improving error handling, and managing sequential asynchronous tasks. However, for tasks requiring parallel execution, non-promise-based code, or very simple asynchronous logic, other approaches might be more appropriate.</p> <p>By understanding when to use <code>async/await</code> and when other methods might be better suited, you can write more efficient and maintainable asynchronous code in your JavaScript applications.</p>","tags":["react"]},{"location":"blog/2024/08/25/understanding-the-importance-of-rowkey-in-react-tables/","title":"Understanding the Importance of rowKey in React Tables","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/08/25/understanding-the-importance-of-rowkey-in-react-tables/#understanding-the-importance-of-rowkey-in-react-tables","title":"Understanding the Importance of rowKey in React Tables","text":"<p>When working with tables in React, especially when using libraries like Ant Design, setting a unique key for each row is crucial. The <code>rowKey</code> property allows the table component to efficiently manage and render rows, and here's why it matters.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/25/understanding-the-importance-of-rowkey-in-react-tables/#overview","title":"Overview","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/08/25/understanding-the-importance-of-rowkey-in-react-tables/#why-use-a-unique-rowkey","title":"Why Use a Unique <code>rowKey</code>?","text":"<ol> <li> <p>Performance Optimization: React relies on keys to identify which items have changed, are added, or are removed. When rows have unique keys, React can optimize re-rendering by only updating the affected rows rather than re-rendering the entire table.</p> </li> <li> <p>Consistent Row Identity: Using a unique identifier, such as an <code>id</code>, helps maintain the identity of each row across renders. This is especially important in dynamic lists where items may be reordered, added, or deleted. Consistent row identity ensures that the correct data is displayed for each row.</p> </li> <li> <p>Preventing Bugs: Without a unique key, React might mistakenly reuse DOM elements for different data. This can lead to incorrect rendering of content, unexpected behavior, or visual glitches, as React may not know which row corresponds to which data.</p> </li> <li> <p>Improved User Experience: With proper key management, interactions like sorting, filtering, or pagination will work seamlessly. Users will see a consistent experience without unexpected data flickering or mismatches.</p> </li> </ol>","tags":["Porgramming","React"]},{"location":"blog/2024/08/25/understanding-the-importance-of-rowkey-in-react-tables/#how-to-implement-rowkey-correctly","title":"How to Implement <code>rowKey</code> Correctly","text":"<p>When defining your table, you can specify <code>rowKey</code> by providing a unique identifier from your data source. For instance, if each item in your <code>todos</code> array has a unique <code>id</code>, you can set it like this:</p> <pre><code>&lt;Table\n  dataSource={todos}\n  columns={columns}\n  pagination={false}\n  scroll={{ y: 400 }}\n  rowHeight={10}\n  style={{ height: \"100%\" }}\n  rowKey=\"id\" // Ensure each row has a unique key\n/&gt;\n</code></pre> <p>This configuration ensures that each row in the table is associated with a specific <code>id</code>, allowing React to efficiently manage updates and changes.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/25/understanding-the-importance-of-rowkey-in-react-tables/#conclusion","title":"Conclusion","text":"<p>In summary, setting a unique <code>rowKey</code> for your table rows is not just a best practice; it is essential for maintaining performance, ensuring consistent rendering, and providing a better user experience. Always remember to use a unique identifier from your data, such as an <code>id</code>, to help React effectively manage your table rows. By doing so, you will create a more robust and reliable table component in your application.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/25/understanding-the-importance-of-rowkey-in-react-tables/#question","title":"Question","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/08/25/understanding-the-importance-of-rowkey-in-react-tables/#what-to-do-if-your-api-doesnt-provide-a-unique-key","title":"What to Do If Your API Doesn\u2019t Provide a Unique Key?","text":"<p>When working with data from an API, you may encounter situations where the response does not include a unique identifier for each item. This can pose challenges when rendering lists or tables in React, as each item needs a unique key for optimal performance and reliability. Here\u2019s how to handle this situation.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/25/understanding-the-importance-of-rowkey-in-react-tables/#why-is-a-unique-key-important","title":"Why Is a Unique Key Important?","text":"<p>Before we dive into solutions, it's important to understand why a unique key is critical:</p> <ul> <li>Performance Optimization: React uses keys to efficiently update and re-render components. Without unique keys, React might end up re-rendering the entire list, leading to performance issues.</li> <li>Data Consistency: Unique keys help maintain the identity of each item across renders, preventing bugs and mismatches.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/25/understanding-the-importance-of-rowkey-in-react-tables/#solutions-for-generating-unique-keys","title":"Solutions for Generating Unique Keys","text":"<p>If your API doesn\u2019t provide a unique key, consider the following approaches:</p> <ol> <li> <p>Use a Combination of Fields: If your data has multiple fields that, when combined, can form a unique identifier, use those. For example, combining <code>name</code> and <code>timestamp</code> might create a unique string for each item.</p> <pre><code>const rowKey = (item) =&gt; `${item.name}-${item.timestamp}`;\n</code></pre> </li> <li> <p>Generate a Unique Key Locally: You can generate unique keys on the client side using libraries like uuid or by creating a simple function that generates a random string.</p> <pre><code>npm install uuid\n</code></pre> <pre><code>import { v4 as uuidv4 } from \"uuid\";\n\n// Add a unique key to each todo item\nconst todosWithKeys = data.map((todo) =&gt; ({\n  ...todo,\n  id: uuidv4(), // Generate a unique ID\n}));\n</code></pre> </li> <li> <p>Index as a Last Resort: If no other unique identifiers are available, you can use the index of the item in the array as a key. However, this is generally not recommended for dynamic lists, as it can lead to issues with state preservation and performance.</p> <pre><code>&lt;Table dataSource={todos} rowKey={(item, index) =&gt; index} /&gt;\n</code></pre> </li> </ol> Note: <p>Using the index should be avoided when items can be <code>reordered</code>, <code>added</code>, or <code>removed</code>, as it can lead to inconsistent rendering.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/25/understanding-the-importance-of-rowkey-in-react-tables/#conclusion_1","title":"Conclusion","text":"<p>If your API doesn\u2019t provide a unique key, there are several strategies you can employ to create one. Whether by combining fields, generating keys locally, or using indices as a last resort, ensuring that each item in your list has a unique identifier is essential for optimal performance and a reliable user experience in your React application.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/25/understanding-the-importance-of-rowkey-in-react-tables/#implementation","title":"Implementation","text":"<p>To use uuid in your table setup, you would typically generate unique keys when you first receive the data from the API or before rendering the table. Here's how you can implement it:</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/25/understanding-the-importance-of-rowkey-in-react-tables/#step-by-step-implementation","title":"Step-by-Step Implementation","text":"<ol> <li> <p>Install the UUID Package: If you haven't already, install the <code>uuid</code> package:</p> <pre><code>npm install uuid\n</code></pre> </li> <li> <p>Generate UUIDs for Each Todo Item: When you fetch your <code>todos</code> data, map through the array to add a unique key to each item. Here's how you can do that:</p> <pre><code>import { v4 as uuidv4 } from \"uuid\";\nimport { Table } from \"antd\"; // Assuming you're using Ant Design\n\nconst App = () =&gt; {\n  const [todos, setTodos] = React.useState([]);\n\n  // Example function to fetch todos\n  const fetchTodos = async () =&gt; {\n    const response = await fetch(\"your-api-url\");\n    const data = await response.json();\n\n    // Add a unique key to each todo item\n    const todosWithKeys = data.map((todo) =&gt; ({\n      ...todo,\n      id: uuidv4(), // Generate a unique ID\n    }));\n    setTodos(todosWithKeys);\n  };\n\n  React.useEffect(() =&gt; {\n    fetchTodos();\n  }, []);\n\n  const columns = [\n    // Define your columns here\n  ];\n\n  return (\n    &lt;Table\n      dataSource={todos}\n      columns={columns}\n      pagination={false}\n      scroll={{ y: 400 }}\n      rowHeight={10}\n      style={{ height: \"100%\" }}\n      rowKey=\"id\" // Use the unique id generated\n    /&gt;\n  );\n};\n\nexport default App;\n</code></pre> </li> </ol>","tags":["Porgramming","React"]},{"location":"blog/2024/08/25/understanding-the-importance-of-rowkey-in-react-tables/#explanation","title":"Explanation","text":"<ul> <li>UUID Generation: When you map through the fetched <code>todos</code>, a unique <code>id</code> is generated using <code>uuidv4()</code> for each item.</li> <li>Setting Data: This new array with unique keys is then set to the state, ensuring each row in the table has a unique key.</li> <li>Using <code>rowKey</code>: The <code>rowKey</code> prop is set to <code>\"id\"</code>, allowing the table to use the generated unique IDs.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/25/understanding-the-importance-of-rowkey-in-react-tables/#conclusion_2","title":"Conclusion","text":"<p>By generating unique IDs for each todo item when fetching the data, you ensure that your table renders efficiently and correctly, even if the original API does not provide unique identifiers. This approach enhances performance and reduces the likelihood of bugs related to row identity.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/25/understanding-the-importance-of-rowkey-in-react-tables/#reference","title":"Reference","text":"<ul> <li>Generating Unique key in React</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/05/24/useful-react-libraries-for-projects/","title":"Useful React Libraries for Projects","text":"","tags":["postman","http"]},{"location":"blog/2024/05/24/useful-react-libraries-for-projects/#useful-react-libraries-for-projects","title":"Useful React Libraries for Projects","text":"<p>Pdf</p>","tags":["postman","http"]},{"location":"blog/2024/05/24/useful-react-libraries-for-projects/#loadash","title":"loadash","text":"<pre><code>import { uniqBy } from 'lodash';\n\nconst recentlyUsedTags = [\n  { code: \"AFL-asdasdasaggdfgdfg\", id: \"45f3d5c0-6e3e-4d24-b9e6-f960845c9c0d\" },\n  { code: \"AFL-asdasdasaggdfgdfg\", id: \"45f3d5c0-6e3e-4d24-b9e6-f960845c9c0d\" }\n];\n\nconst otherReferenceDtos = [\n  { code: \"BFL-sdfdsfsdfsdffsd\", id: \"23d4c5a0-7e2f-5d25-b7a6-f234512d4b4d\" },\n  { code: \"AFL-asdasdasaggdfgdfg\", id: \"45f3d5c0-6e3e-4d24-b9e6-f960845c9c0d\" }\n];\n\nconst combinedArray = [...recentlyUsedTags, ...otherReferenceDtos];\n\nconst uniqueArray = uniqBy(combinedArray, 'id');\n\nsetFilterReference(uniqueArray);\n</code></pre> <ul> <li>Top 10 JavaScript Libraries To Use in 2024 </li> <li>js-utility-libraries</li> </ul> <ul> <li>pip install mkdocs-pdf</li> <li>mkdocs-pdf: pypi</li> <li>How to link a pdf</li> <li></li> <li>How to Import SVGs in a React and Vite app</li> <li>How to display svg icons(.svg files) in UI using React Component?: slackoverflow</li> <li>How to use SVGs in React</li> </ul>","tags":["postman","http"]},{"location":"blog/2024/08/10/empty-array-or-null/","title":"Empty array or null","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/08/10/empty-array-or-null/#empty-array-or-null","title":"Empty array or null","text":"<p>In your case, both approaches can work, but using an empty array (<code>[]</code>) instead of <code>null</code> for <code>getCircularPlanningResp</code> is generally a better practice.</p> <p>Here\u2019s why:</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/10/empty-array-or-null/#1-consistency","title":"1. Consistency:","text":"<ul> <li>Empty Array (<code>[]</code>): Using an empty array signifies that there are no logs available yet, which aligns with the concept of a list. This allows your components to render without worrying about type checking and makes it clear that you can still iterate over it safely.</li> <li>Null: Using <code>null</code> can lead to situations where you have to add additional checks or handling in your components to avoid errors when trying to map over it.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/08/10/empty-array-or-null/#2-ease-of-mapping","title":"2. Ease of Mapping:","text":"<ul> <li>When you return an empty array, you can directly call <code>.map()</code> on it without any checks:</li> </ul> <pre><code>const dataSource = getCircularPlanningResp.map((log) =&gt; ({\n  key: log.id,\n  remarks: log.remarks,\n  creationTime: log.creationTime,\n}));\n</code></pre> <p>This avoids the need for additional checks and improves readability.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/10/empty-array-or-null/#3-state-management","title":"3. State Management:","text":"<ul> <li>It can be clearer in your state management. For example:</li> </ul> <pre><code>const initialState = {\n  getCircularPlanningResp: [], // Use an empty array\n  getCircularPlanningLoading: false,\n};\n</code></pre> <p>This indicates that <code>getCircularPlanningResp</code> will always be an array, which can help prevent potential <code>TypeError</code> issues throughout your code.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/10/empty-array-or-null/#4-ui-feedback","title":"4. UI Feedback:","text":"<ul> <li>When <code>getCircularPlanningResp</code> is an empty array, you can render a message like \"No logs available\" directly in your component if needed:</li> </ul> <pre><code>if (dataSource.length === 0) {\n  return &lt;div&gt;No logs available&lt;/div&gt;;\n}\n</code></pre>","tags":["Porgramming","React"]},{"location":"blog/2024/08/10/empty-array-or-null/#conclusion","title":"Conclusion","text":"<p>While both <code>null</code> and an empty array can be used, using an empty array (<code>[]</code>) is generally preferred because it simplifies your logic, improves code clarity, and avoids potential errors when dealing with array operations. It also aligns well with how data is usually expected in UI components, making the development process smoother.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/14/using-immer-with-standard-redux/","title":"Using Immer with Standard Redux","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/08/14/using-immer-with-standard-redux/#using-immer-with-standard-redux","title":"Using Immer with Standard Redux","text":"<p>Using <code>Immer</code> with <code>Redux</code> in the same project is a common practice and can be very beneficial.</p> <p>Here's how they can complement each other, along with standard practices:</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/14/using-immer-with-standard-redux/#using-immer-with-redux","title":"Using Immer with Redux","text":"<ol> <li> <p>State Management Simplification:</p> <ul> <li>Immer allows you to write \"mutable\" code when updating state, which can make your reducers much more readable.</li> <li>Instead of returning new state objects with the spread operator or using methods like <code>map</code>, <code>filter</code>, or <code>reduce</code>, you can mutate a draft state directly.</li> </ul> </li> <li> <p>Integration with Redux Toolkit:</p> <ul> <li>Redux Toolkit already uses Immer under the hood for its <code>createSlice</code> method. This means you can write reducers that look mutable, but they are actually producing immutable updates.</li> <li>This allows you to leverage both libraries seamlessly, especially when using the Toolkit.</li> </ul> </li> </ol>","tags":["Porgramming","React"]},{"location":"blog/2024/08/14/using-immer-with-standard-redux/#example-with-redux-toolkit-and-immer","title":"Example with Redux Toolkit and Immer","text":"CodeStandard Practices <pre><code>import { createSlice } from '@reduxjs/toolkit';\n\nconst itemsSlice = createSlice({\n    name: 'items',\n    initialState: [],\n    reducers: {\n        addItem: (state, action) =&gt; {\n            state.push(action.payload); // Mutative update, thanks to Immer\n        },\n        updateItem: (state, action) =&gt; {\n            const index = state.findIndex(item =&gt; item.id === action.payload.id);\n            if (index !== -1) {\n                state[index] = action.payload; // Mutative update\n            }\n        },\n        deleteItem: (state, action) =&gt; {\n            return state.filter(item =&gt; item.id !== action.payload.id); // Non-mutative, but still concise\n        },\n    },\n});\n\nexport const { addItem, updateItem, deleteItem } = itemsSlice.actions;\nexport default itemsSlice.reducer;\n</code></pre> <ol> <li> <p>Use Redux Toolkit:</p> <ul> <li>Start with Redux Toolkit for setting up Redux. It simplifies the Redux setup and integrates well with Immer.</li> </ul> </li> <li> <p>Leverage Immer for Reducers:</p> <ul> <li>Use Immer's mutability in reducers when you need more complex state updates. This can reduce boilerplate code and improve clarity.</li> </ul> </li> <li> <p>Keep State Management Concise:</p> <ul> <li>Use Immer to handle nested state updates easily without the need for deep cloning or complex logic.</li> </ul> </li> <li> <p>Evaluate Needs:</p> <ul> <li>While Immer is very useful, consider your project's complexity. For simple state updates, the standard Redux pattern may suffice without needing Immer.</li> </ul> </li> <li> <p>Documentation and Consistency:</p> <ul> <li>Document your use of these libraries in your codebase to ensure all team members understand the patterns being used.</li> </ul> </li> </ol>","tags":["Porgramming","React"]},{"location":"blog/2024/08/14/using-immer-with-standard-redux/#conclusion","title":"Conclusion","text":"<p>Combining Immer and Redux Toolkit is a standard practice in modern Redux applications. It improves the developer experience by allowing clearer and more concise state management while maintaining the immutable nature of Redux.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/07/where-does-redux-shines/","title":"Where does redux shines?","text":"","tags":["react","redux"]},{"location":"blog/2024/08/07/where-does-redux-shines/#where-does-redux-shines","title":"Where does <code>redux</code> shines?","text":"<p>Redux shines in scenarios where managing state across a complex application becomes cumbersome with React\u2019s built-in state management.</p> <p>Here are some common scenarios where Redux is beneficial, along with examples:</p>","tags":["react","redux"]},{"location":"blog/2024/08/07/where-does-redux-shines/#scenario-1","title":"Scenario 1","text":"<p>Complex State Management Across Multiple Components</p> <p>When your application has a complex state that needs to be shared among many components, Redux can centralize and simplify this state management.</p> ScenarioCode Example <p>Example: A Shopping Cart Application</p> <p>Imagine a shopping cart application where you have multiple components like <code>ProductList</code>, <code>Cart</code>, and <code>Checkout</code> that need to access and update the cart state.</p> <p>Without Redux:</p> <ul> <li>You might have to pass cart state and handlers through many layers of components using props, which can become messy and hard to maintain.</li> </ul> <p>With Redux:</p> <ul> <li>You can manage the cart state in a single Redux store, making it accessible from any component without prop drilling.</li> </ul> <pre><code>// actions.js\nexport const addItem = item =&gt; ({\n    type: 'ADD_ITEM',\n    payload: item,\n});\n\nexport const removeItem = id =&gt; ({\n    type: 'REMOVE_ITEM',\n    payload: id,\n});\n\n// reducers.js\nconst initialState = {\n    cart: [],\n};\n\nconst cartReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case 'ADD_ITEM':\n            return { ...state, cart: [...state.cart, action.payload] };\n        case 'REMOVE_ITEM':\n            return { ...state, cart: state.cart.filter(item =&gt; item.id !== action.payload) };\n        default:\n            return state;\n    }\n};\n\nexport default cartReducer;\n\n// store.js\nimport { createStore } from 'redux';\nimport cartReducer from './reducers';\n\nconst store = createStore(cartReducer);\n\nexport default store;\n\n// ProductList.js\nimport React from 'react';\nimport { useDispatch } from 'react-redux';\nimport { addItem } from './actions';\n\nconst ProductList = () =&gt; {\n    const dispatch = useDispatch();\n\n    const handleAddToCart = item =&gt; {\n        dispatch(addItem(item));\n    };\n\n    // Render product list with button to add to cart\n    return (\n        &lt;div&gt;\n            {/* Render product items */}\n            &lt;button onClick={() =&gt; handleAddToCart({ id: 1, name: 'Product 1' })}&gt;Add to Cart&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\n// Cart.js\nimport React from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { removeItem } from './actions';\n\nconst Cart = () =&gt; {\n    const cart = useSelector(state =&gt; state.cart);\n    const dispatch = useDispatch();\n\n    const handleRemove = id =&gt; {\n        dispatch(removeItem(id));\n    };\n\n    return (\n        &lt;div&gt;\n        {cart.map(item =&gt; (\n            &lt;div key={item.id}&gt;\n                {item.name}\n                &lt;button onClick={() =&gt; handleRemove(item.id)}&gt;Remove&lt;/button&gt;\n            &lt;/div&gt;\n        ))}\n        &lt;/div&gt;\n    );\n};\n\n// App.js\nimport React from 'react';\nimport { Provider } from 'react-redux';\nimport store from './store';\nimport ProductList from './ProductList';\nimport Cart from './Cart';\n\nconst App = () =&gt; (\n    &lt;Provider store={store}&gt;\n        &lt;div&gt;\n            &lt;ProductList /&gt;\n            &lt;Cart /&gt;\n        &lt;/div&gt;\n    &lt;/Provider&gt;\n);\n\nexport default App;\n</code></pre>","tags":["react","redux"]},{"location":"blog/2024/08/07/where-does-redux-shines/#scenario-2","title":"Scenario 2","text":"<p>Complex Async Operations</p> <p>Redux, especially with middleware like redux-thunk or redux-saga, helps manage complex asynchronous operations.</p> ScenarioCode Example <p>Example: Fetching Data from an API</p> <p>When you need to fetch data from an API and update your application state based on the result, Redux can help manage these async actions in a clean manner.</p> <p>Without Redux:</p> <ul> <li>You might handle async operations directly in components, leading to scattered logic and difficult-to-manage code.</li> </ul> <p>With Redux:</p> <ul> <li>Redux middleware like <code>redux-thunk</code> allows you to dispatch actions for async operations and manage loading, success, and error states.</li> </ul> <pre><code>// actions.js\nimport axios from 'axios';\n\nexport const fetchData = () =&gt; async dispatch =&gt; {\n    dispatch({ type: 'FETCH_DATA_REQUEST' });\n    try {\n        const response = await axios.get('https://api.example.com/data');\n        dispatch({ type: 'FETCH_DATA_SUCCESS', payload: response.data });\n    } catch (error) {\n        dispatch({ type: 'FETCH_DATA_FAILURE', payload: error });\n    }\n};\n\n// reducers.js\nconst initialState = {\n    data: [],\n    loading: false,\n    error: null,\n};\n\nconst dataReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case 'FETCH_DATA_REQUEST':\n            return { ...state, loading: true };\n        case 'FETCH_DATA_SUCCESS':\n            return { ...state, loading: false, data: action.payload };\n        case 'FETCH_DATA_FAILURE':\n            return { ...state, loading: false, error: action.payload };\n        default:\n            return state;\n    }\n};\n\nexport default dataReducer;\n\n// DataDisplay.js\nimport React, { useEffect } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { fetchData } from './actions';\n\nconst DataDisplay = () =&gt; {\n    const dispatch = useDispatch();\n    const { data, loading, error } = useSelector(state =&gt; state.data);\n\n    useEffect(() =&gt; {\n        dispatch(fetchData());\n    }, [dispatch]);\n\n    if (loading) return &lt;p&gt;Loading...&lt;/p&gt;;\n    if (error) return &lt;p&gt;Error: {error.message}&lt;/p&gt;;\n\n    return (\n        &lt;div&gt;\n            {data.map(item =&gt; (\n            &lt;div key={item.id}&gt;{item.name}&lt;/div&gt;\n            ))}\n        &lt;/div&gt;\n    );\n};\n\n// App.js\nimport React from 'react';\nimport { Provider } from 'react-redux';\nimport store from './store';\nimport DataDisplay from './DataDisplay';\n\nconst App = () =&gt; (\n    &lt;Provider store={store}&gt;\n        &lt;div&gt;\n            &lt;DataDisplay /&gt;\n        &lt;/div&gt;\n    &lt;/Provider&gt;\n);\n\nexport default App;\n</code></pre>","tags":["react","redux"]},{"location":"blog/2024/08/07/where-does-redux-shines/#scenario-3","title":"Scenario 3","text":"<p>Maintaining Consistent State Across Components</p> <p>If you have multiple components that need to access or modify the same piece of state in a consistent manner, Redux helps keep this state synchronized.</p> ScenarioCode Example <p>Example: User Authentication</p> <p>When managing user authentication status and user information, Redux can ensure that all components reflecting user-related data stay in sync.</p> <pre><code>// actions.js\nexport const login = user =&gt; ({\n    type: 'LOGIN',\n    payload: user,\n});\n\nexport const logout = () =&gt; ({\n    type: 'LOGOUT',\n});\n\n// reducers.js\nconst initialState = {\n    user: null,\n};\n\nconst authReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case 'LOGIN':\n            return { ...state, user: action.payload };\n        case 'LOGOUT':\n            return { ...state, user: null };\n        default:\n            return state;\n    }\n};\n\nexport default authReducer;\n\n// UserProfile.js\nimport React from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { logout } from './actions';\n\nconst UserProfile = () =&gt; {\n    const user = useSelector(state =&gt; state.user);\n    const dispatch = useDispatch();\n\n    if (!user) return &lt;p&gt;Please log in.&lt;/p&gt;;\n\n    return (\n        &lt;div&gt;\n            &lt;p&gt;Welcome, {user.name}!&lt;/p&gt;\n            &lt;button onClick={() =&gt; dispatch(logout())}&gt;Logout&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\n// LoginForm.js\nimport React, { useState } from 'react';\nimport { useDispatch } from 'react-redux';\nimport { login } from './actions';\n\nconst LoginForm = () =&gt; {\n    const [username, setUsername] = useState('');\n    const dispatch = useDispatch();\n\n    const handleSubmit = e =&gt; {\n        e.preventDefault();\n        dispatch(login({ name: username }));\n    };\n\n    return (\n        &lt;form onSubmit={handleSubmit}&gt;\n            &lt;input\n                type=\"text\"\n                value={username}\n                onChange={e =&gt; setUsername(e.target.value)}\n                placeholder=\"Username\"\n            /&gt;\n            &lt;button type=\"submit\"&gt;Login&lt;/button&gt;\n        &lt;/form&gt;\n    );\n};\n\n// App.js\nimport React from 'react';\nimport { Provider } from 'react-redux';\nimport store from './store';\nimport UserProfile from './UserProfile';\nimport LoginForm from './LoginForm';\n\nconst App = () =&gt; (\n    &lt;Provider store={store}&gt;\n        &lt;div&gt;\n            &lt;UserProfile /&gt;\n            &lt;LoginForm /&gt;\n        &lt;/div&gt;\n    &lt;/Provider&gt;\n);\n\nexport default App;\n</code></pre>","tags":["react","redux"]},{"location":"blog/2024/08/07/where-does-redux-shines/#summary","title":"Summary","text":"Redux is particularly useful for: <ul> <li>Complex state sharing among many components.</li> <li>Predictable state management with centralized control.</li> <li>Handling complex async operations with middleware.</li> <li>Maintaining consistent state across components in larger applications.</li> </ul> <p>These examples illustrate how Redux can help manage state in different scenarios, providing a more organized and scalable approach to state management.</p>","tags":["react","redux"]},{"location":"blog/2024/08/22/where-to-store-api-calls-in-redux-toolkit/","title":"Where to store API calls in Redux Toolkit","text":"","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/22/where-to-store-api-calls-in-redux-toolkit/#where-to-store-api-calls-in-redux-toolkit","title":"Where to store API calls in Redux Toolkit","text":"<p>Importing API functions typically depends on your project's organization and the specific architecture you're using.</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/22/where-to-store-api-calls-in-redux-toolkit/#overview","title":"Overview","text":"<p>Here are a few common approaches:</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/22/where-to-store-api-calls-in-redux-toolkit/#1-feature-specific-api-imports","title":"1. Feature-Specific API Imports","text":"<p>If your API calls are closely tied to specific features, you can create an <code>api.js</code> file within each feature folder. This keeps everything related to that feature together.</p> Example <pre><code>/src\n    /features\n        /auth\n            authSlice.js\n            authAPI.js       // API functions for authentication\n        /products\n            productSlice.js\n            productAPI.js    // API functions for products\n</code></pre>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/22/where-to-store-api-calls-in-redux-toolkit/#2-centralized-api-folder","title":"2. Centralized API Folder","text":"<p>For larger projects, you might prefer a centralized folder for all API calls. This can help manage your API functions in one place, especially if they are used across multiple features.</p> Example <pre><code>/src\n    /api\n        authAPI.js        // API functions for authentication\n        productAPI.js     // API functions for products\n    /features\n        /auth\n            authSlice.js\n        /products\n            productSlice.js\n</code></pre>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/22/where-to-store-api-calls-in-redux-toolkit/#3-using-a-service-layer","title":"3. Using a Service Layer","text":"<p>You could also implement a service layer where each service file corresponds to a feature and contains both API calls and any logic related to that feature.</p> Example Structure <pre><code>/src\n    /services\n        authService.js    // Functions to handle authentication logic\n        productService.js  // Functions to handle product-related logic\n/features\n    /auth\n        authSlice.js\n    /products\n        productSlice.js\n</code></pre>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/22/where-to-store-api-calls-in-redux-toolkit/#where-to-import-api-functions","title":"Where to Import API Functions","text":"<ul> <li>Within Feature Components/Slices: Import the API functions in your feature slices or components where they are needed. For example, in your <code>authSlice.js</code>, you could import the <code>authAPI.js</code> functions.</li> </ul> Example <pre><code>// In authSlice.js\nimport { login, register } from '../api/authAPI';\n\n// Usage in a thunk or action\n</code></pre> Summary <ul> <li>Use feature-specific API files for tightly coupled features.</li> <li>Use a centralized API folder for shared functions.</li> <li>Consider a service layer for better separation of concerns.</li> </ul> <p>Choose the structure that best fits your project's needs and keeps your code organized and maintainable!</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/22/where-to-store-api-calls-in-redux-toolkit/#categorized-by-application-size","title":"Categorized by Application Size","text":"<p>Let\u2019s clarify the approaches to organizing your API calls and services in a structured way, tailored for different application sizes.</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/22/where-to-store-api-calls-in-redux-toolkit/#1-small-applications","title":"1. Small Applications","text":"<p>Structure: Centralized API File or Feature-Specific Files</p> <ul> <li>Centralized API File: All API calls in one place.</li> </ul> StructureExample (api.js) <pre><code>/src\n    /api\n        api.js           // Contains all API functions\n</code></pre> <pre><code>export const loginAPI = async (credentials) =&gt; {\n    // API call for login\n};\n\nexport const fetchProductsAPI = async () =&gt; {\n    // API call for fetching products\n};\n</code></pre> <ul> <li>Feature-Specific Files: Separate files for each feature.</li> </ul> StructureExample (authAPI.js) <pre><code>/src\n    /api\n        authAPI.js      // API functions for authentication\n        productAPI.js   // API functions for products\n</code></pre> <pre><code>export const login = async (credentials) =&gt; {\n    // API call for login\n};\n</code></pre>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/22/where-to-store-api-calls-in-redux-toolkit/#2-medium-applications","title":"2. Medium Applications","text":"<p>Structure: Feature-Specific API Files with Service Layer</p> <ul> <li>Feature-Specific API Files: Group related API calls.</li> </ul> StructureExample (authService.js) <pre><code>/src\n    /services\n        authService.js       // Handles auth logic and API calls\n        productService.js    // Handles product logic and API calls\n</code></pre> <pre><code>import { loginAPI, registerAPI } from '../api/authAPI';\n\nexport const login = async (credentials) =&gt; {\n    const response = await loginAPI(credentials);\n    // Handle response, e.g., saving tokens\n    return response.data;\n};\n</code></pre>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/22/where-to-store-api-calls-in-redux-toolkit/#3-large-applications","title":"3. Large Applications","text":"<p>Structure: Comprehensive Service Layer with Clear Separation</p> <ul> <li>Service Layer: Each service file handles its logic and API calls.</li> </ul> StructureExample (authService.js) <pre><code>/src\n    /services\n        authService.js       // Authentication logic and API calls\n        productService.js    // Product logic and API calls\n    /api\n        authAPI.js           // Raw API functions for authentication\n        productAPI.js        // Raw API functions for products\n</code></pre> <pre><code>import { loginAPI, registerAPI } from \"../api/authAPI\";\n\nexport const authService = {\n    login: async (credentials) =&gt; {\n        const response = await loginAPI(credentials);\n        // Additional login logic\n        return response.data;\n    },\n    register: async (userInfo) =&gt; {\n        const response = await registerAPI(userInfo);\n        // Additional registration logic\n        return response.data;\n    },\n};\n</code></pre> <p>Full Example</p> Project Structure1. authAPI.js2. authService.js3. authSlice.js4. store.js <pre><code>/src\n    /api\n        authAPI.js          // Raw API functions for authentication\n    /services\n        authService.js      // Authentication logic and API calls\n    /features\n        /auth\n        authSlice.js      // Redux slice for authentication state\n    /store\n        store.js            // Redux store setup\n</code></pre> <p>This file contains the raw API calls using <code>axios</code>.</p> <pre><code>// src/api/authAPI.js\nimport axios from 'axios';\n\nconst API_URL = 'https://api.example.com/auth'; // Replace with your API URL\n\nexport const loginAPI = async (credentials) =&gt; {\n    return await axios.post(`${API_URL}/login`, credentials);\n};\n\nexport const registerAPI = async (userInfo) =&gt; {\n    return await axios.post(`${API_URL}/register`, userInfo);\n};\n\nexport const logoutAPI = async () =&gt; {\n    return await axios.post(`${API_URL}/logout`);\n};\n</code></pre> <p>This file handles the logic for calling the API and managing side effects.</p> <pre><code>// src/services/authService.js\nimport { loginAPI, registerAPI, logoutAPI } from '../api/authAPI';\n\nexport const authService = {\n    login: async (credentials) =&gt; {\n        const response = await loginAPI(credentials);\n        // Additional logic (e.g., storing tokens) can be added here\n        return response.data;\n    },\n    register: async (userInfo) =&gt; {\n        const response = await registerAPI(userInfo);\n        return response.data;\n    },\n    logout: async () =&gt; {\n        await logoutAPI();\n        // Additional logic for logout can be added here\n    }\n};\n</code></pre> <p>This file defines the Redux slice for managing authentication state.</p> <pre><code>// src/features/auth/authSlice.js\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { authService } from '../../services/authService';\n\nexport const login = createAsyncThunk('auth/login', async (credentials) =&gt; {\n    const data = await authService.login(credentials);\n    return data; // Return user data (e.g., tokens)\n});\n\nexport const register = createAsyncThunk('auth/register', async (userInfo) =&gt; {\n    const data = await authService.register(userInfo);\n    return data; // Return user data\n});\n\nexport const logout = createAsyncThunk('auth/logout', async () =&gt; {\n    await authService.logout();\n});\n\nconst authSlice = createSlice({\n    name: 'auth',\n    initialState: {\n        user: null,\n        isLoading: false,\n        error: null,\n    },\n    reducers: {},\n    extraReducers: (builder) =&gt; {\n        builder\n            .addCase(login.pending, (state) =&gt; {\n                state.isLoading = true;\n                state.error = null;\n            })\n            .addCase(login.fulfilled, (state, action) =&gt; {\n                state.isLoading = false;\n                state.user = action.payload; // Set user data\n            })\n            .addCase(login.rejected, (state, action) =&gt; {\n                state.isLoading = false;\n                state.error = action.error.message; // Handle error\n            })\n            .addCase(logout.fulfilled, (state) =&gt; {\n                state.user = null; // Clear user on logout\n            });\n    },\n});\n\nexport default authSlice.reducer;\n</code></pre> <p>Set up the Redux store to include the authentication slice.</p> <pre><code>// src/store/store.js\nimport { configureStore } from '@reduxjs/toolkit';\nimport authReducer from '../features/auth/authSlice';\n\nconst store = configureStore({\n    reducer: {\n        auth: authReducer,\n    },\n});\n\nexport default store;\n</code></pre> <p>Example Usage in a Component</p> ExampleSummary <p>Here\u2019s an example of how you might use the authentication features in a React component.</p> <pre><code>// src/components/LoginComponent.js\nimport React, { useState } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { login } from '../features/auth/authSlice';\n\nconst LoginComponent = () =&gt; {\n    const [credentials, setCredentials] = useState({ email: '', password: '' });\n    const dispatch = useDispatch();\n    const { isLoading, error } = useSelector((state) =&gt; state.auth);\n\n    const handleSubmit = (e) =&gt; {\n        e.preventDefault();\n        dispatch(login(credentials));\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;h2&gt;Login&lt;/h2&gt;\n            {error &amp;&amp; &lt;p&gt;Error: {error}&lt;/p&gt;}\n            &lt;form onSubmit={handleSubmit}&gt;\n                &lt;input\n                    type=\"email\"\n                    placeholder=\"Email\"\n                    value={credentials.email}\n                    onChange={(e) =&gt; setCredentials({ ...credentials, email: e.target.value })}\n                    required\n                /&gt;\n                &lt;input\n                    type=\"password\"\n                    placeholder=\"Password\"\n                    value={credentials.password}\n                    onChange={(e) =&gt; setCredentials({ ...credentials, password: e.target.value })}\n                    required\n                /&gt;\n                &lt;button type=\"submit\" disabled={isLoading}&gt;\n                    {isLoading ? 'Loading...' : 'Login'}\n                &lt;/button&gt;\n            &lt;/form&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default LoginComponent;\n</code></pre> <ol> <li>authAPI.js: Contains raw API calls using <code>axios</code>.</li> <li>authService.js: Handles calling the API and any additional logic (e.g., storing tokens).</li> <li>authSlice.js: Manages the authentication state using Redux Toolkit.</li> <li>store.js: Configures the Redux store with the authentication slice.</li> <li>LoginComponent.js: Example component that uses the login functionality.</li> </ol> <p>This structure keeps your code organized and makes it easy to manage authentication in a large application.</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/22/where-to-store-api-calls-in-redux-toolkit/#summary","title":"Summary","text":"<ul> <li>Small Apps: Use a single API file or separate files for each feature.</li> <li>Medium Apps: Use feature-specific files along with a service layer for better organization.</li> <li>Large Apps: Implement a full service layer with clear separation between API calls and business logic.</li> </ul> <p>This should provide a clear and structured approach to organizing your API and service layers based on application size.</p> <p>Question</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/22/where-to-store-api-calls-in-redux-toolkit/#question-1","title":"Question 1","text":"<p>1. Storing API Calls:</p> <ul> <li>API calls, particularly those using Axios, are best stored in a dedicated <code>/services</code> folder within your project. This keeps your API logic separate from your components and Redux slices, promoting a clear structure and separation of concerns.</li> </ul> <p>2. Structure of the Services Folder:</p> <p>The <code>/services</code> folder can contain:</p> <ul> <li>An Axios instance for default configurations (like base URL and headers).</li> <li>Specific service files for various API endpoints or resources (e.g., users, posts).</li> </ul> <pre><code>/src\n\u251c\u2500\u2500 /services\n\u2502   \u251c\u2500\u2500 axiosInstance.js        // Axios instance with default settings\n\u2502   \u251c\u2500\u2500 userService.js          // API calls related to users\n\u2502   \u2514\u2500\u2500 postService.js          // API calls related to posts\n</code></pre> <p>3. Creating the Axios Instance:</p> <ul> <li>The Axios instance allows you to define default configurations (like the base URL) that will be used across all API calls.</li> </ul> axiosInstance.js<pre><code>// /services/axiosInstance.js\nimport axios from \"axios\";\n\nconst axiosInstance = axios.create({\n  baseURL: \"https://api.example.com\", // Set your API base URL here\n  timeout: 1000, // Optional: Set timeout for requests\n});\n\nexport default axiosInstance;\n</code></pre> <p>4. Defining API Calls in Service Files:</p> <ul> <li>Each service file can contain functions that correspond to specific API endpoints.</li> </ul> userService.js<pre><code>// /services/userService.js\nimport axiosInstance from \"./axiosInstance\";\n\nexport const getUsers = async () =&gt; {\n  const response = await axiosInstance.get(\"/users\");\n  return response.data;\n};\n\nexport const getUserById = async (id) =&gt; {\n  const response = await axiosInstance.get(`/users/${id}`);\n  return response.data;\n};\n</code></pre> <p>5. Benefits of This Organization:</p> <ul> <li>Separation of Concerns: Keeps your API logic distinct from your UI and Redux state management, making the code easier to read and maintain.</li> <li>Reusability: Allows for easy reuse of API calls across different components and slices.</li> <li>Easier Testing: Having a dedicated services layer makes it easier to mock API calls during unit testing.</li> </ul> <p>Summary:</p> <p>Storing API calls in a <code>/services</code> folder keeps your code organized and promotes separation of concerns. This structure allows for better maintainability, reusability, and testing of your API logic in a Redux Toolkit application.</p>","tags":["Porgramming","Redux","Saga","Thunk"]},{"location":"blog/2024/08/15/write-cleaner-reducers-with-immer/","title":"Write Cleaner Reducers with Immer","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/08/15/write-cleaner-reducers-with-immer/#write-cleaner-reducers-with-immer","title":"Write Cleaner Reducers with Immer","text":"<p>Immer is primarily used in the following contexts within a JavaScript or React application:</p> Title <ul> <li>Simplifying State Management: The Power of Immer in Redux</li> <li>Write Cleaner Reducers with Immer: A Guide for Redux Developers</li> <li>Harnessing Immer for Immutable State Updates in React</li> <li>How Immer Transforms Redux: A Deep Dive into Mutable Logic</li> <li>Boost Your Redux Efficiency with Immer: Best Practices and Examples</li> <li>Understanding Immer: The Secret to Easier State Management in Redux</li> <li>From Immutable to Intuitive: Using Immer in Your Redux Workflow</li> <li>Integrating Immer with Redux Toolkit: Simplifying Your State Logic</li> <li>Mastering State Updates: Why You Should Use Immer in Your Projects</li> <li>Streamlining State Management: Leveraging Immer in React Applications</li> </ul> <p></p>","tags":["Porgramming","React"]},{"location":"blog/2024/08/15/write-cleaner-reducers-with-immer/#1-in-redux-reducers","title":"1. In Redux Reducers","text":"<ul> <li>Purpose: Simplifies state updates by allowing you to write mutable code that is transformed into immutable updates.</li> <li>Usage: In reducers, you can modify a draft state directly. For example:</li> </ul> <pre><code>import produce from \"immer\";\n\nconst reducer = produce((draft, action) =&gt; {\n  switch (action.type) {\n    case \"ADD_ITEM\":\n      draft.push(action.payload);\n      break;\n    case \"UPDATE_ITEM\":\n      const index = draft.findIndex((item) =&gt; item.id === action.payload.id);\n      if (index !== -1) {\n        draft[index] = action.payload;\n      }\n      break;\n    // Other cases...\n  }\n}, initialState);\n</code></pre>","tags":["Porgramming","React"]},{"location":"blog/2024/08/15/write-cleaner-reducers-with-immer/#2-in-redux-toolkit","title":"2. In Redux Toolkit","text":"<ul> <li>Purpose: Redux Toolkit integrates Immer by default for its <code>createSlice</code> function.</li> <li>Usage: When defining reducers, you can use mutable logic directly without needing to import Immer separately</li> </ul> <pre><code>import { createSlice } from \"@reduxjs/toolkit\";\n\nconst itemsSlice = createSlice({\n  name: \"items\",\n  initialState: [],\n  reducers: {\n    addItem: (state, action) =&gt; {\n      state.push(action.payload); // Mutable update\n    },\n    updateItem: (state, action) =&gt; {\n      const index = state.findIndex((item) =&gt; item.id === action.payload.id);\n      if (index !== -1) {\n        state[index] = action.payload; // Mutable update\n      }\n    },\n  },\n});\n</code></pre>","tags":["Porgramming","React"]},{"location":"blog/2024/08/15/write-cleaner-reducers-with-immer/#3-in-react-state-management","title":"3. In React State Management","text":"<ul> <li>Purpose: While less common, Immer can also be used to manage local component state.</li> <li>Usage: You can use Immer with the <code>useState</code> hook to simplify complex updates:</li> </ul> <pre><code>import { useState } from \"react\";\nimport produce from \"immer\";\n\nconst MyComponent = () =&gt; {\n  const [state, setState] = useState(initialState);\n\n  const updateState = (newData) =&gt; {\n    setState(\n      produce(state, (draft) =&gt; {\n        draft.someProperty = newData;\n      })\n    );\n  };\n};\n</code></pre>","tags":["Porgramming","React"]},{"location":"blog/2024/08/15/write-cleaner-reducers-with-immer/#conclusion","title":"Conclusion","text":"<p>Immer is primarily used in reducers for state management in Redux (and Redux Toolkit) to allow for simpler, more readable code while maintaining immutability. It can also be applied to local component state updates in React for similar benefits.</p>","tags":["Porgramming","React"]},{"location":"frontend/fp/books/","title":"Books","text":""},{"location":"frontend/fp/definition/","title":"Definition","text":""},{"location":"frontend/fp/definition/#high-order-functions-hoc","title":"High Order Functions (HOC)","text":"<p>Higher-order functions are central to functional programming and flow naturally from the idea that functions should be \u201cfirst-class objects\u201d in a language, with all of the rights and privileges that numbers or lists have.</p> <p>A higher-order function is one that accepts a function as input and/or returns a function as output.</p> <ul> <li>LEARN PHYSICS WITH FUNCTIONAL PROGRAMMING by 2023 by Scott N. Walck</li> </ul> <p>A function that takes another function as a parameter, or returns a function as a result, is known as a high-order function.</p> <ul> <li>Quick Functional Programming by David Matuszek</li> </ul> <p>A function that accepts another function as a parameter, or returns a function, or both, is known as a higher order function.</p> <p>Memoization is the process where interim values are cached rather than recreated, cutting down on the number of iterations and computation time.</p> <ul> <li>JavaScript Cookbook, Second Edition by Shelley Powers, pg: 80</li> </ul> Note <p>In a functional language, functions are values.</p> <p>This means that they can be stored in variables, passed around as parameters, and returned as the result of a function calls, just like any other type of value. There are even operations on functions that produce new functions.</p> <ul> <li>Quick Functional Programming by David Matuszek</li> </ul>"},{"location":"frontend/fp/definition/#currying","title":"Currying","text":"<p>Currying is a technique to convert a function that takes multiple parameters into a series of functions, each taking a single function.</p> <ul> <li>Quick Functional Programming by David Matuszek : pg-67</li> </ul> Note <p>No Description of Functional programming would be complete without a mention of currying. Curring is a technique developed by the mathematician Haskell Curry (the programing language Haskell is also named after him).</p>"},{"location":"frontend/fp/definition/#key-features-of-javascript","title":"Key features of JavaScript","text":"<p>JavaScript isn\u2019t a purely functional language, but it has all the features that we need for it to work as if it were. The main features of the language that we will be using are as follows:</p> <ul> <li>Functions as first-class objects</li> <li>Recursion</li> <li>Closures</li> <li>Arrow functions</li> <li>Spread</li> </ul> <p>Functions as first-class objects</p> <p>Saying that functions are first-class objects (also called first-class entities or first-class citizens) means that you can do everything with functions that you can do with other objects. For example, you can store a function in a variable, you can pass it to a function, you can print it out, and so on. This is really the key to doing FP; we will often be passing functions as parameters (to other functions) or returning a function as the result of a function call. If you have been doing <code>async</code> Ajax calls, then you have already been using this feature: a <code>callback</code> is a function that will be called after the Ajax call finishes and is passed as a parameter. Using jQuery, you could write something like the following:</p> <pre><code>$.get(\"some/url\", someData, function (result, status) {\n  // check status, and do something\n  // with the result\n});\n</code></pre> <p>The <code>$.get()</code> function receives a callback function as a parameter and calls it after the result is obtained.</p> The way to go <p>This is better solved, in a more modern way, by using promises or async/await, but for the sake of our example, the old way is enough. We\u2019ll be getting back to promises, though, in Chapter 12, Building Better Containers, when we discuss monads; in particular, see the Unexpected monads \u2013 promises section.</p> 3 basic ways to define function <p>JavaScript functions provide a way to encapsulate a block of code in order to reuse the code several times. They are first-class objects in JavaScript, which means they can be treated as an object, as well as an expression or statement.</p> <ul> <li>JavaScript Cookbook, Second Edition by Shelley Powers, pg: 61</li> </ul> note <p>An important concept to remember when considering the different ways you can create a function is hoisting. In JavaScript, all variable declarations are moved, or hoisted to the top of their current scope.</p> <p>That\u2019s declaration, though, not instantiation. The difference is critical. If you access a variable that\u2019s not declared, you\u2019ll get a <code>reference error</code>.</p> <p>However, if you access a variable before it\u2019s declared, but it is declared within the scope at a later time, you\u2019ll get an <code>undefined</code>:</p> <ul> <li>JavaScript Cookbook, Second Edition by Shelley Powers, pg: 62</li> </ul>"},{"location":"frontend/fp/definition/#asynchronous-operations","title":"Asynchronous Operations","text":"<p>Asynchronous operations are operations that happen outside the linear flow of program execution. Normally, the JavaScript engine will execute code line by line, in order from top to bottom, following the normal flow of your program (such as function calls, con\u2010 ditional logic, etc.).</p> <p>Asynchronous operations are broken up into two phases:</p> <ul> <li>call &amp;</li> <li>response.</li> </ul> <p>By definition, it\u2019s impossible to know at what point in the program flow you\u2019ll be when you receive an asynchronous response. There are a couple of popular ways to manage that uncertainty.</p>"},{"location":"frontend/fp/definition/#callbacks","title":"Callbacks","text":"<ul> <li>Callbacks are functions that you pass as arguments to be invoked when the callee has finished its job.</li> <li>Callbacks are commonly passed into event handlers, Ajax requests, and timers.</li> </ul> <p>You should already be familiar with passing callbacks to event listeners and timers:</p> CodeExplanation <pre><code>var $button = $('&lt;button class=\"select\"&gt;Click&lt;/button&gt;').appendTo(\"body\");\n\nasyncTest(\"Async callback event listener.\", function () {\n    $button.on(\"click\", function clicked() {\n        ok(true, \"Button clicked.\");\n        start();\n    });\n\n    setTimeout(function timedOut() {\n        $button.click();\n        $button.remove();\n    }, 20);\n});\n</code></pre> <p>In this code, the <code>clicked()</code> callback gets passed into into jQuery\u2019s <code>.on()</code> method. When <code>$button</code> receives a click event, it invokes <code>clicked()</code>, which runs the <code>ok()</code> assertion and then <code>start()</code>, which tells QUnit that it\u2019s finished waiting for asynchronous operations so it can continue to run tests.</p> <p>Next, the <code>timedOut()</code> callback is passed into <code>setTimeout()</code>, which triggers the click event on <code>$button</code> and removes the button from the DOM.</p> <p>Callbacks work great when you\u2019re only waiting for one operation at a time, or when you only have one job to do when the response comes back, but what if you need to manage multiple asynchronous dependencies or you have several unrelated tasks waiting on the same data (such as a provider authorization)? That\u2019s where promises can be very useful.</p>"},{"location":"frontend/fp/definition/#promises","title":"Promises","text":"<ul> <li>Promises are objects that allow you to add callback functions to success or failure queues.</li> <li>Instead of calling a callback function in response to the completion of an asynchronous (or synchronous) operation, you return a promise, which allows you to register any number of callbacks.</li> </ul> <p>The promise provides access to the state of the operation: whether it\u2019s <code>waiting</code> or <code>finished</code>, and in some cases, what the progress is. You can add callbacks to a promise at any time, which will trigger after the operation is complete and the promise is resolved. If the promise has already resolved, the callback will be invoked immediately.</p> <pre><code>var whenDataFetched = $.getJSON(\"https://graph.facebook.com/jsapplications\");\n\nasyncTest(\"Ajax promise API\", function () {\n  whenDataFetched\n    .done(function (response) {\n      ok(response, \"The server returned data.\");\n      start();\n    })\n    .fail(function () {\n      ok(true, \"There was an error.\");\n      start();\n    });\n});\n</code></pre> Note <p>The difference between a promise and a callback is that a promise is an object that gets returned from the callee, instead of a function that gets passed into and invoked by the callee. With promises, it\u2019s much easier to add additional callbacks if you need them and to isolate those callbacks from each other so that the callback code can be organized independently of the initiating call.</p> <p>Programming Javascript Applications by Eric Elliott - Orielly - pg: 41</p>"},{"location":"frontend/fp/definition/#click-this-link-closure","title":"click this link: Closure","text":""},{"location":"frontend/fp/definition/#click-this-link-js-data-types","title":"click this link: JS Data Types:","text":""},{"location":"frontend/fp/intro/","title":"Intro","text":"<p>Functional Programming</p> <ul> <li> <p>Functional programming is a style of programming that uses higher-order functions (as opposed to objects and data) to facilitate code organization and reuse. A higher order function treats functions as data, either taking a function as an argument or returning a function as a result.</p> </li> <li> <p>Programming Javascript Applications by Eric Elliott - Orielly, pg-36</p> </li> </ul> <p></p> Note <p>In Nepali, the term \"paradigm\" is commonly translated as \"\u092a\u093e\u0930\u093e\u0921\u093e\u0907\u092e\" (pronounced p\u0101r\u0101\u1e0d\u0101'ima) or \"\u0935\u093f\u091a\u093e\u0930\u0927\u093e\u0930\u093e\" (vich\u0101radh\u0101r\u0101), which means \"thought process\" or \"philosophy.\" The second term is more focused on the idea of a mindset or approach to thinking, which aligns with the concept of a paradigm in a more general sense.</p> <p>In the context of programming paradigms, it would typically be referred to as \"\u0915\u093e\u0930\u094d\u092f\u0935\u093f\u0927\u093f\" (k\u0101ryavidh\u012b), which means \"methodology\" or \"approach to work.\"</p> Quote <p>One of the best ways to learn something is to teach it.</p> <ul> <li>LEARN PHYSICS WITH FUNCTIONAL PROGRAMMING by 2023 by Scott N. Walck</li> </ul>"},{"location":"frontend/fp/principle/","title":"Principle","text":""},{"location":"frontend/fp/principle/#overview","title":"Overview","text":"<p>The main principles of functional programming (FP) that are consistent across all functional programming languages are:</p> <ol> <li> <p>First-Class and Higher-Order Functions:</p> <ul> <li>Functions are treated as first-class citizens, meaning they can be passed as arguments, returned from other functions, and assigned to variables.</li> <li>Higher-order functions are those that can take other functions as parameters or return them as results.</li> </ul> </li> <li> <p>Immutability:</p> <ul> <li>Data is immutable by default, meaning once a value is assigned to a variable, it cannot be changed. Instead of modifying values, new values are created by applying functions to existing ones.</li> </ul> </li> <li> <p>Pure Functions:</p> <ul> <li>A function is considered pure if it always produces the same output for the same input and has no side effects (e.g., no changes to the state of the system or I/O operations).</li> </ul> </li> <li> <p>Referential Transparency:</p> <ul> <li>An expression is referentially transparent if it can be replaced with its value without changing the program's behavior. This relies on pure functions and immutability.</li> </ul> </li> <li> <p>Function Composition:</p> <ul> <li>Functions can be composed to build more complex functions. The output of one function can be passed as the input to another, allowing for modular and reusable code.</li> </ul> </li> <li> <p>Lazy Evaluation:</p> <ul> <li>Computation is deferred until the value is actually needed. This can improve performance by avoiding unnecessary calculations and allows for the creation of infinite data structures.</li> </ul> </li> <li> <p>Declarative Style:</p> <ul> <li>Functional programming emphasizes describing what should be done, rather than how to do it (which is more typical in imperative programming). This leads to code that is more readable and easier to maintain.</li> </ul> </li> <li> <p>Avoidance of State and Side Effects:</p> <ul> <li>Functional programming avoids mutable state and side effects. This contrasts with imperative programming, where variables can change and side effects (such as I/O or changes to shared state) are common.</li> </ul> </li> <li> <p>Recursion:</p> <ul> <li>Recursion is a fundamental technique for looping or iteration in functional programming, since mutable state and traditional loops (like for or while) are avoided. Functions often call themselves to solve problems.</li> </ul> </li> <li> <p>Type Systems (in many FP languages):</p> <ul> <li>Many functional programming languages make extensive use of static typing and strong type systems to ensure correctness and reduce errors. Types often enable powerful features like type inference and higher-order type relationships.</li> </ul> </li> </ol> <p>These principles are core to the philosophy of functional programming, and while implementation may vary slightly across languages (e.g., Haskell, Scala, or F#), these concepts remain central to FP.</p>"},{"location":"frontend/fp/principle/#in-js","title":"In JS","text":"<p>Yes, many principles of functional programming can be applied in JavaScript, although JavaScript is not a purely functional programming language. It is a multi-paradigm language that supports functional, object-oriented, and imperative programming styles. Here's how JavaScript aligns with the core principles of functional programming:</p> <ol> <li> <p>First-Class and Higher-Order Functions</p> <ul> <li> <p>Yes. In JavaScript, functions are first-class citizens, meaning they can be passed as arguments, returned from other functions, and assigned to variables. JavaScript supports higher-order functions as well, where functions can take other functions as parameters or return them.</p> <pre><code>const add = (a, b) =&gt; a + b;\nconst applyOperation = (a, b, operation) =&gt; operation(a, b);\n\nconsole.log(applyOperation(2, 3, add)); // Output: 5\n</code></pre> </li> </ul> </li> <li> <p>Immutability</p> <ul> <li> <p>Partially. JavaScript does not enforce immutability by default, but it is possible to achieve immutability with techniques such as using <code>const</code> for variable declarations and libraries like Immutable.js or using features like <code>Object.freeze</code> or <code>Array.prototype.map</code> to avoid mutation.</p> <pre><code>const arr = [1, 2, 3];\nconst newArr = arr.map((x) =&gt; x * 2); // Creates a new array, doesn't mutate `arr`\nconsole.log(arr); // Output: [1, 2, 3]\nconsole.log(newArr); // Output: [2, 4, 6]\n</code></pre> </li> </ul> </li> <li> <p>Pure Functions</p> <ul> <li> <p>Yes. JavaScript supports pure functions, which return the same output for the same input and have no side effects. Writing pure functions in JavaScript is encouraged in functional programming practices.</p> <pre><code>const add = (a, b) =&gt; a + b; // Pure function\n</code></pre> </li> </ul> </li> <li> <p>Referential Transparency</p> <ul> <li> <p>Yes, but it's up to the developer to ensure that functions are pure and do not rely on mutable state, which allows for referential transparency.</p> <pre><code>const double = (x) =&gt; x * 2;\n// double(4) is referentially transparent; it can be replaced with 8\n</code></pre> </li> </ul> </li> <li> <p>Function Composition</p> <ul> <li> <p>Yes. JavaScript allows function composition, often done through chaining or using techniques like <code>compose</code> or <code>pipe</code> (popular in libraries like Ramda).</p> Example (using Ramda)<pre><code>const R = require(\"ramda\");\nconst add5 = (x) =&gt; x + 5;\nconst multiply2 = (x) =&gt; x * 2;\nconst composeFunc = R.compose(multiply2, add5); // Function composition\nconsole.log(composeFunc(3)); // Output: 16 (multiply2(add5(3)))\n</code></pre> </li> </ul> </li> <li> <p>Lazy Evaluation</p> <ul> <li> <p>Partially. JavaScript does not have built-in lazy evaluation, but it can be implemented using techniques such as generators or libraries like Lazy.js.</p> Example (using a generator function)<pre><code>function* range(start, end) {\n    while (start &lt; end) {\n    yield start++;\n    }\n}\nconst gen = range(1, 5);\nconsole.log(gen.next().value); // Output: 1 (evaluates lazily)\n</code></pre> </li> </ul> </li> <li> <p>Declarative Style</p> <ul> <li> <p>Yes. JavaScript allows for a declarative style, especially when working with arrays using methods like <code>map</code>, <code>filter</code>, <code>reduce</code>, etc. These methods help express what should be done, not how.</p> <pre><code>const arr = [1, 2, 3, 4];\nconst doubled = arr.map((x) =&gt; x * 2); // Declarative approach\n</code></pre> </li> </ul> </li> <li> <p>Avoidance of State and Side Effects</p> <ul> <li> <p>Partially. While JavaScript allows side effects (e.g., modifying global state, interacting with I/O), you can still minimize side effects by writing pure functions. Frameworks and libraries like React encourage minimizing side effects.</p> <pre><code>const sum = (a, b) =&gt; a + b; // No side effects\n</code></pre> </li> </ul> </li> <li> <p>Recursion</p> <ul> <li> <p>Yes. JavaScript supports recursion, and while it does not have tail call optimization (which could make recursion more efficient), recursion is commonly used in functional programming.</p> <pre><code>const factorial = (n) =&gt; (n === 0 ? 1 : n * factorial(n - 1));\nconsole.log(factorial(5)); // Output: 120\n</code></pre> </li> </ul> </li> <li> <p>Type Systems</p> <ul> <li>Partially. JavaScript is dynamically typed, meaning types are not enforced at compile time. However, with TypeScript (a superset of JavaScript), you get strong static typing that helps in ensuring type correctness, similar to the type systems in functional programming languages.</li> </ul> </li> </ol> <p>Summary</p> <p>While JavaScript does not enforce functional programming principles as strictly as purely functional languages like Haskell, it can still support functional programming paradigms. You can write <code>pure functions</code>, <code>use higher-order functions</code>, <code>avoid side effects</code>, and <code>emphasize immutability</code> in JavaScript with proper discipline. Libraries like Ramda and Lodash also offer functional programming utilities to help adopt a more functional style in JavaScript.</p>"},{"location":"frontend/fp/principle/#in-react","title":"In React","text":"<p>In React, you can apply many functional programming principles, and it's actually encouraged to write pure, declarative, and immutable code when working with React components. While React itself is a JavaScript library (which is multi-paradigm), it has a strong functional programming influence, especially with the introduction of React Hooks and function components.</p> <p>Here's how <code>functional programming principles</code> apply in React:</p> <ol> <li> <p>First-Class and Higher-Order Functions</p> <p>React components (especially with Hooks) are functions that can accept other functions as props or return other functions.</p> <ul> <li> <p>Higher-order functions in React: Functions that take other functions as arguments or return them as results (like render props or HOCs (Higher-Order Components)).</p> Higher-Order Component (HOC)<pre><code>// A higher-order component that adds a `count` state to any component\nconst withCounter = (WrappedComponent) =&gt; {\n  return function EnhancedComponent(props) {\n      const [count, setCount] = useState(0);\n      return &lt;WrappedComponent count={count} setCount={setCount} {...props} /&gt;;\n  };\n};\n\nconst MyComponent = ({ count, setCount }) =&gt; (\n  &lt;div&gt;\n      &lt;p&gt;Count: {count}&lt;/p&gt;\n      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;\n  &lt;/div&gt;\n);\n\nconst EnhancedComponent = withCounter(MyComponent);\n</code></pre> </li> </ul> </li> <li> <p>Immutability</p> <p>In React, state is often <code>immutable</code>. When state changes, instead of modifying the existing state, you create a <code>new state object</code>.</p> <pre><code>import React, { useState } from \"react\";\n\nconst Counter = () =&gt; {\n  const [count, setCount] = useState(0);\n\n  const increment = () =&gt; setCount((prevCount) =&gt; prevCount + 1);\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Count: {count}&lt;/p&gt;\n      &lt;button onClick={increment}&gt;Increment&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n</code></pre> <p>Here, <code>setCount</code> does not mutate the <code>count</code> directly but creates a new state value, which is the core of immutability in React.</p> </li> <li> <p>Pure Functions</p> <p>React components can be considered <code>pure functions</code> if they always return the same output for the same input and do not cause side effects.</p> <pre><code>const Greeting = ({ name }) =&gt; {\n  return &lt;h1&gt;Hello, {name}!&lt;/h1&gt;;\n};\n</code></pre> <p>In this example, the <code>Greeting</code> component is a pure function since it takes <code>name</code> as input and always returns the same output for the same <code>name</code>.</p> </li> <li> <p>Referential Transparency</p> <p>React encourages referential transparency in its components. If you replace a component call with its output, the behavior of the app won't change.</p> <pre><code>const Double = ({ value }) =&gt; value * 2;\n\nconst App = () =&gt; {\n  const number = 5;\n  return &lt;Double value={number} /&gt;;\n};\n</code></pre> <p>Here, you can replace <code>&lt;Double value={number} /&gt;</code> with the value <code>10</code>, and the behavior would remain the same.</p> </li> <li> <p>Function Composition</p> <p>You can compose functions to combine their behavior. This is often done with <code>custom hooks</code> or by chaining functions.</p> <pre><code>const withUppercase = (WrappedComponent) =&gt; {\n  return (props) =&gt; (\n    &lt;WrappedComponent {...props} text={props.text.toUpperCase()} /&gt;\n  );\n};\n\nconst DisplayText = ({ text }) =&gt; &lt;p&gt;{text}&lt;/p&gt;;\n\nconst EnhancedDisplayText = withUppercase(DisplayText);\n\n// Usage\n&lt;EnhancedDisplayText text=\"hello world\" /&gt;;\n</code></pre> <p>Here, the <code>withUppercase</code> HOC composes a function to convert the text to uppercase before passing it down to the <code>DisplayText</code> component.</p> </li> <li> <p>Lazy Evaluation</p> <p>In React, you can achieve <code>lazy evaluation</code> by <code>lazily loading components</code>. This helps improve performance by only loading components when they're needed.</p> <pre><code>import React, { Suspense, lazy } from \"react\";\n\n// Lazy load the component\nconst LazyComponent = lazy(() =&gt; import(\"./LazyComponent\"));\n\nconst App = () =&gt; (\n  &lt;div&gt;\n    &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;\n      &lt;LazyComponent /&gt;\n    &lt;/Suspense&gt;\n  &lt;/div&gt;\n);\n</code></pre> <p>In this example, <code>LazyComponent</code> is loaded only when it's required (i.e., when it's rendered), which aligns with lazy evaluation.</p> </li> <li> <p>Declarative Style</p> <p>React is all about <code>declarative programming</code>. You describe what the UI should look like based on the state, and React takes care of updating the DOM accordingly.</p> <pre><code>const TodoList = ({ todos }) =&gt; (\n  &lt;ul&gt;\n    {todos.map((todo, index) =&gt; (\n      &lt;li key={index}&gt;{todo}&lt;/li&gt;\n    ))}\n  &lt;/ul&gt;\n);\n</code></pre> <p>Here, you're declaring the structure of the UI based on the <code>todos</code> array, and React handles rendering and updating the DOM.</p> </li> <li> <p>Avoidance of State and Side Effects</p> <p>React encourages using pure components (components that don\u2019t cause side effects) and managing side effects through React Hooks (<code>useEffect</code>).</p> <ul> <li> <p>You can isolate side effects in <code>useEffect</code>, making components predictable and easy to reason about.</p> <pre><code>import React, { useState, useEffect } from \"react\";\n\nconst Timer = () =&gt; {\n  const [seconds, setSeconds] = useState(0);\n\n  useEffect(() =&gt; {\n      const intervalId = setInterval(() =&gt; {\n          setSeconds((prev) =&gt; prev + 1);\n      }, 1000);\n\n     return () =&gt; clearInterval(intervalId); // Cleanup side effect on component unmount\n  }, []);\n\n  return &lt;div&gt;Time: {seconds}s&lt;/div&gt;;\n};\n</code></pre> <p>In this example, the side effect (interval timer) is handled in <code>useEffect</code>, and the effect is cleaned up when the component unmounts.</p> </li> </ul> </li> <li> <p>Recursion</p> <p>React components can use <code>recursion</code> for rendering nested structures, like trees or lists.</p> <pre><code>const Tree = ({ node }) =&gt; {\n  return (\n    &lt;div&gt;\n      &lt;p&gt;{node.name}&lt;/p&gt;\n      {node.children &amp;&amp; (\n        &lt;div style={{ marginLeft: 20 }}&gt;\n          {node.children.map((child, index) =&gt; (\n            &lt;Tree key={index} node={child} /&gt;\n          ))}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nconst data = {\n  name: \"Root\",\n  children: [\n    { name: \"Child 1\" },\n    { name: \"Child 2\", children: [{ name: \"Grandchild 1\" }] },\n  ],\n};\n\nconst App = () =&gt; &lt;Tree node={data} /&gt;;\n</code></pre> <p>This is an example of recursive rendering of a tree structure in React.</p> </li> <li> <p>Type Systems</p> <p>React is <code>dynamically typed</code>, but you can improve type safety by using <code>TypeScript</code> or <code>PropTypes</code>.</p> PropTypes<pre><code>import PropTypes from \"prop-types\";\n\nconst Greeting = ({ name }) =&gt; &lt;h1&gt;Hello, {name}!&lt;/h1&gt;;\n\nGreeting.propTypes = {\n  name: PropTypes.string.isRequired,\n};\n</code></pre> Example with TypeScript<pre><code>interface GreetingProps {\n  name: string;\n}\n\nconst Greeting = ({ name }: GreetingProps) =&gt; &lt;h1&gt;Hello, {name}!&lt;/h1&gt;;\n</code></pre> <p>In both examples, you're using types to ensure that the name <code>prop</code> is a string and is provided.</p> </li> </ol> <p>Summary</p> <p>While React is not a pure functional programming language, it encourages many functional programming principles, especially with the advent of function components and React Hooks. By writing <code>pure</code>, <code>declarative</code>, and <code>immutable code</code>, React developers can create applications that are easier to reason about and maintain, leveraging functional programming techniques where appropriate.</p>"},{"location":"frontend/js/intro/","title":"Intro","text":"<p>What\u2019s in a name?</p> <p>The name JavaScript was chosen to take advantage of the popularity of Java \u2013 just as a marketing ploy! Its first name was Mocha, then, LiveScript, and only then JavaScript.</p>"},{"location":"frontend/js/intro/#fp-and-other-programming-paradigms","title":"FP and other programming paradigms","text":"<p>Programming paradigms classify programming languages according to their features.</p> <p>However, some languages may be classified into multiple paradigms \u2013 as is the case of JavaScript itself!</p> <p>A primary division is imperative versus declarative languages. In the former, developers must instruct the machine on how to do its work, step by step.</p> <p>Programming may be procedural (if instructions are grouped into procedures) or object-oriented (if instructions are grouped with a related state).</p> <p>In declarative languages, in opposition, developers just declare properties that the sought result must satisfy, but not how to calculate it. Declarative languages may be logic-based (based on logic rules and constraints), reactive (based on data and event streams), or functional (based on the application and combination of functions).</p> <p>In a sense, we could say that imperative languages focus on how, while declarative languages focus on what.</p> <p>JavaScript is multi-paradigm: it\u2019s imperative (both procedural and object-oriented) but also allows declarative programming, both functional (like almost everything in this book! In particular, we will devote Chapter 5, Programming Declaratively, to this topic) and reactive (we\u2019ll see reactive FP in Chapter 11, Implementing Design Patterns).</p> <p></p>"},{"location":"frontend/js/intro/#reference","title":"Reference","text":"<ul> <li>Mastering JavaScript Functional Programming Third Edition by Federico Kereki</li> </ul>"},{"location":"frontend/js/advanced/maps-and-sets/","title":"Maps and Sets","text":""},{"location":"frontend/js/advanced/maps-and-sets/#maps-and-sets-the-new-data-structures-on-the-block","title":"Maps and Sets <code>\u2014 The New Data-structures on the Block</code>","text":""},{"location":"frontend/js/advanced/maps-and-sets/#reference","title":"Reference","text":"<ul> <li>JavaScript Next by Raju Gandhi, pg: 81</li> </ul>"},{"location":"frontend/js/advanced/promise/","title":"Promise","text":"<p>What is a Promise in JavaScript?</p> <p>A promise is a native JavaScript object that represents the eventual completion (or failure) of an asynchronous operation and its resulting value. Promises provide a way to handle asynchronous operations in a more manageable and cleaner manner compared to traditional callback-based approaches.</p>"},{"location":"frontend/js/advanced/promise/#history","title":"History","text":"<p>Promises were introduced to JavaScript as part of ECMAScript 2015 (ES6) to improve the way asynchronous operations are handled. They provide a more manageable way to deal with asynchronous code compared to traditional callback approaches, helping to avoid issues like callback hell.</p> <p>When Promises Were Introduced</p> <p>Promises were standardized in ECMAScript 2015 (ES6), which was officially released in June 2015. Before ES6, handling asynchronous operations was done using <code>callbacks</code>, which could lead to deeply nested and difficult-to-read code.</p>"},{"location":"frontend/js/advanced/promise/#key-concepts-of-promises","title":"Key Concepts of Promises","text":"States <ul> <li>Pending: The initial state, before the promise has been fulfilled or rejected.</li> <li>Fulfilled: The operation completed successfully, resulting in a value.</li> <li>Rejected: The operation failed, resulting in a reason (error).</li> </ul>"},{"location":"frontend/js/advanced/promise/#usage","title":"Usage","text":"<p>Do We Need to Use Promises Only for Asynchronous Data?</p> <p>While promises are commonly used for asynchronous operations, they can be used for any situation where you need to handle operations that may complete in the future, not just for asynchronous data fetching. However, their primary use case is for handling asynchronous operations like:</p> <ul> <li>Fetching data from a server</li> <li>Reading files (in Node.js)</li> <li>Timers and delays</li> </ul>"},{"location":"frontend/js/advanced/serialization/","title":"Serialization","text":""},{"location":"frontend/js/advanced/serialization/#serialization","title":"Serialization","text":""},{"location":"frontend/js/advanced/serialization/#question","title":"Question","text":"<p>why do we need to serailize to tranfer in http protocal? why does we can't transfers the direct object. what is the reason?\"</p> <p>Serialization is necessary to transfer objects over the HTTP protocol because HTTP is a text-based protocol that only understands text or binary data formats. Directly transferring an object as it exists in memory is not feasible due to several reasons:</p> Reasons for Serialization <ol> <li> <p>Incompatibility with HTTP Protocol: HTTP is designed to transfer data in text (ASCII or UTF-8) or binary format, not in the complex memory structures that objects are represented as within a running program.</p> </li> <li> <p>Language and Platform Independence: Serialization transforms objects into a standardized format that can be understood across different programming languages and platforms. Without serialization, the internal memory representation of an object in one language (e.g., Python) might not be understandable by another language (e.g., JavaScript).</p> </li> <li> <p>Security: Directly transferring raw memory data could expose sensitive information and increase the risk of security vulnerabilities. Serialization allows control over what data is included and how it is represented, enhancing security.</p> </li> <li> <p>Data Integrity and Structure: Serialization ensures that the data structure is preserved and can be accurately reconstructed. It converts complex objects into a structured format (like JSON or XML) that maintains the relationships between data fields.</p> </li> <li> <p>Efficiency and Performance: Serialized data can be optimized for transmission. Formats like JSON and Protocol Buffers are designed to be lightweight and efficient, reducing the amount of data transferred and improving performance.</p> </li> </ol> Why Direct Transfer of Objects is Not Feasible <ol> <li> <p>Memory Representation: Objects in memory contain pointers, memory addresses, and other metadata that are specific to the runtime environment. This low-level information is not meaningful outside the context of that environment.</p> </li> <li> <p>Endianness and Architecture Differences: Computers may have different endianness (byte order) and architecture (<code>32-bit</code> vs. <code>64-bit</code>), leading to differences in how data is stored in memory. Serialization abstracts these differences.</p> </li> <li> <p>Complex Object Graphs: Objects often reference other objects, creating complex graphs of interconnected data. Direct transfer would require duplicating the entire memory structure, which is impractical and error-prone.</p> </li> </ol> <p>Example</p>"},{"location":"frontend/js/advanced/serialization/#serialization-process","title":"Serialization Process","text":"<ol> <li> <p>Conversion to Text or Binary Format: The object is converted into a format like <code>JSON</code>, <code>XML</code>, or <code>Protocol Buffers</code>. This format represents the object's data in a standardized way.</p> </li> <li> <p>Transmission Over HTTP: The serialized data is included in the HTTP request or response body, allowing it to be transmitted over the network.</p> </li> <li> <p>Deserialization: On the receiving end, the data is converted back into an object, reconstructing the original data structure.</p> </li> </ol>"},{"location":"frontend/js/advanced/serialization/#example-of-serialization-and-transmission","title":"Example of Serialization and Transmission","text":""},{"location":"frontend/js/advanced/serialization/#json-serialization","title":"JSON Serialization","text":"Original Object (Python):<pre><code>user = {\"name\": \"Alice\", \"age\": 30, \"isMember\": True}\n</code></pre>"},{"location":"frontend/js/advanced/serialization/#serialized-json","title":"Serialized JSON:","text":"json<pre><code>{\n    \"name\": \"Alice\",\n    \"age\": 30,\n    \"isMember\": true\n}\n</code></pre>"},{"location":"frontend/js/advanced/serialization/#http-request","title":"HTTP Request:","text":"http<pre><code>POST /api/users HTTP/1.1\nHost: example.com\nContent-Type: application/json\n\n{\n    \"name\": \"Alice\",\n    \"age\": 30,\n    \"isMember\": true\n}\n</code></pre>"},{"location":"frontend/js/advanced/serialization/#deserialization-javascript","title":"Deserialization (JavaScript):","text":"javascript<pre><code>let user = JSON.parse('{\"name\": \"Alice\", \"age\": 30, \"isMember\": true}');\n</code></pre>"},{"location":"frontend/js/advanced/serialization/#conclusion","title":"Conclusion","text":"<p>Serialization is essential for transferring objects over the HTTP protocol because it converts objects into a text or binary format that is compatible with HTTP, ensures language and platform independence, and maintains data integrity and security. Direct transfer of objects is not feasible due to the complexity of memory representations and the need for standardized data formats.</p>"},{"location":"frontend/js/advanced/this-in-js/","title":"this","text":"<p>Understanding <code>this</code> in JavaScript: Context and Behavior Explained</p> <p>Understanding the <code>this</code> context in JavaScript can be a bit tricky, especially because it behaves differently in various situations.</p> <p>Let\u2019s break it down in simple terms.</p>"},{"location":"frontend/js/advanced/this-in-js/#what-is-this","title":"What is this?","text":"<p>In JavaScript, <code>this</code> refers to the object that is currently executing the code. It is a special keyword that changes depending on how a function is called.</p>"},{"location":"frontend/js/advanced/this-in-js/#how-this-works","title":"How this Works","text":"<p>The value of <code>this</code> depends on the context in which a function is invoked. Here\u2019s a basic guide to help understand it:</p> <ol> <li> <p>Global Context:</p> <ul> <li> <p>When <code>this</code> is used in the global scope (outside of any function), it refers to the global object. In a browser, this global object is window.</p> </li> <li> <p>In a browser, this global object is <code>window</code>.</p> </li> </ul> <pre><code>console.log(this); // In a browser, this logs the `window` object\n</code></pre> </li> <li> <p>Object Method:</p> <ul> <li>When <code>this</code> is used inside a method of an object, it refers to the object that the method is called on.</li> </ul> <pre><code>const obj = {\n    name: 'Alice',\n    greet: function() {\n        // `this` refers to `obj`, so it logs 'Alice'\n        console.log(this.name);\n    }\n};\n\nobj.greet();\n</code></pre> </li> <li> <p>Constructor Function:</p> <ul> <li>When <code>this</code> is used inside a constructor function (a function meant to create objects), it refers to the newly created object.</li> </ul> <pre><code>function Person(name) {\n    this.name = name;\n}\n\nconst alice = new Person('Alice');\nconsole.log(alice.name); // Logs 'Alice'\n</code></pre> </li> <li> <p>Event Handlers:</p> <ul> <li>In event handlers, <code>this</code> refers to the element that the event handler is attached to.</li> </ul> <pre><code>document.querySelector('button').addEventListener('click', function() {\n    console.log(this); // Logs the button element\n});\n</code></pre> </li> <li> <p>Arrow Functions:</p> <ul> <li>Arrow functions do not have their own <code>this</code>. Instead, they inherit <code>this</code> from the surrounding (lexical) context where they were defined. This is known as lexical scoping.</li> </ul> <pre><code>const obj = {\n    name: 'Alice',\n    greet: function() {\n        const innerFunction = () =&gt; {\n            // `this` refers to `obj`, because arrow function inherits `this` from `greet`\n            console.log(this.name);\n        };\n        innerFunction();\n    }\n};\n\nobj.greet(); // Logs 'Alice'\n</code></pre> </li> </ol>"},{"location":"frontend/js/advanced/this-in-js/#why-this-isnt-the-same-for-all","title":"Why <code>this</code> Isn\u2019t the Same for All","text":"<p>The behavior of <code>this</code> is designed to be flexible to accommodate different use cases in JavaScript. However, this flexibility can lead to confusion:</p> <ul> <li> <p>Dynamic Binding: <code>this</code> is dynamically bound based on how a function is called. This allows functions to operate on different objects depending on the context, but can make it hard to predict what <code>this</code> refers to without understanding the call site.</p> </li> <li> <p>Arrow Functions: Arrow functions were introduced to simplify the handling of <code>this</code> by lexically binding <code>this</code>, meaning they use the <code>this</code> value from where they were created, rather than where they are executed.</p> </li> </ul>"},{"location":"frontend/js/advanced/this-in-js/#summary","title":"Summary","text":"<ul> <li>Global Context: <code>this</code> refers to the global object (e.g., window in browsers).</li> <li>Object Method: <code>this</code> refers to the object the method is called on.</li> <li>Constructor Function: <code>this</code> refers to the newly created instance.</li> <li>Event Handlers: <code>this</code> refers to the element that triggered the event.</li> <li>Arrow Functions: <code>this</code> is inherited from the surrounding context, not dynamically bound.</li> </ul> <p>Understanding <code>this</code> involves recognizing how functions are called and how <code>this</code> is set based on these contexts. It\u2019s a core part of JavaScript\u2019s flexible function behavior but requires careful consideration to use effectively.</p>"},{"location":"frontend/js/advanced/reducer/intro/","title":"Intro","text":""},{"location":"frontend/js/advanced/reducer/intro/#overview","title":"Overview","text":"<p>In JavaScript, the concept of a reducer often comes into play when working with state management, particularly in functional programming and libraries like <code>Redux</code> or when using the <code>Array.prototype.reduce()</code> method.</p>"},{"location":"frontend/js/advanced/reducer/intro/#1-what-is-a-reducer","title":"1. What is a Reducer?","text":"<p>A reducer is a function that takes in two arguments: the current state and an action (or data), and then returns a new state based on that input. The key here is that a reducer function is pure, meaning it doesn\u2019t modify the original state but instead returns a new state.</p> <p>In the context of <code>React</code>, <code>Redux</code>, or other state management systems, a reducer is used to handle state updates based on different actions or events.</p>"},{"location":"frontend/js/advanced/reducer/intro/#2-when-to-use-a-reducer","title":"2. When to Use a Reducer?","text":"<p>You use a reducer when you need to handle changes to a state over time, especially when the state is complex or when there are different types of actions that need to modify the state in different ways.</p> <p>For example:</p> <ul> <li>When you're building a state management system (like Redux in React).</li> <li>When you need to perform updates on an array or object based on different operations (adding, removing, modifying items).</li> <li>When your state needs to be modified based on multiple conditions or events.</li> </ul>"},{"location":"frontend/js/advanced/reducer/intro/#3-how-to-use-a-reducer-in-javascript","title":"3. How to Use a Reducer in JavaScript?","text":""},{"location":"frontend/js/advanced/reducer/intro/#using-arrayprototypereduce","title":"Using <code>Array.prototype.reduce()</code>","text":"<p>In JavaScript, the <code>reduce()</code> method allows you to accumulate a value (like a sum, or a transformed array) by iterating over an array and applying a reducer function.</p> Syntax<pre><code>array.reduce((accumulator, currentValue) =&gt; {\n  // your logic here\n  return newAccumulator;\n}, initialValue);\n</code></pre> <ul> <li>accumulator: The value that accumulates the result (e.g., sum, object, etc.).</li> <li>currentValue: The current item in the array being processed.</li> <li>initialValue: An optional initial value for the accumulator.</li> </ul> Example<pre><code>// Summing numbers in an array\nconst numbers = [1, 2, 3, 4, 5];\n\nconst sum = numbers.reduce((acc, curr) =&gt; acc + curr, 0);\n\nconsole.log(sum); // Output: 15\n</code></pre>"},{"location":"frontend/js/advanced/reducer/intro/#using-reducers-in-react-or-redux","title":"Using Reducers in React (or Redux)","text":"<p>In React (with Redux, for example), a reducer function is typically used to manage the application state by responding to different action types. The reducer returns a new state object based on the action type.</p> ExampleExplanation <pre><code>// Initial state\nconst initialState = {\n    count: 0,\n    user: null,\n};\n\n// Reducer function\nfunction reducer(state = initialState, action) {\n    switch (action.type) {\n        case \"INCREMENT\":\n            return { ...state, count: state.count + 1 };\n        case \"DECREMENT\":\n            return { ...state, count: state.count - 1 };\n        case \"SET_USER\":\n            return { ...state, user: action.payload };\n        default:\n            return state;\n    }\n}\n</code></pre> <ul> <li>The reducer function handles three different types of actions: increment, decrement, and set user.</li> <li>The state is immutable: a new state is returned on each action.</li> </ul> Example in a Redux Store<pre><code>import { createStore } from \"redux\";\n\n// The same reducer from above\nconst store = createStore(reducer);\n\n// Dispatching actions\nstore.dispatch({ type: \"INCREMENT\" });\nconsole.log(store.getState()); // { count: 1, user: null }\n\nstore.dispatch({ type: \"SET_USER\", payload: { name: \"John Doe\" } });\nconsole.log(store.getState()); // { count: 1, user: { name: 'John Doe' } }\n</code></pre>"},{"location":"frontend/js/advanced/reducer/intro/#4-why-do-we-need-a-reducer","title":"4. Why Do We Need a Reducer?","text":"<p>Reducers help you manage and update application state in a predictable and maintainable way. Here\u2019s why they are useful:</p> <ul> <li>Predictability: Reducers ensure that state transitions happen in a consistent and predictable manner, which is especially important when your app grows in complexity.</li> <li>Immutability: By always returning a new state rather than mutating the old state, reducers help maintain immutability, which reduces bugs and makes your code easier to reason about.</li> <li>Separation of concerns: Reducers allow you to isolate how state is updated based on specific actions, making your application logic more modular and easier to test.</li> <li>Composability: Reducers can be combined (using functions like <code>combineReducers</code> in Redux), allowing you to manage complex states in a modular way.</li> </ul>"},{"location":"frontend/js/advanced/reducer/intro/#5-summary","title":"5. Summary:","text":"<ul> <li>Reducer is a function that takes in state and an action, and returns a new state.</li> <li>Use a reducer when you need to manage complex or mutable state, especially with actions that modify the state in different ways.</li> <li>In JavaScript, reducers are often used with <code>reduce()</code> for arrays or in state management libraries (like Redux in React).</li> <li>Why use it? Reducers provide predictable state transitions, maintain immutability, allow modular code, and ensure that application state updates are traceable and easy to manage.</li> </ul>"},{"location":"frontend/js/advanced/reducer/intro/#additional","title":"Additional","text":"<p>In JavaScript and React, the concept of a \"reducer\" primarily comes from Redux, a popular state management library. It is a key part of managing and updating application state in a predictable way.</p>"},{"location":"frontend/js/advanced/reducer/intro/#reducer-in-javascript","title":"Reducer in JavaScript","text":"<p>A reducer is a function that takes the current state of an application and an action, and returns a new state based on that action. It follows a predictable pattern for managing state updates.</p> Syntax of a Reducer<pre><code>function reducer(state, action) {\n  switch (action.type) {\n    case \"ACTION_TYPE_1\":\n      return { ...state, someProperty: action.payload };\n    case \"ACTION_TYPE_2\":\n      return { ...state, anotherProperty: action.payload };\n    default:\n      return state;\n  }\n}\n</code></pre> <ul> <li>state: The current state of the application or the specific part of the state that this reducer manages.</li> <li>action: An object describing the change, typically containing a <code>type</code> field (to describe the action) and optionally a <code>payload</code> field (to pass additional data).</li> </ul> <p>In the context of React and Redux, this function does not mutate the original state directly; instead, it returns a new state.</p>"},{"location":"frontend/js/advanced/reducer/intro/#reducer-pattern-in-react-and-redux","title":"Reducer Pattern in React and Redux","text":"<p>The Reducer pattern in Redux (and by extension, React) is a way to manage state using pure functions. The pattern is inspired by the reduce function in functional programming, which applies a series of transformations to an initial value.</p> <ul> <li>State is treated as an immutable object, and actions trigger changes to the state.</li> <li>The reducer pattern helps in keeping state transitions predictable and traceable.</li> </ul> Example in Redux <p>Here is a simple Redux-like example to illustrate the reducer pattern:</p> <pre><code>// Initial state\nconst initialState = {\n    count: 0,\n};\n\n// Reducer function\nfunction counterReducer(state = initialState, action) {\n    switch (action.type) {\n        case \"INCREMENT\":\n            return { ...state, count: state.count + 1 };\n        case \"DECREMENT\":\n            return { ...state, count: state.count - 1 };\n        default:\n            return state;\n    }\n}\n\n// Example actions\nconst incrementAction = { type: \"INCREMENT\" };\nconst decrementAction = { type: \"DECREMENT\" };\n\n// Using the reducer to update state\nlet state = counterReducer(undefined, incrementAction); // { count: 1 }\nstate = counterReducer(state, decrementAction); // { count: 0 }\n</code></pre>"},{"location":"frontend/js/advanced/reducer/intro/#how-it-works-in-react-with-usereducer","title":"How it works in React with <code>useReducer</code>","text":"<p>In React, you can use the <code>useReducer</code> hook, which is a way to manage local component state in a manner similar to how Redux works. <code>useReducer</code> is typically used when state logic is complex (e.g., involves multiple sub-values or conditions).</p> ExampleExplanation <pre><code>import React, { useReducer } from \"react\";\n\n// Initial state\nconst initialState = { count: 0 };\n\n// Reducer function\nfunction counterReducer(state, action) {\n    switch (action.type) {\n        case \"INCREMENT\":\n            return { ...state, count: state.count + 1 };\n        case \"DECREMENT\":\n            return { ...state, count: state.count - 1 };\n        default:\n            return state;\n    }\n}\n\nfunction Counter() {\n    const [state, dispatch] = useReducer(counterReducer, initialState);\n\n    return (\n        &lt;div&gt;\n            &lt;p&gt;Count: {state.count}&lt;/p&gt;\n            &lt;button onClick={() =&gt; dispatch({ type: \"INCREMENT\" })}&gt;Increment&lt;/button&gt;\n            &lt;button onClick={() =&gt; dispatch({ type: \"DECREMENT\" })}&gt;Decrement&lt;/button&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default Counter;\n</code></pre> <p><code>useReducer</code> returns two values:</p> <ul> <li><code>state</code>: The current state.</li> <li><code>dispatch</code>: A function that allows you to send actions to the reducer.</li> </ul>"},{"location":"frontend/js/advanced/reducer/intro/#key-characteristics-of-the-reducer-pattern","title":"Key Characteristics of the Reducer Pattern","text":"<ol> <li> <p>Pure Function: A reducer is a pure function that depends solely on its inputs (current state and action). It does not have side effects, and it returns a new state without modifying the existing one.</p> </li> <li> <p>Immutability: Reducers should not mutate the existing state. Instead, they return a new state object, which is a copy of the old one with the necessary updates.</p> </li> <li> <p>State Transition: The reducer determines how the state changes in response to different actions, keeping the application\u2019s state transition predictable.</p> </li> <li> <p>Centralized State Management: In libraries like Redux, the reducer pattern is used to maintain a centralized state, making it easier to manage, debug, and test application state.</p> </li> </ol>"},{"location":"frontend/js/advanced/reducer/intro/#when-to-use-a-reducer","title":"When to Use a Reducer","text":"<ul> <li> <p>Complex State: Use a reducer when your state management logic is too complex for simple <code>useState</code> or <code>setState</code>. For example, when you need to manage multiple variables that depend on each other or when you need to handle different actions for updating state.</p> </li> <li> <p>Predictability and Debugging: Since reducers are pure functions, the state transitions are predictable and easier to debug, especially when combined with tools like Redux DevTools.</p> </li> </ul>"},{"location":"frontend/js/advanced/reducer/intro/#conclusion","title":"Conclusion","text":"<p>The reducer pattern is a fundamental concept in JavaScript, particularly in state management with Redux and React's <code>useReducer</code>. It provides a structured and predictable way to manage complex state transitions by using pure functions to handle state changes based on dispatched actions. While Redux popularized the reducer pattern, React's <code>useReducer</code> allows you to use this pattern in local component state as well.</p>"},{"location":"frontend/js/advanced/reducer/intro/#reference","title":"Reference","text":"<ul> <li>Reducers in JavaScript</li> </ul>"},{"location":"frontend/js/advanced/reducer/syntax/","title":"Syntax","text":""},{"location":"frontend/js/advanced/reducer/syntax/#example","title":"Example","text":""},{"location":"frontend/js/advanced/reducer/syntax/#additional","title":"Additional","text":""},{"location":"frontend/js/advanced/reducer/syntax/#reference","title":"Reference","text":"<ul> <li>Reducers in JavaScript</li> <li>Understanding React Reducer in JavaScript for State Management</li> <li>The State Reducer Pattern with React Hooks</li> <li>JavaScript Reducer (origin React/Redux)</li> <li>Redux Ducks: Restructure your Redux App with Ducks</li> <li>Understanding Reducers in JavaScript</li> </ul>"},{"location":"frontend/js/convention/coercion/","title":"Coercion","text":"<p>In JavaScript, there are three components of the language that especially lend themselves to the creation of jargon:</p> <ol> <li>coercion,</li> <li>logical operators, &amp;</li> <li>bitwise manipulations (pejoratively known as bit twiddling.)</li> </ol>"},{"location":"frontend/js/convention/coercion/#coercion","title":"Coercion","text":"<p>In JavaScript as in most other languages, coercion is the act of forcing an object or entity of one type into another. This is not to be confused with type conversion, which is the explicit transformation between types. In JavaScript, explicit type conversion would look like this:</p> <pre><code>// =&gt; \"1\"\nvar a = (1).toString();\nconsole.log(a);\n\n// However, the number can also be implicitly coerced into a string this way:\n// =&gt; \"1\"\nvar a = 1 + \"\";\nconsole.log(a);\n</code></pre>"},{"location":"frontend/js/convention/intro/","title":"Intro","text":"<p>Convention</p>"},{"location":"frontend/js/convention/intro/#reference","title":"Reference","text":"<ul> <li>9 Most Useful JavaScript Style Guides To Write Better Code</li> </ul>"},{"location":"frontend/js/convention/js-style-guide/","title":"Style","text":""},{"location":"frontend/js/convention/js-style-guide/#javascript-style-guide","title":"JavaScript Style Guide","text":"<p>Style guides are just that, guides. They are meant to point you in the right direction, but they are, at best, a mutable truth. Coding theory changes constantly and it is important not to lock yourself into a dogmatic approach to the application of these rules.</p>"},{"location":"frontend/js/convention/js-style-guide/#rules-for-visual-clarity","title":"Rules for Visual Clarity","text":"<ul> <li> <p>Write clearly and expressively: While thinking about good guidelines for visual clarity in your code, it\u2019s important to keep this rule in mind. When naming variables and functions, or organizing code, remember that you are writing for humans, not compilers.</p> </li> <li> <p>Follow existing conventions: If you work on a team or are hired to write code, you are not writing for yourself. Therefore, you should conform your style to co-exist in the existing ecosystem, but without sacrificing quality.</p> </li> <li> <p>Write in only one language: Where possible, don\u2019t use JavaScript as a transport for other languages. This means resisting the urge to write inline HTML or CSS. Clear code enforces a separation of concerns.</p> </li> <li> <p>Enforce a uniform column width: Strive for consistent line lengths in source code. Long lines tire the eyes, which reduces comprehension. Long lines also cause needless horizontal scrolling. An industry standard is 80 characters per line.</p> </li> </ul>"},{"location":"frontend/js/convention/js-style-guide/#document-formatting","title":"Document Formatting","text":"<p>Understanding a program\u2019s source often requires the reader to mentally compile the code. This process needs sustained focus from readers, and any distraction can eject readers from their mental flow. Improperly or inconsistently formatted sources act as visual noise to the source\u2019s signal. This section offers conventions and guides that allows the formatting to support the source instead of weighing it down.</p>"},{"location":"frontend/js/convention/js-style-guide/#rules-for-computational-effectiveness","title":"Rules for Computational Effectiveness","text":"<p>Computational effectiveness is important to consider as well as visual clarity. Keep the following examples in mind:</p> <ul> <li> <p>Write for concatenation: Modern applications often munge the JavaScript source into a streamlined file for production. You should defensively program your scripts to protect from switches in operation context and scope corruption.</p> </li> <li> <p>Keep your code browser agnostic: Keep your business logic free of browser-specific code by abstracting them into interfaces. This will keep your code on a clean upgrade path as browsers fall in and out of fashion.</p> </li> <li> <p>Resist the use of <code>eval()</code>: It can often be an injection point for malicious code execution.</p> </li> <li> <p>Resist the use of <code>with()</code>: It can make the implications of the code hard to understand.</p> </li> <li> <p>Keep prototype pristine: Never modify the prototype of a built-in such as Array.prototype because it can silently break other\u2019s code, which expects standard behavior.</p> </li> </ul>"},{"location":"frontend/js/convention/js-style-guide/#equality-comparisons-and-conditional-evaluation","title":"Equality Comparisons and Conditional Evaluation","text":"<p>Use <code>===</code> instead of <code>==</code> and use <code>!==</code> instead of <code>!=</code> because the dynamic nature of JavaScript means that it is sometimes overly loose when testing equality. When just testing for \u201ctruthiness,\u201d you can coerce the values:</p> <p>Function Expressions</p> <p>Function expressions are function objects that are linked to variables. As such, they can be written more ways than a function declaration:</p> <pre><code>// Anonymous Function\nvar anon = function () {\n  return true;\n};\n\n// Named Function\nvar named = function named() {\n  return true;\n};\n\n// Immediately-invoked function, hides its contents from the executing scope.\n(function main() {\n  return true;\n})();\n</code></pre> <p>Function expressions are defined at parse-time. Therefore, do not have their names hoisted to the top of the scope. However, function expressions are preferred over function declarations because of certain bugs in older browsers.</p> <pre><code>// Bad - Runtime Error\niGoBoom();\nvar iGoBoom = function () {\n  alert(\"boom\");\n};\n\n// Good\niGoBoom();\nfunction iGoBoom() {\n  alert(\"boom\");\n}\n</code></pre> <p>Do not use function declarations within block statements; they are not part of ECMAScript. Use a function expression instead:</p> <pre><code>// Bad\nif (ball.is(round)) {\n  function bounce() {\n    // Statements Continue\n  }\n  return bounce();\n}\n\n// Good\nif (ball.is(round)) {\n  var bounce = function () {\n    // Statements Continue\n  };\n}\n</code></pre> <p>Do not hide the native arguments object by using the same name in a function:</p> <pre><code>// Bad\nvar foo = function (arguments) {\n  alert(arguments.join(\" \"));\n};\n\n// Good\nvar foo = function (args) {\n  alert(args.join(\" \"));\n};\n</code></pre> <p>Coercion</p> <p>Use explicit conversion over implicit coercion because it makes the code base more declarative:</p> <pre><code>var num = \"1\";\n// Bad implicit coercion\nnum = +num;\n// Good expressive conversion\nnum = Number(num);\n</code></pre>"},{"location":"frontend/js/convention/naming-convention/","title":"Naming Covention","text":"<p>JavaScript is a terse language of brackets numbers and letters. One of the only ways to make your code expressive to humans is through naming your variables, functions, and properties meaningfully. When choosing a name, it should describe the role and responsibilities of that object. Using vague or obtuse names such as doStuff or item1 is like telling the reader to figure it out, which they often won\u2019t</p> <p>Choose variables and functions with meaningful, expressive, and descriptive names. Write for the reader, not the compiler.</p> <pre><code>// Bad\nvar a = 1,\n  aa = function (aaa) {\n    return \"\" + aaa;\n  };\n\n// Good\nvar count = 1,\n  toString = function (num) {\n    return \"\" + num;\n  };\n</code></pre>"},{"location":"frontend/js/convention/naming-convention/#constants","title":"Constants","text":"<p>Constant should be written in uppercase with spaces replaced with underscores.</p> <pre><code>// Bad\nMEANING_OF_LIFE = 43;\n\n// Good\nconst MEANING_OF_LIFE = 43;\n\n// Good\ncom.humansized.MEANING_OF_LIFE = 42;\n\n// Good\nMath.PI;\n</code></pre>"},{"location":"frontend/js/convention/naming-convention/#additional-naming-conventions","title":"Additional Naming Conventions","text":"<p>Variables should be CamelCase:</p> <pre><code>myVariableName;\n</code></pre> <p>Classes should be PascalCase:</p> <pre><code>MyAwesomeClass;\n</code></pre> <p>Functions should be CamelCase:</p> <pre><code>isLie(cake);\n</code></pre> <p>Namespaces should be CamelCase and use periods as delimiters:</p> <pre><code>com.site.namespace;\n</code></pre> <ul> <li>JavaScript Recipes: A Problem-Solution Approach by Russ Ferguson, Keith Cirkel - pg: 133</li> </ul>"},{"location":"frontend/js/core/callback/","title":"Callbacks","text":"<p>A callback function in JavaScript is a fundamental concept that plays a crucial role in handling asynchronous operations and implementing flexible code. Let\u2019s break down everything from the basics to advanced usage.</p>"},{"location":"frontend/js/core/closure/","title":"Closure","text":"<p>One of the most important concepts to learn in JavaScript is closures. Mastering closures is key to understanding many advanced JavaScript concepts such as:</p> <ol> <li> <p>Callbacks and Higher-Order Functions: Functions that return or take other functions as arguments rely heavily on closures. This is foundational for asynchronous programming, event handling, and functional programming.</p> </li> <li> <p>Lexical Scope: Closures are based on how JavaScript handles variable scoping, which is essential when writing modular, reusable code.</p> </li> <li> <p>Modules and Data Privacy: Understanding closures allows you to create private variables and implement encapsulation, which is crucial in creating well-structured, maintainable code.</p> </li> <li> <p>Asynchronous JavaScript (Promises, async/await): Closure helps in managing the state in asynchronous functions, avoiding side effects, and managing async callbacks.</p> </li> </ol> <p>By mastering closures, you'll gain a deeper understanding of how JavaScript handles function scopes, which is foundational for mastering more advanced concepts such as functional programming, asynchronous patterns, and JavaScript frameworks like React.</p> <p>A closure in JavaScript occurs when an inner function has access to the variables from its outer function, even after the outer function has finished executing. Let's break this down with an example and dive into when and why we use closures.</p> Basic ExampleHow It Works <pre><code>function outerFunction() {\n    let outerVariable = \"I am from the outer function\";\n\n    function innerFunction() {\n        console.log(outerVariable); // Accesses outerVariable from outerFunction\n    }\n\n    return innerFunction; // Return innerFunction to be used outside\n}\n\nconst closure = outerFunction(); // outerFunction is called, and it returns innerFunction\nclosure(); // Calls innerFunction, which still has access to outerVariable\n</code></pre> <ul> <li><code>outerFunction()</code> declares a variable <code>outerVariable</code> and an inner function <code>innerFunction()</code> that uses it.</li> <li><code>outerFunction()</code> returns <code>innerFunction()</code> to the outer scope.</li> <li>When <code>closure()</code> is called, even though <code>outerFunction()</code> has finished execution, <code>innerFunction()</code> still has access to <code>outerVariable</code> because of closure. The JavaScript engine remembers the scope in which <code>innerFunction()</code> was created.</li> </ul>"},{"location":"frontend/js/core/closure/#when-to-use-closures","title":"When to Use Closures","text":"<ol> <li> <p>Encapsulation / Data Privacy:</p> <p>Closures can help you create private variables that can't be accessed from outside a function.</p> <pre><code>function counter() {\n    let count = 0;\n\n    return function () {\n        count++; // count persists in memory due to closure\n        console.log(count);\n    };\n}\n\nconst increment = counter();\nincrement(); // 1\nincrement(); // 2\nincrement(); // 3\n</code></pre> <p>Here, the <code>count</code> variable is protected and can't be directly modified from outside. It can only be incremented via the returned function.</p> </li> <li> <p>Maintaining State in Asynchronous Programming:</p> <p>Closures are useful when working with asynchronous callbacks, as they maintain the state between calls.</p> <pre><code>function fetchData() {\n    const data = \"Loaded data\"; // Imagine this is fetched from an API\n\n    setTimeout(function () {\n        console.log(data); // Accesses data even after fetchData execution is done\n    }, 1000);\n}\n\nfetchData();\n</code></pre> </li> <li> <p>Function Factories:</p> <p>You can use closures to create functions dynamically based on the outer scope.</p> <pre><code>function createMultiplier(multiplier) {\n    return function (num) {\n        return num * multiplier;\n    };\n}\n\nconst double = createMultiplier(2);\nconst triple = createMultiplier(3);\n\nconsole.log(double(5)); // 10\nconsole.log(triple(5)); // 15\n</code></pre> </li> </ol>"},{"location":"frontend/js/core/closure/#why-do-we-need-closures","title":"Why Do We Need Closures?","text":"<ol> <li> <p>Data Persistence: Closures allow functions to remember the environment in which they were created. This is helpful for maintaining state, encapsulating data, or working with asynchronous code.</p> </li> <li> <p>Avoiding Global Variables: Without closures, you may resort to using global variables to retain state, which can lead to bugs and harder-to-maintain code.</p> </li> <li> <p>Higher-Order Functions &amp; Functional Programming: Closures enable more flexible, modular code by returning and passing around functions that remember their environments.</p> </li> </ol>"},{"location":"frontend/js/core/closure/#what-happens-if-we-dont-use-closures","title":"What Happens if We Don\u2019t Use Closures?","text":"<ul> <li> <p>No Encapsulation: Without closures, variables in outer functions would be inaccessible after those functions complete. You might have to use global variables, which is generally discouraged because they can lead to name conflicts and side effects in larger codebases.</p> </li> <li> <p>Loss of State: In asynchronous code, you'd lose the ability to persist data from the original function context, leading to more complex and less maintainable code.</p> </li> <li> <p>Functional Programming Limitations: You won't be able to effectively use function factories or higher-order functions, which are key to writing clean, functional JavaScript code.</p> </li> </ul> <p>Closures are a powerful tool that help in creating more modular, reusable, and maintainable code. They are especially useful in real-world scenarios like managing state in asynchronous calls, avoiding global variables, and creating private data.</p>"},{"location":"frontend/js/core/closure/#real-world-examples-of-closures-in-javascript-and-react","title":"Real-World Examples of Closures in JavaScript and React","text":"<p>Closures are widely used in JavaScript libraries, packages, and frameworks like React. Below are examples of how closures are applied in real-world scenarios.</p> <ol> <li> <p>Using Closures in JavaScript (Debouncing Example)</p> <p>In web development, debouncing is a technique used to limit the rate at which a function gets invoked. For example, when handling user input, we may want to delay execution of a function until the user stops typing.</p> ExampleExplanation <pre><code>function debounce(func, delay) {\n    let timeout;\n\n    return function(...args) {\n        const context = this;\n        clearTimeout(timeout);\n        timeout = setTimeout(() =&gt; func.apply(context, args), delay);\n    };\n}\n\n// Usage: Debouncing a search function\nconst searchInput = document.getElementById(\"search\");\n\nsearchInput.addEventListener(\"input\", debounce(function (event) {\n    console.log(\"Search query:\", event.target.value);\n}, 300));\n</code></pre> <p>How Closures Work Here:</p> <ul> <li><code>debounce()</code> returns a function that remembers the <code>timeout</code> variable from the outer function, ensuring that only the latest function call is executed after a delay.</li> <li>The inner function maintains access to the outer function's <code>timeout</code> variable across multiple calls, which is crucial to implement debouncing.</li> </ul> <p>Why It's Useful:</p> <p>Without closures, you'd need to manage the <code>timeout</code> variable globally or in another external scope, which would complicate the code and lead to potential bugs.</p> </li> <li> <p>Using Closures in React (State Management with <code>useState</code> Hook)</p> <p>React's <code>useState</code> hook indirectly relies on closures to preserve the component's state across renders. Closures help to keep the state within the scope of the functional component.</p> ExampleExplanation <pre><code>import React, { useState } from \"react\";\n\nfunction Counter() {\n    const [count, setCount] = useState(0);\n\n    function increment() {\n        setCount((prevCount) =&gt; prevCount + 1); // Closure retains access to prevCount\n    }\n\n    return (\n        &lt;div&gt;\n            &lt;p&gt;Count: {count}&lt;/p&gt;\n            &lt;button onClick={increment}&gt;Increment&lt;/button&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default Counter;\n</code></pre> <p>How Closures Work Here:</p> <ul> <li>The <code>setCount</code> function receives the current state (<code>prevCount</code>) and returns an updated state.</li> <li>Even though the <code>increment</code> function is executed on each re-render, the closure allows it to access the most recent <code>count</code> state value, thanks to the way React re-renders components and preserves state with hooks.</li> </ul> <p>Why It's Useful:</p> <p>Without closures, managing state updates in React would require much more manual work, such as handling global state or keeping track of the previous state explicitly.</p> </li> <li> <p>Using Closures in Redux Thunk (Handling Asynchronous Logic in Redux)</p> <p>In Redux, middleware like Redux Thunk uses closures to delay the dispatch of actions until after some asynchronous logic (e.g., API calls) has been completed.</p> ExampleExplanation <pre><code>// Action creator using Redux Thunk\nfunction fetchUserData(userId) {\n    return function (dispatch, getState) {\n        // Closure over dispatch and getState\n        dispatch({ type: \"FETCH_USER_REQUEST\" });\n\n        fetch(`/api/user/${userId}`)\n            .then(response =&gt; response.json())\n            .then(data =&gt; {\n                dispatch({ type: \"FETCH_USER_SUCCESS\", payload: data });\n            })\n        .catch(error =&gt; {\n            dispatch({ type: \"FETCH_USER_FAILURE\", error });\n        });\n    };\n}\n</code></pre> <p>How Closures Work Here:</p> <ul> <li>The returned function is a closure that maintains access to the <code>dispatch</code> and <code>getState</code> functions.</li> <li>Even after the outer action creator finishes executing, the inner function can still call <code>dispatch()</code> and interact with Redux's state and actions.</li> </ul> <p>Why It's Useful:</p> <p>Without closures, you\u2019d lose access to the <code>dispatch</code> and <code>getState</code> methods once the asynchronous call begins, and managing side effects like API calls would become more difficult and less clean.</p> </li> <li> <p>Custom Hook in React Using Closure</p> <p>React developers often write custom hooks to abstract complex logic. These hooks use closures to encapsulate state and behavior, providing reusable logic across components.</p> ExampleExplanation <pre><code>import { useState, useEffect } from 'react';\n\n// A custom hook that uses closure to encapsulate timer functionality\nfunction useTimer() {\n    const [seconds, setSeconds] = useState(0);\n\n    useEffect(() =&gt; {\n        const intervalId = setInterval(() =&gt; {\n            setSeconds((prevSeconds) =&gt; prevSeconds + 1); // Closure remembers previous seconds\n        }, 1000);\n\n        return () =&gt; clearInterval(intervalId);\n    }, []);\n\n    return seconds;\n}\n\n// Usage of the custom hook\nfunction TimerComponent() {\n    const secondsElapsed = useTimer();\n\n    return &lt;div&gt;Time Elapsed: {secondsElapsed} seconds&lt;/div&gt;;\n}\n</code></pre> <p>How Closures Work Here:</p> <ul> <li>The <code>setSeconds</code> function uses a closure to remember and update the previous state (<code>prevSeconds</code>) at each interval.</li> <li>The <code>useEffect</code> hook ensures that the interval runs in the background, while the closure inside <code>setSeconds</code> allows access to the most recent value of <code>seconds</code>.</li> </ul> <p>Why It's Useful:</p> <p>Without closures, updating the <code>seconds</code> state would require a more cumbersome manual approach, and the <code>useEffect</code> wouldn't be able to access the component's most recent state.</p> </li> <li> <p>Handling Event Listeners (A Closure Example in Vanilla JS)</p> <p>Event listeners often make use of closures to maintain access to the environment in which they were created.</p> ExampleExplanation <pre><code>function createEventListener(elementId, message) {\n    const element = document.getElementById(elementId);\n\n    element.addEventListener(\"click\", function () {\n        console.log(message); // Closure retains access to `message`\n    });\n}\n\ncreateEventListener(\"myButton\", \"Button was clicked!\");\n</code></pre> <p>How Closures Work Here:</p> <ul> <li>The event listener's callback function retains access to the <code>message</code> variable, even after <code>createEventListener</code> finishes execution.</li> <li>Each time the button is clicked, the inner function can still access the message it was created with.</li> </ul> <p>Why It's Useful:</p> <p>Without closures, you'd have to pass the <code>message</code> directly into the event listener at the time of the click, which would reduce the flexibility of the code.</p> </li> </ol>"},{"location":"frontend/js/core/closure/#conclusion","title":"Conclusion","text":"<p>Closures are crucial in JavaScript for:</p> <ul> <li>Encapsulating logic (as seen in the <code>debounce</code> function or custom React hooks).</li> <li>Preserving state (e.g., React's <code>useState</code> or Redux Thunk's asynchronous actions).</li> <li>Enabling modular, reusable code by maintaining access to outer variables long after the outer function has executed.</li> </ul> <p>Without closures, maintaining state and reusability would become significantly more challenging, leading to more complex, less efficient code.</p>"},{"location":"frontend/js/core/control-statement/","title":"Control Statement","text":"<p>Control statements in JavaScript allow you to control the flow of execution within your programs. They enable you to make decisions, iterate over collections, and manage complex logical operations. Here are the main control statements in JavaScript:</p> <p>Tip</p> <ul> <li>Conditional Statements: <code>if</code>, <code>if...else</code>, <code>if...else if...else</code>, <code>switch</code>.</li> <li>Looping Statements: <code>for</code>, <code>while</code>, <code>do...while</code>.</li> <li>Jump Statements: <code>break</code>, <code>continue</code>, <code>return</code>.</li> <li>Exception Handling Statements: <code>try...catch</code>, <code>try...catch...finally</code>, <code>throw</code>.</li> </ul> Looping an Array &amp; Object Looping an ArrayLooping through an Object <ol> <li> <p><code>for</code> loop:</p> <ul> <li>Does not return a new array.</li> <li> <p>It is simply a control flow statement.</p> <pre><code>const array = [1, 2, 3, 4, 5];\n\nfor (let i = 0; i &lt; array.length; i++) {\n    console.log(array[i]);\n}\n</code></pre> </li> </ul> </li> <li> <p><code>for...of</code> loop:</p> <ul> <li>Does not return a new array.</li> <li> <p>It is used to iterate over iterable objects.</p> <pre><code>const array = [1, 2, 3, 4, 5];\n\nfor (const item of array) {\n    console.log(item);\n}\n</code></pre> </li> </ul> </li> <li> <p><code>forEach</code> method:</p> <ul> <li>Does not return a new array.</li> <li> <p>It executes a provided function once for each array element.</p> <pre><code>const array = [1, 2, 3, 4, 5];\n\narray.forEach(item =&gt; {\n    console.log(item);\n});\n</code></pre> </li> </ul> </li> <li> <p><code>map</code> method:</p> <ul> <li>Returns a new array.</li> <li> <p>It creates a new array with the results of calling a provided function on every element in the calling array.</p> <pre><code>const array = [1, 2, 3, 4, 5];\n\narray.map(item =&gt; {\n    console.log(item);\n    return item;\n});\n\n// Example\nconst array = [1, 2, 3, 4, 5];\nconst newArray = array.map(item =&gt; item * 2);\nconsole.log(newArray); // [2, 4, 6, 8, 10]\n</code></pre> </li> </ul> </li> </ol> <ol> <li> <p><code>for...in</code> loop:</p> <ul> <li>Does not return a new object.</li> <li> <p>It is used to iterate over the enumerable properties of an object.</p> <pre><code>const obj = {a: 1, b: 2, c: 3};\n\nfor (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n        console.log(key, obj[key]);\n    }\n}\n</code></pre> </li> </ul> </li> <li> <p><code>Object.keys</code> method:</p> <ul> <li> <p>Returns a new array of the object\u2019s own enumerable property names (keys).</p> <pre><code>const obj = {a: 1, b: 2, c: 3};\n\nObject.keys(obj).forEach(key =&gt; {\n    console.log(key, obj[key]);\n});\n\n// Example\nconst obj = {a: 1, b: 2, c: 3};\nconst keys = Object.keys(obj);\nconsole.log(keys); // ['a', 'b', 'c']\n</code></pre> </li> </ul> </li> <li> <p><code>Object.entries</code> method:</p> <ul> <li> <p>Returns a new array of the object\u2019s own enumerable string-keyed property [key, value] pairs.</p> <pre><code>const obj = {a: 1, b: 2, c: 3};\n\nObject.entries(obj).forEach(([key, value]) =&gt; {\n    console.log(key, value);\n});\n\n// Example\nconst obj = {a: 1, b: 2, c: 3};\nconst entries = Object.entries(obj);\nconsole.log(entries); // [['a', 1], ['b', 2], ['c', 3]]\n</code></pre> </li> </ul> </li> <li> <p><code>Object.values</code> method:</p> <ul> <li> <p>Returns a new array of the object\u2019s own enumerable property values.</p> <pre><code>const obj = {a: 1, b: 2, c: 3};\n\nObject.values(obj).forEach(value =&gt; {\n    console.log(value);\n});\n\n// Example\nconst obj = {a: 1, b: 2, c: 3};\nconst values = Object.values(obj);\nconsole.log(values); // [1, 2, 3]\n</code></pre> </li> </ul> </li> </ol> <p>These methods provide flexibility depending on the specific requirements of your task. For example, <code>for...in</code> is generally used for objects, while <code>for...of</code> is typically used for arrays and iterable objects.</p> <p>In summary, among the array methods, only map returns a new array. For objects, Object.keys, Object.entries, and Object.values return new arrays. Methods like for, for...of, forEach, and for...in are used for iteration and do not inherently create new arrays or objects.</p>"},{"location":"frontend/js/core/control-statement/#for-in-vs-for-of-loop","title":"for in <code>vs</code> for of Loop","text":"<p>The <code>for...in</code> and <code>for...of</code> loops are both used for iterating over collections in JavaScript, but they serve different purposes and work with different types of collections.</p>"},{"location":"frontend/js/core/control-statement/#forin-loop","title":"<code>for...in</code> Loop","text":"<ul> <li>Purpose: Iterates over the enumerable properties of an object.</li> <li>Usage: Typically used for iterating over the keys of an object.</li> <li>Works with: Objects (though it can also be used with <code>arrays</code>, it is generally not recommended).</li> </ul> <pre><code>const obj = {a: 1, b: 2, c: 3};\n\nfor (const key in obj) {\n    console.log(key, obj[key]);\n}\n\n// Output:\n// a 1\n// b 2\n// c 3\n</code></pre> <p>When used with <code>arrays</code>, it iterates over the array indices (which are the enumerable properties of the array object).</p> <pre><code>const array = [1, 2, 3, 4, 5];\n\nfor (const index in array) {\n    console.log(index, array[index]);\n}\n\n// Output:\n// 0 1\n// 1 2\n// 2 3\n// 3 4\n// 4 5\n</code></pre>"},{"location":"frontend/js/core/control-statement/#forof-loop","title":"for...of Loop","text":"<ul> <li>Purpose: Iterates over the values of an iterable object.</li> <li>Usage: Typically used for iterating over the values of arrays, strings, maps, sets, and other iterable objects.</li> <li>Works with: Arrays, strings, maps, sets, and other iterable objects.</li> </ul> <pre><code>const array = [1, 2, 3, 4, 5];\n\nfor (const value of array) {\n    console.log(value);\n}\n\n// Output:\n// 1\n// 2\n// 3\n// 4\n// 5\n</code></pre> <p>It can also be used with other iterable objects like strings:</p> <pre><code>const string = \"hello\";\n\nfor (const char of string) {\n    console.log(char);\n}\n\n// Output:\n// h\n// e\n// l\n// l\n// o\n</code></pre>"},{"location":"frontend/js/core/control-statement/#key-differences","title":"Key Differences","text":"<ol> <li> <p>Iteration Target:</p> <ul> <li><code>for...in</code> iterates over the enumerable properties (keys) of an object.</li> <li><code>for...of</code> iterates over the values of an iterable object.</li> </ul> </li> <li> <p>Common Use Cases:</p> <ul> <li><code>for...in</code> is commonly used with objects to get the keys.</li> <li><code>for...of</code> is commonly used with <code>arrays</code>, <code>strings</code>, <code>maps</code>, <code>sets</code>, and other iterable objects to get the values.</li> </ul> </li> <li> <p>Arrays:</p> <ul> <li><code>for...in</code> should generally be avoided for arrays because it iterates over keys (indices) and can include properties from the prototype chain.</li> <li><code>for...of</code> is ideal for arrays as it directly iterates over the values.</li> </ul> </li> <li> <p>Prototype Chain:</p> <ul> <li><code>for...in</code> iterates over all enumerable properties, including those inherited from the prototype chain.</li> <li><code>for...of</code> only iterates over the values of the iterable object and does not consider properties from the prototype chain.</li> </ul> </li> </ol> <p>In summary, use <code>for...in</code> when you need to iterate over the properties of an object and use <code>for...of</code> when you need to iterate over the values of an iterable collection like an array or string.</p>"},{"location":"frontend/js/core/high-order-function/","title":"High Order Function (Hof)","text":""},{"location":"frontend/js/core/high-order-function/#higher-order-functions","title":"Higher-Order Functions","text":"<p>A higher-order function is a function that does at least one of the following:</p> <ul> <li>Takes one or more functions as arguments.</li> <li>Returns a function as its result.</li> </ul> <p>In JavaScript, many of the methods provided by the Array object are higher-order functions because they accept a function as an argument to process each element in the array. Here are a couple of examples:</p> Example map()filter()reduce()forEach()some()every()find()findIndex()sort()concat() <p>Takes a function as an argument to apply to each element and returns a new array.</p> <pre><code>const numbers = [1, 2, 3];\nconst doubled = numbers.map(num =&gt; num * 2);\nconsole.log(doubled); // [2, 4, 6]\n</code></pre> <p>Takes a function as an argument to determine which elements to include in the new array.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst evens = numbers.filter(num =&gt; num % 2 === 0);\nconsole.log(evens); // [2, 4]\n</code></pre> <p>Executes a reducer function (that you provide) on each element of the array, resulting in a single output value.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst sum = numbers.reduce((accumulator, currentValue) =&gt; accumulator + currentValue, 0);\nconsole.log(sum); // 10\n</code></pre> <p>Executes a provided function once for each array element.</p> <pre><code>const numbers = [1, 2, 3, 4];\nnumbers.forEach(num =&gt; console.log(num)); // 1 2 3 4\n</code></pre> <p>Tests whether at least one element in the array passes the test implemented by the provided function. Returns a Boolean value.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst hasEven = numbers.some(num =&gt; num % 2 === 0);\nconsole.log(hasEven); // true\n</code></pre> <p>Tests whether all elements in the array pass the test implemented by the provided function. Returns a Boolean value.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst allEven = numbers.every(num =&gt; num % 2 === 0);\nconsole.log(allEven); // false\n</code></pre> <p>Returns the value of the first element in the array that satisfies the provided testing function. Otherwise undefined is returned.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst firstEven = numbers.find(num =&gt; num % 2 === 0);\nconsole.log(firstEven); // 2\n</code></pre> <p>Returns the index of the first element in the array that satisfies the provided testing function. Otherwise, -1 is returned.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst firstEvenIndex = numbers.findIndex(num =&gt; num % 2 === 0);\nconsole.log(firstEvenIndex); // 1\n</code></pre> <p>Sorts the elements of an array in place and returns the sorted array.</p> <pre><code>const numbers = [4, 2, 3, 1];\nnumbers.sort((a, b) =&gt; a - b);\nconsole.log(numbers); // [1, 2, 3, 4]\n</code></pre> <p>Merges two or more arrays. This method does not change the existing arrays, but instead returns a new array.</p> <pre><code>const array1 = [1, 2];\nconst array2 = [3, 4];\nconst combined = array1.concat(array2);\nconsole.log(combined); // [1, 2, 3, 4]\n</code></pre> <p>These functions are \"higher-order\" because they operate on other functions, either by receiving them as arguments or by returning them.</p> what is high order function in javascript? why it is called hof? why do we need them. when does the hof comes in javascript? explain me in depth <p>A higher-order function (HOF) in JavaScript is a function that either takes one or more functions as arguments, returns a function as its result, or both. Higher-order functions are a key feature in functional programming, allowing for more flexible and reusable code.</p> <p>Why It's Called HOF</p> <p>The term \"higher-order\" comes from mathematics, where functions that operate on other functions are called higher-order functions. This terminology has been adopted in programming to describe functions that can take other functions as parameters or return functions as results.</p> <p>Why We Need Higher-Order Functions</p> <ul> <li> <p>Abstraction: Higher-order functions allow for abstraction of actions, not just values. They enable you to create more generic and reusable code by encapsulating behavior that can be varied.</p> </li> <li> <p>Code Reusability: By using HOFs, you can write more generic functions that can be reused with different behaviors, leading to less code duplication.</p> </li> <li> <p>Functional Programming: They are a cornerstone of functional programming, promoting a declarative coding style. This can make code more readable and maintainable.</p> </li> <li> <p>Composability: HOFs enable function composition, which is a way to build complex functions by combining simpler ones.</p> </li> </ul> <p>Examples of Higher-Order Functions</p> Functions as Arguments:Functions as Return Values:Both: <pre><code>function filter(array, test) {\n    let passed = [];\n    for (let element of array) {\n        if (test(element)) {\n            passed.push(element);\n        }\n    }\n    return passed;\n}\n\nconst isEven = n =&gt; n % 2 === 0;\nconst numbers = [1, 2, 3, 4, 5, 6];\nconsole.log(filter(numbers, isEven)); // [2, 4, 6]\n</code></pre> <pre><code>function createMultiplier(multiplier) {\n    return function(x) {\n        return x * multiplier;\n    };\n}\n\nconst double = createMultiplier(2);\nconsole.log(double(5)); // 10\n</code></pre> <pre><code>function repeat(n, action) {\n    for (let i = 0; i &lt; n; i++) {\n        action(i);\n    }\n}\n\nrepeat(3, console.log);\n// Output:\n// 0\n// 1\n// 2\n</code></pre> <p>Common JavaScript Higher-Order Functions</p> <ol> <li> <p>Array.prototype.map():</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst doubled = numbers.map(n =&gt; n * 2);\nconsole.log(doubled); // [2, 4, 6, 8]\n</code></pre> </li> <li> <p>Array.prototype.filter():</p> <pre><code>const numbers = [1, 2, 3, 4, 5];\nconst evens = numbers.filter(n =&gt; n % 2 === 0);\nconsole.log(evens); // [2, 4]\n</code></pre> </li> <li> <p>Array.prototype.reduce():</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst sum = numbers.reduce((acc, n) =&gt; acc + n, 0);\nconsole.log(sum); // 10\n</code></pre> </li> </ol> <p>When Do HOFs Come in JavaScript?</p> <p>HOFs come into play in various scenarios:</p> <ul> <li>Array Operations: Functions like <code>map</code>, <code>filter</code>, <code>reduce</code>, and <code>forEach</code> are higher-order functions that operate on arrays.</li> <li>Event Handling: Functions like <code>addEventListener</code> in the browser API take a callback function to be executed when an event occurs.</li> <li>Asynchronous Programming: Functions like <code>setTimeout</code>, <code>setInterval</code>, and <code>promises</code> use callbacks to handle asynchronous operations.</li> </ul> <p>Conclusion</p> <p>Higher-order functions are a powerful feature in JavaScript that allows for more flexible, reusable, and composable code. They enable a functional programming approach, promoting a declarative coding style and making complex operations more manageable. Understanding and using HOFs can greatly enhance your ability to write clean and efficient JavaScript code.</p> higher-order functions can be applied in various contexts beyond array operations? <ol> <li> <p>Event Handling</p> <p>Higher-order functions are widely used in event handling in web development.</p> <pre><code>document.getElementById(\"myButton\").addEventListener(\"click\", function() {\n    alert(\"Button was clicked!\");\n});\n</code></pre> <p>In this example, <code>addEventListener</code> is a higher-order function that takes another function (the event handler) as an argument.</p> </li> <li> <p>Asynchronous Programming</p> <p>Higher-order functions are crucial in asynchronous programming with <code>callbacks</code>, <code>promises</code>, and <code>async/await</code>.</p> Callbacks<pre><code>function fetchData(callback) {\n    setTimeout(() =&gt; {\n        const data = { name: \"John\", age: 30 };\n        callback(data);\n    }, 1000);\n}\n\nfetchData(function(data) {\n    console.log(data);\n});\n</code></pre> Promises<pre><code>function fetchData() {\n    return new Promise((resolve, reject) =&gt; {\n        setTimeout(() =&gt; {\n        const data = { name: \"John\", age: 30 };\n        resolve(data);\n        }, 1000);\n    });\n}\n\nfetchData().then(data =&gt; {\n    console.log(data);\n});\n</code></pre> </li> <li> <p>Function Composition</p> <p>Higher-order functions are used to compose functions.</p> <pre><code>const add = x =&gt; x + 1;\nconst multiply = x =&gt; x * 2;\n\nconst compose = (f, g) =&gt; x =&gt; f(g(x));\n\nconst addThenMultiply = compose(multiply, add);\n\nconsole.log(addThenMultiply(5)); // 12\n</code></pre> </li> <li> <p>Middleware</p> <p>In frameworks like <code>Express.js</code>, middleware functions are higher-order functions that process HTTP requests and responses.</p> <pre><code>const express = require(\"express\");\nconst app = express();\n\napp.use((req, res, next) =&gt; {\n    console.log(\"Middleware function\");\n    next();\n});\n\napp.get(\"/\", (req, res) =&gt; {\n    res.send(\"Hello World\");\n});\n\napp.listen(3000);\n</code></pre> </li> <li> <p>Currying</p> <p>Currying transforms a function with multiple arguments into a sequence of functions each with a single argument.</p> <pre><code>const multiply = a =&gt; b =&gt; a * b;\nconst double = multiply(2);\nconsole.log(double(5)); // 10\n</code></pre> </li> </ol> <p>Conclusion</p> <p>Higher-order functions in JavaScript are versatile and can be applied in various contexts, including but not limited to array operations. They play a significant role in event handling, asynchronous programming, function composition, middleware, and more. Understanding how to use higher-order functions effectively can greatly enhance your programming skills and enable you to write more flexible and reusable code.</p> does high order function used in object? <p>Yes, higher-order functions can be used with objects in JavaScript. While they are often associated with arrays due to methods like <code>map</code>, <code>filter</code>, and <code>reduce</code>, higher-order functions can operate on objects and be used in various object-oriented programming scenarios. Here are some examples to illustrate how higher-order functions can be used with objects:</p> <p>1. Iterating Over Object Properties</p> <p>You can create higher-order functions to iterate over an object's properties.</p> Mapping Over Object Properties<pre><code>const mapObject = (obj, fn) =&gt; {\n    const result = {};\n    for (const [key, value] of Object.entries(obj)) {\n        result[key] = fn(value);\n    }\n    return result;\n};\n\nconst user = { name: \"Alice\", age: 25, country: \"USA\" };\nconst upperCasedUser = mapObject(user, val =&gt; val.toString().toUpperCase());\nconsole.log(upperCasedUser); \n// { name: \"ALICE\", age: \"25\", country: \"USA\" }\n</code></pre> <p>2. Object Methods as Higher-Order Functions</p> <p>Objects can have methods that accept functions as arguments or return functions.</p> Configurable Logger<pre><code>const logger = {\n    log: (message) =&gt; console.log(`LOG: ${message}`),\n    error: (message) =&gt; console.error(`ERROR: ${message}`),\n    withPrefix: function(prefix) {\n        return (message) =&gt; this.log(`${prefix} ${message}`);\n    }\n};\n\nconst prefixedLogger = logger.withPrefix(\"Prefix\");\nprefixedLogger(\"This is a message.\"); \n// LOG: Prefix This is a message.\n</code></pre> <p>3. Functional Programming with Objects</p> <p>You can use higher-order functions to manipulate objects in a functional programming style.</p> Object Transformation<pre><code>const transformObject = (obj, transformFn) =&gt; {\n    return Object.keys(obj).reduce((acc, key) =&gt; {\n        acc[key] = transformFn(obj[key]);\n        return acc;\n    }, {});\n};\n\nconst user = { name: \"Alice\", age: 25, country: \"USA\" };\nconst doubledAgesUser = transformObject(user, val =&gt; typeof val === 'number' ? val * 2 : val);\nconsole.log(doubledAgesUser); \n// { name: \"Alice\", age: 50, country: \"USA\" }\n</code></pre> <p>4. Creating Fluent APIs</p> <p>Higher-order functions can help create fluent APIs, where methods can be chained together.</p> Fluent API for Object Manipulation<pre><code>const user = {\n    name: \"Alice\",\n    age: 25,\n    setName: function(newName) {\n        this.name = newName;\n        return this;\n    },\n    setAge: function(newAge) {\n        this.age = newAge;\n        return this;\n    }\n};\n\nconst updatedUser = user.setName(\"Bob\").setAge(30);\nconsole.log(updatedUser); \n// { name: \"Bob\", age: 30, setName: [Function], setAge: [Function] }\n</code></pre> <p>Conclusion</p> <p>Higher-order functions are not limited to arrays and can be effectively used with objects in JavaScript. They enable powerful patterns for iterating over object properties, transforming objects, creating methods that accept or return functions, and building fluent APIs. Understanding how to apply higher-order functions to objects can help you write more flexible, reusable, and expressive code.</p> Example <p>In JavaScript, a higher-order function is a function that either takes one or more functions as arguments or returns a function as a result. This allows for more abstract and flexible code.</p> <p>Here's a simple mathematical example using higher-order functions in JavaScript:</p> <p>Example 1: Function that multiplies numbers by a given factor</p> <p>We'll create a higher-order function called <code>createMultiplier</code> that takes a number as an argument and returns a new function. This returned function will multiply its input by the given number.</p> <pre><code>// Higher-order function\nfunction createMultiplier(factor) {\n    // Returning a new function\n    return function(number) {\n        return number * factor;\n    };\n}\n\n// Using the higher-order function to create multiplier functions\nconst double = createMultiplier(2);\nconst triple = createMultiplier(3);\n\n// Testing the created functions\nconsole.log(double(5)); // Output: 10\nconsole.log(triple(5)); // Output: 15\n</code></pre> <p>Explanation</p> <ul> <li>Higher-Order Function: <code>createMultiplier</code> is a higher-order function because it takes a number (<code>factor</code>) as an argument and returns a new function.</li> <li>Returned Function: The returned function takes another number (<code>number</code>) as an argument and multiplies it by the <code>factor</code>.</li> <li>Usage: We use <code>createMultiplier</code> to create two new functions: <code>double</code> (which multiplies by 2) and <code>triple</code> (which multiplies by 3).</li> <li>Testing: When we call <code>double(5)</code>, it returns <code>10</code> (because 5\u00d72=10). When we call <code>triple(5)</code>, it returns <code>15</code> (because 5\u00d73=15).</li> </ul> <p>Another Example: Function Composition</p> <p>Here's another mathematical example using higher-order functions for function composition:</p> <pre><code>// Higher-order function for function composition\nfunction compose(f, g) {\n    // Returning a new function\n    return function(x) {\n        return f(g(x));\n    };\n}\n\n// Simple mathematical functions\nfunction add2(x) {\n    return x + 2;\n}\n\nfunction square(x) {\n    return x * x;\n}\n\n// Using the compose function\nconst add2AndSquare = compose(square, add2);\n\n// Testing the composed function\nconsole.log(add2AndSquare(3)); // Output: 25\n</code></pre> <p>Explanation</p> <ul> <li>Higher-Order Function: <code>compose</code> is a higher-order function because it takes two functions (<code>f</code> and <code>g</code>) as arguments and returns a new function.</li> <li>Returned Function: The returned function takes a number (<code>x</code>) as an argument and applies <code>g</code> to <code>x</code>, then applies <code>f</code> to the result of <code>g(x)</code>.</li> <li>Simple Functions: <code>add2</code> adds 2 to its input, and <code>square</code> squares its input.</li> <li>Usage: We use <code>compose</code> to create a new function <code>add2AndSquare</code> which first adds 2 to the input and then squares the result.</li> <li>Testing: When we call <code>add2AndSquare(3)</code>, it returns <code>25</code> (because (3+2)\u00d7(3+2)=5\u00d75=25).</li> </ul> <p>Higher-order functions are powerful tools in functional programming, allowing you to create more flexible and reusable code by abstracting common patterns.</p> Warning <p>The two functions you've provided are quite different in both their structure and their behavior. Let's break down the differences:</p> <p>First Function: Higher-Order Function</p> <pre><code>function createMultiplier(factor) {\n    // Returning a new function\n    return function(number) {\n        return number * factor;\n    };\n}\n</code></pre> <p>Explanation:</p> <ul> <li>Higher-Order Function: This function is a higher-order function because it returns a new function.</li> <li>Returned Function: The returned function takes an argument <code>number</code> and multiplies it by factor.</li> <li>Usage: You can use this function to create specific multiplier functions that can be used multiple times with different inputs.</li> </ul> Example Usage<pre><code>const double = createMultiplier(2);\nconst triple = createMultiplier(3);\n\nconsole.log(double(5)); // Output: 10\nconsole.log(triple(5)); // Output: 15\n</code></pre> <p>Second Function: Simple Multiplication</p> <pre><code>function createMultiplier(factor) {\n    return factor * factor;\n}\n</code></pre> <p>Explanation:</p> <ul> <li>Simple Function: This function is not a higher-order function. It simply multiplies the <code>factor</code> by itself and returns the result.</li> <li>Immediate Result: The function returns the result of <code>factor * factor</code> immediately without returning another function.</li> <li>Usage: You use this function to get the square of a number.</li> </ul> Example Usage<pre><code>console.log(createMultiplier(2)); // Output: 4\nconsole.log(createMultiplier(3)); // Output: 9\n</code></pre> Differences: <ol> <li> <p>Function Type:</p> <ul> <li>First Function: A higher-order function that returns a new function.</li> <li>Second Function: A simple function that performs a calculation and returns the result immediately.</li> </ul> </li> <li> <p>Purpose:</p> <ul> <li>First Function: Designed to create and return a multiplier function that can be used to multiply different numbers by a specific factor.</li> <li>Second Function: Designed to return the square of the given factor.</li> </ul> </li> <li> <p>Usage:</p> <ul> <li>First Function: Can be used to create specific multiplier functions (e.g., doubling, tripling).</li> <li>Second Function: Can only be used to calculate the square of the given factor.</li> </ul> </li> </ol> <p>Summary:</p> <ul> <li>The first function (<code>createMultiplier(factor) { return function(number) { return number * factor; }; }</code>) is a higher-order function that returns a new function capable of multiplying a number by the specified factor.</li> <li>The second function (<code>createMultiplier(factor) { return factor * factor; }</code>) is a simple function that returns the square of the given factor.</li> </ul> <p>Each function serves a different purpose and is used in different contexts. The higher-order function is more flexible and can create various multiplier functions, while the simple function is limited to calculating the square of the input factor.</p>"},{"location":"frontend/js/core/high-order-function/#finale-example","title":"FINALE EXAMPLE","text":"javascript<pre><code>function createMultiplier(factor) {\n    // Returning a new function\n    return function(number) {\n        return number * factor;\n    };\n}\nconst double = createMultiplier(2);\nconsole.log(double(5));\n</code></pre>"},{"location":"frontend/js/core/high-order-function/#lets-clarify-where-5-and-2-fit-in","title":"Let's clarify where 5 and 2 fit in:","text":"<ul> <li> <p>Factor (<code>factor</code>): When you call <code>createMultiplier(2)</code>, <code>2</code> is passed as an argument to <code>createMultiplier</code>, which assigns it to the parameter <code>factor</code>. So, <code>factor</code> becomes <code>2</code> within the scope of the returned function.</p> </li> <li> <p>Number (<code>number</code>): When you call <code>double(5)</code>, <code>5</code> is passed as an argument to double, which is actually the function returned by <code>createMultiplier(2)</code>. Inside this function, <code>number</code> refers to <code>5</code> in this particular call.</p> </li> </ul>"},{"location":"frontend/js/core/instance-and-static-methods/","title":"Instance & Static Methods","text":""},{"location":"frontend/js/core/instance-and-static-methods/#instance-methods","title":"Instance Methods","text":"<p>What They Do:</p> <ul> <li>Require an Instance: These methods operate on instances of the class. To use them, you first need to create an instance (object) of that class.</li> <li>Example: If you have a <code>Person</code> class with an instance method <code>greet()</code>, you need to create a <code>Person</code> object to call <code>greet()</code>.</li> </ul> <p>How to Use:</p> <ul> <li> <p>Syntax: Call these methods on an instance created with the new keyword.</p> </li> <li> <p>Example:</p> <pre><code>class Person {\n    constructor(name) {\n        this.name = name;\n    }\n\n    greet() {\n        console.log(`Hello, my name is ${this.name}.`);\n    }\n}\n\nconst alice = new Person('Alice'); // Creating an instance\nalice.greet(); // Calling the instance method\n</code></pre> <p>Explanation: <code>greet()</code> is an instance method. You must create a <code>Person</code> object (<code>alice</code>) before calling <code>greet()</code>.</p> </li> </ul>"},{"location":"frontend/js/core/instance-and-static-methods/#static-methods","title":"Static Methods","text":"<p>What They Do:</p> <ul> <li>Class-Level Functions: These methods belong to the class itself rather than to any particular instance.</li> <li>Example: If you have a <code>MathHelper</code> class with a static method <code>add()</code>, you call <code>add()</code> directly on the class, not on an instance.</li> </ul> <p>How to Use:</p> <ul> <li> <p>Syntax: Call these methods directly on the class.</p> </li> <li> <p>Example:</p> <pre><code>class MathHelper {\n    static add(x, y) {\n        return x + y;\n    }\n}\n\nconsole.log(MathHelper.add(5, 3)); // Calling the static method on the class\n</code></pre> <p>Explanation: <code>add()</code> is a static method. You can call it directly on the <code>MathHelper</code> class without creating an instance.</p> </li> </ul>"},{"location":"frontend/js/core/instance-and-static-methods/#summary","title":"Summary","text":"<p>Instance Methods:</p> <ul> <li>Need an Instance: Methods defined inside the class (not static) need an object created with new to be used.</li> <li>Use Case: They operate on data specific to an instance.</li> </ul> <p>Static Methods:</p> <ul> <li>No Instance Needed: You can call them directly on the class itself.</li> <li>Use Case: They provide utility functions or class-level operations.</li> </ul> Mnemonic for Remembering <ul> <li>Instance Methods: \"I Need an Instance\" - You need to create an instance to use these methods.</li> <li>Static Methods: \"Solely on the Class\" - You use these methods directly on the class, without creating an instance.</li> </ul> <p>By using these mnemonics, you can easily remember the difference between instance methods and static methods and know when and how to use each.</p>"},{"location":"frontend/js/core/js-exception-handling/","title":"Exception Handling","text":"<p>In JavaScript, the throw new Error(errorMessage); statement does not display the error on the web by itself. Instead, it creates an Error object with the provided errorMessage and then throws that error. This error will be caught by the nearest catch block in a try...catch structure.</p> Here\u2019s a breakdown of how it works: <ol> <li> <p>Error Creation and Throwing:</p> <ul> <li><code>throw new Error(errorMessage)</code>; creates a new <code>Error</code> object with the specified errorMessage.</li> <li>The <code>throw</code> statement then throws this Error object, which immediately exits the current function and passes the error to the nearest <code>catch</code> block.</li> </ul> </li> <li> <p>Error Handling in <code>catch</code>:</p> <ul> <li>If there is a <code>catch</code> block that matches this <code>Error</code>, the error is caught and can be handled appropriately (e.g., logging the error, dispatching an error action, displaying an error message to the user).</li> </ul> </li> <li> <p>Error Display on the Web:</p> <ul> <li>To show an error message to the user, you must explicitly handle and display it. This usually involves:<ul> <li>Catching the error and then displaying a message in the UI.</li> <li>Using a library or UI component to show user-friendly error messages (e.g., alert, modal, or notification).</li> </ul> </li> </ul> </li> </ol> <pre><code>// Action creator with error handling\nexport const actionForUpdateDailyDairy = (id, body) =&gt; {\n    return async(dispatch) =&gt; {\n        dispatch(init(DAILY_DAIRY.UPDATE_DAILY_DIARY));\n\n        try {\n            const response = await dailyDairyService.apiForDailyDiaryUpdate(id, body);\n            if(response.isSuccess) {\n                dispatch(success(DAILY_DAIRY.UPDATE_DAILY_DIARY, response.data));\n                return response.data;\n            } else {\n                const errorMessage = response.errorMessage || 'Unknown error occurred during the update';\n                dispatch(error(errorMessage));\n                throw new Error(errorMessage); // Throwing error to be caught by catch block\n            }\n        } catch (err) {\n            // Handling the error\n            const errorMessage = err.message || 'Unknown error occurred';\n            dispatch(error(errorMessage));\n            // Optionally show the error message in the UI\n            // e.g., displayNotification(errorMessage);\n        } finally {\n            dispatch(finish(DAILY_DAIRY.UPDATE_DAILY_DIARY));\n        }\n    }\n}\n</code></pre> Points to Note: <ol> <li> <p>Error Propagation:</p> <ul> <li>The error thrown is caught by the <code>catch</code> block, where you can handle it (e.g., dispatch an error action to update the UI).</li> </ul> </li> <li> <p>UI Error Display:</p> <ul> <li>To display an error message on the web, ensure that your <code>catch</code> block (or the part of the application handling errors) updates the UI or shows a message to the user.</li> </ul> </li> <li> <p>No Automatic Display:</p> <ul> <li>JavaScript does not automatically display error messages. You need to implement a mechanism to display errors if needed.</li> </ul> </li> </ol> <p>By correctly handling errors in the <code>catch</code> block, you can manage how errors are propagated and displayed in your application.</p> <p>Mastering JavaScript exception handling involves understanding how errors work, effectively using error-handling mechanisms, and implementing best practices to ensure robust and user-friendly applications. Here\u2019s a comprehensive guide to help you master JavaScript exception handling:</p> <ol> <li> <p>Understanding JavaScript Errors</p> <p>JavaScript errors are instances of the Error class and its subclasses:</p> <ul> <li>Error: Base class for all errors.</li> <li>TypeError: Indicates an operation was performed on a value of the wrong type.</li> <li>ReferenceError: Indicates a reference to an undefined variable.</li> <li>SyntaxError: Indicates a syntax mistake in code.</li> <li>RangeError: Indicates a value is out of range.</li> <li>EvalError: Indicates an error with the <code>eval()</code> function (rarely used).</li> </ul> </li> <li> <p>Basic Exception Handling</p> <p>Use <code>try...catch</code> blocks to handle exceptions:</p> <pre><code>try {\n    // Code that may throw an error\n    let result = riskyOperation();\n} catch (error) {\n    // Handle the error\n    console.error('Error occurred:', error.message);\n} finally {\n    // Code that always executes\n    console.log('Cleanup code');\n}\n</code></pre> <ul> <li>try: Contains code that might throw an error.</li> <li>catch: Handles the error if one occurs.</li> <li>finally: Executes code regardless of whether an error occurred.</li> </ul> </li> <li> <p>Throwing Errors</p> <p>You can throw your own errors using <code>throw</code>:</p> <pre><code>function validate(value) {\n    if (value &lt; 0) {\n        throw new RangeError('Value must be non-negative');\n    }\n    return value;\n}\n</code></pre> </li> <li> <p>Custom Error Classes</p> <p>Create custom error classes to represent specific error conditions:</p> <pre><code>class CustomError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = 'CustomError';\n    }\n}\n\nfunction doSomething() {\n    throw new CustomError('Something went wrong');\n}\n</code></pre> </li> </ol> Best Practices <ul> <li>Avoid Silent Failures: Always handle errors to avoid silent failures that can lead to unexpected behavior.</li> <li>Use Specific Errors: Throw specific error types where applicable to make debugging easier.</li> <li>Avoid Overuse of <code>try...catch</code>: Only use <code>try...catch</code> where necessary, as overuse can obscure issues.</li> </ul>"},{"location":"frontend/js/core/js-exception-handling/#reducer","title":"REDUCER","text":""},{"location":"frontend/js/core/js-exception-handling/#function","title":"FUNCTION","text":""},{"location":"frontend/js/core/js-exception-handling/#question-1","title":"Question 1:","text":"Question <pre><code>const handleTodaySaveDiary = () =&gt; {\n    console.log(\"data.items\", data.items);\n}\n\n&lt;Content\n    style={{\n        display: \"flex\",\n        justifyContent: \"end\",\n        paddingTop: \"8px\",\n    }}\n&gt;\n{!loading &amp;&amp; data != null &amp;&amp; !isEmpty(data.items) &amp;&amp; (\n    &lt;Button\n        type=\"primary\"\n        // disabled\n        // loading={loading}\n        onClick={handleTodaySaveDiary}\n        style={{\n            padding: \"0px 10px\"\n        }}\n    &gt;\n        Save\n    &lt;/Button&gt;\n)}\n&lt;/Content&gt;\n\n&lt;Modal\n    title=\"Basic Modal\"\n    visible={isModalOpen}\n    onOk={handleOk}\n    onCancel={handleCancel}\n    fotter={null}\n&gt;\n    &lt;Form\n        form={formToday}\n    &gt;\n        Today Form\n    &lt;/Form&gt;\n&lt;/Modal&gt;\n\n\n// data.items value\n\n{\n    \"totalCount\": 2,\n    \"items\": [\n    {\n        \"id\": \"5a618cd6-53d8-4d49-b0b9-23f1ef72a395\",\n        \"todoEventId\": \"cafba611-b13b-4881-8639-b7715257a430\",\n        \"dailyDairyDate\": \"2024-08-15T12:07:48.1704016\",\n        \"stutusId\": \"4de2c2e9-aed1-4b28-bec0-6e52ab148f87\",\n        \"statusName\": \"Start\",\n        \"userId\": \"73fc9457-6b63-6a4a-64de-39f960722731\",\n        \"userName\": \"admin_bbask\",\n        \"title\": \"OS\",\n        \"remarks\": \"KHALAS xcccpp\",\n        \"isActive\": true,\n        \"statusDto\": {\n        \"id\": \"4de2c2e9-aed1-4b28-bec0-6e52ab148f87\",\n        \"name\": \"Start\",\n        \"colorHexValue\": \"#6a71ad\",\n        \"colorFontHexValue\": \"#ffffff\"\n        }\n    },\n    {\n        \"id\": \"84970e8e-2d55-4703-b4a8-ce118cd2a363\",\n        \"todoEventId\": \"f83a16b1-3931-4b0f-b2ea-59a123e4b2af\",\n        \"dailyDairyDate\": \"2024-08-15T09:34:31.976906\",\n        \"stutusId\": \"6a4a2e83-c05a-4134-999b-fd211a546e86\",\n        \"statusName\": \"Completed\",\n        \"userId\": \"73fc9457-6b63-6a4a-64de-39f960722731\",\n        \"userName\": \"admin_bbask\",\n        \"title\": \"NEW TASK TODAY\",\n        \"remarks\": \"fsfafsdfdsfasdf  jkhjk sadfjasdfb sadasdf\\ndsds\",\n        \"isActive\": true,\n        \"statusDto\": {\n        \"id\": \"6a4a2e83-c05a-4134-999b-fd211a546e86\",\n        \"name\": \"Completed\",\n        \"colorHexValue\": \"#cbce91\",\n        \"colorFontHexValue\": \"#ffffff\"\n        }\n    }\n    ]\n}\n</code></pre> <p>Scenario: after click the handleTodaySaveDiary button if the data.items contains object which statusName is not Completed then open the modal and list the title and remarks description box to submit. if all the statusName is completed then donot open the modal.</p>"},{"location":"frontend/js/core/js-exception-handling/#solution-1","title":"SOLUTION 1:","text":"Question <p>To ensure that <code>handleAddUpdateDairy()</code> is only called if <code>actionForUpdateDailyDairy</code> completes successfully, you need to adjust your <code>handleOnFinish</code> function to properly handle errors from the asynchronous action. Currently, <code>handleAddUpdateDairy()</code> is called unconditionally after dispatching <code>actionForUpdateDailyDairy</code>, so you should modify the function to wait for <code>actionForUpdateDailyDairy</code> to complete and handle errors properly.</p> <p>Here's how you can adjust the handleOnFinish function:</p> <ol> <li> <p>Use <code>await</code> for asynchronous operations: Since <code>dispatch</code> is returning a promise, you should await the result of <code>dispatch(actionForUpdateDailyDairy(selectedRecordData?.id, body))</code> to handle errors effectively.</p> </li> <li> <p>Check the result of dispatch before calling <code>handleAddUpdateDairy()</code>: Only call <code>handleAddUpdateDairy()</code> if the update action was successful.</p> </li> </ol> <p>Here's the updated handleOnFinish function:</p> <pre><code>const handleOnFinish = async (values) =&gt; {\n    let body = {\n        statusId: values?.todoEventStatusId,\n        remarks: values?.remarks\n    };\n\n    try {\n        // Ensure dispatch returns a promise to await it\n        const result = await dispatch(actionForUpdateDailyDairy(selectedRecordData?.id, body));\n\n        // If the result was successful, proceed with handleAddUpdateDairy\n        if (result) {\n            handleAddUpdateDairy();\n        }\n    } catch (err) {\n        console.log(\"Error: \", err);\n    }\n}\n</code></pre> Explanation <ol> <li> <p>Await Dispatch: The <code>await dispatch(actionForUpdateDailyDairy(selectedRecordData?.id, body))</code> will pause execution until <code>actionForUpdateDailyDairy</code> has finished, allowing you to catch any errors that might be thrown during the dispatch.</p> </li> <li> <p>Conditional Call: <code>handleAddUpdateDairy()</code> is only called if the result from <code>actionForUpdateDailyDairy</code> indicates success. You may need to adjust the <code>actionForUpdateDailyDairy</code> action to ensure it returns a result that you can check, such as a boolean indicating success.</p> </li> <li> <p>Error Handling: The catch block will handle any errors thrown during the dispatch or the async operation itself.</p> </li> </ol> Important Note <p>Make sure that <code>actionForUpdateDailyDairy</code>'s promise resolves with a value you can check. If the action creator does not currently return a meaningful result, you might need to adjust it so that it does. For example, you could modify <code>actionForUpdateDailyDairy</code> to return <code>response.data</code> only when the operation is successful, and ensure that the error handling logic is correctly implemented.</p>"},{"location":"frontend/js/core/js-exception-handling/#solution-2","title":"SOLUTION 2:","text":"<p>To update your <code>handleOnFinish</code> function so that <code>handleAddUpdateDairy</code> is only called if there is no error in <code>actionForUpdateDailyDairy</code>, you'll need to handle the asynchronous nature of <code>dispatch</code>. You should await the result of <code>dispatch</code> and check for errors before proceeding. Here\u2019s how you can modify your code:</p> Updated handleOnFinish Function<pre><code>const handleOnFinish = async (values) =&gt; {\n    let body = {\n        statusId: values?.todoEventStatusId,\n        remarks: values?.remarks\n    };\n\n    try {\n        if (values?.todoEventStatusId) {\n            // Await the dispatch to ensure completion\n            await dispatch(actionForUpdateDailyDairy(selectedRecordData?.id, body));\n        }\n\n        // Only call handleAddUpdateDairy if dispatch was successful\n        handleAddUpdateDairy();\n    } catch (err) {\n        // Log error and handle it appropriately\n        console.log(\"Error: \", err);\n        // Optionally handle or display the error to the user\n    }\n};\n</code></pre> Explanation: <ol> <li> <p>Await Dispatch: The <code>await dispatch(actionForUpdateDailyDairy(selectedRecordData?.id, body))</code>; line ensures that you wait for the asynchronous action to complete. This means <code>handleAddUpdateDairy()</code> will only be called after <code>actionForUpdateDailyDairy</code> has finished.</p> </li> <li> <p>Conditional Call: <code>handleAddUpdateDairy()</code> is called after the <code>dispatch</code> promise resolves successfully. If <code>dispatch</code> throws an error or fails, the catch block will handle it, and <code>handleAddUpdateDairy()</code> will not be executed.</p> </li> <li> <p>Error Handling: The <code>catch</code> block catches any errors thrown during the dispatch process. You can log or handle these errors as needed.</p> </li> </ol> Additional Considerations: <ul> <li> <p>Action Return Values: Ensure that <code>actionForUpdateDailyDairy</code> is set up to correctly handle and throw errors if necessary. The action creator should be designed to handle success and failure cases.</p> </li> <li> <p>User Feedback: Depending on your UI needs, you might want to provide feedback to the user if an error occurs. This can be done using a UI library or custom error messaging.</p> </li> </ul> <p>With this approach, your code will properly handle the asynchronous operation and ensure that subsequent actions are only taken if the update is successful.</p>"},{"location":"frontend/js/core/js-exception-handling/#example","title":"Example","text":""},{"location":"frontend/js/core/js-exception-handling/#question-2","title":"Question 2:","text":"<ul> <li><code>onClick={handleTodaySaveDiary}</code>: Directly assigns the function to the <code>onClick</code> event, so it will be called when the button is clicked.</li> <li><code>onClick={() =&gt; handleTodaySaveDiary()}</code>: Uses an arrow function to call <code>handleTodaySaveDiary()</code> when the button is clicked. This is useful if you need to perform additional logic in the future.</li> </ul>"},{"location":"frontend/js/core/js-exception-handling/#button-code-snippit-example","title":"Button Code Snippit Example","text":"Example <pre><code>{!loading &amp;&amp; data != null &amp;&amp; !isEmpty(data.items) &amp;&amp; (\n    &lt;Button\n        type=\"primary\"\n        loading={loading}\n        onClick={() =&gt; console.log(\"hello world\", data?.items)}\n        style={{\n            padding: \"0px 10px\"\n        }}\n    &gt;\n        Save\n    &lt;/Button&gt;\n)}\n\n// or\n\n&lt;Button\n    // disabled\n    type=\"primary\"\n    loading={loading}\n    onClick={() =&gt; console.log(\"hello world\", data?.items)}\n    style={{\n        padding: \"0px 10px\"\n    }}\n&gt;\n    Save\n&lt;/Button&gt;\n</code></pre>"},{"location":"frontend/js/core/js-exception-handling/#use-content-for-layout","title":"use <code>Content</code> for Layout","text":"Note <pre><code>import { Layout } from \"antd\";\n\nconst { Content } = Layout;\n\n&lt;Content\n    style={{\n        display: \"flex\",\n        justifyContent: \"end\",\n        paddingTop: \"8px\",\n    }}\n&gt;\n    &lt;Button\n        // disabled\n        type=\"primary\"\n        loading={loading}\n        onClick={() =&gt; console.log(\"hello world\", data?.items)}\n        style={{\n            padding: \"0px 10px\"\n        }}\n    &gt;\n        Save\n    &lt;/Button&gt;\n&lt;/Content&gt;\n</code></pre>"},{"location":"frontend/js/core/js-exception-handling/#office-solve","title":"Office Solve","text":""},{"location":"frontend/js/core/js-exception-handling/#question-1_1","title":"Question 1","text":"Example CodeExplanationModified <p>To implement this scenario, you can filter data.items based on the statusName. If there are any items with statusName not equal to \"Completed\", the modal will open; otherwise, it will remain closed.</p> <p>Here's how you can achieve this:</p> Updated Code:<pre><code>const handleTodaySaveDiary = () =&gt; {\n    const incompleteItems = data.items.filter(item =&gt; item.statusName !== \"Completed\");\n\n    // Log items that are not completed\n    console.log(\"Incomplete Items:\", incompleteItems);\n\n    if (incompleteItems.length &gt; 0) {\n        // Open the modal\n        setIsModalOpen(true);\n    } else {\n        // All items are completed, do not open the modal\n        console.log(\"All items are completed, no modal needed\");\n    }\n};\n\n&lt;Content\n    style={{\n        display: \"flex\",\n        justifyContent: \"end\",\n        paddingTop: \"8px\",\n    }}\n&gt;\n{!loading &amp;&amp; data != null &amp;&amp; !isEmpty(data.items) &amp;&amp; (\n    &lt;Button\n        type=\"primary\"\n        onClick={handleTodaySaveDiary}\n        style={{\n            padding: \"0px 10px\"\n        }}\n    &gt;\n        Save\n    &lt;/Button&gt;\n)}\n&lt;/Content&gt;\n\n&lt;Modal\n    title=\"Incomplete Tasks\"\n    visible={isModalOpen}\n    onOk={handleOk}\n    onCancel={handleCancel}\n    footer={null}\n&gt;\n    &lt;Form form={formToday}&gt;\n        {data.items.filter(item =&gt; item.statusName !== \"Completed\").map(item =&gt; (\n            &lt;div key={item.id}&gt;\n                &lt;h3&gt;{item.title}&lt;/h3&gt;\n                &lt;p&gt;{item.remarks}&lt;/p&gt;\n                &lt;Form.Item\n                    name={`remarks_${item.id}`}\n                    label=\"Remarks\"\n                    rules={[{ required: true, message: 'Please enter remarks' }]}\n                &gt;\n                    &lt;Input.TextArea rows={4} defaultValue={item.remarks} /&gt;\n                &lt;/Form.Item&gt;\n            &lt;/div&gt;\n        ))}\n    &lt;/Form&gt;\n&lt;/Modal&gt;\n</code></pre> <ol> <li> <p><code>handleTodaySaveDiary</code> Function:</p> <ul> <li>Filters <code>data.items</code> to find objects where <code>statusName</code> is not \"Completed\".</li> <li>If there are any such objects, it opens the modal by setting <code>setIsModalOpen(true)</code>.</li> <li>Otherwise, it logs that all items are completed and the modal doesn't open.</li> </ul> </li> <li> <p>Modal Rendering:</p> <ul> <li>Inside the modal, we map over the filtered items (those that are not completed) and display the <code>title</code> and a <code>TextArea</code> input field pre-filled with the current <code>remarks</code>.</li> </ul> </li> </ol> <p>This way, you ensure that the modal only opens when there are incomplete tasks, and it provides an interface for the user to edit the <code>remarks</code> for those tasks.</p> <pre><code>const handleOk = () =&gt; {\n    // Submit the form when Ok is clicked\n    formToday.submit();\n};\n\nconst handleCancel = () =&gt; {\n    formToday.resetFields();\n    setIsModalOpen(false);\n};\n\nconst handleOnFinishFormModal = (values) =&gt; {\n    // Log the form values on form submission\n    console.log(\"Form Values Submitted: \", values);\n\n    // Close the modal after successful submission\n    setIsModalOpen(false);\n};\n</code></pre> Explanation: <ol> <li> <p>onFinish: This function (<code>handleOnFinishFormModal</code>) will be triggered when the form is successfully submitted. The submitted form values are captured in the <code>values</code> parameter.</p> </li> <li> <p>formToday.submit(): Inside <code>handleOk()</code>, calling <code>formToday.submit()</code> ensures that the form submission is triggered when the \"Ok\" button is clicked in the modal.</p> </li> <li> <p>footer={null}: Removed the default footer of the modal to prevent the default \"Ok\" and \"Cancel\" buttons, ensuring you have full control over when the form is submitted.</p> </li> </ol> <p>With this setup, when the modal is open, and the user fills in the remarks and clicks \"Ok,\" the form values will be logged to the console, and you can handle them as needed.</p> <pre><code>if (InomplteStatusItems.length &gt; 0) {\n    // Open the modal\n    setIsModalOpen(true);\n\n    //\n    const initialFormValues = {};\n    InomplteStatusItems.forEach(item =&gt; {\n        initialFormValues[`remarks_${item.id}`] = item.remarks || '';  // Set initial remarks or empty if not available\n    });\n    formToday.setFieldsValue(initialFormValues);\n} else {\n    // All items are completed, do not open the modal\n    console.log(\"All items are completed, no modal needed\");\n}\n</code></pre>"},{"location":"frontend/js/core/js-exception-handling/#reference","title":"Reference","text":"<ul> <li>Control flow and error handling: developer.mozilla</li> <li>JavaScript Errors: w3schools</li> </ul>"},{"location":"frontend/js/core/topic/","title":"Topic","text":"<p>Mastering JavaScript requires a deep understanding of both its fundamental concepts and advanced topics. Here are some key areas to focus on, along with some hidden depths you should explore:</p>"},{"location":"frontend/js/core/topic/#core-concepts","title":"Core Concepts","text":"<ol> <li> <p>Data Types and Structures</p> <ul> <li>Primitive types and their behavior.</li> <li>Objects, arrays, and their methods.</li> <li>Map and Set objects.</li> </ul> </li> <li> <p>Functions</p> <ul> <li>Function declarations, expressions, and arrow functions.</li> <li>Scope, closures, and lexical scoping.</li> <li>Higher-order functions and callbacks.</li> <li>The <code>this</code> keyword and context binding.</li> </ul> </li> <li> <p>Asynchronous Programming</p> <ul> <li>Callbacks, promises, and async/await.</li> <li>Event loop and concurrency model.</li> <li>Error handling in asynchronous code.</li> </ul> </li> </ol>"},{"location":"frontend/js/core/topic/#advanced-topics","title":"Advanced Topics","text":"<ol> <li> <p>Prototypes and Inheritance</p> <ul> <li>Prototypal inheritance and the prototype chain.</li> <li>ES6 class syntax and how it relates to prototypes.</li> <li><code>Object.create</code> and inheritance patterns.</li> </ul> </li> <li> <p>Execution Context and Hoisting</p> <ul> <li>Execution context and the call stack.</li> <li>Variable and function hoisting.</li> <li>Temporal dead zone (TDZ) with <code>let</code> and <code>const</code>.</li> </ul> </li> <li> <p>Closures and Lexical Scope</p> <ul> <li>Understanding closures and their applications.</li> <li>Practical uses of closures in module patterns and function factories.</li> </ul> </li> <li> <p>Modules and Module Bundlers</p> <ul> <li>ES6 modules: import and export.</li> <li>Module patterns in older JavaScript (CommonJS, AMD).</li> <li>Using module bundlers like Webpack, Parcel, and Rollup.</li> </ul> </li> <li> <p>Event Handling and DOM Manipulation</p> <ul> <li>Event delegation and propagation (bubbling and capturing).</li> <li>Modern DOM APIs and manipulation techniques.</li> <li>Understanding and handling browser events.</li> </ul> </li> </ol>"},{"location":"frontend/js/core/topic/#deep-dive-topics","title":"Deep Dive Topics","text":"<ol> <li> <p>Memory Management and Performance</p> <ul> <li>Garbage collection and memory leaks.</li> <li>Optimizing performance: profiling and benchmarking.</li> <li>Understanding V8 engine optimizations.</li> </ul> </li> <li> <p>Design Patterns</p> <ul> <li>Common JavaScript design patterns (e.g., Singleton, Factory, Observer).</li> <li>Applying design patterns to real-world problems.</li> </ul> </li> <li> <p>Type Systems and Type Checking</p> <ul> <li>Dynamic vs. static typing.</li> <li>Using TypeScript for type safety.</li> <li>Flow and other type checkers.</li> </ul> </li> <li> <p>Testing</p> <ul> <li>Unit testing, integration testing, and end-to-end testing.</li> <li>Popular testing frameworks (<code>Jest</code>, <code>Mocha</code>, <code>Chai</code>, <code>Cypress</code>).</li> <li>Test-driven development (TDD) practices.</li> </ul> </li> <li> <p>Tooling and Build Processes</p> <ul> <li>Modern JavaScript tooling: ESLint, Prettier, Babel.</li> <li>Setting up and configuring build processes with tools like Webpack.</li> <li>Continuous integration and deployment (CI/CD) for JavaScript projects.</li> </ul> </li> </ol>"},{"location":"frontend/js/core/topic/#hidden-depths","title":"Hidden Depths","text":"<ol> <li> <p>Symbol and Meta-programming</p> <ul> <li>Using symbols to create unique property keys.</li> <li>Understanding well-known symbols and their uses.</li> <li>Proxy objects and the Reflect API for metaprogramming.</li> </ul> </li> <li> <p>Iterators and Generators</p> <ul> <li>Custom iterators and the iterable protocol.</li> <li>Generator functions and the yield keyword.</li> <li>Using generators for asynchronous control flow.</li> </ul> </li> <li> <p>Concurrency and Parallelism</p> <ul> <li>Web Workers for parallel processing.</li> <li>Understanding and using SharedArrayBuffer and Atomics.</li> <li>Concurrency models in JavaScript.</li> </ul> </li> <li> <p>Advanced Asynchronous Patterns</p> <ul> <li>Async iterators and generators.</li> <li>Using <code>Promise.all</code>, <code>Promise.race</code>, and <code>Promise.allSettled</code>.</li> <li>Managing complex async workflows with libraries like RxJS.</li> </ul> </li> <li> <p>Understanding the Event Loop and Microtasks</p> <ul> <li>Detailed workings of the event loop.</li> <li>Difference between macro-tasks and micro-tasks.</li> <li>Practical implications for writing efficient asynchronous code.</li> </ul> </li> </ol>"},{"location":"frontend/js/core/topic/#practical-application","title":"Practical Application","text":"<ul> <li>Building Projects: Apply what you learn by building real-world projects.</li> <li>Contributing to Open Source: Contribute to JavaScript libraries and frameworks.</li> <li>Reading and Understanding Source Code: Study the source code of popular libraries and frameworks.</li> </ul> <p>Mastering JavaScript is a journey that involves both understanding the theory and applying it in practical scenarios. By delving into these topics, you will gain a comprehensive and deep understanding of JavaScript, enabling you to write efficient, maintainable, and robust code.</p> Abstract <p>To gain a deep understanding of JavaScript, the main approach is to focus on mastering its core concepts and advanced features. Here's a structured plan to achieve that:</p> <ol> <li> <p>Fundamentals:</p> <ul> <li>Variables and Data Types: Understand var, let, const, and data types (number, string, boolean, object, undefined, null).</li> <li>Functions: Learn about function declarations, expressions, arrow functions, and IIFE (Immediately Invoked Function Expressions).</li> <li>Control Structures: Master if statements, loops (for, while, do-while), and switch statements.</li> </ul> </li> <li> <p>Advanced Concepts:</p> <ul> <li>Closures: Understand how closures work and how they enable functions to have private variables.</li> <li>Prototypes and Inheritance: Learn about prototype chains, inheritance models, and how to create objects using constructor functions and class syntax.</li> <li>Asynchronous Programming: Master callbacks, promises, async/await, and event loop mechanisms.</li> <li>Scope and Hoisting: Understand the scope (global, local, block) and hoisting behaviors in JavaScript.</li> </ul> </li> <li> <p>JavaScript in the Browser:</p> <ul> <li>DOM Manipulation: Learn how to select, traverse, and manipulate DOM elements.</li> <li>Event Handling: Understand how to handle user interactions and events.</li> <li>Browser APIs: Explore key browser APIs like fetch, localStorage, and sessionStorage.</li> </ul> </li> <li> <p>Modern JavaScript (ES6+):</p> <ul> <li>Learn new syntax and features introduced in ES6 and later versions, including template literals, destructuring, spread/rest operators, modules, and enhanced object literals.</li> </ul> </li> <li> <p>Tooling and Ecosystem:</p> <ul> <li>Node.js: Understand server-side JavaScript and how to build backend applications with Node.js.</li> <li>Build Tools: Learn about build tools like Webpack, Babel, and task runners like Gulp or Grunt.</li> <li>Testing: Master JavaScript testing frameworks like Jest, Mocha, or Jasmine.</li> </ul> </li> <li> <p>Best Practices:</p> <ul> <li>Code Organization: Learn how to write modular, maintainable, and reusable code.</li> <li>Performance Optimization: Understand techniques for optimizing JavaScript performance.</li> <li>Security: Learn common security practices to prevent vulnerabilities like XSS and CSRF.</li> </ul> </li> <li> <p>Projects and Real-world Applications:</p> <ul> <li>Build projects that challenge you to apply what you've learned.</li> <li>Contribute to open-source projects or collaborate on team projects to gain practical experience.</li> </ul> </li> </ol> <p>By systematically studying these areas, practicing through projects, and keeping up with the latest advancements in JavaScript, you'll be able to develop a deep and comprehensive understanding of the language.</p>"},{"location":"frontend/js/datatypes/data-types/","title":"Data Type","text":""},{"location":"frontend/js/datatypes/data-types/#data-types-in-js","title":"Data Types in JS","text":"<p>In JavaScript, while many things are objects, not everything is an object. JavaScript has a variety of data types, and understanding which are objects and which are not is important for grasping the language's structure.</p>"},{"location":"frontend/js/datatypes/data-types/#javascript-data-types","title":"JavaScript Data Types","text":"<p>JavaScript has both primitive data types and objects.</p>"},{"location":"frontend/js/datatypes/data-types/#primitive-data-types","title":"Primitive Data Types","text":"<p>primitive</p> <p>Primitive data types are not objects and do not have properties or methods. They are immutable and are directly assigned and manipulated.</p> <ol> <li> <p>Number: Represents both integer and floating-point numbers.</p> <pre><code>let num = 42;\n</code></pre> </li> <li> <p>String: Represents a sequence of characters.</p> <pre><code>let str = \"Hello, world!\";\n</code></pre> </li> <li> <p>Boolean: Represents a logical entity with two values: <code>true</code> and <code>false</code>.</p> <pre><code>let bool = true;\n</code></pre> </li> <li> <p>Null: Represents the intentional absence of any object value.</p> <pre><code>let nullValue = null;\n</code></pre> </li> <li> <p>Undefined:: Represents a variable that has been declared but not assigned a value.</p> <pre><code>let undefinedValue;\n</code></pre> </li> <li> <p>Symbol: Represents a unique and immutable identifier.</p> <pre><code>let sym = Symbol('description');\n</code></pre> </li> <li> <p>BigInt: Represents integers with arbitrary precision.</p> <pre><code>let bigInt = 1234567890123456789012345678901234567890n;\n</code></pre> </li> </ol>"},{"location":"frontend/js/datatypes/data-types/#objects","title":"Objects","text":"<p>Object</p> <p>Objects are collections of properties and are more complex. <code>Arrays</code>, <code>functions</code>, and <code>objects</code> created using the Object constructor or object literals are examples of objects.</p> <ol> <li> <p>Object: General-purpose containers for named properties.</p> <pre><code>let obj = { key: 'value' };\n</code></pre> </li> <li> <p>Array: Ordered lists of values.</p> <pre><code>let arr = [1, 2, 3];\n</code></pre> </li> <li> <p>Function: Callable objects.</p> <pre><code>function func() { return 'Hello!'; }\n</code></pre> </li> <li> <p>Date: Represents dates and times.</p> <pre><code>let date = new Date();\n</code></pre> </li> <li> <p>RegExp: Represents regular expressions.</p> <pre><code>let regex = /abc/;\n</code></pre> </li> <li> <p>Map: Key-value pairs where keys can be of any type.</p> <pre><code>let map = new Map();\n</code></pre> </li> <li> <p>Set: Collections of unique values.</p> <pre><code>let set = new Set();\n</code></pre> </li> </ol>"},{"location":"frontend/js/datatypes/data-types/#why-not-everything-is-an-object","title":"Why Not Everything is an Object","text":"<p>Primitive types are not objects because they are meant to be simple and efficient. They are stored directly in memory rather than by reference, which allows for faster access and manipulation. For example, mathematical operations on numbers or string manipulations are faster because these operations do not involve object overhead. Wrappers for Primitives</p> <p>JavaScript automatically provides temporary objects, known as wrapper objects, when methods or properties are accessed on primitive values. These objects allow primitives to behave like objects in certain contexts.</p> <pre><code>let str = \"hello\";\nconsole.log(str.toUpperCase()); // \"HELLO\"\n</code></pre> <p>In this example, <code>str</code> is a primitive string, but JavaScript temporarily wraps it in a <code>String</code> object to call the <code>toUpperCase</code> method.</p>"},{"location":"frontend/js/datatypes/data-types/#summary","title":"Summary","text":"<ul> <li>Primitive Types: <code>Number</code>, <code>String</code>, <code>Boolean</code>, <code>Null</code>, <code>Undefined</code>, <code>Symbol</code>, <code>BigInt</code>. Not objects, immutable, and have no properties or methods directly.</li> <li>Objects: More complex structures including plain <code>objects</code>, <code>arrays</code>, <code>functions</code>, etc. Have properties and methods and are stored by reference.</li> </ul> <p>While JavaScript provides a unified and flexible approach to handling various data types, understanding the distinction between primitives and objects is crucial for effective programming in JavaScript.</p>"},{"location":"frontend/js/datatypes/data-types/#autoboxing","title":"Autoboxing","text":"<p><code>autoboxing in javascript</code></p> <p>In JavaScript, when you attempt to access a property or method on a primitive value, the language automatically wraps the primitive in a temporary object so that you can use the properties and methods that are typically available on objects. This process is known as autoboxing. Here\u2019s a detailed explanation of how this works:</p>"},{"location":"frontend/js/datatypes/data-types/#how-javascript-wraps-primitives","title":"How JavaScript Wraps Primitives","text":"<ol> <li> <p>Autoboxing: When you try to access a method or property on a primitive value, JavaScript temporarily converts (or \"boxes\") the primitive value into an object.</p> <pre><code>let str = \"hello\";\nconsole.log(str.toUpperCase()); // \"HELLO\"\n</code></pre> </li> </ol> <p>Here's what happens behind the scenes:</p> <ul> <li>JavaScript sees that you're calling <code>toUpperCase()</code> on the str variable, which is a string primitive.</li> <li>It creates a temporary <code>String</code> object from the primitive value \"hello\".</li> <li>It calls the toUpperCase method on this temporary <code>String</code> object.</li> <li>The method returns the result (\"HELLO\").</li> <li>The temporary <code>String</code> object is discarded.</li> </ul>"},{"location":"frontend/js/datatypes/data-types/#steps-involved","title":"Steps Involved","text":"<ol> <li> <p>Primitive Detection: When you try to access a property or method on a primitive value, the JavaScript engine checks the type of the value.</p> <ul> <li>If the value is a primitive type (<code>string</code>, <code>number</code>, <code>boolean</code>, <code>symbol</code>, <code>bigint</code>), the engine understands that it needs to provide access to the methods and properties that are defined on the corresponding wrapper objects (<code>String</code>, <code>Number</code>, <code>Boolean</code>, <code>Symbol</code>, <code>BigInt</code>).</li> </ul> </li> <li> <p>Temporary Object Creation: The JavaScript engine creates a temporary object of the corresponding wrapper type.</p> <ul> <li>For a string, it creates a <code>String</code> object.</li> <li>For a number, it creates a <code>Number</code> object.</li> <li>For a boolean, it creates a <code>Boolean</code> object.</li> <li>For a symbol, it creates a <code>Symbol</code> object.</li> <li>For a bigint, it creates a <code>BigInt</code> object.</li> </ul> </li> <li> <p>Method/Property Access: The engine uses this temporary object to access the desired method or property.</p> <ul> <li>In the case of \"hello\".toUpperCase(), it creates a <code>String</code> object and calls the <code>toUpperCase</code> method on it.</li> </ul> </li> <li> <p>Result Return and Discarding Temporary Object: The result of the method or property access is returned, and the temporary object is discarded.</p> <ul> <li>The temporary <code>String</code> object is no longer needed after the <code>toUpperCase</code> method is called, so it is discarded.</li> </ul> </li> </ol> <p>--</p>"},{"location":"frontend/js/datatypes/data-types/#example-in-detail","title":"Example in Detail","text":"<p>Here\u2019s a more detailed breakdown of the example:</p> <pre><code>let str = \"hello\";\nconsole.log(str.toUpperCase()); // \"HELLO\"\n</code></pre> <ol> <li>Primitive Detection: The JavaScript engine sees that str is a primitive string.</li> <li> <p>Temporary Object Creation: The engine creates a temporary String object that represents the value \"hello\".</p> <pre><code>let tempStrObj = new String(\"hello\");\n</code></pre> </li> <li> <p>Method/Property Access: The engine calls the <code>toUpperCase</code> method on the <code>tempStrObj</code> object.</p> <pre><code>let result = tempStrObj.toUpperCase(); // \"HELLO\"\n</code></pre> </li> <li> <p>Result Return and Discarding Temporary Object: The engine returns the result (\"HELLO\") and discards the temporary <code>String</code> object.</p> </li> </ol>"},{"location":"frontend/js/datatypes/data-types/#summary_1","title":"Summary","text":"<ul> <li>JavaScript uses autoboxing to wrap primitive values in temporary objects when you try to access properties or methods on them.</li> <li>The engine checks the type of the value and creates a corresponding wrapper object (<code>String</code>, <code>Number</code>, <code>Boolean</code>, <code>Symbol</code>, <code>BigInt</code>).</li> <li>After accessing the property or method, the result is returned, and the temporary object is discarded.</li> </ul> <p>This mechanism allows primitive values to behave like objects when needed, providing a seamless and flexible programming experience.</p>"},{"location":"frontend/js/datatypes/data-types/#reference","title":"Reference","text":"<ul> <li>Autoboxing in JavaScript</li> </ul>"},{"location":"frontend/js/datatypes/intro/","title":"Intro","text":"<p>In JavaScript, objects and arrays are reference types. This means when you assign an object or array to a variable, that variable doesn't hold the actual data but instead holds a reference (or pointer) to the original object or array in memory.</p> <p>In React, the most efficient way to detect whether a value has changed is by comparing the reference of the value, not the value itself (for non-primitive types like arrays and objects).</p> Key Concept: <ul> <li>Primitive types: (e.g., <code>number</code>, <code>string</code>, <code>boolean</code>) are compared by value.</li> <li>Reference types: (e.g., <code>array</code>, <code>object</code>) are compared by reference.</li> </ul> <p>In React, you can use shallow comparison (comparing the references) to check if something has changed, and React will re-render when the reference changes.</p> Shallow vs Deep Comparison <ul> <li> <p>Shallow Comparison: Compares only the references for objects and arrays. This is how React determines whether a state change has occurred, by comparing the <code>reference</code> of the previous and new state.</p> </li> <li> <p>Deep Comparison: Compares the actual contents of objects or arrays, which is more expensive computationally and generally not needed in React.</p> </li> </ul> <p>For React, shallow comparison is used by default. When you update state by creating a new reference (new object or array), React will re-render the component.</p>"},{"location":"frontend/js/datatypes/intro/#what-are-javascript-data-types-interview","title":"What are JavaScript data types? INTERVIEW","text":"<p>In JavaScript, there are <code>three</code> primary data types, <code>two</code> composite data types, and <code>two</code> special data types.</p> <p>Primary Data Types</p> <ul> <li>String</li> <li>Number</li> <li>Boolean</li> </ul> <p>Composite Data Types</p> <ul> <li>Object</li> <li>Array</li> </ul> <p>Special Data Types</p> <ul> <li>Null</li> <li>Undefined</li> </ul> <p>pg: 6. JavaScript Interview Questions by Fabio Cimo</p>"},{"location":"frontend/js/datatypes/intro/#related-blogs","title":"Related Blogs","text":"<ul> <li>State Immutability</li> </ul>"},{"location":"frontend/js/datatypes/state-immutability/","title":"Immutability","text":""},{"location":"frontend/js/datatypes/state-immutability/#state-immutability-in-javascript","title":"State Immutability in JavaScript","text":"<p>Immutability refers to the concept that once an object or data structure is created, it cannot be changed. Instead of directly modifying the original object, a new copy of the object is created with the updated values. This principle is critical in both JavaScript and React for ensuring that your code works predictably and efficiently, especially when it comes to state management.</p> <p>Immutability in JavaScript</p> <p>In JavaScript, objects and arrays are mutable by default, meaning that you can modify them directly (e.g., change a property of an object or append to an array). However, immutability means you should avoid direct modifications. For example:</p> <ul> <li> <p>Mutable Operation (Not Immutable):</p> <pre><code>let obj = { name: \"John\" };\nobj.name = \"Jane\"; // Direct modification\n</code></pre> </li> <li> <p>Immutable Operation (Using Immutability):</p> <pre><code>let obj = { name: \"John\" };\nobj = { ...obj, name: \"Jane\" }; // Create a new object with updated values\n</code></pre> </li> </ul> <p>Instead of directly modifying <code>obj</code>, you create a new object with the updated properties. This ensures that the original object remains unchanged.</p>"},{"location":"frontend/js/datatypes/state-immutability/#how-to-identify-mutable-vs-immutable-methods","title":"How to Identify Mutable vs Immutable Methods","text":""},{"location":"frontend/js/datatypes/state-immutability/#1-arrays","title":"1. Arrays","text":"<p>Mutable methods (modify the array directly):</p> <ul> <li><code>push()</code>: Adds elements to the end of an array.</li> <li><code>pop()</code>: Removes the last element.</li> <li><code>shift()</code>: Removes the first element.</li> <li><code>unshift()</code>: Adds elements to the beginning.</li> <li><code>splice()</code>: Removes or replaces elements at a specific index.</li> </ul> <p>These methods change the original array.</p> <pre><code>let arr = [1, 2, 3];\narr.push(4); // arr is now [1, 2, 3, 4] (mutated)\n</code></pre> <p>Immutable methods (return a new array):</p> <ul> <li><code>concat()</code>: Combines multiple arrays and returns a new array.</li> <li><code>slice()</code>: Returns a shallow copy of part of an array.</li> <li><code>map()</code>: Creates a new array by applying a function to each element.</li> <li><code>filter()</code>: Returns a new array containing elements that pass the test.</li> <li><code>reduce()</code>: Reduces an array to a single value, returning a new value.</li> <li><code>flat()</code>: Flattens nested arrays into a new array.</li> </ul> <p>These methods do not modify the original array; they return new arrays.</p> <pre><code>let arr = [1, 2, 3];\nlet newArr = arr.concat([4, 5]); // arr is unchanged, newArr is [1, 2, 3, 4, 5]\n</code></pre>"},{"location":"frontend/js/datatypes/state-immutability/#2-objects","title":"2. Objects","text":"<p>Mutable methods (modify the object directly):</p> <ul> <li> <p>Direct assignment: Assigning a new value to a property of an object mutates the object.</p> <pre><code>let obj = { name: \"Alice\" };\nobj.name = \"Bob\"; // This changes the original object\n</code></pre> </li> <li> <p><code>Object.assign()</code>: Copies properties from one object to another. This method is shallow and modifies the target object.</p> <pre><code>let obj1 = { name: \"Alice\" };\nlet obj2 = Object.assign({}, obj1, { age: 25 }); // obj1 is not modified, but obj2 is modified\n</code></pre> </li> </ul> <p>Immutable methods (create a new object):</p> <ul> <li> <p>Spread syntax (...): Creates a new object with the existing properties.</p> <pre><code>let obj = { name: \"Alice\", age: 25 };\nlet newObj = { ...obj, name: \"Bob\" }; // newObj is created with modified property\n</code></pre> </li> <li> <p>Object.freeze(): This method makes an object immutable by preventing modification of its properties. However, it\u2019s a shallow freeze, meaning nested objects can still be changed.</p> <pre><code>const obj = { name: \"Alice\" };\nconst newObj = { ...obj, age: 25 }; // newObj is created, obj is unchanged\n</code></pre> </li> </ul>"},{"location":"frontend/js/datatypes/state-immutability/#3-strings","title":"3. Strings","text":"<p>Strings are immutable in JavaScript, meaning you can\u2019t change a character in the string once it is created. However, many string methods return new strings based on the original one.</p> <p>Immutable string methods:</p> <ul> <li> <p>substring(), slice(), replace(), toUpperCase(), toLowerCase(), etc., all return new strings without modifying the original.</p> <pre><code>let str = \"hello\";\nlet newStr = str.toUpperCase(); // newStr is 'HELLO', str is unchanged\n</code></pre> </li> </ul> <p>Is There a Simple Rule?</p> <p>Yes, here's a simplified rule:</p> <ul> <li>If the method modifies the original object/array/variable, it is mutable.</li> <li>If the method returns a new version (copy) of the data without changing the original, it is immutable.</li> </ul> <p>Common Patterns to Recognize Mutable/Immutable Methods</p> <ol> <li>Methods that change data in-place (like <code>push()</code>, <code>pop()</code>, <code>shift()</code>, <code>unshift()</code>, <code>splice()</code> for arrays) are mutable.</li> <li>Methods that return a new version of data (like <code>concat()</code>, <code>slice()</code>, <code>map()</code>, <code>filter()</code> for arrays) are immutable.</li> <li>Direct assignment to properties (like <code>obj.property = value</code>) is mutable.</li> <li>Methods that create new objects or arrays (like <code>Object.assign()</code>, spread syntax <code>{ ...obj }</code>) are usually immutable.</li> </ol> <p>Summary</p> <ul> <li>Immutability ensures that you don\u2019t accidentally change the state/data, making your code more predictable and easier to debug.</li> <li>Mutable methods modify the original data directly.</li> <li>Immutable methods return new copies of the data, leaving the original data intact.</li> <li>To identify if a method is mutable or immutable, check if it directly modifies the data (mutable) or returns a new copy of the data (immutable).</li> </ul>"},{"location":"frontend/js/datatypes/state-immutability/#why-immutability-is-important","title":"Why Immutability is Important","text":"<p>Let me explain immutability in simpler terms and how it affects the way you write code in JavaScript, especially in frameworks like React. What Does Immutability Mean?</p> <p>Immutability means that once a value is created, it cannot be changed. Instead of changing the original value (like an object or array), you create a new value with the changes.</p>"},{"location":"frontend/js/datatypes/state-immutability/#related-blogs","title":"Related Blogs","text":"<ul> <li>State Immutability</li> </ul>"},{"location":"frontend/js/datatypes/state-immutability/#blog","title":"Blog","text":"<ul> <li>Libraries for Immutable Data Structure in React</li> </ul>"},{"location":"frontend/js/definition/definition/","title":"Intro","text":"<p>A literal is syntax that allows you to define a reference value without explicitly creating an object, using the <code>new</code> operator and the object\u2019s constructor.</p> <ul> <li> The Principles of Object-Oriented JavaScript by Nicholas C. Zakas: Literal Forms: pg-9</li> </ul> Tip <p>What Are Types?</p> <p>Although JavaScript has no concept of classes, it still uses two kinds of types: primitive and reference.</p> <ul> <li>Primitive types are stored as simple data types.</li> <li>Reference types are stored as objects, which are really just references to locations in memory.</li> </ul> <p>The tricky thing is that JavaScript lets you treat primitive types like reference types in order to make the language more consistent for the developer.</p> <p>While other programming languages distinguish between primitive and reference types by storing <code>primitives</code> on the stack and <code>references</code> in the heap, JavaScript does away with this concept completely: It tracks variables for a particular scope with a variable object. Primitive values are stored directly on the variable object, while reference values are placed as a pointer in the variable object, which serves as a reference to a location in memory where the object is stored.</p> <p>However, as you\u2019ll see later in this chapter, primitive values and reference values behave quite differently although they may initially seem the same.</p> <ul> <li> The Principles of Object-Oriented JavaScript by Nicholas C. Zakas: Literal Forms: pg-2</li> </ul> <p>Dereferencing Objects</p> <p>JavaScript is a garbage-collected language, so you don\u2019t really need to worry about memory allocations when you use reference types. However,</p> <p>it\u2019s best to dereference objects that you no longer need so that the garbage collector can free up that memory. The best way to do this is to set the object variable to <code>null</code>.</p> <pre><code>var object1 = new Object();\n\n// do something\n\nobject1 = null; // dereference\n</code></pre> <ul> <li> The Principles of Object-Oriented JavaScript by Nicholas C. Zakas: Literal Forms: pg-7</li> </ul>"},{"location":"frontend/js/definition/definition/#js-data-types","title":"JS Data Types","text":"<p>Primitive data types</p> <ol> <li>Number</li> <li>String</li> <li>Boolean</li> <li>Undefined <code>special type</code></li> <li>Null <code>special type</code></li> </ol> <p>Any value that doesn't belong to one of the five primitive types listed here is an <code>object</code>. Even <code>null</code> is considered an <code>object</code>, which is a little awkward\u2014having an object (something) that is actually nothing.</p> <p>just remember that in JavaScript the data types are either:</p> <ul> <li>Primitive (the <code>five types</code> listed previously)</li> <li>Non-primitive (<code>objects</code>)</li> </ul> <p>Finding out the value type \u2013 the typeof operator</p> <p>If you want to know the type of a variable or a value, you use the special typeof operator. This operator returns a string that represents the data type. The return values of using typeof are one of the following:</p> <ul> <li>\"number\"</li> <li>\"string\"</li> <li>\"boolean\"</li> <li>\"undefined\"</li> <li>\"object\"</li> <li>\"function\"</li> </ul> <p>Javascript: Object Oriented Programming: 2016 Packt Publishing, pg- 500</p> Primitive data types recap <p>There are five primitive data types in JavaScript:</p> <ul> <li>Number</li> <li>String</li> <li>Boolean</li> <li>Undefined</li> <li>Null</li> </ul> <p>Everything that is not a primitive data type is an <code>object</code></p> <ul> <li>Javascript: Object Oriented Programming: 2016 Packt Publishing, pg- 509</li> </ul>"},{"location":"frontend/js/definition/definition/#loops","title":"Loops","text":"<p>In JavaScript, there are four types of loops:</p> <ul> <li>while loops</li> <li>do-while loops</li> <li>for loops</li> <li>for-in loops</li> </ul> Note <ul> <li> <p>for is the most widely used type of loop</p> </li> <li> <p>The for-in loop is used to iterate over the elements of an array (or an object).</p> </li> </ul> <p>as for-in is mostly suitable for objects, and the regular for loop should be used for arrays.</p> <p>Javascript: Object Oriented Programming: 2016 Packt Publishing, pg- 528</p>"},{"location":"frontend/js/definition/definition/#hashes-and-associative-arrays","title":"Hashes and associative arrays","text":"<p>In some programming languages, there is a distinction between:</p> <ul> <li>A regular array, also called an indexed or enumerated array (the <code>keys</code> are numbers)</li> <li>An associative array, also called a hash or a dictionary (the <code>keys</code> are strings)</li> </ul> <p>JavaScript uses arrays to represent indexed arrays and objects to represent associative arrays. If you want a hash in JavaScript, you use an object.</p>"},{"location":"frontend/js/definition/definition/#accessing-an-objects-properties","title":"Accessing an object's properties","text":"<p>There are two ways to access a property of an object:</p> <ul> <li>Using the <code>square bracket notation</code>, for example <code>hero['occupation']</code></li> <li>Using the <code>dot notation</code>, for example <code>hero.occupation</code></li> </ul>"},{"location":"frontend/js/definition/definition/#the-instanceof-operator","title":"The <code>instanceof</code> operator","text":"<p>With the instanceof operator, you can test if an object was created with a specific constructor function:</p> <pre><code>&gt; function Hero() {}\n&gt; var h = new Hero();\n&gt; var o = {};\n&gt; h instanceof Hero;\ntrue\n&gt; h instanceof Object;\ntrue\n&gt; o instanceof Object;\ntrue\n</code></pre> <p>Note that you don't put parentheses after the function name (you don't use <code>h instanceof Hero()</code>). This is because you're not invoking this function, but just referring to it by name, as with any other variable.</p>"},{"location":"frontend/js/definition/definition/#null","title":"Null","text":"<p>Conceptual overview of using the <code>null</code> value</p> <p>You can use <code>null</code> to explicitly indicate that an object property does not contain a value.</p> <p>Typically, if a property is set up to contain a value, but the value is not available for some reason, the value <code>null</code> should be used to indicate that the reference property has an empty value.</p> <pre><code>// The property foo is waiting for a value, so we set its initial value\nto null.\nvar myObjectObject = { foo: null };\nconsole.log(myObjectObject.foo); // Logs 'null\n</code></pre> <p><code>typeof</code> returns <code>null</code> values as \"object\"</p> <p>For a variable that has a value of <code>null</code>, the <code>typeof</code> operator returns \"object\u201d. If you need to verify a <code>null</code> value, the ideal solution would be to see if the value you are after is equal to <code>null</code>.</p> <p>In the following sample, we use the <code>===</code> operator to specifically verify that we are dealing with a null value.</p> <pre><code>var myObject = null;\nconsole.log(typeof myObject); // Logs 'object', not exactly helpful.\nconsole.log(myObject === null); // Logs true, only for a real null value.\n</code></pre> Note <p>When verifying a <code>null</code> value, always use <code>===</code> because <code>==</code> does not distinguish between <code>null</code> and <code>undefined</code>.</p> <ul> <li>JavaScript Succinctly by Cody Lindley - 68</li> </ul>"},{"location":"frontend/js/definition/definition/#undefined","title":"Undefined","text":"<p>Conceptual overview of the undefined value</p> <p>The undefined value is used by JavaScript in two slightly different ways.</p> <ul> <li>The first way it's used is to indicate that a declared variable (e.g., var foo) has no assigned value.</li> <li>The second way it's used is to indicate that an object property you\u2019re trying to access is not defined (i.e. it has not even been named), and is not found in the prototype chain.</li> </ul> <pre><code>var initializedVariable; // Declare variable.\n\nconsole.log(initializedVariable); // Logs undefined.\nconsole.log(typeof initializedVariable); // Confirm that JavaScript returns undefined.\n\nvar foo = {};\n\nconsole.log(foo.bar); // Logs undefined, no bar property in foo object.\nconsole.log(typeof foo.bar); // Confirm that JavaScript returns undefined.\n</code></pre> Note <p>It is considered good practice to allow JavaScript alone to use <code>undefined</code>. You should never find yourself setting a value to <code>undefined</code>, as in foo = undefined. Instead, <code>null</code> should be used if you are specifying that a property or variable value is not available.</p> <ul> <li>JavaScript Succinctly by Cody Lindley - 69</li> </ul>"},{"location":"frontend/js/definition/definition/#primitive-values","title":"Primitive values","text":"<p>Primitive/literal values are converted to objects when properties are accessed</p> <p>Do not be mystified by the fact that <code>string</code>, <code>number</code>, and <code>Boolean</code> literals can be treated like an object with properties (e.g., <code>true.toString()</code>). When these primitive values are treated like objects by attempting to access their properties, JavaScript will create a wrapper object from the primitive\u2019s associated constructor, so that the properties and methods of the wrapper object can be accessed. Once the properties have been accessed, the wrapper object is discarded. This conversion allows us to write code that would make it appear as if a primitive value was, in fact, an object. Truth be told, when it is treated like an object in code, JavaScript will convert it to an object so property access will work, and then convert it back to a primitive value once a value is returned. The key thing to notice here is what is occurring, and that JavaScript is doing this for you behind the scenes.</p> <pre><code>// String object treated like an object.\nvar stringObject = new String(\"foo\");\n\nconsole.log(stringObject.length); // Logs 3.\nconsole.log(stringObject[\"length\"]); // Logs 3.\n// String literal/primitive converted to an object when treated as an object.\n\nvar stringLiteral = \"foo\";\n\nconsole.log(stringLiteral.length); // Logs 3.\nconsole.log(stringLiteral[\"length\"]); // Logs 3.\nconsole.log(\"bar\".length); // Logs 3.\nconsole.log(\"bar\"[\"length\"]); // Logs 3.\n</code></pre> <ul> <li>JavaScript Succinctly by Cody Lindley - 65</li> </ul>"},{"location":"frontend/js/definition/definition/#the-headglobal-object","title":"The Head/Global Object","text":"<p>Conceptual overview of the head object</p> <p>JavaScript code itself must be contained within an object. For example, when crafting JavaScript code for a web browser environment, JavaScript is contained and executed within the window object. This window object is considered to be the \"head object,\" or sometimes confusingly referred to as \"the global object.\" All implementations of JavaScript require the use of a single head object.</p> <pre><code>var myStringVar = \"myString\";\nvar myFunctionVar = function () {};\nmyString = \"myString\";\nmyFunction = function () {};\n\nconsole.log(\"myStringVar\" in window); // Returns true.\nconsole.log(\"myFunctionVar\" in window); // Returns true.\nconsole.log(\"myString\" in window); // Returns true.\nconsole.log(\"myFunction\" in window); // Return true.\n</code></pre> Note <p>The head object is the highest scope/context available in a JavaScript environment.</p> <ul> <li>JavaScript Succinctly by Cody Lindley - 71</li> </ul>"},{"location":"frontend/js/definition/definition/#scope-and-closures","title":"Scope and Closures","text":"<p>Conceptual overview of JavaScript scope</p> <p>In JavaScript, scope is the context in which code is executed.</p> <p>There are three types of scope:</p> <ul> <li>global scope,</li> <li>local scope (sometimes referred to as \"function scope\"), &amp;</li> <li>eval scope.</li> </ul> <pre><code>var foo = \"bar\"; // foo is a global object and a property of the head/window object.\n\nvar myApp = function () {\n  // Remember functions create scope.\n  var run = (function () {\n    // Logs bar, foo's value is found via the scope chain in the head object.\n    console.log(foo);\n  })();\n};\n\nmyApp();\n</code></pre> <ul> <li>JavaScript Succinctly by Cody Lindley - 102</li> </ul>"},{"location":"frontend/js/definition/definition/#errors-in-javascript","title":"Errors in Javascript","text":"<p>Three kinds of errors can occur in JavaScript:</p> <ul> <li>syntax errors</li> <li>runtime errors</li> <li>logic errors</li> </ul> <p>Only the first two produce error messages.</p> Note <p>Syntax Errors</p> <p>A syntax error is caused when your code violates the fundamental rules (or syntax) of the JavaScript language. It\u2019s the browser\u2019s way of saying, \u201cWhatchoo talkin\u2019 \u2019bout,</p> <p>syntax errors are the easiest to fix, but the hardest to spot in your code.</p> <p>Runtime Errors</p> <p>Runtime errors occur when a perfectly valid piece of JavaScript code tries to do something that it\u2019s not allowed to do, or that is flat out impossible. These errors are so named because they occur while the script is actually running.</p> <p>The trick is figuring out why the error occurred.</p> <p>Logic Errors</p> <p>Logic errors aren\u2019t so much errors as they are bugs in your script. The code runs fine as it was written\u2014it just doesn\u2019t behave the way you expected it to when you wrote it. These kinds of errors can be devilishly difficult to find because as far as the browser\u2019s concerned the script is working just fine, so you never see an error message.</p> <p>Debugging with Firebug</p> <p>In the past, the most common approach to resolving logic errors in JavaScript code was liberal use of the <code>alert</code> function.</p> <p>At the time of writing, a much more powerful (not to mention sane) approach is to use a JavaScript debugger, and by far the best debugger around is <code>Firebug</code>. <code>Firebug</code> is a free extension for Firefox that adds to the browser a panel containing a rich set of tools for diagnosing problems with your HTML, CSS, and JavaScript.</p> <ul> <li>Simply JavaScript by Kevin Yank and Cameron Adams - 306</li> </ul>"},{"location":"frontend/js/definition/definition/#primitive-wrapper-types","title":"Primitive Wrapper Types","text":"<p>Perhaps one of the most confusing parts of JavaScript is the concept of primitive wrapper types.</p> <p>There are three primitive wrapper types</p> <ol> <li>String</li> <li>Number</li> <li>Boolean</li> </ol> <p>These special reference types exist to make working with primitive values as easy as working with objects.</p> <p>The primitive wrapper types are reference types that are automatically created behind the scenes whenever <code>strings</code>, <code>num\u00adbers</code>, or <code>Booleans</code> are read. For example, in the first line of this listing, a primitive string value is assigned to name. The second line treats name like an object and calls <code>charAt(0)</code> using dot notation.</p> <pre><code>var name = \"Nicholas\";\nvar firstChar = name.charAt(0);\nconsole.log(firstChar);\n</code></pre> <p>This is what happens behind the scenes:</p> <pre><code>// what the JavaScript engine does\nvar name = \"Nicholas\";\nvar temp = new String(name);\nvar firstChar = temp.charAt(0);\ntemp = null;\nconsole.log(firstChar); // \"N\"\n</code></pre> <p>Because the second line uses a string (a primitive) like an object, the JavaScript engine creates an instance of String so that charAt(0) will work. The String object exists only for one statement before it\u2019s destroyed (a process called autoboxing). To test this out, try adding a property to a string as if it were a regular object:</p> <pre><code>var name = \"Nicholas\";\nname.last = \"Zakas\";\nconsole.log(name.last); // undefined\n</code></pre> <p>This code attempts to add the property last to the string name. The code itself is just fine except that the property disappears. What happened? When working with regular objects, you can add properties at any time and they stay until you manually remove them. With primitive wrapper types, properties seem to disappear because the object on which the property was assigned is destroyed immediately afterward.</p> Here\u2019s what\u2019s actually happening in the JavaScript engine:<pre><code>// what the JavaScript engine does\nvar name = \"Nicholas\";\nvar temp = new String(name);\ntemp.last = \"Zakas\";\ntemp = null; // temporary object destroyed\n\nvar temp = new String(name);\nconsole.log(temp.last);\ntemp = null; // undefined\n</code></pre> <p>Instead of assigning a new property to a string, the code actually c\u00adreates a new property on a temporary object that is then destroyed. When you try to access that property later, a different object is temporarily created and the new property doesn\u2019t exist there. Although reference values are created automatically for primitive values, when <code>instanceof</code> checks for these types of values the result is false:</p> <pre><code>var name = \"Nicholas\";\nvar count = 10;\nvar found = false;\n\nconsole.log(name instanceof String); // false\nconsole.log(count instanceof Number); // false\nconsole.log(found instanceof Boolean); // false\n</code></pre> <p>The instanceof operator returns false because a temporary object is created only when a value is read. Because <code>instanceof</code> doesn\u2019t actually read anything, no temporary objects are created, and it tells us the \u00advalues aren\u2019t instances of primitive wrapper types. You can create primitive wrapper types manually, but there are certain side effects:</p> <pre><code>var name = new String(\"Nicholas\");\nvar count = new Number(10);\nvar found = new Boolean(false);\n\nconsole.log(typeof name); // \"object\"\nconsole.log(typeof count); // \"object\"\nconsole.log(typeof found); // \"object\"\n</code></pre> <p>As you can see, creating an instance of the primitive wrapper type just creates another object, which means that typeof can\u2019t identify the type of data you intend to store.</p> <p>Summary</p> <p>While JavaScript doesn\u2019t have classes, it does have types. Each variable or piece of data is associated with a specific primitive or reference type.</p> <p>The five primitive types (<code>strings</code>, <code>numbers</code>, <code>Booleans</code>, <code>null</code>, and <code>\u00adundefined</code>) represent simple values stored directly in the variable object for a given context. You can use <code>typeof</code> to identify primitive types with the exception of <code>null</code>, which must be compared directly against the special value null.</p> <p>Reference types are the closest thing to classes in JavaScript, and objects are <code>instances</code> of reference types. You can create new objects using the <code>new</code> operator or a reference literal.</p> <p>Functions are objects in JavaScript, and you can identify them with the <code>typeof</code> operator. You should use <code>instanceof</code> with a constructor to identify objects of any other reference type.</p> <p>To make primitives seem more like <code>references</code>, JavaScript has three primitive wrapper types: <code>String</code>, <code>Number</code>, and <code>Boolean</code>. JavaScript creates these objects behind the scenes so that you can treat primitives like regular objects, but the temporary objects are destroyed as soon as the statement using them is complete. Although you can create your own instances of primitive wrappers, it\u2019s best not to do that because it can be confusing.</p> <ul> <li> The Principles of Object-Oriented JavaScript by Nicholas C. Zakas: pg-14</li> </ul>"},{"location":"frontend/js/definition/definition/#design-patterns","title":"Design patterns","text":""},{"location":"frontend/js/definition/intro/","title":"What is","text":""},{"location":"frontend/js/definition/intro/#promise","title":"Promise","text":"<p>A promise is a token object the represents the future value or exception of a function that has not yet returned.</p> <p>Click link here for simple definition</p> <p>Promises offer a clean and easy-to-read approach for wrangling asynchronous execution back into a visually sequential control flow. Any process that blocks the event loop is a candidate for the promise pattern.</p> According to the spec, a promise object is composed of the following parts: <ul> <li>Promise is an object or function with a then method whose behavior conforms to this specification.</li> <li>Thenable is an object or function that defines a then method.</li> <li>Value is any legal JavaScript value (including <code>undefined</code>, a <code>thenable</code>, or a <code>promise</code>).</li> <li>Exception is a value that is thrown using the throw statement.</li> <li>Reason is a value that indicates why a promise was rejected.</li> </ul> <ul> <li>Expert JavaScript by Mark E. Daggett, pg:88</li> </ul>"},{"location":"frontend/js/designpattern/daily/","title":"Daily","text":"<p>Which design patterns can I use daily in JavaScript and React, and how should I implement them?</p>"},{"location":"frontend/js/designpattern/daily/#overview","title":"Overview","text":"<p>In both JavaScript and React, some design patterns are used more frequently due to the nature of front-end development and state management. Below are the most common design patterns you\u2019ll likely use daily, along with examples of how to implement them in both JavaScript and React.</p>"},{"location":"frontend/js/designpattern/daily/#1-module-pattern-javascript-custom-hooks-react","title":"1. Module Pattern (JavaScript) / Custom Hooks (React)","text":"<ul> <li>Purpose: The <code>Module Pattern</code> encapsulates code into a private scope, while in React, <code>Custom Hooks</code> encapsulate reusable logic.</li> <li>When to use: When you want to reuse logic across your application or manage specific behavior in an isolated way.</li> </ul> JavaScriptReact Example in JavaScript (Module Pattern)<pre><code>const calculatorModule = (function () {\n    let result = 0; // Private variable\n\n    return {\n        add: function (num) {\n            result += num;\n            return result;\n        },\n        reset: function () {\n            result = 0;\n            return result;\n        },\n    };\n})();\n\n// Usage\ncalculatorModule.add(5); // 5\ncalculatorModule.reset(); // 0\n</code></pre> Example in React (Custom Hook)<pre><code>import { useState } from 'react';\n\nfunction useCounter() {\n    const [count, setCount] = useState(0);\n\n    const increment = () =&gt; setCount(count + 1);\n    const reset = () =&gt; setCount(0);\n\n    return { count, increment, reset };\n}\n\nfunction CounterComponent() {\n    const { count, increment, reset } = useCounter();\n\n    return (\n        &lt;div&gt;\n            &lt;p&gt;{count}&lt;/p&gt;\n            &lt;button onClick={increment}&gt;Increment&lt;/button&gt;\n            &lt;button onClick={reset}&gt;Reset&lt;/button&gt;\n        &lt;/div&gt;\n    );\n}\n</code></pre> <p>Why Daily?</p> <p>You can use Modules to organize your logic into reusable blocks, while Custom Hooks in React let you encapsulate functionality like state management or data fetching in a reusable way.</p>"},{"location":"frontend/js/designpattern/daily/#2-observer-pattern-javascript-reacts-component-lifecycle-and-context-api","title":"2. Observer Pattern (JavaScript) / React\u2019s Component Lifecycle and Context API","text":"<ul> <li>Purpose: The <code>Observer Pattern</code> allows objects to subscribe to events, while React\u2019s <code>Context API</code> and <code>useEffect</code> are used to manage state changes and notify components.</li> <li>When to use: When you need to handle state or data changes across multiple components.</li> </ul> JavaScriptReact Example in JavaScript (Observer Pattern)<pre><code>class Subject {\n    constructor() {\n        this.observers = [];\n    }\n\n    subscribe(observer) {\n        this.observers.push(observer);\n    }\n\n    notify(data) {\n        this.observers.forEach(observer =&gt; observer.update(data));\n    }\n}\n\nclass Observer {\n    update(data) {\n        console.log('Data received:', data);\n    }\n}\n\nconst subject = new Subject();\nconst observer1 = new Observer();\nconst observer2 = new Observer();\n\nsubject.subscribe(observer1);\nsubject.subscribe(observer2);\n\nsubject.notify('Hello Observers');\n</code></pre> Example in React (Context API)<pre><code>import React, { createContext, useState, useContext } from 'react';\n\nconst ThemeContext = createContext();\n\nfunction ThemeProvider({ children }) {\n    const [theme, setTheme] = useState('light');\n\n    const toggleTheme = () =&gt; {\n        setTheme(theme === 'light' ? 'dark' : 'light');\n    };\n\n    return (\n        &lt;ThemeContext.Provider value={{ theme, toggleTheme }}&gt;\n            {children}\n        &lt;/ThemeContext.Provider&gt;\n    );\n}\n\nfunction ThemedComponent() {\n    const { theme, toggleTheme } = useContext(ThemeContext);\n    return (\n        &lt;div&gt;\n            &lt;p&gt;Current theme: {theme}&lt;/p&gt;\n            &lt;button onClick={toggleTheme}&gt;Toggle Theme&lt;/button&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default function App() {\n    return (\n        &lt;ThemeProvider&gt;\n            &lt;ThemedComponent /&gt;\n        &lt;/ThemeProvider&gt;\n    );\n}\n</code></pre> <p>Why Daily?</p> <p>In JavaScript, you may need the Observer Pattern to manage event-driven updates, while in React, Context API and useEffect are used frequently for state and lifecycle management.</p>"},{"location":"frontend/js/designpattern/daily/#3-factory-pattern-javascript-component-composition-react","title":"3. Factory Pattern (JavaScript) / Component Composition (React)","text":"<ul> <li>Purpose: The <code>Factory Pattern</code> creates objects without specifying the exact class, while in React, <code>Component Composition</code> allows you to assemble components dynamically.</li> <li>When to use: When creating objects or components based on dynamic inputs.</li> </ul> JavaScriptReact Example in JavaScript (Factory Pattern)<pre><code>function ButtonFactory(type) {\n    if (type === 'primary') {\n        return { style: 'blue', text: 'Primary Button' };\n    } else if (type === 'secondary') {\n        return { style: 'gray', text: 'Secondary Button' };\n    }\n}\n\nconst primaryButton = ButtonFactory('primary');\nconst secondaryButton = ButtonFactory('secondary');\n\nconsole.log(primaryButton);  // { style: 'blue', text: 'Primary Button' }\n</code></pre> Example in React (Component Composition)<pre><code>function Button({ style, text }) {\n    return &lt;button className={style}&gt;{text}&lt;/button&gt;;\n}\n\nfunction ButtonFactory({ type }) {\n    if (type === 'primary') {\n        return &lt;Button style=\"blue\" text=\"Primary Button\" /&gt;;\n    } else if (type === 'secondary') {\n        return &lt;Button style=\"gray\" text=\"Secondary Button\" /&gt;;\n    }\n    return null;\n}\n\nfunction App() {\n    return (\n        &lt;div&gt;\n            &lt;ButtonFactory type=\"primary\" /&gt;\n            &lt;ButtonFactory type=\"secondary\" /&gt;\n        &lt;/div&gt;\n    );\n}\n</code></pre> <p>Why Daily?</p> <p>In JavaScript, the Factory Pattern helps dynamically create objects, and in React, Component Composition lets you dynamically build your UI based on the application's state or user input.</p>"},{"location":"frontend/js/designpattern/daily/#4-singleton-pattern-javascript-redux-store-react","title":"4. Singleton Pattern (JavaScript) / Redux Store (React)","text":"<ul> <li>Purpose: The <code>Singleton Pattern</code> ensures that a class has only one instance, and in React, <code>Redux Store</code> is a global singleton store for state management.</li> <li>When to use: When you need a single source of truth for managing shared state.</li> </ul> JavaScriptReact Example in JavaScript (Singleton Pattern)<pre><code>const Singleton = (function() {\n    let instance;\n\n    function createInstance() {\n        return { data: 'I am the single instance' };\n    }\n\n    return {\n        getInstance: function() {\n            if (!instance) {\n                instance = createInstance();\n            }\n            return instance;\n        }\n    };\n})();\n\nconst instance1 = Singleton.getInstance();\nconst instance2 = Singleton.getInstance();\n\nconsole.log(instance1 === instance2); // true\n</code></pre> Example in React (Redux Store)<pre><code>import { createStore } from 'redux';\n\nconst initialState = { counter: 0 };\n\nfunction counterReducer(state = initialState, action) {\n    switch (action.type) {\n        case 'INCREMENT':\n            return { counter: state.counter + 1 };\n        default:\n            return state;\n    }\n}\n\nconst store = createStore(counterReducer);\n\nstore.subscribe(() =&gt; console.log(store.getState()));\n\nstore.dispatch({ type: 'INCREMENT' });  // Output: { counter: 1 }\nstore.dispatch({ type: 'INCREMENT' });  // Output: { counter: 2 }\n</code></pre> <p>Why Daily?</p> <p>In JavaScript, the Singleton Pattern helps manage single instances, and in React, Redux serves as a central store, which is essential for managing global state across the app.</p>"},{"location":"frontend/js/designpattern/daily/#5-decorator-pattern-javascript-higher-order-components-react","title":"5. Decorator Pattern (JavaScript) / Higher-Order Components (React)","text":"<ul> <li>Purpose: The <code>Decorator Pattern</code> allows for dynamic behavior addition, while in React, <code>Higher-Order Components (HOC)</code> wrap components to add functionality.</li> <li>When to use: When you need to add features to existing objects or components.</li> </ul> JavaScriptReact Example in JavaScript (Decorator Pattern)<pre><code>function addTimestamp(originalFunction) {\n    return function(...args) {\n        console.log('Timestamp:', new Date());\n        return originalFunction(...args);\n    };\n}\n\nfunction logMessage(message) {\n    console.log(message);\n}\n\nconst decoratedLog = addTimestamp(logMessage);\ndecoratedLog('Hello!'); // Logs the timestamp and then \"Hello!\"\n</code></pre> Example in React (Higher-Order Component)<pre><code>function withLogging(WrappedComponent) {\n    return function(props) {\n        console.log('Rendering:', WrappedComponent.name);\n        return &lt;WrappedComponent {...props} /&gt;;\n    };\n}\n\nfunction Button(props) {\n    return &lt;button&gt;{props.text}&lt;/button&gt;;\n}\n\nconst ButtonWithLogging = withLogging(Button);\n\nfunction App() {\n    return &lt;ButtonWithLogging text=\"Click Me\" /&gt;;\n}\n</code></pre> <p>Why Daily?</p> <p>Use the Decorator Pattern to add new behaviors to existing objects in JavaScript, and in React, HOCs help you reuse logic by enhancing components with additional functionality.</p>"},{"location":"frontend/js/designpattern/daily/#conclusion","title":"Conclusion:","text":"<ul> <li>Daily in JavaScript: Module Pattern, Observer Pattern, Factory Pattern, Singleton Pattern, Decorator Pattern.</li> <li>Daily in React: Custom Hooks, Context API, Component Composition</li> </ul>"},{"location":"frontend/js/designpattern/intro/","title":"Intro","text":"<p>To master JavaScript design patterns, you can focus on the following key topics and categories. These topics will help you understand the core patterns used in JavaScript development and how they can be applied in different scenarios.</p>"},{"location":"frontend/js/designpattern/intro/#1-creational-patterns","title":"1. Creational Patterns","text":"<ul> <li> <p>Goal: Deal with object creation mechanisms, trying to create objects in a manner suitable for the situation.</p> </li> <li> <p>Key Patterns:</p> <ul> <li>Constructor Pattern</li> <li>Factory Pattern</li> <li>Abstract Factory Pattern</li> <li>Singleton Pattern</li> <li>Prototype Pattern</li> <li>Builder Pattern</li> </ul> </li> </ul>"},{"location":"frontend/js/designpattern/intro/#2-structural-patterns","title":"2. Structural Patterns","text":"<ul> <li> <p>Goal: Deal with object composition and how objects and classes can be combined to form larger structures while keeping them flexible and efficient.</p> </li> <li> <p>Key Patterns:</p> <ul> <li>Module Pattern (often considered a structural pattern in JavaScript)</li> <li>Decorator Pattern</li> <li>Adapter Pattern</li> <li>Facade Pattern</li> <li>Proxy Pattern</li> <li>Flyweight Pattern</li> <li>Bridge Pattern</li> </ul> </li> </ul>"},{"location":"frontend/js/designpattern/intro/#3-behavioral-patterns","title":"3. Behavioral Patterns","text":"<ul> <li>Goal: Focus on communication between objects, defining how objects interact and share responsibility.</li> <li> <p>Key Patterns:</p> <ul> <li>Observer Pattern</li> <li>Strategy Pattern</li> <li>Command Pattern</li> <li>Iterator Pattern</li> <li>Mediator Pattern</li> <li>State Pattern</li> <li>Memento Pattern</li> <li>Visitor Pattern</li> <li>Chain of Responsibility Pattern</li> <li>Template Method Pattern</li> </ul> </li> </ul>"},{"location":"frontend/js/designpattern/intro/#4-concurrency-patterns-relevant-for-asynchronous-operations","title":"4. Concurrency Patterns (relevant for asynchronous operations)","text":"<ul> <li>Goal: Manage multithreading or asynchronous operations in an efficient and controlled way.</li> <li> <p>Key Patterns:</p> <ul> <li>Promises</li> <li>Async/Await</li> <li>Callbacks (though not necessarily a formal design pattern, understanding callback mechanisms is crucial)</li> <li>Throttling/Debouncing</li> <li>Publish-Subscribe Pattern (variation of Observer Pattern for event handling)</li> <li>Event Loop and Queues (JavaScript-specific concepts for managing concurrency)</li> </ul> </li> </ul>"},{"location":"frontend/js/designpattern/intro/#5-architectural-patterns","title":"5. Architectural Patterns","text":"<ul> <li>Goal: Deal with the architecture of applications, ensuring the structure is maintainable and scalable.</li> <li> <p>Key Patterns:</p> <ul> <li>MVC (Model-View-Controller)</li> <li>MVVM (Model-View-ViewModel)</li> <li>Flux Architecture (used with React, often implemented with Redux)</li> <li>Microservices (if you're working in Node.js)</li> </ul> </li> </ul>"},{"location":"frontend/js/designpattern/intro/#6-functional-programming-concepts-relevant-to-javascript","title":"6. Functional Programming Concepts (Relevant to JavaScript)","text":"<ul> <li>Goal: Understand how functional programming can be applied to write cleaner, more predictable code.</li> <li> <p>Key Concepts:</p> <ul> <li>Pure Functions</li> <li>Higher-Order Functions</li> <li>Function Composition</li> <li>Currying</li> <li>Immutability</li> </ul> </li> </ul>"},{"location":"frontend/js/designpattern/intro/#7-javascript-specific-design-patterns","title":"7. JavaScript-Specific Design Patterns","text":"<ul> <li>Goal: Learn patterns that are highly relevant to the JavaScript language and its peculiarities.</li> <li> <p>Key Patterns:</p> <ul> <li>Revealing Module Pattern</li> <li>IIFE (Immediately Invoked Function Expression)</li> <li>Mixin Pattern (for code reusability, especially in ES5 and older)</li> <li>Event Delegation</li> <li>Prototype Inheritance</li> <li>Promises and Async Patterns</li> </ul> </li> </ul>"},{"location":"frontend/js/designpattern/intro/#8-solid-principles-while-not-specific-design-patterns-these-principles-guide-the-use-of-patterns-effectively","title":"8. SOLID Principles (While not specific design patterns, these principles guide the use of patterns effectively)","text":"<ul> <li>Single Responsibility Principle (SRP)</li> <li>Open/Closed Principle (OCP)</li> <li>Liskov Substitution Principle (LSP)</li> <li>Interface Segregation Principle (ISP)</li> <li>Dependency Inversion Principle (DIP)</li> </ul>"},{"location":"frontend/js/designpattern/intro/#9-error-handling-patterns","title":"9. Error Handling Patterns","text":"<ul> <li>Goal: Learn strategies for handling errors gracefully.</li> <li> <p>Key Concepts:</p> <ul> <li>Try/Catch</li> <li>Graceful Degradation</li> <li>Fail Fast</li> <li>Error Propagation</li> </ul> </li> </ul>"},{"location":"frontend/js/designpattern/intro/#10-performance-optimization-patterns","title":"10. Performance Optimization Patterns","text":"<ul> <li>Goal: Understand patterns that help in improving the performance of JavaScript applications.</li> <li> <p>Key Patterns:</p> <ul> <li>Lazy Loading</li> <li>Memoization</li> <li>Throttling and Debouncing (useful for optimizing user interactions)</li> <li>Chunking</li> <li>Virtual DOM (relevant for front-end frameworks like React)</li> </ul> </li> </ul>"},{"location":"frontend/js/designpattern/intro/#suggested-learning-path","title":"Suggested Learning Path:","text":"<ol> <li>Start with Creational Patterns like Factory, Singleton, and Constructor, as they help manage object creation.</li> <li>Explore Structural Patterns to learn about object composition and efficient architecture.</li> <li>Delve into Behavioral Patterns to handle object interactions and communication (Observer, Strategy, etc.).</li> <li>Dive deeper into Concurrency Patterns to manage asynchronous operations, critical for modern JavaScript apps.</li> <li>Understand Architectural Patterns, especially MVC, Flux, and MVVM, for building scalable apps.</li> <li>Focus on JavaScript-specific patterns like Module, IIFE, and Event Delegation, as these are crucial for mastering JS.</li> <li>Apply SOLID principles to make the use of design patterns more effective and maintainable.</li> </ol> <p>Mastering these topics will help you apply design patterns to JavaScript effectively in various contexts.</p>"},{"location":"frontend/js/designpattern/js/","title":"JS","text":""},{"location":"frontend/js/designpattern/js/#how-to-use-javascript-design-patterns-in-daily-applications-simple-examples","title":"How to Use JavaScript Design Patterns in Daily Applications (Simple Examples)","text":"<p>Here\u2019s how you can use the most common design patterns in JavaScript in your daily applications:</p>"},{"location":"frontend/js/designpattern/js/#1-module-pattern","title":"1. Module Pattern","text":"<p>The Module Pattern helps organize your code by encapsulating related functions into a single object, making your code more modular and reusable. It\u2019s great for managing separate functionality like API services or UI components.</p> Simple ExampleUserService.jsmain.js <pre><code>// UserService.js (Module)\nconst UserService = (function () {\n    let users = [];\n\n    function addUser(user) {\n        users.push(user);\n        console.log(\"User added:\", user);\n    }\n\n    function getUsers() {\n        return users;\n    }\n\n    return {\n        addUser,\n        getUsers,\n    };\n})();\n\n// Usage\nUserService.addUser({ name: \"John\", age: 30 });\nUserService.addUser({ name: \"Jane\", age: 25 });\nconsole.log(UserService.getUsers()); // [{ name: 'John', age: 30 }, { name: 'Jane', age: 25 }]\n</code></pre> <pre><code>// UserService.js\nconst UserService = (function() {\n    let users = [];\n\n    function addUser(user) {\n        users.push(user);\n        console.log('User added:', user);\n    }\n\n    function getUsers() {\n        return users;\n    }\n\n    return {\n        addUser,\n        getUsers\n    };\n})();\n\nexport default UserService;\n</code></pre> <pre><code>// main.js\nimport UserService from './UserService.js';\n\nUserService.addUser({ name: 'John', age: 30 });\nUserService.addUser({ name: 'Jane', age: 25 });\nconsole.log(UserService.getUsers()); // [{ name: 'John', age: 30 }, { name: 'Jane', age: 25 }]\n</code></pre> <p>When to Use:</p> <ul> <li>Whenever you need to manage different pieces of functionality in your app separately (e.g., user management, data fetching).</li> </ul>"},{"location":"frontend/js/designpattern/js/#2-observer-pattern","title":"2. Observer Pattern","text":"<p>The Observer Pattern is useful when you have multiple parts of your app that need to react to changes, like a UI updating in response to data changes.</p> Simple ExampleSubject.jsObserver.jsmain.js <pre><code>// Subject.js\nclass Subject {\n    constructor() {\n        this.observers = [];\n    }\n\n    subscribe(observer) {\n        this.observers.push(observer);\n    }\n\n    notify(data) {\n        this.observers.forEach(observer =&gt; observer.update(data));\n    }\n}\n\n// Observer.js\nclass Observer {\n    update(data) {\n        console.log('Received data:', data);\n    }\n}\n\n// Usage\nconst subject = new Subject();\nconst observer1 = new Observer();\nconst observer2 = new Observer();\n\nsubject.subscribe(observer1);\nsubject.subscribe(observer2);\n\nsubject.notify('New Data Available');\n// Both observers will log: \"Received data: New Data Available\"\n</code></pre> <pre><code>// Subject.js\nclass Subject {\n    constructor() {\n        this.observers = [];\n    }\n\n    subscribe(observer) {\n        this.observers.push(observer);\n    }\n\n    notify(data) {\n        this.observers.forEach(observer =&gt; observer.update(data));\n    }\n}\n\nexport default Subject;\n</code></pre> <pre><code>// Observer.js\nclass Observer {\n    update(data) {\n        console.log('Received data:', data);\n    }\n}\n\nexport default Observer;\n</code></pre> <pre><code>// main.js\nimport Subject from './Subject.js';\nimport Observer from './Observer.js';\n\nconst subject = new Subject();\nconst observer1 = new Observer();\nconst observer2 = new Observer();\n\nsubject.subscribe(observer1);\nsubject.subscribe(observer2);\n\nsubject.notify('New Data Available');\n// Both observers will log: \"Received data: New Data Available\"\n</code></pre> <p>When to Use:</p> <ul> <li>Use it when you need to notify multiple components or modules when a certain event occurs (e.g., real-time notifications or data updates).</li> </ul>"},{"location":"frontend/js/designpattern/js/#3-factory-pattern","title":"3. Factory Pattern","text":"<p>The Factory Pattern is helpful when you need to create different types of objects based on certain conditions, like different kinds of UI components or products.</p> Simple ExampleButtonFactory.jsmain.js <pre><code>// ButtonFactory.js\nfunction ButtonFactory(type) {\n    if (type === 'primary') {\n        return { text: 'Primary Button', style: 'blue' };\n    } else if (type === 'secondary') {\n        return { text: 'Secondary Button', style: 'gray' };\n    } else {\n        return { text: 'Default Button', style: 'default' };\n    }\n}\n\n// Usage\nconst primaryButton = ButtonFactory('primary');\nconst secondaryButton = ButtonFactory('secondary');\n\nconsole.log(primaryButton); // { text: 'Primary Button', style: 'blue' }\nconsole.log(secondaryButton); // { text: 'Secondary Button', style: 'gray' }\n</code></pre> <pre><code>// ButtonFactory.js\nfunction ButtonFactory(type) {\n    if (type === 'primary') {\n        return { text: 'Primary Button', style: 'blue' };\n    } else if (type === 'secondary') {\n        return { text: 'Secondary Button', style: 'gray' };\n    } else {\n        return { text: 'Default Button', style: 'default' };\n    }\n}\n\nexport default ButtonFactory;\n</code></pre> <pre><code>// main.js\nimport ButtonFactory from './ButtonFactory.js';\n\nconst primaryButton = ButtonFactory('primary');\nconst secondaryButton = ButtonFactory('secondary');\n\nconsole.log(primaryButton); // { text: 'Primary Button', style: 'blue' }\nconsole.log(secondaryButton); // { text: 'Secondary Button', style: 'gray' }\n</code></pre> <p>When to Use:</p> <ul> <li>When you need to create objects based on some conditions, such as dynamically generating UI elements (e.g., buttons, forms).</li> </ul>"},{"location":"frontend/js/designpattern/js/#4-singleton-pattern","title":"4. Singleton Pattern","text":"<p>The Singleton Pattern is useful when you need a single instance of an object or service across your entire application, like a logger or configuration manager.</p> Simple ExampleLogger.jsmain.js <pre><code>// Logger.js (Singleton)\nconst Logger = (function () {\n    let instance;\n\n    function createInstance() {\n        return {\n        log: function (message) {\n            console.log(\"Log message:\", message);\n        },\n        };\n    }\n\n    return {\n        getInstance: function () {\n        if (!instance) {\n            instance = createInstance();\n        }\n        return instance;\n        },\n    };\n})();\n\n// Usage\nconst logger1 = Logger.getInstance();\nconst logger2 = Logger.getInstance();\n\nlogger1.log(\"This is the first log\"); // \"Log message: This is the first log\"\nlogger2.log(\"This is the second log\"); // \"Log message: This is the second log\"\n\nconsole.log(logger1 === logger2); // true (same instance)\n</code></pre> <pre><code>// Logger.js\nconst Logger = (function() {\n    let instance;\n\n    function createInstance() {\n        return {\n            log: function(message) {\n                console.log('Log message:', message);\n            }\n        };\n    }\n\n    return {\n        getInstance: function() {\n            if (!instance) {\n                instance = createInstance();\n            }\n            return instance;\n        }\n    };\n})();\n\nexport default Logger;\n</code></pre> <pre><code>// main.js\nimport Logger from './Logger.js';\n\nconst logger1 = Logger.getInstance();\nconst logger2 = Logger.getInstance();\n\nlogger1.log('This is the first log');  // \"Log message: This is the first log\"\nlogger2.log('This is the second log'); // \"Log message: This is the second log\"\n\nconsole.log(logger1 === logger2); // true (same instance)\n</code></pre> <p>When to Use:</p> <ul> <li>Use it when you need a shared instance of an object (e.g., a logging service or configuration settings) throughout your app.</li> </ul>"},{"location":"frontend/js/designpattern/js/#5-decorator-pattern","title":"5. Decorator Pattern","text":"<p>The Decorator Pattern allows you to add extra functionality to an existing object without modifying its structure, like adding logging or validation.</p> Simple ExamplelogDecorator.jsgreet.jsmain.js <pre><code>// Original function\nfunction greet(name) {\n    return `Hello, ${name}`;\n}\n\n// Decorator to log function calls\nfunction logDecorator(fn) {\n    return function (...args) {\n        console.log(`Calling function with args: ${args}`);\n        return fn(...args);\n    };\n}\n\n// Usage\nconst decoratedGreet = logDecorator(greet);\nconsole.log(decoratedGreet(\"John\")); // \"Calling function with args: John\" followed by \"Hello, John\"\n</code></pre> <pre><code>// logDecorator.js\nfunction logDecorator(fn) {\n    return function(...args) {\n        console.log(`Calling function with args: ${args}`);\n        return fn(...args);\n    };\n}\n\nexport default logDecorator;\n</code></pre> <pre><code>// greet.js\nfunction greet(name) {\n    return `Hello, ${name}`;\n}\n\nexport default greet;\n</code></pre> <pre><code>// main.js\nimport logDecorator from './logDecorator.js';\nimport greet from './greet.js';\n\nconst decoratedGreet = logDecorator(greet);\nconsole.log(decoratedGreet('John'));  // \"Calling function with args: John\" followed by \"Hello, John\"\n</code></pre> <p>When to Use:</p> <ul> <li>When you need to add extra functionality (e.g., logging, validation, caching) to existing functions or methods without altering their core logic.</li> </ul> File Explained <p>This folder structure with file names makes it easier to integrate design patterns into your daily JavaScript workflow. Here's a summary of file names and what they do:</p> <ol> <li>Module Pattern: Encapsulate logic in modules (<code>UserService.js</code>).</li> <li>Observer Pattern: Build an event-driven system with subscribers (<code>Subject.js</code>, <code>Observer.js</code>).</li> <li>Factory Pattern: Dynamically create objects based on input (<code>ButtonFactory.js</code>).</li> <li>Singleton Pattern: Ensure only one instance of a service or resource (<code>Logger.js</code>).</li> <li>Decorator Pattern: Add functionality to functions without changing them (<code>logDecorator.js</code>, <code>greet.js</code>).</li> </ol> <p>By splitting your project into smaller, pattern-based files, you'll achieve better maintainability and code organization in large-scale applications.</p>"},{"location":"frontend/js/designpattern/js/#conclusion","title":"Conclusion:","text":"<p>Here\u2019s how you can use these design patterns in daily JavaScript applications:</p> <ol> <li>Module Pattern: Organize your code into reusable modules, great for services like user management or API handling.</li> <li>Observer Pattern: Use when you need event-driven behavior, like updating multiple parts of the UI when data changes.</li> <li>Factory Pattern: Dynamically create objects based on conditions, perfect for generating UI components.</li> <li>Singleton Pattern: Ensure only one instance of a service or configuration manager is created, such as a logger.</li> <li>Decorator Pattern: Add extra functionality to existing objects (e.g., logging, validation) without modifying their structure.</li> </ol> <p>These patterns help make your code more structured, maintainable, and scalable as your JavaScript applications grow.</p>"},{"location":"frontend/js/designpattern/mnemonic/","title":"Mnemonic","text":""},{"location":"frontend/js/designpattern/mnemonic/#creational-patterns","title":"Creational Patterns:","text":"<p>Some Fat Cats Paint Beautiful Canvases</p> <ul> <li>Singleton</li> <li>Factory</li> <li>Constructor</li> <li>Prototype</li> <li>Builder</li> </ul>"},{"location":"frontend/js/designpattern/mnemonic/#structural-patterns","title":"Structural Patterns:","text":"<p>Many Friendly Dogs Are Full of Pretty Energy</p> <ul> <li>Module</li> <li>Facade</li> <li>Decorator</li> <li>Adapter</li> <li>Flyweight</li> <li>Proxy</li> <li>Event Delegation</li> </ul>"},{"location":"frontend/js/designpattern/mnemonic/#behavioral-patterns","title":"Behavioral Patterns:","text":"<p>Only Sweet Dogs Make Super Cute Hugs</p> <ul> <li>Observer</li> <li>Strategy</li> <li>Decorator</li> <li>Mediator</li> <li>State</li> <li>Chain of Responsibility</li> <li>Handler (Command)</li> </ul>"},{"location":"frontend/js/designpattern/mnemonic/#most-used-design-patterns","title":"Most Used Design Patterns","text":"<p>As a beginner, it\u2019s essential to focus on the most commonly used design patterns in JavaScript. Below are the most used design patterns from each category, along with examples of how you can use them.</p>"},{"location":"frontend/js/designpattern/mnemonic/#1-creational-pattern-factory-pattern","title":"1. Creational Pattern: Factory Pattern","text":"<ul> <li>Purpose: The Factory Pattern provides a way to create objects without exposing the exact class or constructor used, which makes the code more flexible.</li> <li>When to use: When you need to create different types of objects based on certain conditions.</li> </ul> Example <pre><code>function Car(type) {\n    this.type = type;\n    this.drive = function () {\n        console.log(\"Driving a \" + this.type);\n    };\n}\n\nfunction CarFactory() {\n    this.createCar = function (type) {\n        if (type === \"sedan\") {\n            return new Car(\"Sedan\");\n        } else if (type === \"suv\") {\n            return new Car(\"SUV\");\n        } else {\n            return new Car(\"Unknown type\");\n        }\n    };\n}\n\n// Usage\nconst factory = new CarFactory();\nconst sedan = factory.createCar(\"sedan\");\nconst suv = factory.createCar(\"suv\");\n\nsedan.drive(); // Output: Driving a Sedan\nsuv.drive(); // Output: Driving an SUV\n</code></pre> <p>As a Beginner:</p> <p>Use the Factory Pattern when you want to avoid the complexity of handling object creation for different types and want a centralized way to create instances.</p>"},{"location":"frontend/js/designpattern/mnemonic/#2-structural-pattern-module-pattern","title":"2. Structural Pattern: Module Pattern","text":"<ul> <li>Purpose: The Module Pattern allows you to create private and public variables and methods by using closures.</li> <li>When to use: When you need to encapsulate code, keeping some variables private and exposing only the necessary functions or variables.</li> </ul> Example <pre><code>const calculatorModule = (function() {\n    let result = 0; // Private variable\n\n    return {\n        add: function(x) {\n            result += x;\n            return result;\n        },\n        subtract: function(x) {\n            result -= x;\n            return result;\n        },\n        getResult: function() {\n            return result;\n        }\n    };\n})();\n\n// Usage\ncalculatorModule.add(10); // 10\ncalculatorModule.subtract(3); // 7\nconsole.log(calculatorModule.getResult()); // Output: 7\n</code></pre> <p>As a Beginner:</p> <p>Use the Module Pattern to organize your code into a clean structure. It\u2019s perfect for creating reusable libraries or utilities, especially when you want to hide implementation details.</p>"},{"location":"frontend/js/designpattern/mnemonic/#3-behavioral-pattern-observer-pattern","title":"3. Behavioral Pattern: Observer Pattern","text":"<ul> <li>Purpose: The Observer Pattern allows one object (subject) to notify other objects (observers) when its state changes.</li> <li>When to use: When you have multiple parts of your application that need to react to changes in the state of an object (e.g., event handling).</li> </ul> Example <pre><code>class Subject {\n    constructor() {\n        this.observers = [];\n    }\n\n    subscribe(observer) {\n        this.observers.push(observer);\n    }\n\n    unsubscribe(observer) {\n        this.observers = this.observers.filter((obs) =&gt; obs !== observer);\n    }\n\n    notify(data) {\n        this.observers.forEach((observer) =&gt; observer.update(data));\n    }\n}\n\nclass Observer {\n    update(data) {\n        console.log(\"Observer received data:\", data);\n    }\n}\n\n// Usage\nconst subject = new Subject();\nconst observer1 = new Observer();\nconst observer2 = new Observer();\n\nsubject.subscribe(observer1);\nsubject.subscribe(observer2);\n\nsubject.notify(\"Hello Observers\"); // Output: Observer received data: Hello Observers (twice)\n</code></pre> <p>As a Beginner:</p> <p>Use the Observer Pattern in event-driven applications, such as when building event handlers or pub-sub systems where you need to notify multiple objects of state changes.</p>"},{"location":"frontend/js/designpattern/mnemonic/#4-concurrency-pattern-promises","title":"4. Concurrency Pattern: Promises","text":"<ul> <li>Purpose: Promises simplify asynchronous operations, allowing for cleaner and more manageable code when dealing with tasks like fetching data.</li> <li>When to use: When handling asynchronous operations such as API calls or setTimeout, and you want to avoid callback hell.</li> </ul> Example <pre><code>function fetchData() {\n    return new Promise((resolve, reject) =&gt; {\n        setTimeout(() =&gt; {\n            resolve(\"Data fetched successfully!\");\n        }, 1000);\n    });\n}\n\n// Usage\nfetchData()\n.then((data) =&gt; {\n    console.log(data); // Output: Data fetched successfully!\n})\n.catch((error) =&gt; {\n    console.error(\"Error:\", error);\n});\n</code></pre> <p>As a Beginner:</p> <p>Use Promises to handle asynchronous code without nesting callbacks. This improves readability and maintainability in JavaScript when working with APIs or delayed actions.</p>"},{"location":"frontend/js/designpattern/mnemonic/#5-architectural-pattern-mvc-model-view-controller","title":"5. Architectural Pattern: MVC (Model-View-Controller)","text":"<ul> <li>Purpose: The MVC pattern separates your application into three parts: Model (data), View (UI), and Controller (business logic), allowing for better separation of concerns.</li> <li>When to use: When building web applications where you want to organize your code based on user interface, data, and logic separation.</li> </ul> Example (Simplified MVC in vanilla JS): <pre><code>// Model\nconst model = {\n    items: [],\n    addItem(item) {\n        this.items.push(item);\n        controller.updateView();\n    },\n};\n\n// View\nconst view = {\n    render(items) {\n        const list = document.getElementById(\"item-list\");\n        list.innerHTML = items.map((item) =&gt; `&lt;li&gt;${item}&lt;/li&gt;`).join(\"\");\n    },\n};\n\n// Controller\nconst controller = {\n    addItem(item) {\n        model.addItem(item);\n    },\n    updateView() {\n        view.render(model.items);\n    },\n};\n\n// Usage (Assume there's an input and button in the HTML)\ndocument.getElementById(\"add-btn\").addEventListener(\"click\", () =&gt; {\n    const item = document.getElementById(\"item-input\").value;\n    controller.addItem(item);\n});\n</code></pre> <p>As a Beginner:</p> <p>Use MVC when building larger applications to keep your code organized and maintainable by separating the concerns of data, UI, and logic.</p>"},{"location":"frontend/js/designpattern/mnemonic/#summary-of-common-patterns-to-focus-on-as-a-beginner","title":"Summary of Common Patterns to Focus on as a Beginner:","text":"<ol> <li>Factory Pattern (Creational) \u2013 Helps with flexible object creation.</li> <li>Module Pattern (Structural) \u2013 Encapsulates code and organizes it.</li> <li>Observer Pattern (Behavioral) \u2013 Handles event-driven updates.</li> <li>Promises (Concurrency) \u2013 Simplifies asynchronous tasks.</li> <li>MVC (Architectural) \u2013 Organizes web applications for separation of concerns.</li> </ol> <p>Mastering these design patterns will give you a strong foundation for writing clean, maintainable, and efficient JavaScript code!</p>"},{"location":"frontend/js/designpattern/official/","title":"Official","text":""},{"location":"frontend/js/designpattern/official/#design-patterns","title":"Design patterns","text":"<p>Most languages have their set of anti-patterns. Based on the kind of problems that they solve, design patterns were categorized into a few broad categories by the GOF:</p> <ul> <li> <p>Creational design patterns: These patterns deal with various mechanisms of object creation. While most languages provide basic object creation methods, these patterns look at optimized or more controlled mechanisms of object creation.</p> </li> <li> <p>Structural design patterns: These patterns are all about the composition of objects and relationships among them. The idea is to have minimal impact on overall object relationships when something in the system changes.</p> </li> <li> <p>Behavioral design patterns: These patterns focus on the interdependency and communication between objects.</p> </li> </ul> <p>The following table is a useful ready reckoner to identify categories of patterns</p> <p>Creational patterns:</p> <ul> <li>Factory method</li> <li>Abstract factory</li> <li>Builder</li> <li>Prototype</li> <li>Singleton</li> </ul> <p>Structural patterns:</p> <ul> <li>Adapter</li> <li>Bridge</li> <li>Composite</li> <li>Decorator</li> <li>Fa\u00e7ade</li> <li>Flyweight</li> <li>Proxy</li> </ul> <p>Behavioral patterns</p> <ul> <li>Interpreter</li> <li>Template method</li> <li>Chain of responsibility</li> <li>Command</li> <li>Iterator</li> <li>Mediator</li> <li>Memento</li> <li>Observer</li> <li>State</li> <li>Strategy</li> <li>Visitor</li> </ul> <p>Some patterns that we will discuss in this chapter may not be part of this list as they are more specific to JavaScript or a variation of these classical patterns. Similarly, we will not discuss patterns that do not fit into JavaScript or are not in popular use.</p>"},{"location":"frontend/js/designpattern/advanced/recall/","title":"Recall","text":""},{"location":"frontend/js/designpattern/advanced/recall/#overview","title":"Overview","text":"<p>Remembering and recalling design patterns, especially in JavaScript, can be challenging at first due to the variety and complexity of patterns. However, there are several strategies that can help you master and efficiently recall them when needed.</p> <p>Here are some techniques to help with remembering and recalling design patterns:</p>"},{"location":"frontend/js/designpattern/advanced/recall/#1-understand-the-problem-the-pattern-solves","title":"1. Understand the Problem the Pattern Solves","text":"<p>Instead of memorizing the pattern itself, focus on understanding the problem it solves and when it's typically used. This way, you'll know why you might need a particular pattern, which makes it easier to recall.</p> <ul> <li>Example: The Observer Pattern is often used when you have a situation where multiple objects (observers) need to be notified when a certain event happens (subject). If you understand this problem, recalling the pattern becomes easier.</li> </ul>"},{"location":"frontend/js/designpattern/advanced/recall/#2-group-patterns-by-category","title":"2. Group Patterns by Category","text":"<p>Design patterns can be grouped into different categories based on their purpose. If you understand which category a pattern belongs to, you\u2019ll have a quicker mental map for choosing and recalling the correct one.</p> <p>Here are common categories:</p> <ul> <li>Creational Patterns: These are about object creation (e.g., Singleton, Factory, Prototype).</li> <li>Structural Patterns: These are about organizing objects and classes (e.g., Decorator, Facade, Adapter).</li> <li>Behavioral Patterns: These are about object interaction and communication (e.g., Observer, Strategy, Command).</li> </ul> <p>Grouping patterns into categories will help you recall the appropriate one based on the kind of problem you're facing.</p>"},{"location":"frontend/js/designpattern/advanced/recall/#3-use-visual-aids-diagrams","title":"3. Use Visual Aids (Diagrams)","text":"<p>A lot of design patterns are easier to understand with <code>visual diagrams</code>. Many online resources, books, and tutorials provide <code>UML</code> diagrams that map out the relationships between the objects involved in each pattern.</p> <ul> <li> <p>For example, a <code>Factory Pattern</code> often has a central class (factory) that creates other objects based on certain conditions. Seeing this visually makes it easier to recall how to implement it.</p> </li> <li> <p>Create your own diagrams for each pattern or keep a reference of them, as visualizing the structure can reinforce memory.</p> </li> </ul>"},{"location":"frontend/js/designpattern/advanced/recall/#4-practice-implementing-the-patterns","title":"4. Practice Implementing the Patterns","text":"<p>Once you've understood a pattern, the best way to remember it is by <code>practicing</code>. Try solving small problems using different patterns. The more you use them, the more they will become second nature.</p> <ul> <li> <p>Example: Try building a small app that uses <code>Observer Pattern</code> for handling events. You can also implement a <code>Factory Pattern</code> for creating different types of objects.</p> </li> <li> <p>When you implement a pattern, make sure to write comments explaining how the pattern solves the problem. This will deepen your understanding and make it easier to recall later.</p> </li> </ul>"},{"location":"frontend/js/designpattern/advanced/recall/#5-use-analogies","title":"5. Use Analogies","text":"<p>Sometimes thinking of patterns in terms of real-world analogies can help make them stick. For example:</p> <ul> <li> <p>Singleton Pattern: Think of a <code>president</code> in a country\u2014there's only one president, and everyone has to communicate with that president, just like the Singleton ensures only one instance exists.</p> </li> <li> <p>Observer Pattern: Think of a <code>news subscription</code> service where multiple people (observers) are notified when a news article (subject) is published.</p> </li> </ul> <p>By relating patterns to everyday objects or concepts, you can more easily recall them when needed.</p>"},{"location":"frontend/js/designpattern/advanced/recall/#6-keep-a-pattern-cheat-sheet","title":"6. Keep a \"Pattern Cheat Sheet\"","text":"<p>Create or keep a quick reference cheat sheet or table of patterns. Include:</p> <ul> <li>Name of the pattern.</li> <li>Problem it solves.</li> <li>Example use cases.</li> <li>Key characteristics.</li> <li>A small code snippet or diagram.</li> </ul> <p>Having a quick reference will help you <code>recall the patterns</code> faster in real projects. You can create this as a personal document or find a pre-made one online.</p>"},{"location":"frontend/js/designpattern/advanced/recall/#7-learn-from-real-world-codebases","title":"7. Learn From Real-World Codebases","text":"<p>When working on real-world projects, <code>look at existing code</code> to see how and where design patterns are used. Reading and analyzing well-structured code can help you recognize when certain patterns are being applied and reinforce your understanding of them.</p> <ul> <li>Open-source projects (like on GitHub) often employ design patterns effectively. Try to find patterns like <code>Factory</code>, <code>Singleton</code>, or <code>Observer</code> in popular libraries and frameworks.</li> </ul>"},{"location":"frontend/js/designpattern/advanced/recall/#8-teach-others","title":"8. Teach Others","text":"<p>One of the best ways to solidify your understanding of design patterns is to teach them to others. When explaining a pattern, you\u2019ll need to clearly describe:</p> <ul> <li>What problem it solves.</li> <li>How it\u2019s implemented.</li> <li>Why it\u2019s useful.</li> </ul> <p>This will force you to recall and reframe the knowledge in your own words, deepening your understanding.</p>"},{"location":"frontend/js/designpattern/advanced/recall/#9-use-flashcards","title":"9. Use Flashcards","text":"<p>Flashcards are a great way to test yourself and reinforce your memory. You can create flashcards for each design pattern with:</p> <ul> <li>The <code>name</code> of the pattern on one side.</li> <li>The <code>description</code> and <code>use case</code> on the other side.</li> </ul> <p>Apps like Anki or Quizlet can be used to create digital flashcards. You can test yourself periodically to reinforce recall.</p>"},{"location":"frontend/js/designpattern/advanced/recall/#10-start-with-common-patterns","title":"10. Start with Common Patterns","text":"<p>Focus on learning and mastering the most common patterns first, as these are most likely to be used in practice. Some of the most common ones are:</p> <ul> <li>Singleton</li> <li>Observer</li> <li>Factory</li> <li>Decorator</li> <li>Strategy</li> </ul> <p>Once you're comfortable with these, expanding your knowledge to other patterns like Command, Facade, or State will be easier.</p>"},{"location":"frontend/js/designpattern/advanced/recall/#11-pair-programming","title":"11. Pair Programming","text":"<p>If you work with a team, engaging in pair programming can be helpful. In a pair programming session, you can discuss how to apply different patterns in real-time. Explaining the patterns and working through the code together can reinforce your understanding and recall.</p>"},{"location":"frontend/js/designpattern/advanced/recall/#12-refactor-code-using-design-patterns","title":"12. Refactor Code Using Design Patterns","text":"<p>As you gain experience, try refactoring old code with design patterns. You might initially write a function that is simple and works, but over time, you can identify areas that would benefit from a specific pattern.</p> <ul> <li>Example: If you have a lot of repetitive object creation code, refactor it to use the Factory Pattern. If your code has a lot of conditional behavior, try using the Strategy Pattern to clean it up.</li> </ul>"},{"location":"frontend/js/designpattern/advanced/recall/#13-use-pattern-driven-development-pdd","title":"13. Use Pattern-Driven Development (PDD)","text":"<p>Instead of just learning patterns in isolation, try applying them directly in the context of your software development process. Pattern-driven development means consciously choosing the best patterns as part of your daily coding process.</p> <ul> <li>As you build applications, always think about which design pattern could solve a particular problem. This active engagement will help you internalize the patterns more effectively.</li> </ul>"},{"location":"frontend/js/designpattern/advanced/recall/#summary-of-key-tips","title":"Summary of Key Tips:","text":"<ul> <li>Understand the problem the pattern solves.</li> <li>Group patterns by category to make them easier to recall.</li> <li>Use visual diagrams to better understand the relationships in each pattern.</li> <li>Practice implementing the patterns regularly.</li> <li>Use analogies from real life to relate the patterns to common concepts.</li> <li>Create a Pattern Cheat Sheet for quick reference.</li> <li>Read real-world code to see patterns in action.</li> <li>Teach others or discuss patterns to solidify your understanding.</li> <li>Use flashcards for active recall and review.</li> <li>Start with the most common patterns and gradually expand.</li> <li>Use pair programming or collaborate with peers to reinforce patterns.</li> <li>Refactor code using patterns to reinforce learning.</li> <li>Embrace Pattern-Driven Development by consciously applying patterns in your work.</li> </ul> <p>By using these strategies, you'll be able to internalize design patterns in JavaScript and effectively recall and apply them when solving problems in your code.</p>"},{"location":"frontend/js/designpattern/react/antd-resuable-component/","title":"antd component","text":""},{"location":"frontend/js/designpattern/react/antd-resuable-component/#overview","title":"Overview","text":"<p>In Ant Design (Antd), there are several components that can be customized to suit the specific needs of your application. Customizing these components can help you provide a more cohesive, brand-aligned, or feature-rich experience for your users.</p> <p>Below are some key components in Ant Design that are commonly customized, along with the reasons why customization can be important and beneficial:</p>"},{"location":"frontend/js/designpattern/react/antd-resuable-component/#1-button","title":"1. Button","text":"<ul> <li> <p>Customizations:</p> <ul> <li>Change the button\u2019s shape, size, or style.</li> <li>Add icons or images as prefixes/suffixes.</li> <li>Customize loading states (e.g., spinner in the button).</li> <li>Conditional button styles (e.g., red for delete, green for add).</li> </ul> </li> <li> <p>Benefits:</p> <ul> <li>Customizing buttons helps in improving the user experience by making them visually appealing, functional (e.g., adding icons), and aligned with the overall design system of your app.</li> </ul> </li> </ul> <pre><code>const CustomButton = ({ icon, type, loading, children }) =&gt; (\n  &lt;Button\n    type={type}\n    icon={icon}\n    loading={loading}\n    style={{ borderRadius: \"8px\" }}\n  &gt;\n    {children}\n  &lt;/Button&gt;\n);\n</code></pre> ExampleUsage <pre><code>import React from 'react';\nimport { Button } from 'antd';\nimport { ArrowUpOutlined, ArrowDownOutlined } from '@ant-design/icons';\n\n// Custom Button Component\nconst CustomButton = ({ type, icon, children, onClick }) =&gt; (\n    &lt;Button\n        type={type}\n        icon={icon}\n        onClick={onClick}\n        style={{ borderRadius: '8px', margin: '5px', padding: '10px 20px' }}\n    &gt;\n        {children}\n    &lt;/Button&gt;\n);\n\nexport default CustomButton;\n</code></pre> <pre><code>import React from 'react';\nimport CustomButton from './CustomButton'; // Path to your CustomButton component\n\nconst App = () =&gt; (\n    &lt;div&gt;\n        &lt;h2&gt;Custom Button Example&lt;/h2&gt;\n\n        &lt;CustomButton\n            type=\"primary\"\n            icon={&lt;ArrowUpOutlined /&gt;}\n            onClick={() =&gt; alert('Up Clicked')}\n        &gt;\n            Increase Value\n        &lt;/CustomButton&gt;\n\n        &lt;CustomButton\n            type=\"danger\"\n            icon={&lt;ArrowDownOutlined /&gt;}\n            onClick={() =&gt; alert('Down Clicked')}\n        &gt;\n            Decrease Value\n        &lt;/CustomButton&gt;\n    &lt;/div&gt;\n);\n\nexport default App;\n</code></pre>"},{"location":"frontend/js/designpattern/react/antd-resuable-component/#2-input","title":"2. Input","text":"<ul> <li> <p>Customizations:</p> <ul> <li>Add custom validation logic, placeholders, or tooltips.</li> <li>Style the input field (e.g., border-radius, colors, focus states).</li> <li>Add custom icons or clear functionality.</li> </ul> </li> <li> <p>Benefits:</p> <ul> <li>Inputs are used throughout any app, and consistent styling with custom validation or error handling improves form usability.</li> <li>Custom input components can provide specific features like auto-formatting, masking, or integrating with custom libraries (e.g., phone number input, date pickers).</li> </ul> </li> </ul> <pre><code>const CustomInput = ({ value, onChange, placeholder }) =&gt; (\n  &lt;Input\n    value={value}\n    onChange={onChange}\n    placeholder={placeholder}\n    style={{ borderRadius: \"4px\" }}\n  /&gt;\n);\n</code></pre> ExampleUsage <pre><code>import React from 'react';\nimport { Input } from 'antd';\n\n// Custom Input Component\nconst CustomInput = ({ placeholder, value, onChange, style }) =&gt; (\n    &lt;Input\n        value={value}\n        onChange={onChange}\n        placeholder={placeholder}\n        style={{ ...style, borderRadius: '5px' }}\n    /&gt;\n);\n\nexport default CustomInput;\n</code></pre> <pre><code>import React, { useState } from 'react';\nimport CustomInput from './CustomInput';\n\nconst App = () =&gt; {\n    const [inputValue, setInputValue] = useState('');\n\n    return (\n        &lt;div&gt;\n            &lt;h2&gt;Custom Input Example&lt;/h2&gt;\n\n            &lt;CustomInput\n                placeholder=\"Type something...\"\n                value={inputValue}\n                onChange={e =&gt; setInputValue(e.target.value)}\n                style={{ width: '300px', marginBottom: '20px' }}\n            /&gt;\n\n            &lt;p&gt;You typed: {inputValue}&lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default App;\n</code></pre>"},{"location":"frontend/js/designpattern/react/antd-resuable-component/#3-select-dropdown","title":"3. Select / Dropdown","text":"<ul> <li> <p>Customizations:</p> <ul> <li>Custom dropdown item rendering (e.g., custom components, icons, or checkboxes).</li> <li>Asynchronous options loading (e.g., fetching from an API).</li> <li>Custom multi-select with tags.</li> </ul> </li> <li> <p>Benefits:</p> <ul> <li>Select components are often used for filtering and choosing options. Customizing them ensures a better user experience with tailored behavior, UI, and dynamic data handling.</li> </ul> </li> </ul> <pre><code>const CustomSelect = ({ options, value, onChange }) =&gt; (\n  &lt;Select value={value} onChange={onChange} style={{ width: 200 }}&gt;\n    {options.map((option) =&gt; (\n      &lt;Select.Option key={option.value} value={option.value}&gt;\n        {option.label}\n      &lt;/Select.Option&gt;\n    ))}\n  &lt;/Select&gt;\n);\n</code></pre> ExampleUsage <pre><code>import React from 'react';\nimport { Select } from 'antd';\n\n// Custom Select Component\nconst CustomSelect = ({ options, value, onChange }) =&gt; (\n    &lt;Select value={value} onChange={onChange} style={{ width: 200 }}&gt;\n        {options.map(option =&gt; (\n        &lt;Select.Option key={option.value} value={option.value}&gt;\n            {option.label}\n        &lt;/Select.Option&gt;\n        ))}\n    &lt;/Select&gt;\n);\n\nexport default CustomSelect;\n</code></pre> <pre><code>import React, { useState } from 'react';\nimport CustomSelect from './CustomSelect';\n\nconst App = () =&gt; {\n    const [selectedOption, setSelectedOption] = useState(null);\n\n    const options = [\n        { value: 'apple', label: 'Apple' },\n        { value: 'banana', label: 'Banana' },\n        { value: 'orange', label: 'Orange' }\n    ];\n\n    return (\n        &lt;div&gt;\n            &lt;h2&gt;Custom Select Example&lt;/h2&gt;\n\n            &lt;CustomSelect\n                options={options}\n                value={selectedOption}\n                onChange={setSelectedOption}\n            /&gt;\n\n            {selectedOption &amp;&amp; &lt;p&gt;You selected: {selectedOption}&lt;/p&gt;}\n        &lt;/div&gt;\n    );\n};\n\nexport default App;\n</code></pre>"},{"location":"frontend/js/designpattern/react/antd-resuable-component/#4-table","title":"4. Table","text":"<ul> <li> <p>Customizations:</p> <ul> <li>Custom cell rendering (e.g., to display different components like icons, buttons, or styled text).</li> <li>Custom pagination (e.g., showing a dropdown or changing the page size dynamically).</li> <li>Custom filtering, sorting, or search behavior.</li> </ul> </li> <li> <p>Benefits:</p> <ul> <li>Tables often contain complex data and require different ways of interacting with rows and columns. A custom table can allow you to integrate actions (edit, delete) directly inside rows or cells, as well as customize sorting and filtering functionality.</li> </ul> </li> </ul> <pre><code>const CustomTable = ({ data, columns }) =&gt; (\n  &lt;Table\n    dataSource={data}\n    columns={columns}\n    pagination={{ pageSize: 10 }}\n    rowKey=\"id\"\n    // Add custom logic for actions, sorting, etc.\n  /&gt;\n);\n</code></pre> ExampleUsage <pre><code>import React from 'react';\nimport { Table } from 'antd';\n\n// Custom Table Component\nconst CustomTable = ({ data, columns }) =&gt; (\n    &lt;Table\n        dataSource={data}\n        columns={columns}\n        pagination={{ pageSize: 5 }}\n        rowKey=\"id\"\n    /&gt;\n);\n\nexport default CustomTable;\n</code></pre> <pre><code>import React from 'react';\nimport CustomTable from './CustomTable';\n\nconst App = () =&gt; {\n    const data = [\n        { id: 1, name: 'John Doe', age: 28, address: 'New York' },\n        { id: 2, name: 'Jane Smith', age: 32, address: 'London' },\n        { id: 3, name: 'George White', age: 45, address: 'Paris' },\n        { id: 4, name: 'Mary Brown', age: 29, address: 'Berlin' },\n        { id: 5, name: 'James Black', age: 38, address: 'Tokyo' },\n    ];\n\n    const columns = [\n        { title: 'Name', dataIndex: 'name', key: 'name' },\n        { title: 'Age', dataIndex: 'age', key: 'age' },\n        { title: 'Address', dataIndex: 'address', key: 'address' }\n    ];\n\n    return (\n        &lt;div&gt;\n            &lt;h2&gt;Custom Table Example&lt;/h2&gt;\n\n            &lt;CustomTable data={data} columns={columns} /&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default App;\n</code></pre>"},{"location":"frontend/js/designpattern/react/antd-resuable-component/#5-modal","title":"5. Modal","text":"<ul> <li> <p>Customizations:</p> <ul> <li>Change modal content (e.g., dynamic content, images, forms).</li> <li>Add custom footer buttons or actions.</li> <li>Handle closing logic (e.g., close on escape, outside click).</li> </ul> </li> <li> <p>Benefits:</p> <ul> <li>Modals are used for displaying notifications, forms, and confirmation dialogs. Customizing modals gives you full control over how they behave, the layout, and the interactions (e.g., customizing the footer with different actions).</li> </ul> </li> </ul> <pre><code>const CustomModal = ({ visible, onCancel, onOk, title, children }) =&gt; (\n  &lt;Modal visible={visible} onCancel={onCancel} onOk={onOk} title={title}&gt;\n    {children}\n  &lt;/Modal&gt;\n);\n</code></pre> ExampleUsage <pre><code>import React from 'react';\nimport { Modal, Button } from 'antd';\n\n// Custom Modal Component\nconst CustomModal = ({ visible, onClose, title, children, footer }) =&gt; (\n    &lt;Modal\n        visible={visible}\n        onCancel={onClose}\n        title={title}\n        footer={footer || [\n            &lt;Button key=\"cancel\" onClick={onClose}&gt;Cancel&lt;/Button&gt;,\n            &lt;Button key=\"ok\" type=\"primary\" onClick={onClose}&gt;OK&lt;/Button&gt;\n        ]}\n    &gt;\n        {children}\n    &lt;/Modal&gt;\n);\n\nexport default CustomModal;\n</code></pre> <pre><code>import React, { useState } from 'react';\nimport CustomModal from './CustomModal';\nimport { Button } from 'antd';\n\nconst App = () =&gt; {\n    const [modalVisible, setModalVisible] = useState(false);\n\n    return (\n        &lt;div&gt;\n            &lt;h2&gt;Custom Modal Example&lt;/h2&gt;\n\n            &lt;Button type=\"primary\" onClick={() =&gt; setModalVisible(true)}&gt;\n                Open Modal\n            &lt;/Button&gt;\n\n            &lt;CustomModal\n                visible={modalVisible}\n                onClose={() =&gt; setModalVisible(false)}\n                title=\"Custom Modal\"\n                footer={null} // You can also customize the footer\n            &gt;\n                &lt;p&gt;This is a custom modal with no footer.&lt;/p&gt;\n            &lt;/CustomModal&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default App;\n</code></pre>"},{"location":"frontend/js/designpattern/react/antd-resuable-component/#6-tooltip","title":"6. Tooltip","text":"<ul> <li> <p>Customizations:</p> <ul> <li>Custom content (e.g., rendering HTML or images).</li> <li>Change positioning (e.g., top, bottom, left, right).</li> <li>Add interactive elements like buttons or links inside tooltips.</li> </ul> </li> <li> <p>Benefits:</p> <ul> <li>Tooltips provide additional information on hover. Customizing tooltips can make them more informative, interactive, or visually aligned with your design.</li> </ul> </li> </ul> <pre><code>const CustomTooltip = ({ title, children }) =&gt; (\n  &lt;Tooltip title={title} placement=\"top\"&gt;\n    {children}\n  &lt;/Tooltip&gt;\n);\n</code></pre> ExampleUsage <pre><code>\n</code></pre> <pre><code>\n</code></pre>"},{"location":"frontend/js/designpattern/react/antd-resuable-component/#7-card","title":"7. Card","text":"<ul> <li> <p>Customizations:</p> <ul> <li>Custom headers, footers, or content.</li> <li>Add custom styling like background color, borders, or shadows.</li> <li>Add actions, buttons, or links within the card.</li> </ul> </li> <li> <p>Benefits:</p> <ul> <li>Cards are a great way to display grouped content. Customizing them allows you to adjust layouts, add different interactive elements, and make them align with your application's visual language.</li> </ul> </li> </ul> <pre><code>const CustomCard = ({ title, content, footer }) =&gt; (\n  &lt;Card title={title} extra={footer} style={{ width: 300 }}&gt;\n    {content}\n  &lt;/Card&gt;\n);\n</code></pre> ExampleUsage <pre><code>\n</code></pre> <pre><code>\n</code></pre>"},{"location":"frontend/js/designpattern/react/antd-resuable-component/#8-notification-alert","title":"8. Notification / Alert","text":"<ul> <li> <p>Customizations:</p> <ul> <li>Custom icons or action buttons.</li> <li>Dynamic styling based on notification type (error, success, info).</li> <li>Add custom close behavior or durations.</li> </ul> </li> <li> <p>Benefits:</p> <ul> <li>Notifications and alerts are critical for providing feedback to users. Customizing them ensures you can control their behavior, appearance, and make them more informative or interactive.</li> </ul> </li> </ul> <pre><code>const CustomNotification = ({ message, description, type }) =&gt; (\n  &lt;Notification\n    message={message}\n    description={description}\n    type={type}\n    duration={4.5}\n  /&gt;\n);\n</code></pre> ExampleUsage <pre><code>import React from 'react';\nimport { notification, Button } from 'antd';\n\n// Custom Notification Component\nconst CustomNotification = ({ message, description, type }) =&gt; {\n    notification[type]({\n        message: message,\n        description: description,\n        duration: 3\n    });\n};\n\nexport default CustomNotification;\n</code></pre> <pre><code>import React from 'react';\nimport CustomNotification from './CustomNotification';\nimport { Button } from 'antd';\n\nconst App = () =&gt; (\n    &lt;div&gt;\n        &lt;h2&gt;Custom Notification Example&lt;/h2&gt;\n\n        &lt;Button onClick={() =&gt; CustomNotification({ message: 'Success', description: 'Your action was successful.', type: 'success' })}&gt;\n            Show Success Notification\n        &lt;/Button&gt;\n\n        &lt;Button onClick={() =&gt; CustomNotification({ message: 'Error', description: 'Something went wrong.', type: 'error' })}&gt;\n            Show Error Notification\n        &lt;/Button&gt;\n    &lt;/div&gt;\n);\n\nexport default App;\n</code></pre>"},{"location":"frontend/js/designpattern/react/antd-resuable-component/#9-progress","title":"9. Progress","text":"<ul> <li> <p>Customizations:</p> <ul> <li>Add custom labels or statuses.</li> <li>Add custom labels or statuses.</li> <li>Display custom icons or text inside the progress bar.</li> </ul> </li> <li> <p>Benefits:</p> <ul> <li>Progress bars are useful for showing tasks or processes. Customizing them helps to display dynamic stages or give more context to the progress.</li> </ul> </li> </ul> <pre><code>const CustomProgress = ({ percent, status, label }) =&gt; (\n  &lt;Progress percent={percent} status={status} format={label} /&gt;\n);\n</code></pre> ExampleUsage <pre><code>\n</code></pre> <pre><code>\n</code></pre>"},{"location":"frontend/js/designpattern/react/antd-resuable-component/#10-avatar","title":"10. Avatar","text":"<ul> <li> <p>Customizations:</p> <ul> <li>Dynamic sources for avatar images (e.g., fetching from a URL or API).</li> <li>Customize size, shape, or status (online/offline).</li> <li>Add initials or fallback icons.</li> </ul> </li> <li> <p>Benefits:</p> <ul> <li>Avatars are used for profile pictures or user representations. Customizing them can provide fallback images, add status indicators, or change sizes dynamically based on the context.</li> </ul> </li> </ul> <pre><code>const CustomAvatar = ({ src, size, status }) =&gt; (\n  &lt;Avatar\n    src={src}\n    size={size}\n    style={{ border: \"2px solid #f0f0f0\" }}\n    status={status}\n  /&gt;\n);\n</code></pre> ExampleUsage <pre><code>\n</code></pre> <pre><code>\n</code></pre>"},{"location":"frontend/js/designpattern/react/antd-resuable-component/#why-customize-these-components","title":"Why Customize These Components?","text":"<ul> <li>Consistency: Customizing common components (buttons, inputs, tables, modals) ensures that your application has a consistent UI, making it easier for users to interact with and understand.</li> <li>User Experience: You can optimize interaction flows and visual feedback by customizing component behaviors, such as adding loading states, icons, or improving accessibility.</li> <li>Brand Alignment: Customization allows you to tailor the look and feel of Ant Design components to fit your brand's design guidelines, improving the overall appearance and user engagement.</li> <li>Functionality: Some components (e.g., modals, tables, inputs) might need to handle custom logic like dynamic data fetching, validation, or interaction with APIs, which requires customization.</li> </ul>"},{"location":"frontend/js/designpattern/react/antd-resuable-component/#conclusion","title":"Conclusion:","text":"<p>The most beneficial components to customize in Ant Design largely depend on your application's needs, but typically, components like <code>Button</code>, <code>Input</code>, <code>Table</code>, <code>Select</code>, <code>Modal</code>, and <code>Card</code> offer significant customization opportunities that can enhance the user experience and align with your app\u2019s design system. Customizing them allows you to implement unique functionalities, tailor the look and feel, and ensure a smooth, consistent interaction flow.</p>"},{"location":"frontend/js/designpattern/react/container-presentation-theory/","title":"Presentation/Container 2","text":""},{"location":"frontend/js/designpattern/react/container-presentation-theory/#intro","title":"Intro","text":"Tip <p>Business logic should ideally be separated from presentation logic to keep the components clean, maintainable, and reusable (using patterns like <code>container/presentational</code> or custom hooks).</p> <p>Yes, the Presentation/Container Pattern and the Smart/Dumb Component Pattern essentially refer to the same concept in React, although the terminology differs slightly.</p>"},{"location":"frontend/js/designpattern/react/container-presentation-theory/#presentationcontainer-pattern","title":"Presentation/Container Pattern","text":"<ul> <li>Container components (also known as smart components) are responsible for handling logic, state management, side effects (like API calls), and passing data to child components.</li> <li>Presentation components (also known as dumb components) are focused purely on rendering UI and are often stateless. They receive data via props and don\u2019t manage any complex logic themselves.</li> </ul>"},{"location":"frontend/js/designpattern/react/container-presentation-theory/#smartdumb-component-pattern","title":"Smart/Dumb Component Pattern","text":"<ul> <li>Smart components are the ones that manage the application's state and logic, fetch data, handle events, etc. These components are \"aware\" of how the application works and are usually stateful.</li> <li>Dumb components are the simple components that only focus on how things look. They receive all their data and behavior via props and don\u2019t have any internal logic or state management. They are \"dumb\" in the sense that they don't manage any logic beyond rendering UI.</li> </ul>"},{"location":"frontend/js/designpattern/react/container-presentation-theory/#key-differences","title":"Key Differences:","text":"<ul> <li>Terminology: The Presentation/Container pattern focuses on the separation of concerns between logic and UI, while Smart/Dumb is more of a common React community terminology that implies which components manage state and behavior.</li> <li> <p>Functional Role: Both terms describe the same idea where:</p> <ul> <li>Smart (Container) components are responsible for the application\u2019s logic, state, and handling side effects.</li> <li>Dumb (Presentational) components are purely responsible for displaying the UI based on the data passed down from the parent.</li> </ul> </li> </ul>"},{"location":"frontend/js/designpattern/react/container-presentation-theory/#example-of-the-two-patterns","title":"Example of the Two Patterns:","text":""},{"location":"frontend/js/designpattern/react/container-presentation-theory/#1-containersmart-component-stateful","title":"1. Container/Smart Component (Stateful)","text":"<pre><code>import React, { useState, useEffect } from \"react\";\nimport TodoList from \"./TodoList\"; // Dumb/Presentational Component\n\nconst TodoContainer = () =&gt; {\n  const [todos, setTodos] = useState([]);\n\n  useEffect(() =&gt; {\n    fetch(\"/api/todos\")\n      .then((response) =&gt; response.json())\n      .then((data) =&gt; setTodos(data));\n  }, []);\n\n  return &lt;TodoList todos={todos} /&gt;;\n};\n\nexport default TodoContainer;\n</code></pre>"},{"location":"frontend/js/designpattern/react/container-presentation-theory/#2-presentationaldumb-component-stateless","title":"2. Presentational/Dumb Component (Stateless)","text":"<pre><code>import React from \"react\";\n\nconst TodoList = ({ todos }) =&gt; (\n  &lt;ul&gt;\n    {todos.map((todo) =&gt; (\n      &lt;li key={todo.id}&gt;{todo.text}&lt;/li&gt;\n    ))}\n  &lt;/ul&gt;\n);\n\nexport default TodoList;\n</code></pre>"},{"location":"frontend/js/designpattern/react/container-presentation-theory/#conclusion","title":"Conclusion:","text":"<ul> <li>Presentation/Container Pattern and Smart/Dumb Pattern are indeed the same.</li> <li>Smart (Container) components manage state, logic, and side effects.</li> <li>Dumb (Presentational) components focus purely on displaying UI.</li> </ul> <p>This pattern is useful for <code>maintainability</code>, <code>testability</code>, and <code>reusability</code> in larger React applications by decoupling UI rendering from business logic.</p>"},{"location":"frontend/js/designpattern/react/container-presentation/","title":"Presentation/Container","text":""},{"location":"frontend/js/designpattern/react/container-presentation/#intro","title":"Intro","text":"<p>In the Presentation/Container Pattern, the naming and structure of files are crucial for maintaining clarity and scalability in your project. While there isn't a strict standard enforced across all React projects, there are widely accepted best practices and conventions for organizing your files and naming components.</p> <p>Here\u2019s how you can structure your files and name your components in a way that follows the Presentation/Container Pattern:</p>"},{"location":"frontend/js/designpattern/react/container-presentation/#1-folder-structure","title":"1. Folder Structure","text":"<p>A common approach is to structure your components in a <code>containers/</code> and <code>components/</code> (or <code>presentational/</code>) folder. The containers will handle logic, while the presentational components will focus on UI rendering.</p> Example Folder Structure: <pre><code>src/\n\u2502\n\u251c\u2500\u2500 components/              # Presentational components\n\u2502   \u251c\u2500\u2500 Button.js            # Dumb component\n\u2502   \u251c\u2500\u2500 TodoItem.js          # Dumb component\n\u2502   \u2514\u2500\u2500 TodoList.js          # Dumb component\n\u2502\n\u251c\u2500\u2500 containers/              # Container components (stateful)\n\u2502   \u251c\u2500\u2500 TodoContainer.js     # Smart component\n\u2502\n\u2514\u2500\u2500 App.js                   # App component, which might use containers\n</code></pre> <p>In this structure:</p> <ul> <li><code>components/</code>: Contains dumb/presentational components that receive data via props and render it. These are reusable UI elements.</li> <li><code>containers/</code>: Contains smart/container components that manage state and handle business logic. These components typically pass props to the presentational components.</li> </ul>"},{"location":"frontend/js/designpattern/react/container-presentation/#2-naming-conventions","title":"2. Naming Conventions","text":""},{"location":"frontend/js/designpattern/react/container-presentation/#for-presentational-dumb-components","title":"For Presentational (Dumb) Components:","text":"<ul> <li>Name them based on what they represent or how they display information.</li> <li>Use descriptive, singular nouns or phrases.</li> <li>These components should be UI-centric and stateless (or minimally stateful, if needed for UI reasons like toggles, form inputs, etc.).</li> </ul> Example <ul> <li><code>TodoItem.js</code>: Displays an individual todo.</li> <li><code>Button.js</code>: A simple button component.</li> <li><code>Header.js:</code> Renders a header UI.</li> </ul> <pre><code>// components/TodoItem.js\nimport React from 'react';\n\nconst TodoItem = ({ todo }) =&gt; {\n    return &lt;li&gt;{todo.text}&lt;/li&gt;;\n};\n\nexport default TodoItem;\n</code></pre>"},{"location":"frontend/js/designpattern/react/container-presentation/#for-container-smart-components","title":"For Container (Smart) Components:","text":"<ul> <li>Name them based on their function or the data they manage.</li> <li>The name should describe the container's responsibility (e.g., managing todos, user info).</li> <li>It is common to name them with the suffix <code>Container</code> (e.g., <code>TodoContainer.js</code> or <code>UserContainer.js</code>).</li> </ul> Example <ul> <li><code>TodoContainer.js</code>: Fetches and manages the todo list, passing data to TodoItem.</li> <li><code>UserContainer.js</code>: Manages the user authentication and data, passing data to a presentational component like <code>UserProfile</code>.</li> </ul> <pre><code>// containers/TodoContainer.js\nimport React, { useState, useEffect } from 'react';\nimport TodoItem from '../components/TodoItem';\n\nconst TodoContainer = () =&gt; {\n    const [todos, setTodos] = useState([]);\n\n    useEffect(() =&gt; {\n        // Imagine fetching todos from an API\n        const fetchTodos = async () =&gt; {\n            const response = await fetch('/api/todos');\n            const data = await response.json();\n            setTodos(data);\n        };\n\n        fetchTodos();\n    }, []);\n\n    return (\n        &lt;ul&gt;\n            {todos.map(todo =&gt; (\n                &lt;TodoItem key={todo.id} todo={todo} /&gt;\n            ))}\n        &lt;/ul&gt;\n    );\n};\n\nexport default TodoContainer;\n</code></pre>"},{"location":"frontend/js/designpattern/react/container-presentation/#3-use-clear-and-descriptive-file-names","title":"3. Use Clear and Descriptive File Names","text":"<p>Be clear in naming so it\u2019s immediately obvious which component is responsible for what:</p> <ul> <li> <p>Presentational Components: Prefer naming files after their role or function in the UI.</p> <ul> <li><code>Button.js</code>, <code>Header.js</code>, <code>TodoItem.js</code></li> </ul> </li> <li> <p>Container Components: Use the Container suffix to highlight that this component is responsible for logic and managing state.</p> <ul> <li><code>TodoContainer.js</code>, <code>UserContainer.js</code>, <code>ProfileContainer.js</code></li> </ul> </li> </ul> <p>This naming system allows you to easily understand the structure of the project just by looking at the file names.</p>"},{"location":"frontend/js/designpattern/react/container-presentation/#4-organizing-components-and-containers-together-optional","title":"4. Organizing Components and Containers Together (Optional)","text":"<p>In smaller projects, you might keep components and containers in the same directory or use subdirectories for a more modular approach.</p> Example folder structure with modular subfolders <pre><code>src/\n\u2502\n\u251c\u2500\u2500 features/                # Feature-based organization\n\u2502   \u251c\u2500\u2500 todos/\n\u2502   \u2502   \u251c\u2500\u2500 components/      # Presentational components related to todos\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 TodoItem.js\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 TodoList.js\n\u2502   \u2502   \u2514\u2500\u2500 containers/      # Containers for managing todos\n\u2502   \u2502       \u2514\u2500\u2500 TodoContainer.js\n\u2502   \u2514\u2500\u2500 users/\n\u2502       \u251c\u2500\u2500 components/      # Presentational components related to users\n\u2502       \u2514\u2500\u2500 containers/\n\u2502           \u2514\u2500\u2500 UserContainer.js\n\u2502\n\u2514\u2500\u2500 App.js\n</code></pre> <p>This approach groups related components by feature or domain rather than separating strictly by the component type (presentational vs. container).</p>"},{"location":"frontend/js/designpattern/react/container-presentation/#5-component-folder-with-index-file","title":"5. Component Folder with Index File","text":"<p>In some cases, you can also use an <code>index.js</code> file inside each feature or container folder to simplify imports.</p> Example <pre><code>src/\n\u2502\n\u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 TodoItem.js\n\u2502   \u2514\u2500\u2500 index.js   # Exports all components in this folder\n\u2502\n\u251c\u2500\u2500 containers/\n\u2502   \u251c\u2500\u2500 TodoContainer.js\n\u2502   \u2514\u2500\u2500 index.js   # Exports all containers in this folder\n\u2502\n\u2514\u2500\u2500 App.js\n</code></pre> <p><code>index.js</code> can look like this:</p> <pre><code>// components/index.js\nexport { default as TodoItem } from \"./TodoItem\";\n</code></pre> <p>This way, you can import components in <code>TodoContainer.js</code> like:</p> <pre><code>import { TodoItem } from \"../components\";\n</code></pre> <p>This keeps the import statements clean and scalable, especially as the project grows.</p>"},{"location":"frontend/js/designpattern/react/container-presentation/#summary-of-best-practices-for-file-structure-and-naming","title":"Summary of Best Practices for File Structure and Naming:","text":"<ol> <li> <p>File Organization:</p> <ul> <li>Store Presentational Components in a <code>components/</code> folder.</li> <li>Store Container Components in a <code>containers/</code> folder.</li> <li>Optionally, group by feature if your project scales.</li> </ul> </li> <li> <p>Naming Convention:</p> <ul> <li>Presentational/Dumb Components: Name them based on their function or the UI they represent (e.g., <code>TodoItem.js</code>, <code>Button.js</code>).</li> <li>Container/Smart Components: Use the <code>Container</code> suffix to indicate their role (e.g., <code>TodoContainer.js</code>, <code>UserContainer.js</code>).</li> </ul> </li> <li> <p>Modularity:</p> <ul> <li>As the project grows, consider grouping components by features or domains (e.g., <code>features/todos/</code>, <code>features/users/</code>).</li> </ul> </li> <li> <p>Avoid Overcomplication:</p> <ul> <li>Don\u2019t over-structure\u2014keep things simple in the beginning and scale as necessary.</li> </ul> </li> </ol> <p>By following these practices, you'll keep your codebase organized, modular, and maintainable as it grows.</p>"},{"location":"frontend/js/designpattern/react/custom-component/","title":"custom component","text":"<p>Whether to directly use the Statistic component or to create a CustomStatistic component depends on a few factors such as reusability, flexibility, and code clarity. Let's explore both approaches:</p>"},{"location":"frontend/js/designpattern/react/custom-component/#1-directly-using-the-statistic-component","title":"1. Directly Using the <code>Statistic</code> Component:","text":"ExampleExplanation <pre><code>&lt;Statistic\n    title=\"Active\"\n    value={11.28}\n    precision={2}\n    valueStyle={{\n        color: \"#3f8600\",\n    }}\n    suffix=\"%\"\n/&gt;\n</code></pre> <p>This approach is perfectly fine if:</p> <ul> <li>The <code>Statistic</code> component is used only once in your app, and you don't need to customize it often.</li> <li>You don't foresee needing to make changes like adding custom logic, styling, or behavior that is specific to this <code>Statistic</code> in multiple places.</li> </ul>"},{"location":"frontend/js/designpattern/react/custom-component/#2-creating-a-customstatistic-component","title":"2. Creating a <code>CustomStatistic</code> Component:","text":"ExampleExplanation <pre><code>const CustomStatistic = ({ title, value, suffix }) =&gt; (\n    &lt;Statistic\n        title={title}\n        value={value}\n        precision={2}\n        valueStyle={{\n            color: \"#3f8600\",\n        }}\n        suffix={suffix}\n    /&gt;\n);\n\n// Usage:\n&lt;CustomStatistic title=\"Active\" value={11.28} suffix=\"%\" /&gt;;\n</code></pre> <p>This approach is preferable if:</p> <ul> <li> <p>Reusability: You need to reuse the same <code>Statistic</code> component with the same style and behavior across multiple places in your app. In this case, creating a <code>CustomStatistic</code> component can help centralize and simplify any future changes to styling or logic (like adding additional customization).</p> </li> <li> <p>Consistency: If you have specific design patterns or customizations (like value styles, precision, or color) that need to be applied consistently across multiple statistics in your app, wrapping the <code>Statistic</code> in a custom component ensures all instances follow the same pattern without repetitive code.</p> </li> <li> <p>Extendability: If you might want to add more logic or dynamic behavior (like fetching the value, conditionally changing the color, or adding icons) in the future, having a <code>CustomStatistic</code> component gives you more flexibility.</p> </li> </ul>"},{"location":"frontend/js/designpattern/react/custom-component/#when-to-choose-each-approach","title":"When to Choose Each Approach","text":"<p>Use the <code>Statistic</code> directly:</p> <ul> <li>When it's a one-off use case.</li> <li>When you don\u2019t need customization or reuse.</li> </ul> <p>Create a <code>CustomStatistic</code> component:</p> <ul> <li>When the same logic/style is used in multiple places in your app.</li> <li>When you need to easily update or extend functionality (like adding a prefix, conditionally changing styles, adding animation, etc.).</li> </ul> <p>Example of Extending with More Flexibility (Custom Component):</p> <p>If you want to add more flexibility, like having a custom icon prefix, or allowing for dynamic color based on the value, you can extend your <code>CustomStatistic</code>:</p> <pre><code>const CustomStatistic = ({ title, value, suffix, icon, color }) =&gt; (\n  &lt;Statistic\n    title={title}\n    value={value}\n    precision={2}\n    valueStyle={{\n      color: color || \"#3f8600\", // Default to green if no color is provided\n    }}\n    prefix={icon}\n    suffix={suffix}\n  /&gt;\n);\n\n// Usage with dynamic values:\n&lt;CustomStatistic\n  title=\"Active\"\n  value={11.28}\n  suffix=\"%\"\n  icon={&lt;ArrowUpOutlined /&gt;}\n  color={value &gt; 10 ? \"#3f8600\" : \"#cf1322\"} // Example dynamic color based on value\n/&gt;;\n</code></pre> <p>Conclusion:</p> <ul> <li>Use <code>Statistic</code> directly when you're working with just a single instance and the customization needs are minimal.</li> <li>Create <code>CustomStatistic</code> if you need more flexibility, reuse, or consistency across your app, or if you're likely to extend the functionality in the future.</li> </ul> <p>In most cases, creating a <code>CustomStatistic</code> is a better practice if you're building a larger app with multiple similar components. It can save you time in the long run and make your code more maintainable.</p>"},{"location":"frontend/js/designpattern/react/intro/","title":"Intro","text":"<p>How can I use design patterns in real-time for large-scale web applications, and how do they fit into daily development?</p>"},{"location":"frontend/js/designpattern/react/intro/#overview","title":"Overview","text":"<p>In large-scale web applications, using design patterns helps improve code scalability, maintainability, and modularity. Here\u2019s how you can apply the most common patterns in real-time scenarios in a large web application, especially using JavaScript and React.</p>"},{"location":"frontend/js/designpattern/react/intro/#1-module-pattern-javascript-custom-hooks-react","title":"1. Module Pattern (JavaScript) / Custom Hooks (React)","text":"<p>Real-time Scenario:</p> <p>In a large web app, you often need to reuse logic like API calls, authentication checks, or form handling. Encapsulating these into modules (JavaScript) or custom hooks (React) ensures that the logic is reusable and maintainable.</p> <p>Real-world Example in React:</p> <p>Imagine you have a large application that requires fetching data from multiple APIs. You can create a custom hook for handling API requests.</p> <pre><code>// useFetch.js (Custom Hook)\nimport { useState, useEffect } from \"react\";\n\nfunction useFetch(url) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() =&gt; {\n    async function fetchData() {\n      try {\n        const response = await fetch(url);\n        const result = await response.json();\n        setData(result);\n      } catch (err) {\n        setError(err);\n      } finally {\n        setLoading(false);\n      }\n    }\n    fetchData();\n  }, [url]);\n\n  return { data, loading, error };\n}\n\n// Component usage\nfunction Users() {\n  const { data, loading, error } = useFetch(\n    \"https://jsonplaceholder.typicode.com/users\"\n  );\n\n  if (loading) return &lt;p&gt;Loading...&lt;/p&gt;;\n  if (error) return &lt;p&gt;Error loading data.&lt;/p&gt;;\n\n  return (\n    &lt;ul&gt;\n      {data.map((user) =&gt; (\n        &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  );\n}\n</code></pre> <p>Why Daily?</p> <p>In large-scale applications, Custom Hooks and Modules help you abstract repetitive logic like API calls, authentication, or state handling, making it easier to maintain the code.</p>"},{"location":"frontend/js/designpattern/react/intro/#2-observer-pattern-javascript-context-api-react","title":"2. Observer Pattern (JavaScript) / Context API (React)","text":"<p>Real-time Scenario:</p> <p>A large-scale app might need to notify multiple components about global changes like theme updates or user authentication state. The Observer Pattern in JavaScript, or Context API in React, allows for this kind of communication across the app.</p> <p>Real-world Example in React (Using Context API for Theme Management):</p> <pre><code>// themeContext.js\nimport React, { createContext, useState, useContext } from \"react\";\n\nconst ThemeContext = createContext();\n\nexport function ThemeProvider({ children }) {\n  const [theme, setTheme] = useState(\"light\");\n\n  const toggleTheme = () =&gt; {\n    setTheme(theme === \"light\" ? \"dark\" : \"light\");\n  };\n\n  return (\n    &lt;ThemeContext.Provider value={{ theme, toggleTheme }}&gt;\n      {children}\n    &lt;/ThemeContext.Provider&gt;\n  );\n}\n\nexport function useTheme() {\n  return useContext(ThemeContext);\n}\n\n// Any component\nfunction ThemeToggler() {\n  const { theme, toggleTheme } = useTheme();\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Current theme: {theme}&lt;/p&gt;\n      &lt;button onClick={toggleTheme}&gt;Toggle Theme&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\n// App.js\nimport { ThemeProvider } from \"./themeContext\";\nimport ThemeToggler from \"./ThemeToggler\";\n\nfunction App() {\n  return (\n    &lt;ThemeProvider&gt;\n      &lt;ThemeToggler /&gt;\n    &lt;/ThemeProvider&gt;\n  );\n}\n</code></pre> <p>Why Daily?</p> <p>You use Context API to handle global state changes (e.g., user preferences, authentication) that need to be accessible across multiple components in a large web app, ensuring consistency and avoiding prop-drilling.</p>"},{"location":"frontend/js/designpattern/react/intro/#3-factory-pattern-javascript-component-composition-react","title":"3. Factory Pattern (JavaScript) / Component Composition (React)","text":"<p>Real-time Scenario:</p> <p>When building complex forms or UI components that need to adapt based on user input or app state, the Factory Pattern in JavaScript or Component Composition in React is ideal.</p> <p>Real-world Example in React (Form Factory):</p> <pre><code>// FieldFactory.js\nfunction FieldFactory({ field }) {\n  switch (field.type) {\n    case \"text\":\n      return &lt;input type=\"text\" placeholder={field.label} /&gt;;\n    case \"select\":\n      return (\n        &lt;select&gt;\n          {field.options.map((option) =&gt; (\n            &lt;option key={option} value={option}&gt;\n              {option}\n            &lt;/option&gt;\n          ))}\n        &lt;/select&gt;\n      );\n    case \"checkbox\":\n      return &lt;input type=\"checkbox\" /&gt;;\n    default:\n      return null;\n  }\n}\n\n// DynamicForm.js\nfunction DynamicForm({ fields }) {\n  return (\n    &lt;form&gt;\n      {fields.map((field, index) =&gt; (\n        &lt;div key={index}&gt;\n          &lt;label&gt;{field.label}&lt;/label&gt;\n          &lt;FieldFactory field={field} /&gt;\n        &lt;/div&gt;\n      ))}\n    &lt;/form&gt;\n  );\n}\n\n// Usage\nconst formFields = [\n  { type: \"text\", label: \"Username\" },\n  { type: \"select\", label: \"Country\", options: [\"USA\", \"Canada\"] },\n  { type: \"checkbox\", label: \"Accept Terms\" },\n];\n\nfunction App() {\n  return &lt;DynamicForm fields={formFields} /&gt;;\n}\n</code></pre> <p>Why Daily?</p> <p>In large-scale applications, Factory Patterns or Component Composition help you manage the complexity of dynamic UIs and forms by allowing you to create components based on configurations or user input.</p>"},{"location":"frontend/js/designpattern/react/intro/#4-singleton-pattern-javascript-redux-store-react","title":"4. Singleton Pattern (JavaScript) / Redux Store (React)","text":"<p>Real-time Scenario:</p> <p>When managing shared state (e.g., user authentication, cart items) across multiple parts of your app, a Singleton in JavaScript or Redux Store in React ensures that you have a single source of truth.</p> <p>Real-world Example in React (Redux Store for Global State):</p> <pre><code>// store.js (Redux setup)\nimport { createStore } from \"redux\";\n\nconst initialState = { isAuthenticated: false };\n\nfunction authReducer(state = initialState, action) {\n  switch (action.type) {\n    case \"LOGIN\":\n      return { ...state, isAuthenticated: true };\n    case \"LOGOUT\":\n      return { ...state, isAuthenticated: false };\n    default:\n      return state;\n  }\n}\n\nconst store = createStore(authReducer);\n\n// Component usage (React + Redux)\nimport { useSelector, useDispatch } from \"react-redux\";\n\nfunction AuthButton() {\n  const dispatch = useDispatch();\n  const isAuthenticated = useSelector((state) =&gt; state.isAuthenticated);\n\n  return (\n    &lt;div&gt;\n      {isAuthenticated ? (\n        &lt;button onClick={() =&gt; dispatch({ type: \"LOGOUT\" })}&gt;Logout&lt;/button&gt;\n      ) : (\n        &lt;button onClick={() =&gt; dispatch({ type: \"LOGIN\" })}&gt;Login&lt;/button&gt;\n      )}\n    &lt;/div&gt;\n  );\n}\n\n// App.js\nimport { Provider } from \"react-redux\";\nimport AuthButton from \"./AuthButton\";\nimport store from \"./store\";\n\nfunction App() {\n  return (\n    &lt;Provider store={store}&gt;\n      &lt;AuthButton /&gt;\n    &lt;/Provider&gt;\n  );\n}\n</code></pre> <p>Why Daily?</p> <p>Redux (or any global state management tool like Zustand) is essential in large apps for managing state across components. It\u2019s a clear example of the Singleton Pattern, ensuring only one instance of your app\u2019s state exists.</p>"},{"location":"frontend/js/designpattern/react/intro/#5-decorator-pattern-javascript-higher-order-components-react","title":"5. Decorator Pattern (JavaScript) / Higher-Order Components (React)","text":"<p>Real-time Scenario:</p> <p>In a large app, you may want to add functionality (e.g., logging, authentication, or permissions) to components dynamically without modifying their implementation. The Decorator Pattern in JavaScript or Higher-Order Components (HOC) in React provides this flexibility.</p> <p>Real-world Example in React (HOC for Authorization):</p> <pre><code>// withAuth.js (HOC for authorization)\nfunction withAuth(WrappedComponent) {\n  return function (props) {\n    const isAuthenticated = useAuth(); // custom hook for checking auth\n\n    if (!isAuthenticated) {\n      return &lt;p&gt;You are not authorized to view this content&lt;/p&gt;;\n    }\n\n    return &lt;WrappedComponent {...props} /&gt;;\n  };\n}\n\n// SomeProtectedComponent.js\nfunction SomeProtectedComponent() {\n  return &lt;p&gt;Secret Content: You are authorized!&lt;/p&gt;;\n}\n\n// Usage in App.js\nconst ProtectedComponent = withAuth(SomeProtectedComponent);\n\nfunction App() {\n  return &lt;ProtectedComponent /&gt;;\n}\n</code></pre> <p>Why Daily?</p> <p>In large-scale web applications, HOCs and Decorators allow you to add functionality like authentication checks, logging, or performance tracking to components without duplicating code.</p>"},{"location":"frontend/js/designpattern/react/intro/#conclusion","title":"Conclusion:","text":"<p>In large-scale web applications, design patterns play a crucial role in organizing code, making it reusable, maintainable, and scalable. Here\u2019s how you can apply them:</p> <ol> <li>Module Pattern/Custom Hooks: Reuse logic (e.g., API calls, state handling).</li> <li>Observer Pattern/Context API: Manage global state (e.g., themes, auth).</li> <li>Factory Pattern/Component Composition: Dynamically generate components.</li> <li>Singleton Pattern/Redux Store: Centralized state management.</li> <li>Decorator Pattern/HOCs: Add cross-cutting concerns (e.g., auth, logging).</li> </ol> <p>Mastering these patterns ensures that your application remains efficient and maintainable as it grows.</p>"},{"location":"frontend/js/designpattern/react/mostly-used/","title":"Mostly Used","text":""},{"location":"frontend/js/designpattern/react/mostly-used/#overview","title":"Overview","text":"<p>In React, several design patterns are commonly used due to their flexibility and the nature of component-based development. While different projects and teams may lean towards different patterns depending on specific use cases, the following patterns are most frequently used in React applications:</p>"},{"location":"frontend/js/designpattern/react/mostly-used/#1-containerpresentational-pattern","title":"1. Container/Presentational Pattern","text":"<ul> <li> <p>Use case: Separates the concerns of data management (container) and UI rendering (presentational).</p> </li> <li> <p>Why it's used: Helps keep React components clean, focused, and maintainable by separating logic and UI.</p> </li> <li> <p>Container: Handles the state, logic, and side-effects.</p> </li> <li> <p>Presentational: Focuses only on rendering UI and receiving data via props.</p> </li> <li> <p>Example: In a Todo app, the Container might manage the state of the todo list, while the Presentational component would just display it.</p> </li> </ul>"},{"location":"frontend/js/designpattern/react/mostly-used/#2-higher-order-component-hoc-pattern","title":"2. Higher-Order Component (HOC) Pattern","text":"<ul> <li>Use case: Enhances or modifies a component by wrapping it in another component.</li> <li>Why it's used: Reusable logic can be abstracted and shared across components without altering their structure.</li> <li>Example: You might create an HOC for adding <code>authentication checks</code>, which wraps the component and checks if the user is logged in before rendering the UI.</li> </ul>"},{"location":"frontend/js/designpattern/react/mostly-used/#3-render-props-pattern","title":"3. Render Props Pattern","text":"<ul> <li>Use case: Allows sharing code between components using a function that returns a React element.</li> <li>Why it's used: Enables component logic to be shared without relying on inheritance or wrapping. It's more flexible than HOCs and allows you to inject UI elements based on shared logic.</li> <li>Example: A component might use <code>render props</code> to share a piece of functionality (like mouse position) with other components that need it.</li> </ul>"},{"location":"frontend/js/designpattern/react/mostly-used/#4-state-as-a-function-of-props-pattern","title":"4. State as a Function of Props Pattern","text":"<ul> <li>Use case: Using props to define the state of a component, rather than managing it internally.</li> <li>Why it's used: Encourages more predictable, testable, and reusable components.</li> <li>Example: React hooks, like <code>useState</code>, and even <code>Redux</code> (state management library) often adopt this pattern, where the state reflects props passed to the component.</li> </ul>"},{"location":"frontend/js/designpattern/react/mostly-used/#5-compound-component-pattern","title":"5. Compound Component Pattern","text":"<ul> <li>Use case: Allows components to work together in a way where they implicitly share state and behavior.</li> <li>Why it's used: Encapsulates the logic of a set of components, making them easy to use together without explicitly managing their relationships.</li> <li>Example: A <code>Tabs component</code> where the <code>Tab children</code> automatically know which one is active.</li> </ul>"},{"location":"frontend/js/designpattern/react/mostly-used/#6-context-api-pattern","title":"6. Context API Pattern","text":"<ul> <li>Use case: Sharing state globally across deeply nested components without having to pass props down manually.</li> <li>Why it's used: Great for managing global state like themes, authentication, or user preferences.</li> <li>Example: You might use <code>React's Context API</code> to share the user's authentication state across the entire app without having to pass the props down to each component.</li> </ul>"},{"location":"frontend/js/designpattern/react/mostly-used/#7-component-composition-pattern","title":"7. Component Composition Pattern","text":"<ul> <li>Use case: Combining small, reusable components to create more complex UIs.</li> <li>Why it's used: Encourages reusability and maintainability, following React\u2019s philosophy of building small, focused components.</li> <li>Example: A <code>Button</code> component may be used inside other components like <code>Card</code>, <code>Modal</code>, etc., to create consistent and reusable UI elements.</li> </ul>"},{"location":"frontend/js/designpattern/react/mostly-used/#8-observer-pattern-via-hooks-like-useeffect","title":"8. Observer Pattern (via Hooks like <code>useEffect</code>)","text":"<ul> <li>Use case: Observing changes in state or props and performing side effects.</li> <li>Why it's used: React\u2019s <code>useEffect</code> hook is a good example of an Observer Pattern, where components react to changes in state or props, making it easy to manage side effects like fetching data, subscribing to events, etc.</li> <li>Example: You might use <code>useEffect</code> to fetch data when the component mounts or when certain state variables change.</li> </ul>"},{"location":"frontend/js/designpattern/react/mostly-used/#which-one-is-most-used-in-react","title":"Which One is Most Used in React?","text":"<p>The most commonly used patterns in React are:</p> <ul> <li>Container/Presentational Pattern: This is often used to keep logic separate from the UI, especially in larger applications where managing the state is a concern.</li> <li>Higher-Order Components (HOCs) and Render Props: These two patterns are also widely used for code reuse, though with the introduction of React Hooks, many developers have shifted away from HOCs in favor of hooks for shared logic.</li> <li>Context API: For managing state globally and passing it down the component tree without having to manually pass props, especially in large apps.</li> <li>Component Composition: The core idea behind React is to compose components, so this pattern is used constantly in React applications.</li> </ul> <p>So, in summary, <code>Component Composition</code> and <code>Hooks</code> (State as a Function of Props) are foundational to React, and <code>Container/Presentational</code> and <code>HOCs/Render Props</code> are also commonly used. The use of these patterns depends on the app's complexity and requirements.</p>"},{"location":"frontend/js/ecmascript/defaultParameters/","title":"defaultParameters","text":""},{"location":"frontend/js/ecmascript/defaultParameters/#defaultparameters-ecmascript-6","title":"defaultParameters (ECMAScript 6)","text":"<p>Many languages allow you to choose default values for arguments in the method signature. Finally, in <code>ECMAScript 6 (ES 6)</code>, JavaScript will be one of those languages</p> <pre><code>var join = function (\n  foo = \"foo\",\n  baz = foo === \"foo\" ? join(foo + \"!\") : \"baz\"\n) {\n  return foo + \":\" + baz;\n};\n\n// =&gt; hi:there\nconsole.log(join(\"hi\", \"there\"));\n\n// Use the default parameter when not supplied\n// =&gt; hi:baz\nconsole.log(join(\"hi\"));\n\n// Use the default parameter when undefined is supplied\n// =&gt; foo:there\n\nconsole.log(join(undefined, \"there\"));\n\n// Use an expression which has access to the current set of arguments\n// =&gt; foo:foo!:baz\nconsole.log(join(\"foo\"));\n</code></pre>"},{"location":"frontend/js/ecmascript/defaultParameters/#reference","title":"Reference","text":"<ul> <li>Expert JavaScript by Mark E. Daggett</li> </ul>"},{"location":"frontend/js/ecmascript/es6/","title":"Intro","text":""},{"location":"frontend/js/ecmascript/es6/#javascript-es6","title":"JavaScript ES6","text":"<p>ES6 is a significant update. It contains a whole host of new features for JavaScript, almost two dozen in total. JavaScript written in ES6 is tangibly different than JavaScript written in ES5.</p> <p>The most important ECMAScript version is generally considered to be <code>ECMAScript 2015 (ES6)</code>. Here are the reasons why ES6 is so significant:</p>"},{"location":"frontend/js/ecmascript/es6/#impact-of-es6","title":"Impact of ES6:","text":"<ul> <li>Modern JavaScript: ES6 transformed JavaScript into a more modern, powerful, and developer-friendly language.</li> <li>Tooling and Frameworks: Many modern JavaScript frameworks and libraries (e.g., React, Angular, Vue.js) heavily utilize ES6 features.</li> <li>Backward Compatibility: Tools like Babel allow developers to write ES6+ code while maintaining compatibility with older browsers.</li> <li>Standardization: Set the foundation for annual updates to the ECMAScript specification, ensuring continuous improvement of the language.</li> </ul> <p>Due to these significant enhancements and its foundational role in modern JavaScript development, ECMAScript 2015 (ES6) is often regarded as the most important ECMAScript version.</p>"},{"location":"frontend/js/ecmascript/es6/#key-features-of-es6","title":"Key Features of ES6:","text":"React <p>There are two ways to declare React components:</p> <ol> <li>ES6 classes</li> <li>Function components</li> </ol> <p>An example of using an ES6 class:</p> <pre><code>class HelloWorld extends React.Component {\n    render() { return &lt;p&gt;Hello, world!&lt;/p&gt;; }\n}\n</code></pre> <p>The same component written in a \u201cfunctional component\u201d style:</p> <pre><code>function HelloWorld() {\n    return &lt;p&gt;Hello, world!&lt;/p&gt;;\n}\n</code></pre> <p>At the time of writing, both types of declarations are in widespread use. </p> <p>While they both do essentially the same thing, there are some important differences that we\u2019ll get to later in the book.</p> <p>We\u2019ll be using ES6 class components through much of the book, but we\u2019ll be using function components from time-to-time as well. While it might seem cleaner to just pick one, you\u2019ll encounter (and use) both in your real-world work. So we\u2019ll cover both.</p> <ul> <li>Fullstack React The Complete Guide to ReactJS and Friends by Anthony Accomazzo :21</li> </ul>"},{"location":"frontend/js/ecmascript/spread-vs-rest-operator/","title":"Spread vs Rest Operator","text":""},{"location":"frontend/js/ecmascript/spread-vs-rest-operator/#spread-vs-rest-polar-opposite-twins","title":"Spread vs. Rest <code>\u2014 Polar Opposite Twins</code>","text":"<p>One will have observed that the syntax for the rest parameter and the spread operator is identical, but their behavior is the exact opposite of one another. The rest parameter \u201ccollects\u201d all the unaccounted arguments supplied to a function into an array, while the spread operator extracts all the elements out of an array. What differentiates what the ... syntax does depends on the invocation context. ... only acts as the rest parameter when an assignment happens, and if not, then it acts as a spread operator. This contradiction can be both interesting and disconcerting at the same time:</p> <p>Differences Between Spread and Rest</p> <ol> <li> <p>Spread Operator: Expands an array or object into individual elements.</p> <ul> <li>Example: <code>...array</code></li> </ul> </li> <li> <p>Rest Operator: Collects multiple elements into a single array.</p> <ul> <li>Example: <code>...args</code></li> </ul> </li> </ol> <p>Tip</p>"},{"location":"frontend/js/ecmascript/spread-vs-rest-operator/#destructuring","title":"Destructuring","text":"Array DestructuringObject DestructuringCombination"},{"location":"frontend/js/ecmascript/spread-vs-rest-operator/#reference","title":"Reference","text":"<ul> <li>JavaScript Next by Raju Gandhi, pg: 48</li> </ul>"},{"location":"frontend/js/essential/array-prototype/","title":"Array Prototype","text":""},{"location":"frontend/js/essential/array-prototype/#array-prototype","title":"Array Prototype","text":"<p>In JavaScript, the Array prototype is an object that contains methods and properties available to all arrays. When you create a new array, it inherits these methods and properties through its prototype chain.</p> <p>Here's how the prototype chain works for arrays:</p> <ul> <li>When you create an array like <code>let myArray = [1, 2, 3];</code>, myArray inherits from <code>Array.prototype</code>.</li> <li>Array.prototype is itself an object that inherits from Object.prototype.</li> </ul>"},{"location":"frontend/js/essential/array-prototype/#why-is-the-array-prototype-important","title":"Why is the Array Prototype Important?","text":"<ul> <li> <p>Inheritance:</p> <p>All arrays have access to the methods defined on Array.prototype. This means you can call methods like push, pop, map, filter, etc., on any array.</p> <pre><code>let myArray = [1, 2, 3];\nmyArray.push(4);\nconsole.log(myArray); // [1, 2, 3, 4]\n</code></pre> </li> <li> <p>Extensibility:</p> <p>You can add custom methods to all arrays by modifying <code>Array.prototype</code>. However, this is generally discouraged in practice because it can lead to conflicts and unexpected behavior, especially in shared environments or libraries.</p> <pre><code>Array.prototype.first = function() {\n    return this[0];\n};\n\nlet myArray = [1, 2, 3];\nconsole.log(myArray.first()); // 1\n</code></pre> </li> <li> <p>Efficiency:</p> <p>By defining methods on the prototype, JavaScript ensures that only one copy of each method exists in memory, regardless of the number of arrays you create. This is more efficient than defining the same method individually for each array instance.</p> </li> </ul>"},{"location":"frontend/js/essential/array-prototype/#example-of-adding-a-custom-method-to-array-prototype","title":"Example of Adding a Custom Method to Array Prototype","text":"<pre><code>Array.prototype.last = function() {\n  return this[this.length - 1];\n};\n\nlet myArray = [1, 2, 3, 4];\nconsole.log(myArray.last()); // 4\n</code></pre> <p>In this example:</p> <ul> <li>We add a last method to <code>Array.prototype</code>, which returns the last element of the array.</li> <li>All arrays now have access to this <code>last</code> method.</li> </ul>"},{"location":"frontend/js/essential/array-prototype/#summary","title":"Summary","text":"<ul> <li> <p>Higher-order functions are functions that operate on other functions, either by taking them as arguments or by returning them. Many array methods in JavaScript are higher-order functions.</p> </li> <li> <p>The Array prototype is an object from which all arrays inherit their methods and properties. It allows for method sharing and efficient memory use, as well as extensibility by adding custom methods.</p> </li> </ul>"},{"location":"frontend/js/essential/array-prototype/#most-important-about-array","title":"Most Important about Array","text":"<p>One of the most important things to learn about arrays in JavaScript to master advanced programming is understanding and effectively utilizing higher-order functions provided by the Array prototype. These functions include methods like <code>map()</code>, <code>filter()</code>, <code>reduce()</code>, <code>forEach()</code>, <code>find()</code>, <code>some()</code>, and <code>every()</code>. Mastering these functions allows you to write concise, expressive, and efficient code for manipulating and processing arrays</p> Example and Explanation of Key Higher-Order Functions: <ol> <li> <p>map():</p> <p>Creates a new array populated with the results of calling a provided function on every element in the calling array.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst doubled = numbers.map(num =&gt; num * 2);\nconsole.log(doubled); // [2, 4, 6, 8]\n</code></pre> </li> <li> <p>filter():</p> <p>Creates a new array with all elements that pass the test implemented by the provided function.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst evens = numbers.filter(num =&gt; num % 2 === 0);\nconsole.log(evens); // [2, 4]\n</code></pre> </li> <li> <p>reduce():</p> <p>Executes a reducer function on each element of the array, resulting in a single output value.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst sum = numbers.reduce((accumulator, currentValue) =&gt; accumulator + currentValue, 0);\nconsole.log(sum); // 10\n</code></pre> </li> <li> <p>forEach():</p> <p>Executes a provided function once for each array element.</p> <pre><code>const numbers = [1, 2, 3, 4];\nnumbers.forEach(num =&gt; console.log(num));\n// Outputs: 1, 2, 3, 4\n</code></pre> </li> <li> <p>find():</p> <p>Returns the value of the first element in the provided array that satisfies the provided testing function.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst firstEven = numbers.find(num =&gt; num % 2 === 0);\nconsole.log(firstEven); // 2\n</code></pre> </li> <li> <p>some():</p> <p>Tests whether at least one element in the array passes the test implemented by the provided function. It returns a Boolean value.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst hasEven = numbers.some(num =&gt; num % 2 === 0);\nconsole.log(hasEven); // true\n</code></pre> </li> <li> <p>every():</p> <p>Tests whether all elements in the array pass the test implemented by the provided function. It returns a Boolean value.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst allEven = numbers.every(num =&gt; num % 2 === 0);\nconsole.log(allEven); // false\n</code></pre> </li> </ol>"},{"location":"frontend/js/essential/array-prototype/#why-mastering-these-functions-is-important","title":"Why Mastering These Functions is Important:","text":"<ul> <li>Expressiveness: They allow you to express complex operations on arrays concisely and declaratively.</li> <li>Readability: Code written with these methods is often more readable and easier to understand, as it closely matches the high-level description of the logic.</li> <li>Functional Programming: These methods are fundamental to functional programming techniques, which are powerful for writing clean, maintainable, and bug-resistant code.</li> <li>Efficiency: They are optimized for performance in most JavaScript engines, making them efficient for large datasets.</li> </ul> <p>Understanding and mastering these higher-order functions will significantly enhance your ability to write advanced and efficient JavaScript code.</p>"},{"location":"frontend/js/essential/array/","title":"Array","text":""},{"location":"frontend/js/essential/array/#array","title":"Array","text":""},{"location":"frontend/js/essential/array/#why-is-an-array-an-object-in-javascript","title":"Why is an Array an Object in JavaScript?","text":"<p>In JavaScript, arrays are a type of object because the language is designed around the concept of objects as the fundamental building blocks. Here are a few reasons why arrays are implemented as objects in JavaScript:</p> <ul> <li> <p>Unified Data Structure: JavaScript is a language designed to be flexible and dynamic. By treating arrays as objects, JavaScript can leverage the existing object infrastructure, providing a unified way to handle collections of data.</p> </li> <li> <p>Dynamic Properties and Methods: As objects, arrays can have properties and methods. This allows for powerful features like dynamic resizing, and built-in methods (e.g., <code>push</code>, <code>pop</code>, <code>map</code>, <code>filter</code>) that make working with arrays convenient.</p> </li> <li> <p>Flexibility: Arrays being objects allow them to be extended and manipulated in ways that more rigid, statically-typed arrays in other languages might not support. This fits well with JavaScript's dynamic and loosely-typed nature.</p> </li> </ul>"},{"location":"frontend/js/essential/array/#are-arrays-objects-in-other-programming-languages","title":"Are Arrays Objects in Other Programming Languages?","text":"<p>The treatment of arrays varies across different programming languages:</p> <ul> <li> <p>C/C++: In languages like <code>C</code> and <code>C++</code>, arrays are not objects. They are contiguous blocks of memory with a fixed size. Arrays in these languages are more primitive and have limited functionality compared to JavaScript arrays.</p> </li> <li> <p>Java: In Java, arrays are objects. They are instances of a class and have a fixed size once created. They also have properties (like <code>length</code>) and methods.</p> </li> <li> <p>Python: In Python, the closest equivalent to JavaScript arrays is the list. Lists are objects in Python, with dynamic sizing and many built-in methods, similar to JavaScript arrays.</p> </li> <li> <p>Ruby: In Ruby, arrays are also objects. They are instances of the Array class and come with a rich set of methods for manipulation.</p> </li> </ul>"},{"location":"frontend/js/essential/array/#reason-behind-the-design-choice","title":"Reason Behind the Design Choice","text":"<p>The decision to make arrays objects in JavaScript (and other high-level languages) often comes down to the following reasons:</p> <ul> <li> <p>Consistency: By making arrays objects, the language maintains a consistent approach to data structures. Everything is an object, which simplifies the language model and makes it easier to learn and use.</p> </li> <li> <p>Extensibility: Arrays as objects can be easily extended with new properties and methods. This allows for more powerful and flexible programming paradigms.</p> </li> <li> <p>Ease of Use: Built-in methods and properties provided by the array object simplify many common tasks, reducing the need for boilerplate code and making the language more expressive and productive for developers.</p> </li> </ul>"},{"location":"frontend/js/essential/array/#summary","title":"Summary","text":"<ul> <li>In JavaScript: Arrays are objects to provide a consistent, flexible, and powerful way to handle collections of data.</li> <li>In Other Languages: The treatment of arrays varies, with some languages treating them as primitive types and others as objects.</li> <li>Design Reasons: Making arrays objects allows for extensibility, ease of use, and a unified data structure model.</li> </ul> <p>This design choice reflects JavaScript's overall philosophy of being a flexible and dynamic language, aiming to simplify and enhance the developer experience.</p> what is exactly an array in javascript. <p>Yes, in JavaScript, an array is indeed a type of object. Here's a more detailed explanation:</p> is array an object in javascript <p>In JavaScript, arrays are a type of object. Specifically, they are a specialized type of object designed to store indexed collections of data. Arrays in JavaScript can hold various types of data (such as <code>numbers</code>, <code>strings</code>, <code>objects</code>, or even other <code>arrays</code>) and provide methods for manipulating those data elements.</p> <pre><code>let myArray = [1, 2, 3, 4, 5]; // An array of numbers\n\nconsole.log(typeof myArray); // Outputs: object\nconsole.log(Array.isArray(myArray)); // Outputs: true\n</code></pre> <p>Even though <code>typeof myArray</code> returns \"object\", you can use Array.isArray() to specifically check if a variable is an array. Arrays have additional properties and methods compared to regular objects, such as length for the number of elements and methods like <code>push</code>, <code>pop</code>, <code>forEach</code>, etc., for array manipulation.</p> what do you mean by type of object. is it exactly object? what is it? if it is an object then why do we need isArray <p>In JavaScript, the <code>typeof</code> operator can return several values, including \"object\" for objects and arrays. However, arrays are a specialized type of object with additional features and behaviors tailored specifically for handling ordered collections of data.</p> <p>Here's why <code>Array.isArray()</code> is useful:</p> <ul> <li> <p>Clarity: Arrays and objects are both considered \"object\" types by <code>typeof</code>, so Array.isArray() provides a clear and specific way to determine if a variable is an array.</p> </li> <li> <p>Behavior: Arrays in JavaScript have specialized methods and properties (length, push, pop, etc.) that make them distinct from regular objects. Using Array.isArray() ensures that you are working with an array and can safely use array-specific methods without encountering unexpected behavior.</p> </li> <li> <p>Compatibility: In older versions of JavaScript, before Array.isArray() was introduced in ECMAScript 5 (2009), checking if an object was an array was less straightforward. Array.isArray() provides a reliable cross-browser way to perform this check.</p> </li> </ul> <p>Here\u2019s an example of how you might use Array.isArray():</p> <pre><code>let myArray = [1, 2, 3];\nlet myObject = { key: 'value' };\n\nconsole.log(Array.isArray(myArray)); // true\nconsole.log(Array.isArray(myObject)); // false\n\n// Using typeof\nconsole.log(typeof myArray); // \"object\"\nconsole.log(typeof myObject); // \"object\"\n</code></pre> <p>So, while arrays are objects in JavaScript, Array.isArray() is necessary to distinguish arrays from other types of objects and ensure correct behavior when working with arrays.</p> so why do we need array object type and Array.isArray() <p>The distinction between arrays and regular objects in JavaScript, as well as the use of Array.isArray(), serves several important purposes:</p> <ol> <li> <p>Specialized Functionality:</p> <p>Arrays are specialized objects designed specifically for storing ordered collections of data. They come with built-in methods (push, pop, forEach, etc.) that make it easy to manipulate and iterate over their elements. This specialization allows for efficient handling of sequential data, which is common in programming tasks.</p> </li> <li> <p>Type Checking:</p> <p>JavaScript's typeof operator returns \"object\" for both arrays and regular objects. However, arrays have distinct behavior and capabilities compared to generic objects. Array.isArray() provides a reliable way to specifically check if a variable is an array, ensuring that you can safely use array-specific methods without encountering errors or unexpected behavior.</p> </li> <li> <p>Compatibility:</p> <p>Prior to the introduction of Array.isArray() in ECMAScript 5 (2009), developers often used less reliable methods to check if an object was an array (such as checking for the presence of array-specific methods like push). Array.isArray() provides a standardized and cross-browser-compatible approach to this check.</p> </li> <li> <p>Code Readability:</p> <p>Explicitly using Array.isArray() improves the readability and maintainability of your code. It clearly communicates your intention to check whether a variable is an array, making the code easier to understand for other developers who may work with or maintain it in the future.</p> </li> </ol> <p>In essence, while arrays are objects in JavaScript, they have specialized features that distinguish them from regular objects. Array.isArray() is a utility function that ensures clarity, reliability, and compatibility when working with arrays, helping developers write more robust and understandable code.</p>"},{"location":"frontend/js/essential/array/#what-is-an-array","title":"What is an Array?","text":"<p>An array in JavaScript is a special type of object used to store multiple values in a single variable. Unlike regular objects, which use named keys to store values, arrays use numeric indices.</p>"},{"location":"frontend/js/essential/array/#characteristics-of-arrays","title":"Characteristics of Arrays","text":"<ol> <li>Indexed Collection: Arrays are indexed, meaning each element in the array has a numbered position (starting from 0).</li> <li>Dynamic Size: Arrays can grow and shrink in size dynamically as elements are added or removed.</li> <li>Zero-based Index: The index of the first element is 0, the second element is 1, and so on.</li> <li>Heterogeneous Elements: Arrays can store elements of different types (numbers, strings, objects, other arrays, etc.).</li> </ol> Example of an Array<pre><code>let fruits = ['Apple', 'Banana', 'Cherry'];\n</code></pre> <p>In this example, <code>fruits</code> is an array containing three string elements.</p>"},{"location":"frontend/js/essential/array/#arrays-are-objects","title":"Arrays are Objects","text":"<p>Internally, arrays are a specialized type of object. You can verify this by using the typeof operator:</p> javascript<pre><code>console.log(typeof fruits); // \"object\"\n</code></pre> <p>Despite being objects, arrays have special properties and methods that make them particularly useful for working with ordered collections of data. For example:</p> <ul> <li>length property: Returns the number of elements in the array.</li> <li>push method: Adds one or more elements to the end of the array.</li> <li>pop method: Removes the last element from the array.</li> <li>map method: Creates a new array with the results of calling a provided function on every element in the array.</li> </ul>"},{"location":"frontend/js/essential/array/#key-differences-between-arrays-and-objects","title":"Key Differences Between <code>Arrays</code> and <code>Objects</code>","text":"<ul> <li>Indexing: Arrays are indexed using numeric indices, while objects use named keys.</li> <li>Length Property: Arrays have a <code>length</code> property that keeps track of the number of elements. Objects do not have a built-in <code>length</code> property.</li> <li>Iteration: Arrays can be easily iterated using loops (like <code>for</code>, <code>for...of</code>, <code>forEach</code>). Iterating over an object typically requires using a <code>for...in</code> loop or <code>Object.keys()</code>.</li> </ul>"},{"location":"frontend/js/essential/array/#summary_1","title":"Summary","text":"<ul> <li>Arrays are objects with additional functionality suited for storing ordered collections of data.</li> <li>They provide methods and properties that make it easier to manipulate sequences of values.</li> </ul> Example: some common array operations<pre><code>let numbers = [1, 2, 3, 4, 5];\n\nconsole.log(numbers.length); // 5\nnumbers.push(6);\nconsole.log(numbers); // [1, 2, 3, 4, 5, 6]\nnumbers.pop();\nconsole.log(numbers); // [1, 2, 3, 4, 5]\n\nnumbers.forEach(num =&gt; console.log(num * 2)); // 2, 4, 6, 8, 10\n</code></pre>"},{"location":"frontend/js/essential/array/#example","title":"Example","text":"<p>Tip</p> <p>Certainly! Here are basic and advanced examples demonstrating the usage of <code>Array.isArray()</code> in JavaScript:</p> Basic ExampleAdvanced Example javascript<pre><code>// Basic example\nlet arr = [1, 2, 3];\n\nconsole.log(Array.isArray(arr)); // true\n\nlet obj = { name: 'John', age: 30 };\n\nconsole.log(Array.isArray(obj)); // false\n</code></pre> <p>In this basic example:</p> <ul> <li>Array.isArray(arr) returns true because arr is an array.</li> <li>Array.isArray(obj) returns false because obj is a plain object, not an array.</li> </ul> javascript<pre><code>function processArray(input) {\n    if (Array.isArray(input)) {\n        input.forEach(item =&gt; console.log(item));\n    } else {\n        console.log(\"Input is not an array.\");\n    }\n}\n\nlet arr = [1, 2, 3];\nlet obj = { name: 'Jane', age: 25 };\n\nprocessArray(arr); // Outputs: 1, 2, 3\nprocessArray(obj); // Outputs: \"Input is not an array.\"\n</code></pre> <p>In this advanced example:</p> <ul> <li>The <code>processArray</code> function takes <code>input</code> as a parameter.</li> <li>Inside the function, <code>Array.isArray(input)</code> checks if <code>input</code> is an array.</li> <li>If <code>input</code> is an array, it iterates over its elements using <code>forEach</code>.</li> <li>If <code>input</code> is not an array, it outputs a message indicating that it's not an array.</li> </ul> <p>These examples illustrate how <code>Array.isArray()</code> can be used to safely and reliably determine whether a variable is an array before performing operations specific to arrays. This helps prevent errors and ensures that your code behaves as expected in different scenarios.</p>"},{"location":"frontend/js/essential/object-object.prototype/","title":"Object & Object.Prototype","text":"<p>The difference between <code>Object</code> and <code>Object.prototype</code> in JavaScript lies in their roles and usage within the language. Here's an in-depth explanation:</p>"},{"location":"frontend/js/essential/object-object.prototype/#1-object","title":"1. Object","text":"<ul> <li>Definition: Object is a built-in global constructor function in JavaScript.</li> <li>Purpose: It is used to create and manage objects, and it also provides utility methods for working with objects.</li> </ul> Key Characteristics <ul> <li>It's a function that serves as the parent of all objects in JavaScript.</li> <li>Provides static methods like <code>Object.keys()</code>, <code>Object.values()</code>, <code>Object.entries()</code>, etc.</li> <li>You can use it to create objects explicitly: <code>new Object()</code> (though <code>Object.create()</code> or object literals <code>{}</code> are more common).</li> </ul> <pre><code>// Using Object as a constructor\nconst obj1 = new Object();\nobj1.name = \"Alice\";\nconsole.log(obj1); // { name: 'Alice' }\n\n// Using static methods provided by Object\nconst obj2 = { a: 1, b: 2 };\nconsole.log(Object.keys(obj2)); // ['a', 'b']\nconsole.log(Object.values(obj2)); // [1, 2]\nconsole.log(Object.entries(obj2)); // [['a', 1], ['b', 2]]\n</code></pre>"},{"location":"frontend/js/essential/object-object.prototype/#2-objectprototype","title":"2. Object.prototype","text":"<ul> <li>Definition: <code>Object.prototype</code> is the prototype object from which all JavaScript objects inherit properties and methods.</li> <li>Purpose: It acts as the base object, and every object created in JavaScript implicitly links to <code>Object.prototype</code> (or a prototype that inherits from it).</li> </ul> Key Characteristics <ul> <li>Contains instance methods like <code>.toString()</code>, <code>.hasOwnProperty()</code>, <code>.isPrototypeOf()</code>, etc.</li> <li>When you create an object, its prototype chain ultimately leads to <code>Object.prototype</code>.</li> <li>It defines the default behavior for all objects unless overridden.</li> </ul> <pre><code>const obj3 = { a: 1 };\n\n// Accessing methods from Object.prototype\nconsole.log(obj3.hasOwnProperty(\"a\")); // true\nconsole.log(obj3.toString()); // [object Object]\n\n// Adding a custom method to Object.prototype\nObject.prototype.greet = function () {\n  return \"Hello from Object.prototype!\";\n};\nconsole.log(obj3.greet()); // \"Hello from Object.prototype!\"\n\n// Caution: Modifying Object.prototype affects all objects\n</code></pre>"},{"location":"frontend/js/essential/object-object.prototype/#3-key-differences-between-object-and-objectprototype","title":"3. Key Differences Between <code>Object</code> and <code>Object.prototype</code>","text":"Feature <code>Object</code> <code>Object.prototype</code> Type Constructor function Prototype object Purpose Used to create objects and access static methods Provides default methods and properties to all objects Access Static methods like <code>Object.keys()</code> Instance methods like <code>.toString()</code> Inheritance Does not inherit from anything Root of the prototype chain Extensibility Adding properties or methods is uncommon Can extend to modify behavior of all objects Example Methods <code>Object.keys()</code>, <code>Object.create()</code> <code>.hasOwnProperty()</code>, <code>.toString()</code>"},{"location":"frontend/js/essential/object-object.prototype/#4-how-they-work-together","title":"4. How They Work Together","text":"<p>When you create an object, it inherits from <code>Object.prototype</code>. For example:</p> <pre><code>const myObj = { a: 1 };\n\n// Prototype chain\nconsole.log(Object.getPrototypeOf(myObj) === Object.prototype); // true\n</code></pre>"},{"location":"frontend/js/essential/object-object.prototype/#5-visualizing-the-relationship","title":"5. Visualizing the Relationship","text":"<pre><code>Object\n \u2514\u2500&gt; Object.prototype\n       \u2514\u2500&gt; myObj\n</code></pre> <ul> <li><code>Object.prototype</code> is the prototype of all plain objects.</li> <li><code>Object</code> is the global constructor function that creates objects and provides static methods.</li> </ul>"},{"location":"frontend/js/essential/object-object.prototype/#also-similar-to-array-function","title":"Also Similar to Array &amp; Function","text":"<pre><code>Array\n \u2514\u2500&gt; Array.prototype\n       \u2514\u2500&gt; myArray\n</code></pre> <pre><code>Function\n \u2514\u2500&gt; Function.prototype\n       \u2514\u2500&gt; myFunction\n</code></pre>"},{"location":"frontend/js/essential/object-object.prototype/#constructor","title":"Constructor","text":"<ul> <li>Number() constructor function</li> <li>String() constructor function</li> <li>Boolean() constructor function</li> <li>Object() constructor function</li> <li>Array() constructor function</li> <li>Function() constructor function</li> </ul>"},{"location":"frontend/js/essential/object-object.prototype/#array","title":"Array","text":"<p>An array is an ordered list of values typically created with the intention of looping through numerically indexed values, beginning with the index zero.</p> <p>What you need to know is that arrays are numerically ordered sets, as opposed to objects which have property names associated with values in non-numeric order.</p> <p>Essentially, arrays use numbers as a lookup key, while objects have user-defined property names. JavaScript does not have true associative arrays, but objects can be used to achieve the functionality of associative arrays.</p> <pre><code>var myArray = [\"blue\", \"green\", \"orange\", \"red\"];\nconsole.log(myArray[0]); // Logs blue using the 0 index to access the string in myArray.\n\n// Versus\n\nvar myObject = {\n  // aka an associative array/hash, known as an object in JavaScript.\n  blue: \"blue\",\n  green: \"green\",\n  orange: \"orange\",\n  red: \"red\",\n};\n</code></pre> Note <p>Arrays can hold any type of values, and these values can be updated or deleted at any time.</p> <p>If you need a hash (aka associative array), an object is the closest solution.</p> <p>An Array() is just a special type of Object(). That is, Array() instances are basically Object() instances with a couple of extra functions (e.g., <code>.length</code> and a built-in numeric index).</p> <p><code>Values</code> contained in an array are commonly referred to as <code>elements</code>.</p> <ul> <li>JavaScript Succinctly by Cody Lindley - 119</li> </ul> <p>In JavaScript, objects are king: Almost everything is an object or acts like an object. Understand objects and you will understand JavaScript.</p> <ul> <li>JavaScript Succinctly by Cody Lindley - 16</li> </ul>"},{"location":"frontend/js/essential/object-prototype/","title":"Object Prototype","text":""},{"location":"frontend/js/essential/object-prototype/#objectprototype","title":"Object.prototype","text":"<p>In JavaScript, Object.prototype is the prototype object from which all other objects inherit their properties and methods, unless explicitly specified otherwise. It is the top of the prototype chain, meaning that any object created using a constructor function or an object literal will have Object.prototype in its prototype chain.</p>"},{"location":"frontend/js/essential/object-prototype/#what-is-objectprototype","title":"What is Object.prototype?","text":"<ul> <li> <p>Prototype Chain:</p> <p>In JavaScript, objects can have a prototype, which is another object from which they inherit properties. The prototype of an object is accessible through the <code>__proto__</code> property (or <code>[[Prototype]]</code> in more formal terms).</p> </li> <li> <p>Inheritance:</p> <p><code>Object.prototype</code> is the final object in the prototype chain. It means that all properties and methods defined on <code>Object.prototype</code> are available to all other objects, unless those properties and methods are overridden further down the prototype chain.</p> </li> </ul>"},{"location":"frontend/js/essential/object-prototype/#common-properties-and-methods-from-objectprototype","title":"Common Properties and Methods from <code>Object.prototype</code>","text":"<p>Object.prototype includes several methods and properties that are useful and commonly used:</p> <ol> <li> <p>hasOwnProperty:</p> <p>Checks if a property is a direct property of the object (not inherited).</p> <pre><code>const obj = { a: 1 };\nconsole.log(obj.hasOwnProperty('a')); // true\nconsole.log(obj.hasOwnProperty('toString')); // false\n</code></pre> </li> <li> <p>isPrototypeOf:</p> <p>Checks if an object exists in another object's prototype chain.</p> <pre><code>function Person() {}\nconst person = new Person();\nconsole.log(Person.prototype.isPrototypeOf(person)); // true\n</code></pre> </li> <li> <p>toString:</p> <p>Returns a string representation of the object.</p> <pre><code>const obj = { a: 1 };\nconsole.log(obj.toString()); // \"[object Object]\"\n</code></pre> </li> <li> <p>valueOf:</p> <p>Returns the primitive value of the specified object.</p> <pre><code>const obj = { a: 1 };\nconsole.log(obj.valueOf()); // { a: 1 }\n</code></pre> </li> </ol> <p>Prototype Chain Example</p>"},{"location":"frontend/js/essential/object-prototype/#prototype-chain-example","title":"Prototype Chain Example","text":"<p>To better understand Object.prototype and the prototype chain, consider the following example:</p> <pre><code>const person = {\n    name: 'John',\n    greet: function() {\n        console.log('Hello, ' + this.name);\n    }\n};\n\n// Create a new object that inherits from person\nconst anotherPerson = Object.create(person);\nanotherPerson.name = 'Jane';\n\nanotherPerson.greet(); // Hello, Jane\n\n// Check the prototype chain\nconsole.log(Object.getPrototypeOf(anotherPerson) === person); // true\nconsole.log(Object.getPrototypeOf(person) === Object.prototype); // true\n</code></pre> <p>In this example:</p> <ol> <li>We define an object <code>person</code> with a property <code>name</code> and a method <code>greet</code>.</li> <li>We create a new object <code>anotherPerson</code> that inherits from person using Object.create.</li> <li>The <code>anotherPerson</code> object can access properties and methods from <code>person</code> because <code>person</code> is in its prototype chain.</li> <li>We verify the prototype chain using Object.getPrototypeOf.</li> </ol>"},{"location":"frontend/js/essential/object-prototype/#customizing-objectprototype","title":"Customizing Object.prototype","text":"<p>While it is possible to add properties or methods to Object.prototypeit is generally discouraged== because it can lead to unexpected behavior and conflicts in your code, especially when working with third-party libraries. Modifying Object.prototype affects all objects, which can have unintended side effects.</p> <pre><code>Object.prototype.customMethod = function() {\n  console.log('This is a custom method.');\n};\n\nconst obj = {};\nobj.customMethod(); // This is a custom method.\n</code></pre> <p>In this example, the <code>customMethod</code> is added to Object.prototype, making it available to all objects. However, this practice should be used with caution.</p>"},{"location":"frontend/js/essential/object-prototype/#summary","title":"Summary","text":"<ul> <li>Object.prototype is the top-level prototype object from which all other objects inherit properties and methods.</li> <li>It provides several built-in methods like <code>hasOwnProperty</code>, <code>isPrototypeOf</code>, <code>toString</code>, and <code>valueOf</code>.</li> <li>All objects in JavaScript have Object.prototype in their prototype chain unless explicitly specified otherwise.</li> <li>Modifying Object.prototype is possible but generally discouraged due to the potential for unintended side effects.</li> </ul>"},{"location":"frontend/js/essential/object/","title":"Object","text":""},{"location":"frontend/js/essential/object/#object","title":"Object","text":""},{"location":"frontend/js/essential/object/#question","title":"Question","text":"<p>what is exactly object in programming language. why it is called the king in programming language. where does it exist. where does not it exist. how does it transfer in http protocal.\"</p> <p>An object in programming is an instance of a class that encapsulates both data and methods that operate on that data. Objects are fundamental building blocks in object-oriented programming (OOP) and represent real-world entities and concepts within the code.</p> <p>Tip</p> <p>Success</p> <p>Danger</p> <p>Example</p>"},{"location":"frontend/js/essential/object/#why-is-an-object-called-the-king-in-programming","title":"Why is an Object Called the \"King\" in Programming?","text":"<ul> <li>Encapsulation: Objects bundle data and methods that operate on the data, ensuring a modular and organized code structure.</li> <li>Abstraction: Objects provide a simplified interface to interact with complex systems, hiding unnecessary details.</li> <li>Inheritance: Objects can inherit properties and methods from other objects, promoting code reuse and efficiency.</li> <li>Polymorphism**: Objects can take many forms, allowing methods to be used interchangeably across different classes.</li> </ul> <p>These principles make objects central to OOP, hence they are often referred to as the \"king\" in programming.</p>"},{"location":"frontend/js/essential/object/#where-do-objects-exist","title":"Where Do Objects Exist?","text":"<ul> <li>Object-Oriented Programming Languages: Objects are fundamental in languages like <code>Java</code>, <code>C++</code>, <code>Python</code>, <code>Ruby</code>, and <code>JavaScript</code>.</li> <li>In Memory: At runtime, objects exist in a computer's memory, where they are instantiated, manipulated, and used by the program.</li> </ul>"},{"location":"frontend/js/essential/object/#where-do-objects-not-exist","title":"Where Do Objects Not Exist?","text":"<ul> <li>Non-OOP Languages: In procedural programming languages like <code>C</code> (not C++), there is no concept of objects. Code is organized around procedures or functions.</li> <li>Static Resources: Objects do not exist in static resources like <code>plain text files</code>, simple scripts, or configuration files, which do not use OOP principles.</li> </ul>"},{"location":"frontend/js/essential/object/#how-do-objects-transfer-in-http-protocol","title":"How Do Objects Transfer in HTTP Protocol?","text":"<p>Objects transfer in HTTP protocol typically <code>through serialization</code>, where the object's state is converted into a format that can be transmitted over the network. Common serialization formats include:</p> <ol> <li> <p>JSON (<code>JavaScript Object Notation</code>): Widely used due to its simplicity and readability.</p> json<pre><code>{\n    \"name\": \"Alice\",\n    \"age\": 30,\n    \"isMember\": true\n}\n</code></pre> </li> <li> <p>XML (<code>Extensible Markup Language</code>): More verbose than JSON but still commonly used.</p> xml<pre><code>&lt;person&gt;\n    &lt;name&gt;Alice&lt;/name&gt;\n    &lt;age&gt;30&lt;/age&gt;\n    &lt;isMember&gt;true&lt;/isMember&gt;\n&lt;/person&gt;\n</code></pre> </li> <li> <p>Binary Formats: <code>Protocol Buffers</code>, <code>Apache Avro</code>, or <code>MessagePack</code>, which are more efficient for data transfer but less human-readable.</p> </li> </ol> <p>The serialized object is included in the HTTP request or response body and transferred between the client and server.</p> HTTP Request Example:<pre><code>POST /api/users HTTP/1.1\nHost: example.com\nContent-Type: application/json\n\n{\n    \"name\": \"Alice\",\n    \"age\": 30,\n    \"isMember\": true\n}\n</code></pre> HTTP Response Example:<pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n    \"status\": \"success\",\n    \"data\": {\n        \"id\": 123,\n        \"name\": \"Alice\"\n    }\n}\n</code></pre>"},{"location":"frontend/js/essential/object/#dynamically-selecting-a-methodproperty","title":"Dynamically Selecting a Method/Property","text":"<p>JavaScript offers a simple syntax for dynamically selecting methods and properties, all relying on the square brackets (<code>[ ]</code>) operator. You see JavaScript has two interchangeable syntaxes for member access (that is a common dynamic language trait):</p> <pre><code>obj[expressionResultingInMemberName] == obj.memberName;\n</code></pre> <p>If you\u2019ve ever plucked a value from an Array cell using its integer index, you\u2019ve already used the square brackets operator for dynamic member selection! This is because Array objects have properties named after their numerical indices (plus the length property). However, in this case, JavaScript won\u2019t let you use the dot operator (<code>.</code>) for direct access. <code>myArray.0</code> is invalid syntax (too bad, that would have made a good nerd trick).</p> <p>Here\u2019s why using the square brackets operator (<code>[ ]</code>) is more powerful than dot notation: you can put anything in between the brackets to obtain the name of the member (property or method) that you want to access.</p> <p>Common cases include literals, variables holding the member name, name composition expressions (mostly string concatenations), and quick <code>if/then</code> choices in the form of a ternary operator (<code>condition ? valueIfTrue : valueIfFalse</code>). It\u2019ll all be turned into a string first and then used to look up the member you want to use.</p> <ul> <li>Pragmatic Guide to JavaScript by Christophe Porteneuve :pg - 18</li> </ul>"},{"location":"frontend/js/essential/object/#summary","title":"Summary","text":"<p>Objects are essential in OOP, providing a structured way to represent and manipulate data. They exist in memory and within OOP languages but not in non-OOP contexts. They transfer over HTTP through serialization into formats like JSON, XML, or binary.</p>"},{"location":"frontend/js/essential/prototype/","title":"Prototype","text":""},{"location":"frontend/js/essential/prototype/#prototype","title":"Prototype","text":""},{"location":"frontend/js/essential/prototype/#objectprototype","title":"Object.prototype","text":"<ul> <li> <p>Base Prototype:</p> <p>Object.prototype is the prototype object from which all other objects inherit, unless explicitly specified otherwise. It is the root of the prototype chain for most objects.</p> </li> <li> <p>Properties and Methods:</p> <p>It includes methods and properties that are common to all objects, such as <code>toString()</code>, <code>valueOf()</code>, <code>hasOwnProperty()</code>, <code>isPrototypeOf()</code>, and <code>propertyIsEnumerable()</code>.</p> </li> <li> <p>Role:</p> <p>Any object created using an object literal or the Object constructor will have Object.prototype in its prototype chain.</p> </li> </ul> <p>Example</p> Function.prototypeString.prototypeNumber.prototypeBoolean.prototypeDate.prototypeRegExp.prototype <p>The prototype for all function objects. It includes methods like <code>apply()</code>, <code>call()</code>, and <code>bind()</code>.</p> <pre><code>function sayHello() {\n    console.log('Hello');\n}\n\nsayHello.call(); // Hello\n</code></pre> <p>The prototype for all string objects. It includes methods like <code>charAt()</code>, <code>indexOf()</code>, <code>toUpperCase()</code>, <code>toLowerCase()</code>, <code>substring()</code>, <code>slice()</code>, and <code>replace()</code>.</p> <pre><code>const str = 'hello';\nconsole.log(str.toUpperCase()); // HELLO\n</code></pre> <p>The prototype for all number objects. It includes methods like <code>toFixed()</code>, <code>toExponential()</code>, and <code>toPrecision()</code>.</p> <pre><code>const num = 123.456;\nconsole.log(num.toFixed(2)); // 123.46\n</code></pre> <p>The prototype for all boolean objects. It has methods like <code>toString()</code> and <code>valueOf()</code>.</p> <pre><code>const bool = true;\nconsole.log(bool.toString()); // true\n</code></pre> <p>The prototype for all date objects. It includes methods like <code>getDate()</code>, <code>getDay()</code>, <code>getFullYear()</code>, <code>getHours()</code>, and <code>toISOString()</code>.</p> <pre><code>const date = new Date();\nconsole.log(date.toISOString()); // Current date in ISO format\n</code></pre> <p>The prototype for all regular expression objects. It includes methods like <code>exec()</code>, <code>test()</code>, and properties like source.</p> <pre><code>const regex = /hello/;\nconsole.log(regex.test('hello world')); // true\n</code></pre>"},{"location":"frontend/js/essential/prototype/#key-differences-and-summary","title":"Key Differences and Summary","text":"<ul> <li> <p>Purpose:</p> <p><code>Object.prototype</code> provides generic methods and properties for all objects, while Array.prototype provides specific methods and properties for array instances.</p> </li> <li> <p>Inheritance:</p> <p>All objects inherit from <code>Object.prototype</code>, but array instances additionally inherit from <code>Array.prototype</code>.</p> </li> <li> <p>Methods and Properties:</p> <p>The methods and properties on <code>Object.prototype</code>are applicable to all objects, whereas those on Array.prototype are specifically for arrays.</p> </li> </ul> <p>Understanding the prototype chain and how different prototypes provide different methods and properties is crucial for effective JavaScript programming. It helps in leveraging the full power of built-in objects and creating custom objects with shared behaviors.</p>"},{"location":"frontend/js/essential/prototype/#prototype-chain-illustration","title":"Prototype Chain Illustration","text":"<p>Here\u2019s a simplified illustration of the prototype chain for these <code>built-in</code> objects:</p> <ol> <li> <p>Function:</p> <ul> <li><code>example.__proto__ === Function.prototype</code></li> <li><code>Function.prototype.__proto__ === Object.prototype</code></li> </ul> </li> <li> <p>String:</p> <ul> <li><code>str.__proto__ === String.prototype</code></li> <li><code>String.prototype.__proto__ === Object.prototype</code></li> </ul> </li> <li> <p>Array:</p> <ul> <li><code>arr.__proto__ === Array.prototype</code></li> <li><code>Array.prototype.__proto__ === Object.prototype</code></li> </ul> </li> <li> <p>Boolean:</p> <ul> <li><code>bool.__proto__ === Boolean.prototype</code></li> <li><code>Boolean.prototype.__proto__ === Object.prototype</code></li> </ul> </li> </ol> <p>Example of Prototype Chain</p> <pre><code>function example() {}\nconst str = 'hello';\nconst arr = [1, 2, 3];\nconst bool = true;\n\n// Checking the prototype chain\nconsole.log(Object.getPrototypeOf(example) === Function.prototype); // true\nconsole.log(Object.getPrototypeOf(Function.prototype) === Object.prototype); // true\n\nconsole.log(Object.getPrototypeOf(str) === String.prototype); // true\nconsole.log(Object.getPrototypeOf(String.prototype) === Object.prototype); // true\n\nconsole.log(Object.getPrototypeOf(arr) === Array.prototype); // true\nconsole.log(Object.getPrototypeOf(Array.prototype) === Object.prototype); // true\n\nconsole.log(Object.getPrototypeOf(bool) === Boolean.prototype); // true\nconsole.log(Object.getPrototypeOf(Boolean.prototype) === Object.prototype); // true\n</code></pre>"},{"location":"frontend/js/essential/prototype/#__proto__","title":"<code>__proto__</code>","text":"<p>A hidden link that lets an object inherit properties and methods from another object.</p>"},{"location":"frontend/js/function/arrow-example/","title":"Arrow Example","text":"<p>In React, whether you use direct function references or arrow functions for event handlers can impact performance and behavior in different ways. </p> <p>Here\u2019s a breakdown of why you might choose one approach over the other:</p> Direct Reference<pre><code>const handleClickButton1 = () =&gt; console.log('Button 1 clicked');\nconst handleClickButton2 = () =&gt; console.log('Button 2 clicked');\n\nreturn (\n  &lt;div&gt;\n    &lt;button onClick={handleClickButton1}&gt;Button 1&lt;/button&gt;\n    &lt;button onClick={handleClickButton2}&gt;Button 2&lt;/button&gt;\n  &lt;/div&gt;\n);\n</code></pre> Arrow Function for Argument Passing<pre><code>const handleClickButtonWithData = (data) =&gt; console.log('Button clicked with data:', data);\n\nreturn (\n  &lt;div&gt;\n    &lt;button \n        onClick={() =&gt; handleClickButtonWithData(recordData)}\n    &gt;Button with Data&lt;/button&gt;\n  &lt;/div&gt;\n);\n</code></pre>"},{"location":"frontend/js/function/arrow-example/#summary","title":"Summary","text":"<ul> <li>Use direct function references for simplicity and better performance if no arguments are needed.</li> <li>Use arrow functions when you need to pass arguments or need more dynamic behavior for the handler. This approach ensures that your code remains efficient and maintainable while accommodating different use cases for event handling.</li> </ul> <pre><code>import React from 'react';\n\nconst MyComponent = () =&gt; {\n  // General function that takes data as a parameter\n  const handleClickButtonWithData = (data) =&gt; {\n    console.log('Button clicked with data:', data);\n  };\n\n  // Example data\n  const recordData = { id: 1, name: 'Sample Record' };\n\n  return (\n    &lt;div&gt;\n      {/* Using an arrow function to pass data to the general function */}\n      &lt;button onClick={() =&gt; handleClickButtonWithData(recordData)}&gt;Button with Data&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default MyComponent;\n</code></pre>"},{"location":"frontend/js/function/arrow-function/","title":"Arrow Functions","text":""},{"location":"frontend/js/function/arrow-function/#arrow-functions-and-this-a-comprehensive-guide-to-context-in-modern-javascript","title":"Arrow Functions and <code>this</code>: A Comprehensive Guide to Context in Modern JavaScript","text":"<p>Understanding how arrow functions affect the this context in JavaScript is crucial for writing accurate and effective code. </p> <p>Here\u2019s a deep dive into the topic:</p> Key Concept to Remember <p>Arrow functions lexically bind <code>this</code> from their surrounding scope. This means they do not have their own <code>this</code> context, making them ideal for preserving this in callbacks and asynchronous code without additional binding.</p> <p>In traditional (general) functions, the binding of <code>this</code> depends on the context in which the function is invoked. </p>"},{"location":"frontend/js/function/arrow-function/#what-is-this","title":"What is this?","text":"<p>In JavaScript, this is a special keyword that refers to the context in which a function is executed. Its value depends on how the function is called.</p>"},{"location":"frontend/js/function/arrow-function/#in-different-contexts","title":"In Different Contexts:","text":"<ul> <li>Global Context: In the global context, <code>this</code> refers to the global object (<code>window</code> in browsers, <code>global</code> in Node.js).</li> <li>Object Method: When a function is a method of an object, <code>this</code> refers to the object the method is called on.</li> <li>Constructor Function: When a function is used as a constructor (with the <code>new</code> keyword), <code>this</code> refers to the newly created instance.</li> <li>Event Handlers: In event handlers, <code>this</code> refers to the element that triggered the event.</li> <li>Arrow Functions: Arrow functions have a unique behavior regarding <code>this</code>.</li> </ul>"},{"location":"frontend/js/function/arrow-function/#arrow-functions-and-this","title":"Arrow Functions and this","text":"<p>Arrow functions were introduced in ECMAScript 6 (ES6) and have a distinct behavior compared to regular functions:</p> <ol> <li> <p>Lexical <code>this</code> Binding: Arrow functions do not have their own <code>this</code> context. Instead, they inherit <code>this</code> from the surrounding (lexical) scope at the time they are defined.</p> <pre><code>function Timer() {\n    this.seconds = 0;\n    setInterval(() =&gt; {\n        this.seconds += 1;\n        console.log(this.seconds);\n    }, 1000);\n}\n\nconst timer = new Timer();\n// Logs: 1, 2, 3, ...\n</code></pre> <p>In this example, the arrow function inside <code>setInterval</code> uses <code>this</code> from the <code>Timer</code> function scope. If we used a regular function instead, <code>this</code> would refer to the global object or be undefined in strict mode, not the <code>Timer</code> instance.</p> </li> <li> <p>No <code>this</code> Binding Override: Unlike regular functions, arrow functions cannot have their <code>this</code> value overridden with methods like call, apply, or bind.</p> <pre><code>const obj = {\n    value: 10,\n    regularFunction: function() {\n        console.log(this.value);\n    },\n    arrowFunction: () =&gt; {\n        console.log(this.value);\n    }\n};\n\nobj.regularFunction(); // Logs: 10\nobj.arrowFunction();  // Logs: undefined (or the value of `this.value` in the global scope, which is likely `undefined`)\n</code></pre> <p>Here, <code>regularFunction</code> has <code>this</code> bound to <code>obj</code>, whereas <code>arrowFunction</code> has <code>this</code> bound to the <code>surrounding context</code> (which is the global scope in this case).</p> </li> </ol>"},{"location":"frontend/js/function/arrow-function/#why-do-we-need-arrow-functions","title":"Why Do We Need Arrow Functions?","text":"<ol> <li> <p>Simplify Code: Arrow functions provide a more concise syntax, especially useful for small functions.</p> <pre><code>const add = (a, b) =&gt; a + b;\n</code></pre> </li> <li> <p>Preserve <code>this</code> Context: In scenarios where <code>this</code> needs to be consistent across nested functions (like callbacks or event handlers), arrow functions are helpful.</p> <pre><code>class MyClass {\n    constructor() {\n        this.value = 5;\n    }\n\n    increment() {\n        setTimeout(() =&gt; {\n            this.value += 1;\n            console.log(this.value); // Correctly logs updated value\n        }, 1000);\n    }\n}\n\nconst instance = new MyClass();\ninstance.increment();\n</code></pre> </li> <li> <p>Avoid Common Pitfalls: Traditional functions can cause confusion when used as methods or callbacks due to <code>this</code> binding issues. Arrow functions mitigate these issues by keeping the <code>this</code> context consistent with the lexical scope.</p> </li> <li> <p>Functional Programming: Arrow functions align with functional programming practices by allowing cleaner and more predictable function behavior.</p> </li> </ol> Key Points to Remember <ul> <li>No Own <code>this</code>: Arrow functions do not create their own <code>this</code>. They inherit <code>this</code> from the surrounding context at the time they are defined.</li> <li>Use Cases: Use arrow functions when you need a short function with no special <code>this</code> context or when you want to preserve the <code>this</code> value from the outer scope.</li> <li>Limitations: Avoid using arrow functions as methods in objects or constructors where you need <code>this</code> to refer to the object or the instance.</li> </ul>"},{"location":"frontend/js/function/arrow-function/#summary","title":"Summary","text":"<p>Arrow functions provide a more predictable and concise way to handle <code>this</code> in JavaScript, making them especially useful in scenarios involving callbacks and asynchronous code. They simplify function syntax while preserving the lexical scope of <code>this</code>, avoiding common pitfalls associated with traditional function behavior. Understanding and leveraging these characteristics can help you write more maintainable and bug-free code.</p>"},{"location":"frontend/js/function/arrow-function/#hidden-facts-of-arrow-function","title":"Hidden Facts of Arrow Function","text":"<ol> <li> <p>No <code>prototype</code> Property</p> <p>Arrow functions do not have a <code>prototype</code> property. This means you cannot use them to create prototype-based inheritance.</p> <pre><code>const MyFunction = () =&gt; {};\nconsole.log(MyFunction.prototype); // Logs: undefined\n</code></pre> </li> </ol> Hidden Facts About Arrow Functions <ol> <li> <p>Lexical <code>this</code> Binding**: Arrow functions inherit <code>this</code> from their surrounding context, meaning they don\u2019t have their own <code>this</code>. Useful for preserving <code>this</code> in callbacks.</p> </li> <li> <p>No <code>arguments</code> Object: Arrow functions don\u2019t have their own <code>arguments</code> object. They inherit <code>arguments</code> from their outer function.</p> </li> <li> <p>Not Constructors: Arrow functions cannot be used as constructors and cannot be called with <code>new</code>.</p> </li> <li> <p>No <code>super</code> Keyword: Arrow functions do not have a <code>super</code> keyword, so they can\u2019t be used to call methods from a superclass.</p> </li> <li> <p>No <code>prototype</code> Property: Arrow functions do not have a prototype property, so they can\u2019t be used for prototypal inheritance.</p> </li> <li> <p>Not Suitable for Object Methods: Arrow functions are not ideal for defining methods on objects where <code>this</code> needs to refer to the object itself.</p> </li> <li> <p>Syntax Simplicity: They offer a concise syntax but lack flexibility in some complex scenarios, such as method chaining.</p> </li> <li> <p><code>this</code> Context in Classes: Arrow functions can be used in class constructors to preserve the <code>this</code> context, but not for all class-specific operations.</p> </li> </ol> <p>These points highlight the unique behavior and limitations of arrow functions, helping you use them effectively in JavaScript.</p>"},{"location":"frontend/js/function/implicit-explicit-return/","title":"Implicit & Explicit","text":""},{"location":"frontend/js/function/implicit-explicit-return/#overview","title":"Overview","text":"<p>The concepts of implicit return and explicit return are important in JavaScript, especially when dealing with functions, especially arrow functions and regular functions. Let me explain these concepts and show you examples using your <code>createMeal</code> function.</p>"},{"location":"frontend/js/function/implicit-explicit-return/#1-explicit-return","title":"1. Explicit Return","text":"<p>An explicit return happens when you use the <code>return</code> keyword in the body of a function to specify what the function should return.</p> <p>In your <code>createMeal</code> example, the function has an explicit return because you're explicitly using the <code>return</code> keyword to return the function result:</p> CodeExplanation <pre><code>function createMeal(type) {\n    return function () {\n        // Explicit return\n        if (type === \"veg\") {\n            return \"I'm Veg\"; // Explicit return\n        } else {\n            return \"I'm non Veg\"; // Explicit return\n        }\n    };\n}\n\nconst vegMeal = createMeal(\"veg\");\nconsole.log(vegMeal()); // \"I'm Veg\"\n\nconst nonVegMeal = createMeal(\"nonVeg\");\nconsole.log(nonVegMeal()); // \"I'm non Veg\"\n</code></pre> <p>In the example above:</p> <ul> <li>The <code>createMeal</code> function explicitly returns a new function (an anonymous function).</li> <li>Inside that returned function, each <code>return</code> statement explicitly tells the function what to return based on the <code>type</code> argument.</li> </ul>"},{"location":"frontend/js/function/implicit-explicit-return/#2-implicit-return","title":"2. Implicit Return","text":"<p>An implicit return occurs when you do not need to use the <code>return</code> keyword in the function body, often used in arrow functions. It's when a function immediately returns a value without needing curly braces <code>{}</code>.</p> <p>For example, an implicit return can be used in arrow functions where you can omit the <code>return</code> keyword and the curly braces if the function is simple enough (i.e., it has a single expression).</p> CodeExplanation Here's an example of implicit return<pre><code>const createMeal = (type) =&gt; (type === \"veg\" ? \"I'm Veg\" : \"I'm non Veg\");\n\nconst vegMeal = createMeal(\"veg\");\nconsole.log(vegMeal); // \"I'm Veg\"\n\nconst nonVegMeal = createMeal(\"nonVeg\");\nconsole.log(nonVegMeal); // \"I'm non Veg\"\n</code></pre> <ul> <li>In the <code>createMeal</code> function (using arrow syntax), there are no curly braces <code>{}</code> around the function body, and there's no <code>return</code> keyword. The expression after the <code>=&gt;</code> is implicitly returned.</li> <li>The ternary operator (<code>condition ? expr1 : expr2</code>) is used to decide the return value based on the <code>type</code> argument. This is a very concise way to return values conditionally.</li> </ul>"},{"location":"frontend/js/function/implicit-explicit-return/#key-differences","title":"Key Differences:","text":"<ol> <li> <p>Explicit return: Requires the <code>return</code> keyword and curly braces <code>{}</code> around the function body (for regular functions).</p> <pre><code>function createMeal(type) {\n  if (type === \"veg\") {\n    return \"I'm Veg\";\n  } else {\n    return \"I'm non Veg\";\n  }\n}\n</code></pre> </li> <li> <p>Implicit return: No <code>return</code> keyword is needed, and curly braces <code>{}</code> are optional if there's just one expression to evaluate. The function implicitly returns the result of that expression.</p> <pre><code>const createMeal = (type) =&gt; (type === \"veg\" ? \"I'm Veg\" : \"I'm non Veg\");\n</code></pre> </li> </ol>"},{"location":"frontend/js/function/implicit-explicit-return/#when-to-use","title":"When to use","text":"<p>The choice between using explicit return and implicit return in JavaScript depends on factors like clarity, readability, and function complexity. Below, I'll outline scenarios where each approach is commonly used and discuss when you might prefer one over the other.</p>"},{"location":"frontend/js/function/implicit-explicit-return/#1-implicit-return","title":"1. Implicit Return","text":"Use implicit return when <ul> <li>The function is short and simple, containing a single expression that can be immediately returned.</li> <li>You want to write concise code and improve readability for simple operations.</li> <li>The function does not require multiple statements or logic before returning a value.</li> <li>You are using arrow functions, as implicit returns are often preferred for shorter expressions.</li> </ul> Typical scenarios for implicit return <ul> <li>One-liner functions, especially for operations like mapping, filtering, or reducing.</li> <li>Simple conditional expressions or return values that don\u2019t require extra logic.</li> <li>Functional programming styles, where you want functions to be short and expressive.</li> </ul> Example 1: Simple function with a single return value<pre><code>const double = (x) =&gt; x * 2; // Implicit return\nconsole.log(double(5)); // 10\n</code></pre> Example 2: Using implicit return in map()<pre><code>const numbers = [1, 2, 3];\nconst doubled = numbers.map((x) =&gt; x * 2); // Implicit return\nconsole.log(doubled); // [2, 4, 6]\n</code></pre> Example 3: Conditional check with ternary operator<pre><code>const mealType = (type) =&gt; (type === \"veg\" ? \"I'm Veg\" : \"I'm non Veg\"); // Implicit return\nconsole.log(mealType(\"veg\")); // \"I'm Veg\"\n</code></pre> Why use implicit return here? <ul> <li>It's a concise and clear way to express simple logic.</li> <li>The function is a single expression, so the implicit return makes the code cleaner and easier to read.</li> </ul>"},{"location":"frontend/js/function/implicit-explicit-return/#2-explicit-return","title":"2. Explicit Return","text":"Use explicit return when <ul> <li>The function is complex and contains multiple statements or logic that needs to be processed before returning a value.</li> <li>You need to perform more detailed operations, such as loops, conditionals, or multiple steps before returning a value.</li> <li>You want to improve clarity in situations where the function has multiple branches or complex logic.</li> <li>You are dealing with functions that return objects or larger data structures where readability is key.</li> </ul> Typical scenarios for explicit return <ul> <li>Functions with more than one line of code that involve multiple operations.</li> <li>Functions that need to mutate variables, call other functions, or have other side effects.</li> <li>More complex conditional logic, such as <code>if-else</code> statements, multiple returns, or loops.</li> </ul> <p>Example 1: Multiple conditions or logic</p> CodeExplanation <pre><code>function getMeal(type) {  // Explicit return\n    if (type === 'veg') {\n        return \"I'm Veg\";\n    } else if (type === 'nonVeg') {\n        return \"I'm non Veg\";\n    } else {\n        return \"Unknown Meal\";\n    }\n}\nconsole.log(getMeal('veg'));  // \"I'm Veg\"\nconsole.log(getMeal('nonVeg'));  // \"I'm non Veg\"\nconsole.log(getMeal('fruit'));  // \"Unknown Meal\"\n</code></pre> <p>Why use explicit return here?</p> <ul> <li>The function has multiple conditional branches (<code>if-else</code>), so it's clearer and more readable with explicit returns.</li> <li>It would be hard to express this logic cleanly in a single line with an implicit return.</li> </ul> <p>Example 2: Returning an object or more complex data</p> CodeExplanation <pre><code>function createPerson(name, age) {\n    // Explicit return\n    return {\n        name: name,\n        age: age,\n\n        greet: function () {\n            return `Hello, ${name}!`;\n        },\n    };\n}\n\nconst person = createPerson(\"John\", 30);\nconsole.log(person.greet()); // \"Hello, John!\"\n</code></pre> <p>Why use explicit return here?</p> <ul> <li>Returning an object with multiple properties requires an explicit <code>return</code> statement for clarity.</li> <li>The function involves more logic than just returning a single expression, so it's clearer to use an explicit return.</li> </ul> <p>Example 3: Handling complex operations with loops</p> CodeExplanation <pre><code>function sumNumbers(arr) {\n    // Explicit return\n    let total = 0;\n    for (let i = 0; i &lt; arr.length; i++) {\n        total += arr[i];\n    }\n    return total;\n    }\n\nconsole.log(sumNumbers([1, 2, 3, 4])); // 10\n</code></pre> <p>Why use explicit return here?</p> <ul> <li>The function contains a loop and involves a cumulative operation, so it needs multiple statements to compute the result before returning it.</li> </ul>"},{"location":"frontend/js/function/implicit-explicit-return/#when-to-choose-explicit-return-vs-implicit-return","title":"When to choose explicit return vs. implicit return:","text":"Use implicit return <ul> <li>When the function is simple and can be expressed as a single expression.</li> <li>For arrow functions that don't require multiple lines of code.</li> <li>When you're writing concise, functional code, e.g., with <code>map()</code>, <code>filter()</code>, or <code>reduce()</code>.</li> </ul> Use explicit return <ul> <li>When the function is complex, with multiple statements, conditional logic, or side effects.</li> <li>When the return value requires multiple calculations, data manipulations, or handling more complex data structures.</li> <li>To improve clarity and readability when the function's behavior is not straightforward.</li> </ul>"},{"location":"frontend/js/function/implicit-explicit-return/#summary-table","title":"Summary Table","text":"Scenario Use Implicit Return Use Explicit Return Simple expressions \u2705 <code>const double = (x) =&gt; x * 2;</code> \u274c (use implicit for conciseness) Single conditional return \u2705 <code>const mealType = (type) =&gt; type === 'veg' ? \"I'm Veg\" : \"I'm non Veg\";</code> \u274c (use implicit for clarity and simplicity) Multiple conditions or branches \u274c (not recommended for complex logic) \u2705 <code>function getMeal(type) { ... }</code> Returning objects or data \u274c (explicit return is better for objects) \u2705 <code>function createPerson(name, age) { return {...} }</code> Looping or iteration-based logic \u274c (not suitable for loops or multiple steps) \u2705 <code>function sumNumbers(arr) { ... }</code>"},{"location":"frontend/js/function/implicit-explicit-return/#conclusion","title":"Conclusion:","text":"<ul> <li>Implicit return works best for short, single-expression functions, especially when you're using arrow functions.</li> <li>Explicit return should be used for complex functions with multiple statements, conditionals, loops, or data manipulations.</li> </ul> <p>This helps to maintain both conciseness and clarity depending on the function's complexity.</p> <p>what do you mean by urly braces {} are optional in implicit return</p>"},{"location":"frontend/js/function/intro/","title":"Intro","text":"<p>In JavaScript, a function is a fundamental building block of the language. It is a reusable piece of code that performs a specific task. Functions help in organizing code, improving reusability, and making programs easier to understand and maintain.</p>"},{"location":"frontend/js/function/intro/#what-is-a-function","title":"What is a Function?","text":"<p>A function in JavaScript is a block of code designed to perform a particular task. It can take inputs, called parameters, and return an output. Functions help you encapsulate code into a single, manageable unit.</p> SyntaxExplanation <pre><code>function functionName(parameters) {\n  // Code to execute\n  return value; // Optional\n}\n</code></pre> Why Do We Need Functions? <ol> <li>Code Reusability: Write once, use multiple times. Functions help avoid code duplication.</li> <li>Modularity: Break down complex problems into smaller, manageable parts.</li> <li>Maintainability: Changes to functionality can be made in one place rather than throughout your codebase.</li> <li>Abstraction: Hide implementation details and expose only what\u2019s necessary.</li> <li>Testing: Functions can be tested independently for better reliability.</li> </ol> What Does a Function Do? <p>A function performs a specific action based on the logic defined within it. When you call a function, it executes the code inside its body, using any parameters you pass to it and potentially returning a result.</p>"},{"location":"frontend/js/function/intro/#question","title":"Question","text":"<p>What Happens When <code>return</code> Is Not Used?</p> <p>In JavaScript, not every function has to return a value. If a function doesn't explicitly use the <code>return</code> statement, it will return <code>undefined</code> by default.</p> <p>When a function does not have a <code>return</code> statement, or if the <code>return</code> statement is used without an explicit value, JavaScript automatically returns <code>undefined</code>. This is useful for cases where a function performs an action but does not need to produce a result.</p> Example Example 1Example 2Example 3 <p>Function with No <code>return</code> Statement</p> <pre><code>function sayHello() {\n    console.log(\"Hello!\");\n}\n\nconst result = sayHello(); // Logs \"Hello!\" to the console\nconsole.log(result); // Outputs: undefined\n</code></pre> <p>In this example:</p> <ul> <li><code>sayHello</code> logs a message to the console but does not return a value.</li> <li>When <code>sayHello</code> is called, it returns <code>undefined</code> because there is no <code>return</code> statement.</li> </ul> <p>Function with <code>return</code> Statement But No Value</p> <pre><code>function logAndReturn() {\n    console.log(\"Logging something.\");\n    return; // Explicitly returns undefined\n}\n\nconst result = logAndReturn(); // Logs \"Logging something.\" to the console\nconsole.log(result); // Outputs: undefined\n</code></pre> <p>In this example:</p> <ul> <li><code>logAndReturn</code> includes a <code>return</code> statement but does not specify a value.</li> <li>The function still returns <code>undefined</code> because that is the default behavior when no value is provided in the <code>return</code> statement.</li> </ul> <p>Example with Return Value</p> <pre><code>function add(a, b) {\n    return a + b;\n}\n\nconst sum = add(3, 4); // sum will be 7\nconsole.log(sum); // Outputs: 7\n</code></pre> <p>Here, the function <code>add</code> returns the result of adding <code>a</code> and <code>b</code>, and this value is captured in the <code>sum</code> variable.</p>"},{"location":"frontend/js/function/intro/#key-points","title":"Key Points","text":"<ol> <li> <p>Explicit Return: If you want your function to return a specific value, you need to include a return statement with that value.</p> </li> <li> <p>Implicit Return: If the <code>return</code> statement is omitted or if it is used without a value, the function will return <code>undefined</code>.</p> </li> <li> <p>Useful for Side Effects: Functions that perform actions (like logging, modifying global state, or interacting with the DOM) without returning a value are often referred to as procedures or actions. They focus on side effects rather than producing a value.</p> </li> </ol> <p>In summary, a function in JavaScript that does not use a <code>return</code> statement will return <code>undefined</code> by default. This behavior is often useful for functions that are intended to perform actions rather than calculate and return a value.</p>"},{"location":"frontend/js/function/intro/#function-types","title":"Function Types","text":"<p>let\u2019s dive deeper into <code>function declarations</code> and <code>function expressions</code>, the two types of functions used in JavaScript. To the casual reader, the two appear very similar:</p> <pre><code>// Function Declaration\nfunction isLie(cake) {\n  return cake === true;\n}\n\n// Function Expression\nvar isLie = function (cake) {\n  return cake === true;\n};\n</code></pre> <p>The only real difference between the two is when they are evaluated.</p> <p>A function declaration can be accessed by the interpreter as it is being parsed. The function expression, on the other hand, is part of an assignment expression, which prevents JavaScript from evaluating it until the program has completed the assignment. This difference may seem minor, but implications are huge; consider the following example:</p> <pre><code>// =&gt; Hi, I'm a function declaration!\ndeclaration();\n\nfunction declaration() {\n  console.log(\"Hi, I'm a function declaration!\");\n}\n\n// =&gt; Uncaught TypeError: undefined is not a function\nexpression();\n\nvar expression = function () {\n  console.log(\"Hi, I'm a function expression!\");\n};\n</code></pre> <p>As you can see in the previous example, the function expression threw an exception when it was invoked, but the function declaration executed just fine. This exception gets to the heart of the difference between declaration and expression functions. JavaScript knows about the declaration function and can parse it before the program executes. Therefore, it doesn\u2019t matter if the program invokes the function before it is defined because JavaScript has hoisted the function to the top of the current scope behind the scenes. The function expression is not evaluated until it is assigned to a variable; therefore, it is still undefined when invoked. This is why good code style is to define all variables at the top of the current scope. Had you done this then, your script would visually match what JavaScript is doing during parse time.</p> Tip <p>The concept to take away is that during parse time, JavaScript moves all function declarations to the top of the current scope. This is why it doesn\u2019t matter where declarative functions appear in the script body</p> <p>The key to remember here is that function declarations cannot be conditionally defined. If you need conditional definition use a function expression.</p> <p>Furthermore, function declarations should never be made inside a control flow statement, due to the different ways interpreters handle it</p> <ul> <li>Expert JavaScript by Mark E. Daggett, pg:37</li> </ul>"},{"location":"frontend/js/function/intro/#related-blogs","title":"Related Blogs","text":"<ul> <li>Why Mastering These Functions is Important</li> <li>High Order Function</li> <li>Javascript Arrow Functions</li> <li>Control Statement</li> <li>Understanding JavaScript Array Methods: Mutating vs. Non-Mutating</li> <li>Languages That Return Default Values</li> <li>Mastering JavaScript Array</li> <li>Why React is Both Declarative and Functional</li> </ul>"},{"location":"frontend/js/function/pure-and-impure/","title":"Pure & Impure","text":""},{"location":"frontend/js/function/pure-and-impure/#pure-function","title":"Pure Function","text":"<p>A pure function in JavaScript is a function that:</p> <ol> <li>Always produces the same <code>output</code> for the same <code>input</code>: No matter how many times you call the function with the same arguments, the result will always be the same.</li> <li>Has no side effects: It does not modify external variables, data, or state.</li> </ol>"},{"location":"frontend/js/function/pure-and-impure/#key-characteristics-of-pure-functions","title":"Key Characteristics of Pure Functions","text":"<ul> <li>Deterministic: Output depends solely on input.</li> <li>No Side Effects: Does not interact with or modify anything outside of its scope (e.g., no I/O operations, no modifying global variables).</li> </ul>"},{"location":"frontend/js/function/pure-and-impure/#example-of-a-pure-function","title":"Example of a Pure Function","text":"Example<pre><code>function add(a, b) {\n  return a + b;\n}\n\n// Example usage\nconsole.log(add(2, 3)); // Output: 5\nconsole.log(add(2, 3)); // Output: 5 (always the same output for the same inputs)\n</code></pre>"},{"location":"frontend/js/function/pure-and-impure/#what-makes-a-function-pure","title":"What Makes a Function Pure","text":"<p>No Dependency on External State:</p> <p>The function must not rely on or modify variables outside of its scope.</p> Impure ExamplePure Alternative Impure Example:<pre><code>let x = 10;\nfunction addToX(y) {\n    return x + y; // Impure because it uses external variable x\n}\n</code></pre> Pure Alternative:<pre><code>function add(x, y) {\n    return x + y; // Pure because it only depends on input arguments\n}\n</code></pre> <p>No Side Effects:</p> <p>It must not modify anything outside itself (e.g., DOM, global state, etc.).</p> Impure ExamplePure Alternative <pre><code>function incrementArray(arr) {\n    arr.push(arr.length); // Impure because it modifies the input array\n    return arr;\n}\n</code></pre> <pre><code>function getIncrementedArray(arr) {\n    return [...arr, arr.length]; // Pure because it returns a new array without modifying the original\n}\n</code></pre>"},{"location":"frontend/js/function/pure-and-impure/#impure-function","title":"Impure Function","text":""},{"location":"frontend/js/function/pure-and-impure/#reference","title":"Reference","text":"<ul> <li>What are Pure and Impure functions in JavaScript</li> <li>Pure vs Impure Functions </li> <li>Understanding Pure and Impure Functions</li> <li>Pure Functions</li> </ul>"},{"location":"frontend/js/function/return-statement/","title":"Return Statement","text":"<p>All functions return a value whether the original developer intended it or not.</p> <p>If a value was defined and passed back to the function caller, it can be assigned to a variable or used directly.</p> <p>A function returns <code>undefined</code> if a value was not returned, or the return statement inside a function is empty.</p> Determining If a Function Defines and Returns a Value<pre><code>// A function with an empty return-statement returns undefined\nfunction function1() {\n  return;\n}\n\n// A function with no return-statement returns undefined\nfunction function2() {}\n\nfunction function3() {\n  return 2 + 2;\n}\n\nfunction function4() {\n  return true;\n}\n\nfunction function5() {\n  return {};\n}\n\nvar fn1 = function1();\nconsole.log(\"Function1 returns: \" + fn1); // undefined\n\nvar fn2 = function2();\nconsole.log(\"Function2 returns: \" + fn2); // undefined\n\nvar fn3 = function3();\nconsole.log(\"Function3 returns: \" + fn3); // 4\n\nvar fn4 = function4();\nconsole.log(\"Function4 returns: \" + fn4); // true\n\nvar fn5 = function5();\nconsole.log(\"Function5 returns: \" + fn5); // Object{}\n</code></pre> <ul> <li>JavaScript Recipes: A Problem-Solution Approach by Russ Ferguson, Keith Cirkel - pg: 13</li> </ul>"},{"location":"frontend/js/function/types/","title":"Types","text":""},{"location":"frontend/js/function/types/#function-types","title":"Function Types","text":"<p>JavaScript functions can be broadly categorized based on their syntax, usage, and characteristics.</p> <p>Here's a summary of the main categories of functions in JavaScript:</p>"},{"location":"frontend/js/function/types/#1-function-declarations","title":"1. Function Declarations","text":"<p>Functions defined using the <code>function</code> keyword followed by the function name. These functions are hoisted, meaning they can be called before their definition in the code.</p> Usage SyntaxExample <pre><code>function functionName(parameters) {\n    // function body\n}\n</code></pre> <pre><code>function greet(name) {\n    return `Hello, ${name}!`;\n}\n</code></pre>"},{"location":"frontend/js/function/types/#2-function-expressions","title":"2. Function Expressions","text":"<p>Functions that are defined within an expression and assigned to a variable. They are not hoisted, so they must be defined before they are used.</p> <p>a. Anonymous Function Expressions</p> Usage SyntaxExample <pre><code>const functionName = function(parameters) {\n    // function body\n};\n</code></pre> <pre><code>const add = function(a, b) {\n    return a + b;\n};\n</code></pre> <p>b. Named Function Expressions</p> Usage SyntaxExample <pre><code>const functionName = function functionName(parameters) {\n    // function body\n};\n</code></pre> <pre><code>const subtract = function subtract(a, b) {\n    return a - b;\n};\n</code></pre> <p>c. Arrow Functions</p> Usage SyntaxCharacteristicsExample <pre><code>const functionName = (parameters) =&gt; {\n    // function body\n};\n</code></pre> <ul> <li>Concise syntax.</li> <li>Lexical <code>this</code>, meaning <code>this</code> is inherited from the surrounding context.</li> <li>Not hoisted.</li> </ul> <pre><code>const multiply = (x, y) =&gt; x * y;\n\nconst square = x =&gt; x * x;\n\nconst greet = name =&gt; {\n    return `Hello, ${name}!`;\n};\n</code></pre>"},{"location":"frontend/js/function/types/#3-immediately-invoked-function-expressions-iife","title":"3. Immediately Invoked Function Expressions (IIFE)","text":"<p>Functions that are defined and executed immediately. Used to create a local scope and avoid polluting the global namespace.</p> SyntaxExample <pre><code>(function() {\n    // function body\n})();\n</code></pre> <pre><code>(function() {\n    const message = 'Hello, World!';\n    console.log(message);\n})();\n</code></pre>"},{"location":"frontend/js/function/types/#4-generator-functions","title":"4. Generator Functions","text":"<p>Functions that can pause execution and resume later. Defined using the <code>function*</code> syntax and <code>yield</code> keyword.</p> SyntaxExample <pre><code>function* generatorFunction() {\n    // function body\n}\n</code></pre> <pre><code>function* countUpTo(max) {\n    let count = 1;\n    while (count &lt;= max) {\n        yield count++;\n    }\n}\n</code></pre>"},{"location":"frontend/js/function/types/#5-async-functions","title":"5. Async Functions","text":"<p>Functions designed for handling asynchronous operations. They return a <code>Promise</code> and allow the use of <code>await</code> to pause execution until a <code>Promise</code> is resolved.</p> SyntaxExample <pre><code>async function functionName(parameters) {\n    // function body\n}\n</code></pre> <pre><code>async function fetchData() {\n    const response = await fetch('https://api.example.com/data');\n    const data = await response.json();\n    return data;\n}\n</code></pre>"},{"location":"frontend/js/function/types/#6-method-definitions","title":"6. Method Definitions","text":"<p>Functions defined within objects or classes. They use shorthand syntax in object literals and class definitions.</p> <p>a. Object Methods</p> SyntaxExample <pre><code>const obj = {\n    methodName(parameters) {\n        // function body\n    }\n};\n</code></pre> <pre><code>const person = {\n    greet() {\n        return 'Hello!';\n    }\n};\n</code></pre> <p>b. Class Methods</p> SyntaxExample <pre><code>class ClassName {\n    methodName(parameters) {\n        // function body\n    }\n}\n</code></pre> <pre><code>class Person {\n    greet() {\n        return 'Hello!';\n    }\n}\n</code></pre> Summary <ul> <li>Function Declarations: Traditional named functions, hoisted.</li> <li>Function Expressions: Functions assigned to variables, not hoisted. Includes anonymous, named, and arrow functions.</li> <li>IIFE: Immediately executed function expressions, used for local scope.</li> <li>Generator Functions: Functions that can yield multiple values over time.</li> <li>Async Functions: Functions for asynchronous operations, using <code>async/await</code>.</li> <li>Method Definitions: Functions defined within objects or classes.</li> </ul> <p>Each of these function types serves different purposes and is used in various scenarios in JavaScript programming.</p>"},{"location":"frontend/js/function/types/#reference","title":"Reference","text":"<ul> <li>8 Types of JavaScript Functions</li> <li>What are the different types of functions in JavaScript?</li> <li>Functions in JavaScript</li> <li>Different ways of writing functions in JavaScript</li> <li>Functions in JavaScript: Important Things To Know 2024</li> </ul>"},{"location":"frontend/js/function/advanced/advanced-concept/","title":"Concept","text":"Key Concept to Remember <p>Arrow functions lexically bind <code>this</code> from their surrounding scope. This means they do not have their own <code>this</code> context, making them ideal for preserving this in callbacks and asynchronous code without additional binding.</p> <p>In traditional (general) functions, the binding of <code>this</code> depends on the context in which the function is invoked.</p>"},{"location":"frontend/js/function/advanced/advanced-concept/#advanced-concepts","title":"Advanced Concepts","text":"<p>Here are some advanced function-related topics in JavaScript:</p> <ol> <li> <p>Anonymous Functions and Function Expressions</p> <p>Functions don\u2019t always need names. An anonymous function can be used in situations where a function doesn\u2019t need to be reused.</p> <pre><code>const greet = function (name) {\n  return `Hello, ${name}!`;\n};\nconsole.log(greet(\"Alice\")); // Outputs: Hello, Alice!\n</code></pre> </li> <li> <p>Arrow Functions</p> <p>Arrow functions offer a shorter syntax and do not bind their own this. They are especially useful for simple functions.</p> <pre><code>const multiply = (x, y) =&gt; x * y;\nconsole.log(multiply(4, 5)); // Outputs: 20\n</code></pre> <p>Note: Arrow functions do not have their own this context.</p> </li> <li> <p>Higher-Order Functions</p> <p>A higher-order function is a function that takes another function as an argument or returns a function.</p> <pre><code>function higherOrderFunction(callback) {\n  return function (value) {\n    return callback(value);\n  };\n}\n\nconst square = higherOrderFunction((x) =&gt; x * x);\nconsole.log(square(5)); // Outputs: 25\n</code></pre> </li> <li> <p>Closures</p> <p>Closures are functions that capture the lexical environment in which they are defined, allowing them to access variables from an outer scope even after that outer function has finished executing.</p> <pre><code>function createCounter() {\n  let count = 0;\n  return function () {\n    count += 1;\n    return count;\n  };\n}\n\nconst counter = createCounter();\nconsole.log(counter()); // Outputs: 1\nconsole.log(counter()); // Outputs: 2\n</code></pre> </li> <li> <p>Currying and Partial Application</p> <p><code>Currying</code> transforms a function that takes multiple arguments into a sequence of functions each taking a single argument. <code>Partial</code> application involves fixing some arguments of a function and generating a new function.</p> Currying<pre><code>function multiply(a) {\n  return function (b) {\n    return a * b;\n  };\n}\n\nconst multiplyBy2 = multiply(2);\nconsole.log(multiplyBy2(5)); // Outputs: 10\n</code></pre> Partial Application<pre><code>function add(a, b, c) {\n  return a + b + c;\n}\n\nfunction partialAdd(a) {\n  return function (b, c) {\n    return add(a, b, c);\n  };\n}\n\nconst add5 = partialAdd(5);\nconsole.log(add5(3, 2)); // Outputs: 10\n</code></pre> </li> <li> <p>Generators</p> <p>Generators are functions that can be paused and resumed, allowing for more complex iteration patterns.</p> <pre><code>function* countUpTo(max) {\n  let count = 1;\n  while (count &lt;= max) {\n    yield count++;\n  }\n}\n\nconst counter = countUpTo(3);\nconsole.log(counter.next().value); // Outputs: 1\nconsole.log(counter.next().value); // Outputs: 2\nconsole.log(counter.next().value); // Outputs: 3\nconsole.log(counter.next().value); // Outputs: undefined\n</code></pre> </li> <li> <p>Async Functions and Promises</p> <p>Async functions simplify working with asynchronous code by allowing you to use <code>await</code> to pause execution until a promise is resolved.</p> <pre><code>async function fetchData() {\n  const response = await fetch(\"https://api.example.com/data\");\n  const data = await response.json();\n  return data;\n}\n\nfetchData().then((data) =&gt; console.log(data));\n</code></pre> </li> </ol>"},{"location":"frontend/js/function/advanced/advanced-concept/#hidden-facts","title":"Hidden Facts","text":"<ul> <li>Functions Are Objects: Functions in JavaScript are first-class objects, meaning they can have properties and methods.</li> <li>Function Hoisting: Function declarations are hoisted to the top of their scope, meaning they can be used before they are defined.</li> <li><code>arguments</code> Object: Regular functions have access to an <code>arguments</code> object that contains all the passed arguments.</li> <li>Function Constructor: Functions can also be created using the <code>Function</code> constructor, though it's less common and can be less secure.</li> </ul> <pre><code>const sum = new Function(\"a\", \"b\", \"return a + b;\");\nconsole.log(sum(1, 2)); // Outputs: 3\n</code></pre> <p>Mastering these concepts will greatly enhance your JavaScript skills and help you write more efficient, elegant code.</p> Implement in Real Projects <p>Apply your knowledge in real-world projects:</p> <ol> <li>Refactor Code: Use advanced functions to improve existing codebases. For instance, refactor callback-heavy code to use Promises and async/await.</li> <li>Build Libraries: Create libraries or utilities that leverage these advanced concepts. For example, build a custom function library using higher-order functions and currying.</li> <li>Contribute to Open Source: Work on open-source projects where these concepts are used. This will expose you to practical use cases and diverse coding styles.</li> </ol>"},{"location":"frontend/js/function/advanced/advanced-concept/#why-these-concepts-are-important","title":"Why These Concepts Are Important","text":"<p>Performance Optimization: Advanced functions like currying and partial application can optimize performance by reducing redundant computations. Enhanced Code Readability: Functions like arrow functions and higher-order functions can make code more concise and easier to understand. Maintainability: Closures and generators help manage state and handle complex logic in a manageable way, making the codebase easier to maintain. Improved Asynchronous Handling: Async/await provides a more straightforward way to handle asynchronous operations compared to traditional callback methods. Functional Programming Paradigms: Embracing functional programming techniques can lead to more predictable, reliable, and testable code.</p>"},{"location":"frontend/js/function/advanced/function-categories/","title":"Function Categories","text":""},{"location":"frontend/js/function/advanced/function-categories/#overview","title":"Overview","text":"<p>In JavaScript, functions can be categorized based on various factors, such as their syntax, behavior, and usage within the program. Below are some common categories of functions in JavaScript:</p>"},{"location":"frontend/js/function/advanced/function-categories/#1-based-on-function-syntax","title":"1. Based on Function Syntax","text":"<ul> <li> <p>Function Declaration (Named Function): A function that is declared with a name. It can be invoked before its declaration due to hoisting.</p> <pre><code>function sayHello() {\n  console.log(\"Hello, World!\");\n}\nsayHello();\n</code></pre> </li> <li> <p>Function Expression: A function that is defined as part of an expression. It can be anonymous or named.</p> <pre><code>const greet = function () {\n  console.log(\"Hello!\");\n};\ngreet();\n</code></pre> </li> <li> <p>Arrow Function: A shorthand syntax for writing functions. Arrow functions have lexical scoping for <code>this</code> and are often used for concise function expressions.</p> <pre><code>const add = (a, b) =&gt; a + b;\nconsole.log(add(5, 10));\n</code></pre> </li> <li> <p>Anonymous Function: A function without a name. Often used in places where functions are passed as arguments (like callbacks).</p> <pre><code>setTimeout(function () {\n  console.log(\"This is an anonymous function!\");\n}, 1000);\n</code></pre> </li> <li> <p>Named Function Expression: A function expression where the function has a name, but it's still defined as part of an expression.</p> <pre><code>const factorial = function fact(n) {\n  if (n === 0) return 1;\n  return n * fact(n - 1);\n};\nconsole.log(factorial(5)); // Output: 120\n</code></pre> </li> </ul>"},{"location":"frontend/js/function/advanced/function-categories/#2-based-on-function-behavior","title":"2. Based on Function Behavior","text":"<ul> <li> <p>Pure Function: A function that, given the same input, always produces the same output and has no side effects (it does not modify any external state).</p> <pre><code>const add = (a, b) =&gt; a + b; // Pure function\n</code></pre> </li> <li> <p>Impure Function: A function that may rely on or modify external state, or produce different outputs for the same inputs.</p> <pre><code>let counter = 0;\nconst increment = () =&gt; counter++; // Impure function, modifies external state\n</code></pre> </li> <li> <p>Recursive Function: A function that calls itself in order to solve smaller instances of a problem.</p> <pre><code>const factorial = (n) =&gt; {\n  if (n === 0) return 1;\n  return n * factorial(n - 1);\n};\nconsole.log(factorial(5)); // Output: 120\n</code></pre> </li> </ul>"},{"location":"frontend/js/function/advanced/function-categories/#3-based-on-return-type","title":"3. Based on Return Type","text":"<ul> <li> <p>Void Function: A function that does not return any value. It performs an action but doesn't produce a return value.</p> <pre><code>function logMessage() {\n  console.log(\"This function does not return anything.\");\n}\nlogMessage();\n</code></pre> </li> <li> <p>Value-returning Function: A function that returns a value after performing some operations.</p> <pre><code>function add(a, b) {\n  return a + b;\n}\nconsole.log(add(2, 3)); // Output: 5\n</code></pre> </li> </ul>"},{"location":"frontend/js/function/advanced/function-categories/#4-based-on-function-invocation","title":"4. Based on Function Invocation","text":"<ul> <li> <p>Callback Function: A function that is passed as an argument to another function and is executed at a later time (usually after some asynchronous operation).</p> <pre><code>function fetchData(callback) {\n  setTimeout(() =&gt; {\n    callback(\"Data loaded\");\n  }, 1000);\n}\n\nfetchData((message) =&gt; {\n  console.log(message);\n});\n</code></pre> </li> <li> <p>Higher-order Function: A function that takes one or more functions as arguments, returns a function, or both. This is a key concept in functional programming.</p> <pre><code>const multiplyBy = (factor) =&gt; {\n  return (number) =&gt; number * factor;\n};\n\nconst double = multiplyBy(2);\nconsole.log(double(5)); // Output: 10\n</code></pre> </li> <li> <p>Immediately Invoked Function Expression (IIFE): A function that is defined and executed immediately after being declared.</p> <pre><code>(function () {\n  console.log(\"I am executed immediately!\");\n})();\n</code></pre> </li> </ul>"},{"location":"frontend/js/function/advanced/function-categories/#5-based-on-scope-and-context","title":"5. Based on Scope and Context","text":"<ul> <li> <p>Global Function: A function that is defined in the global scope and is accessible throughout the program.</p> <pre><code>function globalFunction() {\n  console.log(\"I am a global function!\");\n}\n</code></pre> </li> <li> <p>Local Function: A function defined within another function, having access only within that function.</p> <pre><code>function outerFunction() {\n  function innerFunction() {\n    console.log(\"I am a local function!\");\n  }\n  innerFunction();\n}\nouterFunction();\n</code></pre> </li> <li> <p>Method (Object Function): A function that is a property of an object. It is called a method when defined inside an object.</p> <pre><code>const person = {\n  name: \"John\",\n  greet: function () {\n    console.log(`Hello, my name is ${this.name}`);\n  },\n};\nperson.greet(); // Output: Hello, my name is John\n</code></pre> </li> </ul>"},{"location":"frontend/js/function/advanced/function-categories/#6-functional-programming-concepts","title":"6. Functional Programming Concepts","text":"<ul> <li> <p>Lambda Function: A small, anonymous function that is often used in functional programming. In JavaScript, it's commonly implemented using arrow functions.</p> <pre><code>const square = (x) =&gt; x * x;\nconsole.log(square(4)); // Output: 16\n</code></pre> </li> <li> <p>Currying: A technique where a function takes multiple arguments one by one, returning new functions until all arguments are received.</p> <pre><code>const multiply = (a) =&gt; (b) =&gt; a * b;\nconst double = multiply(2);\nconsole.log(double(5)); // Output: 10\n</code></pre> </li> <li> <p>Partial Application: A form of currying where some arguments of the function are pre-filled.</p> <pre><code>const add = (a, b, c) =&gt; a + b + c;\nconst addFive = add.bind(null, 5); // Partial application\nconsole.log(addFive(3, 2)); // Output: 10\n</code></pre> </li> </ul>"},{"location":"frontend/js/function/advanced/function-categories/#7-based-on-asynchronous-behavior","title":"7. Based on Asynchronous Behavior","text":"<ul> <li>Synchronous Function: A function that runs and completes execution before allowing the program to move to the next line of code.</li> </ul> <pre><code>function syncFunction() {\n  console.log(\"This is a synchronous function.\");\n}\nsyncFunction();\n</code></pre> <ul> <li> <p>Asynchronous Function: A function that executes asynchronously, allowing other operations to continue while it completes.</p> <ol> <li> <p>Callback-based Asynchronous Function:</p> <pre><code>setTimeout(() =&gt; {\n    console.log(\"Executed after 2 seconds.\");\n}, 2000);\n</code></pre> </li> <li> <p>Promise-based Asynchronous Function:</p> <pre><code>function fetchData() {\n    return new Promise((resolve, reject) =&gt; {\n        setTimeout(() =&gt; {\n            resolve(\"Data fetched\");\n        }, 2000);\n    });\n}\n\nfetchData().then((message) =&gt; {\n    console.log(message);  // Output: Data fetched\n});\n</code></pre> </li> <li> <p>Async/Await: A syntax to work with promises in a more synchronous-like manner.</p> <pre><code>async function fetchData() {\n    let data = await new Promise((resolve) =&gt; {\n        setTimeout(() =&gt; resolve(\"Data fetched\"), 2000);\n    });\n    console.log(data);  // Output: Data fetched\n}\n\nfetchData();\n</code></pre> </li> </ol> </li> </ul> <p>These categories help us understand the flexibility and capabilities of functions in JavaScript, making it possible to handle various programming paradigms, including imperative, functional, and object-oriented programming.</p>"},{"location":"frontend/js/function/advanced/function-categories/#programming-functions","title":"Programming Functions","text":"<ol> <li> <p>Based on Return Type:</p> <ul> <li>Void Function: A function that does not return any value. It simply performs an action (e.g., printing output).</li> <li>Value-returning Function: A function that returns a value after execution (e.g., a function that adds two numbers and returns the result).</li> </ul> </li> <li> <p>Based on Number of Parameters:</p> <ul> <li>No-argument Function: A function that takes no input parameters.</li> <li>Single-argument Function: A function that takes one input parameter.</li> <li>Multiple-argument Function: A function that takes multiple input parameters.</li> </ul> </li> <li> <p>Based on Scope and Lifetime:</p> <ul> <li>Global Function: A function defined outside of any classes or methods, accessible from anywhere in the program.</li> <li>Local Function: A function defined within another function or block, typically having a limited scope.</li> <li>Recursive Function: A function that calls itself in order to solve smaller instances of the problem.</li> </ul> </li> <li> <p>Based on Usage:</p> <ul> <li>Pure Function: A function that always produces the same output for the same input and has no side effects.</li> <li>Impure Function: A function that may produce different outputs for the same input or has side effects (e.g., modifying a global variable).</li> </ul> </li> <li> <p>Based on Invocation:</p> <ul> <li>Built-in Function: Functions that are pre-defined in the programming language (e.g., <code>print()</code> in Python, <code>sqrt()</code> in C++).</li> <li>User-defined Function: Functions created by the programmer to perform specific tasks.</li> </ul> </li> <li> <p>Functional Programming Categories:</p> <ul> <li>Higher-order Function: A function that takes one or more functions as arguments or returns a function as its result.</li> <li>Anonymous Function (Lambda Function): A function that is defined without a name, often used for short, one-time operations.</li> </ul> </li> </ol> <p>These are just a few of the main categories and types of functions that appear across different areas of mathematics and programming. The categorization can be further refined depending on the specific context in which the functions are applied.</p> <ul> <li>A Guaranteed Method for Writing Testable Code in JavaScript</li> <li>Understanding State Batching in React: A Simple Explanation</li> </ul>"},{"location":"frontend/js/function/hof/intro/","title":"Intro","text":"<p>Higher-order functions (HOFs) \u2014 that is, functions that take functions as <code>parameters</code>, such as the following</p> <ul> <li><code>reduce()</code> and <code>reduceRight()</code> to apply an operation to a whole array, reducing it to a single result</li> <li><code>map()</code> to transform one array into another by applying a function to each of its elements</li> <li><code>flat()</code> to make a single array out of an array of arrays</li> <li><code>flatMap()</code> to mix together mapping and flattening</li> <li><code>forEach()</code> to simplify writing loops by abstracting the necessary looping code</li> </ul> <p>We\u2019ll also be able to perform searches and selections with the following:</p> <ul> <li><code>filter()</code> to pick some elements from an array</li> <li><code>find()</code> and <code>findIndex()</code> to search for elements that satisfy a condition</li> <li>A pair of predicates, <code>every()</code> and <code>some()</code>, to check an array for a Boolean test</li> </ul> <p>Using these functions will let you work more declaratively, and you\u2019ll see that your focus will shift to what you need to do and not so much to how it\u2019s going to be done; the dirty details are hidden inside our functions. Instead of writing a series of possibly nested loops, we\u2019ll focus on using functions as building blocks to specify our desired result.</p>"},{"location":"frontend/js/function/hof/intro/#overview","title":"Overview","text":"<p>JS Online Compiler</p> <pre><code>function veg() {\n  return \"I'm Veg\";\n}\n\nfunction nonVege() {\n  return \"I'm non Veg\";\n}\n\nfunction Meal(veg) {\n  return veg();\n}\n\n// Meal(veg);\n\nconsole.log(Meal(veg));\n</code></pre> <p>A higher-order function (HOF) in JavaScript is defined as a function that:</p> <ul> <li>Accepts a function as an argument, or</li> <li>Returns a function.</li> </ul> <p>Your original Meal function only meets the first criterion, because it accepts a function (veg) as an argument and calls it.</p> <p>Let's break down your two criteria:</p> <p>1. Function that accepts another function as an argument</p> <p>Your <code>Meal</code> function does this:</p> <pre><code>function Meal(veg) {\n  return veg(); // 'veg' is a function passed as an argument.\n}\n</code></pre> <p>In this case, <code>veg</code> is passed as an argument to the <code>Meal</code> function. When <code>Meal</code> is called with the <code>veg</code> function as an argument, it calls <code>veg()</code> inside it, which makes it a higher-order function (HOF).</p> <p>2. Function that returns another function</p> <p>Here's an example where the <code>Meal</code> function returns another function:</p> <pre><code>function createMeal(type) {\n  return function () {\n    if (type === \"veg\") {\n      return \"I'm Veg\";\n    } else {\n      return \"I'm non Veg\";\n    }\n  };\n}\n\nconst vegMeal = createMeal(\"veg\");\nconsole.log(vegMeal()); // Prints: \"I'm Veg\"\n\nconst nonVegMeal = createMeal(\"nonVeg\");\nconsole.log(nonVegMeal()); // Prints: \"I'm non Veg\"\n</code></pre> <p>In this example, <code>createMeal</code> is a higher-order function because it returns a new function based on the argument (<code>'veg'</code> or <code>'nonVeg'</code>). The returned function then contains the logic for the meal type.</p> Summary <ul> <li>In your original example, <code>Meal</code> qualifies as a higher-order function because it accepts a function as an argument (<code>veg</code>).</li> <li>If the <code>Meal</code> function had returned a function (rather than just calling <code>veg</code>), it would also qualify as a higher-order function for returning a function.</li> </ul> <p>So, you are correct in both cases:</p> <ul> <li>If a function accepts another function as an argument (like your <code>Meal</code> function), it is a higher-order function.</li> <li>If a function returns a function, it is also a higher-order function.</li> </ul> <p>Your initial code fits the definition of a higher-order function because it takes a function (<code>veg</code>) as an argument and calls it, which is why it qualifies as a higher-order function in JavaScript.</p>"},{"location":"frontend/js/function/hof/intro/#why-can-we-also-call-it-hoc","title":"Why can we also call it HOC?","text":"<p>The term HOC (Higher-Order Component) is generally used in the context of React, which is a JavaScript library for building user interfaces. In React, Higher-Order Components are a specific type of higher-order function that takes a component as an argument and returns a new component, typically with enhanced functionality.</p> <pre><code>function withEnhancement(Component) {\n  return function EnhancedComponent(props) {\n    // Add some additional behavior here\n    return &lt;Component {...props} /&gt;;\n  };\n}\n</code></pre> <p>Higher-Order Component (HOC) is a term specific to React and is a type of higher-order function that operates on React components.</p>"},{"location":"frontend/js/function/hof/intro/#reference","title":"Reference","text":""},{"location":"frontend/js/function/hof/map/","title":"Map","text":"<p>In JavaScript, <code>.map</code> is considered a higher-order function because it meets the definition of a higher-order function: it takes a function as an argument and/or returns a function. Here's how this works:</p>"},{"location":"frontend/js/function/hof/map/#what-is-map","title":"What is <code>.map</code>?","text":"<p>The <code>.map()</code> method is used on arrays to create a new array by applying a given function to each element of the original array. The key aspect is that the function passed to <code>.map()</code> does not modify the original array but instead returns a new array based on the function's transformation.</p>"},{"location":"frontend/js/function/hof/map/#why-is-map-a-higher-order-function","title":"Why is <code>.map</code> a Higher-Order Function?","text":"<p>A higher-order function is a function that either:</p> <ol> <li>Takes one or more functions as arguments, or</li> <li>Returns a function as a result.</li> </ol> <p>In the case of <code>.map()</code>, it takes a function as an argument. Here's a breakdown of how that makes <code>.map</code> a higher-order function:</p> <ol> <li> <p>It accepts a callback function as an argument: When you use <code>.map()</code>, you provide a function that will be applied to each element of the array.</p> </li> <li> <p>The callback function can be defined inline: This means you can pass an anonymous function (also called a callback function) directly within the <code>.map()</code> method.</p> </li> </ol> Example of .map() as a Higher-Order Function<pre><code>// An example array\nconst numbers = [1, 2, 3, 4];\n\n// .map() takes a function as an argument\nconst doubledNumbers = numbers.map(function (num) {\n  return num * 2; // Callback function transforms each element\n});\n\nconsole.log(doubledNumbers); // Output: [2, 4, 6, 8]\n</code></pre> <p>In this example:</p> <ul> <li>The <code>.map()</code> method is called on the <code>numbers</code> array.</li> <li>We pass a callback function <code>function(num) { return num * 2; }</code> to <code>.map()</code>. This function is applied to each element of the array.</li> <li>The callback function transforms each element, and <code>.map()</code> returns a new array with the transformed elements.</li> </ul>"},{"location":"frontend/js/function/hof/map/#more-examples","title":"More Examples","text":"<p>Using Arrow Function Syntax</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst squaredNumbers = numbers.map((num) =&gt; num ** 2);\nconsole.log(squaredNumbers); // Output: [1, 4, 9, 16]\n</code></pre> <p>Using <code>.map()</code> to Create Objects</p> <pre><code>const names = [\"Alice\", \"Bob\", \"Charlie\"];\nconst nameObjects = names.map((name) =&gt; ({ name: name }));\nconsole.log(nameObjects);\n// Output: [{ name: \"Alice\" }, { name: \"Bob\" }, { name: \"Charlie\" }]\n</code></pre>"},{"location":"frontend/js/function/hof/map/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Function as Argument: <code>.map()</code> is a higher-order function because it accepts a function as an argument.</li> <li>Returns a New Array: It applies the given function to each element and returns a new array.</li> <li>No Side Effects: It doesn't modify the original array; it creates a new one.</li> </ul> <p>In summary, <code>.map()</code> is a higher-order function in JavaScript because it accepts a function as an argument and applies it to each element in an array, returning a new array with the transformed results.</p>"},{"location":"frontend/js/function/hof/map/#udemy-modern-react-with-redux-2024-update","title":"Udemy - Modern React with Redux [2024 Update]","text":"<ul> <li>link</li> </ul>"},{"location":"frontend/js/function/hof/map/#udemy-the-ultimate-react-course-2024-react-nextjs-redux-more","title":"Udemy - The Ultimate React Course 2024: React, Next.js, Redux &amp; More","text":"<ul> <li>link</li> </ul>"},{"location":"frontend/js/function/hof/map/#object-oriented-design-oop-patterns","title":"Object-oriented design (OOP) patterns","text":"<p><code>pg: 412</code></p>"},{"location":"frontend/js/function/hof/map/#functional-design-patterns","title":"Functional design patterns","text":"<p><code>pg: 417</code></p> <p>Having seen several OOP design patterns, it may seem a cheat to say that there\u2019s no approved, official, or even remotely generally accepted similar list of patterns for FP.</p>"},{"location":"frontend/js/function/hof/map/#processing-collections-using-filtermapreduce","title":"Processing collections using filter/map/reduce:","text":"<p>Whenever you have to process a data collection, using declarative higher-order functions such as <code>filter()</code>, <code>map()</code>, and <code>reduce()</code>.</p>"},{"location":"frontend/js/function/hof/map/#lazy-evaluation-with-thunks","title":"Lazy evaluation with thunks:","text":"<p>The idea of lazy evaluation is not doing any calculations until they are actually needed. In some programming languages, this is built in. However, in JavaScript (and most imperative languages), eager evaluation is applied, in which an expression is evaluated as soon as it is bound to some variable. (Another way of saying this is that JavaScript is a strict programming language, with a strict paradigm, which only allows calling a function if all of its parameters have been completely evaluated.) This sort of evaluation is required when you need to specify the order of evaluation with precision, mainly because such evaluations may have side effects.</p>"},{"location":"frontend/js/function/hof/map/#persistent-data-structures-for-immutability","title":"Persistent data structures for immutability","text":"<p>Having immutable data structures, is mandatory when working with certain frameworks, and in general, it is recommended because it helps to reason about a program or to debug it.</p>"},{"location":"frontend/js/function/hof/map/#wrapped-values-for-checks-and-operations","title":"Wrapped values for checks and operations:","text":"<p>If you directly work with variables or data structures, you can modify them at will (possibly violating any restrictions), or you may need to do many checks before using them (such as verifying that a value is not null before trying to access the corresponding object). This pattern aims to wrap a value within an object or function, so direct manipulation won\u2019t be possible, and checks can be managed more functionally.</p>"},{"location":"frontend/js/function/hof/question-answer/","title":"Q&A","text":"<p>Here's a set of Higher-Order Function (HOF) practice questions in JavaScript, ranging from beginner to intermediate level. These questions will help you improve your understanding and use of higher-order functions like <code>map()</code>, <code>filter()</code>, <code>reduce()</code>, and custom HOFs.</p>"},{"location":"frontend/js/function/hof/question-answer/#beginner-level-understanding-basic-hofs","title":"Beginner Level (Understanding Basic HOFs)","text":"1. What is a higher-order function in JavaScript? <ul> <li> <p>Cognitive Skill: Comprehension</p> </li> <li> <p>Explanation:</p> <p>Define a higher-order function and provide an example (e.g., <code>map()</code>, <code>filter()</code>, r<code>educe()</code>).</p> </li> </ul> 2. Given an array of numbers, use <code>map()</code> to create a new array where each number is squared. <ul> <li> <p>Cognitive Skill: Application</p> </li> <li> <p>Example:</p> <pre><code>let numbers = [1, 2, 3, 4];\n// Use map to square the numbers\n</code></pre> </li> </ul> 3. Use <code>filter()</code> to create a new array containing only the numbers greater than 10 from the following array: <code>[5, 12, 7, 30, 8, 2]</code>. <ul> <li> <p>Cognitive Skill: Application</p> </li> <li> <p>Example:</p> <pre><code>let numbers = [5, 12, 7, 30, 8, 2];\n// Use filter to select numbers greater than 10\n</code></pre> </li> </ul> 4. Using the <code>reduce()</code> method, calculate the sum of an array of numbers. <ul> <li> <p>Cognitive Skill: Application</p> </li> <li> <p>Example:</p> <pre><code>let numbers = [1, 2, 3, 4, 5];\n// Use reduce to sum the numbers\n</code></pre> </li> </ul> 5. Create a higher-order function that takes a function as an argument and returns a new function that calls the original function twice. <ul> <li> <p>Cognitive Skill: Synthesis</p> </li> <li> <p>Example:</p> <pre><code>function callTwice(fn) {\n    return function(...args) {\n        fn(...args);\n        fn(...args);\n    };\n}\n</code></pre> </li> </ul>"},{"location":"frontend/js/function/hof/question-answer/#intermediate-level-advanced-use-of-hofs","title":"Intermediate Level (Advanced Use of HOFs)","text":"6. Write a function that accepts an array and a callback, and uses map() to apply the callback to each element of the array. <ul> <li> <p>Cognitive Skill: Application</p> </li> <li> <p>Example:</p> <pre><code>function mapArray(arr, callback) {\n    return arr.map(callback);\n}\n\nlet result = mapArray([1, 2, 3, 4], num =&gt; num * 2); // [2, 4, 6, 8]\n</code></pre> </li> </ul> 7. Create a higher-order function that accepts an array and returns a new array with only the odd numbers, using <code>filter()</code>. <ul> <li> <p>Cognitive Skill: Application</p> </li> <li> <p>Example:</p> <pre><code>function filterOdds(arr) {\n    return arr.filter(num =&gt; num % 2 !== 0);\n}\n</code></pre> </li> </ul> 8. Write a function that returns the average of an array of numbers using reduce(). <ul> <li> <p>Cognitive Skill: Problem Solving</p> </li> <li> <p>Example:</p> <pre><code>function average(arr) {\n    return arr.reduce((acc, num) =&gt; acc + num, 0) / arr.length;\n}\n</code></pre> </li> </ul> 9. Create a function that accepts two arrays of numbers and returns an array of numbers that are present in both arrays, using <code>filter()</code> and <code>includes()</code>. <ul> <li> <p>Cognitive Skill: Application</p> </li> <li> <p>Example:</p> <pre><code>function intersection(arr1, arr2) {\n    return arr1.filter(num =&gt; arr2.includes(num));\n}\n</code></pre> </li> </ul> 10. Write a higher-order function <code>compose()</code> that allows you to compose multiple functions together. <ul> <li> <p>Cognitive Skill: Synthesis</p> </li> <li> <p>Example:</p> <pre><code>function compose(...fns) {\n    return function (value) {\n        return fns.reduceRight((acc, fn) =&gt; fn(acc), value);\n    };\n}\n\nlet add = (x) =&gt; x + 1;\nlet multiply = (x) =&gt; x * 2;\nlet addThenMultiply = compose(multiply, add);\nconsole.log(addThenMultiply(2)); // 6 (add 1, then multiply by 2)\n</code></pre> </li> </ul>"},{"location":"frontend/js/function/hof/question-answer/#intermediate-to-advanced-level-custom-higher-order-functions","title":"Intermediate to Advanced Level (Custom Higher-Order Functions)","text":"11. Create a function <code>debounce()</code> that accepts a function and a delay, and ensures the function is called only after the specified delay and only if the last call occurred after the delay. <ul> <li> <p>Cognitive Skill: Problem Solving/Optimization</p> </li> <li> <p>Example:</p> <pre><code>function debounce(fn, delay) {\n    let timeout;\n    return function(...args) {\n        clearTimeout(timeout);\n        timeout = setTimeout(() =&gt; fn(...args), delay);\n    };\n}\n</code></pre> </li> </ul> 12. Write a function <code>once()</code> that ensures a given function can only be called once, no matter how many times it is invoked. <ul> <li> <p>Cognitive Skill: Problem Solving/Abstraction</p> </li> <li> <p>Example:</p> <pre><code>function once(fn) {\n    let called = false;\n    return function(...args) {\n        if (!called) {\n            called = true;\n            return fn(...args);\n        }\n    };\n}\n</code></pre> </li> </ul> 13. Write a <code>memoize()</code> function that caches the results of a function based on its arguments. If the same arguments are provided again, it should return the cached result instead of recalculating it. <ul> <li> <p>Cognitive Skill: Problem Solving/Optimization</p> </li> <li> <p>Example:</p> <pre><code>function memoize(fn) {\n    let cache = {};\n    return function(...args) {\n        const key = JSON.stringify(args);\n        if (cache[key]) {\n            return cache[key];\n        }\n        const result = fn(...args);\n        cache[key] = result;\n        return result;\n    };\n}\n</code></pre> </li> </ul> 14. Write a function <code>repeat()</code> that takes a string and a number as arguments and returns the string repeated that many times. Use <code>Array.from()</code> with <code>map()</code> to accomplish this. <ul> <li> <p>Cognitive Skill: Application</p> </li> <li> <p>Example:</p> <pre><code>function repeat(str, num) {\n    return Array.from({ length: num }, () =&gt; str).join('');\n}\n</code></pre> </li> </ul> 15. Write a function <code>groupBy()</code> that groups an array of objects by a property. The function should return an object where the keys are the unique values of that property, and the values are arrays of objects. <ul> <li> <p>Cognitive Skill: Problem Solving/Abstraction</p> </li> <li> <p>Example:</p> <pre><code>function groupBy(arr, key) {\n    return arr.reduce((acc, obj) =&gt; {\n        const groupKey = obj[key];\n        if (!acc[groupKey]) {\n            acc[groupKey] = [];\n        }\n\n        acc[groupKey].push(obj);\n        return acc;\n    }, {});\n}\n</code></pre> </li> </ul>"},{"location":"frontend/js/function/hof/question-answer/#advanced-level-complex-hofs-composition","title":"Advanced Level (Complex HOFs &amp; Composition)","text":"16. Implement a function <code>pipe()</code> that allows you to apply multiple functions from left to right. <ul> <li> <p>Cognitive Skill: Composition/Synthesis</p> </li> <li> <p>Example:</p> <pre><code>function pipe(...fns) {\n    return function(value) {\n        return fns.reduce((acc, fn) =&gt; fn(acc), value);\n    };\n}\n\nconst add2 = x =&gt; x + 2;\nconst multiplyBy3 = x =&gt; x * 3;\nconst pipeExample = pipe(add2, multiplyBy3);\nconsole.log(pipeExample(4)); // 18 (4 + 2, then * 3)\n</code></pre> </li> </ul> 17. Write a function <code>flatten()</code> that flattens a nested array using recursion and <code>reduce()</code>. <ul> <li> <p>Cognitive Skill: Problem Solving/Recursion</p> </li> <li> <p>Example:</p> <pre><code>function flatten(arr) {\n    return arr.reduce((acc, val) =&gt; Array.isArray(val) ? acc.concat(flatten(val)) : acc.concat(val), []);\n}\n</code></pre> </li> </ul> 18. Create a function <code>oncePerInterval()</code> that allows a function to be called only once within a given time interval (e.g., 2000ms). <ul> <li> <p>Cognitive Skill: Problem Solving/Abstraction</p> </li> <li> <p>Example:</p> <pre><code>function oncePerInterval(fn, interval) {\n    let lastCall = 0;\n\n    return function(...args) {\n        const now = Date.now();\n\n        if (now - lastCall &gt;= interval) {\n            lastCall = now;\n            fn(...args);\n        }\n    };\n}\n</code></pre> </li> </ul> 19. Write a <code>partial()</code> function that allows you to pre-fill some arguments for a function, and then apply the remaining arguments later. <ul> <li> <p>Cognitive Skill: Abstraction/Synthesis</p> </li> <li> <p>Example:</p> <pre><code>function partial(fn, ...args1) {\n    return function(...args2) {\n        return fn(...args1, ...args2);\n    };\n}\n</code></pre> </li> </ul> 20. Write a function <code>asyncMap()</code> that works like <code>map()</code>, but it works with asynchronous functions and returns a promise of the mapped results. <ul> <li> <p>Cognitive Skill: Asynchronous Programming/Abstraction</p> </li> <li> <p>Example:</p> <pre><code>function asyncMap(arr, asyncFn) {\n    return Promise.all(arr.map(asyncFn));\n}\n</code></pre> </li> </ul>"},{"location":"frontend/js/function/hof/question-answer/#tips-for-practicing-hofs-in-javascript","title":"Tips for Practicing HOFs in JavaScript:","text":"<ul> <li>Practice using built-in HOFs like <code>map()</code>, <code>filter()</code>, and <code>reduce()</code>. They're powerful and frequently used in real-world code.</li> <li>Experiment with custom HOFs: Start building your own higher-order functions to modify or enhance behavior.</li> <li>Combine HOFs: Get comfortable chaining and composing multiple HOFs together for more powerful solutions.</li> <li>Understand the inner workings: Think about closures, scope, and how HOFs allow you to abstract behavior in clean and reusable ways.</li> </ul> <p>These questions will help you deepen your understanding of higher-order functions in JavaScript and improve your ability to use them in real-world scenarios!</p> <p></p> <p></p>"},{"location":"frontend/js/httprequest/cancellation-mechanisms/","title":"Cancellation Mechanisms","text":"<p>The AbortController in JavaScript is part of the modern Web APIs, specifically introduced to help manage and control asynchronous operations, particularly when dealing with tasks that may need to be <code>cancelled</code> or <code>terminated</code>.</p>"},{"location":"frontend/js/httprequest/cancellation-mechanisms/#most-used-cancellation-mechanisms","title":"Most used <code>cancellation mechanisms</code>","text":"<p>In React applications, handling asynchronous operations and cancellations is crucial for preventing memory leaks, avoiding unnecessary API calls, and improving user experience. When working with <code>axios</code> for HTTP requests, several cancellation mechanisms are commonly used. </p> <p>Here\u2019s a breakdown of the most commonly used approaches:</p> <ol> <li> <p>Axios Cancellation Token</p> <p><code>axios</code> provides built-in support for request cancellation via a cancellation token. This mechanism is straightforward and effective for handling cancellations in a React environment.</p> Basic Example <pre><code>import axios from 'axios';\nimport { useEffect, useState } from 'react';\n\nconst MyComponent = () =&gt; {\n    const [data, setData] = useState(null);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n\n    useEffect(() =&gt; {\n        // Create a CancelToken source\n        const source = axios.CancelToken.source();\n\n        const fetchData = async () =&gt; {\n            try {\n                const response = await axios.get('https://api.example.com/data', {\n                    cancelToken: source.token\n                });\n                setData(response.data);\n            } catch (err) {\n                if (axios.isCancel(err)) {\n                    console.log('Request canceled', err.message);\n                } else {\n                    setError(err);\n                }\n            } finally {\n                setLoading(false);\n            }\n        };\n\n        fetchData();\n\n        // Cleanup function to cancel the request\n        return () =&gt; {\n            source.cancel('Operation canceled by the user.');\n        };\n    }, []);\n\n    if (loading) return &lt;p&gt;Loading...&lt;/p&gt;;\n    if (error) return &lt;p&gt;Error: {error.message}&lt;/p&gt;;\n\n    return &lt;div&gt;Data: {JSON.stringify(data)}&lt;/div&gt;;\n};\n\nexport default MyComponent;\n</code></pre> </li> <li> <p><code>AbortController</code> with Fetch API</p> <p>While <code>axios</code> has its own cancellation mechanism, you might sometimes use the <code>Fetch</code> API with <code>AbortController</code> for cancellation. This approach can be used when you're not specifically using <code>axios</code> but need to handle fetch requests.</p> Basic Example <pre><code>import { useEffect, useState } from 'react';\n\nconst MyComponent = () =&gt; {\nconst [data, setData] = useState(null);\nconst [loading, setLoading] = useState(true);\nconst [error, setError] = useState(null);\n\nuseEffect(() =&gt; {\n    const controller = new AbortController();\n    const { signal } = controller;\n\n    const fetchData = async () =&gt; {\n        try {\n            const response = await fetch('https://api.example.com/data', { signal });\n            if (!response.ok) {\n                throw new Error('Network response was not ok');\n            }\n            const result = await response.json();\n            setData(result);\n        } catch (err) {\n            if (err.name === 'AbortError') {\n                console.log('Fetch aborted');\n            } else {\n                setError(err);\n            }\n        } finally {\n            setLoading(false);\n        }\n    };\n\n    fetchData();\n\n    return () =&gt; {\n        controller.abort();\n    };\n}, []);\n\nif (loading) return &lt;p&gt;Loading...&lt;/p&gt;;\nif (error) return &lt;p&gt;Error: {error.message}&lt;/p&gt;;\n\nreturn &lt;div&gt;Data: {JSON.stringify(data)}&lt;/div&gt;;\n};\n\nexport default MyComponent;\n</code></pre> </li> <li> <p>Using <code>react-query</code></p> <p><code>react-query</code> is a popular library for managing server state in React applications. It includes built-in support for request cancellation, caching, and other advanced features. It is particularly useful for managing asynchronous data fetching in a more declarative way.</p> Basic Example <pre><code>import { useQuery } from 'react-query';\nimport axios from 'axios';\n\nconst fetchData = async () =&gt; {\n    const response = await axios.get('https://api.example.com/data');\n    return response.data;\n};\n\nconst MyComponent = () =&gt; {\n    const { data, error, isLoading } = useQuery('fetchData', fetchData);\n\n    if (isLoading) return &lt;p&gt;Loading...&lt;/p&gt;;\n    if (error) return &lt;p&gt;Error: {error.message}&lt;/p&gt;;\n    return &lt;div&gt;Data: {JSON.stringify(data)}&lt;/div&gt;;\n};\n\nexport default MyComponent;\n</code></pre> </li> <li> <p>Using Libraries for Cancellations</p> <p>Libraries such as <code>axios-cancel</code> provide additional features for handling cancellations and other advanced patterns. These libraries can be integrated with <code>axios</code> for more control over cancellation.</p> </li> </ol> Summary <ul> <li>Axios Cancellation Token: Directly supported by <code>axios</code>, easy to implement and widely used.</li> <li>AbortController with Fetch API: Useful for native fetch requests, provides a standard way to handle cancellations.</li> <li>react-query: Offers advanced features for data fetching, caching, and cancellation with built-in support for request management.</li> <li>Additional Libraries: Provide enhanced features and patterns for managing cancellations and asynchronous operations.</li> </ul> <p>In a real-world React application, the choice of cancellation mechanism often depends on the libraries and tools in use, as well as the specific requirements of the project.</p>"},{"location":"frontend/js/httprequest/cancellation-mechanisms/#categorized","title":"categorized","text":"<p>Certainly! Here's a categorized overview of the important concepts related to asynchronous operations in JavaScript:</p>"},{"location":"frontend/js/httprequest/cancellation-mechanisms/#1-basic-asynchronous-handling","title":"1. Basic Asynchronous Handling","text":"<ul> <li> <p>Callbacks</p> <ul> <li>Definition: Functions passed as arguments to other functions, executed after the first function completes.</li> <li>Example: <code>setTimeout(callback, delay)</code></li> </ul> </li> <li> <p>Promises</p> <ul> <li>Definition: Objects representing the eventual completion or failure of an asynchronous operation.</li> <li>Methods: <code>.then()</code>, <code>.catch()</code>, <code>.finally()</code></li> <li>Example: <code>new Promise((resolve, reject) =&gt; {...})</code></li> </ul> </li> <li> <p>Async/Await</p> <ul> <li>Definition: Syntax for working with promises that makes asynchronous code look synchronous.</li> <li>Keywords: <code>async</code>, <code>await</code></li> <li>Example: <code>async function fetchData() {...}</code></li> </ul> </li> </ul>"},{"location":"frontend/js/httprequest/cancellation-mechanisms/#2-cancellation-mechanisms","title":"2. Cancellation Mechanisms","text":"<ul> <li> <p>AbortController</p> <ul> <li>Definition: Allows you to abort ongoing asynchronous operations.</li> <li>Usage: Provides an <code>AbortSignal</code> to communicate cancellation.</li> <li>Example: <code>fetch(url, { signal: controller.signal })</code></li> </ul> </li> <li> <p>Custom Cancellation Logic</p> <ul> <li>Definition: Implementing your own cancellation mechanism, often using flags.</li> <li>Example: Using a flag variable to signal cancellation.</li> </ul> </li> </ul>"},{"location":"frontend/js/httprequest/cancellation-mechanisms/#3-timing-and-scheduling","title":"3. Timing and Scheduling","text":"<ul> <li> <p>setTimeout / setInterval</p> <ul> <li>Definition: Schedule tasks to execute after a delay or at regular intervals.</li> <li>Methods: <code>setTimeout(callback, delay), setInterval(callback, interval)</code></li> <li>Example: <code>setTimeout(() =&gt; {...}, 1000)</code></li> </ul> </li> </ul>"},{"location":"frontend/js/httprequest/cancellation-mechanisms/#4-background-processing","title":"4. Background Processing","text":"<ul> <li> <p>Web Workers</p> <ul> <li>Definition: Allow scripts to run in background threads, enabling concurrent execution.</li> <li>Usage: Separate scripts for worker logic.</li> <li>Example: <code>new Worker('worker.js')</code></li> </ul> </li> </ul>"},{"location":"frontend/js/httprequest/cancellation-mechanisms/#5-promise-combinators","title":"5. Promise Combinators","text":"<ul> <li> <p>Promise.all</p> <ul> <li>Definition: Waits for all promises to be fulfilled or any to be rejected.</li> <li>Example: <code>Promise.all([promise1, promise2])</code></li> </ul> </li> <li> <p>Promise.any</p> <ul> <li>Definition: Waits for any promise to be fulfilled, ignoring rejections.</li> <li>Example: <code>Promise.any([promise1, promise2])</code></li> </ul> </li> <li> <p>Promise.race</p> <ul> <li>Definition: Returns the result of the first promise that resolves or rejects.</li> <li>Example: <code>Promise.race([promise1, promise2])</code></li> </ul> </li> <li> <p>Promise.allSettled</p> <ul> <li>Definition: Waits for all promises to be settled (fulfilled or rejected) and returns their results.</li> <li>Example: <code>Promise.allSettled([promise1, promise2])</code></li> </ul> </li> </ul>"},{"location":"frontend/js/httprequest/cancellation-mechanisms/#6-execution-management","title":"6. Execution Management","text":"<ul> <li> <p>Event Loop</p> <ul> <li>Definition: Manages the execution of code, handling asynchronous operations and callbacks.</li> <li>Function: Processes the call stack and handles tasks in the callbacks queue.</li> </ul> </li> <li> <p>Callbacks Queue</p> <ul> <li>Definition: A queue where functions to be executed are placed, managed by the event loop.</li> </ul> </li> </ul> Summary <p>Here\u2019s a quick reference categorization:</p> <p>Basic Asynchronous Handling:</p> <ul> <li>Callbacks</li> <li>Promises</li> <li>Async/Await</li> </ul> <p>Cancellation Mechanisms:</p> <ul> <li>AbortController</li> <li>Custom Cancellation Logic</li> </ul> <p>Timing and Scheduling:</p> <ul> <li>setTimeout / setInterval</li> </ul> <p>Background Processing:</p> <ul> <li>Web Workers</li> </ul> <p>Promise Combinators:</p> <ul> <li>Promise.all</li> <li>Promise.any</li> <li>Promise.race</li> <li>Promise.allSettled</li> </ul> <p>Execution Management:</p> <ul> <li>Event Loop</li> <li>Callbacks Queue</li> </ul> <p>By categorizing these concepts, you can more easily remember and apply them in different scenarios when dealing with asynchronous operations in JavaScript.</p> <pre><code>Practical Applications and Patterns\n\n    Common Patterns for Asynchronous Code\n        Error Handling Strategies\n        Avoiding Callback Hell\n        Optimizing Performance with Asynchronous Code\n\nAdvanced Topics and Libraries\n\n    Cancelable Promises\n    Using Third-Party Libraries for Asynchronous Operations\n        Libraries like `axios`, `bluebird`, or `async.js`\n\nSummary and Best Practices\n\n    Review of Key Concepts\n    Best Practices for Writing Asynchronous Code\n    Performance Considerations\n</code></pre>"},{"location":"frontend/js/httprequest/cancellation-mechanisms/#debugging-or-logging","title":"Debugging or Logging","text":"BasicAdvanced <pre><code>useEffect(() =&gt; {\n    console.log('useEffect triggered at', new Date().toISOString()); // Log when useEffect is triggered\n    const controller = new AbortController();\n    const signal = controller.signal;\n\n    const API_URL = process.env.REACT_APP_API_URL;\n    const API_KEY = process.env.REACT_APP_API_KEY;\n\n    console.log('Starting fetch at', new Date().toISOString()); // Log fetch start time\n    fetchData(API_URL, API_KEY, signal);\n\n    return () =&gt; {\n        console.log('Cleaning up at', new Date().toISOString()); // Log cleanup time\n        controller.abort();\n    };\n}, []);\n</code></pre> <pre><code>const fetchData = async (url, apiKey, signal) =&gt; {\n    console.log('Starting fetch request at', new Date().toISOString()); // Log fetch start\n\n    try {\n        const response = await fetch(url, {\n            method: 'GET',\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Api-Key ${apiKey}`,\n            },\n            signal, // Pass the signal to fetch\n        });\n\n        if (!response.ok) {\n            throw new Error('Network response was not ok');\n        }\n        const data = await response.json();\n        console.log('Fetch successful at', new Date().toISOString()); // Log success\n        setData(data);\n    } catch (error) {\n        if (error.name === 'AbortError') {\n            console.log('Fetch request was aborted at', new Date().toISOString()); // Log abort\n        } else {\n            setError(error);\n        }\n    } finally {\n        setLoading(false);\n    }\n};\n</code></pre>"},{"location":"frontend/js/httprequest/cancellation-mechanisms/#diagnostic-steps","title":"Diagnostic Steps","text":"<pre><code>import React, { useEffect, useState } from 'react';\n\nconst YourComponent = () =&gt; {\n    const [data, setData] = useState(null);\n    const [error, setError] = useState(null);\n    const [loading, setLoading] = useState(true);\n\n    const fetchData = async (url, apiKey, signal) =&gt; {\n        console.log('Starting fetch...'); // Debug log\n        try {\n            const response = await fetch(url, {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Api-Key ${apiKey}`,\n                },\n                signal, // Pass the signal to fetch\n            });\n\n            if (!response.ok) {\n                throw new Error('Network response was not ok');\n            }\n            const data = await response.json();\n            setData(data);\n        } catch (error) {\n            if (error.name === 'AbortError') {\n                console.log('Fetch request was aborted');\n            } else {\n                setError(error);\n            }\n        } finally {\n            setLoading(false);\n        }\n    };\n\n    useEffect(() =&gt; {\n        console.log('useEffect triggered'); // Debug log\n        const controller = new AbortController(); // Create a new AbortController\n        const signal = controller.signal;\n\n        const API_URL = process.env.REACT_APP_API_URL;\n        const API_KEY = process.env.REACT_APP_API_KEY;\n\n        fetchData(API_URL, API_KEY, signal);\n\n        // Cleanup function to abort the request if the component unmounts\n        return () =&gt; {\n            console.log('Cleaning up...'); // Debug log\n            controller.abort();\n        };\n    }, []); // Empty dependency array means this effect runs once when the component mounts\n\n    return (\n        &lt;div&gt;\n            {loading &amp;&amp; &lt;p&gt;Loading...&lt;/p&gt;}\n            {error &amp;&amp; &lt;p&gt;Error: {error.message}&lt;/p&gt;}\n            {data &amp;&amp; &lt;div&gt;{/* Render your data here */}&lt;/div&gt;}\n        &lt;/div&gt;\n    );\n};\n\nexport default YourComponent;\n</code></pre>"},{"location":"frontend/js/httprequest/intro/","title":"Intro","text":""},{"location":"frontend/js/httprequest/intro/#intro","title":"Intro","text":"<p>Here's a list of popular React fetching libraries along with brief descriptions and example usage for each:</p>"},{"location":"frontend/js/httprequest/intro/#1-fetch-api","title":"1. Fetch API","text":"<p>The native way to make HTTP requests in JavaScript.</p> <pre><code>useEffect(() =&gt; {\n  fetch('https://api.example.com/data')\n    .then(response =&gt; response.json())\n    .then(data =&gt; console.log(data))\n    .catch(error =&gt; console.error('Error:', error));\n}, []);\n</code></pre>"},{"location":"frontend/js/httprequest/intro/#2-axios","title":"2. Axios","text":"<p>A promise-based HTTP client for the browser and Node.js.</p> <pre><code>import axios from 'axios';\n\nuseEffect(() =&gt; {\n  axios.get('https://api.example.com/data')\n    .then(response =&gt; console.log(response.data))\n    .catch(error =&gt; console.error('Error:', error));\n}, []);\n</code></pre>"},{"location":"frontend/js/httprequest/intro/#3-superagent","title":"3. SuperAgent","text":"<p>A small, progressive HTTP request library.</p> <pre><code>import superagent from 'superagent';\n\nuseEffect(() =&gt; {\n  superagent.get('https://api.example.com/data')\n    .then(response =&gt; console.log(response.body))\n    .catch(error =&gt; console.error('Error:', error));\n}, []);\n</code></pre>"},{"location":"frontend/js/httprequest/intro/#4-swr","title":"4. SWR","text":"<p>A React Hooks library for remote data fetching developed by Vercel.</p> <pre><code>import useSWR from 'swr';\n\nconst fetcher = url =&gt; fetch(url).then(res =&gt; res.json());\n\nfunction Component() {\n  const { data, error } = useSWR('https://api.example.com/data', fetcher);\n\n  if (error) return &lt;div&gt;Error loading data&lt;/div&gt;;\n  if (!data) return &lt;div&gt;Loading...&lt;/div&gt;;\n\n  return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n</code></pre>"},{"location":"frontend/js/httprequest/intro/#5-react-query","title":"5. React Query","text":"<p>A powerful data-fetching and state management library for React.</p> <pre><code>import { useQuery } from 'react-query';\n\nconst fetcher = async () =&gt; {\n  const response = await fetch('https://api.example.com/data');\n  return response.json();\n};\n\nfunction Component() {\n  const { data, error, isLoading } = useQuery('dataKey', fetcher);\n\n  if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;\n  if (error) return &lt;div&gt;Error loading data&lt;/div&gt;;\n\n  return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n</code></pre>"},{"location":"frontend/js/httprequest/intro/#6-apollo-client","title":"6. Apollo Client","text":"<p>A comprehensive solution for managing GraphQL data.</p> <pre><code>import { useQuery, gql } from '@apollo/client';\n\nconst GET_DATA = gql`\n  query GetData {\n    data {\n      id\n      name\n    }\n  }\n`;\n\nfunction Component() {\n  const { data, loading, error } = useQuery(GET_DATA);\n\n  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n  if (error) return &lt;div&gt;Error loading data&lt;/div&gt;;\n\n  return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n</code></pre>"},{"location":"frontend/js/httprequest/intro/#7-relay","title":"7. Relay","text":"<p>A JavaScript framework for building data-driven React applications using GraphQL.</p> <pre><code>import {\n  RelayEnvironmentProvider,\n  loadQuery,\n  usePreloadedQuery,\n  graphql,\n} from 'react-relay/hooks';\nimport RelayEnvironment from './RelayEnvironment';\n\nconst { PreloadedQuery, PreloadableQuery } = loadQuery(\n  RelayEnvironment,\n  graphql`\n    query AppQuery {\n      viewer {\n        name\n      }\n    }\n  `\n);\n\nfunction Component(props) {\n  const data = usePreloadedQuery(PreloadableQuery, props.preloadedQuery);\n  return &lt;div&gt;{data.viewer.name}&lt;/div&gt;;\n}\n\nfunction App() {\n  return (\n    &lt;RelayEnvironmentProvider environment={RelayEnvironment}&gt;\n      &lt;Component preloadedQuery={PreloadedQuery} /&gt;\n    &lt;/RelayEnvironmentProvider&gt;\n  );\n}\n</code></pre>"},{"location":"frontend/js/httprequest/intro/#8-urql","title":"8. Urql","text":"<p>A highly customizable and versatile GraphQL client for React.</p> <pre><code>import { createClient, Provider, useQuery } from 'urql';\n\nconst client = createClient({\n  url: 'https://api.example.com/graphql',\n});\n\nconst GET_DATA = `\n  query {\n    data {\n      id\n      name\n    }\n  }\n`;\n\nfunction Component() {\n  const [result] = useQuery({ query: GET_DATA });\n  const { data, fetching, error } = result;\n\n  if (fetching) return &lt;div&gt;Loading...&lt;/div&gt;;\n  if (error) return &lt;div&gt;Error loading data&lt;/div&gt;;\n\n  return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n\nfunction App() {\n  return (\n    &lt;Provider value={client}&gt;\n      &lt;Component /&gt;\n    &lt;/Provider&gt;\n  );\n}\n</code></pre> <p>These libraries cover a range of use cases from basic HTTP requests to advanced GraphQL queries, allowing you to choose the one that best fits your project's needs.</p> Tips <ol> <li> <p>JavaScript Fundamentals</p> <ul> <li>Promises and Async/Await: Understanding how promises work and how to use async/await syntax for handling asynchronous code is crucial.</li> <li>Error Handling: Knowing how to handle errors properly in asynchronous code.</li> </ul> </li> <li> <p>Data Fetching</p> <ul> <li>Fetch API: Basic understanding of the native Fetch API as a starting point.</li> <li>Axios: Learning how to use Axios for more advanced use cases.</li> </ul> </li> <li> <p>Error Handling</p> <ul> <li>Properly handle errors in data fetching.</li> <li>Display appropriate error messages to users.</li> </ul> </li> </ol>"},{"location":"frontend/js/httprequest/intro/#setup-and-installation","title":"Setup and Installation:","text":"<ol> <li> <p>Practical Steps to Get Started</p> <ul> <li>Install the chosen library using npm or yarn.</li> </ul> <pre><code>npm install axios\nnpm install swr\nnpm install @apollo/client graphql\nnpm install react-query\n</code></pre> </li> <li> <p>Basic Fetching:</p> <ul> <li>Write a simple data-fetching component.</li> </ul> <pre><code>import axios from 'axios';\nimport { useEffect, useState } from 'react';\n\nfunction DataFetchingComponent() {\nconst [data, setData] = useState(null);\n\nuseEffect(() =&gt; {\n    axios.get('https://api.example.com/data')\n    .then(response =&gt; setData(response.data))\n    .catch(error =&gt; console.error(error));\n}, []);\n\nif (!data) return &lt;div&gt;Loading...&lt;/div&gt;;\n\nreturn &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n</code></pre> </li> <li> <p>Error Handling:</p> <ul> <li>Implement proper error handling.</li> </ul> <pre><code>useEffect(() =&gt; {\naxios.get('https://api.example.com/data')\n    .then(response =&gt; setData(response.data))\n    .catch(error =&gt; {\n    console.error(error);\n    setError('Failed to fetch data');\n    });\n}, []);\n</code></pre> </li> <li> <p>Using Hooks:</p> <ul> <li>For libraries like SWR or React Query, understand and use their custom hooks.</li> </ul> <pre><code>import useSWR from 'swr';\nconst fetcher = url =&gt; fetch(url).then(res =&gt; res.json());\n\nfunction DataFetchingComponent() {\nconst { data, error } = useSWR('https://api.example.com/data', fetcher);\n\nif (error) return &lt;div&gt;Error loading data&lt;/div&gt;;\nif (!data) return &lt;div&gt;Loading...&lt;/div&gt;;\n\nreturn &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n</code></pre> </li> <li> <p>Advanced Usage:</p> <ul> <li>Explore more advanced features such as pagination, caching, and optimistic updates provided by libraries like React Query and SWR.</li> </ul> </li> </ol> <p>By understanding these core concepts and gradually building upon them, you will be well-prepared to effectively use any data-fetching library in React.</p> <p>In JavaScript, there are several traditional ways to fetch API data, including:</p>"},{"location":"frontend/js/httprequest/intro/#traditional-methods-in-javascript","title":"Traditional Methods in JavaScript:","text":"<ol> <li> <p>XMLHttpRequest:</p> <pre><code>var xhr = new XMLHttpRequest();\nxhr.open('GET', 'https://api.example.com/data', true);\nxhr.onload = function () {\n    if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) {\n        console.log(JSON.parse(xhr.responseText));\n    } else {\n        console.error('Request failed');\n    }\n};\nxhr.send();\n</code></pre> </li> <li> <p>Fetch API:</p> <pre><code>fetch('https://api.example.com/data')\n.then(response =&gt; response.json())\n.then(data =&gt; console.log(data))\n.catch(error =&gt; console.error('Error:', error));\n</code></pre> </li> <li> <p>Async/Await with Fetch API:</p> <pre><code>async function fetchData() {\n    try {\n        const response = await fetch('https://api.example.com/data');\n        const data = await response.json();\n        console.log(data);\n    } catch (error) {\n        console.error('Error:', error);\n    }\n}\nfetchData();\n</code></pre> </li> </ol>"},{"location":"frontend/js/httprequest/intro/#packages-in-react-to-fetch-api-data","title":"Packages in React to Fetch API Data:","text":"<ol> <li> <p>Axios:</p> <pre><code>import axios from 'axios';\n\naxios.get('https://api.example.com/data')\n    .then(response =&gt; console.log(response.data))\n    .catch(error =&gt; console.error('Error:', error));\n</code></pre> <p>Using Axios with async/await:</p> <pre><code>import axios from 'axios';\n\nasync function fetchData() {\n    try {\n        const response = await axios.get('https://api.example.com/data');\n        console.log(response.data);\n    } catch (error) {\n        console.error('Error:', error);\n    }\n}\nfetchData();\n</code></pre> </li> <li> <p>React Query:</p> <pre><code>import { useQuery } from 'react-query';\n\nfunction MyComponent() {\n    const { isLoading, error, data } = useQuery('fetchData', () =&gt;\n        fetch('https://api.example.com/data').then(res =&gt; res.json())\n    );\n\n    if (isLoading) return 'Loading...';\n    if (error) return 'An error has occurred: ' + error.message;\n\n    return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n</code></pre> </li> <li> <p>SWR (stale-while-revalidate):</p> <pre><code>import useSWR from 'swr';\n\nconst fetcher = url =&gt; fetch(url).then(res =&gt; res.json());\n\nfunction MyComponent() {\n    const { data, error } = useSWR('https://api.example.com/data', fetcher);\n\n    if (error) return &lt;div&gt;Failed to load&lt;/div&gt;;\n    if (!data) return &lt;div&gt;Loading...&lt;/div&gt;;\n\n    return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n</code></pre> </li> <li> <p>useEffect with Fetch API:</p> <pre><code>import { useEffect, useState } from 'react';\n\nfunction MyComponent() {\n    const [data, setData] = useState(null);\n    const [isLoading, setIsLoading] = useState(true);\n    const [error, setError] = useState(null);\n\n    useEffect(() =&gt; {\n        fetch('https://api.example.com/data')\n            .then(response =&gt; response.json())\n            .then(data =&gt; {\n                setData(data);\n                setIsLoading(false);\n            })\n            .catch(error =&gt; {\n                setError(error);\n                setIsLoading(false);\n            });\n    }, []);\n\n    if (isLoading) return 'Loading...';\n    if (error) return 'An error has occurred: ' + error.message;\n\n    return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n</code></pre> </li> </ol> <p>These methods and packages cover a range of use cases and preferences for fetching API data in JavaScript and React applications.</p>"},{"location":"frontend/js/httprequest/core/api-response-object/","title":"Response Object","text":"when we fetch the api endpoint, the reponse data is in which format do we get? object or string <p>When you fetch data from an API endpoint, the response data is typically received as a <code>string</code>. This string needs to be parsed into an object to be usable within your application.</p> Is the json response format is <code>object</code> or <code>string</code> ? <p>When you receive a JSON response from an API, the data is initially received as a string. This string represents the JSON data. To work with this data as a JavaScript object, you need to parse the JSON string into an object.</p> <p>Here's a detailed explanation:</p> so what is the difference between <code>.json()</code> method and <code>JSON.parse</code> when to use. is it the same <p>The <code>.json()</code> method and <code>JSON.parse()</code> serve similar purposes but are used in different contexts. Here's a breakdown of the differences and when to use each:</p> <code>.json()</code> MethodJSON.parse()Key Differences <ul> <li>Context: Used with the <code>fetch</code> API to read and parse the response body as JSON.</li> <li>Functionality: The <code>.json()</code> method is called on a Response object. It reads the response stream to completion and parses it as JSON.</li> <li>Return Value: Returns a promise that resolves with the result of parsing the response body text as JSON.</li> <li>Usage: Use <code>.json()</code> when dealing with the response from a fetch request.</li> </ul>"},{"location":"frontend/js/httprequest/core/api-response-object/#fetching-api-data-in-javascript","title":"Fetching API Data in JavaScript","text":"<p>When using the <code>fetch</code> API in JavaScript, the response is received as a raw stream of data, which is then processed into a string and parsed as needed. Here's the process:</p> <ol> <li>Fetching the Data:</li> </ol> javascript<pre><code>fetch('https://api.example.com/data')\n.then(response =&gt; response.json())  // Parses the response as JSON\n.then(data =&gt; {\n    console.log(data);  // The data is now a JavaScript object\n})\n.catch(error =&gt; console.error('Error:', error));\n</code></pre> <p>In this example, the <code>response.json()</code> method is called on the response object. This method reads the response stream to completion and parses it as JSON. The result is a JavaScript object.</p> Response Data Formats <ol> <li> <p>JSON (Most Common)</p> <ul> <li>Received as: String</li> <li>Parsed to: JavaScript object</li> <li>Example:</li> </ul> <pre><code>fetch('https://api.example.com/data')\n.then(response =&gt; response.json())  // Converts JSON string to JavaScript object\n.then(data =&gt; {\n    console.log(data);\n});\n</code></pre> </li> <li> <p>Text</p> <ul> <li>Received as: String</li> <li>Example:</li> </ul> <pre><code>fetch('https://api.example.com/text')\n.then(response =&gt; response.text())  // Reads response as plain text\n.then(data =&gt; {\n    console.log(data);\n});\n</code></pre> </li> <li> <p>Blob (Binary Large Object)</p> <ul> <li>Received as: Binary data</li> <li>Example:</li> </ul> <pre><code>fetch('https://api.example.com/image')\n.then(response =&gt; response.blob())  // Reads response as binary data (Blob)\n.then(blob =&gt; {\n    console.log(blob);\n});\n</code></pre> </li> <li> <p>FormData</p> <ul> <li>Received as: Form data</li> <li>Example:</li> </ul> <pre><code>fetch('https://api.example.com/formdata')\n.then(response =&gt; response.formData())  // Reads response as FormData\n.then(formData =&gt; {\n    console.log(formData);\n});\n</code></pre> </li> <li> <p>ArrayBuffer</p> <ul> <li>Received as: Binary data</li> <li>Example:</li> </ul> <pre><code>fetch('https://api.example.com/binary')\n.then(response =&gt; response.arrayBuffer())  // Reads response as ArrayBuffer\n.then(buffer =&gt; {\n    console.log(buffer);\n});\n</code></pre> </li> </ol>"},{"location":"frontend/js/httprequest/core/api-response-object/#summary","title":"Summary","text":"<p>When fetching data from an API endpoint, the response is initially received as a string or binary data. For JSON responses, which are most common, the string is parsed into a JavaScript object using the <code>response.json()</code> method. Other methods like <code>response.text()</code>, <code>response.blob()</code>, <code>response.formData()</code>, and <code>response.arrayBuffer()</code> are used to handle different types of response data. The parsed data can then be used within your application as needed.</p>"},{"location":"frontend/js/httprequest/core/api-response-object/#process-of-fetching-and-parsing-json-data","title":"Process of Fetching and Parsing JSON Data","text":"<ol> <li> <p>Fetching the Data:</p> <p>When you use the fetch API to make a request, the response body is a readable stream. This stream needs to be read to obtain the actual data.</p> </li> <li> <p>Response as JSON:</p> <p>The <code>response.json()</code> method reads the response stream to completion and parses the text as JSON. This method returns a promise that resolves with the result of parsing the body text as JSON.</p> </li> </ol>"},{"location":"frontend/js/httprequest/core/api-response-object/#example-in-javascript","title":"Example in JavaScript","text":"<ol> <li> <p>Fetching and Parsing JSON Data:</p> javascript<pre><code>fetch('https://api.example.com/data')\n.then(response =&gt; response.json())  // Parses the response text as JSON\n.then(data =&gt; {\n    console.log(data);  // 'data' is now a JavaScript object\n})\n.catch(error =&gt; console.error('Error:', error));\n</code></pre> </li> </ol> <p>In this example:</p> <ul> <li><code>fetch('https://api.example.com/data')</code> sends a request to the API.</li> <li><code>response.json()</code> reads the response stream and parses it as JSON, converting it from a string to a JavaScript object.</li> <li>The resulting data is a JavaScript object that can be used in your code.</li> </ul>"},{"location":"frontend/js/httprequest/core/api-response-object/#clarification-on-json-response","title":"Clarification on JSON Response","text":"<ul> <li>Initial Format: When the JSON response is received from the API, it is in string format.</li> <li>After Parsing: The JSON string is parsed into a JavaScript object using response.json().</li> </ul>"},{"location":"frontend/js/httprequest/core/api-response-object/#example-of-json-response","title":"Example of JSON Response","text":"<ol> <li> <p>Raw JSON Response (String):</p> json<pre><code>{\n    \"name\": \"Alice\",\n    \"age\": 30,\n    \"isMember\": true\n}\n</code></pre> </li> <li> <p>Parsed JavaScript Object:</p> javascript<pre><code>{\n    name: \"Alice\",\n    age: 30,\n    isMember: true\n}\n</code></pre> </li> </ol> <ul> <li>Context: Used to parse a JSON string into a JavaScript object.</li> <li>Functionality: <code>JSON.parse()</code> takes a JSON string and parses it to produce a JavaScript object.</li> <li>Return Value: Returns a JavaScript object.</li> <li>Usage: Use <code>JSON.parse()</code> when you have a JSON string (e.g., stored in a variable) and need to convert it to a JavaScript object.</li> </ul> javascript<pre><code>let jsonString = '{\"name\": \"Alice\", \"age\": 30, \"isMember\": true}';\nlet data = JSON.parse(jsonString);  // Parses JSON string into JavaScript object\nconsole.log(data.name);  // Output: Alice\n</code></pre> <ol> <li> <p>Source of Data:</p> <ul> <li><code>.json()</code>: Used directly on the Response object returned by the fetch API to handle the response stream.</li> <li><code>JSON.parse()</code>: Used on a JSON string that you already have (e.g., from a variable, local storage, etc.).</li> </ul> </li> <li> <p>Return Type:</p> <ul> <li><code>.json()</code>: Returns a promise that resolves with the parsed JavaScript object.</li> <li><code>JSON.parse()</code>: Directly returns the parsed JavaScript object.</li> </ul> </li> <li> <p>Common Usage:</p> <ul> <li><code>.json()</code>: Commonly used in asynchronous operations involving fetching data from APIs.</li> <li><code>JSON.parse()</code>: Used whenever you have a JSON string and need to convert it to a JavaScript object, irrespective of how you obtained the string.</li> </ul> </li> </ol>"},{"location":"frontend/js/httprequest/core/api-response-object/#summary_1","title":"Summary","text":"<p>While JSON responses from an API are initially received as strings, they are typically parsed into JavaScript objects using methods like <code>response.json()</code>. This parsing process is necessary to convert the string representation of the JSON data into a format (JavaScript object) that can be easily manipulated in your code.</p>"},{"location":"frontend/js/httprequest/core/api-response-object/#example","title":"Example","text":"JavaScript<pre><code>fetch('https://api.example.com/data')\n.then(response =&gt; response.json())  // Reads and parses response body as JSON\n.then(data =&gt; {\n    console.log(data);  // 'data' is now a JavaScript object\n})\n.catch(error =&gt; console.error('Error:', error));\n</code></pre>"},{"location":"frontend/js/httprequest/core/api-response-object/#summary_2","title":"Summary","text":"<ul> <li>Use <code>.json()</code>: When handling responses from fetch API requests to read and parse the JSON response.</li> <li>Use <code>JSON.parse()</code>: When you have a JSON string and need to convert it to a JavaScript object in other contexts.</li> </ul> <p>Both methods are essential for working with JSON data, but they are applied in different scenarios to achieve similar results: converting JSON-formatted data into JavaScript objects.</p>"},{"location":"frontend/js/httprequest/core/api-response-object/#what-is-reponse-api-object","title":"what is reponse API object","text":"<p>The Response object in the Fetch API represents the response to a request. It contains information about the response, including the status code, status text, headers, and the body of the response. This object is returned as a promise when a fetch request is made.</p> <p>Key Properties and Methods of the Response Object</p> PropertiesMethodsExampleExplanation <ul> <li>type: Indicates the type of the response (e.g., \"basic\", \"cors\", \"error\", \"opaque\").</li> <li>url: The URL of the response.</li> <li>redirected: Indicates whether the response is the result of a redirect.</li> <li>status: The status code of the response (e.g., 200 for a successful request).</li> <li>statusText: The status message corresponding to the status code (e.g., \"OK\" for status 200).</li> <li>ok: A boolean indicating whether the response was successful (status in the range 200-299).</li> <li>headers: The <code>Headers</code> object associated with the response.</li> <li>body: A <code>ReadableStream</code> of the body contents.</li> <li>bodyUsed: A boolean indicating whether the body has been read.</li> </ul> <ul> <li>arrayBuffer(): Reads the response body and returns it as a promise that resolves with an ArrayBuffer.</li> <li>blob(): Reads the response body and returns it as a promise that resolves with a Blob.</li> <li>formData(): Reads the response body and returns it as a promise that resolves with FormData.</li> <li>json(): Reads the response body and parses it as JSON, returning a promise that resolves with a JavaScript object.</li> <li>text(): Reads the response body and returns it as a promise that resolves with a string.</li> </ul> javascript<pre><code>fetch('https://api.example.com/data')\n.then(response =&gt; {\n    // Check if the request was successful\n    if (!response.ok) {\n    throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    // Access response properties\n    console.log(response.status);      // e.g., 200\n    console.log(response.statusText);  // e.g., \"OK\"\n    console.log(response.headers.get('Content-Type'));  // e.g., \"application/json\"\n\n    // Read and parse the response body\n    return response.json();  // Returns a promise that resolves with the JSON-parsed body\n})\n.then(data =&gt; {\n    // 'data' is now a JavaScript object\n    console.log(data);\n})\n.catch(error =&gt; {\n    console.error('Fetch error:', error);\n});\n</code></pre> <ol> <li><code>fetch('https://api.example.com/data')</code>: Initiates a request to the specified URL and returns a promise that resolves to a Response object.</li> <li><code>response.ok</code>: Checks if the response status code indicates a successful request.</li> <li><code>response.status</code>: Accesses the status code of the response.</li> <li><code>response.statusText</code>: Accesses the status text of the response.</li> <li><code>response.headers.get('Content-Type')</code>: Accesses the Content-Type header of the response.</li> <li><code>response.json()</code>: Reads and parses the response body as JSON, returning a promise that resolves to a JavaScript object.</li> <li>Handling the parsed data: The parsed JSON data is logged to the console.</li> <li>Error handling: Catches and logs any errors that occur during the fetch or parsing process.</li> </ol>"},{"location":"frontend/js/httprequest/core/api-response-object/#summary_3","title":"Summary","text":"<p>The Response object in the Fetch API encapsulates the response to a request, providing access to the status, headers, and body of the response. You use various methods like <code>.json()</code>, <code>.text()</code>, and others to read and parse the response body, converting it into a usable format such as a JavaScript object or string. This process is essential for working with API responses in web development.</p>"},{"location":"frontend/js/httprequest/core/axios/","title":"Axios","text":""},{"location":"frontend/js/httprequest/core/axios/#mastering-axios","title":"Mastering Axios","text":""},{"location":"frontend/js/httprequest/core/axios/#1-understanding-the-basics","title":"1. Understanding the Basics","text":"<ul> <li> <p>What is Axios?</p> <p>Axios is a promise-based HTTP client for the browser and Node.js. It provides a more feature-rich and flexible way to handle HTTP requests compared to Fetch API.</p> </li> <li> <p>Basic Syntax:</p> <pre><code>axios.get(url, config)\n    .then(response =&gt; console.log(response.data))\n    .catch(error =&gt; console.error('Error:', error));\n</code></pre> </li> <li> <p>Basic Example:</p> <pre><code>axios.get('https://api.example.com/data')\n    .then(response =&gt; console.log(response.data))\n    .catch(error =&gt; console.error('Error:', error));\n</code></pre> </li> </ul>"},{"location":"frontend/js/httprequest/core/axios/#2-handling-responses-and-errors","title":"2. Handling Responses and Errors","text":"<ul> <li> <p>Error Handling:</p> <pre><code>axios.get('https://api.example.com/data')\n    .then(response =&gt; console.log(response.data))\n    .catch(error =&gt; {\n        if (error.response) {\n            console.error('Response error:', error.response);\n        } else if (error.request) {\n            console.error('Request error:', error.request);\n        } else {\n            console.error('Error:', error.message);\n        }\n    });\n</code></pre> </li> </ul>"},{"location":"frontend/js/httprequest/core/axios/#3-making-different-types-of-requests","title":"3. Making Different Types of Requests","text":"<ul> <li> <p>GET Request:</p> <pre><code>axios.get('https://api.example.com/data')\n    .then(response =&gt; console.log(response.data));\n</code></pre> </li> <li> <p>POST Request with Body:</p> <pre><code>axios.post('https://api.example.com/data', { key: 'value' })\n    .then(response =&gt; console.log(response.data));\n</code></pre> </li> <li> <p>PUT Request:</p> <pre><code>axios.put('https://api.example.com/data/1', { key: 'new value' })\n    .then(response =&gt; console.log(response.data));\n</code></pre> </li> <li> <p>DELETE Request:</p> <pre><code>axios.delete('https://api.example.com/data/1')\n    .then(response =&gt; console.log(response.data));\n</code></pre> </li> </ul>"},{"location":"frontend/js/httprequest/core/axios/#4-advanced-features","title":"4. Advanced Features","text":"<ul> <li> <p>Request and Response Interceptors:</p> <pre><code>// Add a request interceptor\naxios.interceptors.request.use(config =&gt; {\n    console.log('Request:', config);\n    return config;\n}, error =&gt; {\n    return Promise.reject(error);\n});\n\n// Add a response interceptor\naxios.interceptors.response.use(response =&gt; {\n    console.log('Response:', response);\n    return response;\n}, error =&gt; {\n    return Promise.reject(error);\n});\n</code></pre> </li> <li> <p>Cancel Requests:</p> <pre><code>const source = axios.CancelToken.source();\n\naxios.get('https://api.example.com/data', { cancelToken: source.token })\n    .then(response =&gt; console.log(response.data))\n    .catch(error =&gt; {\n        if (axios.isCancel(error)) {\n            console.log('Request canceled:', error.message);\n        } else {\n            console.error('Axios error:', error);\n        }\n    });\n\n// To cancel the request\nsource.cancel('Operation canceled by the user.');\n</code></pre> </li> <li> <p>Concurrent Requests:</p> <pre><code>axios.all([\n    axios.get('https://api.example.com/data1'),\n    axios.get('https://api.example.com/data2')\n])\n    .then(axios.spread((response1, response2) =&gt; {\n        console.log('Response 1:', response1.data);\n        console.log('Response 2:', response2.data);\n    }));\n</code></pre> </li> </ul>"},{"location":"frontend/js/httprequest/core/axios/#practical-steps-to-master-both","title":"Practical Steps to Master Both","text":"<ol> <li>Start with Basic Examples: Implement simple GET and POST requests using both Fetch API and Axios.</li> <li>Explore Error Handling: Write code to handle various types of errors and status codes.</li> <li>Work with Different Request Methods: Practice using GET, POST, PUT, and DELETE methods.</li> <li>Dive into Advanced Features: Explore features like request/response interceptors, request cancellation, and concurrent requests.</li> <li>Build Real Projects: Apply what you've learned in real-world scenarios by building projects or contributing to open-source.</li> <li>Review and Refactor: Continuously review your code and refactor it to use best practices and make the most of the features provided by Fetch and Axios.</li> </ol> <p>By following this structured approach, you\u2019ll gain a deep understanding of both Fetch API and Axios, equipping you to use them effectively in various scenarios.</p>"},{"location":"frontend/js/httprequest/core/chaining/","title":"Chaning","text":"<p>Chaining multiple API calls sequentially can be done using <code>.then</code>, <code>async/await</code>, or directly with <code>promises</code>.</p> <p>Here\u2019s a breakdown of the differences between these approaches:</p>"},{"location":"frontend/js/httprequest/core/chaining/#1-using-then","title":"1. Using <code>.then</code>","text":"ApproachExampleExplanation <ul> <li>Sequential Chaining: Each <code>.then</code> is executed only after the previous promise has resolved.</li> <li>Error Handling: Errors are handled using <code>.catch</code> at the end of the chain or within individual .then blocks.</li> </ul> <pre><code>fetch('https://api.example.com/first')\n    .then(response1 =&gt; response1.json())\n    .then(data1 =&gt; {\n        // This code will not execute if the first request fails\n        return fetch(`https://api.example.com/second/${data1.id}`);\n    })\n    .then(response2 =&gt; response2.json())\n    .then(data2 =&gt; {\n        console.log(data2);\n    })\n    .catch(error =&gt; {\n        // This will handle errors from any of the promises in the chain\n        console.error('Error:', error);\n    });\n</code></pre> <p>Advantages:</p> <ul> <li>Readable for Simple Chains: <code>.then</code> works well for simple sequences of operations.</li> <li>Promise-Based: Explicitly shows promise handling.</li> </ul> <p>Disadvantages:</p> <ul> <li>Callback Hell: For very complex chains, nested <code>.then</code> calls can become difficult to read and manage.</li> </ul>"},{"location":"frontend/js/httprequest/core/chaining/#2-using-asyncawait","title":"2. Using <code>async/await</code>","text":"ApproachExampleExplanation <ul> <li>Sequential Execution: <code>await</code> pauses the function execution until the promise resolves, making the code look synchronous.</li> <li>Error Handling: Errors are handled using <code>try/catch</code> blocks.</li> </ul> <pre><code>async function fetchData() {\n    try {\n        const response1 = await fetch('https://api.example.com/first');\n        const data1 = await response1.json();\n\n        // This code will not execute if the first request fails\n        const response2 = await fetch(`https://api.example.com/second/${data1.id}`);\n        const data2 = await response2.json();\n\n        console.log(data2);\n    } catch (error) {\n        // This will handle errors from any of the await statements\n        console.error('Error:', error);\n    }\n}\n\nfetchData();\n</code></pre> <p>Advantages:</p> <ul> <li>Readability: Code is more readable and resembles synchronous code.</li> <li>Error Handling: More intuitive and easier to manage errors with <code>try/catch</code>.</li> </ul> <p>Disadvantages:</p> <ul> <li>Requires Async Functions: You must use <code>async</code> functions, which may require more refactoring if integrating into existing code.</li> </ul>"},{"location":"frontend/js/httprequest/core/chaining/#3-using-promises-directly","title":"3. Using Promises Directly","text":"ApproachExampleExplanation <ul> <li>Manual Promise Creation: Promises are created and resolved/rejected manually using the <code>Promise</code> constructor.</li> <li>Chaining: Promises can be chained using <code>.then</code>.</li> </ul> <pre><code>const fetchFirst = () =&gt; {\n    return new Promise((resolve, reject) =&gt; {\n        fetch('https://api.example.com/first')\n            .then(response =&gt; response.json())\n            .then(data =&gt; resolve(data))\n            .catch(error =&gt; reject(error));\n    });\n};\n\nconst fetchSecond = (id) =&gt; {\n    return new Promise((resolve, reject) =&gt; {\n        fetch(`https://api.example.com/second/${id}`)\n            .then(response =&gt; response.json())\n            .then(data =&gt; resolve(data))\n            .catch(error =&gt; reject(error));\n    });\n};\n\nfetchFirst()\n    .then(data1 =&gt; fetchSecond(data1.id))\n    .then(data2 =&gt; console.log(data2))\n    .catch(error =&gt; console.error('Error:', error));\n</code></pre> <p>Advantages:</p> <ul> <li>Control: Provides explicit control over promise creation and resolution.</li> <li>Flexible: Useful for custom promise handling or integrating with existing promise-based code.</li> </ul> <p>Disadvantages:</p> <ul> <li>Boilerplate Code: More verbose and manual compared to .then or async/await.</li> </ul>"},{"location":"frontend/js/httprequest/core/chaining/#comparison-summary","title":"Comparison Summary","text":"<p><code>.then</code> Chaining:</p> <ul> <li>Best for simple sequences of asynchronous operations.</li> <li>Can become unwieldy with complex chains.</li> </ul> <p><code>async/await</code>:</p> <ul> <li>Best for readability and managing complex asynchronous workflows.</li> <li>Makes the code look synchronous and is easier to debug with try/catch.</li> </ul> <p>Direct Promises:</p> <ul> <li>Provides control over promise creation.</li> <li>Useful when you need custom promise logic or are integrating with existing promise-based systems.</li> </ul> <p>In practice, <code>async/await</code> is often preferred for its clarity and ease of use, especially in complex scenarios. However, <code>.then</code> chaining and direct promises are also valid approaches depending on the specific needs and context of the codebase.</p> <p>so if the first api response error or unsuccessfull does the second hit or not</p> <p>If the first API request fails or returns an error, the second API request will not be initiated. This is true whether you are using <code>.then</code> chaining, <code>async/await</code>, or direct promises.</p> <p>Summary</p> <p>In all three methods, if the first API call fails:</p> <ul> <li>With <code>.then</code>: The subsequent .then calls are skipped, and the .catch block is executed.</li> <li>With <code>async/await</code>: The catch block handles the error, and subsequent await statements are not executed.</li> <li>With direct promises: The .then calls after a failed promise are skipped, and the .catch block handles the error.</li> </ul> <p>This behavior ensures that if one step in a chain of asynchronous operations fails, the remaining steps dependent on that result are not executed, maintaining the integrity of the process.</p>"},{"location":"frontend/js/httprequest/core/chaining/#api-call","title":"API Call","text":""},{"location":"frontend/js/httprequest/core/chaining/#1-dependent-api-calls-with-asyncawait","title":"1. Dependent API Calls with <code>async/await</code>","text":"<p>In this case, the second API call depends on the success of the first call. If the first call fails, the second call should be skipped.</p> ExampleExplanation <pre><code>async function fetchData() {\n    try {\n        // Make the first API call\n        const response1 = await fetch('https://api.example.com/user');\n        if (!response1.ok) {\n            throw new Error('Failed to fetch user');\n        }\n        const userData = await response1.json();\n\n        // Use the result from the first API call to make the second call\n        const response2 = await fetch(`https://api.example.com/user/${userData.id}/details`);\n        if (!response2.ok) {\n            throw new Error('Failed to fetch user details');\n        }\n        const userDetails = await response2.json();\n\n        // Use the result from the second API call\n        console.log('User Details:', userDetails);\n    } catch (error) {\n        // Handle any errors that occurred during the API calls\n        console.error('Error:', error);\n    }\n}\n\nfetchData();\n</code></pre> <ul> <li>First API Call: <code>await fetch('https://api.example.com/user')</code> waits for the first API call to complete.</li> <li>Error Handling: If the first call fails (response is not OK), an error is thrown, and the second call is not made.</li> <li>Second API Call: Only made if the first call succeeds, using the data from the first call.</li> <li>Catch Block: Handles any errors that occur during the process.</li> </ul>"},{"location":"frontend/js/httprequest/core/chaining/#2-independent-api-calls-with-asyncawait","title":"2. Independent API Calls with <code>async/await</code>","text":"<p>n this case, the second API call is independent of the first, so you can make both calls regardless of whether the first call succeeds or fails.</p> ExampleExplanation <pre><code>async function fetchData() {\n    try {\n        // Make the first API call\n        const response1 = await fetch('https://api.example.com/data1').catch(() =&gt; null);\n        const data1 = response1 ? await response1.json() : null;\n        console.log('Data1:', data1);\n\n        // Make the second API call independently\n        const response2 = await fetch('https://api.example.com/data2');\n        if (!response2.ok) {\n            throw new Error('Failed to fetch data2');\n        }\n        const data2 = await response2.json();\n        console.log('Data2:', data2);\n\n    } catch (error) {\n        // Handle any errors that occurred during the API calls\n        console.error('Error:', error);\n    }\n}\n\nfetchData();\n</code></pre> <ul> <li>First API Call: <code>await fetch('https://api.example.com/data1').catch(() =&gt; null)</code> makes the first call and catches any errors, setting <code>data1</code> to <code>null</code> if the call fails.</li> <li>Second API Call: Made independently, regardless of whether the first call succeeds or fails.</li> <li>Error Handling: Errors from either API call are handled in the <code>catch</code> block.</li> </ul> Summary <ul> <li>Dependent Calls: Use <code>async/await</code> to ensure that the second call is only made if the first call succeeds. Handle errors with a <code>try/catch</code> block.</li> <li>Independent Calls: You can make both API calls independently and handle their results separately, while still managing errors gracefully.</li> </ul> <p>These patterns using <code>async/await</code> help manage asynchronous operations in a readable and structured way.</p>"},{"location":"frontend/js/httprequest/core/chaining/#api-excecution","title":"API Excecution","text":"Sequential Execution async/awaitExplanation <p>Example: Sequential Tasks with <code>async/await</code></p> <pre><code>async function fetchDataSequentially() {\n    try {\n        const response1 = await fetch('https://api.example.com/first');\n        const data1 = await response1.json();\n\n        const response2 = await fetch(`https://api.example.com/second/${data1.id}`);\n        const data2 = await response2.json();\n\n        console.log('Data1:', data1);\n        console.log('Data2:', data2);\n    } catch (error) {\n        console.error('Error:', error);\n    }\n}\n\nfetchDataSequentially();\n</code></pre> <p>Best For:</p> <ul> <li>Sequential Execution: When you need to perform asynchronous tasks in a specific order, where each task depends on the result of the previous one.</li> <li>Error Handling: When you want to handle errors from multiple asynchronous tasks in a centralized way.</li> </ul> <p>Advantages:</p> <ul> <li>Readability: Code looks synchronous and is easier to read and understand.</li> <li>Error Handling: Allows you to use <code>try/catch</code> blocks to handle errors, making it simpler to manage exceptions. Control Flow: Better suited for scenarios where each asynchronous operation depends on the previous one.</li> </ul> <p>Disadvantages:</p> <ul> <li>Sequential Execution: If tasks are independent, using <code>async/await</code> might not be as efficient as <code>Promise.all</code> because tasks are executed one after the other.</li> </ul> Parallel Execution Promise.allExplanation <p>Example: Parallel Tasks with Promise.all</p> <pre><code>async function fetchDataInParallel() {\n    try {\n        const [response1, response2] = await Promise.all([\n            fetch('https://api.example.com/first'),\n            fetch('https://api.example.com/second')\n            ]);\n\n        const data1 = await response1.json();\n        const data2 = await response2.json();\n\n        console.log('Data1:', data1);\n        console.log('Data2:', data2);\n    } catch (error) {\n        console.error('Error:', error);\n    }\n}\n\nfetchDataInParallel();\n</code></pre> <p>Best For:</p> <ul> <li>Parallel Execution: When you have multiple asynchronous tasks that can be performed simultaneously and don\u2019t depend on each other\u2019s results.</li> <li>Performance: When you want to execute multiple tasks in parallel to reduce total execution time.</li> </ul> <p>Advantages:</p> <ul> <li>Efficiency: Executes multiple promises in parallel, which can be faster if tasks are independent.</li> <li>Handles Multiple Promises: Easily handles and waits for all promises to resolve or for any to reject.</li> </ul> <p>Disadvantages:</p> <ul> <li>Error Handling: If any promise in the array rejects, <code>Promise.all</code> immediately rejects, and handling errors requires additional logic to manage partial success.</li> </ul> Comparison Summary <p>Use <code>async/await</code> When:</p> <ul> <li>Tasks need to be executed in a specific order.</li> <li>You need to handle errors in a single <code>try/catch</code> block.</li> <li>You are performing operations that depend on the results of previous operations.</li> </ul> <p>Use <code>Promise.all</code> When:</p> <ul> <li>Tasks can be executed in parallel.</li> <li>You want to perform multiple independent asynchronous operations concurrently.</li> <li>You need to wait for all promises to complete, or any to fail, in a single operation.</li> </ul> <p>Choosing the Right Approach:</p> <ul> <li>For Sequential Dependencies: Use <code>async/await</code> to handle tasks in a specific order and manage errors gracefully.</li> <li>For Parallel Tasks: Use <code>Promise.all</code> to run multiple independent tasks concurrently for better performance.</li> </ul> <p>In practice, you might use a combination of both. For example, you could use <code>async/await</code> for sequential tasks and <code>Promise.all</code> for parallel tasks within the same async function, depending on the requirements of your application.</p>"},{"location":"frontend/js/httprequest/core/chaining/#plan-your-data-fetching-strategy","title":"Plan Your Data Fetching Strategy","text":"Decide how you want to fetch the data <ul> <li>Sequential Fetching: Fetch data one after the other. Useful if the order matters or if you want to avoid hitting too many APIs simultaneously.</li> <li>Parallel Fetching: Fetch data for all components simultaneously. This is more efficient but requires managing multiple loading states.</li> </ul>"},{"location":"frontend/js/httprequest/core/fetch-api/","title":"Fetch API","text":"<p>Mastering Fetch API and Axios involves understanding both basic concepts and advanced features.</p> <p>Here's a structured guide to help you master them, starting from the basics and moving to more advanced techniques.</p>"},{"location":"frontend/js/httprequest/core/fetch-api/#mastering-fetch-api","title":"Mastering Fetch API","text":""},{"location":"frontend/js/httprequest/core/fetch-api/#1-understanding-the-basics","title":"1. Understanding the Basics","text":"<ul> <li> <p>What is Fetch API?</p> <p>Fetch API is a modern JavaScript API used to make HTTP requests. It is built into most modern browsers and provides a more powerful and flexible feature set compared to older methods like <code>XMLHttpRequest</code>.</p> </li> <li> <p>Basic Syntax:</p> <pre><code>fetch(url, options)\n    .then(response =&gt; response.json())  // or response.text() / response.blob() etc.\n    .then(data =&gt; console.log(data))\n    .catch(error =&gt; console.error('Error:', error));\n</code></pre> </li> <li> <p>Basic Example:</p> <pre><code>fetch('https://api.example.com/data')\n    .then(response =&gt; response.json())\n    .then(data =&gt; console.log(data))\n    .catch(error =&gt; console.error('Error:', error));\n</code></pre> </li> </ul>"},{"location":"frontend/js/httprequest/core/fetch-api/#2-handling-responses-and-errors","title":"2. Handling Responses and Errors","text":"<ul> <li> <p>Checking Response Status:</p> <pre><code>fetch('https://api.example.com/data')\n    .then(response =&gt; {\n        if (!response.ok) {\n            throw new Error(`HTTP error! Status: ${response.status}`);\n        }\n        return response.json();\n    })\n    .then(data =&gt; console.log(data))\n    .catch(error =&gt; console.error('Fetch error:', error));\n</code></pre> </li> <li> <p>Parsing Different Types of Responses:</p> <pre><code>// JSON\nfetch('https://api.example.com/data')\n    .then(response =&gt; response.json())\n    .then(data =&gt; console.log(data));\n\n// Text\nfetch('https://api.example.com/text')\n    .then(response =&gt; response.text())\n    .then(text =&gt; console.log(text));\n</code></pre> </li> </ul>"},{"location":"frontend/js/httprequest/core/fetch-api/#3-making-different-types-of-requests","title":"3. Making Different Types of Requests","text":"<ul> <li> <p>GET Request:</p> <pre><code>fetch('https://api.example.com/data')\n    .then(response =&gt; response.json())\n    .then(data =&gt; console.log(data));\n</code></pre> </li> <li> <p>POST Request with Body:</p> <pre><code>fetch('https://api.example.com/data', {\n    method: 'POST',\n    headers: {\n        'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({ key: 'value' })\n})\n    .then(response =&gt; response.json())\n    .then(data =&gt; console.log(data));\n</code></pre> </li> <li> <p>PUT Request:</p> <pre><code>fetch('https://api.example.com/data/1', {\n    method: 'PUT',\n    headers: {\n        'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({ key: 'new value' })\n})\n    .then(response =&gt; response.json())\n    .then(data =&gt; console.log(data));\n</code></pre> </li> <li> <p>DELETE Request:</p> <pre><code>fetch('https://api.example.com/data/1', {\n    method: 'DELETE'\n})\n    .then(response =&gt; response.json())\n    .then(data =&gt; console.log(data));\n</code></pre> </li> </ul>"},{"location":"frontend/js/httprequest/core/fetch-api/#4-advanced-features","title":"4. Advanced Features","text":"<ul> <li> <p>Using <code>AbortController</code> for Request Cancellation:</p> <pre><code>const controller = new AbortController();\nconst signal = controller.signal;\n\nfetch('https://api.example.com/data', { signal })\n    .then(response =&gt; response.json())\n    .then(data =&gt; console.log(data))\n    .catch(error =&gt; {\n        if (error.name === 'AbortError') {\n            console.log('Fetch request canceled');\n        } else {\n            console.error('Fetch error:', error);\n        }\n    });\n\n// To cancel the request\ncontroller.abort();\n</code></pre> </li> <li> <p>Streaming:</p> <pre><code>fetch('https://api.example.com/stream')\n    .then(response =&gt; {\n        const reader = response.body.getReader();\n        return reader.read();\n    })\n    .then(result =&gt; console.log(new TextDecoder().decode(result.value)));\n</code></pre> </li> </ul>"},{"location":"frontend/js/httprequest/core/overview/","title":"Overview","text":""},{"location":"frontend/js/httprequest/core/overview/#overview","title":"Overview","text":"<p>Great question! Both Fetch API and Axios are popular tools for making HTTP requests in JavaScript, but they have some key differences.</p>"},{"location":"frontend/js/httprequest/core/overview/#fetch-api","title":"Fetch API","text":"<p>Fetch API is a modern JavaScript API built into browsers for making HTTP requests. It\u2019s part of the standard Web API and doesn\u2019t require any external libraries.</p> ExampleKey Features <pre><code>fetch('https://api.example.com/data')\n    .then(response =&gt; response.json())\n    .then(data =&gt; console.log(data))\n    .catch(error =&gt; console.error('Error:', error));\n</code></pre> <ol> <li>Built-In: Fetch is natively supported in most modern browsers, so there's no need for additional libraries.</li> <li>Promises-Based: Fetch uses promises, making it easier to handle asynchronous operations.</li> <li>Configurable: You have to manually handle some aspects like response parsing, headers, and status codes.</li> <li>No Built-In Support for Older Browsers: For browsers that don't support Fetch, you might need a polyfill.</li> </ol>"},{"location":"frontend/js/httprequest/core/overview/#axios","title":"Axios","text":"<p>Axios is a third-party library for making HTTP requests. It\u2019s popular in both browser and Node.js environments.</p> ExampleKey Features <pre><code>axios.get('https://api.example.com/data')\n    .then(response =&gt; console.log(response.data))\n    .catch(error =&gt; console.error('Error:', error));\n</code></pre> <ol> <li>Promises-Based: Like Fetch, Axios uses promises.</li> <li>Automatic JSON Data Transformation: Axios automatically transforms JSON data into JavaScript objects.</li> <li>Request and Response Interceptors: Axios allows you to define interceptors to modify requests or responses before they are handled by <code>.then</code> or <code>.catch</code>.</li> <li>Error Handling: Axios provides a more refined error handling mechanism, including status codes and error messages.</li> <li>Older Browser Support: Axios works in older browsers without needing a polyfill.</li> </ol>"},{"location":"frontend/js/httprequest/core/overview/#mastering-fetch-and-axios","title":"Mastering Fetch and Axios","text":"<ol> <li> <p>Understand the Basics: Make sure you\u2019re comfortable with basic HTTP concepts (GET, POST, PUT, DELETE) and how to handle responses and errors.</p> </li> <li> <p>Read Documentation: Familiarize yourself with the official documentation for Fetch API and Axios.</p> </li> <li> <p>Practice Error Handling:</p> <ul> <li>Fetch: Check the <code>response.ok</code> property and handle HTTP errors explicitly.</li> <li>Axios: Use <code>.catch</code> to handle errors and access more detailed error information.</li> </ul> </li> <li> <p>Use Advanced Features:</p> <ul> <li>Fetch: Learn to use the AbortController for request cancellation and handle streams.</li> <li>Axios: Explore request/response interceptors, <code>axios.create</code> for custom instances, and <code>axios.all</code> for concurrent requests.</li> </ul> </li> <li> <p>Consider Use Cases:</p> <ul> <li>Use Fetch for simple cases or when working in environments with native support.</li> <li>Use Axios if you need advanced features like interceptors or are working in older browsers.</li> </ul> </li> <li> <p>Build Projects: Implement both Fetch and Axios in various projects to see their strengths and weaknesses in real-world scenarios.</p> </li> <li> <p>Stay Updated: Libraries and standards evolve. Follow updates to the Fetch API and Axios to keep your knowledge current.</p> </li> </ol> <p>By exploring these aspects, you'll gain a solid understanding and become proficient in using both Fetch API and Axios!</p>"},{"location":"frontend/js/httprequest/core/overview/#detailed-differences","title":"Detailed Differences","text":"<p>Absolutely, let's dive deeper into the differences between Fetch API and Axios, and examine scenarios where one might be preferable over the other.</p>"},{"location":"frontend/js/httprequest/core/overview/#1-error-handling","title":"1.  Error Handling:","text":"<p>Fetch API:</p> ExampleExplanation <pre><code>fetch('https://api.example.com/data')\n    .then(response =&gt; {\n        if (!response.ok) {\n            throw new Error('Network response was not ok');\n        }\n        return response.json();\n    })\n    .then(data =&gt; console.log(data))\n    .catch(error =&gt; console.error('Fetch error:', error));\n</code></pre> <ul> <li>Fetch does not reject the promise on HTTP error status codes (like 404 or 500). It only rejects on network errors or issues that prevent the request from completing.</li> <li>You need to manually check <code>response.ok</code> or <code>response.status</code> to handle HTTP errors.</li> </ul> <p>Axios:</p> ExampleExplanation <pre><code>axios.get('https://api.example.com/data')\n    .then(response =&gt; console.log(response.data))\n    .catch(error =&gt; {\n        if (error.response) {\n            // Server responded with a status other than 2xx\n            console.error('Response error:', error.response);\n        } else if (error.request) {\n            // Request was made but no response received\n            console.error('Request error:', error.request);\n        } else {\n            // Something else caused an error\n            console.error('Error:', error.message);\n        }\n    });\n</code></pre> <ul> <li>Axios automatically rejects the promise for HTTP status codes that fall outside the range of <code>2xx</code>. It provides a more straightforward way to handle errors with the <code>catch</code> block.</li> </ul>"},{"location":"frontend/js/httprequest/core/overview/#2-json-transformation","title":"2.  JSON Transformation:","text":"<p>Fetch API:</p> ExampleExplanation <pre><code>fetch('https://api.example.com/data')\n    .then(response =&gt; response.json())\n    .then(data =&gt; console.log(data));\n</code></pre> <ul> <li>Fetch requires you to explicitly call <code>.json()</code> to parse the JSON response.</li> </ul> <p>Axios:</p> ExampleExplanation <pre><code>axios.get('https://api.example.com/data')\n    .then(response =&gt; console.log(response.data));\n</code></pre> <ul> <li>Axios automatically transforms the response data to JSON if the response header <code>Content-Type</code> is set to <code>application/json</code>.</li> </ul>"},{"location":"frontend/js/httprequest/core/overview/#2-request-and-response-interceptors","title":"2. Request and Response Interceptors:","text":"<p>Fetch API:</p> Explanation <ul> <li>Fetch does not have built-in support for interceptors. You have to manually handle request and response modification in each request.</li> </ul> <p>Axios:</p> ExampleExplanation <pre><code>// Request interceptor\naxios.interceptors.request.use(config =&gt; {\n    // Modify request config\n    return config;\n}, error =&gt; {\n    return Promise.reject(error);\n});\n\n// Response interceptor\naxios.interceptors.response.use(response =&gt; {\n    // Modify response data\n    return response;\n}, error =&gt; {\n    return Promise.reject(error);\n});\n</code></pre> <ul> <li>Axios supports interceptors for both requests and responses, allowing you to modify or log them before they are handled by <code>.then</code> or <code>.catch</code>.</li> </ul>"},{"location":"frontend/js/httprequest/core/overview/#3-cancellation","title":"3. Cancellation:","text":"<p>Fetch API:</p> ExampleExplanation <pre><code>const controller = new AbortController();\nconst signal = controller.signal;\n\nfetch('https://api.example.com/data', { signal })\n    .then(response =&gt; response.json())\n    .then(data =&gt; console.log(data))\n    .catch(error =&gt; {\n        if (error.name === 'AbortError') {\n            console.log('Fetch request canceled');\n        } else {\n            console.error('Fetch error:', error);\n        }\n    });\n\n// To cancel the request\ncontroller.abort();\n</code></pre> <ul> <li>Fetch supports request cancellation using AbortController.</li> </ul> <p>Axios:</p> ExampleExplanation <pre><code>const CancelToken = axios.CancelToken;\nconst source = CancelToken.source();\n\naxios.get('https://api.example.com/data', { cancelToken: source.token })\n    .then(response =&gt; console.log(response.data))\n    .catch(error =&gt; {\n        if (axios.isCancel(error)) {\n            console.log('Request canceled:', error.message);\n        } else {\n            console.error('Axios error:', error);\n        }\n    });\n\n// To cancel the request\nsource.cancel('Operation canceled by the user.');\n</code></pre> <ul> <li>Axios supports request cancellation via cancel tokens.</li> </ul>"},{"location":"frontend/js/httprequest/core/overview/#5-browser-support","title":"5. Browser Support:","text":"<p>Fetch API:</p> <pre><code>-   Fetch is natively supported in modern browsers but may require a polyfill for older browsers.\n</code></pre> <p>Axios:</p> <ul> <li>Axios works in both modern and older browsers without additional polyfills, and also supports Node.js environments.</li> </ul>"},{"location":"frontend/js/httprequest/core/overview/#when-to-use-each","title":"When to Use Each","text":"Use Fetch API When: <ol> <li>You prefer native browser support and want to avoid including external libraries.</li> <li>You need a lightweight solution for basic HTTP requests without advanced features.</li> <li>You want fine-grained control over error handling and parsing responses.</li> </ol> Use Axios When: <ol> <li>You need advanced features like request and response interceptors, or need to handle concurrent requests.</li> <li>You want simplified error handling, especially when dealing with different types of errors.</li> <li>You\u2019re working with older browsers or need compatibility with both Node.js and browser environments.</li> <li>You need automatic JSON data transformation and would benefit from built-in request and response manipulation.</li> </ol> <p>Summary</p> <p>Both Fetch and Axios have their strengths. Fetch is ideal for simpler use cases or when avoiding additional dependencies is crucial. Axios is more feature-rich and suitable for complex scenarios involving interceptors, cancellation, and universal support across environments. Understanding these differences will help you choose the right tool for your needs and become more effective at managing HTTP requests in your projects.</p>"},{"location":"frontend/js/httprequest/core/overview/#major-difference","title":"Major Difference","text":"<p>The major difference to remember between Fetch API and Axios is:</p>"},{"location":"frontend/js/httprequest/core/overview/#error-handling","title":"Error Handling:","text":"<ul> <li> <p>Fetch API:</p> <p>Does not reject the promise on HTTP error status codes (like 404 or 500). You need to manually check <code>response.ok</code> or <code>response.status</code> to handle these errors.</p> <p>Example:</p> <pre><code>fetch('https://api.example.com/data')\n    .then(response =&gt; {\n        if (!response.ok) {\n            throw new Error('Network response was not ok');\n        }\n        return response.json();\n    })\n    .then(data =&gt; console.log(data))\n    .catch(error =&gt; console.error('Fetch error:', error));\n</code></pre> </li> <li> <p>Axios:</p> <p>Automatically rejects the promise for HTTP status codes that fall outside the range of 2xx, making error handling more straightforward and consistent.</p> <p>Example:</p> <pre><code>axios.get('https://api.example.com/data')\n    .then(response =&gt; console.log(response.data))\n    .catch(error =&gt; {\n        if (error.response) {\n        console.error('Response error:', error.response);\n        } else if (error.request) {\n        console.error('Request error:', error.request);\n        } else {\n        console.error('Error:', error.message);\n        }\n    });\n</code></pre> </li> </ul> <p>Summary: Axios handles HTTP errors automatically by rejecting the promise for non-2xx status codes, whereas Fetch API requires you to manually check for errors and handle them.</p>"},{"location":"frontend/js/httprequest/core/then-and-asyncwait/","title":"Then and async await","text":""},{"location":"frontend/js/httprequest/core/then-and-asyncwait/#choosing","title":"Choosing","text":"<p>Choosing between <code>.then</code> and <code>async/await</code> for handling asynchronous operations often comes down to readability and personal preference. Here\u2019s a guide to help you decide when to use each approach:</p>"},{"location":"frontend/js/httprequest/core/then-and-asyncwait/#using-then","title":"Using <code>.then</code>","text":"When to UseExample <ul> <li>Chaining Promises: If you need to chain multiple asynchronous operations together, <code>.then</code> can be a clear way to handle this. Each <code>.then</code> can handle the result of the previous promise.</li> <li>Simple Cases: For straightforward cases where you just need to perform actions based on the result of a promise, <code>.then</code> can be simple and effective.</li> <li>Older Codebases: If you're working with legacy code that uses <code>.then</code>, it might be easier to stay consistent with that style.</li> </ul> <pre><code>fetch(url)\n    .then(response =&gt; response.json())\n    .then(data =&gt; console.log(data))\n    .catch(error =&gt; console.error('Error:', error));\n</code></pre>"},{"location":"frontend/js/httprequest/core/then-and-asyncwait/#using-asyncawait","title":"Using <code>async/await</code>","text":"When to UseExample <ul> <li>Readability and Maintenance: <code>async/await</code> often makes asynchronous code look more like synchronous code, which can be easier to read and maintain, especially for complex sequences of operations.</li> <li>Error Handling: <code>async/await</code> allows you to use <code>try/catch</code> blocks for error handling, which can be more intuitive and cleaner compared to chaining <code>.catch</code> with <code>.then</code>.</li> <li>Complex Logic: If you have complex logic involving multiple asynchronous operations, <code>async/await</code> can make your code more organized and easier to understand.</li> </ul> <pre><code>async function fetchData() {\n    try {\n        const response = await fetch(url);\n        const data = await response.json();\n        console.log(data);\n    } catch (error) {\n        console.error('Error:', error);\n    }\n}\n\nfetchData();\n</code></pre>"},{"location":"frontend/js/httprequest/core/then-and-asyncwait/#key-differences","title":"Key Differences:","text":"SyntaxError Handling <ul> <li><code>.then</code> uses a callback-based approach, which can lead to \"callback hell\" or nested <code>.then</code> chains.</li> <li><code>async/await</code> provides a cleaner, synchronous-looking syntax that avoids nested callbacks.</li> </ul> <ul> <li>With <code>.then</code>, you handle errors using <code>.catch</code> at the end of the chain.</li> <li>With <code>async/await</code>, you handle errors using <code>try/catch</code>, which can be more intuitive for handling multiple potential points of failure.</li> </ul>"},{"location":"frontend/js/httprequest/core/then-and-asyncwait/#summary","title":"Summary:","text":"<ul> <li>Use <code>.then</code> for simpler cases or when working with codebases that already use it.</li> <li>Use <code>async/await</code> for more readable and maintainable code, especially when dealing with complex logic or when you prefer synchronous-looking code.</li> </ul> <p>In general, <code>async/await</code> is often preferred for its clarity and ease of handling complex asynchronous logic. However, both approaches are valid and choosing between them can depend on the specific needs and context of your code.</p>"},{"location":"frontend/js/httprequest/core/then-and-asyncwait/#now-explain-to-5-years-old","title":"now explain to 5 years old","text":"<p>now explain to 5 years old</p> <p>Imagine you\u2019re waiting for two different friends to give you two different toys.</p> Using <code>.then</code>Using <code>async/await</code>The Main Difference <ul> <li><code>.then</code> is like asking your first friend to give you a toy, and then, once you have that toy, you ask your second friend to give you another one. You have to wait and check each time to see if they did what they promised.</li> </ul> <p>Example:</p> <ul> <li>First, you get a toy from your friend.</li> <li>Then you ask, \u201cDid you bring another toy?\u201d</li> </ul> <p>If your friend says, \u201cYes,\u201d you play with the toys. If something goes wrong, you have to deal with it then.</p> <ul> <li><code>async/await</code> is like waiting for both friends to give you their toys all at once and checking them together. It\u2019s like you sit and wait for all toys to come before you start playing, and if something goes wrong, you can fix it right then and there.</li> </ul> <p>Example:</p> <ul> <li>You wait and ask your first friend and your second friend to give you the toys.</li> <li>If both toys are okay, you start playing.</li> <li>If there\u2019s a problem with any toy, you fix it immediately.</li> </ul> <ul> <li><code>.then</code> is like taking turns with your friends, waiting for each toy before asking for the next one.</li> <li><code>async/await</code> is like waiting for everything to be ready before you start playing, which can be easier and faster to handle.</li> </ul> <p>In general, <code>async/await</code> makes things simpler and more organized, just like waiting until everything is ready before starting to play.</p>"},{"location":"frontend/js/httprequest/example/axios-api-example/","title":"Axios Api Example","text":""},{"location":"frontend/js/httprequest/example/axios-api-example/#overview","title":"Overview","text":"<p>To convert your React component to use <code>axios</code> instead of fetch, you can follow these steps:</p> <ol> <li> <p>Install <code>axios</code> if you haven\u2019t already:</p> <pre><code>npm install axios\n</code></pre> </li> <li> <p>Import <code>axios</code> and modify the <code>fetchData</code> function to use <code>axios</code> for making the API request.</p> CodeKey Changes <p>Here\u2019s how your updated component would look:</p> <pre><code>import React, { useState, useEffect } from 'react';\nimport axios from 'axios'; // Import axios\n\nfunction FetchExample() {\n    // State to hold data and loading status\n    const [data, setData] = useState(null);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n\n    // Define the fetch function inside the component\n    const fetchData = async (url, apiKey) =&gt; {\n        try {\n            const response = await axios.get(url, {\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${apiKey}`, // Include the API key in headers\n                },\n            });\n\n            setData(response.data); // Axios wraps the data in `response.data`\n        } catch (error) {\n            setError(error);\n        } finally {\n            setLoading(false);\n        }\n    };\n\n    useEffect(() =&gt; {\n        // Define your API endpoint and API key\n        const API_URL = 'https://api.example.com/data'; // Replace with your API URL\n        const API_KEY = 'your-api-key'; // Replace with your API key\n\n        fetchData(API_URL, API_KEY);\n    }, []); // Empty dependency array means this runs once when the component mounts\n\n    // Render loading, error, or data\n    if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Data from API&lt;/h1&gt;\n            &lt;pre&gt;{JSON.stringify(data, null, 2)}&lt;/pre&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default FetchExample;\n</code></pre> <ul> <li>Import <code>axios</code>: Added <code>import axios from 'axios';</code>.</li> <li>Use <code>axios.get</code>: Replaced the <code>fetch</code> call with <code>axios.get</code>, passing headers in the configuration object.</li> <li>Handle <code>response.data</code>: Axios provides the response data directly in the data property of the response object, so you use <code>response.data</code> instead of parsing the response as JSON.</li> </ul> <p>This refactor maintains the same functionality but uses axios for HTTP requests, which can simplify error handling and data extraction.</p> </li> </ol>"},{"location":"frontend/js/httprequest/example/axios-api-example/#difference-between-fetch-and-axios","title":"Difference between <code>fetch</code> and <code>axios</code>","text":"<p>what is the main difference between to fetch and axios to remember and why</p> <p>When choosing between <code>fetch</code> and <code>axios</code> for making HTTP requests in JavaScript, there are several key differences to remember:</p>"},{"location":"frontend/js/httprequest/example/axios-api-example/#1-error-handling","title":"1. Error Handling","text":"<ul> <li> <p><code>fetch</code>: Only rejects the promise on network errors (e.g., failed network requests). It does not reject for HTTP errors (e.g., 404 or 500). You need to manually check <code>response.ok</code> to handle HTTP errors.</p> <pre><code>fetch(url)\n    .then(response =&gt; {\n        if (!response.ok) {\n        throw new Error('Network response was not ok');\n        }\n        return response.json();\n    })\n    .then(data =&gt; console.log(data))\n    .catch(error =&gt; console.error('Error:', error));\n</code></pre> </li> <li> <p><code>axios</code>: Automatically rejects the promise for HTTP errors (status codes outside the range 200\u2013299). This simplifies error handling as you don\u2019t need to manually check for <code>response.ok</code>.</p> <pre><code>axios.get(url)\n    .then(response =&gt; console.log(response.data))\n    .catch(error =&gt; console.error('Error:', error));\n</code></pre> </li> </ul>"},{"location":"frontend/js/httprequest/example/axios-api-example/#2-response-parsing","title":"2. Response Parsing","text":"<ul> <li> <p><code>fetch</code>: Requires manual parsing of the response. You have to call <code>response.json()</code>, <code>response.text()</code>, or similar methods based on the expected response type.</p> <pre><code>fetch(url)\n    .then(response =&gt; response.json())\n    .then(data =&gt; console.log(data));\n</code></pre> </li> <li> <p><code>axios</code>: Automatically parses the response based on the <code>Content-Type</code> header. JSON responses are parsed directly into JavaScript objects, so you don\u2019t need to call a parsing method.</p> <pre><code>axios.get(url)\n    .then(response =&gt; console.log(response.data));\n</code></pre> </li> </ul>"},{"location":"frontend/js/httprequest/example/axios-api-example/#3-request-configuration","title":"3. Request Configuration","text":"<ul> <li> <p><code>fetch</code>: Uses a configuration object with a <code>method</code> key for specifying request methods, and you need to handle configuration options (e.g., headers, body) in the same object.</p> <pre><code>fetch(url, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(data)\n});\n</code></pre> </li> <li> <p><code>axios</code>: Uses a simpler, more flexible configuration object that can be spread out into a method call. Configuration is generally more straightforward and readable.</p> <pre><code>axios.post(url, data, { headers: { 'Content-Type': 'application/json' } });\n</code></pre> </li> </ul>"},{"location":"frontend/js/httprequest/example/axios-api-example/#4-interceptors","title":"4. Interceptors","text":"<ul> <li> <p><code>fetch</code>: Does not support request or response interceptors out-of-the-box. Interceptors need to be manually implemented with custom wrappers or middleware.</p> </li> <li> <p><code>axios</code>: Supports request and response interceptors, which can be used to modify requests or responses before they are handled.</p> <pre><code>axios.interceptors.request.use(config =&gt; {\n    // Modify request config\n    return config;\n}, error =&gt; {\n    return Promise.reject(error);\n});\n\naxios.interceptors.response.use(response =&gt; {\n    // Modify response data\n    return response;\n}, error =&gt; {\n    return Promise.reject(error);\n});\n</code></pre> </li> </ul>"},{"location":"frontend/js/httprequest/example/axios-api-example/#5-browser-support-and-polyfills","title":"5. Browser Support and Polyfills","text":"<ul> <li> <p><code>fetch</code>: Not supported in Internet Explorer and requires a polyfill for older browsers.</p> </li> <li> <p><code>axios</code>: Works in older browsers without needing a polyfill, making it more suitable for projects requiring broader browser support.</p> </li> </ul>"},{"location":"frontend/js/httprequest/example/axios-api-example/#summary","title":"Summary","text":"<ul> <li> <p>Use <code>fetch</code> if you need a lightweight solution and are comfortable handling response parsing and error checking manually. It\u2019s built into modern browsers and has a straightforward API.</p> </li> <li> <p>Use <code>axios</code> if you prefer built-in error handling, automatic response parsing, request/response interceptors, and support for older browsers. It provides additional features and can simplify code, especially for complex scenarios.</p> </li> </ul> <p>Choosing between <code>fetch</code> and <code>axios</code> often comes down to personal preference and project requirements. Both are capable tools, but <code>axios</code> generally provides a more feature-rich experience out of the box.</p>"},{"location":"frontend/js/httprequest/example/axios-api-example/#one-thing-to-remember","title":"One thing to <code>Remember</code>","text":"<p>what is the one main thing to remember?</p> <p>The one main thing to remember when choosing between fetch and axios is:</p>"},{"location":"frontend/js/httprequest/example/axios-api-example/#error-handling","title":"Error Handling","text":"<p><code>axios</code> automatically rejects the promise for HTTP errors, meaning you don\u2019t have to manually check for HTTP status codes or handle network errors separately. This can significantly simplify error handling in your code.</p> <p>In contrast, <code>fetch</code> does not reject the promise for HTTP errors. You need to explicitly check if the response was successful using <code>response.ok</code> or by checking the status code, and handle any parsing errors or network issues separately.</p> <p>This built-in error handling in <code>axios</code> can make your code cleaner and easier to manage, especially when dealing with various types of errors and responses.</p>"},{"location":"frontend/js/httprequest/example/axios-api-example/#explain-to-5-years-old","title":"Explain to 5 years old","text":"<p>now explain to 5 years old</p> <p>Imagine you have two toy robots that help you with your homework: Fetch and Axios.</p>"},{"location":"frontend/js/httprequest/example/axios-api-example/#fetch-robot","title":"Fetch Robot","text":"<ul> <li>Fetch is like a robot that brings you a box from the kitchen. If the box has something wrong, like it's empty or broken, Fetch will still give it to you, and you\u2019ll have to check inside to see if it\u2019s okay or not.</li> </ul>"},{"location":"frontend/js/httprequest/example/axios-api-example/#axios-robot","title":"Axios Robot","text":"<ul> <li>Axios is like a robot that checks the box for you before giving it to you. If something\u2019s wrong with the box, Axios will tell you right away that there\u2019s a problem.</li> </ul>"},{"location":"frontend/js/httprequest/example/axios-api-example/#the-main-thing","title":"The Main Thing","text":"<p>The big thing to remember is that Axios is better at telling you when there\u2019s a problem right away. Fetch will just hand you the box, and you have to check for problems yourself.</p>"},{"location":"frontend/js/httprequest/example/cancel-axios-api/","title":"Cancel Axios","text":"<p>In React 18, when using <code>StrictMode</code>, components may mount and unmount multiple times during development. This can lead to requests being canceled frequently, which can result in <code>CanceledError</code> messages in the console. While this is expected behavior in development, you might want to suppress or handle these errors more gracefully.</p>"},{"location":"frontend/js/httprequest/example/cancel-axios-api/#in-development","title":"In Development","text":""},{"location":"frontend/js/httprequest/example/cancel-axios-api/#heres-how-to-manage-it","title":"Here's how to manage it:","text":"<ul> <li>Ignore Canceled Errors: You can filter out <code>CanceledError</code> in your error handling.</li> <li>Use <code>isCancel</code> Method: This allows you to differentiate between a cancellation and an actual error.</li> </ul> <p>Here's how you can modify your code to implement this:</p> ExampleKey ChangesAdditional Considerations <pre><code>import React, { useState, useEffect } from 'react';\nimport axios from 'axios';\nimport './App.css';\n\nfunction App() {\n    const [data, setData] = useState(null);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n\n    const fetchData = async (url, apiKey, cancelToken) =&gt; {\n        try {\n            const response = await axios.get(url, {\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${apiKey}`,\n                },\n                cancelToken: cancelToken,\n            });\n\n            setData(response.data);\n        } catch (error) {\n            if (axios.isCancel(error)) {\n                // Ignore canceled requests in development mode\n                console.log('Request canceled:', error.message);\n            } else {\n                // Set actual error state for other types of errors\n                setError(error);\n            }\n        } finally {\n            setLoading(false);\n        }\n    };\n\n    useEffect(() =&gt; {\n        const API_URL = 'https://jsonplaceholder.typicode.com/posts';\n        const API_KEY = '';\n\n        const source = axios.CancelToken.source();\n\n        fetchData(API_URL, API_KEY, source.token);\n\n        return () =&gt; {\n            source.cancel('Operation canceled by the user.');\n        };\n    }, []);\n\n    if (loading) return &lt;div&gt;Loading ...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error... {error.message}&lt;/div&gt;;\n\n    return (\n        &lt;div className=\"App\"&gt;\n            &lt;h1&gt;Data From API&lt;/h1&gt;\n            {data &amp;&amp; (\n                &lt;ul&gt;\n                {data.map((post) =&gt; (\n                    &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;\n                ))}\n                &lt;/ul&gt;\n            )}\n        &lt;/div&gt;\n    );\n}\n\nexport default App;\n</code></pre> <ul> <li>Error Handling: Inside the catch block, the <code>if (axios.isCancel(error))</code> check is used to ignore canceled requests. Only actual errors will update the error state.</li> <li>Logging: You can log the canceled request for debugging purposes but avoid setting it in the state.</li> </ul> <ul> <li>Development vs. Production: This handling is especially important in development with React Strict Mode, but in production, you shouldn't see frequent unmounts unless your app is designed that way.</li> <li>Testing: Make sure to test your application in a non-Strict mode to verify that it behaves as expected without frequent cancellations.</li> </ul> <p>By applying these changes, you should be able to suppress unnecessary CanceledError messages while still managing your API requests effectively.</p>"},{"location":"frontend/js/httprequest/example/cancel-axios-api/#in-production","title":"In production","text":"<p>In production, the handling of canceled requests can be a bit different. While you generally want to keep your error handling clean, it\u2019s still useful to acknowledge canceled requests. However, you might not want to log them or show any user-facing messages unless there's a specific reason to do so.</p>"},{"location":"frontend/js/httprequest/example/cancel-axios-api/#production-handling-of-canceled-requests","title":"Production Handling of Canceled Requests","text":"<ul> <li> <p>Silence Logs: You typically don\u2019t need to log canceled requests in production, as they are usually a normal part of application behavior (e.g., user navigating away).</p> </li> <li> <p>Display Errors: Only display actual errors to the user. If the request was canceled due to navigation or unmounting, there's no need to set an error state.</p> </li> <li> <p>Error Monitoring: If you're using error tracking tools (like Sentry), you might want to configure them to ignore canceled requests.</p> </li> </ul>"},{"location":"frontend/js/httprequest/example/cancel-axios-api/#example-for-production","title":"Example for Production","text":"<p>Here\u2019s how you might adjust your code for production:</p> <pre><code>import React, { useState, useEffect } from 'react';\nimport axios from 'axios';\nimport './App.css';\n\nfunction App() {\n    const [data, setData] = useState(null);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n\n    const fetchData = async (url, apiKey, cancelToken) =&gt; {\n        try {\n            const response = await axios.get(url, {\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${apiKey}`,\n                },\n                cancelToken: cancelToken,\n            });\n\n            setData(response.data);\n        } catch (error) {\n            if (axios.isCancel(error)) {\n                // Optionally, you can log this in production for monitoring, but often it's unnecessary\n                // console.log('Request canceled:', error.message); // Commented out for production\n            } else {\n                setError(error);\n            }\n        } finally {\n            setLoading(false);\n        }\n    };\n\n    useEffect(() =&gt; {\n        const API_URL = 'https://jsonplaceholder.typicode.com/posts';\n        const API_KEY = '';\n\n        const source = axios.CancelToken.source();\n\n        fetchData(API_URL, API_KEY, source.token);\n\n        return () =&gt; {\n            source.cancel('Operation canceled by the user.');\n        };\n    }, []);\n\n  if (loading) return &lt;div&gt;Loading ...&lt;/div&gt;;\n  if (error) return &lt;div&gt;Error... {error.message}&lt;/div&gt;;\n\n  return (\n    &lt;div className=\"App\"&gt;\n        &lt;h1&gt;Data From API&lt;/h1&gt;\n        {data &amp;&amp; (\n            &lt;ul&gt;\n                {data.map((post) =&gt; (\n                &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        )}\n    &lt;/div&gt;\n  );\n}\n\nexport default App;\n</code></pre>"},{"location":"frontend/js/httprequest/example/cancel-axios-api/#summary","title":"Summary","text":"<ul> <li>Development: Log canceled requests for debugging purposes.</li> <li>Production: Generally ignore canceled requests unless there's a specific need. Focus on displaying actual errors to users.</li> </ul> <p>This approach keeps your error handling clean and user-friendly in a production environment while still allowing you to debug effectively during development.</p>"},{"location":"frontend/js/httprequest/example/cancel-axios-api/#additional","title":"Additional","text":"ExmapleScenarioExplanation <pre><code>import React, { useEffect, useState } from \"react\";\nimport axios from \"axios\";\n\nconst MyComponent = () =&gt; {\n    const [data, setData] = useState(null);\n    const [error, setError] = useState(null);\n\n    useEffect(() =&gt; {\n        // Create a cancel token source\n        const source = axios.CancelToken.source();\n\n        const fetchData = async () =&gt; {\n            try {\n                const response = await axios.get(\"https://api.example.com/data\", {\n                    cancelToken: source.token,\n                });\n                setData(response.data);\n            } catch (err) {\n                if (axios.isCancel(err)) {\n                    console.log(\"Request canceled\", err.message);\n                } else {\n                    setError(err);\n                }\n            }\n        };\n\n        fetchData();\n\n        // Cleanup function to cancel the request\n        return () =&gt; {\n            source.cancel(\"Operation canceled by the user.\");\n        };\n    }, []);\n\n    return (\n        &lt;div&gt;\n            {error &amp;&amp; &lt;p&gt;Error: {error.message}&lt;/p&gt;}\n            {data ? &lt;pre&gt;{JSON.stringify(data, null, 2)}&lt;/pre&gt; : &lt;p&gt;Loading...&lt;/p&gt;}\n        &lt;/div&gt;\n    );\n};\n\nexport default MyComponent;\n</code></pre> <p>To cancel an Axios HTTP request in a cleanup function, you can use the CancelToken feature provided by Axios. This is useful in React components, especially when making requests in effects. Here's a step-by-step guide:</p> <ol> <li>Create a Cancel Token: Use <code>axios.CancelToken.source()</code> to create a cancel token source.</li> <li>Make the request with the token: Pass the token to your Axios request.</li> <li>Cancel the request in cleanup: In the cleanup function of your <code>useEffect</code>, call the <code>cancel</code> method on the cancel token.</li> </ol> <ul> <li>Cancel Token Creation: <code>const source = axios.CancelToken.source();</code> creates a new cancel token.</li> <li>Making the Request: The cancel token is passed to the request via <code>cancelToken: source.token</code>.</li> <li>Cleanup: In the cleanup function returned from <code>useEffect</code>, you call <code>source.cancel(...)</code> to cancel the request if the component unmounts before the request completes.</li> </ul> <p>This approach helps avoid potential memory leaks and unnecessary state updates if the component is unmounted during the request.</p>"},{"location":"frontend/js/httprequest/example/cancel-fetch-api/","title":"Cancel Fetch","text":"<pre><code>import React, { useEffect, useState } from 'react';\nimport './App.css';\nimport { Button } from 'antd';\n\nfunction App() {\n  const [data, setData] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  const fetchData = async (url, apiKey, signal) =&gt; {\n    try {\n      const response = await fetch(url, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        signal,\n      });\n\n      if (!response.ok) {\n        throw new Error('Network response was not ok');\n      }\n      const data = await response.json();\n      setData(data);\n    } catch (error) {\n      // setError(error);\n      if (error.name !== 'AbortError') { // Ignore AbortError errors\n        setError(error.message);\n        console.error('Fetch error:', error);\n      }\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  useEffect(() =&gt; {\n    const API_URL = process.env.REACT_APP_API_URL;\n    const API_KEY = process.env.REACT_APP_API_KEY;\n\n    const controller = new AbortController();\n    const signal = controller.signal;\n\n    fetchData(API_URL, API_KEY, signal);\n\n    return () =&gt; {\n      controller.abort();\n    };\n  }, [])\n\n  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n  if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;\n\n  return (\n    &lt;div className=\"App\"&gt;\n      &lt;Button\n          type=\"primary\"\n        &gt;Hello&lt;/Button&gt;\n      &lt;h1&gt;Data from API&lt;/h1&gt;\n      {/* &lt;pre&gt;{JSON.stringify(data, null, 2)}&lt;/pre&gt; */}\n    &lt;/div&gt;\n  );\n}\n\nexport default App;\n</code></pre>"},{"location":"frontend/js/httprequest/example/fetch-api-example/","title":"Fetch Api Example","text":""},{"location":"frontend/js/httprequest/example/fetch-api-example/#overview","title":"Overview","text":"<p>In this scenario, I'll show you how to make a request to an API, including the API key in the headers.</p>"},{"location":"frontend/js/httprequest/example/fetch-api-example/#example-react-component-using-fetch","title":"Example React Component Using <code>fetch</code>","text":"<p>Here's a simple React component that fetches data from an API that requires an API key:</p> ExampleExplanationCustomizing <pre><code>import React, { useState, useEffect } from 'react';\n\nfunction FetchExample() {\n    // State to hold data and loading status\n    const [data, setData] = useState(null);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n\n    useEffect(() =&gt; {\n        // Define your API endpoint and API key\n        const API_URL = 'https://api.example.com/data'; // Replace with your API URL\n        const API_KEY = 'your-api-key'; // Replace with your API key\n\n        // Fetch data from API\n        fetch(API_URL, {\n            method: 'GET',\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Bearer ${API_KEY}`, // Include the API key in headers\n            },\n            })\n            .then(response =&gt; {\n                if (!response.ok) {\n                throw new Error('Network response was not ok');\n                }\n                return response.json();\n            })\n            .then(data =&gt; {\n                setData(data);\n                setLoading(false);\n            })\n            .catch(error =&gt; {\n                setError(error);\n                setLoading(false);\n            });\n    }, []); // Empty dependency array means this runs once when the component mounts\n\n    // Render loading, error, or data\n    if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Data from API&lt;/h1&gt;\n            &lt;pre&gt;{JSON.stringify(data, null, 2)}&lt;/pre&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default FetchExample;\n</code></pre> <ol> <li> <p>State Management:</p> <ul> <li><code>data</code> is used to store the API response.</li> <li><code>loading</code> is used to indicate if the data is still being fetched.</li> <li><code>error</code> is used to store any error that occurs during the fetch.</li> </ul> </li> <li> <p><code>useEffect</code> Hook:</p> <ul> <li>The <code>useEffect</code> hook is used to perform the side effect of fetching data when the component mounts. The empty dependency array <code>[]</code> ensures this effect runs only once.</li> </ul> </li> <li> <p>Fetching Data:</p> <ul> <li><code>fetch(API_URL, { ... })</code> is used to make the GET request to the API.</li> <li>The <code>Authorization</code> header is used to include the API key. Replace <code>Bearer ${API_KEY}</code> with the appropriate header format if your API uses a different scheme.</li> <li>The response is checked for success and converted to JSON.</li> </ul> </li> <li> <p>Error Handling:</p> <ul> <li>If the response is not ok, an error is thrown. Any errors during the fetch process are caught and stored in the <code>error</code> state.</li> </ul> </li> <li> <p>Rendering:</p> <ul> <li>The component conditionally renders based on the state: showing loading, error, or the fetched data.</li> </ul> </li> </ol> <ul> <li>Replace <code>https://api.example.com/data</code> with your actual API endpoint.</li> <li>Replace <code>your-api-key</code> with your actual API key.</li> <li>Modify the headers as needed based on the requirements of your API.</li> </ul> <p>This example provides a basic structure for making API requests with <code>fetch</code> in a React component and should be adaptable to most scenarios where an API key is required.</p>"},{"location":"frontend/js/httprequest/example/fetch-api-example/#optimized-example-react-component","title":"Optimized Example React Component","text":"ExampleImprovements and ExplanationsAdditional Considerations <pre><code>import React, { useState, useEffect } from 'react';\n\nfunction FetchExample() {\n    const [data, setData] = useState(null);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n\n    useEffect(() =&gt; {\n        // Define the API request function\n        const fetchData = async () =&gt; {\n        const API_URL = 'https://api.example.com/data'; // Replace with your API URL\n        const API_KEY = 'your-api-key'; // Replace with your API key\n\n        try {\n            const response = await fetch(API_URL, {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${API_KEY}`, // Include the API key in headers\n                },\n            });\n\n            if (!response.ok) {\n                throw new Error('Network response was not ok');\n            }\n\n            const result = await response.json();\n            setData(result);\n        } catch (err) {\n            setError(err);\n        } finally {\n            setLoading(false);\n        }\n        };\n\n        fetchData();\n    }, []); // Empty dependency array means this runs once when the component mounts\n\n    // Render loading, error, or data\n    if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Data from API&lt;/h1&gt;\n            &lt;pre&gt;{JSON.stringify(data, null, 2)}&lt;/pre&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default FetchExample;\n</code></pre> <ol> <li> <p>Async/Await Syntax:</p> <ul> <li>Using <code>async/await</code> makes the code cleaner and easier to read compared to using <code>.then()</code> and <code>.catch()</code>.</li> </ul> </li> <li> <p>Error Handling:</p> <ul> <li>The <code>try/catch</code> block handles errors from both the network request and JSON parsing. This makes the error handling more robust.</li> </ul> </li> <li> <p>Loading State:</p> <ul> <li>The <code>finally</code> block ensures that the <code>loading</code> state is set to <code>false</code> whether the request succeeds or fails.</li> </ul> </li> <li> <p>API Request Function:</p> <ul> <li>Extracting the API request logic into a separate <code>fetchData</code> function inside <code>useEffect</code> helps to keep the effect clean and more readable.</li> </ul> </li> </ol> <ol> <li> <p>Environment Variables:</p> <ul> <li>For security, consider using environment variables to store sensitive information like API keys. Create a <code>.env</code> file in the root of your project and add your API key there:</li> </ul> <pre><code>REACT_APP_API_KEY=your-api-key\n</code></pre> <p>Access this variable in your component:</p> <pre><code>const API_KEY = process.env.REACT_APP_API_KEY;\n</code></pre> </li> <li> <p>Abort Controller:</p> <ul> <li> <p>If your component might unmount before the fetch completes, consider using an <code>AbortController</code> to cancel the request. Here\u2019s how to integrate it:</p> <pre><code>useEffect(() =&gt; {\n    const controller = new AbortController();\n    const signal = controller.signal;\n\n    const fetchData = async () =&gt; {\n        const API_URL = 'https://api.example.com/data';\n        const API_KEY = process.env.REACT_APP_API_KEY;\n\n        try {\n            const response = await fetch(API_URL, {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${API_KEY}`,\n                },\n                signal,\n            });\n\n            if (!response.ok) {\n                throw new Error('Network response was not ok');\n            }\n\n            const result = await response.json();\n            setData(result);\n        } catch (err) {\n            if (err.name === 'AbortError') {\n                console.log('Fetch aborted');\n            } else {\n                setError(err);\n            }\n        } finally {\n            setLoading(false);\n        }\n    };\n\n    fetchData();\n\n    return () =&gt; controller.abort();\n}, []);\n</code></pre> </li> <li> <p>This way, if the component unmounts before the fetch is completed, the request will be aborted, preventing potential memory leaks.</p> </li> </ul> </li> </ol> <p>By incorporating these optimizations, your code will be more maintainable, readable, and robust.</p>"},{"location":"frontend/js/httprequest/example/fetch-api-example/#cleaner-code","title":"Cleaner Code","text":"ExampleExplanationSummary <pre><code>import React, { useState, useEffect } from 'react';\n\nfunction FetchExample() {\n    // State to hold data and loading status\n    const [data, setData] = useState(null);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n\n    // Define the fetch function inside the component\n    const fetchData = async (url, apiKey) =&gt; {\n        try {\n            const response = await fetch(url, {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${apiKey}`, // Include the API key in headers\n                },\n            });\n\n            if (!response.ok) {\n                throw new Error('Network response was not ok');\n            }\n\n            const data = await response.json();\n            setData(data);\n        } catch (error) {\n            setError(error);\n        } finally {\n            setLoading(false);\n        }\n    };\n\n    useEffect(() =&gt; {\n        // Define your API endpoint and API key\n        const API_URL = 'https://api.example.com/data'; // Replace with your API URL\n        const API_KEY = 'your-api-key'; // Replace with your API key\n\n        fetchData(API_URL, API_KEY);\n    }, []); // Empty dependency array means this runs once when the component mounts\n\n    // Render loading, error, or data\n    if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Data from API&lt;/h1&gt;\n            &lt;pre&gt;{JSON.stringify(data, null, 2)}&lt;/pre&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default FetchExample;\n</code></pre> <ol> <li> <p>Function Definition Inside Component:</p> <ul> <li>The <code>fetchData</code> function is defined inside the <code>FetchExample</code> component. This approach makes sense when the function is closely tied to the component\u2019s logic and isn\u2019t reused elsewhere.</li> </ul> </li> <li> <p>Encapsulation:</p> <ul> <li>Keeping the <code>fetchData</code> function within the component encapsulates its behavior and dependencies. This can be useful for maintaining a clear connection between the function and the component state it operates on.</li> </ul> </li> <li> <p>Cleaner and More Readable:</p> <ul> <li>Defining the function inside keeps related code together, which can be beneficial for readability and maintainability, especially for simpler components.</li> </ul> </li> <li> <p>Code Organization:</p> <ul> <li>If the <code>fetchData</code> function were to become more complex or be used across multiple components, you might consider moving it to a separate file or utility module. For now, defining it inside the component is suitable.</li> </ul> </li> <li> <p>React Best Practices:</p> <ul> <li>Both approaches (defining the function inside or outside the component) are valid. Choosing between them depends on factors like the complexity of the function, code reusability, and personal or team coding preferences.</li> </ul> </li> </ol> <p>For the given example, defining the <code>fetchData</code> function inside the <code>FetchExample</code> component keeps the code compact and easier to understand, especially if the function is specific to that component. It\u2019s a matter of balancing between code clarity, modularity, and maintainability based on the context and complexity of the function.</p>"},{"location":"frontend/js/httprequest/example/overview/","title":"Overview","text":"<p>fsdafdf</p>"},{"location":"frontend/js/httprequest/example/useReducer/","title":"useReducer","text":"<p>Using <code>useReducer</code> instead of <code>useState</code> hooks.</p> fetchasync/await <pre><code>import { useReducer, useEffect } from 'react';\n\nconst initialState = { data: null, loading: true, error: null };\n\nfunction reducer(state, action) {\n    switch (action.type) {\n        case 'FETCH_SUCCESS':\n            return { ...state, data: action.payload, loading: false };\n        case 'FETCH_ERROR':\n            return { ...state, error: action.payload, loading: false };\n        default:\n            throw new Error();\n    }\n}\n\nfunction Example() {\n    const [state, dispatch] = useReducer(reducer, initialState);\n\n    useEffect(() =&gt; {\n        fetch('https://api.example.com/data')\n            .then(response =&gt; response.json())\n            .then(data =&gt; dispatch({ type: 'FETCH_SUCCESS', payload: data }))\n            .catch(error =&gt; dispatch({ type: 'FETCH_ERROR', payload: error }));\n    }, []);\n\n    if (state.loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (state.error) return &lt;div&gt;Error: {state.error.message}&lt;/div&gt;;\n\n    return &lt;div&gt;{JSON.stringify(state.data)}&lt;/div&gt;;\n}\n</code></pre> ExampleExplanationChanges Made <pre><code>import { useReducer, useEffect } from 'react';\n\nconst initialState = { data: null, loading: true, error: null };\n\nfunction reducer(state, action) {\n    switch (action.type) {\n        case 'FETCH_SUCCESS':\n            return { ...state, data: action.payload, loading: false };\n        case 'FETCH_ERROR':\n            return { ...state, error: action.payload, loading: false };\n        default:\n            throw new Error();\n    }\n}\n\nfunction Example() {\n    const [state, dispatch] = useReducer(reducer, initialState);\n\n    useEffect(() =&gt; {\n        // Define an async function inside useEffect\n        const fetchData = async () =&gt; {\n            try {\n                const response = await fetch('https://api.example.com/data');\n                if (!response.ok) {\n                    throw new Error('Network response was not ok');\n                }\n                const data = await response.json();\n                dispatch({ type: 'FETCH_SUCCESS', payload: data });\n            } catch (error) {\n                dispatch({ type: 'FETCH_ERROR', payload: error });\n            }\n        };\n\n        fetchData(); // Call the async function\n    }, []);\n\n    if (state.loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (state.error) return &lt;div&gt;Error: {state.error.message}&lt;/div&gt;;\n\n    return &lt;div&gt;{JSON.stringify(state.data)}&lt;/div&gt;;\n}\n\nexport default Example;\n</code></pre> <p>Certainly! To convert the code to use <code>async/await</code>, you'll need to make some adjustments to the <code>useEffect</code> hook. Here\u2019s how you can update it:</p> <ul> <li>Define an <code>async</code> function inside <code>useEffect</code> to handle the asynchronous fetch operation.</li> <li>Call this <code>async</code> function immediately within <code>useEffect</code>.</li> </ul> <ul> <li>Added an <code>async</code> function inside the <code>useEffect</code> hook to perform the fetch operation.</li> <li>Called <code>await</code> on the fetch function and <code>.json()</code> to handle promises with <code>async/await</code>.</li> <li>Added a check to throw an error if the response is not ok (to handle HTTP errors).</li> </ul> <p>This approach makes the asynchronous code cleaner and easier to read compared to using <code>.then</code> and <code>.catch</code>.</p>"},{"location":"frontend/js/httprequest/example/useReducer/#making-code-modular","title":"Making Code Modular","text":"<p>can we separate the api call to api folder</p> <p>Yes, separating the API call into a dedicated file or folder is a great idea for better organization and maintainability. You can create a separate module for the API call and then import it into your component. Here\u2019s how you can do that:</p> Step 1: Create an API UtilityStep 2: Update Your Component <ol> <li>Create a new file in your project, for example, <code>api.js</code> or <code>api.ts</code> if you're using TypeScript. You might place it in an <code>api</code> folder or similar.</li> <li>Define the API call function in this file. For instance, you can create a function that fetches data from the API:</li> </ol> <pre><code>// api/api.js\n\nexport async function fetchData() {\n    const response = await fetch('https://api.example.com/data');\n    if (!response.ok) {\n        throw new Error('Network response was not ok');\n    }\n    const data = await response.json();\n    return data;\n}\n</code></pre> <ol> <li>Import the API function into your component file.</li> <li>Use the imported function inside the <code>useEffect</code> hook.</li> </ol> <p>Here\u2019s how you can modify your <code>Example</code> component:</p> <pre><code>import { useReducer, useEffect } from 'react';\nimport { fetchData } from './api/api'; // Adjust the import path according to your folder structure\n\nconst initialState = { data: null, loading: true, error: null };\n\nfunction reducer(state, action) {\n    switch (action.type) {\n        case 'FETCH_SUCCESS':\n            return { ...state, data: action.payload, loading: false };\n        case 'FETCH_ERROR':\n            return { ...state, error: action.payload, loading: false };\n        default:\n            throw new Error();\n    }\n}\n\nfunction Example() {\n    const [state, dispatch] = useReducer(reducer, initialState);\n\n    useEffect(() =&gt; {\n        // Define an async function inside useEffect\n        const fetchDataFromAPI = async () =&gt; {\n            try {\n                const data = await fetchData();\n                dispatch({ type: 'FETCH_SUCCESS', payload: data });\n            } catch (error) {\n                dispatch({ type: 'FETCH_ERROR', payload: error });\n            }\n        };\n\n        fetchDataFromAPI(); // Call the async function\n    }, []);\n\n    if (state.loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (state.error) return &lt;div&gt;Error: {state.error.message}&lt;/div&gt;;\n\n    return &lt;div&gt;{JSON.stringify(state.data)}&lt;/div&gt;;\n}\n\nexport default Example;\n</code></pre>"},{"location":"frontend/js/httprequest/example/useReducer/#summary","title":"Summary","text":"<ul> <li><code>api/api.js</code>: Contains the <code>fetchData</code> function that performs the API request.</li> <li>Component: Imports <code>fetchData</code> and uses it within the <code>useEffect</code> hook.</li> </ul> <p>This separation makes your component code cleaner and adheres to the principle of separation of concerns.</p>"},{"location":"frontend/js/httprequest/example/useReducer/#reducerjs","title":"<code>reducer.js</code>","text":"<p>can we use <code>reducer.js</code> without using redux</p> <p>Yes, you can use a reducer pattern without Redux. The reducer concept is a fundamental part of state management in JavaScript, often associated with the \"Reducer\" pattern used in libraries like Redux. However, you can implement similar functionality directly in your components or custom hooks.</p> <p>Using Reducers Without Redux</p> <p>You can utilize the <code>useReducer</code> hook provided by React to manage complex state logic without Redux. Here's a simple example:</p> <ol> <li>Basic Example of useReducer</li> </ol> ExampleExplanationAdvantages of Using <code>useReducer</code> <pre><code>import React, { useReducer } from \"react\";\n\n// Define the initial state\nconst initialState = {\n  loading: false,\n  data: null,\n  error: null,\n};\n\n// Define the reducer function\nconst reducer = (state, action) =&gt; {\n  switch (action.type) {\n    case \"FETCH_DATA_REQUEST\":\n      return { ...state, loading: true, error: null };\n    case \"FETCH_DATA_SUCCESS\":\n      return { ...state, loading: false, data: action.payload };\n    case \"FETCH_DATA_FAILURE\":\n      return { ...state, loading: false, error: action.payload };\n    default:\n      return state;\n  }\n};\n\nconst MyComponent = () =&gt; {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  const fetchData = async () =&gt; {\n    dispatch({ type: \"FETCH_DATA_REQUEST\" });\n    try {\n      const response = await fetch(\"https://api.example.com/data\");\n      const data = await response.json();\n      dispatch({ type: \"FETCH_DATA_SUCCESS\", payload: data });\n    } catch (error) {\n      dispatch({ type: \"FETCH_DATA_FAILURE\", payload: error.message });\n    }\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;button onClick={fetchData}&gt;Fetch Data&lt;/button&gt;\n\n      {state.loading &amp;&amp; &lt;p&gt;Loading...&lt;/p&gt;}\n      {state.error &amp;&amp; &lt;p&gt;Error: {state.error}&lt;/p&gt;}\n      {state.data &amp;&amp; &lt;pre&gt;{JSON.stringify(state.data, null, 2)}&lt;/pre&gt;}\n    &lt;/div&gt;\n  );\n};\n\nexport default MyComponent;\n</code></pre> <ul> <li>Initial State: You define an initial state object to represent your component's state.</li> <li>Reducer Function: The <code>reducer</code> function processes actions and returns a new state based on the action type.</li> <li>useReducer Hook: The <code>useReducer</code> hook is used to initialize state and provide a dispatch function to send actions.</li> <li>Fetch Logic: The <code>fetchData</code> function handles the API call and dispatches actions based on the result.</li> </ul> <ul> <li>State Management: It provides a way to manage complex state logic without external libraries.</li> <li>Clear Structure: It organizes state transitions clearly with a central reducer function.</li> <li>Component Scope: The state is scoped to the component, avoiding potential conflicts with other components.</li> </ul> Summary <p>You can absolutely use a reducer pattern with <code>useReducer</code> in React without Redux. This approach is particularly useful for managing local state in a component, especially when dealing with complex state transitions or multiple related state variables.</p>"},{"location":"frontend/js/httprequest/example/useReducer/#reducer-pattern","title":"reducer pattern","text":"<p>The reducer pattern is a design pattern commonly used in state management to handle state changes in a predictable way. It is particularly well-known in libraries like Redux but can be applied in various contexts, including React\u2019s <code>useReducer</code> hook. Here\u2019s a breakdown of the reducer pattern:</p> Key Concepts of the Reducer Pattern <ol> <li> <p>Pure Function:</p> <ul> <li>A reducer is a pure function that takes the current state and an action as arguments and returns a new state.</li> <li>It does not mutate the existing state; instead, it creates a new state object based on the provided action.</li> </ul> </li> <li> <p>State Management:</p> <ul> <li>The reducer handles the state transitions of an application or component based on the actions dispatched to it.</li> <li>Each action represents a specific type of change (e.g., fetching data, updating values, handling errors).</li> </ul> </li> <li> <p>Actions:</p> <ul> <li>Actions are plain JavaScript objects that describe what happened in the application. Each action typically has a <code>type</code> property (a string) and may have a <code>payload</code> containing additional data.</li> </ul> </li> <li> <p>Initial State:</p> <ul> <li>The reducer starts with an initial state that defines the starting conditions for the application or component.</li> </ul> </li> </ol> Structure of a Reducer <p>A typical reducer looks like this:</p> <pre><code>const initialState = {\n    count: 0,\n    loading: false,\n    error: null,\n};\n\nconst reducer = (state, action) =&gt; {\n    switch (action.type) {\n        case 'INCREMENT':\n            return { ...state, count: state.count + 1 };\n        case 'DECREMENT':\n            return { ...state, count: state.count - 1 };\n        case 'FETCH_REQUEST':\n            return { ...state, loading: true, error: null };\n        case 'FETCH_SUCCESS':\n            return { ...state, loading: false, data: action.payload };\n        case 'FETCH_FAILURE':\n            return { ...state, loading: false, error: action.payload };\n        default:\n            return state;\n    }\n};\n</code></pre> <p>Example of Using a Reducer</p> ExampleAdvantages of the Reducer Pattern <p>Here\u2019s an example using the <code>useReducer</code> hook in a React component:</p> <pre><code>import React, { useReducer } from \"react\";\n\nconst initialState = { count: 0 };\n\nconst reducer = (state, action) =&gt; {\n    switch (action.type) {\n        case \"INCREMENT\":\n            return { ...state, count: state.count + 1 };\n        case \"DECREMENT\":\n            return { ...state, count: state.count - 1 };\n        default:\n            return state;\n    }\n};\n\nconst Counter = () =&gt; {\n    const [state, dispatch] = useReducer(reducer, initialState);\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;{state.count}&lt;/h1&gt;\n            &lt;button onClick={() =&gt; dispatch({ type: \"INCREMENT\" })}&gt;Increment&lt;/button&gt;\n            &lt;button onClick={() =&gt; dispatch({ type: \"DECREMENT\" })}&gt;Decrement&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Counter;\n</code></pre> <ul> <li>Predictability: Since the reducer is a pure function, given the same input (state and action), it will always produce the same output. This makes debugging and testing easier.</li> <li>Separation of Concerns: The reducer separates the logic for updating the state from the UI components, improving code organization and maintainability.</li> <li>Centralized State Management: By using a reducer, you centralize the state management logic, making it easier to understand and modify.</li> </ul> Conclusion <p>The reducer pattern is a powerful tool for managing state in applications, especially when state logic is complex. It promotes a clear and predictable way to handle state transitions and is widely used in modern JavaScript frameworks and libraries.</p>"},{"location":"frontend/js/json/intro/","title":"Intro","text":"<p>JSON or JavaScript Object Notation is a very popular data interchange format. It was developed by Douglas Crockford. JSON is text-based, lightweight, and a human-readable format for data exchange between clients and servers. JSON is derived from JavaScript and bears a close resemblance to JavaScript objects, but it is not dependent on JavaScript. JSON is language-independent, and support for the JSON data format is available in all the popular languages, some of which are C#, PHP, Java, C++, Python, and Ruby.</p> <p>JSON is a format and not a language.</p> <p>JSON can be used in web applications for data transfer. Prior to JSON, XML was considered to be the chosen data interchange format. </p>"},{"location":"frontend/js/json/intro/#datatypes-in-json","title":"Datatypes in JSON","text":"<p>Tip</p> <p>JSON supports six datatypes: </p> <ol> <li>strings, </li> <li>numbers, </li> <li>Booleans, </li> <li>arrays, </li> <li>objects, &amp; </li> <li>null.</li> </ol> <ul> <li>JavaScript and JSON Essentials by Sai Srinivas Sriparasa: 2013 Packt Publishing</li> </ul>"},{"location":"frontend/js/json/json5/","title":"Json and .Json5","text":"<p>The main difference between <code>.json</code> and <code>.json5</code> lies in their syntax and flexibility:</p> <ol> <li> <p>JSON (<code>.json</code>):</p> <ul> <li>Stands for JavaScript Object Notation.</li> <li>It is a strict, lightweight data-interchange format.</li> <li>Syntax rules are rigid, requiring:<ul> <li>Double quotes around property names.</li> <li>No trailing commas.</li> <li>No comments allowed.</li> <li>Only strings, numbers, arrays, booleans, null, and objects are valid.</li> </ul> </li> </ul> <pre><code>{\n    \"name\": \"John\",\n    \"age\": 30,\n    \"isStudent\": false\n}\n</code></pre> </li> <li> <p>JSON5 (<code>.json5</code>):</p> <ul> <li>Stands for JSON for Humans, an extension of JSON.</li> <li>It is more flexible and user-friendly, allowing:<ul> <li>Single quotes for strings.</li> <li>Trailing commas.</li> <li>Unquoted property names if valid identifiers.</li> <li>Comments (both single-line <code>//</code> and multi-line <code>/* */</code>).</li> <li>Support for additional data types like <code>Infinity</code>, <code>NaN</code>, and hexadecimal numbers.</li> </ul> </li> </ul> <pre><code>{\n    name: 'John',  // Unquoted property names, single quotes\n    age: 30,       // Trailing commas allowed\n    isStudent: false,  // Comments allowed\n}\n</code></pre> </li> </ol> <p>In summary, JSON5 relaxes some of the strict rules of JSON, making it more human-friendly for editing, while <code>.json</code> is more standardized and widely supported.</p>"},{"location":"frontend/js/json/json5/#json-interesting-topic","title":"JSON interesting topic","text":"<p>Here are some interesting aspects of JSON and how you can maximize its usage:</p> <ol> <li> <p>JSON Schema Validation</p> <ul> <li>What it is: JSON Schema is a powerful tool for validating the structure of JSON data.</li> <li>Why it's interesting: It ensures that your JSON data conforms to a specific format, making it easier to validate inputs and outputs in APIs.</li> <li>How to use it: You can define a schema and use libraries like <code>Ajv</code> (in JavaScript) to validate your data.</li> </ul> <pre><code>{\n    \"type\": \"object\",\n    \"properties\": {\n        \"name\": { \"type\": \"string\" },\n        \"age\": { \"type\": \"integer\" }\n    },\n    \"required\": [\"name\", \"age\"]\n}\n</code></pre> </li> <li> <p>JSON Web Tokens (JWT)</p> <ul> <li>What it is: JWT is a compact, URL-safe means of representing claims to be transferred between two parties.</li> <li>Why it's interesting: JWTs are widely used for authentication and authorization in web applications.</li> <li>How to use it: You can encode and decode JWTs using libraries like <code>jsonwebtoken</code> in Node.js, sending tokens in HTTP headers to secure APIs.</li> </ul> <pre><code>{\n    \"alg\": \"HS256\",\n    \"typ\": \"JWT\"\n}\n{\n    \"sub\": \"1234567890\",\n    \"name\": \"John Doe\",\n    \"iat\": 1516239022\n}\n</code></pre> </li> <li> <p>JSON with Local Storage</p> <ul> <li>What it is: Storing data in a browser's localStorage or sessionStorage.</li> <li>Why it's interesting: You can persist JSON data locally, making it useful for offline applications or user preferences.</li> <li> <p>How to use it:</p> <pre><code>// Storing\nconst user = { name: \"John\", age: 30 };\nlocalStorage.setItem('user', JSON.stringify(user));\n\n// Retrieving\nconst storedUser = JSON.parse(localStorage.getItem('user'));\n</code></pre> </li> </ul> </li> <li> <p>JSON with IndexedDB</p> <ul> <li>What it is: A client-side database that stores complex data (like JSON objects).</li> <li>Why it's interesting: IndexedDB allows you to store and retrieve large amounts of structured data, which is more powerful than localStorage.</li> <li>How to use it: You can store complex data like objects and arrays natively.</li> </ul> <pre><code>const dbRequest = indexedDB.open(\"MyDatabase\");\ndbRequest.onsuccess = function(event) {\n    const db = event.target.result;\n    const transaction = db.transaction(\"myStore\", \"readwrite\");\n    const store = transaction.objectStore(\"myStore\");\n    store.add({ id: 1, name: \"John\", age: 30 });\n};\n</code></pre> </li> <li> <p>JSON Patch (RFC 6902)</p> <ul> <li>What it is: JSON Patch is a format for expressing a list of operations to apply to a JSON document.</li> <li>Why it's interesting: It\u2019s used for efficient partial updates, especially in scenarios where you only want to update specific fields.</li> <li>How to use it: Using libraries like <code>fast-json-patch</code> in JavaScript to apply patches.</li> </ul> <pre><code>[\n    { \"op\": \"replace\", \"path\": \"/name\", \"value\": \"Jane\" },\n    { \"op\": \"remove\", \"path\": \"/age\" }\n]\n</code></pre> </li> <li> <p>JSON Streaming</p> <ul> <li>What it is: JSON Streaming allows large JSON datasets to be processed in chunks rather than loading the entire document at once.</li> <li>Why it's interesting: It's useful for handling big data without crashing the browser or server due to memory overload.</li> <li>How to use it: Tools like <code>stream-json</code> in Node.js can parse large JSON datasets in chunks.</li> </ul> <pre><code>const { parser } = require('stream-json');\nconst fs = require('fs');\nfs.createReadStream('large-file.json').pipe(parser()).on('data', (chunk) =&gt; {\n    console.log(chunk);\n});\n</code></pre> </li> <li> <p>JSON with GraphQL</p> <ul> <li>What it is: JSON is the default format for sending and receiving data in GraphQL APIs.</li> <li>Why it's interesting: GraphQL APIs allow clients to request specific data in JSON format, reducing over-fetching common in REST APIs.</li> <li>How to use it: You define queries in GraphQL, and responses are returned as JSON.</li> </ul> <pre><code>query {\n    user(id: 1) {\n        name\n        age\n    }\n}\n</code></pre> JSON Response:<pre><code>{\n    \"data\": {\n        \"user\": {\n        \"name\": \"John\",\n        \"age\": 30\n        }\n    }\n}\n</code></pre> </li> <li> <p>JSONPath for Querying JSON</p> <ul> <li>What it is: JSONPath is a query language for extracting values from JSON documents (similar to XPath for XML).</li> <li>Why it's interesting: JSONPath allows for complex querying of deeply nested JSON objects.</li> <li>How to use it: Using libraries like <code>jsonpath</code> in JavaScript.</li> </ul> <pre><code>{\n    \"store\": {\n        \"book\": [\n            { \"category\": \"fiction\", \"title\": \"The Great Gatsby\" },\n            { \"category\": \"drama\", \"title\": \"Hamlet\" }\n        ]\n    }\n}\n</code></pre> Query:<pre><code>jsonpath.query(data, '$.store.book[?(@.category==\"fiction\")]');\n</code></pre> </li> <li> <p>JSON Serialization and Deserialization</p> <ul> <li>What it is: Converting objects to JSON format (serialization) and parsing JSON back into objects (deserialization).</li> <li>Why it's interesting: Most web APIs rely on this mechanism for data interchange.</li> <li> <p>How to use it:</p> <pre><code>const obj = { name: \"John\", age: 30 };\nconst jsonStr = JSON.stringify(obj);  // Serialize\nconst parsedObj = JSON.parse(jsonStr);  // Deserialize\n</code></pre> </li> </ul> </li> <li> <p>JSON Transformations with Lodash</p> <ul> <li>What it is: Using utility libraries like Lodash to manipulate JSON objects efficiently.</li> <li>Why it's interesting: Lodash offers powerful tools for querying, filtering, and transforming JSON data.</li> <li> <p>How to use it:</p> <pre><code>const data = [{ name: 'John', age: 30 }, { name: 'Jane', age: 25 }];\nconst adults = _.filter(data, user =&gt; user.age &gt;= 18);\n</code></pre> </li> </ul> </li> <li> <p>JSON for Configuration Files</p> <ul> <li>What it is: JSON is often used as a format for configuration files, especially in web development (<code>package.json</code>, <code>.babelrc</code>).</li> <li>Why it's interesting: Storing settings and configurations in JSON is easy to read, write, and manipulate programmatically.</li> <li>How to use it: You can use JSON in Node.js or other backends to dynamically load and parse configuration settings.</li> </ul> </li> <li> <p>JSON with REST APIs</p> <ul> <li>What it is: JSON is the most common data format used for sending and receiving data via REST APIs.</li> <li>Why it's interesting: Knowing how to effectively work with JSON in REST APIs ensures you build scalable, maintainable systems.</li> <li> <p>How to use it:  </p> <pre><code>fetch('https://api.example.com/data')\n.then(response =&gt; response.json())\n.then(data =&gt; console.log(data));\n</code></pre> </li> </ul> </li> </ol> <p>By learning these techniques, you can leverage the full potential of JSON in various real-world applications, from API development to efficient data management and beyond.</p>"},{"location":"frontend/js/json/json5/#js-topic","title":"JS Topic","text":"<p>Here are some interesting topics you might want to explore as you continue deepening your knowledge, especially considering your focus on becoming a top-tier developer:</p> <ol> <li> <p>Advanced JavaScript Concepts</p> <ul> <li>Closures and Currying: Understanding these will help you write more efficient and readable code.</li> <li>Event Loop and Async/Await: Mastering how JavaScript handles asynchronous operations can enhance performance in complex applications.</li> <li>Prototypes and Inheritance: Dig deeper into object-oriented principles in JavaScript.</li> <li>Functional Programming: Concepts like immutability, pure functions, and higher-order functions can transform how you approach problems.</li> </ul> </li> <li> <p>React Ecosystem</p> <ul> <li>React Performance Optimization: Learn techniques such as memoization (useMemo, useCallback), lazy loading, and code splitting.</li> <li>React Hooks: Mastering custom hooks and using built-in hooks like useReducer for complex state management.</li> <li>React Suspense and Concurrent Mode: These will shape the future of React apps, enabling better UX with async data fetching.</li> <li>Server-Side Rendering (SSR) with Next.js: Explore Next.js for building SEO-friendly React apps.</li> </ul> </li> <li> <p>State Management (Advanced Redux)</p> <ul> <li>Redux Toolkit: Learn the modern way to manage state with Redux's streamlined syntax and enhanced development experience.</li> <li>Context API: It\u2019s lightweight compared to Redux but excellent for certain types of global state management.</li> <li>Middleware in Redux: Thunk, Saga, and custom middleware for managing side effects.</li> </ul> </li> <li> <p>TypeScript</p> <ul> <li>Type Inference &amp; Generics: Learn how to leverage TypeScript's static typing for cleaner, more maintainable code.</li> <li>TypeScript in React and Node.js: Understanding how to use TypeScript in both frontend and backend can be a game changer.</li> </ul> </li> <li> <p>Advanced APIs &amp; Web Technologies</p> <ul> <li>GraphQL: A flexible, efficient alternative to REST APIs. Learn about querying and mutations with GraphQL.</li> <li>WebSockets: Real-time communication for applications like chats, notifications, or live updates.</li> <li>Service Workers: Understanding how to implement Progressive Web Apps (PWAs) with offline capabilities.</li> </ul> </li> <li> <p>Full-Stack Development</p> <ul> <li>Django with React/Next.js: Explore integrating frontend frameworks with powerful backends like Django.</li> <li>Microservices Architecture: Learn how to split large applications into smaller, independent services for scalability and maintainability.</li> <li>API Design Principles: RESTful APIs, versioning, and security considerations like JWT (JSON Web Token).</li> </ul> </li> <li> <p>Databases and Data Management</p> <ul> <li>NoSQL vs. SQL: Learn the differences and when to use MongoDB vs PostgreSQL/MySQL.</li> <li>Database Indexing and Optimization: Mastering these techniques will enhance database performance.</li> <li>Graph Databases: Explore databases like Neo4j for relationship-heavy data (e.g., for your dating app).</li> </ul> </li> <li> <p>Advanced DevOps and CI/CD</p> <ul> <li>Containerization with Docker: Packaging applications into containers for easier deployment.</li> <li>Kubernetes: Managing containerized applications at scale using Kubernetes clusters.</li> <li>CI/CD Pipelines: Automate testing, integration, and deployment with tools like GitLab CI, Jenkins, or GitHub Actions.</li> </ul> </li> <li> <p>Cloud and Serverless Computing</p> <ul> <li>AWS, Google Cloud, or Azure: Master cloud platforms to deploy, manage, and scale applications.</li> <li>Serverless Functions (AWS Lambda, Firebase Functions): Writing and deploying code without managing servers.</li> <li>Cloud Databases and Storage: Using cloud services for data persistence and management.</li> </ul> </li> <li> <p>Software Architecture &amp; Design Patterns</p> <ul> <li>SOLID Principles: These principles will help in writing scalable and maintainable code.</li> <li>Design Patterns: Explore patterns like Singleton, Factory, Observer, etc.</li> <li>Monolithic vs Microservices: Understand when to use each approach.</li> </ul> </li> <li> <p>Security Best Practices</p> <ul> <li>OWASP Top 10: Understanding the most common security vulnerabilities in web applications.</li> <li>Encryption and Authentication: JWT, OAuth2, and bcrypt for hashing passwords.</li> <li>Security in APIs: Preventing XSS, CSRF, and implementing secure HTTP headers.</li> </ul> </li> <li> <p>Mobile App Development</p> <ul> <li>React Native: Since you are already working on a dating app, mastering React Native will help build cross-platform mobile applications.</li> <li>Mobile Optimization: Techniques for performance and UX improvements on mobile devices.</li> <li>Firebase or Traditional Database for Mobile: Integrating real-time databases and authentication in mobile apps.</li> </ul> </li> <li> <p>Machine Learning Basics for Web Developers</p> <ul> <li>TensorFlow.js: Learn how to run machine learning models in the browser.</li> <li>Basic Data Science Concepts: Learn about linear regression, decision trees, and clustering algorithms.</li> <li>Recommendation Systems: Especially useful for personalized applications like a dating app.</li> </ul> </li> <li> <p>GraphQL with Apollo Client</p> <ul> <li>Advanced Querying: Learn about fragments, inline arguments, and directives.</li> <li>Cache Management: Understanding Apollo Client's caching strategies.</li> </ul> </li> <li> <p>Testing and Quality Assurance</p> <ul> <li>Unit, Integration, and E2E Testing: Master tools like Jest, Mocha, Cypress, and React Testing Library.</li> <li>TDD and BDD: Learn Test-Driven Development and Behavior-Driven Development to write better, bug-free code.</li> </ul> </li> <li> <p>Code Management and Collaboration</p> <ul> <li>Git Workflows: Learn about different Git workflows like GitFlow, feature branching, and rebasing.</li> <li>Monorepos: How large companies use tools like Lerna and Nx to manage multiple projects in a single repository.</li> </ul> </li> </ol> <p>These topics can significantly boost your understanding and skillset across modern development paradigms. You can explore them based on your interests and project needs!</p> what is difference between conntecting mysql and postgress. in ubuntu in need to install to connect django with mysql what i need to do in postgress <p>When setting up Django with MySQL versus PostgreSQL on Ubuntu, the installation and configuration processes differ slightly due to the differences in the database systems.</p> <p>Here\u2019s a breakdown of what you need to do for each:</p>"},{"location":"frontend/js/json/json5/#connecting-django-to-mysql","title":"Connecting Django to MySQL","text":"<ol> <li> <p>Install MySQL Server:</p> <ul> <li> <p>Open a terminal and install MySQL server with the following command:</p> <pre><code>sudo apt update\nsudo apt install mysql-server\n</code></pre> </li> </ul> </li> <li> <p>Install MySQL Client Libraries:</p> <ul> <li> <p>You need the MySQL client libraries to interface with MySQL from Python. Install them with:</p> <pre><code>sudo apt install libmysqlclient-dev\n</code></pre> </li> </ul> </li> <li> <p>Install Django MySQL Adapter:</p> <ul> <li> <p>You need the <code>mysqlclient</code> package for Django to connect to MySQL. Install it using pip:</p> <pre><code>pip install mysqlclient\n</code></pre> </li> </ul> </li> <li> <p>Configure Django Settings:</p> <ul> <li> <p>In your <code>settings.py</code>, configure the database settings for <code>MySQL</code>:</p> <pre><code>    DATABASES = {\n        'default': {\n            'ENGINE': 'django.db.backends.mysql',\n            'NAME': 'your_database_name',\n            'USER': 'your_username',\n            'PASSWORD': 'your_password',\n            'HOST': 'localhost',\n            'PORT': '3306',\n        }\n    }\n</code></pre> </li> </ul> </li> </ol> <p>Summary</p> <ul> <li>MySQL: You need to install <code>mysql-server</code>, <code>libmysqlclient-dev</code>, and <code>mysqlclient</code>.</li> </ul> <p>In both cases, after setting up the database server and installing the required Python packages, you'll configure your <code>settings.py</code> file in Django to connect to the database you have chosen.</p>"},{"location":"frontend/js/miscellaneous/books/","title":"Books","text":"<p>sfd</p>"},{"location":"frontend/js/miscellaneous/cognitive-skills/","title":"Coginitive Skills","text":""},{"location":"frontend/js/miscellaneous/cognitive-skills/#overview","title":"Overview","text":"<p>Cognitive skills refer to the mental abilities used to acquire knowledge, think, understand, and solve problems. They play a critical role in learning and cognitive development. In the context of education, programming, and problem-solving (like in JavaScript or any other domain), cognitive skills can be categorized into different types based on the depth of thinking involved. The most widely recognized framework for cognitive skills comes from Bloom's Taxonomy, which classifies cognitive skills into different levels.</p> <p>Here are the key Cognitive Skill Types:</p>"},{"location":"frontend/js/miscellaneous/cognitive-skills/#1-remembering-knowledge-recall","title":"1. Remembering (Knowledge Recall)","text":"<p>This is the most basic cognitive skill, where you retrieve information from memory.</p> <ul> <li>Key Actions: Recalling facts, terms, basic concepts, definitions, or details.</li> <li>Questions: What is\u2026? Who was\u2026? When did\u2026? Define\u2026</li> </ul> <p>Example in Programming:</p> <ul> <li>What is the <code>map()</code> function in JavaScript?</li> <li>Define a JavaScript object.</li> </ul>"},{"location":"frontend/js/miscellaneous/cognitive-skills/#2-understanding-comprehension","title":"2. Understanding (Comprehension)","text":"<p>This skill involves grasping the meaning of information, interpreting data, or explaining concepts in your own words.</p> <ul> <li>Key Actions: Interpreting, summarizing, explaining, describing.</li> <li>Questions: How would you explain\u2026? What is the meaning of\u2026? Can you summarize\u2026?</li> </ul> <p>Example in Programming:</p> <ul> <li>Explain how the <code>filter()</code> method works in JavaScript.</li> <li>What happens when you call <code>addEventListener</code> in JavaScript?</li> </ul>"},{"location":"frontend/js/miscellaneous/cognitive-skills/#3-applying-application","title":"3. Applying (Application)","text":"<p>This involves using knowledge and understanding in a new or practical situation. You take what you've learned and apply it to solve problems or perform tasks.</p> <ul> <li>Key Actions: Using learned concepts in new situations, solving problems, demonstrating skills.</li> <li>Questions: How would you use\u2026? Can you apply the concept of\u2026?</li> </ul> <p>Example in Programming:</p> <ul> <li>Write a function to calculate the sum of all elements in an array.</li> <li>Use the <code>reduce()</code> method to find the average of an array.</li> </ul>"},{"location":"frontend/js/miscellaneous/cognitive-skills/#4-analyzing-analysis","title":"4. Analyzing (Analysis)","text":"<p>This is the ability to break down information into parts and understand its structure. It involves examining relationships, patterns, and organizing ideas or concepts.</p> <ul> <li>Key Actions: Comparing, contrasting, identifying patterns, organizing information.</li> <li>Questions: What is the difference between\u2026? How does X relate to Y? What are the components of\u2026?</li> </ul> <p>Example in Programming:</p> <ul> <li>What are the differences between <code>var</code>, <code>let</code>, and <code>const</code> in JavaScript?</li> <li>Analyze how a recursive function works compared to an iterative function.</li> </ul>"},{"location":"frontend/js/miscellaneous/cognitive-skills/#5-evaluating-evaluation","title":"5. Evaluating (Evaluation)","text":"<p>This involves making judgments about the value of ideas, solutions, or methods. It requires forming an opinion or decision based on criteria.</p> <ul> <li>Key Actions: Critiquing, judging, justifying, supporting, defending.</li> <li>Questions: Which solution is better? How would you defend\u2026? What would be the impact of\u2026?</li> </ul> <p>Example in Programming:</p> <ul> <li>Which sorting algorithm is more efficient for large datasets, and why?</li> <li>Evaluate the pros and cons of using Promises vs. async/await in JavaScript.</li> </ul>"},{"location":"frontend/js/miscellaneous/cognitive-skills/#6-creating-synthesis","title":"6. Creating (Synthesis)","text":"<p>This is the highest level of cognitive skills, where you combine elements to form a new whole. It involves innovation, constructing new solutions, or designing something original.</p> <ul> <li>Key Actions: Designing, constructing, inventing, synthesizing information to create new ideas.</li> <li>Questions: How could you design\u2026? What could you create if\u2026? How can you combine\u2026?</li> </ul> <p>Example in Programming:</p> <ul> <li>Design a RESTful API that allows users to perform CRUD operations on a database.</li> <li>Create a custom higher-order function in JavaScript that handles asynchronous actions in a more efficient way.</li> </ul>"},{"location":"frontend/js/miscellaneous/cognitive-skills/#summary-of-cognitive-skill-levels-in-blooms-taxonomy","title":"Summary of Cognitive Skill Levels in Bloom's Taxonomy:","text":"Cognitive Skill Type Description Action Words/Verbs 1. Remembering Recall facts, basic concepts, and definitions Recall, recognize, list, identify, describe 2. Understanding Grasp meaning, interpret, explain Explain, summarize, interpret, describe, discuss 3. Applying Use knowledge in new situations Use, solve, implement, demonstrate, apply 4. Analyzing Break down information, identify relationships Compare, contrast, analyze, categorize, examine 5. Evaluating Make judgments based on criteria Evaluate, justify, defend, critique, assess 6. Creating Combine elements to form new ideas or solutions Design, construct, develop, invent, create"},{"location":"frontend/js/miscellaneous/cognitive-skills/#other-cognitive-skills-in-problem-solving-beyond-blooms-taxonomy","title":"Other Cognitive Skills in Problem Solving (Beyond Bloom\u2019s Taxonomy):","text":"<p>Some additional cognitive skills include:</p> <ul> <li>Critical Thinking: This skill involves analyzing and evaluating information objectively, often to make decisions or form conclusions.</li> <li>Problem-Solving: The ability to identify solutions to a challenge or problem. In programming, this includes debugging, algorithm design, and troubleshooting.</li> <li>Logical Reasoning: Applying deductive or inductive reasoning to assess situations or problems.</li> <li>Metacognition: Awareness and control over one\u2019s own learning process. It involves self-monitoring and adjusting strategies to improve learning outcomes.</li> </ul>"},{"location":"frontend/js/miscellaneous/cognitive-skills/#application-to-programming-and-javascript","title":"Application to Programming and JavaScript:","text":"<p>In programming, cognitive skills are essential for writing efficient code, debugging, understanding new concepts, and creating innovative solutions. For example:</p> <ul> <li>Remembering: Recognizing syntax or recalling a standard function.</li> <li>Understanding: Explaining how a <code>forEach</code> loop works in JavaScript.</li> <li>Applying: Using a higher-order function like <code>map()</code> to manipulate data in an array.</li> <li>Analyzing: Breaking down complex code to find the root cause of a bug.</li> <li>Evaluating: Deciding which data structure (e.g., arrays vs. objects) is optimal for a given problem.</li> <li>Creating: Designing a full-stack web application, using JavaScript for both frontend and backend.</li> </ul> <p>Understanding these cognitive skills can help you deepen your learning, especially when tackling programming challenges or complex technical problems.</p>"},{"location":"frontend/js/mnemonic/js-array/","title":"JS Array","text":""},{"location":"frontend/js/mnemonic/js-array/#overview","title":"Overview","text":"<p>To get a deep understanding of JavaScript arrays and remember key concepts, you can use mnemonics to simplify and retain the information. Here\u2019s a guide to understanding JavaScript arrays with some mnemonic aids:</p>"},{"location":"frontend/js/mnemonic/js-array/#1-basics-of-arrays","title":"1. Basics of Arrays","text":"<ul> <li> <p>Mnemonic: \"A Big Car Drives Everywhere\" (A-B-C-D-E)</p> <p>A - Arrays: Data structures to store multiple values.</p> <p>B - Basic operations: Initialization, accessing, and updating elements.</p> <p>C - Common methods: <code>.push()</code>, <code>.pop()</code>, <code>.shift()</code>, <code>.unshift()</code>.</p> <p>D - Dynamic size: Arrays can grow or shrink in size.</p> <p>E - Element types: Can store different types (numbers, strings, objects, etc.).</p> </li> </ul>"},{"location":"frontend/js/mnemonic/js-array/#2-common-methods-and-properties","title":"2 . Common Methods and Properties","text":"<ul> <li> <p>Mnemonic: \"Please Set Prime Fridays Carefully\" (P-S-P-F-C)</p> <p>P - <code>.push()</code>: Add elements to the end of the array.</p> <p>S - <code>.shift()</code>: Remove the first element.</p> <p>P - <code>.pop()</code>: Remove the last element.</p> <p>F - <code>.forEach()</code>: Iterate through elements.</p> <p>C - <code>.concat()</code>: Merge arrays.</p> </li> </ul>"},{"location":"frontend/js/mnemonic/js-array/#3-iteration-methods","title":"3. Iteration Methods","text":"<ul> <li> <p>Mnemonic: \"Most Fish Require Tasty Food\" (M-F-R-T-F)</p> <p>M - <code>.map()</code>: Transform each element.</p> <p>F - <code>.filter()</code>: Select elements based on a condition.</p> <p>R - <code>.reduce()</code>: Accumulate values.</p> <p>T - <code>.some()</code>: Check if any element meets a condition.</p> <p>F - <code>.every()</code>: Check if all elements meet a condition.</p> </li> </ul>"},{"location":"frontend/js/mnemonic/js-array/#4-array-properties","title":"4. Array Properties","text":"<ul> <li> <p>Mnemonic: \"Length Is Determined By All\" (L-I-D-B-A)</p> <p>L - <code>.length</code>: Number of elements.</p> <p>I - <code>.indexOf()</code>: Position of an element.</p> <p>D - <code>.delete</code>: Use delete to remove elements but doesn\u2019t change length.</p> <p>B - <code>.back()</code>: Non-standard, for last element (<code>.at(-1)</code> in modern JS).</p> <p>A - <code>.at()</code>: Access elements with negative indexing.</p> </li> </ul>"},{"location":"frontend/js/mnemonic/js-array/#5-multi-dimensional-arrays","title":"5. Multi-dimensional Arrays","text":"<ul> <li> <p>Mnemonic: \"Nested Elements Always Remain Rich\" (N-E-A-R-R)</p> <p>N - Nested: Arrays within arrays.</p> <p>E - Each dimension: Indexed independently.</p> <p>A - Accessing: Use nested loops or <code>.flat()</code> for simplification.</p> <p>R - Reshape: Use methods like <code>.map()</code> for transformations.</p> <p>R - Reorganize: Manipulate structure as needed.</p> </li> </ul>"},{"location":"frontend/js/mnemonic/js-array/#6-advanced-techniques","title":"6. Advanced Techniques","text":"<ul> <li> <p>Mnemonic: \"Strong Support Delivers Reliable Learning\" (S-S-D-R-L)</p> <p>S - Spread operator (<code>...</code>): Expand elements in a new array.</p> <p>S - Slice: Create sub-arrays.</p> <p>D - Destructuring: Extract values from arrays.</p> <p>R - Rest parameters: Handle variable numbers of elements.</p> <p>L - length property: Manage array size.</p> </li> </ul> <p>Using these mnemonics, you can more easily remember and recall various aspects of JavaScript arrays.</p>"},{"location":"frontend/js/mnemonic/js-array/#associations","title":"Associations","text":"<p>To remember information about JavaScript arrays for the long term, it helps to use a combination of mnemonic devices, active learning techniques, and contextual application. Here\u2019s a strategy to deeply associate and retain the knowledge:</p> <ol> <li> <p>Create Strong Associations</p> <p>Use Analogies:</p> <p>Think of arrays like a row of mailboxes (each index is a mailbox) where you can put letters (values).</p> <ul> <li><code>.push()</code> adds a letter to the end.</li> <li><code>.pop()</code> removes the letter from the end.</li> <li><code>.shift()</code> removes the letter from the beginning.</li> <li><code>.unshift()</code> adds a letter to the beginning.</li> </ul> <p>Relate Methods to Real-Life Actions:</p> <ul> <li><code>.map()</code>: Imagine you\u2019re putting a sticker on each item (transforming each element).</li> <li><code>.filter()</code>: Picture sifting through a pile to keep only certain items.</li> <li><code>.reduce()</code>: Think of combining a bunch of ingredients into a single dish.</li> </ul> </li> <li> <p>Engage in Active Learning</p> <p>Practice Coding Regularly:</p> <ul> <li>Write code snippets that use different array methods. Practice is crucial for retention.</li> <li>Build small projects or solve coding challenges that require you to manipulate arrays.</li> </ul> <p>Teach Others:</p> <ul> <li>Explain array concepts and methods to a friend or write a blog post/tutorial. Teaching helps solidify your understanding.</li> </ul> <p>Create Visual Aids:</p> <ul> <li>Draw diagrams of array operations or create flashcards with array methods and their descriptions. Visual memory can be powerful.</li> </ul> </li> <li> <p>Apply the Concepts Contextually</p> <p>Work on Real Projects:</p> <ul> <li>Integrate arrays into projects you're passionate about. Whether it\u2019s a to-do list app, a game, or data visualization, applying arrays in a real context helps reinforce the concepts.</li> </ul> <p>Use Arrays in Everyday Coding:</p> <ul> <li>Whenever you encounter a problem that can be solved with arrays, make a habit of using them. This practice helps cement your understanding.</li> </ul> </li> <li> <p>Leverage Mnemonics and Repetition</p> <p>Revisit Mnemonics Regularly:</p> <ul> <li>Periodically review the mnemonics you created. Spaced repetition (reviewing information at increasing intervals) helps move knowledge from short-term to long-term memory.</li> </ul> <p>Create a Cheat Sheet:</p> <ul> <li>Have a quick reference guide with key array methods and their uses. Regularly glance at it until the information is second nature.</li> </ul> </li> <li> <p>Use Interactive Learning Tools</p> <p>Interactive Platforms:</p> <ul> <li>Utilize coding platforms like Codecademy, freeCodeCamp, or LeetCode that offer interactive exercises and challenges related to arrays.</li> </ul> <p>Visual Learning Tools:</p> <ul> <li>Websites like JavaScript.info or MDN Web Docs provide interactive examples and explanations.</li> </ul> </li> <li> <p>Connect Concepts Together</p> <p>Build Concept Maps:</p> <ul> <li>Draw a map connecting different array methods, their purposes, and how they interact. For example, link <code>.map()</code> with <code>.filter()</code> to show how they can be used together in a data processing pipeline.</li> </ul> <p>Relate to Similar Concepts:</p> <ul> <li>Compare arrays with other data structures you know, like objects or sets. Understanding the similarities and differences helps reinforce your knowledge.</li> </ul> Example Mnemonic Practice <p>Mnemonic for Common Methods:</p> <ul> <li>Remember \"Please Set Prime Fridays Carefully\" to recall <code>.push()</code>, <code>.shift()</code>, <code>.pop()</code>, <code>.forEach()</code>, and <code>.concat()</code>.</li> </ul> <p>Practice with Mnemonics:</p> <ul> <li>Write short stories or sentences using these mnemonics to visualize what each method does in different scenarios.</li> </ul> </li> </ol> <p>By integrating these techniques into your learning routine, you'll build a robust, long-term understanding of JavaScript arrays.</p>"},{"location":"frontend/js/mnemonic/js-array/#data-processing-pipeline","title":"Data Processing Pipeline","text":"<p>A data processing pipeline is a sequence of operations or transformations applied to data to achieve a desired result. In programming, particularly with arrays in JavaScript, a pipeline often involves applying a series of functions to process or analyze the data step-by-step.</p> Data Processing Pipeline Concept <ol> <li>Input Data: Start with a dataset or an array of values.</li> <li>Transformation Steps: Apply various functions to process the data.</li> <li>Output Data: End with the final processed data.</li> </ol> <p>Each step in the pipeline takes input data, applies a transformation, and passes the result to the next step.</p>"},{"location":"frontend/js/mnemonic/js-array/#using-map-with-filter-together","title":"Using <code>.map()</code> with <code>.filter()</code> Together","text":"<p>You can use <code>.map()</code> and <code>.filter()</code> together in a data processing pipeline to transform and then filter data. Here's how:</p> <ol> <li> <p><code>.filter()</code>:</p> <p>This method is used to select elements that meet a certain condition. It creates a new array with only the elements that pass the test implemented by the provided function.</p> </li> <li> <p><code>.map()</code>:</p> <p>This method is used to transform elements. It creates a new array with the results of calling a provided function on every element in the calling array.</p> </li> </ol> Steps to Use <code>.map()</code> with <code>.filter()</code> Together** <ol> <li>Filter the Data: First, use <code>.filter()</code> to narrow down the dataset based on a condition.</li> <li>Transform the Data: Then, use <code>.map()</code> to transform the filtered dataset.</li> </ol> Example 1Example 2Example 3 <p>Let's say you have an array of objects representing people, and you want to filter out only the adults (age 18 or older) and then create a list of their names.</p> <pre><code>const people = [\n    { name: 'Alice', age: 25 },\n    { name: 'Bob', age: 17 },\n    { name: 'Charlie', age: 30 },\n    { name: 'David', age: 15 }\n];\n\n// First, filter out the adults (age 18 or older)\nconst adults = people.filter(person =&gt; person.age &gt;= 18);\n\n// Then, map to get an array of their names\nconst adultNames = adults.map(person =&gt; person.name);\n\nconsole.log(adultNames); // Output: ['Alice', 'Charlie']\n</code></pre> <p>Explanation:</p> <ol> <li>Filtering: <code>.filter(person =&gt; person.age &gt;= 18)</code> creates a new array that only includes people who are 18 or older.</li> <li>Mapping: <code>.map(person =&gt; person.name)</code> creates a new array containing the names of those filtered people.</li> </ol> Visualizing the Pipeline <p>You can visualize the pipeline as a sequence of operations:</p> <ol> <li>Input: <code>people</code></li> <li>Filter Step: <code>people.filter(person =&gt; person.age &gt;= 18)</code></li> <li>Transformation Step: <code>.map(person =&gt; person.name)</code></li> <li>Output: <code>['Alice', 'Charlie']</code></li> </ol> <p>This approach of chaining methods allows for clean, readable code and a logical flow of data transformation.</p> <p>Example: Processing Product Data</p> <p>Assume you have an array of product objects, each containing information about the product\u2019s name, price, and category. You want to filter out products that are in the \"Electronics\" category and then create a list of the names of these products with their prices increased by 10%.</p> <pre><code>const products = [\n    { name: 'Smartphone', price: 699, category: 'Electronics' },\n    { name: 'Laptop', price: 999, category: 'Electronics' },\n    { name: 'Coffee Maker', price: 89, category: 'Home Appliances' },\n    { name: 'Headphones', price: 199, category: 'Electronics' },\n    { name: 'Blender', price: 129, category: 'Home Appliances' }\n];\n\n// Step 1: Filter out products in the 'Electronics' category\nconst electronics = products.filter(product =&gt; product.category === 'Electronics');\n\n// Step 2: Map to increase price by 10% and get names with updated prices\nconst updatedElectronics = electronics.map(product =&gt; ({\n    name: product.name,\n    updatedPrice: product.price * 1.10 // Increase price by 10%\n}));\n\nconsole.log(updatedElectronics);\n// Output: [\n//   { name: 'Smartphone', updatedPrice: 768.9 },\n//   { name: 'Laptop', updatedPrice: 1098.9 },\n//   { name: 'Headphones', updatedPrice: 218.9 }\n// ]\n</code></pre> <p>Explanation:</p> <ol> <li> <p>Filtering: <code>.filter(product =&gt; product.category === 'Electronics')</code> creates a new array that includes only the products from the \"Electronics\" category.</p> </li> <li> <p>Mapping: <code>.map(product =&gt; ({ name: product.name, updatedPrice: product.price * 1.10 }))</code> creates a new array where each product\u2019s price is increased by 10%, and the result is a list of objects containing the product name and the updated price.</p> </li> </ol> <pre><code>const users = [\n    { username: 'john_doe', posts: 15, active: true },\n    { username: 'jane_smith', posts: 22, active: false },\n    { username: 'sam_jones', posts: 10, active: true },\n    { username: 'lisa_williams', posts: 35, active: true },\n    { username: 'michael_brown', posts: 8, active: false }\n];\n\n// Step 1: Filter out active users\nconst activeUsers = users.filter(user =&gt; user.active);\n\n// Step 2: Map to get usernames and increase their post count by 5\nconst updatedUsers = activeUsers.map(user =&gt; ({\nusername: user.username,\nupdatedPosts: user.posts + 5 // Increase post count by 5\n}));\n\nconsole.log(updatedUsers);\n// Output: [\n//   { username: 'john_doe', updatedPosts: 20 },\n//   { username: 'sam_jones', updatedPosts: 15 },\n//   { username: 'lisa_williams', updatedPosts: 40 }\n// ]\n</code></pre> <p>Explanation:</p> <ol> <li>Filtering: <code>.filter(user =&gt; user.active)</code> creates a new array that includes only active users. 2   Mapping: <code>.map(user =&gt; ({ username: user.username, updatedPosts: user.posts + 5 }))</code> creates a new array where each user\u2019s post count is increased by 5, and the result is a list of objects containing the username and the updated post count.</li> </ol> <p>These examples show how you can use <code>.filter()</code> to narrow down your dataset based on specific criteria and then use <code>.map()</code> to transform the filtered data. This approach is useful for a variety of data processing tasks and helps keep your code clean and readable.</p>"},{"location":"frontend/js/mnemonic/js-array/#javascript-iteration-methods","title":"JavaScript Iteration Methods","text":"<ol> <li> <p><code>.forEach()</code>: Executes a provided function once for each array element.</p> <pre><code>array.forEach(element =&gt; console.log(element));\n</code></pre> </li> <li> <p><code>.map()</code>: Creates a new array with the results of applying a function to each element.</p> <pre><code>const doubled = array.map(x =&gt; x * 2);\n</code></pre> </li> <li> <p><code>.filter()</code>: Creates a new array with elements that pass a test implemented by a function.</p> <pre><code>const evenNumbers = array.filter(x =&gt; x % 2 === 0);\n</code></pre> </li> <li> <p><code>.reduce()</code>: Applies a function against an accumulator and each element to reduce it to a single value.</p> <pre><code>const sum = array.reduce((acc, curr) =&gt; acc + curr, 0);\n</code></pre> </li> <li> <p><code>.some()</code>: Tests if at least one element in the array passes the test implemented by a function.</p> <pre><code>const hasNegative = array.some(x =&gt; x &lt; 0);\n</code></pre> </li> <li> <p><code>.every()</code>: Tests if all elements in the array pass the test implemented by a function.</p> <pre><code>const allPositive = array.every(x =&gt; x &gt; 0);\n</code></pre> </li> <li> <p><code>.find()</code>: Returns the first element that satisfies the provided testing function.</p> <pre><code>const firstNegative = array.find(x =&gt; x &lt; 0);\n</code></pre> </li> <li> <p><code>.findIndex()</code>: Returns the index of the first element that satisfies the provided testing function.</p> <pre><code>const index = array.findIndex(x =&gt; x === 5);\n</code></pre> </li> <li> <p><code>.sort()</code>: Sorts the elements of an array in place according to a provided comparison function.</p> <pre><code>const sorted = array.sort((a, b) =&gt; a - b);\n</code></pre> </li> <li> <p><code>.flatMap()</code>: Maps each element to a new array and then flattens the result by one level.</p> <pre><code>const flatMapped = array.flatMap(x =&gt; [x, x * 2]);\n</code></pre> </li> </ol>"},{"location":"frontend/js/mnemonic/js-array/#mnemonic-for-iteration-methods","title":"Mnemonic for Iteration Methods","text":"<p>Use the mnemonic \"Funky Map Friends Really Seek Every Fun Fun Seekers\" (F-M-F-R-S-E-F-F-S)</p> <ul> <li>F - <code>.forEach()</code>: Execute function for each element.</li> <li>M - <code>.map()</code>: Create new array with results of function.</li> <li>F - <code>.filter()</code>: Create new array with elements passing a test.</li> <li>R - <code>.reduce()</code>: Reduce array to a single value.</li> <li>S - <code>.some()</code>: Test if at least one element passes the test.</li> <li>E - <code>.every()</code>: Test if all elements pass the test.</li> <li>F - <code>.find()</code>: Find the first element that satisfies the test.</li> <li>F - <code>.findIndex()</code>: Find the index of the first element that satisfies the test.</li> <li>S - <code>.sort()</code>: Sort the array elements.</li> <li>F - <code>.flatMap()</code>: Map each element to a new array and flatten.</li> </ul> <p>Using this mnemonic helps in recalling the names and purposes of the iteration methods, making it easier to choose the right method for your needs.</p>"},{"location":"frontend/js/mnemonic/js-functions/","title":"JS Function","text":""},{"location":"frontend/js/mnemonic/js-functions/#different-types-of-function-in-javascript","title":"Different types of Function in Javascript","text":"<p>Here are a few tips to help you remember the different types of functions in JavaScript:</p>"},{"location":"frontend/js/mnemonic/js-functions/#1-use-acronyms","title":"1.  Use Acronyms","text":"<p>Create acronyms or mnemonics to remember the key categories. For example:</p> <ul> <li>\"R-A-A\": Regular, Anonymous, Arrow (for how functions are defined).</li> <li>\"I-H-C\": IIFE, Higher-Order, Callback (for when and how functions interact).</li> </ul>"},{"location":"frontend/js/mnemonic/js-functions/#2-visual-associations","title":"2.  Visual Associations","text":"<p>Associate each function type with a visual or real-world analogy:</p> <ul> <li>Regular Function: Think of it as a person with a name. You can call them (invoke them) anytime.</li> <li>Anonymous Function: A person without a name, useful for quick tasks or passing around without long-term use.</li> <li>Arrow Function: A speed arrow or shortcut to show it's a quicker way to write functions.</li> <li>IIFE: Imagine pressing a button that immediately triggers an action, like starting a stopwatch.</li> <li>Async Function: Think of a to-do list where you wait for things to be completed (like waiting for an email to arrive).</li> <li>Constructor Function: Think of a factory that builds objects.</li> </ul>"},{"location":"frontend/js/mnemonic/js-functions/#3-group-by-usage","title":"3.  Group By Usage","text":"<p>Categorize functions based on how you use them:</p> <ul> <li>Reusable Functions: Regular, Arrow</li> <li>One-time Use Functions: Anonymous, IIFE</li> <li>Advanced Usage: Higher-Order, Async, Constructor</li> </ul>"},{"location":"frontend/js/mnemonic/js-functions/#4-practice-using-them","title":"4.  Practice Using Them","text":"<p>The best way to remember is by practicing:</p> <ul> <li>Write examples of each function type.</li> <li>Use them in small coding challenges or real projects.</li> <li>Try to write code using different function types and see how they work in real scenarios.</li> </ul>"},{"location":"frontend/js/mnemonic/js-functions/#5-storytelling","title":"5.  Storytelling","text":"<p>Create a simple story or scenario to tie the functions together. For example:</p> <ul> <li>You have a Regular friend (Regular Function), who helps you anytime.</li> <li>Sometimes, you need help from a stranger (Anonymous Function) who doesn't have a name.</li> <li>You find a shortcut (Arrow Function) to get things done faster.</li> <li>You press a button (IIFE) to instantly start something.</li> <li>You call a helper (Callback Function) and ask them to do a task later.</li> <li>When waiting for something, you use Async (Async Function).</li> <li>And when you need to build something, you go to a factory (Constructor Function).</li> </ul> <p>By making it personal or memorable, you\u2019ll be able to recall the types more easily!</p>"},{"location":"frontend/js/mnemonic/js-object-iterating-method/","title":"Object Iterating Method","text":""},{"location":"frontend/js/mnemonic/js-object-iterating-method/#example-in-react","title":"Example in React","text":"<p>Scenario: User Profile Component</p> <p>Imagine you\u2019re building a React component that displays a user\u2019s profile information. You want to iterate over the profile data to dynamically render the information in the component.</p> for...inObject.keys()Object.values()Object.entries()for...of <p>Using <code>for...in</code> Loop</p> <p>Scenario: You need to display all the profile attributes in a list.</p> <pre><code>import React from 'react';\n\nconst UserProfile = ({ profile }) =&gt; {\n    return (\n        &lt;div&gt;\n        &lt;h1&gt;User Profile&lt;/h1&gt;\n            &lt;ul&gt;\n                {Object.keys(profile).map(key =&gt; (\n                &lt;li key={key}&gt;\n                    &lt;strong&gt;{key}:&lt;/strong&gt; {profile[key]}\n                &lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nconst profile = {\n    name: 'Alice',\n    age: 30,\n    email: 'alice@example.com',\n    isActive: true\n};\n\nexport default function App() {\n    return &lt;UserProfile profile={profile} /&gt;;\n}\n</code></pre> <p>Using <code>Object.keys()</code></p> <p>Scenario: Similar to the previous example, you want to render each key-value pair from the profile object.</p> <pre><code>import React from 'react';\n\nconst UserProfile = ({ profile }) =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;User Profile&lt;/h1&gt;\n            &lt;ul&gt;\n                {Object.keys(profile).map(key =&gt; (\n                &lt;li key={key}&gt;\n                    &lt;strong&gt;{key}:&lt;/strong&gt; {profile[key].toString()}\n                &lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nconst profile = {\n    name: 'Alice',\n    age: 30,\n    email: 'alice@example.com',\n    isActive: true\n};\n\nexport default function App() {\n    return &lt;UserProfile profile={profile} /&gt;;\n}\n</code></pre> <p>Using <code>Object.values()</code></p> <p>Scenario: You only want to display the values, ignoring the keys.</p> <pre><code>import React from 'react';\n\nconst UserProfile = ({ profile }) =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;User Profile&lt;/h1&gt;\n            &lt;ul&gt;\n                {Object.values(profile).map((value, index) =&gt; (\n                &lt;li key={index}&gt;{value.toString()}&lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nconst profile = {\n    name: 'Alice',\n    age: 30,\n    email: 'alice@example.com',\n    isActive: true\n};\n\nexport default function App() {\n    return &lt;UserProfile profile={profile} /&gt;;\n}\n</code></pre> <p>Using Object.entries()</p> <p>Scenario: Display both the key and the value of each profile attribute.</p> <pre><code>import React from 'react';\n\nconst UserProfile = ({ profile }) =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;User Profile&lt;/h1&gt;\n            &lt;ul&gt;\n                {Object.entries(profile).map(([key, value]) =&gt; (\n                &lt;li key={key}&gt;\n                    &lt;strong&gt;{key}:&lt;/strong&gt; {value.toString()}\n                &lt;/li&gt;\n            ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nconst profile = {\n    name: 'Alice',\n    age: 30,\n    email: 'alice@example.com',\n    isActive: true\n};\n\nexport default function App() {\n    return &lt;UserProfile profile={profile} /&gt;;\n}\n</code></pre> <p>Using <code>for...of</code> with <code>Object.entries()</code></p> <p>Scenario: Use the for...of loop to iterate over the entries and render them.</p> <pre><code>import React from 'react';\n\nconst UserProfile = ({ profile }) =&gt; {\n    const entries = Object.entries(profile);\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;User Profile&lt;/h1&gt;\n            &lt;ul&gt;\n                {entries.map(([key, value]) =&gt; (\n                &lt;li key={key}&gt;\n                    &lt;strong&gt;{key}:&lt;/strong&gt; {value.toString()}\n                &lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nconst profile = {\n    name: 'Alice',\n    age: 30,\n    email: 'alice@example.com',\n    isActive: true\n};\n\nexport default function App() {\n    return &lt;UserProfile profile={profile} /&gt;;\n}\n</code></pre> Summary <p>In these React components:</p> <ul> <li><code>for...in</code> and <code>Object.keys()</code>: Useful for iterating over object keys. You can use them to render both keys and values or perform other operations.</li> <li><code>Object.values()</code>: Use when you only need the values from the object.</li> <li><code>Object.entries()</code>: Use when you need both keys and values together for rendering or other operations.</li> <li><code>for...of</code> with <code>Object.entries()</code>: Offers a concise way to loop over key-value pairs.</li> </ul> <p>These methods help you dynamically generate UI elements based on the data in your React components, allowing for flexible and reusable code.</p>"},{"location":"frontend/js/mnemonic/js-object-iterating-method/#example-exclude-keys","title":"Example Exclude keys","text":"<p>If you want to exclude certain keys from being displayed, such as isActive, you can use various methods to filter out these keys before rendering the data. Here\u2019s how you can modify each of the previous examples to exclude specific keys from the display:</p> Object.keys()Object.entries()for...of <p>Scenario: Exclude <code>isActive</code> and <code>age</code> from being displayed.</p> <pre><code>import React from 'react';\n\nconst UserProfile = ({ profile }) =&gt; {\n    // List of keys to exclude\n    const keysToExclude = ['isActive', 'age'];\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;User Profile&lt;/h1&gt;\n            &lt;ul&gt;\n                {Object.keys(profile)\n                    .filter(key =&gt; !keysToExclude.includes(key)) // Filter out excluded keys\n                    .map(key =&gt; (\n                        &lt;li key={key}&gt;\n                        &lt;strong&gt;{key}:&lt;/strong&gt; {profile[key].toString()}\n                        &lt;/li&gt;\n                    ))\n                }\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nconst profile = {\n    name: 'Alice',\n    age: 30,\n    email: 'alice@example.com',\n    isActive: true\n};\n\nexport default function App() {\n    return &lt;UserProfile profile={profile} /&gt;;\n}\n</code></pre> <p>Scenario: Exclude <code>isActive</code> and <code>age</code> from being displayed.</p> <pre><code>import React from 'react';\n\nconst UserProfile = ({ profile }) =&gt; {\n    // List of keys to exclude\n    const keysToExclude = ['isActive', 'age'];\n\n    return (\n        &lt;div&gt;\n        &lt;h1&gt;User Profile&lt;/h1&gt;\n            &lt;ul&gt;\n                {Object.entries(profile)\n                    .filter(([key]) =&gt; !keysToExclude.includes(key)) // Filter out excluded entries\n                    .map(([key, value]) =&gt; (\n                        &lt;li key={key}&gt;\n                        &lt;strong&gt;{key}:&lt;/strong&gt; {value.toString()}\n                        &lt;/li&gt;\n                    ))\n                }\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nconst profile = {\n    name: 'Alice',\n    age: 30,\n    email: 'alice@example.com',\n    isActive: true\n};\n\nexport default function App() {\n    return &lt;UserProfile profile={profile} /&gt;;\n}\n</code></pre> <p>Scenario: Exclude <code>isActive</code> and <code>age</code> from being displayed.</p> <pre><code>import React from 'react';\n\nconst UserProfile = ({ profile }) =&gt; {\n    // List of keys to exclude\n    const keysToExclude = ['isActive', 'age'];\n    const entries = Object.entries(profile)\n        .filter(([key]) =&gt; !keysToExclude.includes(key)); // Filter out excluded entries\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;User Profile&lt;/h1&gt;\n            &lt;ul&gt;\n                {entries.map(([key, value]) =&gt; (\n                &lt;li key={key}&gt;\n                    &lt;strong&gt;{key}:&lt;/strong&gt; {value.toString()}\n                &lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nconst profile = {\n    name: 'Alice',\n    age: 30,\n    email: 'alice@example.com',\n    isActive: true\n};\n\nexport default function App() {\n    return &lt;UserProfile profile={profile} /&gt;;\n}\n</code></pre> Summary <p>To exclude multiple keys (e.g., <code>isActive</code> and <code>age</code>):</p> <ol> <li>Create an array of keys to exclude, such as <code>const keysToExclude = ['isActive', 'age'];</code>.</li> <li>Use <code>filter()</code> on the list of keys or entries to remove any key-value pairs where the key is in the keysToExclude array.</li> <li>Render the filtered keys or entries in your component.</li> </ol> <p>By applying this approach, you ensure that only the desired attributes are displayed in your React application, allowing for a clean and focused user interface.</p>"},{"location":"frontend/js/mnemonic/js-objects/","title":"JS Object","text":"<p>js objects</p>"},{"location":"frontend/js/mnemonic/object-array-iteration-methods/","title":"Iterating Method","text":"<p>JavaScript provides various methods for iterating over arrays and objects. Understanding these methods helps in effectively working with data structures. Here\u2019s a comprehensive overview of iteration methods for both arrays and objects in JavaScript.</p>"},{"location":"frontend/js/mnemonic/object-array-iteration-methods/#javascript-iteration-methods-for-objects","title":"JavaScript Iteration Methods for Objects","text":""},{"location":"frontend/js/mnemonic/object-array-iteration-methods/#methods","title":"Methods","text":"<ol> <li> <p><code>for...in</code> Loop</p> <pre><code>\n</code></pre> </li> <li> <p><code>Object.keys()</code></p> </li> <li> <p><code>Object.values()</code></p> </li> <li> <p><code>Object.entries()</code></p> </li> <li> <p><code>for...of Loop</code> with <code>Object.entries()</code></p> </li> </ol>"},{"location":"frontend/js/mnemonic/object-array-iteration-methods/#categorize","title":"Categorize","text":"<p>Certainly! To help you categorize and remember JavaScript iteration methods for objects, you can group them based on their primary functions and purposes. Here's a breakdown:</p> <ol> <li> <p>Iterating Over Keys</p> <p>These methods focus on accessing the keys (property names) of an object:</p> <ul> <li> <p><code>for...in</code> Loop</p> ExampleOverview <pre><code>const person = { name: 'Alice', age: 30 };\nfor (const key in person) {\n    console.log(key); // Output: name, age\n}\n</code></pre> <ul> <li>Purpose: Iterates over the enumerable properties of an object.</li> <li>Use Case: When you want to loop through all enumerable properties, including those inherited from the prototype chain.</li> </ul> </li> <li> <p><code>Object.keys()</code></p> ExampleOveriew <pre><code>const person = { name: 'Alice', age: 30 };\nconst keys = Object.keys(person); // ['name', 'age']\n</code></pre> <ul> <li>Purpose: Returns an array of the object's own enumerable property names.</li> <li>Use Case: When you need an array of keys to use with array methods.</li> </ul> </li> </ul> </li> <li> <p>Iterating Over Values</p> <p>These methods focus on accessing the values of an object:</p> <ul> <li> <p><code>Object.values()</code></p> ExampleOverview <pre><code>const person = { name: 'Alice', age: 30 };\nconst values = Object.values(person); // ['Alice', 30]\n</code></pre> <ul> <li>Purpose: Returns an array of the object's own enumerable property values.</li> <li>Use Case: When you need an array of values to work with.</li> </ul> </li> </ul> </li> <li> <p>Iterating Over Entries (Key-Value Pairs)</p> <p>These methods are useful for iterating over both keys and values simultaneously:</p> <ul> <li> <p><code>Object.entries()</code></p> ExampleOverview <pre><code>const person = { name: 'Alice', age: 30 };\nconst entries = Object.entries(person); // [['name', 'Alice'], ['age', 30]]\n</code></pre> <ul> <li>Purpose: Returns an array of the object's own enumerable <code>[key, value]</code> pairs.</li> <li>Use Case: When you need to iterate over both keys and values together.</li> </ul> </li> <li> <p><code>for...of</code> Loop with <code>Object.entries()</code></p> ExampleOverview <pre><code>const person = { name: 'Alice', age: 30 };\nfor (const [key, value] of Object.entries(person)) {\n    console.log(`${key}: ${value}`); // Output: name: Alice, age: 30\n}\n</code></pre> <ul> <li>Purpose: Iterates over <code>[key, value]</code> pairs using <code>for...of</code> combined with <code>Object.entries()</code>.</li> <li>Use Case: A concise and readable way to loop over both keys and values.</li> </ul> </li> </ul> </li> </ol> Summary of Categorization <ol> <li> <p>Keys Iteration:</p> <ul> <li><code>for...in</code> (iterates over all enumerable properties including inherited ones)</li> <li><code>Object.keys()</code> (returns an array of the object's own enumerable property names)</li> </ul> </li> <li> <p>Values Iteration:</p> <ul> <li><code>Object.values()</code> (returns an array of the object's own enumerable property values)</li> </ul> </li> <li> <p>Entries Iteration:</p> <ul> <li><code>Object.entries()</code> (returns an array of <code>[key, value]</code> pairs)</li> <li><code>for...of</code> loop with <code>Object.entries()</code> (iterates over <code>[key, value]</code> pairs in a readable way)</li> </ul> </li> </ol> <p>By grouping these methods into categories based on their purposes, you can more easily recall and use them depending on whether you need to work with keys, values, or both.</p>"},{"location":"frontend/js/mnemonic/object-array-iteration-methods/#mnemonic","title":"Mnemonic","text":"<p>Mnemonics can be a helpful tool for memorizing and recalling concepts. Here\u2019s a mnemonic to help remember the JavaScript iteration methods for objects, categorized by their purpose:</p> Mnemonic: \"Keep Value Everything\" <p>K eep (Keys Iteration)</p> <ul> <li>K - <code>for...in</code> (think of \"Keep going through properties\")</li> <li>K - <code>Object.keys()</code> (think of \"Key list\")</li> </ul> <p>V alue (Values Iteration)</p> <ul> <li>V - <code>Object.values()</code> (think of \"Values list\")</li> </ul> <p>E verything (Entries Iteration)</p> <ul> <li>E - <code>Object.entries()</code> (think of \"Everything together as key-value pairs\")</li> <li>E - <code>for...of</code> loop with <code>Object.entries()</code> (think of \"Each pair in a loop\")</li> </ul> Expanded Mnemonic <ol> <li> <p>Keep:</p> <ul> <li><code>for...in</code>: \"Keep going through all enumerable properties.\"</li> <li><code>Object.keys()</code>: \"Key list\" - think of it as a list of keys you can work with.</li> </ul> </li> <li> <p>Value:</p> <ul> <li><code>Object.values()</code>: \"Value list\" - think of it as a list of values extracted from the object.</li> </ul> </li> <li> <p>Everything:</p> <ul> <li><code>Object.entries()</code>: \"Everything together\" - think of it as pairing up keys and values.</li> <li><code>for...of</code> loop with <code>Object.entries()</code>: \"Each pair in a loop\" - remember that it loops over each key-value pair.</li> </ul> </li> </ol>"},{"location":"frontend/js/mnemonic/object-array-iteration-methods/#example-of-using-the-mnemonic","title":"Example of Using the Mnemonic","text":"<p>Imagine you\u2019re working on a JavaScript project and need to iterate over an object. You can use the mnemonic as a checklist:</p> <ol> <li>Keep - Do you need to iterate over keys? Use <code>for...in</code> or <code>Object.keys()</code>.</li> <li>Value - Do you need to get values? Use <code>Object.values()</code>.</li> <li>Everything - Do you need both keys and values? Use <code>Object.entries()</code> or loop through entries with <code>for...of</code>.</li> </ol>"},{"location":"frontend/js/mnemonic/object-array-iteration-methods/#visual-mnemonic","title":"Visual Mnemonic","text":"<p>To visualize this, you might picture a \u201cKVE\u201d checklist:</p> <ul> <li>Keep (Keys) -&gt; <code>for...in</code>, <code>Object.keys()</code></li> <li>Value (Values) -&gt; <code>Object.values()</code></li> <li>Everything (Entries) -&gt; <code>Object.entries()</code>, <code>for...of</code> with <code>Object.entries()</code></li> </ul> <p>Using mnemonics like this can simplify remembering the methods and their purposes, making it easier to choose the right tool for your task.</p>"},{"location":"frontend/js/mnemonic/object-array-iteration-methods/#summary","title":"Summary","text":"<ul> <li> <p>Array Iteration Methods: Include <code>forEach</code>, <code>map</code>, <code>filter</code>, <code>reduce</code>, <code>some</code>, <code>every</code>, <code>find</code>, <code>findIndex</code>, and <code>for...of</code>, each serving specific purposes related to transforming, accumulating, or processing array elements.</p> </li> <li> <p>Object Iteration Methods: Include <code>for...in</code>, <code>Object.keys()</code>, <code>Object.values()</code>, <code>Object.entries()</code>, and <code>for...of</code> with <code>Object.entries()</code>, focusing on iterating over object properties and their values.</p> </li> </ul> <p>By leveraging these methods, you can efficiently work with arrays and objects, perform transformations, handle side effects, and manage state in your applications.</p>"},{"location":"frontend/js/tools/node-version-manager/","title":"Node Version Manager","text":""},{"location":"frontend/js/tools/node-version-manager/#install-nvm","title":"Install NVM","text":"<ol> <li> <p>Install NVM using either <code>curl</code> or <code>wget</code>:</p> cURLwget <p>To install NVM using <code>curl</code>, run the following command:</p> <pre><code>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.2/install.sh | bash\n</code></pre> <p>To install NVM using <code>wget</code>, run the following command:</p> <pre><code>wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.2/install.sh | bash\n</code></pre> </li> <li> <p>Source the new instructions NVM added to <code>.bashrc</code> during the installation process. You can either exit and re-enter the shell console, or manually source your <code>.bashrc</code> file. This file is almost always located at the root of your home directory:</p> <pre><code>source ~/.bashrc\n</code></pre> </li> <li> <p>Confirm the version of NVM that is running with the following command:</p> <pre><code>nvm --version\n</code></pre> </li> </ol>"},{"location":"frontend/js/tools/node-version-manager/#reference","title":"Reference","text":"<ul> <li>node version manager nvm</li> </ul>"},{"location":"frontend/js/tools/eslint/intro/","title":"Intro","text":""},{"location":"frontend/js/tools/eslint/intro/#theory","title":"Theory","text":""},{"location":"frontend/js/tools/eslint/intro/#what-is-eslint","title":"What is ESLint?","text":"<p>ESLint is an open-source JavaScript linting tool that helps developers find and fix problems in their JavaScript code. Linting is the process of analyzing code for potential errors, bugs, stylistic errors, and suspicious constructs.</p>"},{"location":"frontend/js/tools/eslint/intro/#where-does-eslint-come-from","title":"Where Does ESLint Come From?","text":"<p>ESLint was created by Nicholas C. Zakas in June 2013. It was developed to address some of the limitations of other JavaScript linting tools like <code>JSLint</code> and <code>JSHint</code>. ESLint is highly configurable and extensible, which has made it the preferred choice for many developers.</p>"},{"location":"frontend/js/tools/eslint/intro/#how-to-use-eslint","title":"How to Use ESLint","text":"Installation: <ol> <li> <p>Install ESLint:     Use npm (Node Package Manager) or yarn to install ESLint in your project.</p> <pre><code>npm install eslint --save-dev\n# or\nyarn add eslint --dev\n</code></pre> </li> <li> <p>Initialize ESLint:</p> <p>Run the ESLint initialization command to create a configuration file (<code>.eslintrc.json</code>).</p> <pre><code>npx eslint --init\n</code></pre> </li> </ol>"},{"location":"frontend/js/tools/eslint/intro/#configuration","title":"Configuration:","text":"<ol> <li> <p>Config File:</p> <p>The initialization command will prompt you to answer a series of questions to set up your configuration file. Here is an example <code>.eslintrc.json</code>:</p> <pre><code>{\n    \"env\": {\n        \"browser\": true,\n        \"es2021\": true\n    },\n    \"extends\": \"eslint:recommended\",\n    \"parserOptions\": {\n        \"ecmaVersion\": 12,\n        \"sourceType\": \"module\"\n    },\n    \"rules\": {\n        \"indent\": [\"error\", 2],\n        \"linebreak-style\": [\"error\", \"unix\"],\n        \"quotes\": [\"error\", \"single\"],\n        \"semi\": [\"error\", \"always\"]\n    }\n}\n</code></pre> <ol> <li>Custom Rules:</li> </ol> <p>You can customize ESLint rules according to your project's needs by modifying the <code>rules</code> section in the configuration file.</p> </li> </ol>"},{"location":"frontend/js/tools/eslint/intro/#running-eslint","title":"Running ESLint:","text":"<ol> <li> <p>Command Line:</p> <p>You can run ESLint from the command line to lint your code:</p> <pre><code>npx eslint yourfile.js\n</code></pre> </li> <li> <p>Automatic Fixes:</p> <p>ESLint can automatically fix certain issues:</p> <pre><code>npx eslint yourfile.js --fix\n</code></pre> </li> </ol>"},{"location":"frontend/js/tools/eslint/intro/#integration-with-code-editors","title":"Integration with Code Editors:","text":"<ol> <li> <p>VSCode:</p> <p>Install the ESLint extension from the Visual Studio Code Marketplace to get real-time linting feedback.</p> </li> <li> <p>Other Editors:</p> <p>Most popular editors like Atom, Sublime Text, and WebStorm have plugins or built-in support for ESLint.</p> </li> </ol>"},{"location":"frontend/js/tools/eslint/intro/#do-we-need-to-use-eslint-in-react","title":"Do We Need to Use ESLint in React?","text":"<p>Using ESLint in React projects is highly recommended for several reasons:</p> <ol> <li> <p>Code Quality: ESLint helps ensure that your React code follows best practices and avoids common pitfalls.</p> </li> <li> <p>Consistency: Enforces a consistent coding style across your React codebase, making it easier to read and maintain.</p> </li> <li> <p>Error Prevention: Helps catch potential errors early in the development process, reducing the likelihood of bugs in production.</p> </li> <li> <p>Integration: ESLint can be easily integrated with React projects, especially with popular configurations like Airbnb's style guide, which includes rules for React and JSX.</p> </li> </ol>"},{"location":"frontend/js/tools/eslint/intro/#example-configuration-for-react","title":"Example Configuration for React:","text":"<p>To use ESLint with React, you can extend a popular style guide like Airbnb\u2019s that includes React-specific linting rules. Here is an example <code>.eslintrc.json</code> for a React project:</p> <pre><code>{\n  \"env\": {\n    \"browser\": true,\n    \"es2021\": true,\n    \"node\": true\n  },\n  \"extends\": [\n    \"eslint:recommended\",\n    \"plugin:react/recommended\",\n    \"airbnb\"\n  ],\n  \"parserOptions\": {\n    \"ecmaFeatures\": {\n      \"jsx\": true\n    },\n    \"ecmaVersion\": 12,\n    \"sourceType\": \"module\"\n  },\n  \"plugins\": [\n    \"react\"\n  ],\n  \"rules\": {\n    \"react/react-in-jsx-scope\": \"off\",\n    \"indent\": [\"error\", 2],\n    \"linebreak-style\": [\"error\", \"unix\"],\n    \"quotes\": [\"error\", \"single\"],\n    \"semi\": [\"error\", \"always\"]\n  }\n}\n</code></pre> <p>Using ESLint in your React projects will help you maintain high code quality, consistent style, and catch errors early, ultimately leading to more robust and maintainable code.</p>"},{"location":"frontend/js/tools/eslint/intro/#add-eslint-scripts-to-packagejson","title":"Add ESLint Scripts to <code>package.json</code>","text":"<pre><code>{\n  \"scripts\": {\n    \"lint\": \"eslint 'src/**/*.{js,jsx}'\",\n    \"lint:fix\": \"eslint 'src/**/*.{js,jsx}' --fix\"\n  }\n}\n</code></pre>"},{"location":"frontend/js/tools/npm/example/","title":"Example","text":"<p>npm is a powerful package manager for JavaScript and Node.js, serving as the default package manager for the <code>Node.js</code> runtime environment. It includes a command-line client (npm) and an online repository (<code>npm registry</code>) for hosting and sharing JavaScript packages.</p> Example"},{"location":"frontend/js/tools/npm/example/#using-npm-flags-effectively-when-to-use-d-s-and-more","title":"Using npm Flags Effectively: When to Use <code>-D</code>, <code>-S</code>, and More","text":"<ol> <li> <p>-D or --save-dev:</p> <ul> <li>Purpose: Install packages needed only for development, such as build tools, testing libraries, and linters. This means the package will be listed under the devDependencies section in the <code>package.json</code> file.</li> <li>Usage: Use this flag when adding development tools that aren\u2019t needed in production.</li> <li>Example: <code>npm install -D jest eslint webpack</code></li> </ul> </li> <li> <p>No Flag or --save or -S:</p> <ul> <li>Purpose: Install packages needed for both <code>development</code> and <code>production</code>, such as frameworks and libraries. This is the default behavior when you run <code>npm install</code> without any flags. It installs the package as a dependency and adds it to the dependencies section in <code>package.json</code>.</li> <li>Usage: Use this default behavior for core dependencies required to run your application.</li> <li>Example: <code>npm install react express axios</code></li> </ul> </li> <li> <p>-g or --global:</p> <ul> <li>Purpose: Install packages globally for system-wide access, useful for CLI tools and utilities.</li> <li>Usage: Use this flag for tools you want to use from the command line across projects.</li> <li>Example: <code>npm install -g nodemon</code></li> </ul> </li> <li> <p>--exact or -E:</p> <ul> <li>Purpose: Install packages with an exact version, avoiding automatic updates.</li> <li>Usage: Use this for version consistency in your project.</li> <li>Example: <code>npm install lodash@4.17.21 -E</code></li> </ul> </li> <li> <p>--no-save:</p> <ul> <li>Purpose: Install a package temporarily without adding it to package.json.</li> <li>Usage: Use this for testing or one-time installs.</li> <li>Example: <code>npm install some-temporary-package --no-save</code></li> </ul> </li> <li> <p>--save-optional or -O:</p> <ul> <li>Purpose: Install packages that are not essential but provide additional functionality if available.</li> <li>Usage: Use this for optional dependencies that enhance your project but aren't critical.</li> <li>Example: <code>npm install fsevents -O</code></li> </ul> </li> <li> <p>--save-peer:</p> <ul> <li>Purpose: Install packages as peer dependencies, which are meant to work alongside a specific version of another package.</li> <li>Usage: Use this for packages that should be compatible with a specific version of a core dependency.</li> <li>Example: <code>npm install react@^17.0.0 -P</code></li> </ul> </li> </ol> <p>Choosing the right flag ensures that your dependencies are managed effectively, keeping your project organized and efficient.</p> <p>Summary</p> <ul> <li>Use -D for development dependencies.</li> <li>Use without any flag for production dependencies.</li> <li>Use -g for globally installed tools.</li> <li>Use -E for exact version installations.</li> <li>Use --no-save for temporary installations.</li> <li>Use -O for optional dependencies.</li> <li>Use -P for peer dependencies.</li> </ul>"},{"location":"frontend/js/tools/npm/example/#deep-dive-into-packagejson","title":"Deep Dive into <code>package.json</code>","text":"<p>The <code>package.json</code> file is central to any <code>Node.js</code> project, serving as the manifest for your project. It defines project metadata, dependencies, scripts, and configurations. Here\u2019s an in-depth look at the key sections and features of package.json:</p>"},{"location":"frontend/js/tools/npm/example/#scripts","title":"Scripts","text":"<ul> <li>Purpose: Defines custom commands that can be run using <code>npm run &lt;script-name&gt;</code>.</li> <li>Examples:</li> </ul> <pre><code>\"scripts\": {\n    \"start\": \"node index.js\",\n    \"test\": \"jest\",\n    \"build\": \"webpack --config webpack.config.js\"\n}\n</code></pre> <ul> <li>Custom Scripts: You can create scripts for various tasks like testing, building, linting, and more. Scripts can be executed with <code>npm run &lt;script-name&gt;</code>.</li> </ul>"},{"location":"frontend/js/tools/npm/example/#dependencies","title":"Dependencies","text":"<ul> <li>dependencies: Packages required for the application to run in production.</li> </ul> <pre><code>\"dependencies\": {\n    \"express\": \"^4.17.1\",\n    \"axios\": \"^0.21.1\"\n}\n</code></pre> <ul> <li>devDependencies: Packages needed only during development (e.g., testing frameworks, build tools).</li> </ul> <pre><code>\"devDependencies\": {\n    \"jest\": \"^26.6.3\",\n    \"webpack\": \"^5.24.4\"\n}\n</code></pre> <ul> <li>optionalDependencies: Packages that are not essential but provide additional features if available.</li> </ul> <pre><code>\"optionalDependencies\": {\n    \"fsevents\": \"^1.2.13\"\n}\n</code></pre> <ul> <li>peerDependencies: Packages that your project needs to work alongside a specific version of another package.</li> </ul> <pre><code>\"peerDependencies\": {\n    \"react\": \"^17.0.2\"\n}\n</code></pre>"},{"location":"frontend/js/tools/npm/example/#configurations","title":"Configurations","text":"<ul> <li>engines: Specifies which versions of Node.js and other engines your project is compatible with.</li> </ul> <pre><code>\"engines\": {\n    \"node\": \"&gt;=12.0.0\"\n}\n</code></pre> <ul> <li>browserslist: Defines the list of browsers that your project should support, used by tools like Babel and Autoprefixer.</li> </ul> <pre><code>\"browserslist\": [\n    \"&gt; 1%\",\n    \"last 2 versions\",\n    \"not dead\"\n]\n</code></pre>"},{"location":"frontend/js/tools/npm/example/#scripts-configuration-hooks","title":"Scripts Configuration <code>Hooks</code>","text":"<ul> <li>pre and post Hooks: Special scripts that run before or after a specific script. For example, <code>pretest</code> runs before test, and <code>postbuild</code> runs after build.</li> </ul> <pre><code>\"scripts\": {\n    \"pretest\": \"echo Preparing for tests...\",\n    \"test\": \"jest\",\n    \"posttest\": \"echo Tests completed!\"\n}\n</code></pre>"},{"location":"frontend/js/tools/npm/example/#package-metadata","title":"Package Metadata","text":"<ul> <li>main: The entry point of your project or package, usually the main file.</li> </ul> <pre><code>\"main\": \"index.js\"\n</code></pre>"},{"location":"frontend/js/tools/npm/example/#workspaces","title":"Workspaces","text":"<ul> <li> <p>Purpose: Manage multiple packages within a single repository. Useful for monorepos.</p> </li> <li> <p>Configuration:</p> </li> </ul> <pre><code>\"workspaces\": [\n  \"packages/*\"\n]\n</code></pre>"},{"location":"frontend/js/tools/npm/example/#summary","title":"Summary","text":"<ul> <li><code>package.json</code> is crucial for defining project metadata, managing dependencies, configuring scripts, and setting up project settings.</li> <li>Scripts help automate development workflows.</li> <li>Dependencies are categorized into <code>dependencies</code>, <code>devDependencies</code>, <code>optionalDependencies</code>, and <code>peerDependencies</code> based on their role.</li> <li>Configurations and metadata fields help define how your project behaves and integrates with other tools.</li> </ul> <p>Mastering <code>package.json</code> allows you to effectively manage your <code>Node.js</code> projects and streamline development processes.</p>"},{"location":"frontend/js/tools/npm/intro/","title":"Intro","text":""},{"location":"frontend/js/tools/npm/intro/#overview","title":"Overview","text":"<ul> <li> npm (Node Package Manager)</li> </ul> <p>Comes pre-installed with Node.js, no additional setup required.</p> <p> Reference</p> <ul> <li> Yarn</li> </ul> <p>Excellent support for monorepos and managing multiple packages within a single repository.</p> <p> Reference</p> <ul> <li> pnpm (Performant npm)</li> </ul> <p>Uses a unique approach of symlinking packages which saves space and speeds up installations.</p> <p> Reference</p>"},{"location":"frontend/js/tools/npm/intro/#decision-factors","title":"Decision Factors","text":"<ol> <li>Performance Needs: If speed and efficiency are crucial, consider Yarn or pnpm.</li> <li>Monorepo Management: For projects with multiple packages, Yarn or pnpm\u2019s workspace features are beneficial.</li> <li>Team Familiarity: Choose the package manager that your team is most comfortable with to minimize the learning curve.</li> <li>Ecosystem and Tooling: Consider the compatibility of the package manager with other tools and services you use.</li> </ol>"},{"location":"frontend/js/tools/npm/intro/#summary","title":"Summary","text":"<ul> <li>Use npm if you prefer the default, out-of-the-box solution with Node.js.</li> <li>Use Yarn if you need faster installs, stability, and good monorepo support.</li> <li>Use pnpm if you want the best performance and disk space efficiency, and are open to adopting newer tools.</li> </ul>"},{"location":"frontend/js/tools/pnpm/advanced/","title":"Advanced","text":""},{"location":"frontend/js/tools/pnpm/advanced/#pnpm-overview","title":"pnpm overview","text":"Installation<pre><code>npm install -g pnpm\n</code></pre> Scaffolding Your First Vite Project<pre><code>pnpm create vite\n</code></pre> <pre><code># Install pnpm globally if not installed\nnpm install -g pnpm\n\n# Create the project with React and TypeScript template\npnpm create vite my-react-ts-app --template react-ts\n\n# Navigate into the project directory\ncd my-react-ts-app\n\n# Install dependencies\npnpm install\n\n# Start the development server\npnpm run dev\n\n# Build the production version of the app\npnpm run build\n\n# Preview the production build\npnpm run preview\n</code></pre> 1. <code>npm list</code> Shows Local Dependencies, Not Global <p>The <code>npm list</code> command by default shows the dependencies for your current project (i.e., the local <code>node_modules</code> in the current directory). If you installed <code>pnpm</code> globally, it will not show up in the output of npm list unless you specify the global flag.</p> <p>Solution:</p> <p>To list globally installed packages with <code>npm</code>, use the following command:</p> <pre><code>npm list -g --depth=0\n</code></pre> <p>This will show all globally installed packages (including <code>pnpm</code>) at the top level.</p>"},{"location":"frontend/js/tools/pnpm/advanced/#pnpm-a-comprehensive-guide","title":"PNPM: A Comprehensive Guide","text":"<p>PNPM (pronounced as \"Pee-En-Pee-Em\") is a fast, disk space-efficient package manager for JavaScript, specifically designed to handle the installation of dependencies for Node.js projects. It is an alternative to other package managers like npm (Node Package Manager) and Yarn, offering better performance and disk space utilization.</p> <p>Let's break it down step by step, from basic concepts to advanced usage.</p> Tip What is PNPM?Why Do We Need PNPM?When to Use PNPM?When Not to Use PNPM <ul> <li>Package Manager: Like npm and Yarn, PNPM is a tool that helps you manage libraries and dependencies in your JavaScript or Node.js projects.</li> <li>Efficiency: What sets PNPM apart is its focus on optimizing disk space usage and speeding up dependency installation, especially in large projects.</li> <li>Global Store: Instead of downloading a package separately for each project, PNPM uses a global store where it keeps downloaded packages. It then links them to each project, minimizing duplication and reducing disk usage.</li> </ul> <ol> <li> <p>Performance:</p> <p>PNPM installs packages faster than npm and Yarn, especially in large projects. This is because it stores packages globally, avoiding redundant downloads.</p> </li> <li> <p>Disk Space Efficiency:</p> <p>PNPM uses hard links to share common dependencies between different projects. If two projects use the same package (with the same version), PNPM won\u2019t download it twice. Instead, it creates a link to the existing package in the global store, which saves disk space.</p> </li> <li> <p>Consistency:</p> <p>PNPM strictly enforces a deterministic node_modules structure. This means the dependency tree is always the same, even if you install packages on different machines. This can help avoid \"it works on my machine\" issues.</p> </li> <li> <p>Better Dependency Resolution:</p> <p>PNPM uses a strict algorithm for resolving dependencies, meaning that if a package needs a specific version of a dependency, it will only install that version (no more \"hoisting\" to higher levels of the dependency tree, which can cause issues).</p> </li> </ol> <ul> <li> <p>Performance and Efficiency Needs:</p> <p>If you\u2019re working on a large project or managing multiple projects that share dependencies, PNPM can dramatically reduce installation times and disk usage.</p> </li> <li> <p>Modern JavaScript Ecosystem:</p> <p>For frontend and backend projects, especially when you're managing monorepos or large-scale applications, PNPM\u2019s optimization features come in handy.</p> </li> <li> <p>If You're Tired of NPM's Performance and Dependency Issues:</p> <p>If you've encountered slow npm install times or inconsistencies in dependency resolutions (e.g., issues caused by hoisting in node_modules), PNPM can solve many of these problems.</p> </li> </ul> <ol> <li> <p>Legacy Projects:</p> <p>If you're working on a project that requires using npm or Yarn due to compatibility or organizational constraints, it might not be worth switching to PNPM unless there's a clear need for the benefits it offers.</p> </li> <li> <p>Third-Party Tools/Plugins:</p> <p>Some tools and integrations are still optimized for npm or Yarn. In rare cases, certain third-party tools might not support PNPM well, though this is becoming less of an issue over time.</p> </li> </ol> <p>The major benefit of using pnpm over npm is its <code>efficient disk space usage</code> and <code>performance optimization</code>, particularly when dealing with large projects or <code>monorepos</code>.</p> Difference between <code>install</code> and <code>add</code> in pnpm <p>In pnpm, both <code>add</code> and <code>install</code> are commands related to managing dependencies in a project, but they serve different purposes:</p> 1. pnpm add2. pnpm installKey Differences: <p>The pnpm add command is used to add a new dependency to your project. This will install the dependency and update the pnpm-lock.yaml and package.json files accordingly.</p> <ul> <li> <p>Usage:</p> <ul> <li><code>pnpm add &lt;package&gt;</code> \u2013 Adds a package as a regular dependency.</li> <li><code>pnpm add &lt;package&gt;@&lt;version&gt;</code> \u2013 Adds a specific version of a package.</li> <li><code>pnpm add &lt;package&gt; --dev</code> \u2013 Adds a package as a development dependency.</li> <li><code>pnpm add &lt;package&gt; --save-peer</code> \u2013 Adds a package as a peer dependency.</li> </ul> </li> <li> <p>Example:</p> <pre><code>pnpm add lodash\n</code></pre> <p>This will add <code>lodash</code> as a dependency to your <code>package.json</code> and install it into the <code>node_modules</code> folder.</p> </li> </ul> <p>The pnpm install command is used to install all dependencies listed in the package.json file. It will install both regular and development dependencies that are already specified in your project, without adding or modifying the package.json.</p> <ul> <li> <p>Usage:</p> <ul> <li><code>pnpm install</code> \u2013 Installs all dependencies in the current project.</li> <li><code>pnpm install --prod</code> \u2013 Installs only production dependencies (ignores dev dependencies).</li> <li><code>pnpm install &lt;package&gt;</code> \u2013 Installs a specific package, if you want to install without adding it to the <code>package.json</code> (essentially a one-off installation).</li> </ul> </li> <li> <p>Example:</p> <pre><code>pnpm install\n</code></pre> <p>This will install all dependencies defined in your <code>package.json</code> into the <code>node_modules</code> folder.</p> </li> </ul> <ul> <li><code>pnpm add</code>: Used to add a new dependency (and update package.json), and install it.</li> <li><code>pnpm install</code>: Used to install the dependencies already defined in package.json, including any changes to the lockfile.</li> </ul> <ul> <li> <p>In summary:</p> <ul> <li>Use <code>pnpm add</code> when you want to add a new package to the project.</li> <li>Use <code>pnpm install</code> when you want to install all the dependencies that are already listed in <code>package.json</code>.</li> </ul> </li> </ul>"},{"location":"frontend/js/tools/pnpm/advanced/#how-to-use-pnpm","title":"How to Use PNPM","text":"Example 1. Installation2. Basic Usage3. Advanced Usage <p>You can install PNPM globally using npm or Yarn</p> <ul> <li> <p>Via npm:</p> <pre><code>npm install -g pnpm\n</code></pre> </li> <li> <p>Via Yarn:</p> <pre><code>npm install -g pnpm\n</code></pre> </li> </ul> <p>After installation, you can check the version to confirm it worked:</p> <pre><code>pnpm --version\n</code></pre> <ul> <li> <p>Initialize a new project (<code>package.json</code>): To start using PNPM in a new project, run the following:</p> <pre><code>pnpm init\n</code></pre> <p>This will create a <code>package.json</code> file, just like npm init.</p> </li> <li> <p>Install Dependencies: To install all dependencies listed in the <code>package.json</code> file:</p> <pre><code>pnpm install\n</code></pre> <p>PNPM will install dependencies into the <code>node_modules</code> folder using hard links from the global store.</p> </li> <li> <p>Install a Package (One-time install): To install a specific package and add it to <code>dependencies</code> in <code>package.json</code></p> <pre><code>pnpm add &lt;package-name&gt;\n</code></pre> <p>You can also install development dependencies by using <code>-D</code>:</p> <pre><code>pnpm add &lt;package-name&gt; -D\n</code></pre> </li> <li> <p>Install a Specific Version of a Package:</p> <pre><code>pnpm add &lt;package-name&gt;@&lt;version&gt;\n</code></pre> <p>For example:</p> <pre><code>pnpm add lodash@4.17.21\n</code></pre> </li> <li> <p>Uninstall a Package: To remove a package:</p> <pre><code>pnpm remove &lt;package-name&gt;\n</code></pre> </li> </ul> <ul> <li> <p>Workspaces / Monorepos: PNPM supports workspaces, which is useful when you're managing multiple packages in a single repository (a monorepo). You can set up multiple packages and install them all with one command:</p> <ol> <li>Create a <code>pnpm-workspace.yaml</code> file in the root directory.</li> <li> <p>List your packages in that file:</p> <pre><code>packages:\n    - 'packages/*'\n</code></pre> </li> <li> <p>Inside your packages, use <code>pnpm</code> install to install dependencies across the entire workspace.</p> </li> </ol> <p>PNPM automatically links dependencies between your packages within the monorepo, which is a big advantage when working with large codebases that share dependencies.</p> </li> <li> <p>Run Scripts: You can use PNPM to run scripts defined in your <code>package.json</code>:</p> <pre><code>pnpm run &lt;script-name&gt;\n</code></pre> </li> <li> <p>Global Packages: To install packages globally using PNPM, use:</p> <pre><code>pnpm add -g &lt;package-name&gt;\n</code></pre> <p>This will install the package globally, and you can run it directly from the command line.</p> </li> <li> <p>Auditing Dependencies: To check for security vulnerabilities in your project\u2019s dependencies:</p> <pre><code>pnpm audit\n</code></pre> </li> <li> <p>Linking Local Packages: If you're developing multiple local packages and need to link them, you can use the <code>pnpm link</code> command to create symlinks between them:</p> <pre><code>pnpm link &lt;package-name&gt;\n</code></pre> </li> <li> <p>Custom Store: You can customize where PNPM stores its global store. For example, you can set a custom directory by adding this to your <code>.npmrc</code> or <code>pnpmfile.js</code>:</p> <pre><code>pnpm store-dir /path/to/store\n</code></pre> </li> </ul>"},{"location":"frontend/js/tools/pnpm/advanced/#comparing-pnpm-with-npm-and-yarn","title":"Comparing PNPM with NPM and Yarn","text":"Feature PNPM NPM Yarn Speed Fast (due to global store and hard links) Slower (redownloads dependencies for every project) Faster than npm, but not as fast as PNPM Disk Usage Low (global store, hard links) High (duplicates dependencies across projects) Lower than npm but higher than PNPM Deterministic Install Yes (strict dependency tree) No (hoisting can cause issues) Yes Workspaces Support Yes No (requires third-party tool) Yes CLI Commands Similar to npm Standard npm commands Similar to npm Community Growing rapidly Largest (since it's the default package manager for Node.js) Large, but smaller than npm"},{"location":"frontend/js/tools/pnpm/advanced/#conclusion","title":"Conclusion","text":"<p>PNPM is a fast, efficient, and modern alternative to npm and Yarn, offering unique advantages in performance, disk space usage, and dependency management. It's especially beneficial for large-scale projects, monorepos, or teams looking for a more efficient way of managing Node.js dependencies.</p> <p>When adopting PNPM, the transition is straightforward if you're familiar with npm or Yarn. The key advantages \u2014 faster installs, less disk usage, and strict dependency resolution \u2014 can be highly beneficial for large projects, while its simplicity and ease of use ensure it\u2019s a good fit for individual developers as well.</p>"},{"location":"frontend/js/tools/pnpm/advanced/#vite-overview","title":"vite overview","text":"<p>Vite, being a fast and flexible build tool, has a rich ecosystem of plugins that extend its functionality for various tasks such as code transformation, asset handling, testing, and more. Below are some of the commonly used types of plugins in the Vite ecosystem:</p>"},{"location":"frontend/js/tools/pnpm/advanced/#1-official-vite-plugins","title":"1. Official Vite Plugins","text":"<p>These plugins are developed and maintained by the Vite team itself and are included in the core ecosystem:</p> <ul> <li> <p>@vitejs/plugin-vue   Provides support for Vue 3 in Vite. This plugin handles .vue file parsing, component support, and more.</p> </li> <li> <p>@vitejs/plugin-react   Adds React Fast Refresh and support for React files (.jsx/.tsx).</p> </li> <li> <p>@vitejs/plugin-vue-jsx   Adds support for Vue 3 JSX syntax.</p> </li> <li> <p>@vitejs/plugin-legacy   Provides support for legacy browsers by generating polyfills and transforming code accordingly.</p> </li> <li> <p>vite-plugin-svelte   Adds support for Svelte, enabling the compilation of .svelte files.</p> </li> <li> <p>vite-plugin-static-copy   A plugin that allows you to copy static assets (files or directories) into the build output.</p> </li> </ul>"},{"location":"frontend/js/tools/pnpm/advanced/#2-css-related-plugins","title":"2. CSS-related Plugins","text":"<ul> <li> <p>vite-plugin-sass-dts   Generates <code>.d.ts</code> TypeScript declaration files for SASS variables, mixins, and functions.</p> </li> <li> <p>vite-plugin-postcss   Allows custom PostCSS configuration for your project.</p> </li> <li> <p>vite-plugin-sass   Enhances Vite's Sass/SCSS support.</p> </li> <li> <p>vite-plugin-tailwind   Optimizes Tailwind CSS configuration and integration.</p> </li> <li> <p>vite-plugin-stylus   Adds Stylus support for Vite projects.</p> </li> </ul>"},{"location":"frontend/js/tools/pnpm/advanced/#3-typescriptjsxtsx-related-plugins","title":"3. TypeScript/JSX/TSX-related Plugins","text":"<ul> <li> <p>vite-plugin-checker   Provides TypeScript type checking and ESLint checking during development.</p> </li> <li> <p>vite-plugin-tsconfig-paths   Automatically resolves TypeScript paths based on the tsconfig.json paths configuration.</p> </li> <li> <p>vite-plugin-swc   A plugin that uses swc (Speedy Web Compiler) to transpile JavaScript and TypeScript instead of Babel.</p> </li> <li> <p>vite-plugin-prettier   Integrates Prettier into the Vite build process to format files automatically.</p> </li> </ul>"},{"location":"frontend/js/tools/pnpm/advanced/#4-development-tools-features","title":"4. Development Tools &amp; Features","text":"<ul> <li> <p>vite-plugin-env-compatible   Provides compatibility for environment variables in Vite, ensuring that .env files and variables are correctly handled.</p> </li> <li> <p>vite-plugin-serve   Serves static files during development or production using Vite\u2019s dev server.</p> </li> <li> <p>vite-plugin-progress   Displays a progress bar in the terminal during the build process.</p> </li> <li> <p>vite-plugin-mock   Allows for easy integration of mock APIs during development.</p> </li> <li> <p>vite-plugin-html   Extends HTML handling in Vite with various enhancements, including template injections.</p> </li> </ul>"},{"location":"frontend/js/tools/pnpm/advanced/#5-code-splitting-optimization-plugins","title":"5. Code Splitting &amp; Optimization Plugins","text":"<ul> <li> <p>vite-plugin-prerender   Allows you to prerender specific pages during the build process, often used for static site generation.</p> </li> <li> <p>vite-plugin-import   Optimizes imports and reduces bundle size by automatically removing unused code or assets from dependencies.</p> </li> <li> <p>vite-plugin-purgecss   Integrates PurgeCSS with Vite to remove unused CSS and reduce the final bundle size.</p> </li> <li> <p>vite-plugin-bundle-visualizer   Visualizes your final bundle with detailed stats about how much space different dependencies take up.</p> </li> </ul>"},{"location":"frontend/js/tools/pnpm/advanced/#6-image-asset-related-plugins","title":"6. Image &amp; Asset-related Plugins","text":"<ul> <li> <p>vite-plugin-imagemin   Optimizes images in your project to reduce their size without losing quality.</p> </li> <li> <p>vite-plugin-assets   Handles static assets, including images, fonts, etc., and can bundle them efficiently in the final build.</p> </li> <li> <p>vite-plugin-optimize-images   Similar to the imagemin plugin but with additional features to optimize the handling of images.</p> </li> </ul>"},{"location":"frontend/js/tools/pnpm/advanced/#7-backend-api-related-plugins","title":"7. Backend &amp; API-related Plugins","text":"<ul> <li> <p>vite-plugin-graphql   Provides GraphQL-related tooling, such as schema generation and query handling.</p> </li> <li> <p>vite-plugin-cloudflare-workers   Allows you to deploy your Vite project as a Cloudflare Worker.</p> </li> <li> <p>vite-plugin-netlify   Configures your Vite project for optimal deployment on Netlify.</p> </li> </ul>"},{"location":"frontend/js/tools/pnpm/advanced/#8-testing-plugins","title":"8. Testing Plugins","text":"<ul> <li> <p>vite-plugin-test   A plugin for running unit tests, integration tests, or end-to-end tests with Vite.</p> </li> <li> <p>vite-plugin-jest   Integrates Jest testing framework into Vite projects for unit testing.</p> </li> <li> <p>vite-plugin-vitest   Adds Vitest, a fast unit test runner built for Vite, to your project.</p> </li> </ul>"},{"location":"frontend/js/tools/pnpm/advanced/#9-framework-specific-plugins","title":"9. Framework-Specific Plugins","text":"<ul> <li> <p>vite-plugin-nuxt   Adds support for Nuxt.js features in Vite.</p> </li> <li> <p>vite-plugin-next   Adds support for Next.js features, such as React Server Components, in Vite-based projects.</p> </li> <li> <p>vite-plugin-markdown   Processes Markdown files and allows importing them into your project as .md files.</p> </li> </ul>"},{"location":"frontend/js/tools/pnpm/advanced/#10-miscellaneous-plugins","title":"10. Miscellaneous Plugins","text":"<ul> <li> <p>vite-plugin-svgr   This plugin enables importing SVG files as React components, which is especially useful for projects with heavy SVG use.</p> </li> <li> <p>vite-plugin-mdx   Adds support for MDX (Markdown with embedded JSX) in Vite.</p> </li> <li> <p>vite-plugin-webfont-dl   Automatically downloads and serves web fonts during the build process.</p> </li> <li> <p>vite-plugin-eslint   Automatically runs ESLint in the development environment to lint files on save.</p> </li> </ul>"},{"location":"frontend/js/tools/pnpm/advanced/#11-custom-plugins","title":"11. Custom Plugins","text":"<ul> <li>vite-plugin-custom   If you're developing a Vite plugin for your specific use case, you can write your own custom plugin by using the Vite plugin API, which allows you to hook into Vite\u2019s lifecycle events.</li> </ul>"},{"location":"frontend/js/tools/pnpm/advanced/#conclusion_1","title":"Conclusion","text":"<p>The Vite plugin ecosystem is vast and continues to grow. By selecting the right plugins for your project, you can tailor Vite to suit your specific needs, whether it's optimizing your build, adding support for additional frameworks, or improving your development experience.</p> <p>If you\u2019re looking for specific plugins for your project, the Vite Plugin Catalog is a great place to start!</p> Summary of Must-Have Plugins for Your Setup React: <ul> <li>@vitejs/plugin-react \u2013 Essential for React projects.</li> <li>vite-plugin-checker \u2013 TypeScript and ESLint integration during development.</li> <li>vite-plugin-tsconfig-paths \u2013 Ensures TypeScript path aliases work seamlessly in Vite.</li> <li>vite-plugin-swc (Optional for speed) \u2013 Uses swc to speed up TypeScript compilation.</li> <li>vite-plugin-svgr (Optional) \u2013 If using SVGs as React components.</li> <li>vite-plugin-eslint (Optional) \u2013 For continuous linting during development.</li> </ul>"},{"location":"frontend/js/tools/pnpm/advanced/#typescript-overview","title":"TypeScript overview","text":"<ul> <li>Basic types and type annotations</li> <li>Functions, arrays, and objects</li> <li>Classes, inheritance, and generics</li> <li>Modules and TypeScript configuration</li> </ul> <pre><code>After 4 Hours: Next Steps\n\nBy the end of the 4 hours, you'll have a solid understanding of the following concepts:\n\n-   Basic types and type annotations\n-   Functions, arrays, and objects\n-   Classes, inheritance, and generics\n-   Modules and TypeScript configuration\n</code></pre>"},{"location":"frontend/js/tools/pnpm/advanced/#reference","title":"Reference","text":"<ul> <li>pnpm: Official Docs</li> <li>vite: Official Docs</li> </ul>"},{"location":"frontend/js/tools/pnpm/intro/","title":"Intro","text":"<p>pnpm (Performant npm):</p> <ul> <li>Focuses on efficient disk space usage and speed.</li> <li>Shares dependencies across projects without duplicating them.</li> <li>Uses a <code>pnpm-lock.yaml</code> file to lock dependencies.</li> <li>Command examples: <code>pnpm install</code>, <code>pnpm update</code>, <code>pnpm remove</code>.</li> </ul>"},{"location":"frontend/js/tools/pnpm/intro/#installation","title":"Installation","text":"reacttypescript <pre><code>pnpm add antd\npnpm add @ant-design/icons\n\npnpm install @reduxjs/toolkit react-redux react react-router-dom\n\npnpm create vite my-vue-app --template react\npnpm create vite . --template react\n</code></pre> <pre><code>pnpm add @reduxjs/toolkit\n</code></pre> <pre><code>pnpm add redux-persist\n</code></pre> <pre><code>pnpm add axios\n</code></pre> <pre><code>pnpm add react-redux @reduxjs/toolkit @types/react-redux\n</code></pre>"},{"location":"frontend/js/tools/vite/example/","title":"Example","text":"<p>Vite has built-in support for environment variables, and you don't need to install the dotenv package manually.</p> <p>Here\u2019s how you can set it up step-by-step:</p> <p>1. Create <code>.env</code> File</p> <p>In the root of your project, create a <code>.env</code> file (if it doesn't exist already). In this file, you can define environment variables like this:</p> <pre><code>VITE_REACT_APP_BASE_API_URL=https://api.example.com\nVITE_REACT_APP_BLOG_API_URL=https://blog.example.com\nVITE_REACT_APP_TEST_API_URL=https://test.example.com\n</code></pre> <ul> <li>Note: Vite requires that environment variable names start with <code>VITE_</code> to expose them to the frontend (this is different from CRA, where you use <code>REACT_APP_</code>).</li> </ul> <p>2. Using Axios with Environment Variables</p> <p>Since you\u2019re using Axios, the example code you've written should work fine after making the changes to access the variables via <code>import.meta.env</code>. For example:</p> <pre><code>import axios from \"axios\";\nimport axiosConfig from \"./axiosConfig\";\n\nconst axiosInstance = {\n  base: axios.create({\n    baseURL: import.meta.env.VITE_REACT_APP_BASE_API_URL,\n    ...axiosConfig,\n  }),\n  blog: axios.create({\n    baseURL: import.meta.env.VITE_REACT_APP_BLOG_API_URL,\n    ...axiosConfig,\n  }),\n  test: axios.create({\n    baseURL: import.meta.env.VITE_REACT_APP_TEST_API_URL,\n    ...axiosConfig,\n  }),\n};\n\nexport default axiosInstance;\n</code></pre> Summary <ol> <li>Define environment variables in the .env file with the <code>VITE_</code> prefix.</li> <li>Access those variables using <code>import.meta.env</code> in your code.</li> <li>Restart your Vite dev server after changes to <code>.env</code>.</li> <li>Use these environment variables in your Axios setup, Redux store, or any other part of your code.</li> </ol> <p>Summary of Key Vite Features:</p> <ul> <li><code>import.meta.env</code>: Access environment variables during build time.</li> <li>Hot Module Replacement (HMR): Fast, real-time updates during development.</li> <li>ESBuild: Super-fast bundling and minification during development.</li> <li>Code Splitting &amp; Dynamic Imports: Load code as needed for faster performance.</li> <li>Static Assets: Serve images, fonts, and other assets directly from the <code>public</code> directory.</li> <li>TypeScript/JSX Support: Out-of-the-box support for TypeScript, JSX, and TSX.</li> <li>Rollup for Production: Efficient, production-ready bundling.</li> <li>Custom Plugins: Extend Vite with plugins for different use cases.</li> </ul>"},{"location":"frontend/js/tools/vite/example/#question","title":"Question","text":"<p>so where do we need dotnet package ?</p> <p>In the context of a React project using Vite, Redux Toolkit, Axios, and pnpm, you do not need the dotenv package.</p> <p>Why you don't need dotenv with Vite:</p> <ul> <li>Vite has built-in support for environment variables and automatically loads variables from <code>.env</code> files.</li> <li>You can use environment variables in Vite by prefixing them with <code>VITE_</code>, and they will be available at build time through <code>import.meta.env</code>.</li> <li>This means that you don't have to manually use dotenv to load environment variables, because Vite handles that for you.</li> </ul> <p>When would you need the dotenv package?</p> <p>The dotenv package is generally used in Node.js back-end environments or if you're working with custom Webpack configurations (outside of Vite). It allows you to load environment variables from a <code>.env</code> file into your Node.js process during server-side code execution.</p> <p>Here\u2019s a basic use case for dotenv in a Node.js project:</p> <p>1. Install dotenv:</p> <pre><code>npm install dotenv\n</code></pre> <p>2. Create <code>.env</code>file in the root of the project:</p> env<pre><code>DB_HOST=localhost\nDB_PORT=5432\n</code></pre> <p>3. Use <code>dotenv</code> in your Node.js code:</p> <pre><code>require(\"dotenv\").config(); // This will load the environment variables\n\nconsole.log(process.env.DB_HOST); // Should print \"localhost\"\n</code></pre> Key Points: <ul> <li>React + Vite + Frontend: Use <code>VITE_</code> prefixed variables in your <code>.env</code> file. No need for dotenv because Vite automatically processes <code>.env</code> files and makes variables available through <code>import.meta.env</code>.</li> <li>Node.js (Backend) or Custom Webpack: Use dotenv to load environment variables in the backend or if you're using custom configurations (e.g., if you're manually running a server that needs environment variables).</li> </ul> <p>In Summary:</p> <p>Since you're working with Vite in a frontend React app, you do not need the dotenv package. Just ensure your environment variables are prefixed with <code>VITE_</code>, and Vite will handle them automatically. Use <code>import.meta.env</code> to access them in your React components. The dotenv package is unnecessary for your specific setup.</p>"},{"location":"frontend/js/tools/vite/intro/","title":"Intro","text":""},{"location":"frontend/js/tools/vite/intro/#overview","title":"Overview","text":"<p>Vite is primarily needed during the development phase of a project, not in production. Here\u2019s why:</p> Abstract DevelopmentProductionConclusion <ul> <li>Fast Build and HMR: Vite provides a fast and efficient development server with Hot Module Replacement (HMR), allowing you to see changes in real-time without a full page reload.</li> <li>Modern JavaScript Support: Vite leverages native ES modules in the browser for faster builds and efficient module loading during development.</li> <li>Optimized for Development: Vite is optimized to improve the development experience with features like fast refresh, instant feedback, and efficient bundling.</li> </ul> <ul> <li>Build Process: Vite is used to build the final optimized bundle of your application. It handles tasks like minification, code splitting, and other optimizations to prepare your code for production deployment.</li> <li>Static Assets Handling: Vite can process and optimize static assets such as images, stylesheets, and other resources during the build process.</li> </ul> <ul> <li>In Development: You need Vite to run your development server, utilize HMR, and benefit from its fast build times and modern JavaScript support.</li> <li>In Production: Vite is used to build and optimize your application, but it is not required to run the application in a production environment. The built and optimized output from Vite is what gets deployed, not Vite itself.</li> </ul> <p>Therefore, you should install Vite as a <code>development dependency</code> using the -D flag:</p> <pre><code>npm install -D vite\n</code></pre> <p>This ensures that Vite is only used during the development phase and build process, not in the production environment.</p>"},{"location":"frontend/js/tools/vite/intro/#env-files","title":".env Files","text":"<p>Vite uses dotenv to load additional environment variables from the following files in your environment directory:</p> <pre><code>.env                # loaded in all cases\n.env.local          # loaded in all cases, ignored by git\n.env.[mode]         # only loaded in specified mode\n.env.[mode].local   # only loaded in specified mode, ignored by git\n</code></pre> Env Loading Priorities <p>An env file for a specific mode (e.g. <code>.env.production</code>) will take higher priority than a generic one (e.g. <code>.env</code>).</p> <p>In addition, environment variables that already exist when Vite is executed have the highest priority and will not be overwritten by <code>.env</code> files. For example, when running <code>VITE_SOME_KEY=123 vite build</code>.</p> <p><code>.env</code> files are loaded at the start of Vite. Restart the server after making changes.</p> <p>Loaded env variables are also exposed to your client source code via <code>import.meta.env</code> as strings.</p> <p>To prevent accidentally leaking env variables to the client, only variables prefixed with <code>VITE_</code> are exposed to your Vite-processed code. e.g. for the following env variables:</p> .env<pre><code>VITE_SOME_KEY=123\nDB_PASSWORD=foobar\n</code></pre> <p>Only <code>VITE_SOME_KEY</code> will be exposed as <code>import.meta.env.VITE_SOME_KEY</code> to your client source code, but <code>DB_PASSWORD</code> will not.</p> <pre><code>console.log(import.meta.env.VITE_SOME_KEY); // \"123\"\nconsole.log(import.meta.env.DB_PASSWORD); // undefined\n</code></pre> Env parsing <p>As shown above, <code>VITE_SOME_KEY</code> is a number but returns a string when parsed. The same would also happen for boolean env variables. Make sure to convert to the desired type when using it in your code.</p> <p>Also, Vite uses dotenv-expand to expand variables written in env files out of the box. To learn more about the syntax, check out their docs.</p> <p>Note that if you want to use <code>$</code> inside your environment value, you have to escape it with <code>\\</code>.</p>"},{"location":"frontend/js/tools/vite/intro/#scaffolding-your-first-vite-project","title":"Scaffolding Your First Vite Project","text":"Compatibility Note <p>Vite requires <code>Node.js</code> version 18+ or 20+. However, some templates require a higher Node.js version to work, please upgrade if your package manager warns about it.</p> NPMYarnPNPMBun <pre><code>$ npm create vite@latest\n</code></pre> <pre><code>$ yarn create vite\n</code></pre> <pre><code>$ pnpm create vite\n</code></pre> <pre><code>$ bun create vite\n</code></pre> <p>Then follow the prompts!</p> <p>You can also directly specify the project name and the template you want to use via additional command line options. For example, to scaffold a Vite + Vue project, run:</p> <pre><code># npm 7+, extra double-dash is needed:\nnpm create vite@latest my-vue-app -- --template vue\n\n# yarn\nyarn create vite my-vue-app --template vue\n\n# pnpm\npnpm create vite my-vue-app --template vue\n\n# bun\nbun create vite my-vue-app --template vue\n</code></pre> <p>You can use <code>.</code> for the project name to scaffold in the current directory.</p>"},{"location":"frontend/js/tools/vite/intro/#supported-template","title":"Supported Template","text":"<p>The supported template presets are:</p> JavaScript TypeScript vanilla vanilla-ts vue vue-ts react react-ts preact preact-ts lit lit-ts svelte svelte-ts solid solid-ts qwik qwik-ts"},{"location":"frontend/js/tools/vite/intro/#viteconfigjs","title":"vite.config.js","text":"Example ViteVite <pre><code>import { defineConfig } from 'vite';\nimport vue from '@vitejs/plugin-vue'; // Example plugin for Vue\nimport path from 'path';\n\nexport default defineConfig({\n    // Basic server configuration\n    server: {\n        port: 3000, // Specify the port number\n        open: true, // Automatically open the app in the default browser\n    },\n\n    // Aliases\n    resolve: {\n        alias: {\n        '@': path.resolve(__dirname, 'src'), // Simplify import paths\n        },\n    },\n\n    // Plugins\n    plugins: [\n        vue(), // Add plugins here\n    ],\n\n    // CSS Preprocessing\n    css: {\n        preprocessorOptions: {\n            scss: {\n                additionalData: `@import \"@/styles/global.scss\";`, // Example for SCSS\n            },\n        },\n    },\n\n    // Build options\n    build: {\n        outDir: 'dist', // Output directory for the build\n        sourcemap: true, // Enable source maps for debugging\n        rollupOptions: {\n            output: {\n                // Customize the output settings\n                chunkFileNames: 'js/[name]-[hash].js',\n                entryFileNames: 'js/[name]-[hash].js',\n                assetFileNames: 'assets/[name]-[hash].[ext]',\n            },\n        },\n    },\n\n    // Environment Variables\n    define: {\n        'process.env': process.env, // Use environment variables\n    },\n});\n</code></pre> <pre><code>// vite.config.js\nimport { defineConfig } from 'vite';\n\nexport default defineConfig({\n    // Basic server configuration\n    server: {\n        port: 3000, // set the port to 3000\n        host: 'localhost', // set the host\n        https: false, // enable HTTPS\n        open: true, // automatically open the app in the browser\n        cors: true, // enable CORS\n        proxy: {\n            // configure proxy rules\n            '/api': {\n                target: 'http://localhost:5000',\n                changeOrigin: true,\n                rewrite: (path) =&gt; path.replace(/^\\/api/, '')\n            }\n        }\n    }\n});\n</code></pre>"},{"location":"frontend/js/tools/vite/intro/#to-automatically-open-your-app-in-the-browser","title":"To automatically open your app in the browser","text":"<p>To automatically open your app in the browser when running npm run dev, you need to configure your <code>vite.config.js</code> file appropriately and ensure your <code>package.json</code> has the correct script.</p> <pre><code>// vite.config.js\nimport { defineConfig } from \"vite\";\n\nexport default defineConfig({\n  // Basic server configuration\n  server: {\n    open: true, // automatically open the app in the default browser\n    port: 3000, // you can also set the port if needed\n  },\n});\n</code></pre> <p>Updating <code>package.json</code></p> <p>In your package.json, make sure you have a script defined to start the Vite development server. It typically looks like this:</p> <pre><code>// package.json\n{\n  \"scripts\": {\n    \"dev\": \"vite\"\n  }\n}\n</code></pre> <p>Running the Development Server</p> <p>With the above configurations in place, running npm run dev will start the Vite development server and automatically open your app in the default web browser.</p> <pre><code>npm run dev\n</code></pre>"},{"location":"frontend/js/tools/vite/intro/#handling-jsxtsx-in-vite","title":"Handling JSX/TSX in Vite","text":"<p>Vite needs plugins to handle frameworks like React, Vue, etc. For React, you would typically use the <code>@vitejs/plugin-react plugin</code>.</p> <p>Install Necessary Plugins</p> <pre><code>npm install @vitejs/plugin-react\n</code></pre> <p>Update <code>vite.config.js</code> with Plugins</p> <p>Here is a complete example of <code>vite.config.js</code> for a React project:</p> <pre><code>import { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\n\nexport default defineConfig({\n  plugins: [react()],\n  resolve: {\n    alias: {\n      \"@\": path.resolve(__dirname, \"src\"), // Optional alias\n    },\n    extensions: [\".js\", \".jsx\", \".ts\", \".tsx\"], // Ensure Vite resolves these extensions\n  },\n  server: {\n    port: 3000,\n    open: true,\n  },\n  build: {\n    outDir: \"dist\",\n    sourcemap: true,\n  },\n});\n</code></pre> <p>Summary</p> <ol> <li>Rename your files to have the appropriate extensions (<code>.jsx</code> for JavaScript with JSX, <code>.tsx</code> for TypeScript with JSX).</li> <li>Install necessary plugins and configure Vite to recognize these extensions.</li> <li>Update your <code>vite.config.js</code> to include plugins and resolve the appropriate extensions.</li> </ol> <p>By following these steps, you should resolve the internal server error related to invalid JS syntax in Vite.</p>"},{"location":"frontend/js/tools/vite/intro/#reference","title":"Reference","text":"<ul> <li>vitejs.dev</li> </ul>"},{"location":"frontend/js/tools/vite/mode/","title":"Mode","text":""},{"location":"frontend/js/tools/vite/mode/#environment-variables-and-mode","title":"Environment Variables and Mode","text":"<p>Vite also supports different <code>.env</code> files for different environments. For example, you might have:</p> <ul> <li><code>.env</code>: Default settings.</li> <li><code>.env.production</code>: Production-specific settings.</li> <li><code>.env.development</code>: Development-specific settings.</li> <li><code>.env.staging</code>: Staging-specific settings.</li> </ul> <p>When Vite is running in a specific mode (like <code>production</code> or <code>development</code>), it will automatically load the corresponding <code>.env</code> file for that mode.</p> <p>For example:</p> <ul> <li>In development mode, it will use <code>.env</code> and <code>.env.development</code>.</li> <li>In production mode, it will use <code>.env</code> and <code>.env.production</code>.</li> </ul>"},{"location":"frontend/js/tools/vite/mode/#example-workflow-with-modes","title":"Example Workflow with Modes","text":"Example FilesCommands <pre><code>.env\n.env.development\n.env.production\n.env.staging\n</code></pre> <ul> <li>Development: <code>vite</code> or <code>vite --mode development</code></li> <li>Production: <code>vite build</code> or <code>vite build --mode production</code></li> <li>Staging: <code>vite --mode staging</code></li> </ul> .env.staging<pre><code>VITE_API_URL=https://staging-api.example.com\n</code></pre> <pre><code>console.log(import.meta.env.VITE_API_URL); // https://staging-api.example.com (when staging mode is used)\n</code></pre>"},{"location":"frontend/js/tools/vite/mode/#question","title":"Question","text":"<p>so do we need to create all the modes .env files or what. and show me examples</p> <p>No, you do not need to create all the mode-specific <code>.env</code> files. Vite will automatically use the <code>.env</code> file as a fallback, and you can define environment-specific variables in files such as <code>.env.production</code>, <code>.env.development</code>, or <code>.env.staging</code> only when necessary.</p> <p>Here's a breakdown of how to use <code>.env</code> files with different modes and examples for each situation:</p> <p>1. Default <code>.env</code> File (Common for all modes)</p> <p>The <code>.env</code> file contains environment variables that apply to all modes (development, production, staging, etc.). You always have this file in the root of your project if you want to set common variables.</p> .env<pre><code>VITE_API_URL=https://api.example.com\nVITE_APP_NAME=MyViteApp\n</code></pre> <p>This file is always loaded, and its variables are available in all modes unless overridden by mode-specific files.</p> <p>2. Mode-Specific <code>.env</code> Files (Optional)</p> <p>You can create mode-specific <code>.env</code> files to override the common settings in <code>.env</code>. These files are only loaded if Vite is running in the corresponding mode.</p> Example .env.development.env.production.env.staging <p>This file will be used when running <code>vite</code> (dev server), which defaults to <code>development</code> mode.</p> .env.development<pre><code>VITE_API_URL=http://localhost:3000\nVITE_APP_NAME=MyViteApp (Development)\n</code></pre> <p>This file will be used when running <code>vite build</code>, which defaults to <code>production</code> mode.</p> .env.production<pre><code>VITE_API_URL=https://api.production.com\nVITE_APP_NAME=MyViteApp (Production)\n</code></pre> <p>This file can be used when running a custom mode, like <code>vite --mode staging</code>.</p> .env.staging<pre><code>VITE_API_URL=https://api.staging.com\nVITE_APP_NAME=MyViteApp (Staging)\n</code></pre>"},{"location":"frontend/js/tools/vite/mode/#reference","title":"Reference","text":"<ul> <li>Env Variables and Modes </li> </ul>"},{"location":"frontend/js/tools/vite/proxy/","title":"Proxy","text":""},{"location":"frontend/js/tools/vite/proxy/#custom-server-configurations-and-proxying-in-vite","title":"Custom Server Configurations and Proxying in Vite","text":"<p>Vite\u2019s Custom Server Configurations and Proxying features allow you to configure your development server and handle requests to external services (such as APIs, databases, or backend servers) more efficiently during the development phase. This can be particularly useful when you're developing a frontend app that interacts with a backend or an external API.</p> <p>Here's an overview of both features, and when and why you might need them.</p> <p>Vite's proxy helps by acting as a middleman (the helper) between your game (frontend) and the server (backend). It makes sure your game can get the data it needs without running into the CORS rules, making the communication smoother and easier!</p>"},{"location":"frontend/js/tools/vite/under-the-hood/","title":"Under the Hood","text":"<p>Vite uses both dotenv and dotenv-expand under the hood. Here's why:</p> <ul> <li><code>dotenv</code>: Loads environment variables from a <code>.env</code> file into <code>process.env</code>.</li> <li><code>dotenv-expand</code>: Expands and resolves variable references (e.g., <code>${VAR}</code>) within <code>.env</code> files.</li> </ul>"},{"location":"frontend/js/tools/vite/under-the-hood/#overview","title":"Overview","text":"Abstract dotenvdotenv-expand <ul> <li> <p>What It Does:</p> <p>The <code>dotenv</code> package loads environment variables from <code>.env</code> files into <code>process.env</code>.</p> </li> <li> <p>Why Vite Uses It:</p> <p>Vite relies on <code>dotenv</code> to support managing environment-specific configurations. This enables you to define variables in <code>.env</code>, <code>.env.&lt;mode&gt;</code>, or <code>.env.&lt;mode&gt;.local</code> and have them automatically available in your app when a specific mode is used.</p> </li> </ul> <p>For example:</p> <pre><code>VITE_API_URL=https://api.example.com\n</code></pre> <p>This gets loaded into <code>process.env</code> and exposed to the app as <code>import.meta.env.VITE_API_URL</code>.</p> <ul> <li> <p>What It Does:</p> <p>The dotenv-expand package extends dotenv by adding support for variable interpolation, allowing one environment variable to reference another.</p> env<pre><code>BASE_URL=https://api.example.com\nVITE_API_URL=${BASE_URL}/v1\n</code></pre> <p>Here, <code>VITE_API_URL</code> will be expanded to <code>https://api.example.com/v1</code>.</p> </li> <li> <p>Why Vite Uses It:</p> <p>Vite includes dotenv-expand to make it easier to manage complex environment setups, especially when multiple variables depend on a shared base value. Without this feature, you'd need to manually construct these dependent variables in your code.</p> </li> </ul>"},{"location":"frontend/js/tools/vite/under-the-hood/#how-vite-uses-them-together","title":"How Vite Uses Them Together","text":"<ol> <li> <p>Loading Environment Variables: Vite uses dotenv to load .env files into memory for the current mode.</p> <p>For example:</p> <pre><code>.env\n.env.development\n.env.production\n</code></pre> </li> <li> <p>Expanding Variables: If there are references to other variables in the <code>.env</code> files, dotenv-expand resolves those references.</p> </li> <li> <p>Exposing Variables to the App: Only variables prefixed with <code>VITE_</code> are exposed to the client-side app via <code>import.meta.env</code>. The rest remain in <code>process.env</code> for server-side usage.</p> </li> </ol>"},{"location":"frontend/js/tools/vite/under-the-hood/#benefits-of-using-both","title":"Benefits of Using Both","text":"<ul> <li>Flexibility: Handles both simple and complex environment setups.</li> <li>Consistency: Ensures that <code>.env</code> files are loaded in a predictable order (<code>.env</code>, <code>.env.&lt;mode&gt;</code>, <code>.env.local</code>).</li> <li>Ease of Use: Developers can leverage variable interpolation for dynamic configurations.</li> </ul>"},{"location":"frontend/js/tools/vite/under-the-hood/#example","title":"Example","text":"env<pre><code>BASE_API=https://api.example.com\nVITE_API_URL=${BASE_API}/v1\nVITE_APP_NAME=MyApp\n</code></pre> <pre><code>console.log(import.meta.env.VITE_API_URL); // Outputs: https://api.example.com/v1\nconsole.log(import.meta.env.VITE_APP_NAME); // Outputs: MyApp\n</code></pre>"},{"location":"frontend/js/tools/vite/under-the-hood/#usage-in-application","title":"Usage in Application","text":"<pre><code>project/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 utils/\n\u2502   \u2514\u2500\u2500 App.tsx\n\u251c\u2500\u2500 .env\n\u251c\u2500\u2500 .env.development\n\u251c\u2500\u2500 .env.production\n\u251c\u2500\u2500 vite.config.ts\n\u251c\u2500\u2500 package.json\n\u2514\u2500\u2500 tsconfig.json\n</code></pre> <p>Environment Files</p> .env (shared across all modes)<pre><code>APP_NAME=My Vite App\nBASE_API_URL=https://api.example.com\n</code></pre> .env.development<pre><code>VITE_API_URL=${BASE_API_URL}/dev\nVITE_LOG_LEVEL=debug\nVITE_FEATURE_TOGGLE=true\n</code></pre> .env.production<pre><code>VITE_API_URL=${BASE_API_URL}/prod\nVITE_LOG_LEVEL=error\nVITE_FEATURE_TOGGLE=false\n</code></pre>"},{"location":"frontend/js/tools/vite/under-the-hood/#best-practices-for-large-applications","title":"Best Practices for Large Applications","text":"<ol> <li> <p>Centralize Configs in a Utility: Instead of accessing <code>import.meta.env</code> everywhere, create a utility to centralize environment variables:</p> src/utils/config.ts<pre><code>export const Config = {\n  apiUrl: import.meta.env.VITE_API_URL,\n  appName: import.meta.env.VITE_APP_NAME,\n  logLevel: import.meta.env.VITE_LOG_LEVEL,\n  featureToggle: import.meta.env.VITE_FEATURE_TOGGLE === \"true\",\n};\n</code></pre> Usage<pre><code>import { Config } from \"./utils/config\";\n\nconsole.log(Config.apiUrl); // Access variables via a single source\n</code></pre> </li> <li> <p>Use Variable Interpolation (<code>dotenv-expand</code>): In the <code>.env</code> files, use <code>${VAR}</code> to reduce duplication and make configurations maintainable.</p> </li> <li> <p>Secure Sensitive Data: Avoid exposing sensitive data (like API keys) by not prefixing such variables with <code>VITE_</code>. They\u2019ll stay in <code>process.env</code> and not be exposed to the browser.</p> </li> <li> <p>Testing Configurations: Add <code>.env.test</code> for testing environments if needed.</p> </li> </ol> <p>Output Example (Development Mode)</p> <p>When you run <code>pnpm dev</code>, the app will log:</p> <pre><code>App Name: My Vite App\nAPI URL: https://api.example.com/dev\nLog Level: debug\n</code></pre> <p>This setup is scalable, maintainable, and fully leverages the power of <code>dotenv</code> and <code>dotenv-expand</code> with Vite in React.</p>"},{"location":"frontend/js/tools/yarn/intro/","title":"Intro","text":"<ul> <li>Developed by Facebook as an alternative to npm.</li> <li>Focuses on speed, reliability, and deterministic dependency resolution.</li> <li>Uses a <code>yarn.lock</code> file to lock dependencies.</li> <li>Command examples: <code>yarn add</code>, <code>yarn upgrade</code>, <code>yarn remove</code>.</li> </ul>"},{"location":"frontend/js/weird-parts/bug-in-js/","title":"Bug in JS","text":""},{"location":"frontend/js/weird-parts/bug-in-js/#weird-bug-in-js","title":"Weird bug in jS","text":"<p>typeof null is an interesting case because it errantly returns \"<code>object</code>\" when you\u2019d expect it to return \"<code>null</code>\".</p> Tip <p>This is a long-standing bug in JS, but one that is likely never going to be fixed. Too much code on the Web relies on the bug, and thus fixing it would cause a lot more bugs!</p> <ul> <li>Up &amp; Going by Kyle Simpson, pg - 31</li> </ul>"},{"location":"frontend/js/weird-parts/bug-in-js/#values-types","title":"Values &amp; Types","text":"<p>JavaScript has typed values, not typed variables.</p> <p>The following built-in types are available:</p> <ul> <li>string</li> <li>number</li> <li>boolean</li> <li>null and undefined</li> <li>object</li> <li>symbol (new to ES6)</li> </ul> <p>JavaScript provides a <code>typeof</code> operator that can examine a value and tell you what type it is:</p> <pre><code>var a;\ntypeof a; // \"undefined\"\n\na = \"hello world\";\ntypeof a; // \"string\"\n\na = 42;\ntypeof a; // \"number\"\n\na = true;\ntypeof a; // \"boolean\"\n\na = null;\ntypeof a; // \"object\"--weird, bug\n\na = undefined;\ntypeof a; // \"undefined\"\n\na = { b: \"c\" };\ntypeof a; // \"object\"\n</code></pre> <p>The return value from the <code>typeof</code> operator is always one of six (seven as of ES6!) string values. That is, <code>typeof</code> \"abc\" returns \"<code>string</code>\", not string.</p> Note <p>Notice how in this snippet the a variable holds every different type of value, and that despite appearances, typeof a is not asking for the \u201ctype of a,\u201d but rather for the \u201ctype of the value currently in a.\u201d Only values have types in JavaScript; variables are just simple containers for those values.</p> <ul> <li>Up &amp; Going by Kyle Simpson, pg - 30</li> </ul>"},{"location":"frontend/js/weird-parts/bug-in-js/#arrays","title":"Arrays","text":"<p>An array is an object that holds values (of any type) not particularly in named properties/keys, but rather in numerically indexed positions. For example:</p> <pre><code>var arr = [\"hello world\", 42, true];\narr[0]; // \"hello world\"\narr[1]; // 42\narr[2]; // true\narr.length; // 3\n\ntypeof arr; // \"object\"\n</code></pre> <p>Because arrays are special objects (as typeof implies), they can also have properties, including the automatically updated length property.</p> Tip <p>The best and most natural approach is to use arrays for numerically positioned values and use objects for named properties.</p> <ul> <li>Up &amp; Going by Kyle Simpson, pg - 30</li> </ul>"},{"location":"frontend/js/weird-parts/bug-in-js/#comparing-values","title":"Comparing Values","text":"<p>There are two main types of value comparison that you will need to make in your JS programs:</p> <ol> <li>equality &amp;</li> <li>inequality.</li> </ol>"},{"location":"frontend/js/weird-parts/bug-in-js/#equality","title":"Equality","text":"<p>There are four equality operators:</p> <ol> <li><code>==</code>,</li> <li><code>===</code>,</li> <li><code>!=</code>,</li> <li><code>!==</code></li> </ol> <p>Consider the implicit coercion that\u2019s allowed by the <code>==</code> loose-equality comparison and not allowed with the <code>===</code> strict-equality:</p> <pre><code>var a = \"42\";\nvar b = 42;\n\na == b; // true\na === b; // false\n</code></pre> <p>The <code>a === b</code> produces <code>false</code>, because the coercion is not allowed,</p>"},{"location":"frontend/js/weird-parts/bug-in-js/#inequality","title":"Inequality","text":"<p>The <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code> operators are used for inequality, referred to in the specification as \u201crelational comparison.\u201d Typically they will be used with ordinally comparable values like numbers. It\u2019s easy to understand that 3 &lt; 4.</p> <ul> <li>Up &amp; Going by Kyle Simpson, pg - 30</li> </ul>"},{"location":"frontend/js/weird-parts/bug-in-js/#coercion","title":"Coercion","text":"<p>Coercion comes in two forms in JavaScript:</p> <ol> <li>explicit &amp;</li> <li>implicit</li> </ol> <p>Explicit coercion is simply that you can see from the code that a conversion from one type to another will occur, whereas implicit coercion is when the type conversion can happen as more of a non-obvious side effect of some other operation.</p> <ul> <li>Up &amp; Going by Kyle Simpson, pg - 30</li> </ul>"},{"location":"frontend/js/weird-parts/bug-in-js/#reference","title":"Reference","text":"<ul> <li>Weird JavaScript things</li> <li>\ud83e\udd2a A list of funny and tricky JavaScript examples: github</li> </ul>"},{"location":"frontend/js/weird-parts/js-missing-parts/","title":"JS Missing Part","text":"<p>In JavaScript, all types of functions, arrays, key/value pairs, and data structures in general are really objects. Even primitive types get the object treatment when you refer to them with the property access notations. They get automatically wrapped with an object so that you can call their prototype methods. For example:</p> <pre><code>\"tonya@example.com\".split(\"@\")[1]; // =&gt; example.com\n</code></pre> Tip <p>Primitive types behave like objects when you use the property access notations, but you can\u2019t assign new properties to them. Primitives get wrapped with an object temporarily, and then that object is immediately thrown away. Any attempt to assign values to properties will seem to succeed, but subsequent attempts to access that new property will fail.</p> <p>Programming Javascript Applications by Eric Elliott - Orielly - pg: 47</p>"},{"location":"frontend/package/barrel/","title":"Barrel","text":""},{"location":"frontend/package/barrel/#what-is-a-barrel","title":"What is a Barrel?","text":"<p>A barrel in programming is a file (usually named <code>index.js</code> or <code>index.ts</code>) that re-exports all exports from multiple files in the same directory. It acts as a single entry point for importing from that directory.</p>"},{"location":"frontend/package/barrel/#where-does-the-term-come-from","title":"Where Does the Term Come From?","text":"<p>The term \"barrel\" originates from the idea that it contains and organizes multiple exports like a container. The concept is not tied to any specific language or framework\u2014it is a general software development practice. However, it is especially useful in modular systems like JavaScript or TypeScript, where files and modules can proliferate quickly.</p>"},{"location":"frontend/package/barrel/#why-use-barrels","title":"Why Use Barrels?","text":"<ol> <li> <p>Simplifies Import Paths: Without a barrel:</p> <pre><code>import Header from \"./components/Header/Header\";\nimport Footer from \"./components/Footer/Footer\";\n</code></pre> <p>With a barrel:</p> <pre><code>import { Header, Footer } from \"./components\";\n</code></pre> </li> <li> <p>Improves Maintainability:</p> <ul> <li>Changes within the directory (e.g., renaming files) don\u2019t impact import paths elsewhere.</li> <li>Centralizes export management.</li> </ul> </li> <li> <p>Enhances Readability:</p> <ul> <li>Makes the codebase easier to navigate by reducing long or nested import paths.</li> </ul> </li> </ol>"},{"location":"frontend/package/barrel/#can-we-do-it-in-react-without-typescript","title":"Can We Do It in React Without TypeScript?","text":"<p>Yes, barrels work perfectly in plain React with JavaScript. You don\u2019t need TypeScript to use barrels.</p> Here\u2019s how you can set it up: 1. Folder Structure:2. Create a Barrel (index.js):3. Import from the Barrel: Instead of this: <pre><code>src/\n    components/\n        Header.js\n        Footer.js\n        index.js\n</code></pre> <pre><code>export { default as Header } from './Header';\nexport { default as Footer } from './Footer';\n</code></pre> <pre><code>import Header from './components/Header';\nimport Footer from './components/Footer';\n</code></pre> <p>Do this:</p> <pre><code>import { Header, Footer } from './components';\n</code></pre>"},{"location":"frontend/package/barrel/#notes","title":"Notes","text":"<ol> <li> <p>Barrels are Framework-Agnostic:</p> <ul> <li>They are not tied to React or TypeScript. You can use them in any JavaScript or TypeScript project.</li> </ul> </li> <li> <p>Potential Downsides:</p> <ul> <li><code>Circular Dependencies</code>: If two files in a barrel depend on each other, it can cause issues.</li> <li><code>Tree Shaking</code>: If the build tool isn't configured properly, unused exports in a barrel may end up in the final bundle. However, modern tools like Webpack, Rollup, and Vite handle this well.</li> </ul> </li> </ol> <p>Barrels are a great organizational tool and can be used in any React project, whether it's written in TypeScript or plain JavaScript!</p>"},{"location":"frontend/package/barrel/#quesition","title":"Quesition","text":"<p>In a large React TypeScript application, the best way to import a file depends on the context and the purpose of the file (e.g., component, utility, asset). However, the following practices ensure clean, efficient, and maintainable imports:</p> <ol> <li> <p>Organize Files with Barrel Exports</p> <ul> <li> <p>What: Create <code>index.ts</code> files in folders to re-export items.</p> </li> <li> <p>Why: Simplifies import paths and reduces clutter.</p> </li> </ul> <p>Example: Folder structure:</p> <pre><code>components/\n    Header/\n        Header.tsx\n        index.ts\n    Footer/\n        Footer.tsx\n        index.ts\n</code></pre> <p><code>index.ts</code> inside each folder:</p> <pre><code>export { default as Header } from \"./Header\";\nexport { default as Footer } from \"./Footer\";\n</code></pre> <p>Import in a parent file:</p> <pre><code>import { Header, Footer } from \"./components\";\n</code></pre> </li> <li> <p>Use Absolute Imports</p> <ul> <li>What: Avoid long relative paths (<code>../../../</code>) by configuring absolute paths in your project.</li> <li>Why: Makes imports cleaner and reduces errors during refactoring.</li> </ul> <p>Setup: In <code>tsconfig.json</code>:</p> <pre><code>{\n  \"compilerOptions\": {\n    \"baseUrl\": \"./\",\n    \"paths\": {\n      \"@components/*\": [\"src/components/*\"],\n      \"@utils/*\": [\"src/utils/*\"]\n    }\n  }\n}\n</code></pre> <p>Example Import:</p> <pre><code>import { Header } from \"@components/Header\";\n</code></pre> </li> <li> <p>Dynamic Imports for Code Splitting</p> <ul> <li>What: Dynamically load components or files to optimize performance by splitting the bundle.</li> <li>Why: Reduces initial load time by lazy-loading components only when needed.</li> </ul> <p>Example:</p> <pre><code>const LazyComponent = React.lazy(\n  () =&gt; import(\"./components/LazyComponent\")\n);\n\nfunction App() {\n  return (\n    &lt;React.Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;\n      &lt;LazyComponent /&gt;\n    &lt;/React.Suspense&gt;\n  );\n}\n</code></pre> </li> <li> <p>Centralized Typings</p> <ul> <li>What: Group reusable types/interfaces in a <code>types/</code> folder.</li> <li>Why: Prevents redundancy and keeps types manageable.</li> </ul> <p>Example:</p> <ul> <li><code>src/types/index.ts</code>:</li> </ul> <pre><code>export interface User {\n  id: number;\n  name: string;\n}\n</code></pre> <ul> <li>Import:</li> </ul> <pre><code>import { User } from \"@types\";\n</code></pre> </li> <li> <p>Asset Imports with Modules</p> <ul> <li>For styles (CSS/SCSS modules):</li> </ul> <pre><code>import styles from \"./Header.module.css\";\n</code></pre> <ul> <li>For media assets (images, videos):</li> </ul> <pre><code>import Logo from \"./assets/logo.svg\";\n</code></pre> </li> <li> <p>Consider Utility Libraries</p> <ul> <li>Use libraries like [vite-tsconfig-paths] or [module-alias] to manage imports effectively if you're not using Webpack or CRA.</li> </ul> </li> </ol> <p>By following these strategies, you'll ensure your imports remain organized, scalable, and optimized for performance in a large application.</p>"},{"location":"frontend/package/intro/","title":"Intro","text":""},{"location":"frontend/package/intro/#utility-libraries","title":"Utility Libraries","text":"Tip <p>JavaScript utility libraries commonly used in React development.</p> <ul> <li> <p>lodash:</p> <p><code>Lodash</code> is a widely used utility library in the JavaScript ecosystem, and it provides a comprehensive set of functions for working with arrays, objects, strings, and more.</p> </li> </ul> Tip <pre><code>// 1. Installation\nnpm install lodash\n\n// 2. Importing\nimport _ from 'lodash'; // Import the entire library\n// or\nimport { map, filter, debounce } from 'lodash'; // Import specific functions\n\n// Example Debounce\nimport _ from 'lodash';\n\nconst debouncedFunction = _.debounce((value) =&gt; {\nconsole.log('Debounced:', value);\n}, 300);\n</code></pre> <ul> <li> <p>Underscore.js:</p> <p><code>Underscore.js</code> is similar to Lodash and provides a set of utility functions for working with arrays, objects, functions, and more. It predates Lodash and served as an inspiration for it.</p> </li> <li> <p>axios:</p> <p><code>axios</code> is a promise-based HTTP client that simplifies making HTTP requests. It is commonly used for handling API requests in React applications.</p> </li> <li> <p>React Query:</p> <p><code>React Query</code> is a library for managing, caching, and synchronizing data in React applications. It provides hooks for fetching and updating data with a focus on simplicity and performance.</p> </li> <li> <p>Ramda:</p> <p><code>Ramda</code> is a functional programming library that focuses on immutability and functional composition. It provides functions for functional programming paradigms and is suitable for projects that adopt a more functional style.</p> </li> <li> <p>Immer:</p> <p><code>Immer</code> is a library that simplifies state management by enabling a more convenient way to work with immutable data structures. It is often used in combination with React's state to make state updates more concise.</p> </li> </ul> Useful React Libraries for Projects <ol> <li>React-Konva</li> <li>React-Gesture-Handler</li> <li>React-Flip-Move</li> <li>React-Virtualized</li> <li>React-Toastify</li> <li>React-Page-Transition</li> <li>React 360</li> </ol> <ul> <li>Javascript Mastery</li> </ul>"},{"location":"frontend/package/intro/#categorized","title":"Categorized","text":"<p>React packages can be categorized into several broad types based on their purpose and functionality within a React application. Here\u2019s a categorization of common React packages:</p> <ol> <li> <p>Core React Libraries</p> <p>These are essential packages for working with React and managing its state, lifecycle, and rendering.</p> <ul> <li><code>react</code>: The core library for building React components.</li> <li><code>react-dom</code>: Provides methods for rendering React components to the DOM.</li> <li><code>react-scripts</code>: Scripts and configuration used by Create React App (CRA) to set up a React project.</li> <li><code>react-router-dom</code>: For routing in React applications, allowing navigation between different views or pages.</li> <li><code>react-redux</code>: A state management library that integrates Redux with React.</li> </ul> </li> <li> <p>State Management</p> <p>These packages help manage state in a React application, ranging from simple local state to global state management.</p> <ul> <li><code>redux</code>: A predictable state container for JavaScript apps (often used in React applications).</li> <li><code>@reduxjs/toolkit</code>: The official, recommended library for writing Redux logic with minimal boilerplate.</li> <li><code>recoil</code>: A state management library for React with a focus on atoms and selectors.</li> <li><code>mobx</code>: A library that makes state management simple and scalable by using observables.</li> <li><code>zustand</code>: A small, fast state management library that can be used as an alternative to Redux.</li> <li><code>valtio</code>: Proxy-based state management with minimal boilerplate.</li> </ul> </li> <li> <p>UI Component Libraries</p> <p>These libraries provide pre-built React components for UI development, saving time on designing and styling.</p> <ul> <li> <p><code>material-ui</code> (now @mui/material): A popular UI framework with a Material Design system.</p> </li> <li> <p><code>react-bootstrap</code>: React components for Bootstrap.</p> </li> <li><code>semantic-ui-react</code>: React components for Semantic UI.</li> <li><code>ant-design</code>: A design system with a set of high-quality React components.</li> <li><code>chakra-ui</code>: A modular and accessible component library for building React apps.</li> <li><code>tailwindcss</code> (with @tailwindcss/forms, @tailwindcss/typography): Utility-first CSS framework often used with React for styling.</li> </ul> </li> <li> <p>Form Handling</p> <p>These packages simplify form management, validation, and state management in React applications.</p> <ul> <li><code>react-hook-form</code>: A performant, flexible, and extensible form library for React.</li> <li><code>formik</code>: A popular library for building forms in React, with validation and state management.</li> <li><code>react-final-form</code>: Another form management library for React, providing a simple API for form state management.</li> <li><code>yup</code>: A JavaScript schema validator, often used in conjunction with form libraries like formik or react-hook-form.</li> </ul> </li> <li> <p>Testing and Debugging</p> <p>Packages for testing React components and debugging during development.</p> <ul> <li><code>jest</code>: A JavaScript testing framework often used with React to test components and logic.</li> <li><code>react-testing-library</code>: A library for testing React components in a way that focuses on user interactions and behavior rather than implementation details.</li> <li><code>enzyme</code>: A testing utility for React that allows for shallow rendering and full DOM rendering (less common today, as React Testing Library is preferred).</li> <li><code>msw</code> (Mock Service Worker): A library for mocking network requests in frontend tests.</li> <li><code>why-did-you-render</code>: A library for identifying unnecessary re-renders in React applications.</li> </ul> </li> <li> <p>Performance Optimization</p> <p>Packages that help optimize the performance of React apps.</p> <ul> <li><code>react-query</code> (now @tanstack/react-query): A data-fetching and caching library for React to handle server-state and make applications faster.</li> <li><code>react-window</code>: A library for efficiently rendering large lists and tabular data by rendering only the visible items.</li> <li><code>react-virtualized</code>: Similar to react-window, this library optimizes the rendering of large data sets by only rendering visible items in a list/grid.</li> <li><code>reselect</code>: A selector library used with Redux to memoize derived state and prevent unnecessary recalculations.</li> </ul> </li> <li> <p>Animation Libraries</p> <p>These packages help create smooth animations and transitions in React applications.</p> <ul> <li><code>framer-motion</code>: A popular library for creating animations and gestures in React.</li> <li><code>react-spring</code>: A physics-based animation library for React that\u2019s used to create interactive, smooth animations.</li> <li><code>react-transition-group</code>: A simple API for animations and transitions in React.</li> </ul> </li> <li> <p>Utility Libraries</p> <p>These are general-purpose utility libraries that provide functionality beyond React-specific code.</p> <ul> <li><code>lodash</code>: A utility library for working with arrays, objects, and functions.</li> <li><code>date-fns</code>: A modern, lightweight library for date manipulation.</li> <li><code>classnames</code>: A utility for conditionally joining CSS class names.</li> <li><code>react-icons</code>: A library for using icons from popular icon sets like Font Awesome, Material Design, etc., as React components.</li> <li><code>axios</code>: A promise-based HTTP client for making API requests.</li> </ul> </li> <li> <p>Internationalization (i18n)</p> <p>These packages help with translating and managing multiple languages in React apps.</p> <ul> <li><code>react-i18next</code>: A powerful internationalization framework for React based on i18next.</li> <li><code>formatjs</code>: A collection of libraries for formatting dates, numbers, and currencies, and handling translations.</li> </ul> </li> <li> <p>Build Tools and Development Utilities</p> <p>These are tools and utilities that assist with development and build processes in React.</p> <ul> <li><code>webpack</code>: A module bundler often used with React for bundling JavaScript, CSS, and other assets.</li> <li><code>babel</code>: A JavaScript compiler that\u2019s typically used with React for transpiling JSX and ES6+ code.</li> <li><code>eslint</code>: A static code analysis tool for identifying issues in JavaScript and JSX code.</li> <li><code>prettier</code>: A code formatter for consistent styling in React and other codebases.</li> </ul> </li> <li> <p>Server-Side Rendering (SSR) &amp; Static Site Generation (SSG)</p> <p>Packages for enabling SSR or SSG in React applications.</p> <ul> <li><code>next.js</code>: A React framework for server-side rendering, static site generation, and more.</li> <li><code>gatsby</code>: A React-based static site generator with powerful features for building static websites.</li> <li><code>react-helmet</code>: A library for managing the document head (meta tags, title, etc.) in a React app.</li> <li><code>react-snap</code>: A tool for pre-rendering React apps for static site generation.</li> </ul> </li> <li> <p>Mobile Development (React Native)</p> <p>These libraries are used specifically for React Native, which is for building mobile apps.</p> <ul> <li><code>react-native</code>: The core library for building mobile apps with React.</li> <li><code>react-navigation</code>: A navigation library for React Native.</li> <li><code>react-native-reanimated</code>: A library for building animations in React Native.</li> <li><code>react-native-gesture-handler</code>: A library for handling gestures in React Native applications.</li> </ul> </li> <li> <p>Miscellaneous/Other</p> <p>Packages that serve various other purposes in React development.</p> <ul> <li><code>react-error-boundary</code>: A higher-order component for handling JavaScript errors in React components.</li> <li><code>react-query-builder</code>: A component for building dynamic query interfaces in React.</li> <li><code>react-dropzone</code>: A React component for handling file uploads with drag-and-drop support.</li> </ul> </li> </ol> <p>These are some of the most commonly used categories and libraries in the React ecosystem. Each library often serves a specific purpose, and choosing the right one depends on the needs of your project.</p>"},{"location":"frontend/package/intro/#libraries","title":"Libraries","text":"<p>Certainly! Here\u2019s a categorized list of popular UI libraries for React, along with their use cases to help you determine when to use each one:</p> <ol> <li> <p>Component Libraries</p> <p>Ant Design</p> <ul> <li>When to Use: Ideal for enterprise-level applications with a design system. It offers a comprehensive suite of components and a well-defined aesthetic.</li> </ul> <p>Material-UI (MUI)</p> <ul> <li>When to Use: Best for applications that require a modern, material design aesthetic. Great for mobile-friendly designs and responsive layouts.</li> </ul> <p>Bootstrap (React-Bootstrap)</p> <ul> <li>When to Use: Suitable for projects that need a quick and familiar design. Good for responsive layouts and when you want to use Bootstrap\u2019s grid system.</li> </ul> <p>Chakra UI</p> <ul> <li>When to Use: Excellent for building accessible applications. It provides a set of composable components with built-in accessibility features.</li> </ul> </li> <li> <p>Design Systems</p> <p>Storybook</p> <ul> <li>When to Use: Not a UI library but a development tool for building UI components in isolation. Great for documenting and testing components.</li> </ul> <p>Blueprint</p> <ul> <li>When to Use: Designed for complex, data-dense interfaces. Suitable for desktop applications and when you need a lot of input fields and complex forms.</li> </ul> <p>Grommet</p> <ul> <li>When to Use: Good for building responsive and accessible applications. It offers a rich set of components with a focus on mobile-first design.</li> </ul> </li> <li> <p>Styling Libraries</p> <p>Styled Components</p> <ul> <li>When to Use: Perfect for styling React components with a CSS-in-JS approach. Useful for creating dynamic styles based on props.</li> </ul> <p>Emotion</p> <ul> <li>When to Use: Similar to Styled Components, it offers a flexible and performant way to style applications. Good for theming and styled components.</li> </ul> <p>Tailwind CSS</p> <ul> <li>When to Use: Ideal for utility-first styling, where you want to build custom designs without leaving your HTML. Great for rapid prototyping.</li> </ul> </li> <li> <p>Mobile UI Libraries</p> <p>React Native Elements</p> <ul> <li>When to Use: Useful for building mobile applications with a consistent design. Offers a wide range of cross-platform components.</li> </ul> <p>NativeBase</p> <ul> <li>When to Use: Ideal for building mobile apps that require a native look and feel. It includes components that work on both Android and iOS.</li> </ul> </li> <li> <p>Animation Libraries</p> <p>Framer Motion</p> <ul> <li>When to Use: Great for adding animations and transitions to React components. Perfect for interactive UIs that require smooth animations.</li> </ul> <p>React Spring</p> <ul> <li>When to Use: Ideal for physics-based animations. Suitable for applications that require more natural motion effects.</li> </ul> </li> <li> <p>Form Libraries</p> <p>Formik</p> <ul> <li>When to Use: Excellent for handling complex forms with validation. Ideal for managing form state and validation seamlessly.</li> </ul> <p>React Hook Form</p> <ul> <li>When to Use: Great for lightweight forms and performance-sensitive applications. It allows easy integration with UI libraries and validation.</li> </ul> </li> </ol> <p>Conclusion</p> <p>Choosing the right UI library depends on your project requirements, team familiarity, and design goals. Understanding the strengths and use cases of each library will help you make informed decisions and create effective, user-friendly applications.</p>"},{"location":"frontend/package/intro/#types-of-website-to-use-libraries","title":"Types of website to use Libraries","text":"<p>Here\u2019s a list of popular React component libraries categorized by the type of website or application you might build. This will help you choose the right library based on your project needs.</p>"},{"location":"frontend/package/intro/#1-enterprise-applications","title":"1. Enterprise Applications","text":"<p>Ant Design</p> <ul> <li>Type of Website: Enterprise-level applications, admin dashboards, and complex data-heavy interfaces.</li> <li>Use Cases: Management systems, CRM tools, and data visualization.</li> </ul> <p>Blueprint</p> <ul> <li>Type of Website: Complex desktop applications and data-dense interfaces.</li> <li>Use Cases: Financial applications, analytics dashboards, and enterprise software.</li> </ul>"},{"location":"frontend/package/intro/#2-e-commerce-websites","title":"2. E-commerce Websites","text":"<p>Material-UI (MUI)</p> <ul> <li>Type of Website: E-commerce platforms and retail websites.</li> <li>Use Cases: Product listings, shopping carts, and customer accounts.</li> </ul> <p>Chakra UI</p> <ul> <li>Type of Website: User-friendly e-commerce sites focused on accessibility.</li> <li>Use Cases: Online stores that prioritize responsive design and accessibility.</li> </ul>"},{"location":"frontend/package/intro/#3-blogs-and-content-management-systems","title":"3. Blogs and Content Management Systems","text":"<p>Grommet</p> <ul> <li>Type of Website: Blogs, personal websites, and content management systems.</li> <li>Use Cases: Simple content-focused layouts with responsive design.</li> </ul> <p>Semantic UI React</p> <ul> <li>Type of Website: Content-rich websites and blogs.</li> <li>Use Cases: Simple, clean designs for articles and posts.</li> </ul>"},{"location":"frontend/package/intro/#4-social-media-platforms","title":"4. Social Media Platforms","text":"<p>React Bootstrap</p> <ul> <li>Type of Website: Social media applications and networking platforms.</li> <li>Use Cases: User profiles, feeds, and messaging systems.</li> </ul> <p>Ant Design</p> <ul> <li>Type of Website: Social media or community-driven platforms with complex user interactions.</li> <li>Use Cases: Forums, discussion boards, and user dashboards.</li> </ul>"},{"location":"frontend/package/intro/#5-mobile-applications","title":"5. Mobile Applications","text":"<p>React Native Elements</p> <ul> <li>Type of Website: Mobile applications.</li> <li>Use Cases: Cross-platform mobile apps with a consistent design.</li> </ul> <p>NativeBase</p> <ul> <li>Type of Website: Mobile applications requiring a native look and feel.</li> <li>Use Cases: Apps for both iOS and Android with native components.</li> </ul>"},{"location":"frontend/package/intro/#6-dashboards-and-data-visualization","title":"6. Dashboards and Data Visualization","text":"<p>Recharts</p> <ul> <li>Type of Website: Data dashboards and visualization tools.</li> <li>Use Cases: Analytics platforms and reporting tools.</li> </ul> <p>Victory</p> <ul> <li>Type of Website: Customizable data visualization applications.</li> <li>Use Cases: Interactive charts and data-driven UIs.</li> </ul>"},{"location":"frontend/package/intro/#7-portfolio-and-personal-websites","title":"7. Portfolio and Personal Websites","text":"<p>Styled Components</p> <ul> <li>Type of Website: Personal portfolios and creative websites.</li> <li>Use Cases: Custom styling for unique designs and layouts.</li> </ul> <p>Framer Motion</p> <ul> <li>Type of Website: Interactive portfolios and personal sites.</li> <li>Use Cases: Smooth animations and transitions for engaging user experiences.</li> </ul>"},{"location":"frontend/package/intro/#conclusion","title":"Conclusion","text":"<p>Choosing the right component library depends on the type of website you are building and your specific requirements. Understanding the strengths of each library will help you create effective, user-friendly applications tailored to your audience's needs.</p>"},{"location":"frontend/package/antd/","title":"Intro","text":""},{"location":"frontend/package/antd/#and","title":"and","text":"<pre><code>$ pnpm add antd\n$ pnpm add @ant-design/icons\n</code></pre>"},{"location":"frontend/package/antd/#in-one-day","title":"In one day","text":"<p>Mastering Ant Design (antd) in React in just one day is ambitious, but you can certainly get a solid grasp of its advanced features by focusing your efforts strategically. Here\u2019s a plan to help you maximize your learning in one day:</p> <p>1. Set Up Your Environment (1 hour)</p> <ul> <li>Install Ant Design: Ensure you have a React environment ready. You can create a new project with Create React App:</li> </ul> <pre><code>npx create-react-app my-app\ncd my-app\nnpm install antd\n</code></pre> <ul> <li>Basic Setup: Import Ant Design styles in your index.js or App.js:</li> </ul> <pre><code>import \"antd/dist/antd.css\";\n</code></pre> <p>2. Explore the Components (3 hours)</p> <ul> <li> <p>Component Library: Go through the Ant Design Component Library. Focus on the following categories:</p> <pre><code>- Layout: Grids, containers, and menus.\n- Navigation: Breadcrumbs, tabs, pagination.\n- Data Entry: Forms, inputs, select, date pickers.\n- Data Display: Tables, lists, cards, avatars.\n- Feedback: Modals, notifications, alerts.\n</code></pre> </li> <li> <p>Practice: Build small examples for each component. For instance, create a form using <code>Form</code>, <code>Input</code>, and <code>Button</code> components.</p> </li> </ul> <p>3. Deep Dive into Advanced Features (3 hours)</p> <ul> <li> <p>Custom Themes: Learn how to customize the default theme using Less variables or CSS overrides.</p> </li> <li> <p>Form Management: Explore <code>Form</code> validation, nested forms, and dynamic fields. Implement a form that uses <code>Formik</code> or <code>react-hook-form</code> with antd.</p> </li> <li> <p>State Management: Understand how to manage global state with tools like Redux or Context API, and integrate it with antd components.</p> </li> <li> <p>Tables: Go deep into the <code>Table</code> component. Implement features like:</p> <pre><code>- Sorting\n- Filtering\n- Pagination\n- Editable cells\n- Row selection\n</code></pre> </li> </ul> <p>4. Routing and Navigation (1 hour)</p> <ul> <li>React Router: Set up <code>react-router</code> for navigation. Create multiple pages and use antd's <code>Menu</code> for navigation links.</li> </ul> <p>5. Responsive Design (1 hour)</p> <ul> <li>Grid System: Utilize the antd grid system for responsive layouts. Create a multi-column layout that adapts to different screen sizes.</li> </ul> <p>6. Testing (1 hour)</p> <ul> <li>Unit Testing: Learn how to test antd components using libraries like Jest and React - Testing Library. Write tests for your components, focusing on form submissions and interactions.</li> </ul> <p>7. Build a Complete Application (2 hours)</p> <ul> <li>Project: Create a small project that incorporates multiple antd components and features. For example, a simple task manager that allows users to add, delete, and edit tasks, using forms and tables.</li> </ul> <p>8. Documentation and Community (1 hour)</p> <ul> <li> <p>Explore Documentation: Familiarize yourself with the Ant Design documentation. Pay special attention to advanced usage sections.</p> </li> <li> <p>Community: Join communities or forums, such as GitHub discussions or Stack Overflow, to ask questions and see how others are using antd.</p> </li> </ul> <p>9. Practice and Reflect (1 hour)</p> <ul> <li>Review Your Code: Go through what you\u2019ve built throughout the day. Refactor where necessary and ensure best practices.</li> <li>Seek Feedback: If possible, share your work with peers or mentors for constructive criticism.</li> </ul> <p>Conclusion</p> <p>By following this structured approach, you'll be able to cover a lot of ground in mastering Ant Design in a day. Remember that mastery comes with practice, so continue to build projects and refine your skills beyond this initial day of learning!</p>"},{"location":"frontend/package/antd/#mastering","title":"Mastering","text":"<p>To gain a deep understanding of Ant Design (antd) and its capabilities, it's crucial to master several advanced components that are commonly used in building complex applications. Here\u2019s a list of the most important components to focus on:</p> <p>1. Table</p> <ul> <li>Features: Sorting, filtering, pagination, row selection, expandable rows, and editable cells.</li> <li>Advanced Use Cases: Implementing custom renderers, integrating with server-side data, and managing complex data structures.</li> </ul> <p>2. Form</p> <ul> <li>Features: Controlled components, validation, dynamic fields, and form layout.</li> <li>Advanced Use Cases: Using external validation libraries (like Yup), managing nested forms, and integrating with state management solutions.</li> </ul> <p>3. Modal</p> <ul> <li>Features: Dialogs for confirmation, forms, and notifications.</li> <li>Advanced Use Cases: Implementing custom modal content and managing multiple modals efficiently.</li> </ul> <p>4. Menu</p> <ul> <li>Features: Navigation menus, submenus, and dropdowns.</li> <li>Advanced Use Cases: Dynamic menu generation based on user roles and permissions, and handling nested routing.</li> </ul> <p>5. Card</p> <ul> <li>Features: Contain multiple elements, customizable layouts, and actions.</li> <li>Advanced Use Cases: Creating interactive dashboards with cards, using grid layouts, and integrating with charts or other components.</li> </ul> <p>6. Notification and Message</p> <ul> <li>Features: System notifications and user feedback messages.</li> <li>Advanced Use Cases: Customizing notification placement, duration, and using them with asynchronous operations.</li> </ul> <p>7. Select and AutoComplete</p> <ul> <li>Features: Dropdown selections, multi-select, and search functionality.</li> <li>Advanced Use Cases: Implementing asynchronous options loading, custom option rendering, and integrating with API endpoints.</li> </ul> <p>8. DatePicker</p> <ul> <li>Features: Date selection, range selection, and date-time management.</li> <li>Advanced Use Cases: Customizing date formats, integrating with validation, and handling time zones.</li> </ul> <p>9. Spin and Loading</p> <ul> <li>Features: Loading indicators to improve UX.</li> <li>Advanced Use Cases: Managing loading states during data fetching and integrating with asynchronous actions.</li> </ul> <p>10. Grid</p> <ul> <li>Features: Responsive layout using Row and Col components.</li> <li>Advanced Use Cases: Building adaptive designs for different screen sizes and implementing complex layouts.</li> </ul> <p>11. Tree</p> <ul> <li>Features: Hierarchical data representation with expand/collapse functionality.</li> <li>Advanced Use Cases: Dynamic tree data loading, checkable trees, and drag-and-drop functionality.</li> </ul> <p>12. Tabs</p> <ul> <li>Features: Tabbed navigation for organizing content.</li> <li>Advanced Use Cases: Dynamic tab generation and preserving state across tabs.</li> </ul> <p>13. Steps</p> <ul> <li>Features: Step-by-step navigation for multi-step processes.</li> <li>Advanced Use Cases: Managing complex workflows and integrating forms within steps.</li> </ul> <p>Conclusion</p> <p>Focusing on these components will provide you with a comprehensive understanding of Ant Design's capabilities. Mastering them involves not just understanding how they work individually but also how they interact with each other to create cohesive user experiences. Additionally, practice by building projects that utilize these components in various ways to reinforce your knowledge!</p>"},{"location":"frontend/package/antd/antd-configprovider/","title":"antd ConfigProvider","text":""},{"location":"frontend/package/antd/antd-configprovider/#configprovider-overview","title":"ConfigProvider Overview","text":"<p>The <code>ConfigProvider</code> component was introduced in Ant Design v4. It was added to provide a centralized way to configure and customize various aspects of the library globally, such as theming, localization, or component-specific configurations.</p> Key Features of <code>ConfigProvider</code>:Example of using ConfigProvider: <ul> <li>Global Configuration: Allows you to globally configure properties like themes, locale, direction, etc., for all Ant Design components.</li> <li>Customizing Themes: You can pass configuration like primary color, component styles, or font sizes.</li> <li>Localization: You can easily set locale (language settings) across all components via ConfigProvider.</li> <li>Global Defaults: Set default properties for certain components globally (e.g., button size, input style).</li> </ul> <pre><code>import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { ConfigProvider, Button } from 'antd';\nimport enUS from 'antd/es/locale/en_US';  // Example locale (English)\nimport './App.css';\n\nconst App = () =&gt; {\n    return (\n        &lt;ConfigProvider locale={enUS} theme={{ primaryColor: '#25b864' }}&gt;\n            &lt;div style={{ padding: 20 }}&gt;\n                &lt;Button type=\"primary\"&gt;Primary Button&lt;/Button&gt;\n            &lt;/div&gt;\n        &lt;/ConfigProvider&gt;\n    );\n};\n\nReactDOM.render(&lt;App /&gt;, document.getElementById('root'));\n</code></pre> <p>Notable Changes with ConfigProvider:</p> <ul> <li>Before <code>v4</code>, Ant Design relied more on inline configurations for components or directly using CSS to apply styles. <code>ConfigProvider</code> made it easier to manage global settings.</li> <li><code>ConfigProvider</code> is especially useful when you have a large application and want to control settings globally instead of configuring each component individually.</li> </ul> <p>Version Timeline:</p> <ul> <li>v4.0.0 (Released in 2020) \u2014 Introduced <code>ConfigProvider</code> as part of a major update.</li> </ul>"},{"location":"frontend/package/antd/antd-configprovider/#detailed-example-of-files","title":"Detailed Example of Files","text":"src/config/theme.tssrc/index.tsxsrc/App.tsx <p>This file contains the reusable theme configuration.</p> <pre><code>// src/config/theme.ts\nimport { ThemeConfig } from 'antd/es/config-provider/context';\n\n// Define the default theme configuration\nexport const themeConfig: ThemeConfig = {\n    token: {\n        colorPrimary: '#1DA57A',  // Primary green color\n        fontFamily: 'Arial, sans-serif',\n    },\n};\n\n// Example of another theme (optional, for dynamic switching or theming)\nexport const darkTheme: ThemeConfig = {\n    token: {\n        colorPrimary: '#000000',  // Dark theme (black)\n        fontFamily: 'Arial, sans-serif',\n    },\n};\n\nexport const lightTheme: ThemeConfig = {\n    token: {\n        colorPrimary: '#1DA57A',  // Light theme (green)\n        fontFamily: 'Arial, sans-serif',\n    },\n};\n</code></pre> <p>Here, you set up the root rendering of the app and apply the ConfigProvider with the theme configuration.</p> <pre><code>// src/index.tsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { ConfigProvider } from 'antd';\nimport App from './App';\nimport 'antd/dist/reset.css';  // Ant Design reset CSS\nimport { themeConfig } from './config/theme';  // Import the reusable theme configuration\n\nReactDOM.render(\n    &lt;ConfigProvider theme={themeConfig}&gt;\n        &lt;App /&gt;\n    &lt;/ConfigProvider&gt;,\n    document.getElementById('root')\n);\n</code></pre> <p>This is the main application component where you can manage the layout and add logic to toggle themes, etc.</p> <pre><code>// src/App.tsx\nimport React, { useState } from 'react';\nimport { Button, ConfigProvider } from 'antd';\nimport { themeConfig, darkTheme, lightTheme } from './config/theme';  // Import theme config\n\nconst App: React.FC = () =&gt; {\n    const [theme, setTheme] = useState(themeConfig);\n\n    const toggleTheme = () =&gt; {\n        setTheme(theme === lightTheme ? darkTheme : lightTheme);\n    };\n\n    return (\n        &lt;ConfigProvider theme={theme}&gt;\n            &lt;div style={{ padding: '50px' }}&gt;\n                &lt;Button type=\"primary\" onClick={toggleTheme}&gt;\n                Toggle Theme\n                &lt;/Button&gt;\n            &lt;/div&gt;\n        &lt;/ConfigProvider&gt;\n    );\n};\n\nexport default App;\n</code></pre> <p><code>src/components/Button.tsx</code></p> <p>Example of a simple button component that uses Ant Design\u2019s <code>Button</code> component. You can create reusable components like this.</p> <pre><code>// src/components/Button.tsx\nimport React from \"react\";\nimport { Button as AntButton, ButtonProps } from \"antd\";\n\n// Custom Button component that wraps Ant Design's Button\nconst Button: React.FC&lt;ButtonProps&gt; = (props) =&gt; {\n  return &lt;AntButton {...props} /&gt;;\n};\n\nexport default Button;\n</code></pre> <p><code>src/pages/Home.tsx</code></p> <p>Example of a page component (<code>Home.tsx</code>), which might contain layout and specific content for the home page.</p> <pre><code>// src/pages/Home.tsx\nimport React from \"react\";\nimport { Button } from \"antd\";\n\nconst Home: React.FC = () =&gt; {\n  return (\n    &lt;div style={{ padding: \"50px\" }}&gt;\n      &lt;h1&gt;Welcome to the Home Page&lt;/h1&gt;\n      &lt;Button type=\"primary\"&gt;Primary Button&lt;/Button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default Home;\n</code></pre> <p><code>src/styles/global.css (optional)</code></p> <p>If you need global styles (not using CSS-in-JS or styled-components), you can add a <code>global.css</code> file for general layout, spacing, or custom styles.</p> <pre><code>/* src/styles/global.css */\nbody {\n  font-family: Arial, sans-serif;\n  margin: 0;\n  padding: 0;\n}\n\nh1 {\n  color: #333;\n}\n</code></pre> <p>Make sure to import the global styles in your index.tsx or App.tsx if needed:</p> <pre><code>// src/index.tsx\nimport \"./styles/global.css\"; // Import global styles (if you use plain CSS)\n</code></pre>"},{"location":"frontend/package/antd/antd-configprovider/#summary-of-folder-structure","title":"Summary of Folder Structure","text":"<pre><code>src/\n\u251c\u2500\u2500 assets/                 # Optional assets (images, icons, etc.)\n\u251c\u2500\u2500 components/             # Reusable components like Button, Card, etc.\n\u2502   \u251c\u2500\u2500 Button.tsx          # Custom button component\n\u2502   \u2514\u2500\u2500 CustomCard.tsx      # Another reusable component\n\u251c\u2500\u2500 config/                 # Configuration for themes, API, etc.\n\u2502   \u2514\u2500\u2500 theme.ts            # Theme configuration file for Ant Design\n\u251c\u2500\u2500 pages/                  # Components representing different pages\n\u2502   \u251c\u2500\u2500 Home.tsx            # Home page component\n\u2502   \u2514\u2500\u2500 Dashboard.tsx       # Dashboard page component\n\u251c\u2500\u2500 styles/                 # Global or custom styles\n\u2502   \u2514\u2500\u2500 global.css          # Global CSS styles (if used)\n\u251c\u2500\u2500 App.tsx                 # Main app component\n\u251c\u2500\u2500 index.tsx               # React entry point\n\u2514\u2500\u2500 theme.ts                # Reusable theme config for Ant Design (could be merged into `config/`)\ntsconfig.json               # TypeScript configuration\npackage.json                # Project dependencies and scripts\n</code></pre> <p>This structure is flexible, scalable, and ensures that your theme configuration and components remain reusable and maintainable.</p>"},{"location":"frontend/package/antd/antd-configprovider/#what-to-define-in-configprovider","title":"What to Define in ConfigProvider","text":"<p>ConfigProvider in Ant Design is a powerful tool for centralizing and managing global configurations for your application. However, there are some best practices for what you should define within ConfigProvider and what you should avoid. Here's a breakdown of what to define only in ConfigProvider and what you might want to handle elsewhere:</p> Summary: What to Define in <code>ConfigProvider</code> <ul> <li>Global Theme Settings (e.g., colors, fonts, border radius)</li> <li>Locale (for internationalization)</li> <li>Global Component Defaults (e.g., button size, notification duration)</li> <li>Layout Direction (LTR/RTL)</li> </ul> What to Avoid Defining in <code>ConfigProvider</code> <ul> <li>Specific Component Styles (use CSS or styled-components for this)</li> <li>Component-Specific Props (use props directly on components)</li> <li>Custom CSS Styles (use external stylesheets or CSS-in-JS)</li> <li>State or Business Logic (handle this in your components or state management)</li> </ul> <p>By following these guidelines, you can make the most out of ConfigProvider while keeping your code clean and maintainable. Let me know if you need more help!</p> <pre><code>const lightTheme = {\n  token: {\n    colorPrimary: \"#1890ff\", // Primary button color, etc.\n    colorText: \"#000000\", // Primary text color (black in light theme)\n    colorBackground: \"#ffffff\", // Background color (white in light theme)\n    colorTextSecondary: \"#8c8c8c\", // Secondary text color (gray)\n    fontFamily: \"Arial, sans-serif\",\n    borderRadiusBase: \"4px\", // Default border radius for components\n  },\n};\n\nconst darkTheme = {\n  token: {\n    colorPrimary: \"#1890ff\", // Same primary color for buttons\n    colorText: \"#ffffff\", // Primary text color (white in dark theme)\n    colorBackground: \"#333333\", // Dark background color\n    colorTextSecondary: \"#888888\", // Secondary text color (light gray)\n    fontFamily: \"Arial, sans-serif\",\n    borderRadiusBase: \"4px\", // Border radius for components\n  },\n};\n</code></pre>"},{"location":"frontend/package/antd/antd-configprovider/#question","title":"Question","text":""},{"location":"frontend/package/antd/antd-configprovider/#question-1","title":"Question 1","text":"<p>why are we using the two times the ConfigProvider in index.tsx and App.tsx</p> <p>You're right to question that! Using ConfigProvider in both index.tsx and App.tsx would be redundant in most cases. Generally, ConfigProvider should be used once at the root level (in index.tsx), and there's no need to wrap it again in App.tsx unless you specifically want to override the theme at a more localized level (like in a specific page or component).</p>"},{"location":"frontend/package/antd/antd-configprovider/#corrected-approach","title":"Corrected Approach","text":"<p>You should use ConfigProvider only once at the top-level (in index.tsx). Here\u2019s the corrected approach:</p> <p>src/index.tsx</p> <p>The <code>ConfigProvider</code> should be applied here, wrapping the entire application, so the theme is accessible globally across all components.</p> <pre><code>// src/index.tsx\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { ConfigProvider } from \"antd\";\nimport App from \"./App\";\nimport \"antd/dist/reset.css\"; // Ant Design reset CSS\nimport { themeConfig } from \"./config/theme\"; // Import the reusable theme configuration\n\nReactDOM.render(\n  &lt;ConfigProvider theme={themeConfig}&gt;\n    &lt;App /&gt;\n  &lt;/ConfigProvider&gt;,\n  document.getElementById(\"root\")\n);\n</code></pre> <p>src/App.tsx</p> <p>Since the <code>ConfigProvider</code> is already wrapped in <code>index.tsx</code>, you don\u2019t need to use it again here unless you're applying a different theme for a specific part of the app. So, you can simply use <code>App</code> as a regular component:</p> <pre><code>// src/App.tsx\nimport React, { useState } from \"react\";\nimport { Button } from \"antd\";\nimport { darkTheme, lightTheme } from \"./config/theme\"; // Import theme config\n\nconst App: React.FC = () =&gt; {\n  const [theme, setTheme] = useState(lightTheme); // Start with light theme\n\n  const toggleTheme = () =&gt; {\n    setTheme(theme === lightTheme ? darkTheme : lightTheme); // Toggle theme\n  };\n\n  return (\n    &lt;div style={{ padding: \"50px\" }}&gt;\n      &lt;Button type=\"primary\" onClick={toggleTheme}&gt;\n        Toggle Theme\n      &lt;/Button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n</code></pre> <p>Explanation:</p> <ol> <li><code>ConfigProvider</code> in <code>index.tsx</code>: This is where you define and provide the theme globally for the entire application.</li> <li>No <code>ConfigProvider</code> in <code>App.tsx</code>: Since <code>ConfigProvider</code> is already at the root level in <code>index.tsx</code>, there\u2019s no need to wrap <code>App</code> with it again unless you're overriding the theme for specific parts of the app.</li> </ol> <p>If you did want to override the theme for a specific part of the app (for example, in a particular page or component), you could use a second <code>ConfigProvider</code> inside <code>App.tsx</code>, but that would be for localized theming, not for global theming.</p> <p>Conclusion:</p> <p>You only need to use <code>ConfigProvider</code> once in the root component (<code>index.tsx</code>), and then the theme will be applied globally to all components. If you need to override the theme for specific components or pages, you can wrap those parts with another <code>ConfigProvider</code> inside <code>App.tsx</code> or other child components.</p>"},{"location":"frontend/package/antd/antd-configprovider/#question-2","title":"Question 2","text":"<p>if we toogle theme does it changes the global theme.</p> <p>Great question! The short answer is no, toggling the theme locally within a component like <code>App.tsx</code> (or other parts of the app) does not automatically update the global theme across the entire app unless you manage the theme state at a global level.</p> <p>How ConfigProvider Works</p> <p>The <code>ConfigProvider</code> in Ant Design provides a global theme configuration to all child components. When you use <code>ConfigProvider</code> with a specific theme, that <code>theme</code> will apply to all of its children. However, if you try to toggle the theme locally (within a single component), it won't update the global theme for the entire app unless you make the theme state management global.</p> <p>How to Achieve Global Theme Toggling</p> <p>To toggle the theme globally (across the entire app), you need to lift the theme state up to a higher level, likely at the root of your application. This way, when the theme is toggled, it will affect the entire app, and the <code>ConfigProvider</code> will re-render with the new theme.</p> <p>Here\u2019s how you can implement global theme toggling properly:</p> <ol> <li> <p>Lift the Theme State to the Root Level</p> <p>You\u2019ll want to manage the theme state at the top level (usually in <code>index.tsx</code> or a <code>ThemeProvider</code> component) so that toggling the theme updates the global configuration. You can then pass this state down to <code>ConfigProvider</code>.</p> </li> <li> <p>Update the Theme Dynamically</p> <p>When the theme changes, you need to update the <code>ConfigProvider</code> dynamically. This will allow you to apply the theme globally.</p> </li> </ol> <p>Example Implementation</p> 1. src/index.tsx (Root Component)2. src/App.tsx3. src/config/theme.ts <p>In this example, the theme state is managed in the root component (<code>index.tsx</code>), and the <code>ConfigProvider</code> is updated dynamically when the theme changes.</p> <pre><code>// src/index.tsx\nimport React, { useState } from 'react';\nimport ReactDOM from 'react-dom';\nimport { ConfigProvider } from 'antd';\nimport App from './App';\nimport 'antd/dist/reset.css';  // Ant Design reset CSS\nimport { themeConfig, darkTheme, lightTheme } from './config/theme';  // Import theme configs\n\n// Manage the theme globally\nconst Root: React.FC = () =&gt; {\n    const [theme, setTheme] = useState(lightTheme);  // Initial theme\n\n    const toggleTheme = () =&gt; {\n        setTheme(theme === lightTheme ? darkTheme : lightTheme);  // Toggle between light and dark\n    };\n\n    return (\n        &lt;ConfigProvider theme={theme}&gt;\n            &lt;App toggleTheme={toggleTheme} /&gt;\n        &lt;/ConfigProvider&gt;\n    );\n};\n\nReactDOM.render(&lt;Root /&gt;, document.getElementById('root'));\n</code></pre> <p>In <code>App.tsx</code>, we now receive the <code>toggleTheme</code> function as a prop and use it to toggle the theme globally.</p> <pre><code>// src/App.tsx\nimport React from 'react';\nimport { Button } from 'antd';\n\ninterface AppProps {\ntoggleTheme: () =&gt; void;\n}\n\nconst App: React.FC&lt;AppProps&gt; = ({ toggleTheme }) =&gt; {\n    return (\n        &lt;div style={{ padding: '50px' }}&gt;\n            &lt;h1&gt;Global Theme Toggle&lt;/h1&gt;\n            &lt;Button type=\"primary\" onClick={toggleTheme}&gt;\n                Toggle Theme\n            &lt;/Button&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default App;\n</code></pre> <p>Define both the light and dark theme configurations as before.</p> <pre><code>// src/config/theme.ts\nimport { ThemeConfig } from 'antd/es/config-provider/context';\n\n// Default light theme\nexport const lightTheme: ThemeConfig = {\n    token: {\n        colorPrimary: '#1DA57A',  // Green\n        fontFamily: 'Arial, sans-serif',\n    },\n};\n\n// Dark theme configuration\nexport const darkTheme: ThemeConfig = {\n    token: {\n        colorPrimary: '#000000',  // Dark\n        fontFamily: 'Arial, sans-serif',\n    },\n};\n</code></pre> <p>Key Points:</p> <ul> <li><code>ConfigProvider</code> is now wrapped around the whole app (<code>Root</code> component in <code>index.tsx</code>), which allows the theme to be shared globally.</li> <li><code>toggleTheme</code> is lifted to the root (Root component) so that when the theme is toggled, the entire app re-renders with the new theme.</li> <li>The <code>theme</code> is passed down as a prop to <code>ConfigProvider</code>, ensuring that the theme is dynamically updated across the entire app when it changes.</li> </ul> <p>How This Works:</p> <ul> <li>Initially, <code>lightTheme</code> is applied by default (via useState).</li> <li>When the \"Toggle Theme\" button is clicked, it triggers <code>toggleTheme</code>, which switches the theme between <code>lightTheme</code> and <code>darkTheme</code>.</li> <li>Because <code>ConfigProvider</code> is wrapping the entire app, the change in theme will be reflected globally.</li> </ul> <p>Conclusion:</p> <p>By managing the theme state at the root level (<code>index.tsx</code> or <code>Root</code> component), toggling the theme will update the global theme via <code>ConfigProvider</code>, ensuring that the entire app is consistently themed.</p>"},{"location":"frontend/package/antd/antd-configprovider/#reference","title":"Reference","text":"<ul> <li>ConfigProvider</li> </ul>"},{"location":"frontend/package/antd/antd-render-func/","title":"render function","text":""},{"location":"frontend/package/antd/antd-render-func/#overview","title":"Overview","text":"<p>In Ant Design (antd), the <code>render</code> function in table columns is crucial for customizing how data is displayed in each cell. Here\u2019s a breakdown of what the <code>render</code> function does and the implications of not using it.</p> What the <code>render</code> Function DoesWhat Happens If You Don\u2019t Use It <ol> <li> <p>Custom Display: The <code>render</code> function allows you to define how the cell content is rendered. You can return simple text, formatted HTML, or even React components.</p> </li> <li> <p>Access to Data: The function provides access to predefined parameters, such as:</p> <ul> <li><code>text</code>: The value of the current cell.</li> <li><code>record</code>: The entire row data.</li> <li><code>index</code>: The row index.</li> <li><code>column</code>: The column configuration.</li> </ul> </li> <li> <p>Conditional Formatting: You can implement conditional logic to change styles or display different content based on the data.</p> </li> <li> <p>Interactive Elements: It allows you to include interactive components (like buttons or links) in the cells.</p> </li> </ol> <ol> <li> <p>Default Rendering: If you do not define a <code>render</code> function for a column, the table will use the default rendering behavior, which simply displays the value specified by the <code>dataIndex</code> of that column.</p> </li> <li> <p>Limited Customization: You won\u2019t be able to apply any custom formatting or conditional rendering. For example, you can't change the text color based on a condition or render a button.</p> </li> <li> <p>Static Content: The content will be static and only reflect the data from the data source without any interactivity or enhancements.</p> </li> </ol> <p>Example Comparison</p> <ul> <li>Using <code>render</code></li> </ul> <pre><code>{\n    title: 'Age',\n    dataIndex: 'age',\n    render: (text) =&gt; (\n        &lt;span style={{ color: text &gt; 40 ? 'red' : 'black' }}&gt;{text}&lt;/span&gt;\n    ),\n}\n</code></pre> <ul> <li> <p>Outcome: The age will be displayed in red if greater than 40.</p> </li> <li> <p>Not Using <code>render</code></p> </li> </ul> <pre><code>{\n    title: 'Age',\n    dataIndex: 'age',\n}\n</code></pre> <ul> <li>Outcome: The age will simply be displayed as-is without any custom styling or logic.</li> </ul> <p>Summary</p> <p>Using the <code>render</code> function in antd tables is essential for customizing how data is presented and interacted with. Not using it limits the table's flexibility and functionality, resulting in a more static and less engaging user experience. If you have further questions or need more examples, feel free to ask!</p>"},{"location":"frontend/package/antd/antd-render-func/#what-is-the-use-_-of-render-function","title":"What is the use <code>_</code> of render function","text":"<p>In Ant Design (antd) and in JavaScript in general, the underscore (<code>_</code>) can be used in several contexts, especially in function parameters. Here\u2019s a breakdown of its typical usage and when to use it:</p> <p>Common Uses of <code>_</code> in Ant Design</p> <ol> <li> <p>Ignoring Parameters:</p> <ul> <li> <p>If a function receives more parameters than it actually uses, you can use <code>_</code> to indicate that you are intentionally ignoring those parameters. This is common in the render function of table columns, where you might not need all available parameters.</p> </li> <li> <p>Example:</p> </li> </ul> <pre><code>render: (text, record, _) =&gt; {\n  return &lt;span&gt;{text}&lt;/span&gt;; // Ignoring the third parameter\n};\n</code></pre> </li> <li> <p>Placeholder for Unused Values:</p> <ul> <li> <p>Similar to ignoring parameters, <code>_</code> can act as a placeholder to clarify that certain parameters are not needed, making the code more readable.</p> </li> <li> <p>Example:</p> </li> </ul> <pre><code>render: (text, _, index) =&gt; {\n  return (\n    &lt;span&gt;\n      {index + 1}: {text}\n    &lt;/span&gt;\n  ); // Using only `text` and `index`\n};\n</code></pre> </li> </ol> When to Use <code>_</code>When Not to Use <code>_</code> <ul> <li>Readability: Use <code>_</code> when it improves the readability of your code by making it clear which parameters are not utilized.</li> <li>Indicating Intent: If you want to show that a parameter is intentionally ignored (e.g., to prevent warnings about unused parameters), use <code>_</code>.</li> </ul> <ul> <li>Meaningful Parameters: If a parameter is meaningful and could be useful later, don\u2019t ignore it. Instead, use descriptive names or utilize the parameter in your logic.</li> <li>Confusion: Avoid using <code>_</code> if it may cause confusion. For instance, if the context of the parameters isn\u2019t clear, it\u2019s better to use more descriptive variable names.</li> </ul> <p>Example in an Ant Design Table</p> <p>Here's how you might see <code>_</code> used in a typical antd table render function:</p> <pre><code>const columns = [\n  {\n    title: \"Name\",\n    dataIndex: \"name\",\n    render: (text, record, _) =&gt; (\n      &lt;span&gt;\n        {text} (ID: {record.key})\n      &lt;/span&gt;\n    ),\n  },\n  {\n    title: \"Age\",\n    dataIndex: \"age\",\n    render: (_, record) =&gt; &lt;span&gt;{record.age} years old&lt;/span&gt;,\n  },\n];\n</code></pre> <p>Summary</p> <p>Using <code>_</code> is a helpful convention to improve code clarity and manage unused parameters in your functions. Use it when you want to indicate that certain parameters are intentionally ignored or unnecessary, but avoid it if it could lead to confusion or if you might need the parameter later. If you have any more questions or need further clarification, feel free to ask!</p>"},{"location":"frontend/package/antd/antd-render-func/#parameter-order-in-render-function","title":"Parameter Order in <code>render</code> Function","text":"<p>In Ant Design (antd), the render function for table columns typically accepts parameters in a specific order. Understanding this order is crucial for utilizing the data effectively. Here's the standard parameter order and what each parameter represents:</p> <p>Standard Parameter Order in render Function</p> <ul> <li><code>text</code>: The content of the cell, usually the value from the data source corresponding to the <code>dataIndex</code>.</li> <li><code>record</code>: The entire row data for the current row.</li> <li><code>index</code> (optional): The index of the current row in the data source.</li> <li><code>column</code> (optional): The column configuration object.</li> </ul> <p>Example</p> <pre><code>{\n  title: 'Name',\n  dataIndex: 'name',\n  render: (text, record, index, column) =&gt; {\n    return &lt;span&gt;{text} (Row: {index + 1})&lt;/span&gt;;\n  },\n}\n</code></pre> Is It Necessary to Pass Arguments in Order? <ul> <li> <p>Yes, it is necessary to follow the order:</p> <p>The parameters must be in the expected order if you plan to use them. If you do not use them as intended, you might not access the correct values.</p> </li> </ul> What Happens If You Don\u2019t Pass Parameters in Order? <ol> <li> <p>Incorrect Values:</p> <p>If you mix up the parameters, you might end up accessing the wrong data. For example, treating <code>record</code> as <code>text</code> could lead to unexpected behavior.</p> </li> <li> <p>Undefined Behavior:</p> <p>If you try to access properties or methods that don't exist on the wrongly assigned parameter, it could result in runtime errors.</p> </li> </ol> Example of Incorrect OrderUsing Only Required Parameters <p>If you try to change the order or omit certain parameters:</p> <pre><code>{\n    title: 'Name',\n    dataIndex: 'name',\n    render: (record, text) =&gt; { // Incorrect order\n        return &lt;span&gt;{text}&lt;/span&gt;; // This will not work as intended\n    },\n}\n</code></pre> <ul> <li>In this case, <code>text</code> would receive the <code>record</code> value, leading to potential issues and incorrect output.</li> </ul> <p>If you only need some of the parameters, you can still choose to omit the ones you don\u2019t need, but you should maintain the order:</p> <pre><code>{\n    title: 'Name',\n    dataIndex: 'name',\n    render: (text) =&gt; {\n        return &lt;span&gt;{text}&lt;/span&gt;; // Only using text, omitting record and index\n    },\n}\n</code></pre> <p>Summary</p> <ul> <li>The order of parameters in the <code>render</code> function is important and should be respected to avoid confusion and ensure that you access the correct data.</li> <li>You can omit parameters you don\u2019t need, but the ones you do use must be in the correct order.</li> <li>Misordering parameters can lead to errors or unintended behavior, so always keep the defined order in mind when implementing the <code>render</code> function.</li> </ul>"},{"location":"frontend/package/antd/antd-render-func/#what-happens-if-we-only-use-record","title":"What happens if we only use <code>record</code>","text":"<p>If you use the <code>render</code> function in an Ant Design (antd) table like this:</p> <pre><code>render: (record) =&gt; {\n  return &lt;span&gt;{record.name}&lt;/span&gt;;\n},\n</code></pre> What Happens <ol> <li> <p>Parameter Misuse:</p> <ul> <li>The <code>render</code> function is designed to take specific parameters, typically the first being <code>text</code>, which represents the value of the cell being rendered. The second is usually <code>record</code>, which represents the entire row of data.</li> </ul> </li> <li> <p>Output:</p> <ul> <li>In this case, you are trying to directly use <code>record</code> as the only parameter. While this will technically work without throwing an error, you are not following the conventional parameter order. This means that the first parameter (the cell's value) is ignored, which could lead to confusion.</li> </ul> </li> <li> <p>Accessing Data:</p> <ul> <li>If <code>record</code> contains a <code>name</code> property, the cell will correctly display the name from that row. For example, if <code>record</code> is:</li> </ul> <pre><code>{ key: '1', name: 'John', age: 32, address: 'New York' }\n</code></pre> <p>Then the output will be:</p> <pre><code>John\n</code></pre> </li> </ol> Recommended Usage <p>While your implementation might work, it's better practice to adhere to the expected parameter order to avoid confusion and ensure clarity in your code. The standard usage would be:</p> <pre><code>render: (text, record) =&gt; {\n    return &lt;span&gt;{record.name}&lt;/span&gt;;\n},\n</code></pre> <p>Why It\u2019s Important to Follow the Order</p> <ol> <li> <p>Readability: Following the conventional parameter order (i.e., <code>text</code>, <code>record</code>, <code>index</code>, <code>column</code>) makes the code easier to read and understand for others (or yourself in the future).</p> </li> <li> <p>Consistency: It maintains consistency across your codebase, which is especially helpful in larger projects where multiple developers are involved.</p> </li> <li> <p>Potential Errors: Although using just <code>record</code> won\u2019t cause immediate errors, it could lead to issues if you later decide to rely on the first parameter (like <code>text</code>) for other rendering logic.</p> </li> </ol> <p>Summary</p> <p>Using just <code>record</code> in the <code>render</code> function will work as long as you access the properties correctly, but it's best practice to follow the expected parameter order. This approach enhances readability, consistency, and reduces the likelihood of confusion or errors in the future. If you have more questions or need further clarification, feel free to ask!</p>"},{"location":"frontend/package/antd/antd-render-func/#ignored-parameter","title":"Ignored Parameter","text":"<p>If you don't need the <code>text</code> parameter in the <code>render</code> function, you can safely omit it by using an underscore (<code>_</code>) or just by using a single parameter (the one you need). Here\u2019s how you can do it:</p> <p>Using an Underscore to Indicate Ignored Parameter</p> <p>You can indicate that you're intentionally ignoring the <code>text</code> parameter by using an underscore:</p> <pre><code>render: (_, record) =&gt; {\n  return &lt;span&gt;{record.name}&lt;/span&gt;;\n},\n</code></pre> <p>Using Only the Necessary Parameter</p> <p>Alternatively, if you prefer clarity and don\u2019t want to include an unused parameter, you can just write:</p> <pre><code>render: (record) =&gt; {\n  return &lt;span&gt;{record.name}&lt;/span&gt;;\n},\n</code></pre> What Happens <ol> <li> <p>No Errors: Both of these approaches will work without throwing any errors. The <code>record</code> parameter will provide access to the entire row of data, allowing you to retrieve the <code>name</code> property.</p> </li> <li> <p>Readability:</p> <ul> <li>Using an underscore makes it clear to anyone reading the code that you are intentionally ignoring the first parameter.</li> <li>Just using <code>record</code> could lead to confusion, as it deviates from the conventional order.</li> </ul> </li> </ol> Best Practice <p>While it\u2019s technically acceptable to use just <code>record</code>, the most conventional approach is to include the <code>text</code> parameter and use an underscore or simply acknowledge that you won't be using it. This maintains consistency with the expected signature of the <code>render</code> function:</p> <pre><code>render: (_, record) =&gt; {\n    return &lt;span&gt;{record.name}&lt;/span&gt;;\n},\n</code></pre> <p>Summary</p> <p>You can ignore the <code>text</code> parameter in the <code>render</code> function if you don\u2019t need it. Using an underscore (<code>_</code>) is a common practice to indicate that you are intentionally ignoring that parameter, promoting code readability and maintaining conventional coding standards. If you have further questions or need more details, feel free to ask!</p>"},{"location":"frontend/package/antd/controlled-components/","title":"Controlled Component","text":""},{"location":"frontend/package/antd/controlled-components/#controlled-components-with-form-component","title":"Controlled Components with Form Component:","text":"<p>Ant Design provides a <code>Form</code> component that simplifies form handling. You can use controlled components and the <code>Form</code> component together to manage form state and validation easily.</p> jsx<pre><code>import { Form, Input, Button } from \"antd\";\nimport { useState } from \"react\";\n\nfunction MyForm() {\n  const [form] = Form.useForm();\n  const [formData, setFormData] = useState({});\n\n  const onFinish = (values) =&gt; {\n    console.log(\"Form submitted:\", values);\n    // Perform further actions with form data\n  };\n\n  return (\n    &lt;Form form={form} onFinish={onFinish}&gt;\n      &lt;Form.Item name=\"username\" label=\"Username\"&gt;\n        &lt;Input /&gt;\n      &lt;/Form.Item&gt;\n      &lt;Form.Item name=\"password\" label=\"Password\"&gt;\n        &lt;Input.Password /&gt;\n      &lt;/Form.Item&gt;\n      &lt;Form.Item&gt;\n        &lt;Button type=\"primary\" htmlType=\"submit\"&gt;\n          Submit\n        &lt;/Button&gt;\n      &lt;/Form.Item&gt;\n    &lt;/Form&gt;\n  );\n}\n</code></pre>"},{"location":"frontend/package/antd/topic/","title":"Topic","text":"<p>Mastering Ant Design (antd) and reaching a \"god tier\" level involves a combination of understanding the core concepts, practicing extensively, and keeping up with best practices. Here\u2019s a structured approach to get you there:</p> <ol> <li> <p>Understand the Basics</p> <ul> <li>Documentation: Start with the official Ant Design documentation. Familiarize yourself with the core components, layout system, and design principles.</li> <li>Components: Learn how to use basic components like Buttons, Forms, Tables, and Modals. Practice integrating these into a simple project.</li> </ul> </li> <li> <p>Dive Deeper</p> <ul> <li>Advanced Components: Explore more advanced components like DatePicker, Tree, and Cascader. Understand their props, events, and how they interact with other components.</li> <li>Customization: Learn how to customize Ant Design components. Understand theming and how to override default styles using Less or CSS-in-JS.</li> <li>Form Handling: Master the use of Form components for creating and validating forms, handling dynamic fields, and managing complex form layouts.</li> </ul> </li> <li> <p>Build Projects</p> <ul> <li>Small Projects: Start with small projects or components to practice what you\u2019ve learned. For example, build a dashboard using Ant Design\u2019s layout and table components.</li> <li>Complex Applications: Gradually work on more complex applications. Incorporate routing, state management (using libraries like <code>Redux</code> or <code>Zustand</code>), and API interactions.</li> </ul> </li> <li> <p>Optimize Performance</p> <ul> <li>Lazy Loading: Implement code splitting and lazy loading to optimize the performance of your application.</li> <li>Virtualization: Use techniques like windowing for rendering large lists efficiently. Libraries like <code>react-window</code> or <code>react-virtualized</code> can help.</li> </ul> </li> <li> <p>Keep Up with Updates</p> <ul> <li>Changelog: Regularly check Ant Design\u2019s changelog for updates and new features.</li> <li>Community: Engage with the community on forums, GitHub discussions, and social media to learn about best practices and emerging trends.</li> </ul> </li> <li> <p>Contribute and Collaborate</p> <ul> <li>Open Source Contribution: Contribute to the Ant Design library or its ecosystem. It\u2019s a great way to understand the internals and get feedback from other developers.</li> <li>Collaborate: Work on collaborative projects or contribute to open-source projects that use Ant Design.</li> </ul> </li> <li> <p>Best Practices</p> <ul> <li>Consistency: Maintain consistency in your UI design by following Ant Design\u2019s guidelines and patterns.</li> <li>Accessibility: Ensure your applications are accessible. Use tools and practices to make sure your UI is usable by everyone.</li> </ul> </li> <li> <p>Deepen Your Knowledge</p> <ul> <li>Source Code: Explore the source code of Ant Design to understand its inner workings.</li> <li>Performance Tuning: Learn advanced techniques for optimizing React applications, such as memoization, shouldComponentUpdate, and PureComponent.</li> </ul> </li> <li> <p>Teach and Share</p> <ul> <li>Write Articles: Share your knowledge by writing blog posts or creating tutorials.</li> <li>Talks and Workshops: Host talks or workshops to teach others and refine your understanding through teaching.</li> </ul> </li> <li> <p>Stay Curious and Experiment</p> <ul> <li>Experiment: Don\u2019t be afraid to experiment with new features or create custom components.</li> <li>Feedback Loop: Continuously seek feedback on your work and strive for improvement.</li> </ul> </li> </ol> <p>By following these steps, you\u2019ll not only master Ant Design but also become adept at creating high-quality, scalable, and maintainable user interfaces.</p>"},{"location":"frontend/package/antd/twoTone-color/","title":"twoTone icon","text":""},{"location":"frontend/package/antd/twoTone-color/#overview","title":"Overview","text":"<p>For <code>CloseCircleTwoTone</code>, by default, it has two colors: one for the icon's main fill and another for the outline. You can change the color of both parts using the twoToneColor prop.</p> <pre><code>&lt;CloseCircleTwoTone twoToneColor=\"red\" /&gt;\n</code></pre> <p><code>twoToneColor</code> accepts any valid CSS color value:</p> <ul> <li>Hex (\"<code>#FF0000</code>\" for red)</li> <li>RGB (\"<code>rgb(255, 0, 0)</code>\")</li> <li>Named colors (\"<code>red</code>\", \"<code>blue</code>\", etc.)</li> <li>HSL, and so on.</li> </ul> <p>How it works:</p> <ul> <li>When you use CloseCircleTwoTone, the first tone is typically the main fill, and the second tone is used for the stroke (outline) or background.</li> <li>By setting twoToneColor=\"red\", you change both the main fill and the stroke to red.</li> </ul> Example with customization<pre><code>import { CloseCircleTwoTone } from \"@ant-design/icons\";\n\n&lt;CloseCircleTwoTone twoToneColor=\"#FF0000\" /&gt;;\n</code></pre> <p>In this example, the icon will display in red with both the fill and the stroke being red.</p> <p>Default Behavior:</p> <p>If you don't specify <code>twoToneColor</code>, Ant Design uses its default color scheme (usually blue for the main tone and light gray for the secondary tone).</p> <p>So, <code>twoToneColor</code> is not a random property, but a predefined property of Ant Design icons for controlling the color scheme of two-tone icons.</p>"},{"location":"frontend/package/antd/twoTone-color/#question","title":"Question","text":"<p>can't we use twoToneColor in SearchOutlined also like CloseCircleTwoTone</p> <p>No, the <code>twoToneColor</code> prop is specific to two-tone icons in Ant Design, such as <code>CloseCircleTwoTone</code>, <code>HeartTwoTone</code>, <code>CheckCircleTwoTone</code>, and other icons that are designed with two separate color tones (one for the fill and another for the outline or background).</p> <p>The <code>SearchOutlined</code> icon is a single-tone icon, which means it only uses one color for its appearance. Therefore, the <code>twoToneColor</code> prop does not work with single-tone icons like <code>SearchOutlined</code>.</p> <p>Why <code>twoToneColor</code> is not applicable to <code>SearchOutlined</code>:</p> <ul> <li><code>twoToneColor</code> is specifically intended for icons like CloseCircleTwoTone, where there are two separate color sections (e.g., the fill and the outline).</li> <li>Single-tone icons, like <code>SearchOutlined</code>, only have one color applied across the entire icon, which is why the <code>twoToneColor</code> prop is not available for them.</li> </ul> <p>How to Change the Color of SearchOutlined:</p> <p>You can still change the color of single-tone icons, including SearchOutlined, using the following methods:</p> <ol> <li> <p>Using Inline Styles (as mentioned earlier):</p> <ul> <li>Apply a custom color with the <code>style</code> prop.</li> </ul> </li> <li> <p>Using CSS Class:</p> <ul> <li>Apply a CSS class for more flexibility or dynamic styling.</li> </ul> <pre><code>/* styles.css */\n.green-icon {\n  color: green;\n}\n</code></pre> <pre><code>import { SearchOutlined } from \"@ant-design/icons\";\nimport \"./styles.css\"; // Make sure the CSS file is imported\n\n&lt;SearchOutlined className=\"green-icon\" /&gt;;\n</code></pre> </li> </ol> <p>Example with <code>SearchOutlined</code> in Green:</p> <pre><code>import { SearchOutlined } from \"@ant-design/icons\";\n\n&lt;SearchOutlined style={{ color: \"green\", fontSize: \"20px\" }} /&gt;;\n</code></pre> <p>This will apply the green color to the <code>SearchOutlined</code> icon, and you can also adjust other styles like <code>fontSize</code>, <code>padding</code>, etc.</p> <p>In Summary:</p> <ul> <li>No, you cannot use the <code>twoToneColor</code> prop with single-tone icons like <code>SearchOutlined</code>.</li> <li>To change the color of single-tone icons, you should use the <code>style</code> prop or a CSS class to set the color.</li> </ul>"},{"location":"frontend/package/antd/form/antd-form-validator/","title":"Antd Form Validation","text":""},{"location":"frontend/package/antd/form/antd-form-validator/#antd-form-validation","title":"Antd Form Validation","text":"<p><code>Components/modals/quickAddPerson.js</code></p> BasicAdvanced <pre><code>const validateEmail = (_, value) =&gt; {\n    // Basic email validation using a regular expression\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n\n    if (!value || emailRegex.test(value)) {\n        return Promise.resolve();\n    }\n\n    return Promise.reject(\"Invalid email address\");\n};\n\n&lt;Form.Item\n    name=\"email\"\n    label=\"Email\"\n    rules={[\n        {\n            required: true,\n            message: \"Please enter your email\",\n        },\n        {\n            validator: validateEmail,\n        },\n    ]}\n&gt;\n    &lt;Input placeholder=\"Email\" /&gt;\n&lt;/Form.Item&gt;\n</code></pre>"},{"location":"frontend/package/antd/form/antd-form/","title":"Antd Form","text":"<p>Ant Design provides the <code>form.getFieldValue</code> and <code>form.setFieldsValue</code> methods to get and set form field values, respectively</p> jsx<pre><code>const [form] = Form.useForm();\n\nconst otherFieldValue = form.getFieldValue(\"otherField\");\n\nform.setFieldsValue({\n    currentField: /* New value based on custom logic */,\n});\n\nuseEffect(() =&gt; {\n    // Set default values based on external data\n    form.setFieldsValue({\n      username: externalData.username,\n      email: externalData.email,\n    });\n}, [externalData, form]);\n</code></pre>"},{"location":"frontend/package/antd/form/form-crud/","title":"Form CRUD","text":""},{"location":"frontend/package/antd/form/form-crud/#overview","title":"Overview","text":"<p>Certainly! To create a CRUD (Create, Read, Update, Delete) interface using Ant Design (antd) with a component-based architecture, you can break down the application into reusable components. Here\u2019s a simplified example demonstrating this approach.</p>"},{"location":"frontend/package/antd/form/form-crud/#1-setup","title":"1. Setup","text":"<p>First, make sure you have Ant Design installed in your project:</p> <pre><code>npm install antd\n</code></pre>"},{"location":"frontend/package/antd/form/form-crud/#2-basic-structure","title":"2. Basic Structure","text":"<p>For this example, let\u2019s create a CRUD interface for managing a list of items. We will create the following components:</p> <ul> <li>ItemList: Displays the list of items.</li> <li>ItemForm: A form for creating or editing items.</li> <li>CRUDApp: The main component that ties everything together.</li> </ul>"},{"location":"frontend/package/antd/form/form-crud/#3-code-example","title":"3. Code Example","text":"ItemList ComponentItemForm ComponentCRUDApp Component <p>This component will display a list of items and provide buttons to add or edit items.</p> <pre><code>// ItemList.js\nimport React from 'react';\nimport { Table, Button } from 'antd';\n\nconst ItemList = ({ items, onEdit, onDelete, onAdd }) =&gt; {\n    const columns = [\n        {\n            title: 'ID',\n            dataIndex: 'id',\n            key: 'id',\n        },\n        {\n            title: 'Name',\n            dataIndex: 'name',\n            key: 'name',\n        },\n        {\n            title: 'Actions',\n            key: 'actions',\n            render: (_, record) =&gt; (\n                &lt;&gt;\n                    &lt;Button onClick={() =&gt; onEdit(record)} style={{ marginRight: 8 }}&gt;\n                        Edit\n                    &lt;/Button&gt;\n                    &lt;Button onClick={() =&gt; onDelete(record.id)} type=\"danger\"&gt;\n                        Delete\n                    &lt;/Button&gt;\n                &lt;/&gt;\n            ),\n        },\n    ];\n\n    return (\n        &lt;div&gt;\n            &lt;Button onClick={onAdd} type=\"primary\" style={{ marginBottom: 16 }}&gt;\n                Add Item\n            &lt;/Button&gt;\n            &lt;Table dataSource={items} columns={columns} rowKey=\"id\" /&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default ItemList;\n</code></pre> <p>This component will handle the form for adding or editing items.</p> <pre><code>// ItemForm.js\nimport React from 'react';\nimport { Form, Input, Button, Modal } from 'antd';\n\nconst ItemForm = ({ visible, onCancel, onSubmit, initialValues }) =&gt; {\n    const [form] = Form.useForm();\n\n    React.useEffect(() =&gt; {\n        form.setFieldsValue(initialValues);\n    }, [initialValues, form]);\n\n    const handleSubmit = () =&gt; {\n        form.validateFields().then(values =&gt; {\n            onSubmit(values);\n        });\n    };\n\n    return (\n        &lt;Modal\n            visible={visible}\n            title={initialValues ? 'Edit Item' : 'Add Item'}\n            okText=\"Submit\"\n            cancelText=\"Cancel\"\n            onCancel={onCancel}\n            onOk={handleSubmit}\n        &gt;\n            &lt;Form form={form} layout=\"vertical\"&gt;\n                &lt;Form.Item name=\"id\" label=\"ID\" hidden&gt;\n                    &lt;Input /&gt;\n                &lt;/Form.Item&gt;\n                &lt;Form.Item\n                    name=\"name\"\n                    label=\"Name\"\n                    rules={[{ required: true, message: 'Please input the name!' }]}\n                &gt;\n                    &lt;Input /&gt;\n                &lt;/Form.Item&gt;\n            &lt;/Form&gt;\n        &lt;/Modal&gt;\n    );\n};\n\nexport default ItemForm;\n</code></pre> <p>This is the main component that manages the state and handles CRUD operations.</p> <pre><code>// CRUDApp.js\nimport React, { useState } from 'react';\nimport { v4 as uuidv4 } from 'uuid';\nimport ItemList from './ItemList';\nimport ItemForm from './ItemForm';\n\nconst CRUDApp = () =&gt; {\n    const [items, setItems] = useState([]);\n    const [isFormVisible, setIsFormVisible] = useState(false);\n    const [currentItem, setCurrentItem] = useState(null);\n\n    const handleAdd = () =&gt; {\n        setCurrentItem(null);\n        setIsFormVisible(true);\n    };\n\n    const handleEdit = (item) =&gt; {\n        setCurrentItem(item);\n        setIsFormVisible(true);\n    };\n\n    const handleDelete = (id) =&gt; {\n        setItems(items.filter(item =&gt; item.id !== id));\n    };\n\n    const handleSubmit = (values) =&gt; {\n        if (currentItem) {\n            setItems(items.map(item =&gt; (item.id === values.id ? values : item)));\n        } else {\n            setItems([...items, { ...values, id: uuidv4() }]);\n        }\n        setIsFormVisible(false);\n    };\n\n    const handleCancel = () =&gt; {\n        setIsFormVisible(false);\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;ItemList items={items} onAdd={handleAdd} onEdit={handleEdit} onDelete={handleDelete} /&gt;\n            &lt;ItemForm\n                visible={isFormVisible}\n                onCancel={handleCancel}\n                onSubmit={handleSubmit}\n                initialValues={currentItem}\n            /&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default CRUDApp;\n</code></pre>"},{"location":"frontend/package/antd/form/form-crud/#4-integration","title":"4. Integration","text":"<p>Finally, use the <code>CRUDApp</code> component in your application entry point, such as <code>App.js</code>.</p> <pre><code>// App.js\nimport React from \"react\";\nimport \"antd/dist/reset.css\";\nimport CRUDApp from \"./CRUDApp\";\n\nconst App = () =&gt; {\n  return (\n    &lt;div className=\"App\"&gt;\n      &lt;CRUDApp /&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n</code></pre>"},{"location":"frontend/package/antd/form/form-crud/#explanation","title":"Explanation:","text":"<ul> <li> <p>Component-Based Architecture: The application is broken down into reusable components (<code>ItemList</code>, <code>ItemForm</code>, and <code>CRUDApp</code>). This separation of concerns helps maintain clarity and reusability.</p> </li> <li> <p>ItemList Component: Responsible for displaying a table of items and handling actions such as adding, editing, and deleting items.</p> </li> <li> <p>ItemForm Component: A modal form used for both adding new items and editing existing ones. It uses Ant Design's <code>Form</code> and <code>Modal</code> components.</p> </li> <li> <p>CRUDApp Component: Manages the application state and the interaction between <code>ItemList</code> and <code>ItemForm</code>. It handles CRUD operations and controls the visibility of the form.</p> </li> </ul> <p>This structure ensures that each component has a single responsibility, making the code easier to maintain and extend.</p>"},{"location":"frontend/package/antd/form/form-crud/#improvement","title":"Improvement","text":"<p>To improve the CRUD example code provided, you can consider various enhancements for better maintainability, performance, and user experience. Here are several suggestions:</p>"},{"location":"frontend/package/antd/form/form-crud/#1-add-validation-and-error-handling","title":"1. Add Validation and Error Handling:","text":"<p>Ensure robust validation and error handling to make the application more user-friendly and reliable.</p> <ul> <li>Enhanced Validation: Add more detailed validation rules in <code>ItemForm</code> to handle edge cases.</li> </ul> <pre><code>&lt;Form.Item\n  name=\"name\"\n  label=\"Name\"\n  rules={[\n    { required: true, message: \"Please input the name!\" },\n    { min: 3, message: \"Name must be at least 3 characters long!\" },\n  ]}\n&gt;\n  &lt;Input /&gt;\n&lt;/Form.Item&gt;\n</code></pre> <ul> <li>Error Handling in CRUD Operations: Implement error handling for CRUD operations, especially when integrating with an external API.</li> </ul> <pre><code>const handleSubmit = async (values) =&gt; {\n  try {\n    if (currentItem) {\n      // Update existing item\n      setItems(items.map((item) =&gt; (item.id === values.id ? values : item)));\n    } else {\n      // Add new item\n      setItems([...items, { ...values, id: uuidv4() }]);\n    }\n    setIsFormVisible(false);\n  } catch (error) {\n    console.error(\"Failed to save item:\", error);\n    // Show user-friendly error message\n  }\n};\n</code></pre>"},{"location":"frontend/package/antd/form/form-crud/#2-improve-user-experience","title":"2. Improve User Experience:","text":"<p>Enhance the user experience with better UI/UX practices.</p> <ul> <li>Loading States: Add loading indicators to inform users that an operation is in progress.</li> </ul> <pre><code>const [loading, setLoading] = useState(false);\n\nconst handleSubmit = async (values) =&gt; {\n  setLoading(true);\n  try {\n    // Perform the operation\n  } finally {\n    setLoading(false);\n  }\n};\n\nreturn (\n  &lt;Modal\n    visible={visible}\n    title={initialValues ? \"Edit Item\" : \"Add Item\"}\n    okText=\"Submit\"\n    cancelText=\"Cancel\"\n    onCancel={onCancel}\n    onOk={handleSubmit}\n    confirmLoading={loading}\n  &gt;\n    {/* Form content */}\n  &lt;/Modal&gt;\n);\n</code></pre> <ul> <li>Success Messages: Show success messages after successful operations.</li> </ul> <pre><code>import { message } from \"antd\";\n\nconst handleSubmit = async (values) =&gt; {\n  try {\n    if (currentItem) {\n      setItems(items.map((item) =&gt; (item.id === values.id ? values : item)));\n    } else {\n      setItems([...items, { ...values, id: uuidv4() }]);\n    }\n    message.success(\"Item saved successfully!\");\n    setIsFormVisible(false);\n  } catch (error) {\n    message.error(\"Failed to save item.\");\n  }\n};\n</code></pre>"},{"location":"frontend/package/antd/form/form-crud/#3-refactor-and-optimize","title":"3. Refactor and Optimize:","text":"<p>Refactor the code for better organization and performance.</p> <ul> <li>Extract Utility Functions: Move reusable logic into separate utility functions or hooks.</li> </ul> <pre><code>// utils.js\nexport const generateUniqueId = () =&gt; uuidv4();\n\n// CRUDApp.js\nimport { generateUniqueId } from \"./utils\";\n\nconst handleSubmit = (values) =&gt; {\n  if (currentItem) {\n    setItems(items.map((item) =&gt; (item.id === values.id ? values : item)));\n  } else {\n    setItems([...items, { ...values, id: generateUniqueId() }]);\n  }\n  setIsFormVisible(false);\n};\n</code></pre> <ul> <li>Use Custom Hooks: Create custom hooks for managing form state or CRUD operations.</li> </ul> <pre><code>// useItems.js\nimport { useState } from \"react\";\n\nconst useItems = () =&gt; {\n  const [items, setItems] = useState([]);\n\n  const addItem = (item) =&gt; {\n    setItems([...items, { ...item, id: uuidv4() }]);\n  };\n\n  const updateItem = (item) =&gt; {\n    setItems(items.map((i) =&gt; (i.id === item.id ? item : i)));\n  };\n\n  const deleteItem = (id) =&gt; {\n    setItems(items.filter((item) =&gt; item.id !== id));\n  };\n\n  return {\n    items,\n    addItem,\n    updateItem,\n    deleteItem,\n  };\n};\n\nexport default useItems;\n</code></pre> <pre><code>// CRUDApp.js\nimport useItems from \"./useItems\";\n\nconst CRUDApp = () =&gt; {\n  const { items, addItem, updateItem, deleteItem } = useItems();\n  // ...\n};\n</code></pre>"},{"location":"frontend/package/antd/form/form-crud/#4-enhance-accessibility","title":"4. Enhance Accessibility:","text":"<p>Ensure the application is accessible to all users.</p> <ul> <li>Accessible Forms: Add proper labels and ARIA attributes to form elements.</li> </ul> <pre><code>&lt;Form.Item\n  name=\"name\"\n  label=\"Name\"\n  rules={[{ required: true, message: \"Please input the name!\" }]}\n&gt;\n  &lt;Input aria-label=\"Name\" /&gt;\n&lt;/Form.Item&gt;\n</code></pre> <ul> <li>Keyboard Navigation: Ensure that modals and forms can be navigated using the keyboard.</li> </ul>"},{"location":"frontend/package/antd/form/form-crud/#5-add-testing","title":"5. Add Testing:","text":"<p>Implement tests to ensure the application works correctly and to catch regressions.</p> <ul> <li>Unit Tests: Write unit tests for individual components and functions using a testing library like Jest and React Testing Library.</li> </ul> <pre><code>import { render, screen, fireEvent } from \"@testing-library/react\";\nimport CRUDApp from \"./CRUDApp\";\n\ntest(\"renders ItemList and shows form on Add\", () =&gt; {\n  render(&lt;CRUDApp /&gt;);\n  const addButton = screen.getByText(/Add Item/i);\n  fireEvent.click(addButton);\n  expect(screen.getByText(/Add Item/i)).toBeInTheDocument();\n});\n</code></pre> <ul> <li>Integration Tests: Test how different components work together.</li> </ul> <pre><code>// Test that adding an item updates the list\n</code></pre>"},{"location":"frontend/package/antd/form/form-crud/#6-add-documentation","title":"6. Add Documentation:","text":"<p>Document your components and their usage to help future developers understand and use them effectively.</p> <ul> <li>Component Documentation: Use <code>comments</code> and <code>README</code> files to describe the purpose and usage of components.</li> </ul> <pre><code>/**\n * ItemForm Component\n * Displays a form for adding or editing an item.\n * Props:\n * - visible (boolean): Controls the visibility of the modal.\n * - onCancel (function): Callback when the form is canceled.\n * - onSubmit (function): Callback when the form is submitted.\n * - initialValues (object): Values to pre-fill the form.\n */\n</code></pre>"},{"location":"frontend/package/antd/form/form-crud/#conclusion","title":"Conclusion:","text":"<p>By incorporating these improvements, you enhance the robustness, performance, and user experience of your CRUD application. These practices also make your codebase easier to maintain and extend in the future.</p>"},{"location":"frontend/package/antd/form/intro/","title":"Intro","text":""},{"location":"frontend/package/antd/form/intro/#example-form-layouts","title":"Example Form Layouts:","text":"<p>Ant Design offers multiple form layouts:</p> <ul> <li> <p>Horizontal Layout (default):</p> <pre><code>&lt;Form layout=\"horizontal\" ... /&gt;\n</code></pre> </li> <li> <p>Vertical Layout:</p> <pre><code>&lt;Form layout=\"vertical\" ... /&gt;\n</code></pre> </li> <li> <p>Inline Layout:</p> <pre><code>&lt;Form layout=\"inline\" ... /&gt;\n</code></pre> </li> </ul> <p>If you're building a larger form, consider exploring the <code>Form.List</code> for handling dynamic fields or nested forms!</p> Example ExampleExplanation <pre><code>// LoginForm.tsx\n\nimport React from \"react\";\nimport { Form, Input, Button } from \"antd\";\n\nconst LoginForm: React.FC = () =&gt; {\n    // Handle form submission\n    const onFinish = (values: { username: string; password: string }) =&gt; {\n        console.log(\"Received values:\", values);\n    };\n\n    return (\n        &lt;div style={{ maxWidth: \"300px\", margin: \"0 auto\" }}&gt;\n            &lt;h2 style={{ textAlign: \"center\" }}&gt;Login&lt;/h2&gt;\n            &lt;Form\n                name=\"login\"\n                initialValues={{ remember: true }}\n                onFinish={onFinish}\n                layout=\"vertical\"\n            &gt;\n                &lt;Form.Item\n                    name=\"username\"\n                    label=\"Username\"\n                    rules={[{ required: true, message: \"Please input your username!\" }]}\n                &gt;\n                    &lt;Input placeholder=\"Enter your username\" /&gt;\n                &lt;/Form.Item&gt;\n\n                &lt;Form.Item\n                    name=\"password\"\n                    label=\"Password\"\n                    rules={[{ required: true, message: \"Please input your password!\" }]}\n                &gt;\n                    &lt;Input.Password placeholder=\"Enter your password\" /&gt;\n                &lt;/Form.Item&gt;\n\n                &lt;Form.Item&gt;\n                    &lt;Button type=\"primary\" htmlType=\"submit\" block&gt;\n                        Login\n                    &lt;/Button&gt;\n                &lt;/Form.Item&gt;\n            &lt;/Form&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default LoginForm;\n</code></pre> <ol> <li> <p>Form Component: The <code>Form</code> component is used to create the form. It accepts several props:</p> <ul> <li><code>name</code>: The name of the form.</li> <li><code>initialValues</code>: The default values for the form fields (like <code>remember</code> here).</li> <li><code>onFinish</code>: The callback function that is triggered when the form is successfully submitted.</li> <li><code>layout=\"vertical\"</code>: This sets the layout of the form, where each label is placed above the input field.</li> </ul> </li> <li> <p>Form.Item: Each form field is wrapped in a <code>Form.Item</code> component, which corresponds to a single input or control. Each <code>Form.Item</code>:</p> <ul> <li><code>name</code>: Specifies the name of the field (used to reference it in the onFinish callback).</li> <li><code>label</code>: The label text for the field.</li> <li><code>rules</code>: An array that defines the validation rules for that field.</li> </ul> </li> <li> <p>Input &amp; Input.Password:</p> <ul> <li><code>Input</code> is used for regular text input.</li> <li><code>Input.Password</code> is used for password fields (it automatically hides the text).</li> </ul> </li> <li> <p>Button: The <code>Button</code> component is used to trigger the form submission when clicked. It uses the <code>htmlType=\"submit\"</code> attribute to trigger the onFinish function.</p> </li> <li> <p>Form Validation: The <code>rules</code> prop in each <code>Form.Item</code> handles form validation. In this case, both the <code>username</code> and <code>password</code> fields are required, and if the user doesn't fill them out, an error message will appear.</p> </li> </ol>"},{"location":"frontend/package/antd/sidebar/intro/","title":"Intro","text":""},{"location":"frontend/package/antd/sidebar/intro/#overview","title":"Overview","text":"<p>To create a modular and reusable layout in React with Ant Design, we can break the layout into smaller, reusable components. This approach allows you to easily modify parts of the layout and reuse them in other parts of your application. Here's a way to structure your layout:</p>"},{"location":"frontend/package/antd/sidebar/intro/#1-create-reusable-layout-components","title":"1. Create Reusable Layout Components","text":"<p>We will create modular components for:</p> <ul> <li>Sidebar: The sidebar component that will house the navigation.</li> <li>Header: A reusable header with options like logo or user profile.</li> <li>MainLayout: The main layout that combines the <code>Sidebar</code> and <code>Header</code> components.</li> <li>Content: A dynamic content area that changes based on routing or other conditions.</li> </ul>"},{"location":"frontend/package/antd/sidebar/intro/#2-example-code","title":"2. Example Code","text":"Sidebar.jsHeader.jsMainLayout.jsContentArea.js <pre><code>import React from 'react';\nimport { Layout, Menu } from 'antd';\nimport { HomeOutlined, SearchOutlined, AppstoreAddOutlined } from '@ant-design/icons';\n\nconst { Sider } = Layout;\n\nconst Sidebar = ({ collapsed, onCollapse }) =&gt; (\n    &lt;Sider\n        collapsible\n        collapsed={collapsed}\n        onCollapse={onCollapse}\n        width={250}\n        style={{ background: '#fff' }}\n    &gt;\n        &lt;Menu mode=\"inline\" defaultSelectedKeys={['1']} theme=\"light\"&gt;\n            &lt;Menu.Item key=\"1\" icon={&lt;HomeOutlined /&gt;}&gt;\n                Home\n            &lt;/Menu.Item&gt;\n            &lt;Menu.Item key=\"2\" icon={&lt;SearchOutlined /&gt;}&gt;\n                Search\n            &lt;/Menu.Item&gt;\n            &lt;Menu.Item key=\"3\" icon={&lt;AppstoreAddOutlined /&gt;}&gt;\n                Add Item\n            &lt;/Menu.Item&gt;\n        &lt;/Menu&gt;\n    &lt;/Sider&gt;\n);\n\nexport default Sidebar;\n</code></pre> <pre><code>import React from 'react';\nimport { Layout, Button } from 'antd';\n\nconst { Header } = Layout;\n\nconst AppHeader = ({ onCollapse, collapsed }) =&gt; (\n    &lt;Header style={{ background: '#fff', padding: 0 }}&gt;\n        &lt;Button\n        type=\"primary\"\n        onClick={() =&gt; onCollapse(!collapsed)}\n        style={{ marginLeft: 16 }}\n        &gt;\n            {collapsed ? 'Expand' : 'Collapse'}\n        &lt;/Button&gt;\n    &lt;/Header&gt;\n    );\n\nexport default AppHeader;\n</code></pre> <pre><code>import React, { useState } from 'react';\nimport { Layout } from 'antd';\nimport Sidebar from './Sidebar';\nimport AppHeader from './Header';\nimport ContentArea from './ContentArea';\n\nconst { Content } = Layout;\n\nconst MainLayout = () =&gt; {\n    const [collapsed, setCollapsed] = useState(false);\n\n    const handleCollapse = (collapsed) =&gt; {\n        setCollapsed(collapsed);\n    };\n\n    return (\n        &lt;Layout style={{ minHeight: '100vh' }}&gt;\n            &lt;AppHeader collapsed={collapsed} onCollapse={handleCollapse} /&gt;\n            &lt;Layout&gt;\n                &lt;Sidebar collapsed={collapsed} onCollapse={handleCollapse} /&gt;\n                &lt;Layout style={{ padding: '0 24px 24px' }}&gt;\n                    &lt;Content style={{ padding: 24, margin: 0 }}&gt;\n                        &lt;ContentArea /&gt;\n                    &lt;/Content&gt;\n                &lt;/Layout&gt;\n            &lt;/Layout&gt;\n        &lt;/Layout&gt;\n    );\n};\n\nexport default MainLayout;\n</code></pre> <pre><code>import React from 'react';\n\nconst ContentArea = () =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Welcome to the Content Area!&lt;/h1&gt;\n            &lt;p&gt;This section will change depending on the route or active content.&lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default ContentArea;\n</code></pre>"},{"location":"frontend/package/antd/sidebar/intro/#3-putting-it-together","title":"3. Putting It Together","text":"<p>Finally, in your main application file (e.g., <code>App.js</code>), import and use <code>MainLayout</code>:</p> App.js <pre><code>import React from 'react';\nimport MainLayout from './components/MainLayout';\n\nconst App = () =&gt; (\n    &lt;div&gt;\n        &lt;MainLayout /&gt;\n    &lt;/div&gt;\n);\n\nexport default App;\n</code></pre> Explanation <ul> <li> <p>Modularity: Each part of the layout (<code>Sidebar</code>, <code>Header</code>, <code>MainLayout</code>, <code>ContentArea</code>) is separated into its own component, making the layout modular and easy to manage.</p> </li> <li> <p>Reusability: If you need to reuse the <code>Sidebar</code> or <code>Header</code> in other parts of the application, you can just import them as needed. This reduces duplication and makes your code more maintainable.</p> </li> <li> <p>Dynamic Content: The <code>ContentArea</code> component can be replaced with dynamic content based on routing (using react-router), user interaction, or other application states.</p> </li> <li> <p>State Management: The collapsed state of the sidebar is managed at the top level (<code>MainLayout</code>) and passed down to child components (<code>Sidebar</code> and <code>Header</code>) via props. This allows central control of the layout state.</p> </li> </ul>"},{"location":"frontend/package/antd/sidebar/intro/#4-adding-responsiveness","title":"4. Adding Responsiveness","text":"<p>You can enhance responsiveness by adding breakpoints using Ant Design\u2019s <code>Sider</code> props like <code>breakpoint</code> and <code>collapsedWidth</code> or using CSS media queries for custom behavior.</p> <pre><code>&lt;Sider\n  collapsible\n  collapsed={collapsed}\n  onCollapse={onCollapse}\n  breakpoint=\"lg\" // Collapse at 'lg' breakpoint\n  collapsedWidth=\"80\"\n  style={{ background: \"#fff\" }}\n&gt;\n  {/* Menu items */}\n&lt;/Sider&gt;\n</code></pre> <p>This structure provides flexibility to modify, extend, and reuse the layout components across your application. Would you like more advanced features like routing or adding custom hooks to further enhance this layout?</p> <pre><code>/src\n  \u251c\u2500\u2500 /assets                # Static assets like images, fonts, etc.\n  \u251c\u2500\u2500 /components            # Reusable components (UI components unrelated to layout)\n  \u251c\u2500\u2500 /layout                # Folder containing all the sidebar layout components\n  \u2502   \u251c\u2500\u2500 Header.js          # Header component\n  \u2502   \u251c\u2500\u2500 Sidebar.js         # Sidebar component\n  \u2502   \u251c\u2500\u2500 MainLayout.js      # Main layout that combines Sidebar, Header, and Content\n  \u2502   \u2514\u2500\u2500 ContentArea.js     # Content area for dynamic content\n  \u251c\u2500\u2500 /pages                 # Page components (pages of your app)\n  \u2502   \u251c\u2500\u2500 HomePage.js\n  \u2502   \u251c\u2500\u2500 SearchPage.js\n  \u2502   \u2514\u2500\u2500 AddItemPage.js\n  \u251c\u2500\u2500 /styles                # Global styles (CSS, SCSS, styled-components)\n  \u2502   \u251c\u2500\u2500 global.css\n  \u2502   \u2514\u2500\u2500 theme.css\n  \u251c\u2500\u2500 /utils                 # Utility functions and helpers\n  \u251c\u2500\u2500 /App.js                # Main entry point for the app\n  \u2514\u2500\u2500 /index.js              # ReactDOM render entry point\n</code></pre>"},{"location":"frontend/package/antd/table/filters/","title":"Filters","text":""},{"location":"frontend/package/antd/table/filters/#simple","title":"Simple","text":"ExampleHow It Works <pre><code>import React from 'react';\nimport { Table } from 'antd';\n\nconst App = () =&gt; {\n    // Sample data\n    const data = [\n        { key: '1', name: 'John Doe', age: 32, address: 'New York' },\n        { key: '2', name: 'Jane Smith', age: 28, address: 'London' },\n        { key: '3', name: 'Sam Brown', age: 22, address: 'Sydney' },\n    ];\n\n    // Define columns with filters for name\n    const columns = [\n        {\n            title: 'Name',\n            dataIndex: 'name',\n            filters: [\n                { text: 'John Doe', value: 'John Doe' },\n                { text: 'Jane Smith', value: 'Jane Smith' },\n            ],\n            onFilter: (value, record) =&gt; record.name.includes(value),\n        },\n        {\n            title: 'Age',\n            dataIndex: 'age',\n        },\n        {\n            title: 'Address',\n            dataIndex: 'address',\n        },\n    ];\n\n    return (\n        &lt;Table\n            columns={columns}\n            dataSource={data}\n            pagination={false}\n        /&gt;\n    );\n};\n\nexport default App;\n</code></pre> <ol> <li>Data Source: The <code>data</code> array contains records with <code>name</code>, <code>age</code>, and <code>address</code>.</li> <li>Column Definitions:<ul> <li>The <code>name</code> column has filters that allow users to filter by specific names (e.g., \"John Doe\" or \"Jane Smith\").</li> <li>The <code>onFilter</code> function checks if the <code>name</code> of the record includes the selected filter value.</li> </ul> </li> <li>Rendering: The <code>Table</code> component displays the columns and data, enabling name-based filtering.</li> </ol>"},{"location":"frontend/package/antd/table/filters/#age","title":"Age","text":"ExampleKey PointsModular <pre><code>import React from 'react';\nimport { Table } from 'antd';\n\nconst App = () =&gt; {\n    // Sample data\n    const data = [\n        { key: '1', name: 'John Doe', age: 32, address: 'New York' },\n        { key: '2', name: 'Jane Smith', age: 28, address: 'London' },\n        { key: '3', name: 'Sam Brown', age: 22, address: 'Sydney' },\n    ];\n\n    // Define columns with filters directly\n    const columns = [\n        {\n            title: 'Name',\n            dataIndex: 'name',\n        },\n        {\n            title: 'Age',\n            dataIndex: 'age',\n            filters: [\n                { text: 'Under 30', value: 'under30' },\n                { text: '30 and above', value: '30plus' },\n            ],\n            onFilter: (value, record) =&gt; {\n                if (value === 'under30') return record.age &lt; 30;\n                if (value === '30plus') return record.age &gt;= 30;\n                return true;\n            },\n        },\n        {\n            title: 'Address',\n            dataIndex: 'address',\n        },\n    ];\n\n    return (\n        &lt;Table\n            columns={columns}\n            dataSource={data}\n            pagination={false}\n        /&gt;\n    );\n};\n\nexport default App;\n</code></pre> <ol> <li>Data Source: The <code>data</code> array contains a list of users.</li> <li>Column Definitions:<ul> <li>The <code>age</code> column includes filters directly defined in the <code>filters</code> property.</li> <li>The <code>onFilter</code> function is specified inline, making it clear and concise.</li> </ul> </li> <li>Rendering: The <code>Table</code> component displays the columns and data, allowing users to filter by age.</li> </ol> <pre><code>import React from 'react';\nimport { Table } from 'antd';\n\nconst App = () =&gt; {\n    // Sample data\n    const data = [\n        { key: '1', name: 'John Doe', age: 32, address: 'New York' },\n        { key: '2', name: 'Jane Smith', age: 28, address: 'London' },\n        { key: '3', name: 'Sam Brown', age: 22, address: 'Sydney' },\n    ];\n\n    // Age filter options\n    const ageFilter = [\n        { text: 'Under 30', value: 'under30' },\n        { text: '30 and above', value: '30plus' },\n    ];\n\n    // Filter function for age\n    const onFilter = (value, record) =&gt; {\n        if (value === 'under30') {\n            return record.age &lt; 30;\n        }\n        if (value === '30plus') {\n            return record.age &gt;= 30;\n        }\n        return true;\n    };\n\n    // Define columns\n    const columns = [\n        {\n            title: 'Name',\n            dataIndex: 'name',\n        },\n        {\n            title: 'Age',\n            dataIndex: 'age',\n            filters: ageFilter,\n            onFilter: onFilter,\n        },\n        {\n            title: 'Address',\n            dataIndex: 'address',\n        },\n    ];\n\n    return (\n        &lt;Table\n            columns={columns}\n            dataSource={data}\n            pagination={false}\n        /&gt;\n    );\n};\n\nexport default App;\n</code></pre>"},{"location":"frontend/package/antd/table/filters/#mastering-filters-in-ant-design-tables","title":"Mastering filters in Ant Design tables","text":"<p>Mastering filters in Ant Design (antd) tables involves understanding their capabilities and utilizing advanced features for better data management. Here\u2019s a comprehensive guide to help you become proficient with filters in antd tables.</p>"},{"location":"frontend/package/antd/table/filters/#1-basic-filtering","title":"1. Basic Filtering","text":"<p>Start with simple filters for specific columns, as shown in previous examples. You can set filters directly in the column definitions and handle filtering logic.</p> <pre><code>{\n  title: 'Name',\n  dataIndex: 'name',\n  filters: [\n    { text: 'John Doe', value: 'John Doe' },\n    { text: 'Jane Smith', value: 'Jane Smith' },\n  ],\n  onFilter: (value, record) =&gt; record.name.includes(value),\n}\n</code></pre>"},{"location":"frontend/package/antd/table/filters/#2-multiple-filters","title":"2. Multiple Filters","text":"<p>You can implement multiple filters across different columns. Each column can have its own set of filters, allowing users to refine their searches.</p> <pre><code>{\n  title: 'Age',\n  dataIndex: 'age',\n  filters: [\n    { text: 'Under 30', value: 'under30' },\n    { text: '30 and above', value: '30plus' },\n  ],\n  onFilter: (value, record) =&gt; {\n    if (value === 'under30') return record.age &lt; 30;\n    if (value === '30plus') return record.age &gt;= 30;\n    return true;\n  },\n}\n</code></pre>"},{"location":"frontend/package/antd/table/filters/#3-custom-filter-logic","title":"3. Custom Filter Logic","text":"<p>You can create more complex filter logic using custom functions. This is especially useful for non-standard data types or specific business rules.</p> <pre><code>const customFilter = (value, record) =&gt; {\n  // Custom logic based on some criteria\n  return record.age === value;\n};\n\n{\n  title: 'Age',\n  dataIndex: 'age',\n  filters: [\n    { text: '22', value: 22 },\n    { text: '32', value: 32 },\n  ],\n  onFilter: customFilter,\n}\n</code></pre>"},{"location":"frontend/package/antd/table/filters/#4-dynamic-filters","title":"4. Dynamic Filters","text":"<p>You can generate filter options dynamically based on your data. This ensures users always have relevant options to choose from.</p> <pre><code>const uniqueNames = [...new Set(data.map((item) =&gt; item.name))];\n\nconst columns = [\n  {\n    title: \"Name\",\n    dataIndex: \"name\",\n    filters: uniqueNames.map((name) =&gt; ({ text: name, value: name })),\n    onFilter: (value, record) =&gt; record.name.includes(value),\n  },\n];\n</code></pre>"},{"location":"frontend/package/antd/table/filters/#5-search-filtering","title":"5. Search Filtering","text":"<p>In addition to predefined filters, consider implementing a search input for user-friendly filtering. This allows users to search for specific text within a column.</p> <pre><code>import { Input } from \"antd\";\n\nconst App = () =&gt; {\n  const [searchText, setSearchText] = React.useState(\"\");\n\n  const filteredData = data.filter((item) =&gt;\n    item.name.toLowerCase().includes(searchText.toLowerCase())\n  );\n\n  return (\n    &lt;&gt;\n      &lt;Input\n        placeholder=\"Search by name\"\n        onChange={(e) =&gt; setSearchText(e.target.value)}\n      /&gt;\n      &lt;Table dataSource={filteredData} columns={columns} /&gt;\n    &lt;/&gt;\n  );\n};\n</code></pre>"},{"location":"frontend/package/antd/table/filters/#6-combining-filters","title":"6. Combining Filters","text":"<p>You can combine multiple filters across different columns, allowing users to filter based on multiple criteria simultaneously.</p> <pre><code>const combinedFilter = (filters) =&gt; (record) =&gt; {\n  const matchesName = filters.name ? record.name.includes(filters.name) : true;\n  const matchesAge = filters.age ? record.age === filters.age : true;\n  return matchesName &amp;&amp; matchesAge;\n};\n</code></pre>"},{"location":"frontend/package/antd/table/filters/#7-resetting-filters","title":"7. Resetting Filters","text":"<p>Provide a way for users to reset filters easily. This improves usability and allows users to start fresh.</p> <pre><code>const resetFilters = () =&gt; {\n  setFilters({ name: \"\", age: null });\n};\n\n&lt;Button onClick={resetFilters}&gt;Reset Filters&lt;/Button&gt;;\n</code></pre>"},{"location":"frontend/package/antd/table/filters/#conclusion","title":"Conclusion","text":"<p>Mastering filters in antd tables involves understanding how to implement basic filtering, create custom logic, generate dynamic options, and enhance user experience with search functionality. By combining these techniques, you can create powerful and user-friendly data tables in your applications!</p>"},{"location":"frontend/package/axios/axios-interceptors/","title":"Axios Interceptors","text":"<p>Here's how you can structure your application to ensure that the Axios interceptor works properly, along with an example.</p>"},{"location":"frontend/package/axios/axios-interceptors/#overview","title":"Overview","text":"File Structure <pre><code>src/\n\u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 axiosInstance.js\n\u2502   \u251c\u2500\u2500 axiosInterceptors.js\n\u2502   \u2514\u2500\u2500 dataService.js\n\u251c\u2500\u2500 App.js\n\u2514\u2500\u2500 index.js\n</code></pre>"},{"location":"frontend/package/axios/axios-interceptors/#1-axiosinstancejs","title":"1. axiosInstance.js","text":"Example <p>This sets up the Axios instance:</p> <pre><code>// services/axiosInstance.js\nimport axios from \"axios\";\n\nconst axiosInstance = axios.create({\n    baseURL: process.env.REACT_APP_BASE_API_URL,\n});\n\nexport default axiosInstance;\n</code></pre>"},{"location":"frontend/package/axios/axios-interceptors/#2-axiosinterceptorsjs","title":"2. axiosInterceptors.js","text":"Example <p>This configures the request interceptor:</p> <pre><code>// services/axiosInterceptors.js\nimport axiosInstance from \"./axiosInstance\";\n\naxiosInstance.interceptors.request.use(\n    (config) =&gt; {\n        console.log(\"Interceptor triggered\");\n        console.log(\"INTERCEPTORS config: \", config);\n        return config;\n    },\n    (error) =&gt; {\n        console.error(\"Interceptor error:\", error);\n        return Promise.reject(error);\n    }\n);\n</code></pre>"},{"location":"frontend/package/axios/axios-interceptors/#3-dataservicejs","title":"3. dataService.js","text":"Example <p>This file handles API requests:</p> <pre><code>// services/dataService.js\nimport axiosInstance from \"./axiosInstance\";\n\nexport const fetchData = (url, signal) =&gt; {\n    console.log(\"fetchData called with URL:\", url); // Debug log\n    return axiosInstance.get(url, {\n        cancelToken: signal,\n    });\n};\n</code></pre>"},{"location":"frontend/package/axios/axios-interceptors/#4-indexjs","title":"4. index.js","text":"Example <p>Make sure to import the interceptor setup here so it gets registered when your app starts:</p> <pre><code>// index.js\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport './services/axiosInterceptors'; // Import interceptors\n\nReactDOM.render(\n    &lt;React.StrictMode&gt;\n        &lt;App /&gt;\n    &lt;/React.StrictMode&gt;,\n    document.getElementById(\"root\")\n);\n</code></pre>"},{"location":"frontend/package/axios/axios-interceptors/#5-appjs","title":"5. App.js","text":"Example <p>Now you can use the <code>fetchData</code> function in your components:</p> <pre><code>// App.js\nimport React, { useEffect } from \"react\";\nimport { fetchData } from \"./services/dataService\";\n\nconst App = () =&gt; {\n    useEffect(() =&gt; {\n        const controller = new AbortController();\n        const signal = controller.signal;\n\n        fetchData(\"/example-endpoint\", signal)\n            .then((response) =&gt; {\n                console.log(\"Data received:\", response.data);\n            })\n            .catch((error) =&gt; {\n                console.error(\"Error fetching data:\", error);\n            });\n\n            return () =&gt; {\n            controller.abort(); // Cleanup the signal on component unmount\n        };\n    }, []);\n\n    return &lt;div&gt;Check the console for logs!&lt;/div&gt;;\n};\n\nexport default App;\n</code></pre>"},{"location":"frontend/package/axios/axios-interceptors/#explanation","title":"Explanation","text":"<ul> <li>Importing Interceptors: By importing <code>axiosInterceptors.js</code> in <code>index.js</code>, you ensure that the interceptors are set up before any API calls are made.</li> <li>Using the Instance: The <code>fetchData</code> function uses the configured Axios instance, meaning that any request made with it will trigger the interceptor.</li> <li>Logging: You should see the console logs from both the interceptor and the fetch function when the component mounts.</li> </ul>"},{"location":"frontend/package/axios/axios-interceptors/#conclusion","title":"Conclusion","text":"<p>With this setup, you should be able to see the interceptor's log statements in the console when <code>fetchData</code> is called. Make sure your base API URL is set correctly in your environment variables for successful requests.</p>"},{"location":"frontend/package/axios/axios-interceptors/#additional","title":"Additional","text":"<p>If you're not importing axiosInterceptors.js in your index.js, that would explain why the interceptor isn't working.</p> <p>Here's a quick recap of what you need to do to fix it:</p> <p>Steps to Fix the Issue</p> <ul> <li>Import the Interceptor File: Open your <code>index.js</code> file and make sure to import <code>axiosInterceptors.js</code> so that the interceptors get registered when your app starts.</li> </ul> Example Code for <code>index.js</code>Explanation <p>Here\u2019s how your index.js should look:</p> <pre><code>// index.js\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport './services/axiosInterceptors'; // Importing the interceptors\n\nReactDOM.render(\n    &lt;React.StrictMode&gt;\n        &lt;App /&gt;\n    &lt;/React.StrictMode&gt;,\n    document.getElementById(\"root\")\n);\n</code></pre> <ul> <li> <p>Why Import It: By importing <code>axiosInterceptors.js</code>, you ensure that the interceptors are set up as soon as your application initializes. This allows them to intercept any API requests made afterward.</p> </li> <li> <p>No Other Changes Needed: You don't need to change anything else in your existing files. Just make sure the import statement is there.</p> </li> </ul> <p>After Making Changes</p> <p>Once you add the import, you should be able to see the console logs from the interceptor when you make API calls. If you still have issues, double-check that there are no other errors in your console that might be affecting the execution.</p>"},{"location":"frontend/package/axios/axios-interceptors/#issue","title":"Issue","text":"<p>Understanding the Issue</p> <p>Since you've already imported <code>axiosInterceptors.js</code> in your <code>index.js</code>, importing it again in <code>axiosInstance.js</code> is unnecessary and can lead to problems, especially if both files depend on each other.</p> Recommended Approach <ul> <li> <p>Remove Import from <code>axiosInstance.js</code>: Since you are already importing <code>axiosInterceptors.js</code> in <code>index.js</code>, you can safely remove the import statement from <code>axiosInstance.js</code>.</p> </li> <li> <p>Order of Imports: Make sure <code>axiosInterceptors.js</code> is imported before any requests are made in your application. As long as you import it in <code>index.js</code>, it should work fine.</p> </li> </ul> <p>Updated <code>axiosInstance.js</code></p> axiosInstance.jsaxiosInterceptors.jsindex.jsSummary <p>Here's how <code>axiosInstance.js</code> should look:</p> <pre><code>// services/axiosInstance.js\nimport axios from \"axios\";\n\nconst axiosInstance = axios.create({\n    baseURL: process.env.REACT_APP_BASE_API_URL,\n});\n\nexport default axiosInstance;\n</code></pre> <p>This file remains unchanged:</p> <pre><code>// services/axiosInterceptors.js\nimport axiosInstance from \"./axiosInstance\";\n\naxiosInstance.interceptors.request.use(\n    (config) =&gt; {\n        console.log(\"Interceptor triggered\");\n        console.log(\"INTERCEPTORS config: \", config);\n        return config;\n    },\n    (error) =&gt; {\n        console.error(\"Interceptor error:\", error);\n        return Promise.reject(error);\n    }\n);\n</code></pre> <p>Since you've already imported <code>axiosInterceptors.js</code> here, you're all set:</p> <pre><code>// index.js\nimport React from \"react\";\nimport ReactDOM from \"react-dom/client\";\nimport { Provider } from \"react-redux\";\nimport { store } from \"./redux/store/store\";\nimport \"./index.css\";\nimport \"./styles/global.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\nimport \"./redux/services/axiosInterceptors\"; // Importing interceptors here\n\nconst root = ReactDOM.createRoot(document.getElementById(\"root\"));\nroot.render(\n    &lt;React.StrictMode&gt;\n        &lt;Provider store={store}&gt;\n            &lt;App /&gt;\n        &lt;/Provider&gt;\n    &lt;/React.StrictMode&gt;\n);\n\n// Performance measurement code\nreportWebVitals();\n</code></pre> <ul> <li>Remove Import: Remove the import of <code>axiosInterceptors.js</code> from <code>axiosInstance.js</code>.</li> <li>Import in Index: Keep the import in <code>index.js</code>, ensuring that interceptors are set up before any API requests.</li> <li>Circular Dependency: This approach avoids circular dependency issues that can lead to initialization errors.</li> </ul> <p>With these changes, your application should work correctly without the errors you encountered.</p>"},{"location":"frontend/package/axios/axios-interceptors/#great-solution","title":"Great Solution","text":"<p>To manage multiple APIs with different authentication methods in your <code>axiosInstance</code>, you can modify the request interceptor to check which API you're calling and set the <code>Authorization</code> header accordingly. You can achieve this by including an additional property in the config to identify which API is being used.</p> axiosInstance.jsaxiosInterceptors.jsExplanation <pre><code>import axiosInstance from \"./axiosInstance\";\n\nconst apiManager = {\n    base: axiosInstance.create({\n        baseURL: process.env.REACT_APP_BASE_API_URL,\n    }),\n    blog: axiosInstance.create({\n        baseURL: process.env.REACT_APP_BLOG_API_URL,\n    }),\n};\n\nexport default apiManager;\n</code></pre> <pre><code>import axiosInstance from \"./axiosInstance\";\n\n// Add a request interceptor\naxiosInstance.interceptors.request.use(\n    (config) =&gt; {\n            const apiKey = process.env.REACT_APP_BLOG_API_KEY;\n\n            // Check if the request is to the blog API\n            if (config.baseURL === process.env.REACT_APP_BLOG_API_URL) {\n            if (apiKey) {\n                config.headers[\"Authorization\"] = `Bearer ${apiKey}`;\n            }\n        } else {\n            // Assuming you have a way to get the token (e.g., from localStorage or a global state)\n            const token = localStorage.getItem(\"your_token_key\"); // Replace with your method to get the token\n            if (token) {\n                config.headers[\"Authorization\"] = `Bearer ${token}`;\n            }\n        }\n\n        console.log(\"Interceptor triggered\");\n        console.log(\"INTERCEPTORS config: \", config);\n        return config;\n    },\n    (error) =&gt; {\n        console.error(\"Interceptor error:\", error);\n        return Promise.reject(error);\n    }\n);\n</code></pre> <ol> <li> <p>Interceptor Logic: The interceptor checks the <code>baseURL</code> of the request. If it's the blog API URL, it sets the <code>Authorization</code> header using the <code>REACT_APP_BLOG_API_KEY</code>. For all other requests (like the base API for login), it retrieves the token from storage and sets it in the header.</p> </li> <li> <p>Token Storage: Ensure you replace <code>localStorage.getItem(\"your_token_key\")</code> with your actual logic for retrieving the user token.</p> </li> </ol> <p>This setup allows you to easily manage different authentication methods for multiple APIs within your application.</p>"},{"location":"frontend/package/axios/intro/","title":"Intro","text":"<p>Mastering Axios in React involves understanding both the library itself and how to integrate it effectively in your applications.</p>"},{"location":"frontend/package/axios/intro/#overview","title":"Overview","text":"<p>Here\u2019s a roadmap to help you become a top-level developer with Axios:</p>"},{"location":"frontend/package/axios/intro/#1-basics-of-axios","title":"1. Basics of Axios","text":"<ul> <li>Installation: Install Axios via npm or yarn.</li> </ul> <pre><code>npm install axios\n</code></pre> <ul> <li>Making Requests: Understand <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code> requests.</li> <li>Response Handling: Learn to handle responses and errors properly.</li> </ul>"},{"location":"frontend/package/axios/intro/#2-setting-up-axios","title":"2. Setting Up Axios","text":"<ul> <li>Create an Axios Instance: Set default settings (base URL, headers, etc.).</li> </ul> <pre><code>import axios from \"axios\";\n\nconst axiosInstance = axios.create({\n  baseURL: \"https://api.example.com\",\n  timeout: 1000,\n  headers: { Authorization: \"Bearer token\" },\n});\n</code></pre> <ul> <li>Global Interceptors: Use interceptors for requests and responses to handle authentication, logging, etc.</li> </ul> <pre><code>axios.interceptors.request.use(\n  (config) =&gt; {\n    // Modify request\n    return config;\n  },\n  (error) =&gt; {\n    return Promise.reject(error);\n  }\n);\n</code></pre>"},{"location":"frontend/package/axios/intro/#3-advanced-usage","title":"3. Advanced Usage","text":"<ul> <li>Cancellation of Requests: Use <code>CancelToken</code> to cancel requests.</li> <li>Concurrent Requests: Use <code>axios.all</code> and <code>axios.spread</code> for handling multiple requests simultaneously.</li> </ul> <pre><code>axios.all([request1, request2]).then(\n  axios.spread((response1, response2) =&gt; {\n    // Handle responses\n  })\n);\n</code></pre> <ul> <li>Error Handling: Create a centralized error handling system.</li> <li>Custom Transformations: Customize data transformation in requests/responses.</li> </ul>"},{"location":"frontend/package/axios/intro/#4-react-integration","title":"4. React Integration","text":"<ul> <li>Using Axios with Hooks: Create custom hooks for API calls.</li> </ul> <pre><code>import { useEffect, useState } from \"react\";\nconst useFetch = (url) =&gt; {\n  const [data, setData] = useState(null);\n  const [error, setError] = useState(null);\n\n  useEffect(() =&gt; {\n    axios\n      .get(url)\n      .then((response) =&gt; setData(response.data))\n      .catch((err) =&gt; setError(err));\n  }, [url]);\n\n  return { data, error };\n};\n</code></pre> <ul> <li>Context API for Global State: Manage API state using Context API.</li> <li>Error Boundaries: Implement error boundaries to catch errors in the API calls.</li> </ul>"},{"location":"frontend/package/axios/intro/#5-testing","title":"5. Testing","text":"<ul> <li>Mocking Axios Requests: Use libraries like axios-mock-adapter or jest for testing your components and API calls.</li> </ul>"},{"location":"frontend/package/axios/intro/#6-performance-optimization","title":"6. Performance Optimization","text":"<ul> <li>Debouncing Requests: Implement debouncing for search fields or high-frequency requests.</li> <li>Lazy Loading: Load data on-demand for better performance.</li> <li>Memoization: Use React's <code>useMemo</code> and <code>useCallback</code> to prevent unnecessary re-renders.</li> </ul>"},{"location":"frontend/package/axios/intro/#7-security-best-practices","title":"7. Security Best Practices","text":"<ul> <li>Securing API Keys: Use environment variables to store sensitive data.</li> <li>Rate Limiting: Implement mechanisms to handle rate limits from APIs.</li> </ul>"},{"location":"frontend/package/axios/intro/#8-monitoring-and-logging","title":"8. Monitoring and Logging","text":"<ul> <li>Log API Calls: Use logging tools to monitor API interactions.</li> <li>Analytics: Track user interactions and API usage for performance analysis.</li> </ul>"},{"location":"frontend/package/axios/intro/#9-real-world-projects","title":"9. Real-World Projects","text":"<ul> <li>Build projects that require complex API interactions (e.g., e-commerce apps, social media apps).</li> <li>Contribute to open-source projects or create your own to practice and showcase your skills.</li> </ul>"},{"location":"frontend/package/axios/intro/#10-continuous-learning","title":"10. Continuous Learning","text":"<ul> <li>Stay updated with the latest features and best practices.</li> <li>Engage with the developer community through forums, meetups, or conferences.</li> </ul>"},{"location":"frontend/package/axios/intro/#resources","title":"Resources","text":"<ul> <li>Documentation: Read the Axios documentation for in-depth understanding.</li> <li>Tutorials: Follow advanced tutorials on platforms like YouTube, Udemy, or blogs.</li> <li>GitHub: Explore repositories using Axios for practical examples.</li> </ul> <p>By mastering these concepts and continually practicing, you\u2019ll be well on your way to becoming a top-level developer with Axios in React!</p>"},{"location":"frontend/package/axios/sentry/","title":"Sentry","text":"<p>Error monitoring and analytics are crucial for maintaining the health of your applications and improving user experience. Here\u2019s how you can implement error monitoring and analytics in your React application using Axios:</p>"},{"location":"frontend/package/axios/sentry/#error-monitoring-with-sentry","title":"Error Monitoring with Sentry","text":"<p>Sentry is a popular tool for monitoring and fixing crashes in real-time. You can integrate it with Axios to catch and report errors.</p> <p>Step 1: Install Sentry</p> <p>First, install Sentry in your project:</p> <pre><code>npm install @sentry/react @sentry/tracing\n</code></pre> <p>Step 2: Initialize Sentry</p> <p>Initialize Sentry in your application, usually in your main entry file (e.g., <code>index.js</code> or <code>App.js</code>):</p> <pre><code>import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport * as Sentry from \"@sentry/react\";\nimport App from \"./App\";\n\nSentry.init({\n  dsn: \"YOUR_SENTRY_DSN\", // Replace with your DSN from Sentry\n  integrations: [\n    new Sentry.BrowserTracing({\n      tracingOrigins: [\"localhost\", \"https://yourapi.com\", /^\\//],\n    }),\n  ],\n  tracesSampleRate: 1.0, // Adjust this value in production\n});\n\nReactDOM.render(&lt;App /&gt;, document.getElementById(\"root\"));\n</code></pre> <p>Step 3: Capture Errors in Axios Requests</p> <p>You can set up a response interceptor in Axios to capture errors and send them to Sentry:</p> <pre><code>import axios from \"axios\";\nimport * as Sentry from \"@sentry/react\";\n\n// Create an Axios instance\nconst axiosInstance = axios.create({\n  baseURL: \"https://api.example.com\",\n});\n\n// Add a response interceptor\naxiosInstance.interceptors.response.use(\n  (response) =&gt; response,\n  (error) =&gt; {\n    // Capture the error with Sentry\n    Sentry.captureException(error);\n    return Promise.reject(error);\n  }\n);\n\nexport default axiosInstance;\n</code></pre> <p>Step 4: Use the Axios Instance</p> <p>Now, you can use this Axios instance throughout your application:</p> <pre><code>import React, { useEffect, useState } from \"react\";\nimport axiosInstance from \"./axiosInstance\";\n\nconst UserList = () =&gt; {\n  const [users, setUsers] = useState([]);\n  const [error, setError] = useState(null);\n\n  useEffect(() =&gt; {\n    axiosInstance\n      .get(\"/users\")\n      .then((response) =&gt; setUsers(response.data))\n      .catch((err) =&gt; {\n        setError(\"Failed to fetch users\");\n        console.error(err);\n      });\n  }, []);\n\n  if (error) return &lt;div&gt;{error}&lt;/div&gt;;\n\n  return (\n    &lt;ul&gt;\n      {users.map((user) =&gt; (\n        &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  );\n};\n\nexport default UserList;\n</code></pre>"},{"location":"frontend/package/axios/sentry/#analytics-with-google-analytics","title":"Analytics with Google Analytics","text":"<p>You can also track user interactions and API call performance using Google Analytics.</p> <p>Step 1: Install Google Analytics</p> <p>If you haven\u2019t already set up Google Analytics, you can do so by following the official documentation.</p> <p>Step 2: Track API Calls</p> <p>You can use Google Analytics to track when API calls are made and their outcomes. Here's an example of how to integrate it:</p> <pre><code>import React, { useEffect, useState } from \"react\";\nimport axiosInstance from \"./axiosInstance\";\nimport ReactGA from \"react-ga\";\n\n// Initialize Google Analytics\nReactGA.initialize(\"YOUR_GA_TRACKING_ID\");\n\nconst UserList = () =&gt; {\n  const [users, setUsers] = useState([]);\n  const [error, setError] = useState(null);\n\n  const trackAPICall = (action, label) =&gt; {\n    ReactGA.event({\n      category: \"API\",\n      action,\n      label,\n    });\n  };\n\n  useEffect(() =&gt; {\n    trackAPICall(\"Fetch Users\", \"Started\");\n\n    axiosInstance\n      .get(\"/users\")\n      .then((response) =&gt; {\n        setUsers(response.data);\n        trackAPICall(\"Fetch Users\", \"Successful\"); // Successful API call\n      })\n      .catch((err) =&gt; {\n        setError(\"Failed to fetch users\");\n        console.error(err);\n        trackAPICall(\"Fetch Users\", \"Failed\"); // Failed API call\n      });\n  }, []);\n\n  if (error) return &lt;div&gt;{error}&lt;/div&gt;;\n\n  return (\n    &lt;ul&gt;\n      {users.map((user) =&gt; (\n        &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  );\n};\n\nexport default UserList;\n</code></pre>"},{"location":"frontend/package/axios/sentry/#summary","title":"Summary","text":"<p>By integrating Sentry for error monitoring and Google Analytics for tracking API interactions, you can gain valuable insights into your application\u2019s performance and user experience. This not only helps in identifying and fixing issues but also provides data for making informed decisions about your application's direction.</p>"},{"location":"frontend/package/axios/topic/","title":"Topic","text":"<p>To achieve a deep mastery of Axios, consider diving into the following topics:</p>"},{"location":"frontend/package/axios/topic/#1-http-basics","title":"1. HTTP Basics","text":"<ul> <li>Understanding HTTP Protocol: Learn about request/response lifecycle, methods (GET, POST, etc.), and status codes.</li> <li>Headers and Content Types: Understand how to work with headers, including authorization and content negotiation.</li> </ul> Example <p>Example: Understand status codes</p> <pre><code>// Fetching user data\naxios.get('/api/users/1')\n    .then(response =&gt; {\n        console.log(response.status); // 200 for success\n    })\n    .catch(error =&gt; {\n        console.error(error.response.status); // e.g., 404 for not found\n    });\n</code></pre>"},{"location":"frontend/package/axios/topic/#2-axios-fundamentals","title":"2. Axios Fundamentals","text":"<ul> <li>Installation and Setup: Basic installation and setup of Axios in a React project.</li> <li>Basic Requests: Familiarize yourself with making GET, POST, PUT, and DELETE requests.</li> <li>Handling Responses: Learn how to process and handle successful responses and errors.</li> </ul> Example <p>Example: Making a POST request</p> <pre><code>const newUser = { name: 'John Doe', email: 'john@example.com' };\naxios.post('/api/users', newUser)\n    .then(response =&gt; {\n        console.log(response.data); // Handle the new user data\n    })\n    .catch(error =&gt; {\n        console.error(error);\n    });\n</code></pre>"},{"location":"frontend/package/axios/topic/#3-advanced-configuration","title":"3. Advanced Configuration","text":"<ul> <li>Creating Axios Instances: Set up custom instances with default configurations (base URL, headers).</li> <li>Interceptors: Implement request and response interceptors for logging, error handling, and authentication.</li> </ul> ExampleInterceptors <p>Example: Creating an Axios instance</p> <pre><code>const axiosInstance = axios.create({\n    baseURL: 'https://api.example.com',\n    timeout: 1000,\n    headers: { 'Authorization': 'Bearer YOUR_TOKEN' },\n});\n\naxiosInstance.get('/users')\n    .then(response =&gt; console.log(response.data));\n</code></pre> <p>Example: Adding a request interceptor</p> <pre><code>axios.interceptors.request.use(config =&gt; {\n    console.log('Request sent at:', new Date());\n    return config;\n});\n</code></pre>"},{"location":"frontend/package/axios/topic/#4-error-handling-strategies","title":"4. Error Handling Strategies","text":"<ul> <li>Centralized Error Handling: Develop a system for managing API errors across your application.</li> <li>Retry Logic: Implement strategies for retrying failed requests with exponential backoff.</li> </ul> Example <p>Example: Centralized error handling</p> <pre><code>const handleError = (error) =&gt; {\n    console.error('API error:', error);\n    // Notify the user or log the error\n    };\n\naxios.get('/api/users')\n    .catch(handleError);\n</code></pre>"},{"location":"frontend/package/axios/topic/#5-cancellation-and-throttling","title":"5. Cancellation and Throttling","text":"<ul> <li>CancelToken: Use CancelToken to abort requests and prevent memory leaks.</li> <li>Throttling/Debouncing: Optimize requests in high-frequency scenarios (like search inputs).</li> </ul> Example <p>Example: Using CancelToken</p> <pre><code>const CancelToken = axios.CancelToken;\nlet cancel;\n\naxios.get('/api/users', { cancelToken: new CancelToken(c =&gt; cancel = c) });\n// Cancel the request if needed\ncancel();\n</code></pre>"},{"location":"frontend/package/axios/topic/#6-concurrent-requests","title":"6. Concurrent Requests","text":"<ul> <li>Using <code>axios.all</code>: Make multiple concurrent requests and handle them using <code>axios.spread</code>.</li> <li>Managing Promise States: Understand how to handle and display loading states and errors for concurrent requests.</li> </ul> Example <p>Example: Making multiple requests</p> <pre><code>axios.all([\n    axios.get('/api/users'),\n    axios.get('/api/posts'),\n]).then(axios.spread((users, posts) =&gt; {\n    console.log('Users:', users.data);\n    console.log('Posts:', posts.data);\n}));\n</code></pre>"},{"location":"frontend/package/axios/topic/#7-custom-axios-functions","title":"7. Custom Axios Functions","text":"<ul> <li>Service Layer Design: Create a dedicated API service layer for managing Axios calls and endpoints.</li> <li>Utility Functions: Build custom functions for repetitive tasks (like handling token refresh).</li> </ul> Example <p>Example: Creating a service layer</p> <pre><code>const apiService = {\n    getUsers: () =&gt; axios.get('/api/users'),\n    createUser: (user) =&gt; axios.post('/api/users', user),\n};\n\napiService.getUsers().then(response =&gt; console.log(response.data));\n</code></pre>"},{"location":"frontend/package/axios/topic/#8-data-transformation","title":"8. Data Transformation","text":"<ul> <li>Transforming Requests and Responses: Customize how data is sent to and received from the server.</li> <li>Parsing and Normalizing Data: Learn how to structure and normalize API responses for better state management.</li> </ul> Example <p>Example: Transforming response data</p> <pre><code>axios.get('/api/users', {\n    transformResponse: [(data) =&gt; {\n        const jsonData = JSON.parse(data);\n        return jsonData.map(user =&gt; ({ ...user, fullName: `${user.firstName} ${user.lastName}` }));\n    }]\n}).then(response =&gt; console.log(response.data));\n</code></pre>"},{"location":"frontend/package/axios/topic/#9-integration-with-state-management","title":"9. Integration with State Management","text":"<ul> <li>Using Context API: Manage API data and state with React\u2019s Context API.</li> <li>Redux Integration: Implement Redux to handle complex state scenarios involving multiple API calls.</li> </ul> Example <p>Example: Using Context API</p> <pre><code>const UserContext = React.createContext();\n\nconst UserProvider = ({ children }) =&gt; {\n    const [users, setUsers] = useState([]);\n\n    useEffect(() =&gt; {\n        axios.get('/api/users').then(response =&gt; setUsers(response.data));\n    }, []);\n\n    return &lt;UserContext.Provider value={users}&gt;{children}&lt;/UserContext.Provider&gt;;\n};\n</code></pre>"},{"location":"frontend/package/axios/topic/#10-testing","title":"10. Testing","text":"<ul> <li>Unit Testing: Write tests for Axios calls using libraries like Jest and Mock Service Worker (MSW).</li> <li>Integration Testing: Test components that interact with Axios and ensure proper rendering and state management.</li> </ul> Example <p>Example: Mocking Axios with Jest</p> <pre><code>import axios from 'axios';\nimport { fetchUsers } from './apiService'; // Assume this uses axios\n\njest.mock('axios');\n\ntest('fetches users successfully', async () =&gt; {\n    const users = [{ id: 1, name: 'John Doe' }];\n    axios.get.mockResolvedValueOnce({ data: users });\n\n    const result = await fetchUsers();\n    expect(result).toEqual(users);\n});\n</code></pre>"},{"location":"frontend/package/axios/topic/#11-security-practices","title":"11. Security Practices","text":"<ul> <li>Securing API Calls: Understand how to manage tokens (like JWTs) and secure sensitive data.</li> <li>CORS: Learn about Cross-Origin Resource Sharing and how to handle related issues.</li> </ul> Example <p>Example: Securing API calls</p> <pre><code>const apiService = axios.create({\n    baseURL: 'https://api.example.com',\n});\n\napiService.interceptors.request.use(config =&gt; {\n    const token = localStorage.getItem('token'); // Retrieve token securely\n    if (token) {\n        config.headers['Authorization'] = `Bearer ${token}`;\n    }\n    return config;\n});\n</code></pre>"},{"location":"frontend/package/axios/topic/#12-performance-optimization","title":"12. Performance Optimization","text":"<ul> <li>Caching Responses: Implement caching strategies for API responses to improve performance.</li> <li>Pagination and Infinite Scrolling: Efficiently handle large datasets with pagination and loading more data on scroll.</li> </ul> Example <p>Example: Implementing caching</p> <pre><code>const cache = {};\n\nconst fetchUsers = async () =&gt; {\n    if (cache.users) return cache.users;\n\n    const response = await axios.get('/api/users');\n    cache.users = response.data; // Cache response\n    return response.data;\n};\n</code></pre>"},{"location":"frontend/package/axios/topic/#13-real-time-data-handling","title":"13. Real-time Data Handling","text":"<ul> <li>WebSockets vs. Axios: Explore using WebSockets for real-time updates in conjunction with Axios.</li> <li>Polling Techniques: Understand long polling and how to implement it when WebSockets aren't an option.</li> </ul> Example <p>Example: Using WebSockets with Axios</p> <pre><code>const socket = new WebSocket('ws://api.example.com/realtime');\n\nsocket.onmessage = (event) =&gt; {\n    const data = JSON.parse(event.data);\n    console.log('Real-time update:', data);\n};\n</code></pre>"},{"location":"frontend/package/axios/topic/#14-error-monitoring-and-analytics","title":"14. Error Monitoring and Analytics","text":"<ul> <li>Logging Requests: Use logging libraries to track API calls and responses.</li> <li>Monitoring Tools: Integrate tools like Sentry or LogRocket to monitor API performance and errors in production.</li> </ul> Example"},{"location":"frontend/package/axios/topic/#15-best-practices-and-design-patterns","title":"15. Best Practices and Design Patterns","text":"<ul> <li>Code Organization: Structure your API calls and components in a maintainable way.</li> <li>Design Patterns: Familiarize yourself with patterns like the Repository Pattern or Factory Pattern in the context of API calls.</li> </ul> Example <p>Example: Structuring your API layer</p> <pre><code>// api/userService.js\nexport const userService = {\n    getUsers: () =&gt; axios.get('/api/users'),\n    createUser: (user) =&gt; axios.post('/api/users', user),\n};\n\n// In a component\nimport { userService } from './api/userService';\n\nuserService.getUsers().then(response =&gt; console.log(response.data));\n</code></pre>"},{"location":"frontend/package/axios/topic/#resources","title":"Resources","text":"<ul> <li>Official Documentation: Regularly reference the Axios documentation.</li> <li>Online Courses: Consider advanced courses on platforms like Udemy or Pluralsight focusing on React and API integration.</li> <li>Books: Read books on advanced JavaScript and React to deepen your understanding of the underlying technologies.</li> </ul> <p>By systematically exploring these topics, you'll develop a comprehensive and deep understanding of Axios and its capabilities in building robust React applications. Happy learning!</p>"},{"location":"frontend/package/composition/imagegallery/","title":"Image Gallery","text":""},{"location":"frontend/package/composition/imagegallery/#overview","title":"Overview","text":"<p>To make your <code>Picture</code> component reusable and more maintainable in a larger codebase, you can decompose it into smaller, focused components. This approach enhances readability, encourages reuse, and simplifies testing. Here are some strategies for decomposition and organization:</p>"},{"location":"frontend/package/composition/imagegallery/#1-create-separate-components","title":"1. Create Separate Components","text":"<p>You can break down the <code>Picture</code> component into smaller components, such as:</p> <ul> <li>ImageGallery: A component that handles the rendering of the image gallery.</li> <li>ImagePreview: A component that manages the image preview functionality and its toolbar.</li> <li>LoadingSpinner: A component for loading states.</li> <li>ErrorMessage: A component for displaying error messages.</li> </ul>"},{"location":"frontend/package/composition/imagegallery/#2-example-structure","title":"2. Example Structure","text":"<p>Here\u2019s how you could structure your components:</p> <pre><code>src/\n  components/\n    ImageGallery/\n      ImageGallery.js\n      ImagePreview.js\n      LoadingSpinner.js\n      ErrorMessage.js\n  redux/\n    features/\n      gallery/\n        services.js\n</code></pre>"},{"location":"frontend/package/composition/imagegallery/#3-implementation","title":"3. Implementation","text":"ImageGallery.jsImagePreview.jsLoadingSpinner.jsErrorMessage.js <p>This component will fetch the images and manage the gallery state.</p> <pre><code>import React, { useEffect } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { getPhotosService } from \"../../../redux/features/gallery/services\";\nimport ImagePreview from \"./ImagePreview\";\nimport LoadingSpinner from \"./LoadingSpinner\";\nimport ErrorMessage from \"./ErrorMessage\";\n\nconst ImageGallery = () =&gt; {\n    const dispatch = useDispatch();\n    const { gallery, status, error } = useSelector((state) =&gt; state.gallery);\n\n    useEffect(() =&gt; {\n        const source = axios.CancelToken.source();\n        dispatch(getPhotosService(source.token));\n        return () =&gt; {\n            source.cancel();\n        };\n    }, [dispatch]);\n\n    if (status === \"loading\") {\n        return &lt;LoadingSpinner /&gt;;\n    }\n\n    if (error) {\n        return &lt;ErrorMessage message={error.message} /&gt;;\n    }\n\n    return (\n        &lt;&gt;\n        &lt;h1&gt;Picture Gallery&lt;/h1&gt;\n        &lt;ImagePreview gallery={gallery} /&gt;\n        &lt;/&gt;\n    );\n};\n\nexport default ImageGallery;\n</code></pre> <p>This component will handle the preview logic.</p> <pre><code>import React, { useState } from \"react\";\nimport { Image, Space } from \"antd\";\nimport {\n    LeftOutlined,\n    RightOutlined,\n    RotateLeftOutlined,\n    RotateRightOutlined,\n    ZoomInOutlined,\n    ZoomOutOutlined,\n    UndoOutlined,\n    SwapOutlined,\n} from \"@ant-design/icons\";\n\nconst ImagePreview = ({ gallery }) =&gt; {\n    const [current, setCurrent] = useState(0);\n\n    return (\n        &lt;Image.PreviewGroup\n            preview={{\n                toolbarRender: (_, { transform: { scale }, actions }) =&gt; (\n                &lt;Space size={12} className=\"toolbar-wrapper\"&gt;\n                    &lt;LeftOutlined onClick={() =&gt; actions.onActive(-1)} /&gt;\n                    &lt;RightOutlined onClick={() =&gt; actions.onActive(1)} /&gt;\n                    &lt;SwapOutlined rotate={90} onClick={actions.onFlipY} /&gt;\n                    &lt;SwapOutlined onClick={actions.onFlipX} /&gt;\n                    &lt;RotateLeftOutlined onClick={actions.onRotateLeft} /&gt;\n                    &lt;RotateRightOutlined onClick={actions.onRotateRight} /&gt;\n                    &lt;ZoomOutOutlined disabled={scale === 1} onClick={actions.onZoomOut} /&gt;\n                    &lt;ZoomInOutlined disabled={scale === 50} onClick={actions.onZoomIn} /&gt;\n                    &lt;UndoOutlined onClick={actions.onReset} /&gt;\n                &lt;/Space&gt;\n                ),\n                onChange: (index) =&gt; {\n                    setCurrent(index);\n                },\n            }}\n        &gt;\n            {gallery.map((item) =&gt; (\n                &lt;Image\n                    key={item.id}\n                    src={item.url}\n                    alt=\"Gallery\"\n                    height={200}\n                    width={200}\n                /&gt;\n            ))}\n        &lt;/Image.PreviewGroup&gt;\n    );\n};\n\nexport default ImagePreview;\n</code></pre> <p>A simple component to display a loading spinner.</p> <pre><code>import React from \"react\";\nimport { Skeleton } from \"antd\";\n\nconst LoadingSpinner = () =&gt; (\n    &lt;Skeleton active paragraph={{ rows: 4 }} /&gt;\n);\n\nexport default LoadingSpinner;\n</code></pre> <p>A component to display error messages.</p> <pre><code>import React from \"react\";\n\nconst ErrorMessage = ({ message }) =&gt; (\n    &lt;div style={{ color: \"red\" }}&gt;\n        Error loading images: {message}\n    &lt;/div&gt;\n);\n\nexport default ErrorMessage;\n</code></pre>"},{"location":"frontend/package/composition/imagegallery/#ant-image-css","title":"Ant Image CSS","text":"<pre><code>.toolbar-wrapper {\n  padding: 0px 24px;\n  color: #fff;\n  font-size: 20px;\n  background-color: rgba(0, 0, 0, 0.1);\n  border-radius: 100px;\n}\n\n.toolbar-wrapper .anticon {\n  padding: 12px;\n  cursor: pointer;\n}\n\n.toolbar-wrapper .anticon[disabled] {\n  cursor: not-allowed;\n  opacity: 0.3;\n}\n\n.toolbar-wrapper .anticon:hover {\n  opacity: 0.3;\n}\n</code></pre>"},{"location":"frontend/package/composition/imagegallery/#production","title":"Production","text":"<p>In production applications, it's essential to handle errors gracefully while maintaining a good user experience. Here are some best practices for displaying error messages:</p> TheoryExample ImplementationKey Points <p>1. User-Friendly Messages</p> <p>Instead of displaying technical error messages, provide a user-friendly message that informs users something went wrong without exposing sensitive information.</p> <p>2. Hide Technical Details</p> <p>Avoid showing stack traces or error codes to end users. Instead, use a generic message like \"Something went wrong. Please try again later.\"</p> <p>3. Logging</p> <p>Log the actual error details (without exposing them to the user) for debugging purposes. This can be done through a logging service or your application's backend.</p> <p>4. Fallback UI</p> <p>Consider providing a fallback UI, such as a retry button or an option to go back to the home page, to enhance user experience.</p> <p>5. Conditional Rendering</p> <p>You can conditionally render error messages based on the environment. For example, show detailed errors in development but more user-friendly messages in production.</p> <p>You could modify your <code>ErrorMessage</code> component to handle different environments like this:</p> <pre><code>import React from \"react\";\n\nconst ErrorMessage = ({ message }) =&gt; {\n    const isProduction = process.env.NODE_ENV === 'production';\n\n    return (\n        &lt;div style={{ color: \"red\" }}&gt;\n        {isProduction\n            ? \"Something went wrong. Please try again later.\"\n            : `Error loading images: ${message}`}\n        &lt;/div&gt;\n    );\n};\n\nexport default ErrorMessage;\n</code></pre> <ul> <li>User Experience: Focus on a smooth user experience by not alarming users with technical jargon.</li> <li>Environment Check: Use environment variables to differentiate between development and production.</li> <li>Fallback Options: Consider including retry options or guidance on what to do next.</li> </ul> <p>By following these guidelines, you ensure that error handling in your application is both effective and user-friendly, especially in production environments.</p> <p>Additional</p> ExampleExplained <pre><code>import React from \"react\";\n\nconst ErrorMessage = ({ message }) =&gt; (\n    &lt;div style={{ color: \"red\" }}&gt;\n        Error loading images: {message}\n    &lt;/div&gt;\n);\n\nexport default ErrorMessage;\n\n\n// or\n\nimport React from \"react\";\n\nconst ErrorMessage = ({ message }) =&gt; {\n    const isProduction = process.env.NODE_ENV === 'production';\n\n    return (\n        &lt;div style={{ color: \"red\" }}&gt;\n        {isProduction\n            ? \"Something went wrong. Please try again later.\"\n            : `Error loading images: ${message}`}\n        &lt;/div&gt;\n    );\n};\n\nexport default ErrorMessage;\n\n\nwhich is the standard practice and why?\n</code></pre> <p>The second implementation is the standard practice for error handling in production applications. Here\u2019s why:</p> <p>1. User Experience</p> <ul> <li>User-Friendly Messages: In the second implementation, the error message is simplified for end users. Instead of exposing potentially confusing technical details, it provides a clear, non-technical message: \"Something went wrong. Please try again later.\" This helps maintain a good user experience.</li> </ul> <p>2. Security</p> <ul> <li>Avoiding Information Leakage: Displaying detailed error messages (like in the first implementation) can inadvertently expose sensitive information about your application (e.g., internal structure, error codes) to users. This can be a security risk, especially if those details can be exploited.</li> </ul> <p>3. Environment-Specific Behavior</p> <ul> <li>Conditional Rendering: The second implementation checks the environment (process.env.NODE_ENV). This means you can provide detailed error messages during development (helpful for debugging) while showing a generic message in production, where users don't need technical details.</li> </ul> <p>4. Maintainability</p> <ul> <li>Easier Future Updates: If you decide to change how errors are handled in the future, having a single place where the environment check is made makes it easier to implement those changes without affecting user experience negatively.</li> </ul> <p>5. Consistent User Feedback</p> <ul> <li>Standardization: It sets a standard for how errors are presented across the application. This consistency helps users understand what to expect when an error occurs.</li> </ul> <p>Conclusion</p> <p>While the first implementation might be acceptable during development, the second implementation is preferred for production due to its focus on user experience, security, and maintainability. It's crucial to strike a balance between providing useful information to developers and protecting users from technical details that may confuse or concern them.</p>"},{"location":"frontend/package/composition/imagegallery/#download-image","title":"Download Image","text":"OfficialCustomize Error HandlingMethod <pre><code>const onDownload = () =&gt; {\n    const url = imageList[current];\n    const suffix = url.slice(url.lastIndexOf('.'));\n    const filename = Date.now() + suffix;\n    fetch(url)\n        .then((response) =&gt; response.blob())\n        .then((blob) =&gt; {\n            const blobUrl = URL.createObjectURL(new Blob([blob]));\n            const link = document.createElement('a');\n            link.href = blobUrl;\n            link.download = filename;\n            document.body.appendChild(link);\n            link.click();\n            URL.revokeObjectURL(blobUrl);\n            link.remove();\n        });\n};\n</code></pre> <pre><code>const onDownload = () =&gt; {\nconst url = gallery[current].url; // Get the URL of the current image\nconst filename = `image_${Date.now()}.png`; // Create a filename\n\nfetch(url)\n    .then((response) =&gt; {\n        if (!response.ok) {\n            throw new Error('Network response was not ok');\n        }\n        return response.blob(); // Convert the response to a Blob\n    })\n    .then((blob) =&gt; {\n        const blobUrl = URL.createObjectURL(blob); // Create a blob URL\n        const link = document.createElement(\"a\");\n        link.href = blobUrl; // Set the blob URL as the link href\n        link.download = filename; // Set the download attribute with the filename\n        document.body.appendChild(link);\n        link.click(); // Trigger the download\n        document.body.removeChild(link); // Clean up\n        URL.revokeObjectURL(blobUrl); // Release the blob URL\n    })\n    .catch((error) =&gt; {\n        console.error('Download error:', error); // Handle any errors\n    });\n};\n</code></pre> <p>Key Points</p> <ol> <li> <p>Blob Handling:</p> <p>By using <code>response.blob()</code>, you convert the fetched response into a Blob object, which allows for more flexible handling of binary data.</p> </li> <li> <p>Error Handling:</p> <p>It's good practice to check if the response is OK (status 200) before trying to convert it to a blob. The error handling in the <code>.catch</code> block will log any errors that occur during the fetch.</p> </li> <li> <p>Creating a Blob URL:</p> <p><code>URL.createObjectURL(blob)</code> creates a temporary URL for the Blob, which is then used as the <code>href</code> in the link element for downloading.</p> </li> <li> <p>Cleanup:</p> <p>After triggering the download, you should revoke the object URL with <code>URL.revokeObjectURL(blobUrl)</code> to free up resources.</p> </li> </ol> <pre><code>const onDownload = () =&gt; {\n    const url = gallery[current].url; // Get the URL of the current image\n    const filename = `image_${Date.now()}.png`; // Create a filename (you can change the extension if needed)\n\n    // Create a temporary link element\n    const link = document.createElement(\"a\");\n    link.href = url; // Set the URL for the download\n    link.download = filename; // Set the download attribute with the filename\n    document.body.appendChild(link);\n    link.click(); // Trigger the download\n    document.body.removeChild(link); // Clean up\n};\n</code></pre>"},{"location":"frontend/package/composition/imagegallery/#env","title":"Env","text":"<p>A <code>.env</code> file is used to define environment variables for your application, especially when using frameworks like React, Node.js, or any backend technology. This file is typically not committed to version control (e.g., Git) to keep sensitive information private.</p> ExampleExplanationNotes <p>Example of a <code>.env</code> File</p> <p>Here's a simple example of what a <code>.env</code> file might look like for a React application:</p> <pre><code># Environment configuration\nNODE_ENV=development\n\n# API configuration\nREACT_APP_API_URL=https://api.example.com\nREACT_APP_API_KEY=your_api_key_here\n\n# Feature flags\nREACT_APP_ENABLE_FEATURE_X=true\nREACT_APP_ENABLE_DEBUG_MODE=false\n</code></pre> <p>Explanation of Variables</p> <ol> <li> <p>NODE_ENV: This variable indicates the environment your application is running in. Common values are <code>development</code>, <code>production</code>, and <code>test</code>. In React, you can use <code>process.env.NODE_ENV</code> to access this variable.</p> </li> <li> <p>API Configuration:</p> <ul> <li><code>REACT_APP_API_URL</code>: The base URL for your API endpoints.</li> <li><code>REACT_APP_API_KEY</code>: An API key for authentication when making requests to your backend.</li> </ul> </li> <li> <p>Feature Flags:</p> <ul> <li>These variables allow you to toggle certain features on or off without changing the code. This is particularly useful for testing new features in production without impacting all users.</li> </ul> </li> </ol> <p>Important Notes</p> <ul> <li> <p>Prefixing: In a Create React App project, all environment variables that you want to access in your application must start with <code>REACT_APP_</code>. This is a security measure to prevent accidentally exposing sensitive environment variables.</p> </li> <li> <p>Avoid Committing: Make sure to add <code>.env</code> to your <code>.gitignore</code> file to avoid committing sensitive information to your version control system.</p> </li> <li> <p>Different Environments: You can create different <code>.env</code> files for different environments, such as <code>.env.development</code>, <code>.env.production</code>, and use a package like <code>dotenv</code> to manage them in a Node.js application.</p> </li> </ul> <p>Example of Adding to <code>.gitignore</code></p> <p>Your <code>.gitignore</code> file should include:</p> <pre><code># Environment variables\n.env\n</code></pre> <p>This setup helps ensure your sensitive configuration details are kept secure and not exposed in your source code.</p>"},{"location":"frontend/package/composition/imagegallery/#reference","title":"Reference","text":"<ul> <li>Antd Image</li> </ul>"},{"location":"frontend/package/composition/intro/","title":"Intro","text":"<p>dsfsdf</p>"},{"location":"frontend/package/lodash/debounce/","title":"debounce","text":"<p><code>npm install lodash</code></p> jsx<pre><code>import React, { useState, useEffect } from \"react\";\nimport { Select } from \"antd\";\nimport debounce from \"lodash/debounce\";\n\nconst { Option } = Select;\n\nconst DebouncedSelect = () =&gt; {\n  const [searchTerm, setSearchTerm] = useState(\"\");\n\n  const debouncedSearch = debounce((value) =&gt; {\n    // Your search logic here, e.g., making an API call\n    console.log(\"Searching for:\", value);\n  }, 300); // 300ms debounce delay\n\n  useEffect(() =&gt; {\n    debouncedSearch(searchTerm);\n  }, [searchTerm, debouncedSearch]);\n\n  const handleSearch = (value) =&gt; {\n    setSearchTerm(value);\n  };\n\n  return (\n    &lt;Select\n      showSearch\n      onSearch={handleSearch}\n      style={{ width: 200 }}\n      placeholder=\"Search...\"\n    &gt;\n      &lt;Option value=\"1\"&gt;Option 1&lt;/Option&gt;\n      &lt;Option value=\"2\"&gt;Option 2&lt;/Option&gt;\n      &lt;Option value=\"3\"&gt;Option 3&lt;/Option&gt;\n    &lt;/Select&gt;\n  );\n};\n\nexport default DebouncedSelect;\n</code></pre>"},{"location":"frontend/package/lodash/debounce/#debounce-with-hoc","title":"Debounce with Hoc","text":"<p>separate the debounce logic and the HOC into separate files for better organization</p> 1. Debounce utility file2. HOC file3. Component file debounce.js<pre><code>// debounce.js\nconst debounce = (func, delay) =&gt; {\n    let timeoutId;\n    return function (...args) {\n        clearTimeout(timeoutId);\n        timeoutId = setTimeout(() =&gt; func.apply(this, args), delay);\n    };\n};\n\nexport default debounce;\n</code></pre> withDebounce.js<pre><code>import React from 'react';\nimport debounce from './debounce';\n\nconst withDebounce = (WrappedComponent) =&gt; {\n    return class WithDebounce extends React.Component {\n        debouncedFunction = debounce((...args) =&gt; {\n            console.log('Debounced function called with args:', args);\n        }, 500); // 500ms debounce delay\n\n        render() {\n            return (\n                &lt;WrappedComponent\n                    {...this.props}\n                    onDebouncedAction={this.debouncedFunction}\n                /&gt;\n            );\n        }\n    };\n};\n\nexport default withDebounce;\n</code></pre> MyComponent.js<pre><code>import React from 'react';\nimport withDebounce from './withDebounce';\n\nconst MyComponent = ({ onDebouncedAction }) =&gt; {\n    const handleClick = () =&gt; {\n        onDebouncedAction('Click event');\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;button onClick={handleClick}&gt;Click me&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default withDebounce(MyComponent);\n</code></pre> <p>Now you can import and use the <code>MyComponent</code> in your main application file:</p> App.js<pre><code>import React from \"react\";\nimport MyComponent from \"./MyComponent\";\n\nconst App = () =&gt; {\n  return (\n    &lt;div&gt;\n      &lt;MyComponent /&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n</code></pre> <p>This structure helps maintain a clean separation of concerns, making each file focused on its specific responsibility. The debounce utility is isolated in its own file, and the HOC is defined separately, promoting code modularity and reusability.</p>"},{"location":"frontend/package/monitoring-and-logging/intro/","title":"Intro","text":""},{"location":"frontend/package/monitoring-and-logging/intro/#overview","title":"Overview","text":"<p>A logLevel is a configuration that determines the level of detail for logs in your application or development tools. It's primarily used to control what messages are output to the console or logs based on their severity or purpose.</p>"},{"location":"frontend/package/monitoring-and-logging/intro/#why-do-we-need-loglevel","title":"Why Do We Need logLevel?","text":"<ol> <li> <p>Filter Log Messages:</p> <p>Prevent irrelevant or verbose logs (like debug information) from cluttering the console in production while enabling detailed debugging in development.</p> </li> <li> <p>Improve Performance:</p> <p>Avoid unnecessary logging operations, which can be resource-intensive, especially in production environments.</p> </li> <li> <p>Enhance Debugging:</p> <p>Enable verbose logging (e.g., <code>debug</code>, <code>info</code>) during development to identify issues faster.</p> </li> <li> <p>Security:</p> <p>Prevent sensitive or unnecessary debug information from being exposed in production logs.</p> </li> </ol>"},{"location":"frontend/package/monitoring-and-logging/intro/#difference-between-logging-libraies-and-services","title":"Difference between Logging Libraies and Services","text":"<p>The key difference between logging libraries and logging services lies in their functionality, purpose, and scope:</p>"},{"location":"frontend/package/monitoring-and-logging/intro/#logging-libraries","title":"Logging Libraries","text":"<p>Purpose: Provide tools to generate, format, and manage logs within an application.</p> <p>Key Features:</p> <ol> <li>Log Levels: Allow categorization of logs (e.g., debug, info, warn, error).</li> <li>Custom Transports: Define where logs should be sent (e.g., files, console, external endpoints).</li> <li>Formatting Options: Enable custom formats like JSON, timestamps, or plain text.</li> <li>Performance Optimization: Efficiently handle logging to minimize application overhead.</li> </ol> <p>Examples:</p> <ul> <li>Winston: Flexible Node.js logging library with custom transport and formatting options.</li> <li>Pino: High-performance JSON logger for Node.js and browsers.</li> <li>Loglevel: Lightweight logging library for client-side JavaScript.</li> </ul> <p>When to Use:</p> <ul> <li>For local logging (e.g., debugging, saving logs to files).</li> <li>When logs don't need to be aggregated across systems.</li> <li>When you want complete control over how logs are managed.</li> </ul> <p>Limitations:</p> <ul> <li>Logs are often stored locally unless sent to an external endpoint.</li> <li>Limited support for analyzing, searching, or aggregating logs across multiple instances or applications.</li> </ul>"},{"location":"frontend/package/monitoring-and-logging/intro/#logging-services","title":"Logging Services","text":"<p>Purpose: Provide platforms for collecting, aggregating, analyzing, and monitoring logs from multiple applications, servers, and environments.</p> <p>Key Features:</p> <ol> <li>Centralized Log Aggregation: Collect logs from various sources into a single system.</li> <li>Real-Time Monitoring: View logs and system metrics in real-time.</li> <li>Search and Filtering: Quickly find relevant logs using powerful search tools.</li> <li>Visualization and Dashboards: Create charts and graphs for trends and metrics.</li> <li>Alerts and Notifications: Trigger alerts based on log patterns or errors.</li> <li>Integration: Connect with other systems like Slack, PagerDuty, or email for notifications.</li> </ol> <p>Examples:</p> <ul> <li>Sentry: Focused on error tracking and performance monitoring.</li> <li>Datadog: Comprehensive observability platform for logs, metrics, and traces.</li> <li>Elastic Stack (ELK): Open-source suite for log collection (Elasticsearch, Logstash, Kibana).</li> <li>Splunk: Enterprise-grade platform for log analysis and monitoring.</li> </ul> <p>When to Use:</p> <ul> <li>For distributed systems with multiple services and instances.</li> <li>When logs need to be analyzed, visualized, or correlated with metrics.</li> <li>To monitor production environments for performance and errors.</li> <li>For auditing and compliance, where centralized logging is required.</li> </ul> <p>Limitations:</p> <ul> <li>Usually incurs a cost, especially for large-scale applications.</li> <li>Relies on external infrastructure, which could be a concern for sensitive data.</li> </ul>"},{"location":"frontend/package/monitoring-and-logging/intro/#comparison-table","title":"Comparison Table","text":"Aspect Logging Libraries Logging Services Purpose Generate and manage logs locally. Aggregate, monitor, and analyze logs globally. Scope Single application or instance. Distributed systems, multiple instances, or apps. Real-Time Analysis Not available or limited. Fully supported with dashboards and alerts. Storage Logs are stored locally or as specified. Logs are stored and searchable in the cloud. Cost Free or open-source (no external cost). Often subscription-based or pay-as-you-go. Examples Winston, Pino, Loglevel, Bunyan. Sentry, Datadog, ELK Stack, Splunk."},{"location":"frontend/package/monitoring-and-logging/intro/#using-both-together","title":"Using Both Together","text":"<p>For production-grade applications, a common pattern is to use logging libraries for generating logs and sending them to logging services for centralized storage and monitoring. For example:</p> <ul> <li>Use Winston or Pino in your application to format logs and send them to an external endpoint.</li> <li>Forward logs to Sentry, Datadog, or ELK for aggregation, analysis, and alerting.</li> </ul>"},{"location":"frontend/package/monitoring-and-logging/intro/#example-setup","title":"Example Setup","text":"<p>???+ example \"Combine Winston with Sentry:**</p> <pre><code>1.  Install dependencies:\n\n    ```bash\n    pnpm add winston @sentry/node @sentry/winston\n    ```\n\n2.  Configure logger:\n\n    ```jsx\n    const { createLogger, format, transports } = require('winston');\n    const Sentry = require('@sentry/node');\n    const SentryTransport = require('@sentry/winston');\n\n    Sentry.init({ dsn: 'your-sentry-dsn-url' });\n\n    const logger = createLogger({\n        level: 'info',\n        format: format.json(),\n        transports: [\n            new transports.Console(),\n            new SentryTransport({ level: 'error' }),\n        ],\n    });\n\n    logger.info('This is an info log');\n    logger.error('This is an error log');\n    ```\n\nIn this setup:\n\n-   [Winston](#) manages log generation.\n-   [Sentry](#) collects and monitors logs in the cloud.\n\nBy combining libraries and services, you get the best of both worlds: local control with global monitoring.\n</code></pre>"},{"location":"frontend/package/monitoring-and-logging/intro/#question","title":"Question","text":"<p>In large web applications, relying solely on <code>console.log</code> is discouraged due to its limitations in scalability, manageability, and performance. Instead, dedicated logging libraries like Winston, Pino, Loglevel, or services like Sentry and Datadog are used.</p>"},{"location":"frontend/package/monitoring-and-logging/intro/#why-not-use-consolelog-in-large-applications","title":"Why Not Use <code>console.log</code> in Large Applications?","text":"<ol> <li> <p>No Log Levels:</p> <p><code>console.log</code> does not categorize messages by severity (e.g., debug, info, warn, error), making it harder to filter or prioritize logs.</p> </li> <li> <p>Cluttered Output:</p> <p>Logs from all sources are mixed in the browser or server console, making it difficult to trace issues effectively.</p> </li> <li> <p>Lack of Persistent Storage:</p> <p><code>console.log</code> output isn't saved across sessions or accessible for future debugging, limiting its usefulness in identifying production issues.</p> </li> <li> <p>Performance Overhead:</p> <p>Excessive logging can slow down applications, especially in production, as <code>console.log</code> isn't optimized for high-frequency use.</p> </li> <li> <p>Security Risks:</p> <p>Sensitive data accidentally logged with <code>console.log</code> can be exposed in the browser's developer tools.</p> </li> <li> <p>No Remote Monitoring:</p> <p><code>console.log</code> doesn\u2019t integrate with external systems to collect and monitor logs for real-time issue tracking.</p> </li> </ol>"},{"location":"frontend/package/monitoring-and-logging/intro/#what-do-large-applications-use-instead","title":"What Do Large Applications Use Instead?","text":"<ol> <li> <p>Logging Libraries for the Browser</p> <ul> <li>Loglevel: Lightweight and browser-friendly. Great for front-end applications.</li> <li>Pino: High performance and supports both browser and server environments.</li> </ul> </li> <li> <p>Logging Libraries for the Server</p> <ul> <li>Winston: Flexible and widely used in Node.js applications for custom transports and formats.</li> <li>Bunyan: Focused on structured JSON logs, ideal for server applications.</li> <li>Pino: Super-fast and supports JSON-based logs, making it popular in high-performance applications.</li> </ul> </li> <li> <p>Logging Services</p> <p>These provide advanced monitoring, error tracking, and integrations:</p> <ul> <li>Sentry: For error and performance monitoring.</li> <li>Datadog: Comprehensive log aggregation and application monitoring.</li> <li>Elastic Stack (ELK): Elasticsearch, Logstash, and Kibana for centralized logging and visualization.</li> </ul> </li> </ol>"},{"location":"frontend/package/monitoring-and-logging/intro/#conclusion","title":"Conclusion","text":"<ul> <li>Use <code>console.log</code> sparingly during development for quick debugging.</li> <li>Transition to a logging library for structured logging, log levels, and remote monitoring.</li> <li>In large-scale applications, integrate logging libraries with monitoring tools like <code>Sentry</code> or <code>Datadog</code> for production-grade observability.</li> </ul>"},{"location":"frontend/package/monitoring-and-logging/logging-libraries/","title":"Libraries","text":"<p>Logging libraries provide features and capabilities that go far beyond the simple console.log function. Here's a breakdown of how logging libraries differ from console.log and why they are crucial for large, scalable applications:</p>"},{"location":"frontend/package/monitoring-and-logging/logging-libraries/#key-differences","title":"Key Differences","text":"Feature/Capability <code>console.log</code> Logging Libraries Log Levels No log levels\u2014everything is logged equally. Categorizes logs (e.g., <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code>) for better filtering. Log Formatting Raw, unstructured messages. Custom formatting (JSON, timestamps, colors) for clarity and standardization. Log Filtering No built-in filtering; everything appears in the console. Allows filtering logs based on level, environment, or context. Output Destinations Outputs only to the console. Sends logs to multiple destinations: files, databases, remote APIs, etc. Persistence Logs disappear after the session ends (not saved). Logs can be stored in files, databases, or sent to monitoring services. Performance Impact Heavy usage can slow down applications, especially in production. Optimized for minimal impact on performance (e.g., async logging). Log Rotation Not available. Manages log file size by rotating logs automatically to prevent overflow. Correlation IDs No built-in support for tracing specific requests. Supports request tracking across services for distributed systems. Security May inadvertently expose sensitive data in logs. Provides tools to mask or redact sensitive information. Monitoring Integration Requires manual effort to integrate with monitoring services. Direct integration with tools like Sentry, Datadog, and Elasticsearch. Error Tracking Doesn't track error context or metadata automatically. Captures additional context (stack traces, metadata) for easier debugging."},{"location":"frontend/package/monitoring-and-logging/logging-libraries/#what-logging-libraries-do-differently","title":"What Logging Libraries Do Differently","text":"<ol> <li> <p>Structured Logging:</p> <p>Logging libraries output logs in structured formats like JSON, making them machine-readable and searchable.</p> <pre><code>console.log(\"User logged in\");\n// VS\nlogger.info({\n  event: \"User logged in\",\n  userId: 123,\n  timestamp: new Date(),\n});\n</code></pre> </li> <li> <p>Custom Log Levels:</p> <p>Libraries let you define and use log levels (e.g., <code>debug</code>, <code>warn</code>), allowing you to display only what\u2019s relevant.</p> <pre><code>logger.debug(\"This is a debug message\"); // Visible only in development\nlogger.error(\"Critical error occurred!\"); // Always visible\n</code></pre> </li> <li> <p>Centralized Log Management:</p> <p>Logs can be sent to files, remote servers, or log aggregation tools for centralized monitoring and analysis.</p> <pre><code>const logger = createLogger({\n  transports: [\n    new transports.Console(),\n    new transports.File({ filename: \"app.log\" }),\n  ],\n});\n</code></pre> </li> <li> <p>Error Tracking with Context:</p> <p>Libraries often capture additional details about errors, such as stack traces, request IDs, or user context.</p> </li> <li> <p>Remote Log Shipping:</p> <p>Libraries can forward logs to tools like Sentry or Datadog for real-time monitoring and alerting.</p> </li> <li> <p>Log Rotation and Retention:</p> <p>Automatically rotates log files to prevent storage overflow and supports retention policies.</p> </li> <li> <p>Environment-Specific Configurations:</p> <p>Adjust log levels or formats based on the environment (e.g., <code>debug</code> in development, <code>error</code> in production).</p> </li> </ol>"},{"location":"frontend/package/monitoring-and-logging/logging-libraries/#example-scenarios-where-libraries-outperform-consolelog","title":"Example Scenarios Where Libraries Outperform <code>console.log</code>","text":"<ol> <li> <p>Production Debugging:</p> <p>When an error occurs, logs include the exact timestamp, stack trace, and user session details. <code>console.log</code> doesn\u2019t provide this level of detail.</p> <pre><code>logger.error(\"Database connection failed\", { host: dbHost, user: dbUser });\n</code></pre> </li> <li> <p>Scalable Logging:</p> <p>A logging library can send logs from multiple services to a central location, making it easier to troubleshoot across distributed systems.</p> </li> <li> <p>Filtering Logs:</p> <p>You can configure a logger to display only warnings and errors in production, avoiding noisy debug messages.</p> </li> <li> <p>Integration with Monitoring Tools:</p> <p>Libraries can integrate directly with services like Sentry to alert developers about errors, whereas <code>console.log</code> cannot.</p> </li> </ol>"},{"location":"frontend/package/monitoring-and-logging/logging-libraries/#when-to-use-logging-libraries-instead-of-consolelog","title":"When to Use Logging Libraries Instead of console.log","text":"<ul> <li> <p>In Development:</p> <p>Use <code>console.log</code> for quick, temporary debugging. Replace it with a library for better control and context.</p> </li> <li> <p>In Production:</p> <p>Always use a logging library to ensure structured, persistent, and secure logs, with the ability to filter and manage log data effectively.</p> </li> </ul>"},{"location":"frontend/package/monitoring-and-logging/logging-libraries/#conclusion","title":"Conclusion","text":"<p>While <code>console.log</code> is simple and useful for local debugging, logging libraries are designed for scalable, maintainable, and secure logging in large applications. They provide features that are essential for identifying, tracing, and resolving issues in production environments.</p> <p>For a frontend React application using Vite, you need a logging library that is lightweight, browser-friendly, and easy to integrate. Here are some of the best logging libraries to consider:</p>"},{"location":"frontend/package/monitoring-and-logging/logging-libraries/#comparison-of-libraries","title":"Comparison of Libraries","text":"Library Best For Lightweight Log Levels Browser-Friendly Integration with Services Free/Open Source Loglevel Basic logging in React applications \u2705 \u2705 \u2705 \u274c \u2705 Pino High-performance JSON logging \u2705 \u2705 \u2705 \u2705 \u2705 Debug Scoped debugging logs \u2705 \u274c \u2705 \u274c \u2705 LogRocket Advanced monitoring with replay \u274c \u2705 \u2705 \u2705 \u274c Sentry Error tracking and performance logs \u274c \u2705 \u2705 \u2705 \u274c (Free tier)"},{"location":"frontend/package/monitoring-and-logging/logging-libraries/#recommendations","title":"Recommendations","text":"<ul> <li>For simple logging: Loglevel or Debug.</li> <li>For performance and structured logs: Pino.</li> <li>For session tracking and monitoring: LogRocket.</li> <li>For error monitoring and tracing: Sentry.</li> </ul> <p>In a production-grade React application, you can also combine libraries (e.g., use <code>Pino</code> for structured logs and send errors to <code>Sentry</code>).</p>"},{"location":"frontend/package/monitoring-and-logging/logging-libraries/#reference","title":"Reference","text":"<ul> <li>react-logger-lib</li> <li>@dodobrands/react-logger</li> <li>Logging for your frontend apps </li> <li>React Error Handling and Logging Best Practices</li> <li>10 React Logging Best Practices</li> </ul>"},{"location":"frontend/package/monitoring-and-logging/pino/example/","title":"Example","text":""},{"location":"frontend/package/monitoring-and-logging/pino/example/#overview","title":"Overview","text":"<p>To gracefully handle failures in log transmission, you need to implement a robust mechanism that prevents your application from entering infinite loops or encountering crashes due to repeated log transmission failures. Here\u2019s how you can do it:</p> Installation<pre><code>pnpm add pino pino-pretty\n</code></pre> <p>1. Use a Retry Mechanism with Limits</p> <p>If a log fails to transmit, retry the transmission but limit the number of retries to avoid overloading your system.</p> <pre><code>// src/utils/logger.js\nimport pino from \"pino\";\n\nconst sendLogToAPI = async (logObject, retryCount = 0) =&gt; {\n  const MAX_RETRIES = 3;\n  try {\n    await fetch(\"/api/logs\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(logObject),\n    });\n  } catch (error) {\n    console.error(\"Log transmission failed:\", error);\n\n    if (retryCount &lt; MAX_RETRIES) {\n      console.warn(`Retrying (${retryCount + 1}/${MAX_RETRIES})...`);\n      setTimeout(() =&gt; sendLogToAPI(logObject, retryCount + 1), 1000); // Retry after 1 second\n    } else {\n      console.error(\"Max retries reached. Log will be dropped:\", logObject);\n    }\n  }\n};\n\nconst logger = pino({\n  browser: {\n    transmit: {\n      send: (level, logEvent) =&gt; {\n        const logObject = {\n          level,\n          ...logEvent,\n          timestamp: new Date().toISOString(),\n        };\n        sendLogToAPI(logObject);\n      },\n    },\n  },\n});\n\nexport default logger;\n</code></pre> <p>2. Queue Failed Logs for Later Transmission</p> <p>If the log transmission fails, queue the log and attempt to send it again after a set interval.</p> <pre><code>let logQueue = [];\nlet isSending = false;\n\nconst processLogQueue = async () =&gt; {\n  if (isSending || logQueue.length === 0) return;\n\n  isSending = true;\n  const log = logQueue.shift(); // Get the first log in the queue\n\n  try {\n    await fetch(\"/api/logs\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(log),\n    });\n  } catch (error) {\n    console.error(\"Failed to send log, re-queuing:\", log);\n    logQueue.push(log); // Re-queue the log for another attempt\n  } finally {\n    isSending = false;\n  }\n\n  // Process the next log after a delay\n  setTimeout(processLogQueue, 1000);\n};\n\nconst queueLogForTransmission = (logObject) =&gt; {\n  logQueue.push(logObject);\n  processLogQueue();\n};\n\nconst logger = pino({\n  browser: {\n    transmit: {\n      send: (level, logEvent) =&gt; {\n        const logObject = {\n          level,\n          ...logEvent,\n          timestamp: new Date().toISOString(),\n        };\n        queueLogForTransmission(logObject);\n      },\n    },\n  },\n});\n\nexport default logger;\n</code></pre> <p>3. Graceful Fallback for Network Errors</p> <p>Detect network unavailability (e.g., navigator.onLine in the browser) and handle log transmission accordingly.</p> <pre><code>const sendLogToAPI = async (logObject) =&gt; {\n  if (!navigator.onLine) {\n    console.warn(\"Offline: Log will be queued:\", logObject);\n    logQueue.push(logObject);\n    return;\n  }\n\n  try {\n    await fetch(\"/api/logs\", {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify(logObject),\n    });\n  } catch (error) {\n    console.error(\"Failed to send log, queuing for retry:\", error);\n    logQueue.push(logObject); // Queue the log for retry\n  }\n};\n</code></pre> <p>4. Prevent Infinite Loops</p> <p>Ensure that the logger itself does not log errors caused by its own failure to prevent recursion.</p> <pre><code>let isLoggerError = false;\n\nconst sendLogToAPI = async (logObject) =&gt; {\n  if (isLoggerError) return; // Prevent recursive logging of logger errors\n\n  try {\n    await fetch(\"/api/logs\", {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify(logObject),\n    });\n  } catch (error) {\n    isLoggerError = true; // Flag to prevent recursion\n    console.error(\"Logger Error: Could not send log\", error);\n    isLoggerError = false;\n  }\n};\n</code></pre> <p>5. Handle Large Log Volume</p> <p>Implement rate limiting or batching to control the frequency of log transmissions and prevent overloading the server.</p> Batch Logs<pre><code>let logBatch = [];\nconst MAX_BATCH_SIZE = 10;\n\nconst sendBatchToAPI = async () =&gt; {\n  if (logBatch.length === 0) return;\n\n  try {\n    await fetch(\"/api/logs\", {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify(logBatch),\n    });\n    logBatch = []; // Clear the batch on success\n  } catch (error) {\n    console.error(\"Failed to send log batch, retrying...\", error);\n  }\n};\n\nconst logger = pino({\n  browser: {\n    transmit: {\n      send: (level, logEvent) =&gt; {\n        const logObject = {\n          level,\n          ...logEvent,\n          timestamp: new Date().toISOString(),\n        };\n\n        logBatch.push(logObject);\n\n        if (logBatch.length &gt;= MAX_BATCH_SIZE) {\n          sendBatchToAPI();\n        }\n      },\n    },\n  },\n});\n\nsetInterval(sendBatchToAPI, 5000); // Send logs every 5 seconds\n</code></pre>"},{"location":"frontend/package/monitoring-and-logging/pino/example/#best-practices-for-error-handling-in-log-transmission","title":"Best Practices for Error Handling in Log Transmission","text":"<ol> <li>Retry with Limits: Use retries but limit the maximum attempts.</li> <li>Queue and Process Logs: Ensure failed logs are not lost and retry them later.</li> <li>Handle Offline Scenarios: Use <code>navigator.onLine</code> to detect and handle offline states.</li> <li>Avoid Recursive Logging: Prevent the logger from logging errors caused by itself.</li> <li>Use Batch Transmission: Reduce the frequency of API calls by batching logs.</li> <li>Log Gracefully in Development Only: Avoid overloading logs in production to maintain performance.</li> </ol> <p>These practices ensure robust log transmission while avoiding infinite loops or crashes.</p>"},{"location":"frontend/package/monitoring-and-logging/pino/example/#final-implementation","title":"Final Implementation","text":"<pre><code>// src/utils/logger.js\nimport pino from \"pino\";\n\nlet logQueue = [];\nlet isSending = false;\nconst MAX_BATCH_SIZE = 10;\nconst MAX_RETRIES = 3;\nconst RETRY_DELAY = 1000; // 1 second\nconst BATCH_INTERVAL = 5000; // 5 seconds\n\n// Send a batch of logs to the API\nconst sendBatchToAPI = async () =&gt; {\n  if (isSending || logQueue.length === 0) return;\n\n  isSending = true;\n  const batch = logQueue.splice(0, MAX_BATCH_SIZE);\n\n  try {\n    await fetch(\"/api/logs\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(batch),\n    });\n  } catch (error) {\n    console.error(\"Failed to send log batch, re-queuing...\", error);\n    logQueue = [...batch, ...logQueue]; // Re-queue the failed logs\n  } finally {\n    isSending = false;\n  }\n};\n\n// Periodically send batched logs\nsetInterval(sendBatchToAPI, BATCH_INTERVAL);\n\n// Enqueue a log for transmission\nconst enqueueLog = (logObject) =&gt; {\n  logQueue.push(logObject);\n  if (logQueue.length &gt;= MAX_BATCH_SIZE) {\n    sendBatchToAPI(); // Trigger batch sending if max size is reached\n  }\n};\n\n// Log function with retry mechanism\nconst sendLogWithRetry = async (logObject, retryCount = 0) =&gt; {\n  if (!navigator.onLine) {\n    console.warn(\"Offline: Log queued for later transmission:\", logObject);\n    enqueueLog(logObject);\n    return;\n  }\n\n  try {\n    await fetch(\"/api/logs\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify([logObject]), // Send as a single log\n    });\n  } catch (error) {\n    console.error(\"Log transmission failed:\", error);\n\n    if (retryCount &lt; MAX_RETRIES) {\n      setTimeout(\n        () =&gt; sendLogWithRetry(logObject, retryCount + 1),\n        RETRY_DELAY\n      );\n    } else {\n      console.error(\"Max retries reached. Log will be queued:\", logObject);\n      enqueueLog(logObject); // Queue the log if retries fail\n    }\n  }\n};\n\n// Create the Pino logger\nconst logger = pino({\n  browser: {\n    transmit: {\n      send: (level, logEvent) =&gt; {\n        const logObject = {\n          level,\n          msg: logEvent[0], // Main log message\n          context: logEvent[1] || {}, // Additional context if provided\n          timestamp: new Date().toISOString(),\n        };\n\n        sendLogWithRetry(logObject); // Use retry-enabled log sender\n      },\n    },\n    asObject: true, // Keep logs readable in the browser console\n  },\n  level: import.meta.env.VITE_LOG_LEVEL || \"info\", // Set log level from environment\n});\n\nexport default logger;\n</code></pre>"},{"location":"frontend/package/monitoring-and-logging/pino/example/#how-to-use-the-logger","title":"How to Use the Logger","text":"<p>1. Import the logger wherever you need it:</p> <pre><code>import logger from \"./utils/logger\";\n</code></pre> <p>2. Use the logger to record logs:</p> <pre><code>logger.info(\"User clicked on button\", { userId: 123, action: \"click\" });\nlogger.error(\"Error occurred while fetching data\", { errorCode: 500 });\nlogger.warn(\"Potential issue detected\", { module: \"auth\" });\n</code></pre> <p>3. Logs will:</p> <ul> <li>Be sent immediately to the API.</li> <li>Be retried up to 3 times if transmission fails.</li> <li>Be queued if offline and sent when back online or in batches every 5 seconds.</li> </ul>"},{"location":"frontend/package/monitoring-and-logging/pino/intro/","title":"Intro","text":""},{"location":"frontend/package/monitoring-and-logging/pino/intro/#overview","title":"Overview","text":"<p>Pino is a fast and structured logging library, and while it's primarily designed for Node.js, it has a browser-compatible version called <code>pino</code> or <code>pino-browser</code>, which works well in React applications using Vite.</p> Installation<pre><code>pnpm add pino pino-pretty\n</code></pre> Example <code>.env</code>for Log Levels <p>Control the verbosity of logs using an environment variable:</p> <pre><code># .env\nVITE_LOG_LEVEL=info\n</code></pre> <ul> <li>debug: Print everything, useful for development.</li> <li>info: Print standard application flow logs.</li> <li>warn: Print only warnings and errors.</li> <li>error: Print only errors.</li> </ul>"},{"location":"frontend/package/monitoring-and-logging/pino/intro/#1-setup-project-wide-logging","title":"1. Setup Project-Wide Logging","text":"<p>Create a Centralized Logger</p> <p>Create a <code>logger.js</code> file in a shared utilities folder (e.g., <code>src/utils</code>).</p> <pre><code>// src/utils/logger.js\nimport pino from \"pino\";\n\nconst isDev = import.meta.env.MODE === \"development\";\n\nconst logger = pino({\n  level: import.meta.env.VITE_LOG_LEVEL || \"info\",\n  browser: {\n    asObject: true, // Makes logs readable in the browser console\n  },\n  transport: isDev\n    ? {\n        target: \"pino-pretty\",\n        options: { colorize: true }, // Pretty logs in development\n      }\n    : undefined,\n});\n\nexport default logger;\n</code></pre> <p>Configure Environment-Specific Log Levels</p> <p>Use <code>.env</code> files for different environments:</p> <pre><code># .env.development\nVITE_LOG_LEVEL=debug\n\n# .env.production\nVITE_LOG_LEVEL=error\n</code></pre>"},{"location":"frontend/package/monitoring-and-logging/pino/intro/#2-integrate-logger-across-the-application","title":"2. Integrate Logger Across the Application","text":"<p>Use in React Components</p> <p>Import the logger and use it for logging user interactions, API calls, and errors.</p> <pre><code>// src/features/user/UserProfile.jsx\nimport React, { useEffect } from \"react\";\nimport logger from \"../../utils/logger\";\n\nfunction UserProfile({ userId }) {\n  useEffect(() =&gt; {\n    logger.info(`Fetching data for user ID: ${userId}`);\n    fetch(`/api/users/${userId}`)\n      .then((response) =&gt; response.json())\n      .then((data) =&gt; logger.debug(\"User data:\", data))\n      .catch((error) =&gt; logger.error(\"Error fetching user data:\", error));\n  }, [userId]);\n\n  return &lt;div&gt;User Profile for {userId}&lt;/div&gt;;\n}\n\nexport default UserProfile;\n</code></pre> <p>Use in Redux or State Management</p> <p>Integrate logging for debugging Redux actions or state changes.</p> <pre><code>// src/store/middleware/loggerMiddleware.js\nimport logger from \"../../utils/logger\";\n\nconst loggerMiddleware = (store) =&gt; (next) =&gt; (action) =&gt; {\n  logger.debug(\"Dispatching action:\", action);\n  const result = next(action);\n  logger.debug(\"New state:\", store.getState());\n  return result;\n};\n\nexport default loggerMiddleware;\n</code></pre> <p>Add the middleware to your Redux store:</p> <pre><code>import { configureStore } from \"@reduxjs/toolkit\";\nimport loggerMiddleware from \"./middleware/loggerMiddleware\";\nimport rootReducer from \"./reducers\";\n\nconst store = configureStore({\n  reducer: rootReducer,\n  middleware: (getDefaultMiddleware) =&gt;\n    getDefaultMiddleware().concat(loggerMiddleware),\n});\n\nexport default store;\n</code></pre>"},{"location":"frontend/package/monitoring-and-logging/pino/intro/#3-centralize-error-logging","title":"3. Centralize Error Logging","text":"<p>Use Error Boundaries</p> Example <p>Create an error boundary to catch React rendering errors and log them.</p> ClassFunction <pre><code>// src/components/ErrorBoundary.jsx\nimport React from \"react\";\nimport logger from \"../utils/logger\";\n\nclass ErrorBoundary extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = { hasError: false };\n    }\n\n    static getDerivedStateFromError(error) {\n        return { hasError: true };\n    }\n\n    componentDidCatch(error, info) {\n        logger.error(\"React error:\", { error, info });\n    }\n\n    render() {\n        if (this.state.hasError) {\n        return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;\n        }\n\n        return this.props.children;\n    }\n}\n\nexport default ErrorBoundary;\n</code></pre> <p>Wrap your app with the <code>ErrorBoundary</code> in the root component:</p> <pre><code>import ErrorBoundary from './components/ErrorBoundary';\n\nfunction App() {\n    return (\n        &lt;ErrorBoundary&gt;\n            &lt;YourAppRoutes /&gt;\n        &lt;/ErrorBoundary&gt;\n    );\n}\n\nexport default App;\n</code></pre>"},{"location":"frontend/package/monitoring-and-logging/pino/intro/#4-monitor-api-calls","title":"4. Monitor API Calls","text":"<p>Create a wrapper for Axios (or any HTTP client) to log API requests and responses.</p> <pre><code>// src/utils/http.js\nimport axios from \"axios\";\nimport logger from \"./logger\";\n\nconst http = axios.create({\n  baseURL: \"/api\",\n});\n\nhttp.interceptors.request.use((config) =&gt; {\n  logger.info(\"API Request:\", config);\n  return config;\n});\n\nhttp.interceptors.response.use(\n  (response) =&gt; {\n    logger.debug(\"API Response:\", response);\n    return response;\n  },\n  (error) =&gt; {\n    logger.error(\"API Error:\", error);\n    return Promise.reject(error);\n  }\n);\n\nexport default http;\n</code></pre> <p>Use this instance throughout your app:</p> <pre><code>import http from \"../../utils/http\";\n\nhttp.get(\"/users\").then((response) =&gt; {\n  console.log(response.data);\n});\n</code></pre>"},{"location":"frontend/package/monitoring-and-logging/pino/intro/#5-add-log-grouping-for-better-debugging","title":"5. Add Log Grouping for Better Debugging","text":"<p>Use <code>logger.group()</code> and <code>logger.groupEnd()</code> for logically related logs.</p> <pre><code>logger.group(\"User Interaction\");\nlogger.info(\"Button clicked\");\nlogger.debug(\"Current user state:\", userState);\nlogger.groupEnd();\n</code></pre>"},{"location":"frontend/package/monitoring-and-logging/pino/intro/#6-extend-logging-to-monitoring-services","title":"6. Extend Logging to Monitoring Services","text":"<p>For production-ready logging, extend Pino with services like Sentry or LogRocket.</p> <p>Example: Sentry Integration</p> Install Sentry:<pre><code>pnpm add @sentry/react @sentry/browser\n</code></pre> Initialize it:<pre><code>// src/utils/logger.js\nimport * as Sentry from \"@sentry/react\";\nimport pino from \"pino\";\n\nSentry.init({\n  dsn: \"your-sentry-dsn\",\n  tracesSampleRate: 1.0,\n});\n\nconst logger = pino({\n  level: import.meta.env.VITE_LOG_LEVEL || \"info\",\n  browser: { asObject: true },\n});\n\nexport const captureException = (error, context) =&gt; {\n  Sentry.captureException(error, { extra: context });\n  logger.error(\"Captured exception:\", error, context);\n};\n\nexport default logger;\n</code></pre>"},{"location":"frontend/package/monitoring-and-logging/pino/intro/#7-organize-logs-by-feature","title":"7. Organize Logs by Feature","text":"<p>Organize logs by feature or module by creating feature-specific logger instances:</p> <pre><code>// src/features/user/logger.js\nimport logger from \"../../utils/logger\";\n\nconst userLogger = logger.child({ module: \"UserFeature\" });\n\nexport default userLogger;\n</code></pre> <p>Use it in user-specific components or services:</p> <pre><code>import userLogger from \"./logger\";\n\nuserLogger.info(\"User module initialized\");\n</code></pre>"},{"location":"frontend/package/monitoring-and-logging/pino/intro/#benefits-of-using-pino-in-large-applications","title":"Benefits of Using Pino in Large Applications","text":"<ol> <li>Scalability: Structured, JSON-based logging works well in distributed systems.</li> <li>Environment-Specific Configurations: Log levels and outputs can be dynamically adjusted.</li> <li>Error Tracking: Easy integration with tools like Sentry or LogRocket for advanced monitoring.</li> <li>Performance: Lightweight and highly optimized for logging large volumes of data.</li> </ol> <p>This setup ensures reliable and maintainable logging for your large React + Vite application.</p>"},{"location":"frontend/package/monitoring-and-logging/pino/methods/","title":"Methods","text":""},{"location":"frontend/package/monitoring-and-logging/pino/methods/#overview","title":"Overview","text":"<p>Pino's officially supported logging methods correspond to the standard log levels. These methods allow you to log messages with varying levels of severity, which can be filtered or processed depending on the log level configuration.</p>"},{"location":"frontend/package/monitoring-and-logging/pino/methods/#officially-supported-methods-in-pino","title":"Officially Supported Methods in Pino","text":"Method Log Level Description <code>trace</code> 10 For very fine-grained, low-level, and verbose debugging information. <code>debug</code> 20 For debugging information useful during development. <code>info</code> 30 For general informational messages about application behavior or events. <code>warn</code> 40 For warnings about potentially harmful situations or recoverable errors. <code>error</code> 50 For errors that occur during runtime, typically those that require investigation. <code>fatal</code> 60 For critical errors that cause the application to terminate or become unusable."},{"location":"frontend/package/monitoring-and-logging/pino/methods/#key-notes","title":"Key Notes:","text":"<ol> <li> <p>Hierarchy of Log Levels:</p> <ul> <li>Logs with a level lower than the configured <code>level</code> will be ignored. For example, if you set the log level to <code>warn</code>, only <code>warn</code>, <code>error</code>, and <code>fatal</code> logs will appear.</li> </ul> </li> <li> <p>Log Level in Production:</p> <ul> <li>Use <code>error</code> or <code>fatal</code> for production environments to reduce log verbosity and focus on critical issues.</li> </ul> </li> <li> <p>Structured Logging:</p> <ul> <li>Each method can accept a message string and/or a structured object:</li> </ul> <pre><code>logger.info(\"Server started\");\nlogger.error({\n  error: \"Database connection failed\",\n  timestamp: new Date(),\n});\n</code></pre> </li> </ol>"},{"location":"frontend/package/monitoring-and-logging/pino/methods/#unsupported-methods","title":"Unsupported Methods","text":"<ul> <li>Pino does not support methods like <code>.err</code> or <code>.log</code>. These are often mistakenly used, leading to errors like <code>TypeError: (intermediate value).err is not a function</code>.</li> </ul> <p>If you need to log something with custom behavior, use a valid log method (<code>info</code>, <code>error</code>, etc.) and pass the relevant structured data as part of the log payload.</p>"},{"location":"frontend/package/monitoring-and-logging/pino/methods/#best-practice","title":"Best Practice","text":"<ul> <li>Use <code>trace</code> and <code>debug</code> for development environments.</li> <li>Use <code>warn</code>, <code>error</code>, and <code>fatal</code> for production environments.</li> <li>Always prefer structured logging by passing objects instead of plain strings for better log parsing and analysis.</li> </ul>"},{"location":"frontend/package/monitoring-and-logging/pino/notes/","title":"Notes","text":""},{"location":"frontend/package/monitoring-and-logging/pino/notes/#notes","title":"Notes","text":"<p><code>name</code> &amp; <code>msg</code> is not same because:</p> <ol> <li> <p><code>logger.info({msg: \"test\", testObj });</code></p> <ul> <li>The object passed here explicitly sets a key called <code>msg</code> for the log message, along with another key <code>testObj</code>.</li> <li>The <code>msg</code> key is recognized by Pino (depending on configuration) as the primary message field in the log entry.</li> <li>Example Output:</li> </ul> <pre><code>{\n    \"level\": \"info\",\n    \"msg\": \"test\",\n    \"testObj\": {\n        \"key\": \"value\" // example object contents\n    },\n    \"time\": \"2024-11-29T17:00:00.000Z\"\n}\n</code></pre> </li> <li> <p><code>logger.info({name: \"test\", testObj });</code></p> <ul> <li>Here, the log entry has keys <code>name</code> and <code>testObj</code>.</li> <li>Since there is no <code>msg</code> key in this case, Pino does not treat any field as the primary log message (unless you have customized <code>messageKey</code> in the configuration).</li> <li>Example Output:</li> </ul> <pre><code>{\n\"level\": \"info\",\n\"name\": \"test\",\n\"testObj\": {\n    \"key\": \"value\" // example object contents\n},\n\"time\": \"2024-11-29T17:00:00.000Z\"\n}\n</code></pre> </li> </ol>"},{"location":"frontend/package/monitoring-and-logging/pino/notes/#key-differences","title":"Key Differences","text":"<ol> <li> <p>Primary Message Field:</p> <ul> <li>In the first example, the <code>msg</code> key is explicitly set and will be treated as the main log message in Pino's structured logs.</li> <li>In the second example, there is no <code>msg</code>, so the log message is treated as a generic object.</li> </ul> </li> <li> <p>Semantics:</p> <ul> <li><code>msg</code> is a reserved key in Pino logs and should generally hold the main log message for clarity.</li> <li>Using a custom field like <code>name</code> does not carry the same semantic meaning and might reduce clarity when analyzing logs.</li> </ul> </li> <li> <p>Log Parsing:</p> <ul> <li>Log management systems or log parsers may rely on the <code>msg</code> key for displaying the main message in dashboards or alerts.</li> <li>Without a <code>msg</code>, the log might appear less structured or harder to interpret in such systems.</li> </ul> </li> </ol>"},{"location":"frontend/package/monitoring-and-logging/pino/notes/#best-practice","title":"Best Practice","text":"<p>If the intent is to log a primary message along with additional context, the first format is preferred:</p> <pre><code>logger.info({ msg: \"Button clicked\", testObj });\n</code></pre> <p>This ensures consistent formatting and makes it easier to integrate with log parsing tools.</p>"},{"location":"frontend/package/monitoring-and-logging/pino/notes/#common-pino-options","title":"Common Pino Options","text":"<p>Below are some of the key options supported by Pino during logger initialization:</p> Option Description <code>level</code> Specifies the minimum log level to record. Logs below this level are ignored. Defaults to <code>\"info\"</code>. Valid levels are <code>trace</code>, <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code>, and <code>fatal</code>. <code>timestamp</code> Configures the format of the timestamp in logs. You can disable it (<code>false</code>) or use a custom function to format timestamps (e.g., using <code>moment.js</code>). <code>browser</code> Allows customization of how logs are displayed in the browser, including structured logging (<code>asObject</code>) and sending logs to external services. <code>base</code> An object with additional default properties added to every log (e.g., <code>{ pid, hostname }</code>). Set to <code>null</code> to disable default properties. <code>messageKey</code> Customizes the key for the log message in structured logs. Defaults to <code>\"msg\"</code>. <code>enabled</code> Enables or disables logging entirely. Set to <code>false</code> to disable all logs. <code>hooks</code> Provides lifecycle hooks for modifying logs, such as the <code>logMethod</code> hook for customizing how logs are written. <code>serializers</code> Allows defining custom serializers for specific properties, such as masking sensitive data or formatting objects. <code>redact</code> Masks sensitive fields in logs (e.g., <code>\"password\"</code>). Can be an array of keys or a configuration object for redacting nested fields. <code>formatters</code> Customizes how the log object or log level appears in logs. <code>transport</code> Configures log transport for writing logs to files, streams, or external destinations in real-time. <code>customLevels</code> Allows defining additional custom log levels, extending Pino\u2019s default levels."},{"location":"frontend/package/monitoring-and-logging/pino/send-to-api/","title":"Sending to API","text":""},{"location":"frontend/package/monitoring-and-logging/pino/send-to-api/#overview","title":"Overview","text":"Installation<pre><code>pnpm add pino pino-pretty\n</code></pre>"},{"location":"frontend/package/monitoring-and-logging/pino/send-to-api/#steps-to-send-logs-to-an-api","title":"Steps to Send Logs to an API","text":"Example logger.jslogs.jslogModel.jsApp.jsx <p>1. Create a Custom Log Transport</p> <p>Pino allows you to define custom transports for logs. You can create one that sends logs to an API endpoint.</p> <pre><code>// src/utils/logger.js\nimport pino from \"pino\";\n\n// Create a custom transport for sending logs to an API\nconst sendLogToAPI = async (logObject) =&gt; {\n    try {\n        await fetch(\"/api/logs\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n            body: JSON.stringify(logObject),\n        });\n    } catch (error) {\n        console.error(\"Failed to send log:\", error);\n    }\n};\n\nconst logger = pino({\n    browser: {\n        transmit: {\n            send: (level, logEvent) =&gt; {\n                const logObject = {\n                    level,\n                    ...logEvent,\n                    timestamp: new Date().toISOString(),\n                };\n                sendLogToAPI(logObject); // Send log to API\n            },\n        },\n        asObject: true, // Keep logs readable in the browser console\n    },\n    level: import.meta.env.VITE_LOG_LEVEL || \"info\",\n});\n\nexport default logger;\n</code></pre> <p>2. Setup the Backend API to Receive Logs</p> <p>On the backend, create an API route to accept logs and store them in the database. For example, with Express.js:</p> <pre><code>// server/routes/logs.js\nconst express = require('express');\nconst router = express.Router();\nconst { LogModel } = require('../models/logModel'); // Assuming you have a log schema\n\n// Endpoint to receive logs\nrouter.post('/', async (req, res) =&gt; {\n    try {\n        const log = new LogModel(req.body); // Create a new log entry\n        await log.save(); // Save to the database\n        res.status(200).send({ message: 'Log stored successfully' });\n    } catch (error) {\n        console.error('Error storing log:', error);\n        res.status(500).send({ error: 'Failed to store log' });\n    }\n});\n\nmodule.exports = router;\n</code></pre> <p>3. Create a Database Schema for Logs</p> <p>Define a schema for storing logs in your database. For example, using Mongoose for MongoDB:</p> <pre><code>// server/models/logModel.js\nconst mongoose = require('mongoose');\n\nconst logSchema = new mongoose.Schema({\n    level: { type: String, required: true },\n    msg: { type: String, required: true },\n    timestamp: { type: Date, required: true },\n    context: { type: Object }, // Additional log metadata\n});\n\nconst LogModel = mongoose.model('Log', logSchema);\nmodule.exports = { LogModel };\n</code></pre> <p>4. Use the Logger in Your Application</p> <p>The logs will now be transmitted to your API whenever the logger is called.</p> <pre><code>// Example usage in a React component\nimport logger from './utils/logger';\n\nfunction App() {\n    const handleClick = () =&gt; {\n        logger.info('Button clicked', { user: 'John Doe', action: 'click' });\n        logger.error('An error occurred', { errorCode: 500 });\n    };\n\n    return (\n        &lt;div&gt;\n        &lt;h1&gt;Log to API Example&lt;/h1&gt;\n        &lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default App;\n</code></pre>"},{"location":"frontend/package/monitoring-and-logging/pino/send-to-api/#advantages-of-sending-logs-to-an-api","title":"Advantages of Sending Logs to an API","text":"<ol> <li>Centralized Logging: Logs from all clients and services can be stored in a single location.</li> <li>Persistent Storage: Logs can be retained long-term for debugging, audits, or analysis.</li> <li>Scalability: Enables aggregation of logs from distributed systems.</li> <li>Custom Alerts: Logs in a database can be queried for patterns and trigger alerts.</li> </ol>"},{"location":"frontend/package/monitoring-and-logging/pino/send-to-api/#additional-notes","title":"Additional Notes","text":"<ol> <li> <p>Batching Logs: Instead of sending logs individually, you can batch them to reduce API calls. Use a queue and periodically send logs in bulk.</p> <pre><code>let logQueue = [];\nconst batchLogs = () =&gt; {\n  if (logQueue.length &gt; 0) {\n    fetch(\"/api/logs\", {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify(logQueue),\n    }).catch((error) =&gt; console.error(\"Failed to send logs:\", error));\n    logQueue = [];\n  }\n};\nsetInterval(batchLogs, 5000); // Send logs every 5 seconds\n</code></pre> </li> <li> <p>Error Handling: Ensure your application gracefully handles failures in log transmission to avoid infinite loops or crashes.</p> </li> <li> <p>Security: Be cautious about what information is logged to avoid exposing sensitive data.</p> </li> <li> <p>Services: If you don\u2019t want to manage logs manually, consider services like LogRocket, Sentry, or Datadog for automated logging and analysis.</p> </li> </ol> <p>This approach ensures logs from your frontend React app are stored in a database for monitoring, debugging, and auditing purposes.</p>"},{"location":"frontend/package/monitoring-and-logging/pino/send-to-api/#reference","title":"Reference","text":"<ul> <li>pino</li> </ul>"},{"location":"frontend/package/monitoring-and-logging/pino/simple-usage/","title":"Simple Usage","text":""},{"location":"frontend/package/monitoring-and-logging/pino/simple-usage/#overview","title":"Overview","text":"Installation<pre><code>pnpm add pino pino-pretty\n</code></pre> <p>Log Levels in Pino</p> <p>Pino supports the following log levels, which control the severity and verbosity of logs:</p> Level Severity Description <code>fatal</code> 60 (highest) Indicates an unrecoverable error causing the application to crash. <code>error</code> 50 Non-critical errors requiring attention but not causing immediate failure. <code>warn</code> 40 Warnings about potential issues or deprecated usage. <code>info</code> 30 General operational information (e.g., application status, startup info). <code>debug</code> 20 Detailed debugging information useful during development. <code>trace</code> 10 (lowest) Very fine-grained logs for tracing code execution or troubleshooting. <code>silent</code> -1 (special) Disables all logging."},{"location":"frontend/package/monitoring-and-logging/pino/simple-usage/#what-log-levels-to-set-in-env-files","title":"What Log Levels to Set in <code>.env</code> Files","text":"<p>You can control the log verbosity in different environments by setting the <code>VITE_LOG_LEVEL</code> environment variable.</p> <p>1. <code>.env.development</code> (Development Environment)</p> <p>For development, you need verbose logging to debug issues effectively. Set the level to <code>debug</code> or <code>trace</code>.</p> <pre><code># .env.development\nVITE_LOG_LEVEL=debug\n</code></pre> <ul> <li>Reason: <code>debug</code> logs give detailed insights into the app's behavior without being as noisy as <code>trace</code>.</li> </ul> <p>2. <code>.env.production</code> (Production Environment)</p> <p>For production, logs should focus on errors and warnings to avoid performance overhead and clutter.</p> <pre><code># .env.production\nVITE_LOG_LEVEL=warn\n\n# or error only\nVITE_LOG_LEVEL=error\n</code></pre> <ul> <li>Reason: Warnings and errors are sufficient for monitoring production issues without flooding logs with unnecessary information.</li> </ul> <p>3. <code>.env</code> (Default Environment)</p> <p>Set a default level that works for both development and production but can be overridden by specific environments.</p> <pre><code># .env\nVITE_LOG_LEVEL=info\n</code></pre> <ul> <li>Reason: <code>info</code> logs provide general operational details, which is a safe default for most environments.</li> </ul>"},{"location":"frontend/package/monitoring-and-logging/pino/simple-usage/#how-pino-uses-vite_log_level","title":"How Pino Uses <code>VITE_LOG_LEVEL</code>","text":"<p>Here\u2019s how you can configure Pino to respect the <code>VITE_LOG_LEVEL</code> in your React + Vite application:</p> <pre><code>// src/utils/logger.js\nimport pino from \"pino\";\n\n// Get log level from environment variables\nconst logLevel = import.meta.env.VITE_LOG_LEVEL || \"info\";\n\n// Create a logger instance\nconst logger = pino({\n  level: logLevel, // Set log level dynamically\n  browser: {\n    asObject: true, // Make logs structured and readable in the browser console\n  },\n});\n\nexport default logger;\n</code></pre>"},{"location":"frontend/package/monitoring-and-logging/pino/simple-usage/#summary","title":"Summary","text":"<ul> <li>In <code>.env.development</code>: Use <code>VITE_LOG_LEVEL=debug</code> for detailed logs during development.</li> <li>In <code>.env.production</code>: Use <code>VITE_LOG_LEVEL=warn</code> or <code>VITE_LOG_LEVEL=error</code> to monitor issues without performance hits.</li> <li>In <code>.env</code>: Use <code>VITE_LOG_LEVEL=info</code> as a fallback for environments not explicitly configured.</li> </ul> <p>This setup ensures you have the right logging detail for each environment while optimizing performance and usability.</p>"},{"location":"frontend/package/monitoring-and-logging/pino/simple-usage/#what-will-be-logged-in-production","title":"What Will Be Logged in Production?","text":"<p>When <code>VITE_LOG_LEVEL=error</code>:</p> <ul> <li>Only logs with severity <code>error</code> and <code>fatal</code> will be logged.</li> <li>Logs with lower severities (<code>warn</code>, <code>info</code>, <code>debug</code>, <code>trace</code>) will be suppressed.</li> </ul> <pre><code>logger.fatal(\"Critical failure!\"); // Will be logged\nlogger.error(\"Something went wrong\"); // Will be logged\nlogger.warn(\"This is a warning\"); // Will NOT be logged\nlogger.info(\"Application started\"); // Will NOT be logged\nlogger.debug(\"Debugging details\"); // Will NOT be logged\nlogger.trace(\"Tracing execution\"); // Will NOT be logged\n</code></pre>"},{"location":"frontend/package/monitoring-and-logging/pino/simple-usage/#reference","title":"Reference","text":"<ul> <li>pino logger</li> </ul>"},{"location":"frontend/package/react-infinite-scroll-component/","title":"Intro","text":""},{"location":"frontend/package/react-infinite-scroll-component/#overview","title":"Overview","text":"<p>A component to make all your infinite scrolling woes go away with just 4.15 kB! <code>Pull Down to Refresh</code> feature added. An infinite-scroll that actually works and super-simple to integrate!</p>"},{"location":"frontend/package/react-infinite-scroll-component/#install","title":"Install","text":"<pre><code>npm install --save react-infinite-scroll-component\n\n# or\n\nyarn add react-infinite-scroll-component\n\n# in code ES6\nimport InfiniteScroll from 'react-infinite-scroll-component';\n\n# or commonjs\nvar InfiniteScroll = require('react-infinite-scroll-component');\n</code></pre>"},{"location":"frontend/package/react-infinite-scroll-component/#using","title":"Using","text":"<pre><code>&lt;InfiniteScroll\n  dataLength={items.length} //This is important field to render the next data\n  next={fetchData}\n  hasMore={true}\n  loader={&lt;h4&gt;Loading...&lt;/h4&gt;}\n  endMessage={\n    &lt;p style={{ textAlign: \"center\" }}&gt;\n      &lt;b&gt;Yay! You have seen it all&lt;/b&gt;\n    &lt;/p&gt;\n  }\n  // below props only if you need pull down functionality\n  refreshFunction={this.refresh}\n  pullDownToRefresh\n  pullDownToRefreshThreshold={50}\n  pullDownToRefreshContent={\n    &lt;h3 style={{ textAlign: \"center\" }}&gt;&amp;#8595; Pull down to refresh&lt;/h3&gt;\n  }\n  releaseToRefreshContent={\n    &lt;h3 style={{ textAlign: \"center\" }}&gt;&amp;#8593; Release to refresh&lt;/h3&gt;\n  }\n&gt;\n  {items}\n&lt;/InfiniteScroll&gt;\n</code></pre>"},{"location":"frontend/package/react-infinite-scroll-component/#using-scroll-on-top","title":"Using scroll on top","text":"<pre><code>&lt;div\n  id=\"scrollableDiv\"\n  style={{\n    height: 300,\n    overflow: \"auto\",\n    display: \"flex\",\n    flexDirection: \"column-reverse\",\n  }}\n&gt;\n  {/*Put the scroll bar always on the bottom*/}\n  &lt;InfiniteScroll\n    dataLength={this.state.items.length}\n    next={this.fetchMoreData}\n    style={{ display: \"flex\", flexDirection: \"column-reverse\" }} //To put endMessage and loader to the top.\n    inverse={true} //\n    hasMore={true}\n    loader={&lt;h4&gt;Loading...&lt;/h4&gt;}\n    scrollableTarget=\"scrollableDiv\"\n  &gt;\n    {this.state.items.map((_, index) =&gt; (\n      &lt;div style={style} key={index}&gt;\n        div - #{index}\n      &lt;/div&gt;\n    ))}\n  &lt;/InfiniteScroll&gt;\n&lt;/div&gt;\n</code></pre> <p>The <code>InfiniteScroll</code> component can be used in three ways.</p> <ol> <li>Specify a value for the <code>height</code> prop if you want your scrollable content to have a specific height, providing scrollbars for scrolling your content and fetching more data.</li> <li>If your scrollable content is being rendered within a parent element that is already providing overflow scrollbars, you can set the <code>scrollableTarget</code> prop to reference the DOM element and use it's scrollbars for fetching more data.</li> <li>Without setting either the <code>height</code> or <code>scrollableTarget</code> props, the scroll will happen at <code>document.body</code> like Facebook's timeline scroll.</li> </ol>"},{"location":"frontend/package/react-infinite-scroll-component/#props-table","title":"Props Table","text":"Prop Type Default Description <code>dataLength</code> <code>number</code> <code>0</code> The length of the data currently loaded. <code>next</code> <code>function</code> <code>required</code> The function to be called when the user scrolls to the bottom. It should load more data. <code>hasMore</code> <code>boolean</code> <code>true</code> Whether there is more data to load or not. If <code>false</code>, scrolling will stop. <code>loader</code> <code>ReactNode</code> <code>null</code> The element or component to show while loading. <code>endMessage</code> <code>ReactNode</code> <code>null</code> A message to display when all items are loaded. <code>scrollThreshold</code> <code>number</code> or <code>string</code> <code>0.9</code> The scroll position at which <code>next</code> is called, usually expressed as a percentage of the viewport. <code>scrollableTarget</code> <code>string</code> or <code>ref</code> <code>null</code> The id or reference to the scrollable element. <code>scrollThreshold</code> <code>number</code> <code>0.9</code> The percentage of the scroll container\u2019s height before <code>next</code> is called. <code>initialScrollY</code> <code>number</code> <code>0</code> The scroll position to start with when the page first loads. <code>pullDownToRefresh</code> <code>boolean</code> <code>false</code> If <code>true</code>, enables pull down to refresh behavior. <code>pullDownToRefreshThreshold</code> <code>number</code> <code>50</code> The distance in pixels that the user must pull down to trigger the refresh action. <code>releaseToRefresh</code> <code>boolean</code> <code>false</code> If <code>true</code>, the user must release the scroll to trigger the refresh action. <code>refreshFunction</code> <code>function</code> <code>null</code> The function to be called when the user pulls down to refresh. <code>header</code> <code>ReactNode</code> <code>null</code> An optional header to be displayed at the top of the scrollable area. <code>style</code> <code>object</code> <code>null</code> Optional inline styles for the component. <code>className</code> <code>string</code> <code>null</code> Optional class names to apply to the root element of the component."},{"location":"frontend/package/react-infinite-scroll-component/#reference","title":"Reference","text":"<ul> <li>react-infinite-scroll-component: npmjs</li> <li>react-infinite-scroll-component: github</li> </ul>"},{"location":"frontend/package/react-infinite-scroll-component/resuable/","title":"Resuable","text":"Companies.js<pre><code>&lt;TabPane tab=\"Log List\" key=\"4\"&gt;\n  {activeKey === \"4\" &amp;&amp; (\n    &lt;LogList\n      // loading={getCircularPlanningLoading}\n      // data={getCircularPlanningResp}\n      referenceId={getDetails?.referenceId}\n    /&gt;\n  )}\n&lt;/TabPane&gt;\n</code></pre>"},{"location":"frontend/package/react-infinite-scroll-component/resuable/#parentwrapper-component","title":"Parent/Wrapper Component\"","text":"ComponentAPIACTIONREDUCERTYPES LogList/index.js<pre><code>import React, { useEffect, useState, useReducer } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { Table } from \"antd\";\nimport moment from \"moment\";\nimport InfiniteScrollTable from \"components/Fallback/InfiniteScrollTable\";\nimport { isEmpty } from \"lodash\";\nimport { actionForCircularPlanningLog } from \"services/redux/Reference/action\";\nimport { SearchOutlined } from \"@ant-design/icons\";\n\nconst LogList = (props) =&gt; {\n    let { loading, data, referenceId } = props;\n    const LogoImage = \"assets/images/loader.gif\";\n\n    // added for infinite scroll\n    const dispatch = useDispatch();\n    const [logData, setLogData] = useState([]);\n    const [currentPage, setCurrentpage] = useState(1);\n    const pageSize = 10;\n\n    const { getCircularPlanningResp, getCircularPlanningLoading } = useSelector(\n        (state) =&gt; state.reference\n    );\n\n    const columns = [\n        {\n            title: \"S.N\",\n            dataIndex: \"key\",\n            width: \"8%\",\n            render: (_, __, index) =&gt; index + 1,\n            },\n        {\n            title: (\n                &lt;div\n                style={{\n                    display: \"flex\",\n                    justifyContent: \"space-between\",\n                    alignItems: \"center\",\n                }}\n                &gt;\n                &lt;span&gt;Remarks&lt;/span&gt;\n                &lt;SearchOutlined /&gt;\n                &lt;/div&gt;\n            ),\n            dataIndex: \"remarks\",\n            key: \"remarks\",\n        },\n        {\n            title: \"Creation Time\",\n            dataIndex: \"creationTime\",\n            key: \"creationTime\",\n            render: (text) =&gt; {\n                const formattedDate = moment(text).format(\"YYYY-MM-DD\");\n                const formattedTime = moment(text).format(\"hh:mm A\");\n                return (\n                &lt;span&gt;\n                    {formattedDate}{\" \"}\n                    &lt;span style={{ color: \"red\" }}&gt;{formattedTime}&lt;/span&gt;\n                &lt;/span&gt;\n                );\n            },\n        },\n    ];\n\n    // added for infinit scroll\n    useEffect(() =&gt; {\n        dispatch(\n            actionForCircularPlanningLog(\n                {\n                    ReferenceId: referenceId,\n                    MaxResultCount: pageSize,\n                    SkipCount: 0,\n                },\n                false\n            )\n        );\n    }, [referenceId]);\n\n    useEffect(() =&gt; {\n        if (!isEmpty(getCircularPlanningResp?.items)) {\n            setLogData(getCircularPlanningResp?.items);\n            const newCurrentPage = getCircularPlanningResp?.items?.length / pageSize;\n            setCurrentpage(newCurrentPage);\n        } else {\n            setLogData([]);\n        }\n    }, [getCircularPlanningResp, currentPage, pageSize]);\n\n    const getData = (MaxResultCount = pageSize, SkipCount, loadMore = true) =&gt; {\n        dispatch(\n            actionForCircularPlanningLog(\n                {\n                    ReferenceId: referenceId,\n                    MaxResultCount,\n                    SkipCount,\n                },\n                loadMore\n            )\n        );\n    };\n\n    const getMoreData = () =&gt; {\n        getData(pageSize, currentPage * pageSize, true);\n    };\n\n    return (\n        &lt;&gt;\n            &lt;InfiniteScrollTable\n                fetchData={getMoreData}\n                hasMore={\n                    getCircularPlanningResp?.totalCount &gt;\n                    getCircularPlanningResp?.items?.length\n                }\n                columns={columns}\n                data={logData}\n                loading={getCircularPlanningLoading}\n            /&gt;\n        &lt;/&gt;\n    );\n};\n\nexport default LogList;\n</code></pre> <pre><code>getCircularPlanningLog(q) {\n    let query = queryString.stringify(q);\n    let url = `${appBaseUrl}/referenceManagement/circularplanninglogsGetAllData?${query}`;\n    let data = getService(url, query);\n    return data;\n}\n</code></pre> <pre><code>export const actionForCircularPlanningLog = (q, loadMore) =&gt; {\n    return async (dispatch) =&gt; {\n        dispatch(init(REFERENCE__TYPES.GET_CIRCULAR_PLANNING_LOG));\n        const response = await referencesService.getCircularPlanningLog(q);\n        if (response.isSuccess) {\n            if (loadMore) {\n                console.log(\"loadMore\");\n                dispatch(\n                    success(\n                        REFERENCE__TYPES.GET_CIRCULAR_PLANNING_LOG_MORE,\n                        response.data\n                    )\n                );\n            } else {\n                dispatch(\n                success(REFERENCE__TYPES.GET_CIRCULAR_PLANNING_LOG, response.data)\n                );\n            }\n        } else if (!response.isSuccess) {\n            dispatch(error(response.errorMessage));\n        }\n        dispatch(finish(REFERENCE__TYPES.GET_CIRCULAR_PLANNING_LOG));\n    };\n}\n</code></pre> <pre><code>import { uniqBy, sortBy } from \"lodash\";\n\ncase REFERENCE__TYPES.GET_CIRCULAR_PLANNING_LOG_MORE_SUCCESS:\n  return {\n    ...state,\n    getCircularPlanningResp: state.getCircularPlanningResp\n      ? {\n          items: uniqBy(\n            state.getCircularPlanningResp?.items.concat(\n              action.payload.items\n            ),\n            \"id\"\n          ),\n          totalCount: action.payload.totalCount,\n        }\n      : action.payload,\n    getCircularPlanningLoading: action.payload ? false : true,\n};\n</code></pre> <pre><code>let REFERENCE__TYPES = {\n    GET_CIRCULAR_PLANNING_LOG: \"GET_CIRCULAR_PLANNING_LOG\",\n    GET_CIRCULAR_PLANNING_LOG_INIT: \"GET_CIRCULAR_PLANNING_LOG_INIT\",\n    GET_CIRCULAR_PLANNING_LOG_SUCCESS: \"GET_CIRCULAR_PLANNING_LOG_SUCCESS\",\n    GET_CIRCULAR_PLANNING_LOG_FINISH: \"GET_CIRCULAR_PLANNING_LOG_FINISH\",\n    GET_CIRCULAR_PLANNING_LOG_MORE: \"GET_CIRCULAR_PLANNING_LOG_MORE\",\n    GET_CIRCULAR_PLANNING_LOG_MORE_SUCCESS:\n        \"GET_CIRCULAR_PLANNING_LOG_MORE_SUCCESS\",\n}\n</code></pre>"},{"location":"frontend/package/react-infinite-scroll-component/resuable/#infinite-scroll-reuable-component","title":"Infinite Scroll Reuable Component","text":"InfiniteScrollTable.jsx<pre><code>import React, { useState, useEffect } from \"react\";\nimport InfiniteScroll from \"react-infinite-scroll-component\";\nimport { Table, Spin, Skeleton, message } from \"antd\";\n\nconst InfiniteScrollTable = ({\n  fetchData,\n  hasMore,\n  columns,\n  data,\n  loading = false,\n}) =&gt; {\n  return (\n    &lt;div\n      id=\"scrollable-table\"\n      style={{\n        height: 200,\n        overflow: \"auto\",\n        display: \"flex\",\n        flexDirection: \"column\",\n      }}\n    &gt;\n      &lt;InfiniteScroll\n        dataLength={data?.length}\n        next={fetchData}\n        // next={() =&gt; {\n        //   console.log(\"Scroll triggered\");\n        //   fetchData();\n        // }}\n        hasMore={hasMore}\n        loader={&lt;Skeleton active={4} /&gt;}\n        endMessage={&lt;p style={{ textAlign: \"center\" }}&gt;No more data&lt;/p&gt;}\n        scrollThreshold={0.6}\n        scrollableTarget=\"scrollable-table\"\n      &gt;\n        &lt;Table\n          columns={columns}\n          dataSource={data}\n          pagination={false}\n          loading={loading}\n          rowKey=\"id\"\n          // scroll={{ y: 200 }}\n        /&gt;\n      &lt;/InfiniteScroll&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default InfiniteScrollTable;\n</code></pre>"},{"location":"frontend/package/react-infinite-scroll-component/resuable/#update-with-searchkeyword","title":"Update with <code>SearchKeyword</code>","text":"index.jsLogModal.jsx <pre><code>// Added the Modal &amp; Search\nconst [formLog] = Form.useForm();\nconst [visibleLogModal, setVisibleLogModal] = useState(false);\nconst [searchKeyWord, setSearchKeyWord] = useState(null);\n\n\n// added\nuseEffect(() =&gt; {\n    dispatch(\n    actionForCircularPlanningLog(\n        {\n            ReferenceId: referenceId,\n            MaxResultCount: pageSize,\n            SkipCount: 0,\n            SearchKeyword: searchKeyWord,\n        },\n        false\n    )\n    );\n}, [referenceId, searchKeyWord]);\n\nconst getData = (\n    MaxResultCount = pageSize,\n    SkipCount,\n    // added\n    SearchKeyword,\n    loadMore = true\n) =&gt; {\n    dispatch(\n    actionForCircularPlanningLog(\n        {\n            ReferenceId: referenceId,\n            MaxResultCount,\n            SkipCount,\n            // added\n            SearchKeyword,\n        },\n        loadMore\n    )\n    );\n};\n\nconst getMoreData = () =&gt; {\n    // added searchKeyword\n    getData(pageSize, currentPage * pageSize, searchKeyWord, true);\n};\n\n\n// Handle\nconst handleOk = async () =&gt; {\n    try {\n        const values = await formLog.validateFields();\n        const formattedDate = moment(values.date).format(\"YYYY-MM-DD\");\n\n        setSearchKeyWord(values?.title);\n        handleCancel();\n        formLog.resetFields();\n    } catch (error) {\n        console.log(\"Failed to submit:\", error);\n    }\n};\n\nconst handleCancel = () =&gt; {\n    setVisibleLogModal(false);\n};\n\n\nconst columns = [\n    {\n        title: (\n            &lt;div\n                style={{\n                display: \"flex\",\n                justifyContent: \"space-between\",\n                alignItems: \"center\",\n                }}\n            &gt;\n                &lt;span&gt;Remarks&lt;/span&gt;\n                {isNull(searchKeyWord) ? (\n                    &lt;SearchOutlined\n                        style={{ color: \"blue\" }}\n                        onClick={() =&gt; setVisibleLogModal(true)}\n                    /&gt;\n                    ) : (\n                    &lt;CloseCircleTwoTone\n                        onClick={() =&gt; {\n                        setSearchKeyWord(null);\n                        }}\n                        twoToneColor=\"red\"\n                    /&gt;\n                )}\n            &lt;/div&gt;\n        ),\n        width: \"70%\",\n        dataIndex: \"remarks\",\n        key: \"remarks\",\n    },\n]\n</code></pre> <pre><code>import React from \"react\";\nimport { Modal, Form, Input, DatePicker } from \"antd\";\n\nconst LogModal = ({ visible, form, onOk, onCancel }) =&gt; {\n\n    return (\n        &lt;Modal\n            title=\"Log Information\"\n            visible={visible}\n            onOk={onOk}\n            onCancel={onCancel}\n            okText=\"Submit\"\n            cancelText=\"Cancel\"\n        &gt;\n            &lt;Form form={form} layout=\"vertical\" name=\"log_form\"&gt;\n                &lt;Form.Item\n                    name=\"title\"\n                    label=\"Title\"\n                    rules={[{ required: true, message: \"Please enter a title!\" }]}\n                &gt;\n                    &lt;Input /&gt;\n                &lt;/Form.Item&gt;\n\n                {/* &lt;Form.Item\n                name=\"date\"\n                label=\"Date\"\n                rules={[{ required: true, message: \"Please select a date!\" }]}\n                &gt;\n                &lt;DatePicker style={{ width: \"100%\" }} /&gt;\n                &lt;/Form.Item&gt; */}\n            &lt;/Form&gt;\n        &lt;/Modal&gt;\n    );\n};\n\nexport default LogModal;\n</code></pre> <p>Optional Enhancements</p> <ul> <li>Tooltips for icons: If you want to add tooltips for better UX, you can wrap the icons in Ant Design's Tooltip component:</li> </ul> <pre><code>import { Tooltip } from \"antd\";\n\n{\n  searchKeyWord ? (\n    &lt;Tooltip title=\"Clear search\"&gt;\n      &lt;CloseCircleTwoTone\n        style={{ cursor: \"pointer\" }}\n        onClick={() =&gt; setSearchKeyWord(null)}\n        twoToneColor=\"red\"\n      /&gt;\n    &lt;/Tooltip&gt;\n  ) : (\n    &lt;Tooltip title=\"Search\"&gt;\n      &lt;SearchOutlined\n        style={{ cursor: \"pointer\", color: \"blue\" }}\n        onClick={() =&gt; setVisibleLogModal(true)}\n      /&gt;\n    &lt;/Tooltip&gt;\n  );\n}\n</code></pre> <ul> <li>Adding a Loading State: If there\u2019s a need to indicate loading or processing, you can conditionally render the icons based on a loading state.</li> </ul>"},{"location":"frontend/package/tinymce/tinymce/","title":"Intro","text":"<p>TinyMCE is a popular WYSIWYG editor that can be integrated into React applications. To add a template inside the TinyMCE editor in a React project, you can follow these general steps:</p> <ol> <li> <p>Install TinyMCE:     If you haven't already, install the TinyMCE editor in your React project using a package manager like npm or yarn. Here's an example using npm:</p> <pre><code>npm install tinymce\n</code></pre> </li> <li> <p>Import TinyMCE in your React component:     Import TinyMCE in the React component where you want to use the editor.</p> <pre><code>import { Editor } from \"@tinymce/tinymce-react\";\n</code></pre> </li> <li> <p>Configure TinyMCE:     Set up the TinyMCE configuration in your component. This is where you can define the template and other settings.</p> <pre><code>const TinyMCEEditor = () =&gt; {\n  const handleEditorChange = (content, editor) =&gt; {\n    // Handle content changes here\n    console.log(\"Content:\", content);\n  };\n\n  const templateContent = `\n    &lt;p&gt;This is a template content&lt;/p&gt;\n`;\n\n  return (\n    &lt;Editor\n      apiKey=\"YOUR_API_KEY\" // You can obtain an API key by creating a TinyMCE account\n      initialValue={templateContent}\n      init={{\n        height: 500,\n        menubar: false,\n        plugins: [\n          \"advlist autolink lists link image charmap print preview anchor\",\n          \"searchreplace visualblocks code fullscreen\",\n          \"insertdatetime media table paste code help wordcount\",\n        ],\n        toolbar:\n          \"undo redo | formatselect | bold italic backcolor | \\\n        alignleft aligncenter alignright alignjustify | \\\n        bullist numlist outdent indent | removeformat | help\",\n        content_style:\n          \"body { font-family:Helvetica,Arial,sans-serif; font-size:14px }\",\n      }}\n      onChange={handleEditorChange}\n    /&gt;\n  );\n};\n\nexport default TinyMCEEditor;\n</code></pre> <p>In the above example, templateContent is the initial content of the editor, and you can customize the init object to include the desired plugins, toolbar buttons, and other configurations.</p> </li> <li> <p>Handle Template Insertion:</p> <p>You can provide a button or some other user interaction to insert the template content into the editor. For example, you can add a button that, when clicked, inserts the template content at the current cursor position.</p> <pre><code>const insertTemplate = () =&gt; {\n  const editor = tinymce.activeEditor;\n  if (editor) {\n    editor.insertContent(templateContent);\n  }\n};\n\n// ...\n\n&lt;button onClick={insertTemplate}&gt;Insert Template&lt;/button&gt;;\n</code></pre> <p>Make sure to adapt the code according to your specific requirements and integrate it seamlessly into your React application. Adjust the TinyMCE configuration and event handlers based on your needs.</p> </li> </ol>"},{"location":"frontend/query/intro/","title":"Intro","text":"<p>query</p>"},{"location":"frontend/query/rtk-post-put-mutation/","title":"RTK Mutation","text":""},{"location":"frontend/query/rtk-post-put-mutation/#header","title":"HEADER","text":"<p>To resolve this, you should rename the states for each mutation so they don't conflict with each other. Here's a revised version:</p> <pre><code>// For the postCountry mutation\nconst [\n  postCountry,\n  { isLoading: isLoadingPost, isError: isErrorPost, error: postError },\n] = usePostCountryMutation();\n\n// For the putCountry mutation\nconst [\n  putCountry,\n  { isLoading: isLoadingPut, isError: isErrorPut, error: putError },\n] = usePutCountryMutation();\n</code></pre>"},{"location":"frontend/query/rtk-post-put-mutation/#question","title":"Question","text":"Question <pre><code>export const countryApi = createApi({\n    reducerPath: \"countryApi\",\n    baseQuery: axiosBaseQuery({\n        baseUrl: CONFIG.API_BASE_URL,\n    }),\n    endpoints: (builder) =&gt; ({\n        getCountry: builder.query({\n            query: () =&gt; ({ url: \"Country\", method: \"get\" }),\n        }),\n\n        postCountry: builder.mutation({\n            query: (data) =&gt; ({\n                url: \"Country\",\n                method: \"post\",\n                data,\n            }),\n        }),\n\n        putCountry: builder.mutation({\n            query: (data) =&gt; ({\n                url: \"Country\",\n                method: \"put\",\n                data,\n            }),\n        }),\n    }),\n});\n</code></pre> <p>how to update database when put and post</p> <p>To update the database when performing a <code>POST</code> (create) or <code>PUT</code> (update) request, you would typically follow these steps:</p>"},{"location":"frontend/query/rtk-post-put-mutation/#1-sending-the-request-to-the-server-post-or-put","title":"1. Sending the Request to the Server (POST or PUT):","text":"<ul> <li>POST is used to create a new record (in this case, a new country).</li> <li>PUT is used to update an existing record.</li> </ul> <p>In your <code>countryApi</code> definition, the <code>postCountry</code> and <code>putCountry</code> mutations are already set up to send the <code>POST</code> and <code>PUT</code> requests to the server. The <code>query</code> field inside the <code>mutation</code> will handle sending the request when it is called.</p>"},{"location":"frontend/query/rtk-post-put-mutation/#2-optimistically-updating-the-state-optional-but-recommended","title":"2. Optimistically Updating the State (Optional but Recommended):","text":"<p>After sending a <code>POST</code> or <code>PUT</code> request, you can update the Redux state (or cache) to reflect the new or modified data without waiting for the server's response. This can help with a more responsive UI.</p> <p>For this, RTK Query provides optimistic updates. In the case of <code>POST</code> and <code>PUT</code>, you can use <code>onQueryStarted</code> to update the cache optimistically. You can also update the state using <code>updateQueryData</code> and trigger a refetch if needed.</p> <p>Here is how to optimistically update the database on successful <code>POST</code> or <code>PUT</code>:</p> CodeExplanation Example Code for Optimistic Updates<pre><code>export const countryApi = createApi({\n    reducerPath: \"countryApi\",\n    baseQuery: axiosBaseQuery({\n        baseUrl: CONFIG.API_BASE_URL,\n    }),\n    endpoints: (builder) =&gt; ({\n        // Query to fetch country data (GET request)\n        getCountry: builder.query({\n            query: () =&gt; ({ url: \"Country\", method: \"get\" }),\n        }),\n\n        // POST to add a new country\n        postCountry: builder.mutation({\n            query: (data) =&gt; ({\n                url: \"Country\",\n                method: \"post\",\n                data,\n            }),\n\n            // onSuccess or onQueryStarted for optimistic updates\n            async onQueryStarted(data, { dispatch, queryFulfilled }) {\n                // Optimistically update the cache\n                try {\n                    // Optimistically update cache for the added country\n                    const patchResult = dispatch(\n                        countryApi.util.updateQueryData(\n                        \"getCountry\",\n                        undefined,\n                        (draft) =&gt; {\n                            // Add the new country to the existing list of countries\n                            draft.push(data);\n                        }\n                        )\n                    );\n\n                    // Wait for the mutation to succeed\n                    await queryFulfilled;\n                } catch (error) {\n                    // Rollback if the request fails\n                    console.error(\"Error posting country:\", error);\n                }\n            },\n            }),\n\n            // PUT to update an existing country\n            putCountry: builder.mutation({\n                query: (data) =&gt; ({\n                    url: `Country/${data.id}`, // Assuming the country has an `id` field for identifying it\n                    method: \"put\",\n                    data,\n                }),\n\n                // onSuccess or onQueryStarted for optimistic updates\n                async onQueryStarted(data, { dispatch, queryFulfilled }) {\n                    // Optimistically update the cache\n                    try {\n                        // Optimistically update cache for the updated country\n                        const patchResult = dispatch(\n                            countryApi.util.updateQueryData(\n                            \"getCountry\",\n                            undefined,\n                                (draft) =&gt; {\n                                    const index = draft.findIndex(\n                                    (country) =&gt; country.id === data.id\n                                    );\n                                    if (index !== -1) {\n                                    draft[index] = data; // Update the country in the list\n                                    }\n                                }\n                            )\n                        );\n\n                        // Wait for the mutation to succeed\n                        await queryFulfilled;\n                    } catch (error) {\n                        // Rollback if the request fails\n                        console.error(\"Error updating country:\", error);\n                    }\n                },\n        }),\n    }),\n});\n\nexport const {\n    useGetCountryQuery,\n    usePostCountryMutation,\n    usePutCountryMutation,\n} = countryApi;\n</code></pre> <p>Explanation of the Optimistic Update Process:</p> <ol> <li> <p>Optimistic Update for POST (Adding a Country):</p> <ul> <li>After sending a <code>POST</code> request to add a new country, we optimistically update the <code>getCountry</code> query data by adding the new country to the existing list (i.e., the <code>draft.push(data)</code> step).</li> <li>If the mutation fails, no changes are made to the cache.</li> </ul> </li> <li> <p>Optimistic Update for <code>PUT</code> (Updating a Country):</p> <ul> <li>After sending a <code>PUT</code> request to update an existing country, we optimistically update the <code>getCountry</code> query data by replacing the old country data with the updated one (<code>draft[index] = data</code>).</li> <li>If the mutation fails, no changes are made to the cache.</li> </ul> </li> <li> <p><code>queryFulfilled</code>:</p> <ul> <li><code>queryFulfilled</code> is a promise that resolves when the mutation request successfully completes. If it succeeds, the cache update remains; if it fails, any optimistically applied changes are rolled back.</li> </ul> </li> </ol>"},{"location":"frontend/query/rtk-post-put-mutation/#3-handling-errors","title":"3. Handling Errors:","text":"<ul> <li>Error Handling: The <code>onQueryStarted</code> function includes error handling with a <code>try/catch</code> block. If there is any issue during the mutation (e.g., the network request fails), the changes are reverted.</li> <li>Rollback: The cache update happens optimistically, so if the request fails, we simply don't persist those changes.</li> </ul>"},{"location":"frontend/query/rtk-post-put-mutation/#4-refetching-data-after-mutation-optional","title":"4. Refetching Data After Mutation (Optional):","text":"<ul> <li>You can also configure a refetch of the data after the mutation to ensure the cache stays in sync with the server data. For example, you can dispatch a refetch query like this:</li> </ul> <pre><code>dispatch(countryApi.util.invalidateTags([{ type: \"Country\", id: \"LIST\" }]));\n</code></pre> <p>This would trigger a refetch of the <code>getCountry</code> query after a successful mutation.</p>"},{"location":"frontend/query/rtk-post-put-mutation/#conclusion","title":"Conclusion:","text":"<p>By using optimistic updates with <code>onQueryStarted</code>, your app can provide a seamless experience to the user, showing immediate updates without waiting for the server response. This pattern is particularly useful for create (POST) and update (PUT) actions, ensuring that the UI stays responsive even in cases of network latency or failure.</p>"},{"location":"frontend/query/rtk-post-put-mutation/#rollback-functionality","title":"Rollback Functionality","text":"<p>To implement rollback functionality in case of a failed request and show an error message to the user, you can follow this approach in RTK Query:</p> <ul> <li> <p>Optimistic Updates with Rollback: If an optimistic update (like adding or modifying data in the cache) is performed, you can roll back the changes if the request fails. This rollback is accomplished using <code>onQueryStarted</code> and handling the error in the <code>catch</code> block.</p> </li> <li> <p>Error Handling: You can show the error message to the user by catching the error and using it in your UI to display a relevant message.</p> </li> </ul> <p>Updated Example with Rollback and Error Display:</p> <p>Below is an updated example of your <code>countryApi</code> with proper error handling and rollback when a request fails:</p> CodeExplanation <pre><code>export const countryApi = createApi({\n    reducerPath: \"countryApi\",\n    baseQuery: axiosBaseQuery({\n        baseUrl: CONFIG.API_BASE_URL,\n    }),\n    endpoints: (builder) =&gt; ({\n        // GET query for fetching country data\n        getCountry: builder.query({\n            query: () =&gt; ({ url: \"Country\", method: \"get\" }),\n        }),\n\n        // POST to add a new country\n        postCountry: builder.mutation({\n            query: (data) =&gt; ({\n                url: \"Country\",\n                method: \"post\",\n                data,\n            }),\n        async onQueryStarted(data, { dispatch, queryFulfilled }) {\n            const patchResult = dispatch(\n                countryApi.util.updateQueryData(\"getCountry\", undefined, (draft) =&gt; {\n                    draft.push(data); // Optimistically add the new country to the list\n                })\n            );\n\n            try {\n                // Wait for the POST request to finish\n                await queryFulfilled;\n            } catch (error) {\n                // If the request fails, rollback the optimistic update\n                dispatch(\n                    countryApi.util.updateQueryData(\n                    \"getCountry\",\n                    undefined,\n                    (draft) =&gt; {\n                        const index = draft.findIndex(\n                        (country) =&gt; country.id === data.id\n                        );\n                        if (index !== -1) draft.splice(index, 1); // Remove the country if POST fails\n                    }\n                    )\n                );\n\n                // Handle and display the error\n                console.error(\"Error posting country:\", error);\n                alert(`Failed to add country: ${error.message || \"Unknown error\"}`);\n            }\n        },\n    }),\n\n    // PUT to update an existing country\n    putCountry: builder.mutation({\n        query: (data) =&gt; ({\n            url: `Country/${data.id}`, // Assuming data has an `id` field for identification\n            method: \"put\",\n            data,\n        }),\n        async onQueryStarted(data, { dispatch, queryFulfilled }) {\n            const patchResult = dispatch(\n                countryApi.util.updateQueryData(\"getCountry\", undefined, (draft) =&gt; {\n                    const index = draft.findIndex((country) =&gt; country.id === data.id);\n                    if (index !== -1) {\n                    draft[index] = data; // Optimistically update the country data\n                    }\n                })\n            );\n\n            try {\n                // Wait for the PUT request to complete\n                await queryFulfilled;\n            } catch (error) {\n                // If the request fails, rollback the optimistic update\n                dispatch(\n                    countryApi.util.updateQueryData(\n                    \"getCountry\",\n                    undefined,\n                    (draft) =&gt; {\n                        const index = draft.findIndex(\n                        (country) =&gt; country.id === data.id\n                        );\n                        if (index !== -1) draft[index] = data; // Keep the previous data if PUT fails\n                    }\n                    )\n                );\n\n                // Handle and display the error\n                console.error(\"Error updating country:\", error);\n                alert(\n                    `Failed to update country: ${error.message || \"Unknown error\"}`\n                );\n            }\n        },\n        }),\n    }),\n});\n\nexport const {\n    useGetCountryQuery,\n    usePostCountryMutation,\n    usePutCountryMutation,\n} = countryApi;\n</code></pre> <p>Key Points in This Approach:</p> <ol> <li> <p>Optimistic Update:</p> <ul> <li>You optimistically update the local cache using <code>dispatch(countryApi.util.updateQueryData())</code> when the mutation is triggered. For example, when adding a new country via <code>POST</code>, we immediately add it to the list of countries in the cache.</li> </ul> </li> <li> <p>Rollback on Failure:</p> <ul> <li>In the <code>catch</code> block, if the request fails (e.g., network error, server error), we rollback the optimistic update by removing the added country (for <code>POST</code>) or reverting the updated country (for <code>PUT</code>).</li> <li>This is done by updating the cache again but removing or restoring the old data.</li> </ul> </li> <li> <p>Error Handling:</p> <ul> <li>When the request fails, the error is logged using <code>console.error()</code>. Additionally, you can show an error message to the user using <code>alert()</code> or any other UI-based method. In the example, I used an <code>alert</code> with the error message from the <code>error.message</code> object.</li> </ul> </li> <li> <p>Displaying Errors:</p> <ul> <li>In production code, you might want to use a more user-friendly way of displaying errors, such as showing the message in a UI component (e.g., a modal or a toast notification), rather than using <code>alert()</code>.</li> </ul> </li> </ol> Example <p>Example of How You Might Handle the Error in the UI (Optional):</p> <p>If you want to display the error message in a UI component (like a modal or toast), you could use a state in your component to track and display the error.</p> <pre><code>const [postCountry, { isLoading, isError, error }] = usePostCountryMutation();\nconst [errorMessage, setErrorMessage] = useState(\"\");\n\nconst handlePostCountry = async (data) =&gt; {\n    try {\n        await postCountry(data);\n    } catch (err) {\n        setErrorMessage(`Failed to add country: ${err.message || 'Unknown error'}`);\n    }\n};\n\nreturn (\n    &lt;div&gt;\n        {errorMessage &amp;&amp; &lt;div className=\"error-message\"&gt;{errorMessage}&lt;/div&gt;}\n        {/* Your form or other components */}\n    &lt;/div&gt;\n);\n</code></pre> <p>This will allow you to display the error message in a dedicated error section in your UI.</p> Conclusion <ul> <li>Optimistic Updates allow you to update the UI quickly.</li> <li>Rollback ensures that if something goes wrong, the UI reverts to its previous state.</li> <li>Error Handling ensures that users are notified when something fails, and you can show the error in a user-friendly way.</li> </ul> <p>This pattern keeps your application responsive and robust even when network or server errors occur.</p>"},{"location":"frontend/query/rtk-query-header/","title":"RTK Query","text":"api/postsApi.js<pre><code>import { createApi, fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\nimport { store } from \"./store\"; // Import the Redux store to access state\n\nexport const postsApi = createApi({\n  reducerPath: \"postsApi\",\n  baseQuery: fetchBaseQuery({\n    baseUrl: \"https://jsonplaceholder.typicode.com\",\n    // You can add headers here, or use `prepareHeaders` for dynamic headers\n    prepareHeaders: (headers, { getState }) =&gt; {\n      // Get the token from the Redux store (assuming it's stored in auth.token)\n      const token = getState().auth.token;\n      if (token) {\n        headers.set(\"Authorization\", `Bearer ${token}`);\n      }\n      return headers;\n    },\n  }),\n  endpoints: (builder) =&gt; ({\n    getPosts: builder.query({\n      query: () =&gt; \"/posts\",\n    }),\n  }),\n});\n\nexport const { useGetPostsQuery } = postsApi;\n</code></pre> <p>Solution: Global Token Management for Multiple <code>createApi</code> Slices</p> <p>Option 1: Shared <code>baseQuery</code> with Token Injection</p> <pre><code>// api/baseQuery.js\nimport { fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\nimport { store } from \"../store\"; // Import the Redux store to access state\n\n// Custom baseQuery that includes token injection logic\nexport const baseQueryWithAuth = fetchBaseQuery({\n  baseUrl: \"https://jsonplaceholder.typicode.com\", // Default base URL (can be overridden in each createApi)\n  prepareHeaders: (headers, { getState }) =&gt; {\n    const token = getState().auth.token; // Retrieve the token from Redux state\n    if (token) {\n      headers.set(\"Authorization\", `Bearer ${token}`); // Set Authorization header with token\n    }\n    return headers; // Return the modified headers\n  },\n});\n</code></pre>"},{"location":"frontend/query/rtk-query-header/#which-to-choose","title":"Which to Choose?","text":"<ul> <li> <p>If you have only one API slice or want to ensure the token is only added for requests related to <code>postsApi</code>, then you should keep the filter: <code>action.type.startsWith('postsApi/')</code>.</p> </li> <li> <p>If you have multiple API slices and want to add the token to all outgoing API requests, then removing the check is a cleaner approach. It lets you reuse the middleware across multiple createApi slices without having to duplicate the logic.</p> </li> </ul> <p></p>"},{"location":"frontend/query/rtk-query-header/#reference","title":"Reference","text":"<ul> <li>How to Use Redux Middleware to Better Control Your Data and Write Cleaner Code</li> </ul>"},{"location":"frontend/query/rtk-query-header/#examples-basequery","title":"Examples - baseQuery","text":""},{"location":"frontend/query/rtk-query-header/#axios-basequery","title":"Axios baseQuery","text":"<pre><code>import { createApi } from \"@reduxjs/toolkit/query\";\nimport axios from \"axios\";\n\nconst axiosBaseQuery =\n  ({ baseUrl } = { baseUrl: \"\" }) =&gt;\n  async ({ url, method, data, params, headers }) =&gt; {\n    try {\n      const result = await axios({\n        url: baseUrl + url,\n        method,\n        data,\n        params,\n        headers,\n      });\n      return { data: result.data };\n    } catch (axiosError) {\n      const err = axiosError;\n      return {\n        error: {\n          status: err.response?.status,\n          data: err.response?.data || err.message,\n        },\n      };\n    }\n  };\n\nconst api = createApi({\n  baseQuery: axiosBaseQuery({\n    baseUrl: \"https://example.com\",\n  }),\n  endpoints(build) {\n    return {\n      query: build.query({ query: () =&gt; ({ url: \"/query\", method: \"get\" }) }),\n      mutation: build.mutation({\n        query: () =&gt; ({ url: \"/mutation\", method: \"post\" }),\n      }),\n    };\n  },\n});\n</code></pre> <p>Impletementation in code</p> axios axios/axiosInstance.jsx<pre><code>import axios from \"axios\";\nimport axiosConfig from \"./axiosConfig\";\n\nconst axiosInstance = {\n  base: axios.create({\n    baseURL: import.meta.env.VITE_REACT_APP_BASE_API_URL,\n    ...axiosConfig,\n  }),\n  login: axios.create({\n    baseURL: import.meta.env.VITE_REACT_APP_LOGIN_API_URL,\n    ...axiosConfig,\n  }),\n  test: axios.create({\n    baseURL: import.meta.env.VITE_REACT_APP_TEST_API_URL,\n    ...axiosConfig,\n  }),\n};\n\nexport default axiosInstance;\n</code></pre>"},{"location":"frontend/query/rtk-query-header/#automatic-re-authorization-by-extending-fetchbasequery","title":"Automatic re-authorization by extending fetchBaseQuery","text":"Simulating axios-like interceptors with a custom base query<pre><code>import { fetchBaseQuery } from \"@reduxjs/toolkit/query\";\nimport { tokenReceived, loggedOut } from \"./authSlice\";\n\nconst baseQuery = fetchBaseQuery({ baseUrl: \"/\" });\nconst baseQueryWithReauth = async (args, api, extraOptions) =&gt; {\n  let result = await baseQuery(args, api, extraOptions);\n  if (result.error &amp;&amp; result.error.status === 401) {\n    // try to get a new token\n    const refreshResult = await baseQuery(\"/refreshToken\", api, extraOptions);\n    if (refreshResult.data) {\n      // store the new token\n      api.dispatch(tokenReceived(refreshResult.data));\n      // retry the initial query\n      result = await baseQuery(args, api, extraOptions);\n    } else {\n      api.dispatch(loggedOut());\n    }\n  }\n  return result;\n};\n</code></pre> <p>Preventing multiple unauthorized errors</p> <p>Using async-mutex to prevent multiple calls to '/refreshToken' when multiple calls fail with 401 Unauthorized errors.</p> Preventing multiple unauthorized errors<pre><code>import { fetchBaseQuery } from \"@reduxjs/toolkit/query\";\nimport { tokenReceived, loggedOut } from \"./authSlice\";\nimport { Mutex } from \"async-mutex\";\n\n// create a new mutex\nconst mutex = new Mutex();\nconst baseQuery = fetchBaseQuery({ baseUrl: \"/\" });\nconst baseQueryWithReauth = async (args, api, extraOptions) =&gt; {\n  // wait until the mutex is available without locking it\n  await mutex.waitForUnlock();\n  let result = await baseQuery(args, api, extraOptions);\n  if (result.error &amp;&amp; result.error.status === 401) {\n    // checking whether the mutex is locked\n    if (!mutex.isLocked()) {\n      const release = await mutex.acquire();\n      try {\n        const refreshResult = await baseQuery(\n          \"/refreshToken\",\n          api,\n          extraOptions\n        );\n        if (refreshResult.data) {\n          api.dispatch(tokenReceived(refreshResult.data));\n          // retry the initial query\n          result = await baseQuery(args, api, extraOptions);\n        } else {\n          api.dispatch(loggedOut());\n        }\n      } finally {\n        // release must be called once the mutex should be released again.\n        release();\n      }\n    } else {\n      // wait until the mutex is available without locking it\n      await mutex.waitForUnlock();\n      result = await baseQuery(args, api, extraOptions);\n    }\n  }\n  return result;\n};\n</code></pre>"},{"location":"frontend/query/rtk-query-header/#topic","title":"Topic","text":"<p>1. Accessing Data from Redux Persist in a React Component</p> <p>If you are using Redux Persist, you can simply use <code>useSelector</code> (a React-Redux hook) to access the persisted data from your Redux store. Redux Persist will automatically rehydrate the store when the page reloads.</p> <pre><code>import React from \"react\";\nimport { useSelector } from \"react-redux\";\n\nconst MyComponent = () =&gt; {\n  // Accessing persisted data from Redux store\n  const token = useSelector((state) =&gt; state.auth.token);\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Token from Redux Persist: {token}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default MyComponent;\n</code></pre> <p>In the above example, <code>token</code> is stored in your Redux store (perhaps in the <code>auth</code> slice of your state), and since you're using Redux Persist, it will persist the token in the browser's localStorage or sessionStorage. When the page reloads, the token will be automatically rehydrated and made available through the Redux state.</p> <p>2. Accessing Data from Redux Persist in Non-Component Files (Outside React)</p> <p>If you need to access the persisted data outside of React components, such as in a regular JavaScript file or a middleware, you can use Redux directly, but keep in mind that Redux Persist is just a middleware that rehydrates your store when the app loads.</p> <p>You can access persisted data like this:</p> <pre><code>import { store } from \"./store\"; // Assuming you have exported your store\n\n// Accessing persisted data from Redux state\nconst token = store.getState().auth.token;\n\nconsole.log(token);\n</code></pre>"},{"location":"frontend/query/rtk-query-header/#reference_1","title":"Reference","text":"<ul> <li>Migrating to Modern Redux</li> <li>How to add an Authorization header through middleware in an RTK query? : reddit</li> <li>Setting default headers on requests: rtk query</li> </ul>"},{"location":"frontend/query/rtk-query-header/#need-to-read","title":"Need to Read","text":"<ul> <li>The Ultimate Guide to Implementing Secure Redux Authentication</li> <li>prepare headers getState token for server side request   #2165</li> <li>refresh-token-redux-toolkit: github</li> </ul>"},{"location":"frontend/query/rtk-transform/","title":"RTK Transform","text":"<p>rtk transform</p> <pre><code>export const countryApi = createApi({\n  reducerPath: \"countryApi\",\n  baseQuery: axiosBaseQuery({\n    baseUrl: CONFIG.API_BASE_URL,\n  }),\n  tagTypes: [\"Country\"],\n  endpoints: (builder) =&gt; ({\n    getCountry: builder.query({\n      query: () =&gt; ({ url: \"Country\", method: \"get\" }),\n      // transformResponse: (response) =&gt;\n      //   response.filter((country) =&gt; country.isActive !== false),\n      transformResponse: (response) =&gt; {\n        logger.info({ msg: \"RESPONSE: \", response });\n        return response.filter((country) =&gt; country.isActive !== false);\n      },\n      providesTags: [\"Country\"],\n    }),\n  }),\n});\n</code></pre>"},{"location":"frontend/query/rtk-transform/#rtk-query-sorting","title":"RTK Query <code>Sorting</code>","text":"<p>To sort the data in the response from an RTK Query API call, you can leverage the <code>transformResponse</code> function to sort the data before it's passed to your component or store. This function allows you to manipulate the API response, including sorting the data, before it is stored in your Redux store or used in your component.</p> <p>Example: Sorting Response Data in RTK Query</p> <ol> <li>Define the API slice using <code>createApi</code>.</li> <li>Use the <code>transformResponse</code> option to sort the data.</li> </ol> Example CodeExplanation <pre><code>import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';\n\nexport const myApi = createApi({\n    reducerPath: 'myApi',\n    baseQuery: fetchBaseQuery({ baseUrl: 'https://example.com/api/' }),\n    endpoints: (builder) =&gt; ({\n        fetchData: builder.query({\n        query: () =&gt; 'data',  // Replace with your actual endpoint\n        transformResponse: (response) =&gt; {\n            // Sorting the response data (example: sorting by 'name' property)\n            return response.sort((a, b) =&gt; a.name.localeCompare(b.name));\n        },\n        }),\n    }),\n});\n\nexport const { useFetchDataQuery } = myApi;\n</code></pre> <ol> <li><code>transformResponse</code>: This function is executed after the API call and before the data is stored in the Redux state. In this example, we are sorting the response array based on the <code>name</code> property (you can adjust it based on your data structure).</li> <li><code>localeCompare</code>: This method is used for string comparison to sort by the <code>name</code> field. If you're sorting by numbers or other types of data, you can adjust the sorting logic accordingly.</li> </ol> <p>Sorting by Other Criteria</p> <p>If you want to sort by a numeric value or another property, simply adjust the sorting logic within <code>transformResponse</code>. For example, if you are sorting by <code>date</code> or a numeric field, you can modify it like so:</p> <pre><code>transformResponse: (response) =&gt; {\n  return response.sort((a, b) =&gt; new Date(a.date) - new Date(b.date)); // Sorting by date field\n};\n</code></pre> Key Takeaways <ol> <li>Use <code>transformResponse</code> in RTK Query to modify the response data before it's passed to your components.</li> <li>You can sort the data by any criteria (strings, numbers, dates, etc.) within the <code>transformResponse</code> function.</li> <li>The sorted data will automatically be available in the component when the query data is fetched.</li> </ol> <p>This approach ensures that the data is always sorted before it's available for rendering or further processing in your application</p>"},{"location":"frontend/query/rtk-transform/#example","title":"Example","text":"BasicWith SafetyKey Improvements Explained <pre><code>import { createApi, fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\n\nexport const myApi = createApi({\n    reducerPath: \"myApi\",\n    baseQuery: fetchBaseQuery({ baseUrl: \"https://example.com/api/\" }),\n    endpoints: (builder) =&gt; ({\n        fetchData: builder.query({\n            query: () =&gt; \"data\", // Replace with your actual endpoint\n            transformResponse: (response) =&gt; {\n                // Filter the response to only include items where isActive is true\n                const activeItems = response.filter((item) =&gt; item.isActive);\n\n                // Sort the filtered active items by 'name'\n                return activeItems.sort((a, b) =&gt; a.name.localeCompare(b.name));\n            },\n        }),\n    }),\n});\n\nexport const { useFetchDataQuery } = myApi;\n</code></pre> <pre><code>import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';\n\n// API slice definition\nexport const myApi = createApi({\n    reducerPath: 'myApi',\n    baseQuery: fetchBaseQuery({ baseUrl: 'https://example.com/api/' }),\n    endpoints: (builder) =&gt; ({\n        fetchData: builder.query({\n            query: () =&gt; 'data',  // Replace with your actual endpoint\n            transformResponse: (response) =&gt; {\n                try {\n                    // Filter: Only keep active items\n                    const activeItems = response.filter(item =&gt; item.isActive);\n\n                    // Sort: Safely sort by 'name', ensuring both a and b are strings\n                    const sortedItems = activeItems.sort((a, b) =&gt; {\n                        if (!a.name || !b.name) return 0; // Handle edge cases where name might be missing\n                        return a.name.localeCompare(b.name);\n                    });\n\n                    return sortedItems;\n                } catch (error) {\n                    console.error('Error while transforming response:', error);\n                    return [];  // Fallback to an empty array in case of errors\n                }\n            },\n        }),\n    }),\n});\n\nexport const { useFetchDataQuery } = myApi;\n</code></pre> <ul> <li> <p>Error Handling with <code>try-catch</code>: Wrapping the transformation logic in a <code>try-catch</code> block helps handle any unexpected errors that might occur during filtering or sorting (e.g., if the data structure is not as expected). In case of an error, we return an empty array (<code>[]</code>) as a fallback, but you could also return <code>null</code> or handle it differently depending on the requirements.</p> </li> <li> <p>Null Safety in Sorting: While sorting, we check if both <code>a.name</code> and <code>b.name</code> exist. If either <code>name</code> field is missing (<code>null</code> or <code>undefined</code>), we return <code>0</code> to avoid errors. This ensures that items without a <code>name</code> are not causing issues during the sorting operation.</p> </li> <li> <p>Code Comments: Adding comments to each section helps explain what's happening, making the code more maintainable for future developers (or yourself).</p> </li> <li> <p>Optional: TypeScript Enhancements: If you're using TypeScript, consider adding types to the API response, the <code>item</code> object, and the <code>transformResponse</code> function to improve type safety.</p> </li> </ul> Best Practice <p>If you're unsure whether <code>response</code> or <code>item</code> can be null or undefined, it's safer to use the optional chaining version:</p> <pre><code>const activeItems = response?.filter(item =&gt; item?.isActive);\n</code></pre>"},{"location":"frontend/query/rtk-vs-tanstack/","title":"RTK vs TanStack","text":""},{"location":"frontend/query/rtk-vs-tanstack/#does-tanstack-query-replace-redux-mobx-or-other-global-state-managers","title":"Does TanStack Query replace Redux, MobX or other global state managers?","text":"<ul> <li>TanStack Query is a server-state library, responsible for managing asynchronous operations between your server and client</li> <li>Redux, MobX, Zustand, etc. are client-state libraries that can be used to store asynchronous data, albeit inefficiently when compared to a tool like TanStack Query</li> </ul>"},{"location":"frontend/query/rtk-vs-tanstack/#client-state-vs-server-state","title":"Client State vs. Server State","text":"<p>What Apollo gives you is not just the ability to describe which data you want and to fetch that data, it also comes with a cache for that server data. This means that you can just use the same <code>useQuery</code> hook in multiple components, and it will only fetch data once and then subsequently return it from the cache.</p> <p>This sounds very familiar with what we, and probably many other teams as well, have mainly been using <code>redux</code> for: Fetch data from the server and make it available everywhere.</p> <p>So it seems that we have always been treating this server state like any other client state. Except that when it comes to server state (think: A list of articles that you fetch, the details of a User you want to display, ...), your app does not own it. We have only borrowed it to display the most recent version of it on the screen for the user. It is the server who owns the data.</p> <p>To me, that introduced a paradigm shift in how to think about data. If we can leverage the cache to display data that we do not own, there isn't really much left that is real client state that also needs to be made available to the whole app. That made me understand why many think that Apollo can replace redux in lots of instances.</p>"},{"location":"frontend/query/rtk-vs-tanstack/#reference","title":"Reference","text":"<ul> <li>RTK Query vs React/TanStack Query: A Comprehensive Comparison for Frontend Developers.</li> <li>Rtk query or tanstack</li> <li>TanStack Query (FKA React Query): official</li> <li>Rendering paginated data in React with useInfiniteQuery: tanstack</li> <li>Zustand vs. RTK Query vs. TanStack Query: Unpacking the React State Management Toolbox</li> <li>TanStack Query vs. Redux: The Ultimate Guide to API Data Handling in React Native</li> <li>Tanstack react query or rtk query</li> <li>RTK Query vs. TanStack Query \u2013 A Developer's Perspective</li> <li>React Query vs RTK Query: A Comprehensive Comparison</li> <li>What is the main difference between React Query and Redux? : stackoverflow</li> <li>Like react-query and redux? You'll love RTK Query </li> <li>RTK Query Vs. React Query: Breaking Down the Technicalities</li> <li>How we migrated from Redux to TanStack Query and Redux Toolkit</li> </ul> <p>Comparision</p> <ul> <li>Comparison | React Query vs SWR vs Apollo vs RTK Query vs React Router</li> <li>Tanstack Query vs RTK Query: gist</li> </ul>"},{"location":"frontend/react/intro/","title":"Intro","text":""},{"location":"frontend/react/intro/#programming-paradigm","title":"Programming Paradigm","text":"<ul> <li>imperative (how to do)</li> <li>declarative (what to do)</li> </ul>"},{"location":"frontend/react/intro/#react-is-declarative","title":"React is declarative","text":"<p>In declarative programming, you concentrate on the \"<code>what</code>\". Not the \"<code>how</code>\". For instance, the following snippet tells your app to serve certain pages at the given route-paths.</p> <p>Libraries:</p> <ul> <li>React</li> <li>React-Router</li> <li>React-Apollo (GraphQL)</li> <li>Styled-Components</li> <li>Express</li> <li>Infrastructure-Components</li> </ul> <p>Notes</p> <ul> <li> <p><code>React.js</code> removed the boundaries between HTML and JavaScript. It uses the Javascript   Syntax Extension (JSX) that complements basic Javascript source code with HTML.</p> </li> <li> <p><code>Styled-Components</code> added a convenient way of styling your React-components. There\u2019s no   need for global style sheets anymore.</p> </li> <li> <p>With <code>Infrastructure-Components</code>, you can integrate REST-services into your React app. As   well as database schemes and queries. You can even configure your serverless infrastructure.</p> </li> </ul> <p>life is an experiment. The more experiments you make the better. - Ralph Waldo Emerson</p>"},{"location":"frontend/react/intro/#different-ways-to-scaffold-a-react-application","title":"Different Ways to Scaffold a React Application","text":"<p>There are several ways to create and scaffold a React application. Here are some of the most popular methods:</p>"},{"location":"frontend/react/intro/#1-create-react-app-cra","title":"1. Create React App (CRA)","text":"<p>Create React App is an officially supported way to create single-page React applications. It offers a modern build setup with no configuration.</p> Installation:<pre><code>npx create-react-app my-app\ncd my-app\nnpm start\n</code></pre>"},{"location":"frontend/react/intro/#2-vite","title":"2. Vite","text":"<p>Vite is a fast build tool that offers an alternative to Create React App with a focus on speed and performance.</p> Installation:<pre><code>npm create vite@latest my-app --template react\ncd my-app\nnpm install\nnpm run dev\n</code></pre>"},{"location":"frontend/react/intro/#3-nextjs","title":"3. Next.js","text":"<p>Next.js is a powerful framework built on top of React for building server-side rendered (SSR) and statically generated (SSG) websites.</p> Installation:<pre><code>npx create-next-app@latest my-app\ncd my-app\nnpm run dev\n</code></pre>"},{"location":"frontend/react/intro/#4-gatsby","title":"4. Gatsby","text":"<p>Gatsby is a React-based framework for building fast static websites and apps.</p> Installation:<pre><code>npm install -g gatsby-cli\ngatsby new my-app\ncd my-app\ngatsby develop\n</code></pre>"},{"location":"frontend/react/intro/#5-parcel","title":"5. Parcel","text":"<p>Parcel is a web application bundler that can also be used to scaffold a React project with zero configuration.</p> Installation:<pre><code>mkdir my-app\ncd my-app\nnpm init -y\nnpm install react react-dom parcel\n</code></pre> Project Structure: <ol> <li> <p>Create an <code>index.html</code> file:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;My App&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"app\"&gt;&lt;/div&gt;\n    &lt;script src=\"index.js\"&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> </li> <li> <p>Create an <code>index.js</code> file:</p> <pre><code>import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nconst App = () =&gt; &lt;div&gt;Hello, world!&lt;/div&gt;;\n\nReactDOM.render(&lt;App /&gt;, document.getElementById(\"app\"));\n</code></pre> </li> </ol> <p>Start the development server:</p> <pre><code>npx parcel index.html\n</code></pre>"},{"location":"frontend/react/intro/#6-manual-setup-with-webpack-and-babel","title":"6. Manual Setup with Webpack and Babel","text":"<p>For more control over the configuration, you can set up a React project manually using Webpack and Babel.</p> Installation:<pre><code>mkdir my-app\ncd my-app\nnpm init -y\nnpm install react react-dom webpack webpack-cli webpack-dev-server babel-loader @babel/core @babel/preset-env @babel/preset-react html-webpack-plugin\n</code></pre> Configuration <ol> <li> <p>Create a <code>webpack.config.js</code> file:</p> <pre><code>const path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: ['@babel/preset-env', '@babel/preset-react']\n          }\n        }\n      }\n    ]\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html'\n    })\n  ],\n  devServer: {\n    contentBase: './dist'\n  }\n};\n</code></pre> </li> <li> <p>Create a <code>.babelrc</code> file:</p> <pre><code>{\n  \"presets\": [\"@babel/preset-env\", \"@babel/preset-react\"]\n}\n</code></pre> </li> <li> <p>Create an <code>index.html</code> file in src:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;My App&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"app\"&gt;&lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> </li> <li> <p>Create a <code>.babelrc</code> file:</p> <pre><code>import React from 'react';\nimport ReactDOM from 'react-dom';\n\nconst App = () =&gt; &lt;div&gt;Hello, world!&lt;/div&gt;;\n\nReactDOM.render(&lt;App /&gt;, document.getElementById('app'));\n</code></pre> </li> </ol> <p>Start the development server:</p> <pre><code>npx webpack serve\n</code></pre> <p>These methods cover a range of scenarios from quick setups with Create React App to more complex configurations with Next.js and manual setups using Webpack. Choose the one that best fits your project's needs.</p>"},{"location":"frontend/react/intro/#recommendation","title":"Recommendation","text":"<p>For most modern React projects, Next.js is a highly recommended choice due to its flexibility, performance benefits, and future-proof features. It supports a wide range of use cases, from simple SPAs to complex, SEO-friendly applications.</p> <p>Create React App is also a solid choice for simpler projects or for those who prefer minimal configuration and an easy setup process. However, as projects scale, you might find the need to switch to a more flexible solution like Next.js.</p> <p>Vite is gaining traction and can be an excellent choice for developers who prioritize build speed and modern tooling.</p> <p>Gatsby remains a strong option for static site generation and content-driven projects.</p> <p>Ultimately, the choice depends on your project requirements, team familiarity, and long-term goals. All of these tools have strong communities and regular updates, ensuring they remain relevant and useful for years to come.</p>"},{"location":"frontend/react/intro/#reference","title":"Reference","text":"<ul> <li> <p>React-Architect by Dr.Frank Zickert</p> </li> <li> <p>What is Programming Paradigm?</p> </li> </ul>"},{"location":"frontend/react/philosophy/","title":"Philosophy","text":"<p>The main philosophy of React revolves around several key principles that shape how it addresses user interface development. Here\u2019s a summary of the core philosophies behind React:</p>"},{"location":"frontend/react/philosophy/#1-declarative-ui","title":"1. Declarative UI:","text":"<p>React emphasizes a declarative approach to building user interfaces. Instead of describing the sequence of steps needed to achieve a result (imperative programming), you describe what the UI should look like based on the current state (declarative programming). React then handles the process of updating the UI efficiently when the state changes.</p> <ul> <li> <p>Declarative Example:</p> <pre><code>function MyComponent({ isVisible }) {\n    return isVisible ? &lt;div&gt;Visible&lt;/div&gt; : &lt;div&gt;Hidden&lt;/div&gt;;\n}\n</code></pre> <p>In this example, you describe what the UI should look like based on the <code>isVisible</code> prop, and React takes care of updating the DOM accordingly.</p> </li> </ul>"},{"location":"frontend/react/philosophy/#2-component-based-architecture","title":"2. Component-Based Architecture:","text":"<p>React promotes building user interfaces through reusable components. Each component is a self-contained piece of the UI that manages its own state and logic. Components can be composed together to build more complex UIs.</p> <ul> <li> <p>Component Example:</p> <pre><code>function Button({ onClick, children }) {\n    return &lt;button onClick={onClick}&gt;{children}&lt;/button&gt;;\n}\n\nfunction App() {\n    return &lt;Button onClick={() =&gt; alert('Clicked!')}&gt;Click Me&lt;/Button&gt;;\n}\n</code></pre> <p>Here, <code>Button</code> is a reusable component that can be used throughout your application.</p> </li> </ul>"},{"location":"frontend/react/philosophy/#3-virtual-dom","title":"3. Virtual DOM:","text":"<p>React uses a virtual DOM to optimize rendering performance. Instead of directly manipulating the browser\u2019s DOM, React maintains a lightweight virtual representation of the UI. When a component\u2019s state changes, React updates the virtual DOM first and then efficiently applies the changes to the real DOM. This minimizes the number of costly DOM operations and improves performance.</p> <ul> <li>Virtual DOM Example: When state changes, React calculates the difference between the current virtual DOM and the new virtual DOM and updates only the parts of the real DOM that have changed.</li> </ul>"},{"location":"frontend/react/philosophy/#4-unidirectional-data-flow","title":"4. Unidirectional Data Flow:","text":"<p>React enforces a unidirectional data flow, meaning that data flows from parent components to child components through props. This makes the data flow predictable and easier to debug, as you can trace how data changes across the component tree.</p> <ul> <li> <p>Data Flow Example:</p> <pre><code>function ParentComponent() {\n    const [value, setValue] = React.useState('Hello');\n\n    return &lt;ChildComponent text={value} /&gt;;\n}\n\nfunction ChildComponent({ text }) {\n    return &lt;div&gt;{text}&lt;/div&gt;;\n}\n</code></pre> <p>In this example, <code>ParentComponent</code> passes <code>value</code> as a prop to <code>ChildComponent</code>, ensuring a clear and predictable flow of data.</p> </li> </ul>"},{"location":"frontend/react/philosophy/#5-single-responsibility-principle","title":"5. Single Responsibility Principle:","text":"<p>Each component in React is designed to have a single responsibility. This means components should do one thing and do it well. This principle encourages modular and maintainable code.</p> <ul> <li> <p>Single Responsibility Example:</p> <p>A component should ideally focus on one aspect of the UI, such as rendering a list, handling user input, or displaying a form. Combining multiple responsibilities into a single component can lead to complexity and difficulty in managing and testing the component.</p> </li> </ul>"},{"location":"frontend/react/philosophy/#6-reusability-and-composition","title":"6. Reusability and Composition:","text":"<p>React encourages the creation of reusable components that can be composed to build complex UIs. By composing smaller, reusable components, you can create more maintainable and scalable applications.</p> <ul> <li> <p>Composition Example:</p> <pre><code>function Layout({ header, main, footer }) {\n    return (\n        &lt;div&gt;\n            &lt;header&gt;{header}&lt;/header&gt;\n            &lt;main&gt;{main}&lt;/main&gt;\n            &lt;footer&gt;{footer}&lt;/footer&gt;\n        &lt;/div&gt;\n    );\n}\n\nfunction App() {\n    return (\n        &lt;Layout\n            header={&lt;Header /&gt;}\n            main={&lt;MainContent /&gt;}\n            footer={&lt;Footer /&gt;}\n        /&gt;\n    );\n}\n</code></pre> <p>Here, <code>Layout</code> is a component that composes other components (<code>Header</code>, <code>MainContent</code>, <code>Footer</code>) to create a complete layout.</p> </li> </ul>"},{"location":"frontend/react/philosophy/#summary","title":"Summary:","text":"<p>The philosophy of React centers around:</p> <ul> <li>Declarative UI: Describe what the UI should look like.</li> <li>Component-Based Architecture: Build UIs from reusable components.</li> <li>Virtual DOM: Optimize updates and rendering.</li> <li>Unidirectional Data Flow: Maintain predictable data flow.</li> <li>Single Responsibility Principle: Focus each component on a single task.</li> <li>Reusability and Composition: Create modular and scalable UIs.</li> </ul> <p>These principles together enable developers to build complex, interactive, and high-performance user interfaces efficiently and maintainably.</p>"},{"location":"frontend/react/example/breaking-react-component-pattern/","title":"How to break react components","text":"<pre><code>Component Decomposition\nContainer and Presentational Components\nHigher-Order Components (HOCs)\nRender Props\nCustom Hooks\nContext API\nComposition Over Inheritance\n</code></pre> <p>Breaking components into smaller, manageable pieces is essential for maintaining a clean and scalable React application. Here are some of the most useful React patterns for breaking components effectively:</p>"},{"location":"frontend/react/example/breaking-react-component-pattern/#1-component-decomposition","title":"1. Component Decomposition","text":"<p>Break down large components into smaller, reusable ones based on their functionality or UI elements. This makes each component simpler and easier to maintain.</p> Example jsx<pre><code>// Large Component\nconst UserProfile = () =&gt; (\n    &lt;div&gt;\n        &lt;Avatar /&gt;\n        &lt;UserInfo /&gt;\n        &lt;UserPosts /&gt;\n    &lt;/div&gt;\n);\n\n// Smaller Components\nconst Avatar = () =&gt; &lt;img src=\"avatar.jpg\" alt=\"User Avatar\" /&gt;;\n    const UserInfo = () =&gt; (\n    &lt;div&gt;\n        &lt;h2&gt;John Doe&lt;/h2&gt;\n        &lt;p&gt;john.doe@example.com&lt;/p&gt;\n    &lt;/div&gt;\n    );\n    const UserPosts = () =&gt; (\n    &lt;ul&gt;\n        &lt;li&gt;First Post&lt;/li&gt;\n        &lt;li&gt;Second Post&lt;/li&gt;\n    &lt;/ul&gt;\n);\n</code></pre>"},{"location":"frontend/react/example/breaking-react-component-pattern/#2-container-and-presentational-components","title":"2. Container and Presentational Components","text":"<p>Separate components into container (stateful) and presentational (stateless) components. Containers handle logic and state, while presentational components handle rendering.</p> Example jsx<pre><code>// Container Component\nconst UserProfileContainer = () =&gt; {\n    const [user, setUser] = useState({ name: 'John Doe', email: 'john.doe@example.com' });\n    return &lt;UserProfile user={user} /&gt;;\n};\n\n// Presentational Component\nconst UserProfile = ({ user }) =&gt; (\n    &lt;div&gt;\n        &lt;h2&gt;{user.name}&lt;/h2&gt;\n        &lt;p&gt;{user.email}&lt;/p&gt;\n    &lt;/div&gt;\n);\n</code></pre>"},{"location":"frontend/react/example/breaking-react-component-pattern/#3-higher-order-components-hocs","title":"3. Higher-Order Components (HOCs)","text":"<p>Use HOCs to enhance components with additional functionality, such as adding authentication or fetching data.</p> Example jsx<pre><code>// Higher-Order Component\nconst withUserData = (WrappedComponent) =&gt; {\n    return (props) =&gt; {\n        const [user, setUser] = useState(null);\n\n        useEffect(() =&gt; {\n        // Fetch user data\n        setUser({ name: 'John Doe', email: 'john.doe@example.com' });\n        }, []);\n\n        return &lt;WrappedComponent user={user} {...props} /&gt;;\n    };\n};\n\n// Wrapped Component\nconst UserProfile = ({ user }) =&gt; (\n    &lt;div&gt;\n        &lt;h2&gt;{user ? user.name : 'Loading...'}&lt;/h2&gt;\n        &lt;p&gt;{user ? user.email : ''}&lt;/p&gt;\n    &lt;/div&gt;\n);\n\nconst EnhancedUserProfile = withUserData(UserProfile);\n</code></pre>"},{"location":"frontend/react/example/breaking-react-component-pattern/#4-render-props","title":"4. Render Props","text":"<p>Use render props to share code between components by passing a function as a prop that returns React elements.</p> Example jsx<pre><code>// Component with Render Props\nconst DataProvider = ({ render }) =&gt; {\n    const [data, setData] = useState('Hello World');\n\n    return render(data);\n};\n\n// Usage\nconst App = () =&gt; (\n    &lt;DataProvider render={(data) =&gt; &lt;div&gt;{data}&lt;/div&gt;} /&gt;\n);\n</code></pre>"},{"location":"frontend/react/example/breaking-react-component-pattern/#5-custom-hooks","title":"5. Custom Hooks","text":"<p>Create custom hooks to encapsulate reusable logic and state management, which can then be used across multiple components.</p> Example jsx<pre><code>// Custom Hook\nconst useCounter = () =&gt; {\n    const [count, setCount] = useState(0);\n\n    const increment = () =&gt; setCount(count + 1);\n    const decrement = () =&gt; setCount(count - 1);\n\n    return { count, increment, decrement };\n};\n\n// Component using Custom Hook\nconst Counter = () =&gt; {\n    const { count, increment, decrement } = useCounter();\n\n    return (\n        &lt;div&gt;\n        &lt;p&gt;Count: {count}&lt;/p&gt;\n        &lt;button onClick={increment}&gt;Increment&lt;/button&gt;\n        &lt;button onClick={decrement}&gt;Decrement&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n</code></pre>"},{"location":"frontend/react/example/breaking-react-component-pattern/#6-context-api","title":"6. Context API","text":"<p>Use the Context API to manage global state and avoid prop drilling by providing data to all components within a provider.</p> Example jsx<pre><code>// Context\nconst ThemeContext = createContext();\n\n// Provider Component\nconst ThemeProvider = ({ children }) =&gt; {\n    const [theme, setTheme] = useState('light');\n\n    return (\n        &lt;ThemeContext.Provider value={{ theme, setTheme }}&gt;\n        {children}\n        &lt;/ThemeContext.Provider&gt;\n    );\n};\n\n// Consuming Context\nconst ThemedComponent = () =&gt; {\n    const { theme } = useContext(ThemeContext);\n\n    return &lt;div className={theme}&gt;Current Theme: {theme}&lt;/div&gt;;\n};\n</code></pre>"},{"location":"frontend/react/example/breaking-react-component-pattern/#7-composition-over-inheritance","title":"7. Composition Over Inheritance","text":"<p>Leverage composition to build components with flexible and reusable parts, rather than relying on inheritance or deeply nested components.</p> Example jsx<pre><code>// Composition\nconst Panel = ({ header, children }) =&gt; (\n    &lt;div className=\"panel\"&gt;\n        &lt;div className=\"panel-header\"&gt;{header}&lt;/div&gt;\n        &lt;div className=\"panel-body\"&gt;{children}&lt;/div&gt;\n    &lt;/div&gt;\n);\n\n// Usage\nconst App = () =&gt; (\n    &lt;Panel header=\"Panel Header\"&gt;\n        &lt;p&gt;Panel Body Content&lt;/p&gt;\n    &lt;/Panel&gt;\n);\n</code></pre>"},{"location":"frontend/react/example/breaking-react-component-pattern/#summary","title":"Summary","text":"<p>By using these patterns, you can create more maintainable, reusable, and modular React components. Each pattern has its own use cases and benefits, and often, a combination of these patterns will be used to achieve the desired structure and behavior in a React application.</p>"},{"location":"frontend/react/example/children-prop/","title":"Children Prop","text":"<p>In React, children is a special prop that allows you to pass components or elements to a component as its children. This enables the creation of more flexible and reusable components by allowing them to render nested content. What is children?</p> <p>The children prop is a special prop in React that represents the content between the opening and closing tags of a component. This content can be other React components, elements, or plain text.</p>"},{"location":"frontend/react/example/children-prop/#how-children-relates-to-react","title":"How <code>children</code> Relates to React","text":"<p>The <code>children</code> prop is a core feature of React's composition model. It enables components to:</p> <ul> <li>Encapsulate and Render Nested Content: Components can render nested elements or components within their own output.</li> <li>Create Reusable Layouts: Layout components like modals, dialogs, or containers can use children to render dynamic content.</li> </ul>"},{"location":"frontend/react/example/children-prop/#how-to-use-children","title":"How to Use children","text":"<ol> <li> <p>Basic Usage:</p> <p>You can use <code>children</code> to render any content that is passed between the opening and closing tags of a component.</p> Example<pre><code>const Wrapper = ({ children }) =&gt; (\n    &lt;div className=\"wrapper\"&gt;\n        {children}\n    &lt;/div&gt;\n);\n\nconst App = () =&gt; (\n    &lt;Wrapper&gt;\n        &lt;h1&gt;Hello, World!&lt;/h1&gt;\n        &lt;p&gt;This is some content inside the Wrapper component.&lt;/p&gt;\n    &lt;/Wrapper&gt;\n);\n\nexport default App;\n</code></pre> <p>In this example, the Wrapper component uses the children prop to render whatever is passed inside its tags.</p> </li> <li> <p>Rendering Multiple Children:</p> <p>children can be a single element, a list of elements, or even a mix of both.</p> jsx<pre><code>const List = ({ children }) =&gt; (\n    &lt;ul&gt;\n        {React.Children.map(children, (child) =&gt; (\n        &lt;li&gt;{child}&lt;/li&gt;\n        ))}\n    &lt;/ul&gt;\n);\n\nconst App = () =&gt; (\n    &lt;List&gt;\n        &lt;span&gt;Item 1&lt;/span&gt;\n        &lt;span&gt;Item 2&lt;/span&gt;\n        &lt;span&gt;Item 3&lt;/span&gt;\n    &lt;/List&gt;\n);\n\nexport default App;\n</code></pre> <p>In this example, the <code>List</code> component takes multiple <code>children</code> elements and renders them as list items.</p> </li> <li> <p>Using <code>React.Children</code> Utilities:</p> <p>React provides utility methods for working with <code>children</code>, such as <code>React.Children.map</code>, <code>React.Children.forEach</code>, and <code>React.Children.toArray</code>.</p> jsx<pre><code>const Parent = ({ children }) =&gt; (\n    &lt;div&gt;\n        {React.Children.map(children, (child, index) =&gt; (\n        &lt;div key={index}&gt;{child}&lt;/div&gt;\n        ))}\n    &lt;/div&gt;\n);\n\nconst App = () =&gt; (\n    &lt;Parent&gt;\n        &lt;p&gt;First Child&lt;/p&gt;\n        &lt;p&gt;Second Child&lt;/p&gt;\n    &lt;/Parent&gt;\n);\n\nexport default App;\n</code></pre> <p>In this example, <code>React.Children.map</code> is used to iterate over and render each child within a <code>div</code>.</p> </li> <li> <p>Conditional Rendering of <code>children</code>:</p> <p>You can conditionally render <code>children</code> based on some logic.</p> <pre><code>const ConditionalWrapper = ({ condition, children }) =&gt; (\n    &lt;div&gt;\n        {condition ? children : &lt;p&gt;No content available&lt;/p&gt;}\n    &lt;/div&gt;\n);\n\nconst App = () =&gt; (\n    &lt;ConditionalWrapper condition={true}&gt;\n        &lt;p&gt;This content will be displayed.&lt;/p&gt;\n    &lt;/ConditionalWrapper&gt;\n);\n\nexport default App;\n</code></pre> </li> </ol>"},{"location":"frontend/react/example/children-prop/#summary","title":"Summary","text":"<p>The <code>children</code> prop in React is a powerful feature that allows components to render nested content dynamically. It helps in creating flexible and reusable components by enabling them to accept and render various types of content. By understanding and utilizing <code>children</code>, you can build more modular and maintainable React applications.</p>"},{"location":"frontend/react/example/component-composition/","title":"Component Composition","text":"<p>Component composition is a fundamental concept in React that involves building complex UIs by combining smaller, reusable components. It allows developers to create more manageable, modular, and maintainable code. Instead of creating large monolithic components, you can break them down into smaller, self-contained components that can be composed together to form the final UI.</p> <p>Practice creating small, reusable components and composing them into larger components.</p>"},{"location":"frontend/react/example/component-composition/#react-patterns-for-breaking-down-components","title":"React Patterns for Breaking Down Components","text":"<ul> <li> <p> 1. Presentational and Container Components:</p> <p>how things look &amp; how things work</p> <p> Getting started</p> </li> <li> <p> 2. Higher-Order Components (HOCs)</p> <p>Use HOCs to add common functionality to components. For example, you might have an HOC to handle form submission logic.</p> <p> Getting started</p> </li> <li> <p> 3. Render Props</p> <p>Render props is a pattern for sharing code between React components using a prop whose value is a function.</p> <p> Getting started</p> </li> </ul>"},{"location":"frontend/react/example/component-composition/#key-principles-of-component-composition","title":"Key Principles of Component Composition","text":"<ol> <li>Reusability: Create components that can be reused across different parts of your application.</li> <li>Single Responsibility: Each component should have a single responsibility, making it easier to understand and maintain.</li> <li>Separation of Concerns: Separate the concerns of different parts of your application into different components.</li> <li>Declarative Syntax: Use a declarative syntax to define how components should be composed together.</li> </ol>"},{"location":"frontend/react/example/component-composition/#example","title":"Example","text":"<p>Let's look at an example where we compose a user profile page using smaller components.</p> <ol> <li> <p>Basic Components:</p> jsx<pre><code>// Avatar.js\nconst Avatar = ({ url }) =&gt; &lt;img src={url} alt=\"User Avatar\" /&gt;;\n\n// UserInfo.js\nconst UserInfo = ({ name, email }) =&gt; (\n&lt;div&gt;\n    &lt;h2&gt;{name}&lt;/h2&gt;\n    &lt;p&gt;{email}&lt;/p&gt;\n&lt;/div&gt;\n);\n\n// UserPosts.js\nconst UserPosts = ({ posts }) =&gt; (\n&lt;ul&gt;\n    {posts.map(post =&gt; (\n    &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;\n    ))}\n&lt;/ul&gt;\n);\n</code></pre> </li> <li> <p>Composing the Components:</p> jsx<pre><code>// UserProfile.js\nimport Avatar from './Avatar';\nimport UserInfo from './UserInfo';\nimport UserPosts from './UserPosts';\n\nconst UserProfile = ({ user, posts }) =&gt; (\n&lt;div&gt;\n    &lt;Avatar url={user.avatarUrl} /&gt;\n    &lt;UserInfo name={user.name} email={user.email} /&gt;\n    &lt;UserPosts posts={posts} /&gt;\n&lt;/div&gt;\n);\n\nexport default UserProfile;\n</code></pre> </li> <li> <p>Using the Composed Component:</p> jsx<pre><code>// App.js\nimport UserProfile from './UserProfile';\n\nconst user = {\nname: 'John Doe',\nemail: 'john.doe@example.com',\navatarUrl: 'https://example.com/avatar.jpg',\n};\n\nconst posts = [\n{ id: 1, title: 'First Post' },\n{ id: 2, title: 'Second Post' },\n];\n\nconst App = () =&gt; (\n&lt;div&gt;\n    &lt;UserProfile user={user} posts={posts} /&gt;\n&lt;/div&gt;\n);\n\nexport default App;\n</code></pre> </li> </ol>"},{"location":"frontend/react/example/component-composition/#benefits-of-component-composition","title":"Benefits of Component Composition","text":"<ul> <li>Maintainability: Smaller components are easier to understand and maintain.</li> <li>Reusability: Reusable components can be used in different parts of the application.</li> <li>Testability: Smaller components are easier to test individually.</li> <li>Scalability: Composing components makes it easier to scale the application as it grows.</li> </ul>"},{"location":"frontend/react/example/component-composition/#tips-for-effective-component-composition","title":"Tips for Effective Component Composition","text":"<ul> <li>Identify Common Patterns: Look for patterns in your UI that can be abstracted into reusable components.</li> <li>Use Prop Drilling and Context: Pass data and callbacks down the component tree via props or use React Context for deeper hierarchies.</li> <li>Follow Naming Conventions: Use clear and consistent naming conventions for your components to improve readability.</li> <li>Modularity: Keep components focused and modular, avoiding unnecessary dependencies between them.</li> </ul> <p>By mastering component composition, you can create a flexible and maintainable React application, leveraging the power of reusable components to build complex UIs efficiently.</p>"},{"location":"frontend/react/example/component-composition/#handling-missing-prop-values-in-react-components","title":"Handling Missing Prop Values in React Components","text":"<p>To handle cases where the props might not contain values, you can use default values, conditional rendering, and prop type validation. Here's how you can address these scenarios:</p> 1. Using Default Props <p>You can set default props to provide default values for your component's props. This way, if a prop is not provided, the component will use the default value.</p> jsx<pre><code>// UserInfo.js\nimport PropTypes from 'prop-types';\n\nconst UserInfo = ({ name, email }) =&gt; (\n    &lt;div&gt;\n        &lt;h2&gt;{name}&lt;/h2&gt;\n        &lt;p&gt;{email}&lt;/p&gt;\n    &lt;/div&gt;\n);\n\nUserInfo.defaultProps = {\n    name: 'Unknown User',\n    email: 'No email provided',\n};\n\nUserInfo.propTypes = {\n    name: PropTypes.string,\n    email: PropTypes.string,\n};\n\nexport default UserInfo;\n</code></pre> 2. Conditional Rendering <p>You can also use conditional rendering to handle cases where the props might not contain values.</p> <pre><code>// UserInfo.js\nimport PropTypes from 'prop-types';\n\nconst UserInfo = ({ name, email }) =&gt; (\n    &lt;div&gt;\n        &lt;h2&gt;{name ? name : 'Unknown User'}&lt;/h2&gt;\n        &lt;p&gt;{email ? email : 'No email provided'}&lt;/p&gt;\n    &lt;/div&gt;\n);\n\nUserInfo.propTypes = {\n    name: PropTypes.string,\n    email: PropTypes.string,\n};\n\nexport default UserInfo;\n</code></pre> 3. Combining Default Props and Conditional Rendering <p>Combining both approaches can provide a robust solution for handling missing prop values.</p> <pre><code>// UserInfo.js\nimport PropTypes from 'prop-types';\n\nconst UserInfo = ({ name, email }) =&gt; (\n    &lt;div&gt;\n        &lt;h2&gt;{name}&lt;/h2&gt;\n        &lt;p&gt;{email}&lt;/p&gt;\n    &lt;/div&gt;\n);\n\nUserInfo.defaultProps = {\n    name: 'Unknown User',\n    email: 'No email provided',\n};\n\nUserInfo.propTypes = {\n    name: PropTypes.string,\n    email: PropTypes.string,\n};\n\nexport default UserInfo;\n</code></pre> 4. Using Nullish Coalescing Operator (Optional) <p>For modern JavaScript, you can use the nullish coalescing operator (??) to provide fallback values.</p> <pre><code>// UserInfo.js\nimport PropTypes from 'prop-types';\n\nconst UserInfo = ({ name, email }) =&gt; (\n    &lt;div&gt;\n        &lt;h2&gt;{name ?? 'Unknown User'}&lt;/h2&gt;\n        &lt;p&gt;{email ?? 'No email provided'}&lt;/p&gt;\n    &lt;/div&gt;\n);\n\nUserInfo.propTypes = {\n    name: PropTypes.string,\n    email: PropTypes.string,\n};\n\nexport default UserInfo;\n</code></pre>"},{"location":"frontend/react/example/component-composition/#example-usage-in-userprofile-component","title":"Example Usage in UserProfile Component","text":"<p>Here's how you might use the <code>UserInfo</code> component in the UserProfile component with potential missing values.</p> <pre><code>// UserProfile.js\nimport Avatar from './Avatar';\nimport UserInfo from './UserInfo';\nimport UserPosts from './UserPosts';\n\nconst UserProfile = ({ user, posts }) =&gt; (\n  &lt;div&gt;\n    &lt;Avatar url={user?.avatarUrl ?? 'default-avatar.jpg'} /&gt;\n    &lt;UserInfo name={user?.name} email={user?.email} /&gt;\n    &lt;UserPosts posts={posts} /&gt;\n  &lt;/div&gt;\n);\n\nexport default UserProfile;\n</code></pre>"},{"location":"frontend/react/example/component-composition/#example-usage-in-app-component","title":"Example Usage in App Component","text":"<pre><code>// App.js\nimport UserProfile from './UserProfile';\n\nconst user = {\n  name: 'John Doe',\n  email: 'john.doe@example.com',\n  avatarUrl: 'https://example.com/avatar.jpg',\n};\n\nconst posts = [\n  { id: 1, title: 'First Post' },\n  { id: 2, title: 'Second Post' },\n];\n\nconst App = () =&gt; (\n  &lt;div&gt;\n    &lt;UserProfile user={user} posts={posts} /&gt;\n    {/* UserProfile with missing values */}\n    &lt;UserProfile user={{}} posts={posts} /&gt;\n  &lt;/div&gt;\n);\n\nexport default App;\n</code></pre> <p>By using these techniques, you can ensure that your components handle missing prop values gracefully, improving the robustness and user experience of your application.</p>"},{"location":"frontend/react/example/hoc/","title":"High Order Component","text":"<p>High-order components (HOCs) in React are a pattern where a function takes a component and returns a new component with enhanced functionality. Here are examples categorized into basic, intermediate, and advanced HOCs:</p> <p>Use HOCs to add common functionality to components.</p> simple example <p>Use HOCs to add common functionality to components.</p> <p>For example, you might have an HOC to handle form submission logic.</p> jsx<pre><code>// withFormSubmission.js\nconst withFormSubmission = (WrappedComponent) =&gt; {\nreturn (props) =&gt; {\n    const handleSubmit = (values) =&gt; {\n    // handle form submission logic here\n    console.log('Form submitted:', values);\n    };\n\n    return &lt;WrappedComponent {...props} onSubmit={handleSubmit} /&gt;;\n};\n};\n\nexport default withFormSubmission;\n\n// EnhancedUserForm.js\nimport withFormSubmission from './withFormSubmission';\nimport UserForm from './UserForm';\n\nconst EnhancedUserForm = withFormSubmission(UserForm);\n\nexport default EnhancedUserForm;\n</code></pre> Abstract <p>Why High-Order Component Naming Starts with \"with\"</p> <p>The convention of naming higher-order components (HOCs) with a prefix \"with\" comes from the idea of enhancing or augmenting the base component with additional functionality. This naming convention makes it clear that the HOC is wrapping and modifying the behavior or appearance of the original component.</p> <p>For example:</p> <ul> <li>withLogging indicates that the wrapped component will have logging functionality added.</li> <li>withAuthentication indicates that the wrapped component will have authentication checking added.</li> <li>withDataFetching indicates that the wrapped component will have data fetching capabilities added.</li> </ul> <p>Using \"with\" helps developers quickly understand that the function is not just a regular function but an HOC that will provide additional capabilities to the component it wraps.</p> <p>When to Use HOCs</p> <p>HOCs are useful in a variety of scenarios where you want to reuse component logic or behavior across multiple components without repeating code. Here are some common use cases for HOCs:</p> <ol> <li> <p>Cross-Cutting Concerns:</p> <ul> <li>Logging: Adding logging functionality to monitor the props being passed to the component.</li> <li>Error Handling: Wrapping a component in an error boundary to catch JavaScript errors anywhere in their child component tree.</li> </ul> </li> <li> <p>Code Reuse:</p> <ul> <li>Data Fetching: Encapsulating data fetching logic and reusing it across multiple components.</li> <li>Form Handling: Managing form state and submission logic that can be reused in different forms.</li> </ul> </li> <li> <p>Conditional Rendering:</p> <ul> <li>Authorization: Restricting access to certain components based on user roles or permissions.</li> <li>Feature Flags: Conditionally rendering components based on feature flags or configuration.</li> </ul> </li> <li> <p>Enhancing Components:</p> <ul> <li>Styling: Adding or modifying styles dynamically based on props or state.</li> <li>Animation: Adding animation logic to components.</li> </ul> </li> <li> <p>State Management:</p> <ul> <li>Global State: Connecting components to a global state management system (e.g., Redux).</li> </ul> </li> </ol>"},{"location":"frontend/react/example/hoc/#basic-hocs","title":"Basic HOCs","text":""},{"location":"frontend/react/example/hoc/#1-logging-props","title":"1. Logging Props","text":"Asbtract ExampleUsage javascript<pre><code>const withLogging = (WrappedComponent) =&gt; {\n    return (props) =&gt; {\n        console.log(props);\n        return &lt;WrappedComponent {...props} /&gt;;\n    };\n};\n\n// or\n\nconst withLogging = (WrappedComponent) =&gt; (props) =&gt; {\n    console.log(props);\n    return &lt;WrappedComponent {...props} /&gt;;\n};\n</code></pre> javascript<pre><code>const withLogging = (WrappedComponent) =&gt; (props) =&gt; {\n    console.log(props);\n    return &lt;WrappedComponent {...props} /&gt;;\n};\n\nconst SimpleComponent = (props) =&gt; &lt;div&gt;{props.message}&lt;/div&gt;;\n\nconst LoggedSimpleComponent = withLogging(SimpleComponent);\n\n// Usage\n&lt;LoggedSimpleComponent message=\"Hello, World!\" /&gt;;\n</code></pre>"},{"location":"frontend/react/example/hoc/#2-default-props","title":"2. Default Props","text":"Asbtract ExampleUsage javascript<pre><code>const withDefaultProps = (defaultProps) =&gt; (WrappedComponent) =&gt; {\n    return (props) =&gt; {\n        return &lt;WrappedComponent {...defaultProps} {...props} /&gt;;\n    };\n};\n\n// or\n\nconst withDefaultProps = (defaultProps) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    return &lt;WrappedComponent {...defaultProps} {...props} /&gt;;\n};\n</code></pre> javascript<pre><code>const withDefaultProps = (defaultProps) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    return &lt;WrappedComponent {...defaultProps} {...props} /&gt;;\n};\n\nconst SimpleComponent = (props) =&gt; &lt;div&gt;{props.message}&lt;/div&gt;;\n\nconst DefaultPropsComponent = withDefaultProps({ message: \"Default Message\" })(SimpleComponent);\n\n// Usage\n&lt;DefaultPropsComponent /&gt;; // Renders \"Default Message\"\n&lt;DefaultPropsComponent message=\"Custom Message\" /&gt;; // Renders \"Custom Message\"\n</code></pre>"},{"location":"frontend/react/example/hoc/#3-conditional-rendering","title":"3. Conditional Rendering","text":"Asbtract ExampleUsage javascript<pre><code>const withConditionalRendering = (conditionFn) =&gt; (WrappedComponent) =&gt; {\n    return (props) =&gt; {\n        if (conditionFn(props)) {\n            return &lt;WrappedComponent {...props} /&gt;;\n        } else {\n            return null;\n        }\n    };\n};\n\n// or\n\nconst withConditionalRendering = (conditionFn) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    return conditionFn(props) ? &lt;WrappedComponent {...props} /&gt; : null;\n};\n</code></pre> javascript<pre><code>const withConditionalRendering = (conditionFn) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    return conditionFn(props) ? &lt;WrappedComponent {...props} /&gt; : null;\n};\n\nconst SimpleComponent = (props) =&gt; &lt;div&gt;{props.message}&lt;/div&gt;;\n\nconst ConditionalComponent = withConditionalRendering((props) =&gt; props.show)(SimpleComponent);\n\n// Usage\n&lt;ConditionalComponent show={true} message=\"Visible Message\" /&gt;; // Renders \"Visible Message\"\n&lt;ConditionalComponent show={false} message=\"Invisible Message\" /&gt;; // Renders null\n</code></pre>"},{"location":"frontend/react/example/hoc/#4-adding-class-name","title":"4. Adding Class Name","text":"Asbtract ExampleUsage javascript<pre><code>const withClassName = (className) =&gt; (WrappedComponent) =&gt; {\n    return (props) =&gt; {\n        return &lt;WrappedComponent {...props} className={className} /&gt;;\n    };\n};\n\n// or\n\nconst withClassName = (className) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    return &lt;WrappedComponent {...props} className={className} /&gt;;\n};\n</code></pre> javascript<pre><code>const withClassName = (className) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    return &lt;WrappedComponent {...props} className={className} /&gt;;\n};\n\nconst SimpleComponent = (props) =&gt; &lt;div className={props.className}&gt;{props.message}&lt;/div&gt;;\n\nconst ClassNameComponent = withClassName(\"custom-class\")(SimpleComponent);\n\n// Usage\n&lt;ClassNameComponent message=\"Styled Message\" /&gt;;\n</code></pre>"},{"location":"frontend/react/example/hoc/#5-simple-error-boundary","title":"5. Simple Error Boundary","text":"Note Functional ComponentClass ComponentUsage javascript<pre><code>const withErrorBoundary = (WrappedComponent) =&gt; (props) =&gt; {\n    const [hasError, setHasError] = React.useState(false);\n\n    try {\n        return &lt;WrappedComponent {...props} /&gt;;\n    } catch (error) {\n        setHasError(true);\n        console.error(error);\n        return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;\n    }\n};\n</code></pre> javascript<pre><code>const withErrorBoundary = (WrappedComponent) =&gt; {\n    return class extends React.Component {\n        state = { hasError: false };\n\n        static getDerivedStateFromError() {\n            return { hasError: true };\n        }\n\n        componentDidCatch(error, errorInfo) {\n        console.error(error, errorInfo);\n        }\n\n        render() {\n            if (this.state.hasError) {\n                return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;\n            }\n            return &lt;WrappedComponent {...this.props} /&gt;;\n        }\n    };\n};\n</code></pre> <pre><code>const withErrorBoundary = (WrappedComponent) =&gt; (props) =&gt; {\nconst [hasError, setHasError] = React.useState(false);\n\n    try {\n        return &lt;WrappedComponent {...props} /&gt;;\n    } catch (error) {\n        setHasError(true);\n        console.error(error);\n        return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;\n    }\n};\n\nconst SimpleComponent = (props) =&gt; {\n    if (props.throwError) {\n        throw new Error(\"Error triggered\");\n    }\n    return &lt;div&gt;{props.message}&lt;/div&gt;;\n};\n\nconst ErrorBoundaryComponent = withErrorBoundary(SimpleComponent);\n\n// Usage\n&lt;ErrorBoundaryComponent throwError={true} message=\"This will throw an error\" /&gt;; // Renders error message\n&lt;ErrorBoundaryComponent throwError={false} message=\"No error\" /&gt;; // Renders \"No error\"\n</code></pre>"},{"location":"frontend/react/example/hoc/#intermediate-hocs","title":"Intermediate HOCs","text":""},{"location":"frontend/react/example/hoc/#1-data-fetching","title":"1. Data Fetching","text":"Success Functional ComponentClass ComponentUsage javascript<pre><code>const withDataFetching = (url) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    const [data, setData] = React.useState(null);\n    const [loading, setLoading] = React.useState(true);\n\n    React.useEffect(() =&gt; {\n        fetch(url)\n        .then((response) =&gt; response.json())\n        .then((data) =&gt; {\n            setData(data);\n            setLoading(false);\n        });\n    }, [url]);\n\n    return &lt;WrappedComponent {...props} data={data} loading={loading} /&gt;;\n};\n</code></pre> javascript<pre><code>const withDataFetching = (url) =&gt; (WrappedComponent) =&gt; {\n    return class extends React.Component {\n        state = { data: null, loading: true };\n\n        componentDidMount() {\n        fetch(url)\n            .then((response) =&gt; response.json())\n            .then((data) =&gt; this.setState({ data, loading: false }));\n        }\n\n        render() {\n        return &lt;WrappedComponent {...this.props} {...this.state} /&gt;;\n        }\n    };\n};\n</code></pre> <pre><code>const withDataFetching = (url) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    const [data, setData] = React.useState(null);\n    const [loading, setLoading] = React.useState(true);\n\n    React.useEffect(() =&gt; {\n        fetch(url)\n        .then((response) =&gt; response.json())\n        .then((data) =&gt; {\n            setData(data);\n            setLoading(false);\n        });\n    }, [url]);\n\n    return &lt;WrappedComponent {...props} data={data} loading={loading} /&gt;;\n};\n\nconst DataComponent = ({ data, loading }) =&gt; {\n    if (loading) {\n        return &lt;div&gt;Loading...&lt;/div&gt;;\n    }\n    return &lt;div&gt;Data: {JSON.stringify(data)}&lt;/div&gt;;\n};\n\nconst FetchedDataComponent = withDataFetching(\"https://api.example.com/data\")(DataComponent);\n\n// Usage\n&lt;FetchedDataComponent /&gt;;\n</code></pre>"},{"location":"frontend/react/example/hoc/#2-authentication-check","title":"2. Authentication Check","text":"Success Functional ComponentClass ComponentUsage javascript<pre><code>const withAuthentication = (WrappedComponent) =&gt; (props) =&gt; {\n    if (!props.isAuthenticated) {\n        return &lt;div&gt;Please log in&lt;/div&gt;;\n    }\n    return &lt;WrappedComponent {...props} /&gt;;\n};\n</code></pre> javascript<pre><code>const withAuthentication = (WrappedComponent) =&gt; {\n    return class extends React.Component {\n        render() {\n        if (!this.props.isAuthenticated) {\n            return &lt;div&gt;Please log in&lt;/div&gt;;\n        }\n        return &lt;WrappedComponent {...this.props} /&gt;;\n        }\n    };\n};\n</code></pre> <pre><code>const withAuthentication = (WrappedComponent) =&gt; (props) =&gt; {\n    if (!props.isAuthenticated) {\n        return &lt;div&gt;Please log in&lt;/div&gt;;\n    }\n    return &lt;WrappedComponent {...props} /&gt;;\n};\n\nconst AuthenticatedComponent = (props) =&gt; &lt;div&gt;Authenticated Content&lt;/div&gt;;\n\nconst AuthCheckComponent = withAuthentication(AuthenticatedComponent);\n\n// Usage\n&lt;AuthCheckComponent isAuthenticated={true} /&gt;; // Renders \"Authenticated Content\"\n&lt;AuthCheckComponent isAuthenticated={false} /&gt;; // Renders \"Please log in\"\n</code></pre>"},{"location":"frontend/react/example/hoc/#3-form-handling","title":"3. Form Handling","text":"Success Functional ComponentClass ComponentUsage javascript<pre><code>const withFormHandling = (WrappedComponent) =&gt; (props) =&gt; {\n    const [formData, setFormData] = React.useState({});\n\n    const handleChange = (event) =&gt; {\n        const { name, value } = event.target;\n        setFormData({ ...formData, [name]: value });\n    };\n\n    const handleSubmit = (event) =&gt; {\n        event.preventDefault();\n        // handle form submission\n    };\n\n    return (\n        &lt;WrappedComponent\n        {...props}\n        formData={formData}\n        handleChange={handleChange}\n        handleSubmit={handleSubmit}\n        /&gt;\n    );\n};\n</code></pre> javascript<pre><code>const withFormHandling = (WrappedComponent) =&gt; {\n    return class extends React.Component {\n        state = { formData: {} };\n\n        handleChange = (event) =&gt; {\n        const { name, value } = event.target;\n        this.setState({ formData: { ...this.state.formData, [name]: value } });\n        };\n\n        handleSubmit = (event) =&gt; {\n        event.preventDefault();\n        // handle form submission\n        };\n\n        render() {\n        return (\n            &lt;WrappedComponent\n            {...this.props}\n            formData={this.state.formData}\n            handleChange={this.handleChange}\n            handleSubmit={this.handleSubmit}\n            /&gt;\n        );\n        }\n    };\n};\n</code></pre> <pre><code>const withFormHandling = (WrappedComponent) =&gt; (props) =&gt; {\nconst [formData, setFormData] = React.useState({});\n\nconst handleChange = (event) =&gt; {\n    const { name, value } = event.target;\n    setFormData({ ...formData, [name]: value });\n};\n\nconst handleSubmit = (event) =&gt; {\n    event.preventDefault();\n    console.log(\"Form submitted with data:\", formData);\n};\n\nreturn (\n    &lt;WrappedComponent\n    {...props}\n    formData={formData}\n    handleChange={handleChange}\n    handleSubmit={handleSubmit}\n    /&gt;\n);\n};\n\nconst FormComponent = ({ formData, handleChange, handleSubmit }) =&gt; (\n&lt;form onSubmit={handleSubmit}&gt;\n    &lt;input name=\"name\" value={formData.name || ''} onChange={handleChange} /&gt;\n    &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n&lt;/form&gt;\n);\n\nconst HandledFormComponent = withFormHandling(FormComponent);\n\n// Usage\n&lt;HandledFormComponent /&gt;;\n</code></pre>"},{"location":"frontend/react/example/hoc/#4-authorization-check","title":"4. Authorization Check","text":"Success Functional ComponentClass ComponentUsage javascript<pre><code>const withAuthorization = (allowedRoles) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    if (!allowedRoles.includes(props.role)) {\n        return &lt;div&gt;Access Denied&lt;/div&gt;;\n    }\n    return &lt;WrappedComponent {...props} /&gt;;\n};\n</code></pre> javascript<pre><code>const withAuthorization = (allowedRoles) =&gt; (WrappedComponent) =&gt; {\n    return class extends React.Component {\n        render() {\n        if (!allowedRoles.includes(this.props.role)) {\n            return &lt;div&gt;Access Denied&lt;/div&gt;;\n        }\n        return &lt;WrappedComponent {...this.props} /&gt;;\n        }\n    };\n};\n</code></pre> <pre><code>const withAuthorization = (allowedRoles) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    if (!allowedRoles.includes(props.role)) {\n        return &lt;div&gt;Access Denied&lt;/div&gt;;\n    }\n    return &lt;WrappedComponent {...props} /&gt;;\n};\n\nconst AuthorizedComponent = (props) =&gt; &lt;div&gt;Authorized Content&lt;/div&gt;;\n\nconst RoleCheckComponent = withAuthorization(['admin'])(AuthorizedComponent);\n\n// Usage\n&lt;RoleCheckComponent role=\"admin\" /&gt;; // Renders \"Authorized Content\"\n&lt;RoleCheckComponent role=\"user\" /&gt;; // Renders \"Access Denied\"\n</code></pre>"},{"location":"frontend/react/example/hoc/#5-redux-connect-hoc","title":"5. Redux Connect HOC","text":"Success ExampleUsage javascript<pre><code>import { connect } from 'react-redux';\n\nconst withReduxConnect = (mapStateToProps, mapDispatchToProps) =&gt; (WrappedComponent) =&gt; {\n    return connect(mapStateToProps, mapDispatchToProps)(WrappedComponent);\n};\n</code></pre> <pre><code>import { connect } from 'react-redux';\n\nconst withReduxConnect = (mapStateToProps, mapDispatchToProps) =&gt; (WrappedComponent) =&gt; {\n    return connect(mapStateToProps, mapDispatchToProps)(WrappedComponent);\n};\n\nconst SimpleComponent = ({ message }) =&gt; &lt;div&gt;{message}&lt;/div&gt;;\n\nconst mapStateToProps = (state) =&gt; ({\n    message: state.message,\n});\n\nconst mapDispatchToProps = (dispatch) =&gt; ({\n    updateMessage: (msg) =&gt; dispatch({ type: 'UPDATE_MESSAGE', payload: msg }),\n});\n\nconst ReduxConnectedComponent = withReduxConnect(mapStateToProps, mapDispatchToProps)(SimpleComponent);\n\n// Usage\n&lt;ReduxConnectedComponent /&gt;;\n</code></pre>"},{"location":"frontend/react/example/hoc/#advanced-hocs","title":"Advanced HOCs","text":""},{"location":"frontend/react/example/hoc/#1-dynamic-module-loader","title":"1. Dynamic Module Loader","text":"Example Functional ComponentClass ComponentUsage javascript<pre><code>const withDynamicModule = (importModule) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    const [Module, setModule] = React.useState(null);\n\n    React.useEffect(() =&gt; {\n        importModule().then((mod) =&gt; setModule(mod.default));\n    }, [importModule]);\n\n    return Module ? &lt;Module {...props} /&gt; : &lt;div&gt;Loading...&lt;/div&gt;;\n};\n</code></pre> javascript<pre><code>const withDynamicModule = (importModule) =&gt; (WrappedComponent) =&gt; {\n    return class extends React.Component {\n        state = { Module: null };\n\n        componentDidMount() {\n        importModule().then((mod) =&gt; this.setState({ Module: mod.default }));\n        }\n\n        render() {\n        const { Module } = this.state;\n        return Module ? &lt;Module {...this.props} /&gt; : &lt;div&gt;Loading...&lt;/div&gt;;\n        }\n    };\n};\n</code></pre> javascript<pre><code>const withDynamicModule = (importModule) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    const [Module, setModule] = React.useState(null);\n\n    React.useEffect(() =&gt; {\n        importModule().then((mod) =&gt; setModule(mod.default));\n    }, [importModule]);\n\n    return Module ? &lt;Module {...props} /&gt; : &lt;div&gt;Loading...&lt;/div&gt;;\n};\n\nconst DynamicComponent = (props) =&gt; &lt;div&gt;{props.dynamicContent}&lt;/div&gt;;\n\nconst DynamicLoadedComponent = withDynamicModule(() =&gt; import('./DynamicComponent'))(DynamicComponent);\n\n// Usage\n&lt;DynamicLoadedComponent dynamicContent=\"This is dynamically loaded\" /&gt;;\n</code></pre>"},{"location":"frontend/react/example/hoc/#2-performance-optimization-with-memoization","title":"2. Performance Optimization with Memoization","text":"Example Functional ComponentClass ComponentUsage javascript<pre><code>const withMemoization = (WrappedComponent) =&gt; React.memo(WrappedComponent, (prevProps, nextProps) =&gt; {\n    // Add custom comparison logic here\n    return prevProps === nextProps;\n});\n</code></pre> javascript<pre><code>const withMemoization = (WrappedComponent) =&gt; {\n    return React.memo(WrappedComponent, (prevProps, nextProps) =&gt; {\n        // Add custom comparison logic here\n        return prevProps === nextProps;\n    });\n};\n</code></pre> javascript<pre><code>const withMemoization = (WrappedComponent) =&gt; React.memo(WrappedComponent, (prevProps, nextProps) =&gt; {\n    return prevProps === nextProps;\n});\n\nconst MemoizedComponent = ({ message }) =&gt; &lt;div&gt;{message}&lt;/div&gt;;\n\nconst OptimizedComponent = withMemoization(MemoizedComponent);\n\n// Usage\n&lt;OptimizedComponent message=\"Memoized Content\" /&gt;;\n</code></pre>"},{"location":"frontend/react/example/hoc/#3-internationalization-i18n","title":"3. Internationalization (i18n)","text":"Example Functional ComponentClass ComponentUsage javascript<pre><code>import { useTranslation } from 'react-i18next';\n\nconst withI18n = (WrappedComponent) =&gt; (props) =&gt; {\n    const { t, i18n } = useTranslation();\n    return &lt;WrappedComponent {...props} t={t} i18n={i18n} /&gt;;\n};\n</code></pre> javascript<pre><code>import { withTranslation } from 'react-i18next';\n\nconst withI18n = (WrappedComponent) =&gt; {\n    return withTranslation()(WrappedComponent);\n};\n</code></pre> javascript<pre><code>import { useTranslation } from 'react-i18next';\n\nconst withI18n = (WrappedComponent) =&gt; (props) =&gt; {\n    const { t, i18n } = useTranslation();\n    return &lt;WrappedComponent {...props} t={t} i18n={i18n} /&gt;;\n};\n\nconst TranslatedComponent = ({ t }) =&gt; &lt;div&gt;{t('welcome_message')}&lt;/div&gt;;\n\nconst I18nComponent = withI18n(TranslatedComponent);\n\n// Usage\n&lt;I18nComponent /&gt;;\n</code></pre>"},{"location":"frontend/react/example/hoc/#4-analytics-tracking","title":"4. Analytics Tracking","text":"Example Functional ComponentClass ComponentUsage javascript<pre><code>const withAnalytics = (eventName) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    React.useEffect(() =&gt; {\n        // Simulate sending event to analytics service\n        console.log(`Event: ${eventName}`);\n    }, [eventName]);\n\n    return &lt;WrappedComponent {...props} /&gt;;\n};\n</code></pre> javascript<pre><code>const withAnalytics = (eventName) =&gt; (WrappedComponent) =&gt; {\n    return class extends React.Component {\n        componentDidMount() {\n            // Simulate sending event to analytics service\n            console.log(`Event: ${eventName}`);\n        }\n\n        render() {\n            return &lt;WrappedComponent {...this.props} /&gt;;\n        }\n    };\n};\n</code></pre> javascript<pre><code>const withAnalytics = (eventName) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    React.useEffect(() =&gt; {\n        console.log(`Event: ${eventName}`);\n    }, [eventName]);\n\n    return &lt;WrappedComponent {...props} /&gt;;\n};\n\nconst AnalyticsComponent = (props) =&gt; &lt;div&gt;{props.content}&lt;/div&gt;;\n\nconst TrackedComponent = withAnalytics('ComponentLoaded')(AnalyticsComponent);\n\n// Usage\n&lt;TrackedComponent content=\"Analytics Tracked Content\" /&gt;;\n</code></pre>"},{"location":"frontend/react/example/hoc/#5-drag-and-drop","title":"5. Drag and Drop","text":"Example Functional ComponentClass ComponentUsage javascript<pre><code>import { useDrag, useDrop } from 'react-dnd';\n\nconst withDragAndDrop = (WrappedComponent) =&gt; (props) =&gt; {\n    const [, drag] = useDrag({\n        type: 'ITEM',\n        item: { id: props.id },\n    });\n\n    const [, drop] = useDrop({\n        accept: 'ITEM',\n        drop: (item) =&gt; props.onDrop(item.id, props.id),\n    });\n\n    return (\n        &lt;div ref={(node) =&gt; drag(drop(node))}&gt;\n            &lt;WrappedComponent {...props} /&gt;\n        &lt;/div&gt;\n    );\n};\n</code></pre> javascript<pre><code>import { DragSource, DropTarget } from 'react-dnd';\n\nconst withDragAndDrop = (WrappedComponent) =&gt; {\n    const dragSpec = {\n        beginDrag: (props) =&gt; ({ id: props.id })\n    };\n\n    const dropSpec = {\n        drop: (props, monitor) =&gt; {\n            const item = monitor.getItem();\n            props.onDrop(item.id, props.id);\n        }\n    };\n\n    const collectDrag = (connect) =&gt; ({\n        connectDragSource: connect.dragSource()\n    });\n\n    const collectDrop = (connect) =&gt; ({\n        connectDropTarget: connect.dropTarget()\n    });\n\n    const DraggableComponent = DragSource('ITEM', dragSpec, collectDrag)(WrappedComponent);\n    return DropTarget('ITEM', dropSpec, collectDrop)(DraggableComponent);\n};\n</code></pre> javascript<pre><code>import { useDrag, useDrop } from 'react-dnd';\n\nconst withDragAndDrop = (WrappedComponent) =&gt; (props) =&gt; {\n    const [, drag] = useDrag({\n        type: 'ITEM',\n        item: { id: props.id },\n    });\n\n    const [, drop] = useDrop({\n        accept: 'ITEM',\n        drop: (item) =&gt; props.onDrop(item.id, props.id),\n    });\n\n    return (\n        &lt;div ref={(node) =&gt; drag(drop(node))}&gt;\n        &lt;WrappedComponent {...props} /&gt;\n        &lt;/div&gt;\n    );\n};\n\nconst DraggableComponent = ({ content }) =&gt; &lt;div&gt;{content}&lt;/div&gt;;\n\nconst DragDropComponent = withDragAndDrop(DraggableComponent);\n\n// Usage\n&lt;DragDropComponent id=\"1\" content=\"Drag me\" onDrop={(sourceId, targetId) =&gt; console.log(`Dropped ${sourceId} on ${targetId}`)} /&gt;;\n</code></pre> <p>These examples should cover a wide range of scenarios and illustrate how HOCs can be used to enhance and reuse component functionality at different levels of complexity.</p>"},{"location":"frontend/react/example/hoc/#folder-structure-of-hocs","title":"Folder Structure of HOCs","text":"<p>The folder structure for Higher-Order Components (HOCs) in a React project can vary depending on the complexity and size of your project. However, a common and organized way to structure your folders and files can look like this:</p>"},{"location":"frontend/react/example/hoc/#1-basic-folder-structure","title":"1. Basic Folder Structure","text":"<p>A simple structure for a small to medium-sized project might look like this:</p> <pre><code>src/\n\u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 SomeComponent/\n\u2502   \u2502   \u251c\u2500\u2500 SomeComponent.js\n\u2502   \u2502   \u251c\u2500\u2500 SomeComponent.css\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 hocs/\n\u2502   \u251c\u2500\u2500 withAuth.js\n\u2502   \u2514\u2500\u2500 withLogging.js\n\u251c\u2500\u2500 App.js\n\u251c\u2500\u2500 index.js\n\u2514\u2500\u2500 ...\n</code></pre>"},{"location":"frontend/react/example/hoc/#2-advanced-folder-structure","title":"2. Advanced Folder Structure","text":"<p>For larger projects, it might make sense to have a more detailed structure:</p> <pre><code>src/\n\u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 SomeComponent/\n\u2502   \u2502   \u251c\u2500\u2500 SomeComponent.js\n\u2502   \u2502   \u251c\u2500\u2500 SomeComponent.css\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 AnotherComponent/\n\u2502       \u251c\u2500\u2500 AnotherComponent.js\n\u2502       \u251c\u2500\u2500 AnotherComponent.css\n\u2502       \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 hocs/\n\u2502   \u251c\u2500\u2500 withAuth/\n\u2502   \u2502   \u251c\u2500\u2500 withAuth.js\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u251c\u2500\u2500 withLogging/\n\u2502   \u2502   \u251c\u2500\u2500 withLogging.js\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 withAnotherFeature/\n\u2502       \u251c\u2500\u2500 withAnotherFeature.js\n\u2502       \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 utils/\n\u2502   \u251c\u2500\u2500 helper1.js\n\u2502   \u2514\u2500\u2500 helper2.js\n\u251c\u2500\u2500 hooks/\n\u2502   \u251c\u2500\u2500 useCustomHook.js\n\u2502   \u2514\u2500\u2500 useAnotherHook.js\n\u251c\u2500\u2500 App.js\n\u251c\u2500\u2500 index.js\n\u2514\u2500\u2500 ...\n</code></pre>"},{"location":"frontend/react/example/hoc/#explanation-of-each-folder","title":"Explanation of Each Folder:","text":"<ol> <li> <p>components/:</p> <ul> <li>Contains all your React components.</li> <li>Each component has its own folder which may contain its JavaScript file, CSS file, and an <code>index.js</code> for easier imports.</li> </ul> </li> <li> <p>hocs/:</p> <ul> <li>Contains all your Higher-Order Components.</li> <li>Each HOC can have its own folder if it consists of multiple files or just a single file if it's simple.</li> <li>Each HOC folder typically has an <code>index.js</code> file for easier imports.</li> </ul> </li> <li> <p>utils/:</p> <ul> <li>Contains utility functions that can be reused throughout your project.</li> </ul> </li> <li> <p>hooks/:</p> <ul> <li>Contains custom React hooks.</li> </ul> </li> </ol>"},{"location":"frontend/react/example/hoc/#hocs","title":"HOCs","text":"<p>Higher-Order Components (HOCs) are a pattern in React for reusing component logic. They are functions that take a component and return a new component with added functionality. HOCs are particularly useful in various scenarios, and they are commonly used for the following purposes:</p>"},{"location":"frontend/react/example/hoc/#scenarios-for-using-hocs","title":"Scenarios for Using HOCs","text":"<ol> <li> <p>Code Reuse, Logic, and Bootstrap Abstraction:</p> <ul> <li>HOCs allow you to reuse code across multiple components. This is particularly useful for logic that needs to be shared, such as fetching data, managing state, or subscribing to events.</li> </ul> </li> <li> <p>Manipulating Props:</p> <ul> <li>HOCs can manipulate the props passed to a component. This can include adding new props, modifying existing ones, or filtering out unnecessary props.</li> </ul> </li> <li> <p>Conditional Rendering:</p> <ul> <li>HOCs can be used to conditionally render components based on certain criteria, such as user authentication, feature flags, or permission levels.</li> </ul> </li> <li> <p>State Management:</p> <ul> <li>They can manage state and pass it down as props to the wrapped component. This is useful for scenarios where state management logic needs to be shared across multiple components.</li> </ul> </li> <li> <p>Handling Side Effects:</p> <ul> <li>HOCs can handle side effects like data fetching, subscriptions, or logging. This is useful for abstracting side effects out of the component, keeping them clean and focused on rendering UI.</li> </ul> </li> </ol>"},{"location":"frontend/react/example/hoc/#common-uses-of-hocs","title":"Common Uses of HOCs","text":"<ol> <li> <p>Authentication:</p> <ul> <li>Wrapping components to ensure that only authenticated users can access certain parts of an application.</li> <li>Example: <code>withAuth(Component)</code></li> </ul> </li> <li> <p>Logging:</p> <ul> <li>Adding logging functionality to components for debugging or analytics.</li> <li>Example: <code>withLogging(Component)</code></li> </ul> </li> <li> <p>Data Fetching:</p> <ul> <li>Fetching data from an API and passing it as props to the wrapped component.</li> <li>Example: <code>withDataFetching(Component, apiEndpoint)</code></li> </ul> </li> <li> <p>Theming:</p> <ul> <li>Providing theme-related props to components.</li> <li>Example: <code>withTheme(Component)</code></li> </ul> </li> <li> <p>Error Handling:</p> <ul> <li>Wrapping components with error boundaries to catch and handle errors in a standardized way.</li> <li>Example: <code>withErrorBoundary(Component)</code></li> </ul> </li> <li> <p>Access Control:</p> <ul> <li>Enforcing role-based access control by conditionally rendering components based on user roles.</li> <li>Example: <code>withRole(Component, allowedRoles)</code></li> </ul> </li> <li> <p>Form Handling:</p> <ul> <li>Managing form state and validation logic.</li> <li>Example: <code>withFormHandling(Component)</code></li> </ul> </li> </ol>"},{"location":"frontend/react/example/lifting-state-up/","title":"Lifting State Up","text":""},{"location":"frontend/react/example/lifting-state-up/#theory-of-lifting-state-up-in-react","title":"Theory of Lifting State Up in React","text":"<p>Lifting state up is a pattern in React where you move state from <code>child components</code> to a common <code>parent component</code>. This pattern is necessary for managing state that needs to be shared among multiple child components. By lifting the state up to a common ancestor, you create a single source of truth, ensuring that all child components that need the state have access to the same data.</p>"},{"location":"frontend/react/example/lifting-state-up/#why-is-it-necessary","title":"Why Is It Necessary?","text":"<p>When multiple components need to share and synchronize state, managing the state within each component individually can lead to inconsistencies and complexity. Lifting the state up solves these issues by:</p> <ul> <li>Ensuring Consistency: By having a single source of truth for the state, you avoid the risk of components having out-of-sync data.</li> <li>Simplifying State Management: It becomes easier to manage and update the state from one place, reducing the complexity of your application.</li> <li>Avoiding Prop Drilling: While lifting state up does require passing state down as props, it helps avoid deeper and more convoluted prop drilling in larger component trees.</li> </ul>"},{"location":"frontend/react/example/lifting-state-up/#how-does-it-solve-the-problem","title":"How Does It Solve the Problem?","text":"<p>Problem: </p> <p>Imagine two sibling components need to share and synchronize some state. If each component maintains its own state, it becomes challenging to keep them in sync.</p> <p>Solution: </p> <p>Lift the state up to their common parent, and pass the state and state-updating functions down to the child components via props. This way, the parent component manages the state, and the child components simply use the state and functions passed to them.</p>"},{"location":"frontend/react/example/lifting-state-up/#example","title":"Example","text":"<p>Let's consider a more detailed example:</p> Tip Without Lifting State UpWith Lifting State Up <p>We have two sibling components: TemperatureInput for Celsius and Fahrenheit. Each component maintains its own state.</p> <pre><code>function TemperatureInputCelsius() {\n    const [celsius, setCelsius] = useState('');\n\n    const handleChange = (e) =&gt; {\n        setCelsius(e.target.value);\n    };\n\n    return &lt;input type=\"text\" value={celsius} onChange={handleChange} /&gt;;\n}\n\nfunction TemperatureInputFahrenheit() {\n    const [fahrenheit, setFahrenheit] = useState('');\n\n    const handleChange = (e) =&gt; {\n        setFahrenheit(e.target.value);\n    };\n\n    return &lt;input type=\"text\" value={fahrenheit} onChange={handleChange} /&gt;;\n}\n\nfunction App() {\n    return (\n        &lt;div&gt;\n        &lt;TemperatureInputCelsius /&gt;\n        &lt;TemperatureInputFahrenheit /&gt;\n        &lt;/div&gt;\n    );\n}\n</code></pre> <p>In this setup, the components have their own state and do not share data. Converting between Celsius and Fahrenheit requires extra logic in each component and makes it hard to keep them in sync.</p> <p>Lift the state up to the App component and pass the necessary state and handlers down to the child components.</p> <pre><code>function TemperatureInput({ scale, temperature, handleChange }) {\n    return (\n        &lt;fieldset&gt;\n        &lt;legend&gt;Enter temperature in {scale}:&lt;/legend&gt;\n        &lt;input value={temperature} onChange={handleChange} /&gt;\n        &lt;/fieldset&gt;\n    );\n}\n\n// main function\nfunction App() {\n    const [temperature, setTemperature] = useState('');\n    const [scale, setScale] = useState('c');\n\n    const handleCelsiusChange = (e) =&gt; {\n        setScale('c');\n        setTemperature(e.target.value);\n    };\n\n    const handleFahrenheitChange = (e) =&gt; {\n        setScale('f');\n        setTemperature(e.target.value);\n    };\n\n    const celsius = scale === 'f' ? tryConvert(temperature, toCelsius) : temperature;\n    const fahrenheit = scale === 'c' ? tryConvert(temperature, toFahrenheit) : temperature;\n\n    return (\n        &lt;div&gt;\n        &lt;TemperatureInput\n            scale=\"Celsius\"\n            temperature={celsius}\n            handleChange={handleCelsiusChange}\n        /&gt;\n        &lt;TemperatureInput\n            scale=\"Fahrenheit\"\n            temperature={fahrenheit}\n            handleChange={handleFahrenheitChange}\n        /&gt;\n        &lt;/div&gt;\n    );\n}\n\nfunction toCelsius(fahrenheit) {\n    return ((fahrenheit - 32) * 5) / 9;\n}\n\nfunction toFahrenheit(celsius) {\n    return (celsius * 9) / 5 + 32;\n}\n\nfunction tryConvert(temperature, convert) {\n    const input = parseFloat(temperature);\n    if (Number.isNaN(input)) {\n        return '';\n    }\n    const output = convert(input);\n    const rounded = Math.round(output * 1000) / 1000;\n    return rounded.toString();\n}\n</code></pre> <p>In this example, the <code>App</code> component maintains the state for the temperature and the scale. The <code>TemperatureInput</code> components are now stateless and receive the necessary state and handlers as props. The conversion functions ensure that both input fields stay in sync.</p>"},{"location":"frontend/react/example/lifting-state-up/#summary","title":"Summary","text":"<ul> <li>Lifting state up means moving the state to the closest common ancestor of components that need to share the state.</li> <li>It ensures consistency, simplifies state management, and avoids deep prop drilling.</li> <li>By lifting state up, you centralize the state management, making your application more predictable and easier to maintain.</li> </ul> <p>This approach is essential for managing shared state in React applications, particularly as they grow in complexity.</p>"},{"location":"frontend/react/example/passing-props/","title":"Passing Props","text":""},{"location":"frontend/react/example/passing-props/#passing-props","title":"passing props","text":"<p>Yes, you can pass state and functions to other components in React, and this is a common practice. The standard approach typically involves the following methods:</p>"},{"location":"frontend/react/example/passing-props/#1-props","title":"1. Props","text":"<p>Passing state and functions through props is the most straightforward method. This is done by passing them from a parent component to its child components.</p> <pre><code>function ParentComponent() {\n  const [state, setState] = useState(initialState);\n\n  const handleAction = () =&gt; {\n    // function logic\n  };\n\n  return (\n    &lt;ChildComponent state={state} handleAction={handleAction} /&gt;\n  );\n}\n\nfunction ChildComponent({ state, handleAction }) {\n  return (\n    &lt;div&gt;\n      &lt;p&gt;{state}&lt;/p&gt;\n      &lt;button onClick={handleAction}&gt;Do Something&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"frontend/react/example/passing-props/#2-context","title":"2. Context","text":"<p>For passing state and functions down the component tree without prop drilling (passing through many intermediary components), React's Context API can be used.</p> <pre><code>const MyContext = React.createContext();\n\nfunction ParentComponent() {\n  const [state, setState] = useState(initialState);\n\n  const handleAction = () =&gt; {\n    // function logic\n  };\n\n  return (\n    &lt;MyContext.Provider value={{ state, handleAction }}&gt;\n      &lt;ChildComponent /&gt;\n    &lt;/MyContext.Provider&gt;\n  );\n}\n\nfunction ChildComponent() {\n  const { state, handleAction } = React.useContext(MyContext);\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;{state}&lt;/p&gt;\n      &lt;button onClick={handleAction}&gt;Do Something&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"frontend/react/example/passing-props/#3-custom-hooks","title":"3. Custom Hooks","text":"<p>For reusable logic that involves state and functions, you can create custom hooks.</p> <pre><code>function useCustomHook() {\n  const [state, setState] = useState(initialState);\n\n  const handleAction = () =&gt; {\n    // function logic\n  };\n\n  return { state, handleAction };\n}\n\nfunction Component() {\n  const { state, handleAction } = useCustomHook();\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;{state}&lt;/p&gt;\n      &lt;button onClick={handleAction}&gt;Do Something&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"frontend/react/example/passing-props/#standard-practices","title":"Standard Practices:","text":""},{"location":"frontend/react/example/passing-props/#lift-state-up","title":"Lift State Up:","text":"<p>Keep the state in the closest common ancestor of the components that need access to the state. This helps in avoiding unnecessary re-renders and makes the state management simpler.</p>"},{"location":"frontend/react/example/passing-props/#prop-drilling","title":"Prop Drilling:","text":"<p>If prop drilling (passing props through multiple levels of components) becomes cumbersome, consider using Context API or state management libraries like Redux.</p>"},{"location":"frontend/react/example/passing-props/#descriptive-props","title":"Descriptive Props:","text":"<p>When passing functions and state as props, use descriptive names to make the code more readable and maintainable.</p>"},{"location":"frontend/react/example/passing-props/#minimize-context-use","title":"Minimize Context Use:","text":"<p>Use context sparingly to avoid performance issues related to unnecessary re-renders. For global state management, consider state management libraries.</p> <p>By following these methods and practices, you can effectively manage and pass state and functions between components in your React application.</p>"},{"location":"frontend/react/example/passing-props/#naming-conventions-for-passing-props","title":"Naming Conventions for Passing Props","text":"Tip <ol> <li> <p>Descriptive Names:</p> <ul> <li>Use clear, descriptive names that convey the purpose of the prop.</li> <li>For state values, use the noun form.</li> <li>For functions (handlers), use the verb form, often prefixed with on or handle.</li> </ul> </li> <li> <p>State Props:</p> <ul> <li>Use the exact name of the state variable.</li> <li>Example: If the state variable is <code>user</code>, pass it as <code>user</code>.</li> </ul> </li> <li> <p>Function Props:</p> <ul> <li>Prefix functions with on if they are event handlers.</li> <li>Prefix with handle if they are general purpose functions.</li> <li>Example: onClick, onChange, handleSubmit.</li> </ul> </li> <li> <p>Boolean Props:</p> <ul> <li>Use prefixes like is, has, should, etc., to indicate boolean nature.</li> <li>Example: isOpen, hasError.</li> </ul> </li> </ol>"},{"location":"frontend/react/example/passing-props/#examples","title":"Examples","text":"<p>Here are examples demonstrating these conventions:</p> Basic Example Parent Component:Child Component: jsx<pre><code>function ParentComponent() {\n    const [count, setCount] = useState(0);\n\n    const incrementCount = () =&gt; {\n        setCount(count + 1);\n    };\n\n    return (\n        &lt;ChildComponent count={count} onIncrement={incrementCount} /&gt;\n    );\n}\n</code></pre> jsx<pre><code>function ChildComponent({ count, onIncrement }) {\n    return (\n        &lt;div&gt;\n            &lt;p&gt;Count: {count}&lt;/p&gt;\n            &lt;button onClick={onIncrement}&gt;Increment&lt;/button&gt;\n        &lt;/div&gt;\n    );\n}\n</code></pre> Advanced Example with Multiple Props Parent Component:Child Component: jsx<pre><code>function ParentComponent() {\n    const [username, setUsername] = useState('');\n    const [email, setEmail] = useState('');\n\n    const handleUsernameChange = (e) =&gt; {\n        setUsername(e.target.value);\n    };\n\n    const handleEmailChange = (e) =&gt; {\n        setEmail(e.target.value);\n    };\n\n    return (\n        &lt;FormComponent\n            username={username}\n            email={email}\n            onUsernameChange={handleUsernameChange}\n            onEmailChange={handleEmailChange}\n        /&gt;\n    );\n}\n</code></pre> jsx<pre><code>function FormComponent({ username, email, onUsernameChange, onEmailChange }) {\n    return (\n        &lt;form&gt;\n            &lt;div&gt;\n                &lt;label&gt;Username:&lt;/label&gt;\n                &lt;input type=\"text\" value={username} onChange={onUsernameChange} /&gt;\n            &lt;/div&gt;\n            &lt;div&gt;\n                &lt;label&gt;Email:&lt;/label&gt;\n                &lt;input type=\"email\" value={email} onChange={onEmailChange} /&gt;\n            &lt;/div&gt;\n        &lt;/form&gt;\n    );\n}\n</code></pre>"},{"location":"frontend/react/example/passing-props/#summary-of-naming-conventions","title":"Summary of Naming Conventions","text":"<ul> <li>State Values: Use the exact name of the state variable (e.g., <code>count</code>, <code>username</code>).</li> <li>Function Props: Prefix with on for <code>event handlers</code> and handle for <code>general functions</code> (e.g., <code>onClick</code>, <code>handleSubmit</code>).</li> <li>Boolean Props: Use prefixes like is, has, should to indicate their nature (e.g., <code>isOpen</code>, <code>hasError</code>).</li> </ul> <p>Following these conventions makes your code more predictable, readable, and easier to maintain, especially when working in teams or on large projects.</p>"},{"location":"frontend/react/example/presentational-and-container/","title":"Presentation & Container","text":""},{"location":"frontend/react/example/presentational-and-container/#presentational-components","title":"Presentational Components:","text":"<p>These components focus on how things look. They receive data and callbacks exclusively via props and rarely have their own state.</p>"},{"location":"frontend/react/example/presentational-and-container/#container-components","title":"Container Components:","text":"<p>These components focus on how things work. They manage state and handle logic, passing data and callbacks down to presentational components.</p>"},{"location":"frontend/react/example/presentational-and-container/#example","title":"Example","text":"jsx<pre><code>// UserForm.js (Presentational Component)\nimport { Form, Input, Button } from 'antd';\n\nconst UserForm = ({ form, onSubmit }) =&gt; (\n  &lt;Form form={form} layout=\"vertical\" onFinish={onSubmit}&gt;\n    &lt;Form.Item name=\"name\" label=\"Name\" rules={[{ required: true }]}&gt;\n      &lt;Input /&gt;\n    &lt;/Form.Item&gt;\n    &lt;Form.Item name=\"email\" label=\"Email\" rules={[{ required: true, type: 'email' }]}&gt;\n      &lt;Input /&gt;\n    &lt;/Form.Item&gt;\n    &lt;Button type=\"primary\" htmlType=\"submit\"&gt;Submit&lt;/Button&gt;\n  &lt;/Form&gt;\n);\n\nexport default UserForm;\n\n// UserFormContainer.js (Container Component)\nimport React from 'react';\nimport { Form, message } from 'antd';\nimport UserForm from './UserForm';\n\nconst UserFormContainer = () =&gt; {\n  const [form] = Form.useForm();\n\n  const handleSubmit = (values) =&gt; {\n    message.success('Form submitted: ' + JSON.stringify(values));\n    // handle form submission logic here\n  };\n\n  return &lt;UserForm form={form} onSubmit={handleSubmit} /&gt;;\n};\n\nexport default UserFormContainer;\n</code></pre>"},{"location":"frontend/react/example/prop-drilling/","title":"Props Drilling","text":"<p>Prop drilling is a pattern in React where you pass data and functions from a parent component through multiple levels of intermediate components down to a deeply nested child component. This can become cumbersome and make the component tree harder to manage, especially as the application grows.</p>"},{"location":"frontend/react/example/prop-drilling/#what-is-prop-drilling","title":"What is Prop Drilling?","text":"<p>Prop drilling occurs when you need to pass data or callbacks through many layers of components, even if those intermediate components don\u2019t need to use the data themselves. It can lead to:</p> <ul> <li>Complex Component Trees: Passing props through many layers can make components less reusable and harder to maintain.</li> <li>Unnecessary Re-renders: Intermediate components may re-render unnecessarily if the props change.</li> <li>Increased Boilerplate: You may need to add boilerplate code for passing props through each component layer.</li> </ul>"},{"location":"frontend/react/example/prop-drilling/#example","title":"Example","text":"Parent Component: <pre><code>const Parent = () =&gt; {\n    const [data, setData] = useState('Hello');\n\n    return &lt;Intermediate data={data} /&gt;;\n};\n</code></pre> Intermediate Component: <pre><code>const Intermediate = ({ data }) =&gt; {\n    return &lt;DeepChild data={data} /&gt;;\n};\n</code></pre> Deep Child Component: <pre><code>const DeepChild = ({ data }) =&gt; {\n    return &lt;div&gt;{data}&lt;/div&gt;;\n};\n</code></pre> <p>In this example, <code>data</code> is drilled down from <code>Parent</code> through <code>Intermediate</code> to <code>DeepChild</code>.</p>"},{"location":"frontend/react/example/prop-drilling/#how-to-avoid-prop-drilling","title":"How to Avoid Prop Drilling","text":"<p>There are several strategies to avoid prop drilling, making your component tree cleaner and more maintainable:</p>"},{"location":"frontend/react/example/prop-drilling/#1-react-context-api","title":"1. React Context API:","text":"<p>React Context allows you to share values and functions across the component tree without passing props explicitly through every level.</p> jsx<pre><code>// Create a Context\nconst DataContext = createContext();\n\n// Provider Component\nconst DataProvider = ({ children }) =&gt; {\n  const [data, setData] = useState('Hello');\n\n  return (\n    &lt;DataContext.Provider value={{ data, setData }}&gt;\n      {children}\n    &lt;/DataContext.Provider&gt;\n  );\n};\n\n// Deep Component\nconst DeepChild = () =&gt; {\n  const { data } = useContext(DataContext);\n  return &lt;div&gt;{data}&lt;/div&gt;;\n};\n\n// Usage\nconst App = () =&gt; (\n  &lt;DataProvider&gt;\n    &lt;DeepChild /&gt;\n  &lt;/DataProvider&gt;\n);\n\nexport default App;\n</code></pre>"},{"location":"frontend/react/example/prop-drilling/#2-custom-hooks","title":"2. Custom Hooks:","text":"<p>Use custom hooks to encapsulate and share logic across components.</p> <pre><code>// useData.js\nimport { useState } from 'react';\n\nexport const useData = () =&gt; {\n  const [data, setData] = useState('Hello');\n  return { data, setData };\n};\n\n// Deep Component\nconst DeepChild = () =&gt; {\n  const { data } = useData();\n  return &lt;div&gt;{data}&lt;/div&gt;;\n};\n\n// Usage\nconst App = () =&gt; (\n  &lt;div&gt;\n    &lt;DeepChild /&gt;\n  &lt;/div&gt;\n);\n\nexport default App;\n</code></pre>"},{"location":"frontend/react/example/prop-drilling/#3-state-management-libraries","title":"3. State Management Libraries:","text":"<p>Use state management libraries like Redux, Zustand, or Recoil to manage and access state globally.</p> Redux<pre><code>// actions.js\nexport const setData = (data) =&gt; ({\n  type: 'SET_DATA',\n  payload: data,\n});\n\n// reducer.js\nconst initialState = { data: 'Hello' };\n\nexport const dataReducer = (state = initialState, action) =&gt; {\n  switch (action.type) {\n    case 'SET_DATA':\n      return { ...state, data: action.payload };\n    default:\n      return state;\n  }\n};\n\n// Deep Component\nimport { useSelector } from 'react-redux';\n\nconst DeepChild = () =&gt; {\n  const data = useSelector((state) =&gt; state.data);\n  return &lt;div&gt;{data}&lt;/div&gt;;\n};\n\n// Usage\nimport { Provider } from 'react-redux';\nimport { createStore } from 'redux';\nimport { dataReducer } from './reducer';\n\nconst store = createStore(dataReducer);\n\nconst App = () =&gt; (\n  &lt;Provider store={store}&gt;\n    &lt;DeepChild /&gt;\n  &lt;/Provider&gt;\n);\n\nexport default App;\n</code></pre>"},{"location":"frontend/react/example/prop-drilling/#4-composition","title":"4. Composition:","text":"<p>Sometimes, restructuring components to use composition rather than hierarchical prop drilling can simplify the design.</p> <pre><code>// DataProvider Component\nconst DataProvider = ({ children }) =&gt; {\n  const [data, setData] = useState('Hello');\n  return React.cloneElement(children, { data, setData });\n};\n\n// Deep Component\nconst DeepChild = ({ data }) =&gt; {\n  return &lt;div&gt;{data}&lt;/div&gt;;\n};\n\n// Usage\nconst App = () =&gt; (\n  &lt;DataProvider&gt;\n    &lt;DeepChild /&gt;\n  &lt;/DataProvider&gt;\n);\n\nexport default App;\n</code></pre>"},{"location":"frontend/react/example/prop-drilling/#summary","title":"Summary","text":"<p>While prop drilling is a common pattern in React, it can be managed more effectively by leveraging Context API, custom hooks, state management libraries, and component composition. These strategies help maintain a clean and manageable component tree, avoiding the pitfalls of deep prop drilling.</p>"},{"location":"frontend/react/example/render-props/","title":"Render Props","text":"<p>Render props is a pattern for sharing code between React components using a prop whose value is a function.</p> Example jsx<pre><code>// FormContainer.js\nconst FormContainer = ({ children }) =&gt; {\n    const [form] = Form.useForm();\n\n    const handleSubmit = (values) =&gt; {\n        console.log('Form submitted:', values);\n    };\n\n    return children({ form, handleSubmit });\n};\n\n// UserForm.js\nconst UserForm = ({ form, handleSubmit }) =&gt; (\n    &lt;Form form={form} layout=\"vertical\" onFinish={handleSubmit}&gt;\n        &lt;Form.Item name=\"name\" label=\"Name\" rules={[{ required: true }]}&gt;\n            &lt;Input /&gt;\n        &lt;/Form.Item&gt;\n        &lt;Form.Item name=\"email\" label=\"Email\" rules={[{ required: true, type: 'email' }]}&gt;\n            &lt;Input /&gt;\n        &lt;/Form.Item&gt;\n        &lt;Button type=\"primary\" htmlType=\"submit\"&gt;Submit&lt;/Button&gt;\n    &lt;/Form&gt;\n);\n\n// Usage in a component\n&lt;FormContainer&gt;\n    {({ form, handleSubmit }) =&gt; (\n        &lt;UserForm form={form} handleSubmit={handleSubmit} /&gt;\n    )}\n&lt;/FormContainer&gt;\n</code></pre> <p>Render props is a pattern in React that allows sharing code between components using a prop whose value is a function. It\u2019s commonly used to provide data and behavior to a component in a way that is flexible and reusable. While \"render props\" is the most widely recognized term, there are a few other names and related concepts that describe similar patterns:</p>"},{"location":"frontend/react/example/render-props/#other-names-and-related-concepts","title":"Other Names and Related Concepts","text":""},{"location":"frontend/react/example/render-props/#1-function-as-child-component-facc","title":"1. Function as Child Component (FaCC):","text":"<p>This term describes a pattern where a function is used as a child of a component. It\u2019s conceptually similar to render props, but with the function passed as a child rather than a prop.</p> Example<pre><code>const UserProfile = ({ children }) =&gt; {\nconst user = { name: 'John Doe', email: 'john.doe@example.com' };\nreturn children(user);\n};\n\nconst App = () =&gt; (\n&lt;UserProfile&gt;\n    {user =&gt; (\n    &lt;div&gt;\n        &lt;h1&gt;{user.name}&lt;/h1&gt;\n        &lt;p&gt;{user.email}&lt;/p&gt;\n    &lt;/div&gt;\n    )}\n&lt;/UserProfile&gt;\n);\n</code></pre>"},{"location":"frontend/react/example/render-props/#2-controlled-components","title":"2. Controlled Components:","text":"<p>Controlled components use props to control their behavior and render output. While this term is often associated with form elements, it can also apply to the render props pattern where a component is controlled via functions.</p>"},{"location":"frontend/react/example/render-props/#3-function-render-pattern","title":"3. Function Render Pattern:","text":"<p>This term is used interchangeably with render props to describe the pattern of using a function to determine what should be rendered.</p>"},{"location":"frontend/react/example/render-props/#4-function-as-children-pattern","title":"4. Function-as-Children Pattern:","text":"<p>Similar to function as child components, this pattern involves passing a function as a child to render UI based on some state or logic.</p> <pre><code>const DataProvider = ({ children }) =&gt; {\n  const data = ['Item 1', 'Item 2', 'Item 3'];\n  return children(data);\n};\n\nconst App = () =&gt; (\n  &lt;DataProvider&gt;\n    {data =&gt; (\n      &lt;ul&gt;\n        {data.map((item, index) =&gt; (\n          &lt;li key={index}&gt;{item}&lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n    )}\n  &lt;/DataProvider&gt;\n);\n</code></pre>"},{"location":"frontend/react/example/render-props/#5-render-function-pattern","title":"5. Render Function Pattern:","text":"<p>This term emphasizes the use of a function to handle the rendering logic within a component. It is another way to refer to the render props pattern.</p>"},{"location":"frontend/react/example/render-props/#summary","title":"Summary","text":"<p>The render props pattern is known by various names and is conceptually related to several other patterns that involve passing functions to control rendering and behavior. These patterns provide flexibility and reusability in React component design.</p>"},{"location":"frontend/react/fake-api/intro/","title":"Intro","text":"<p>Faking an API in a React application is useful for testing and development purposes. Here are a few common methods:</p>"},{"location":"frontend/react/fake-api/intro/#1-using-mock-service-workers-msw","title":"1. Using Mock Service Workers (MSW)","text":"<p>MSW is a powerful library for mocking API requests. It intercepts requests at the network level and returns mock responses. This is especially useful for integration testing and development.</p> Setup MSW: <ol> <li> <p>Install the library:</p> <pre><code>npm install msw --save-dev\n</code></pre> </li> <li> <p>Create a mock handler file (<code>mocks/handlers.js</code>):</p> <pre><code>import { rest } from 'msw';\n\nexport const handlers = [\n    rest.get('/api/your-endpoint', (req, res, ctx) =&gt; {\n        return res(ctx.json({ message: 'This is a mock response' }));\n    }),\n    // Add more handlers for different endpoints and methods\n];\n</code></pre> </li> <li> <p>Setup the mock server in your application (<code>mocks/browser.js</code>):</p> <pre><code>import { setupWorker } from 'msw';\nimport { handlers } from './handlers';\n\nconst worker = setupWorker(...handlers);\n\nworker.start();\n</code></pre> </li> <li> <p>Include the mock server setup in your application entry point (<code>index.js</code> or <code>App.js</code>):</p> <pre><code>import './mocks/browser';\n</code></pre> </li> </ol>"},{"location":"frontend/react/fake-api/intro/#2-using-json-server","title":"2. Using json-server","text":"<p>json-server is a simple tool to create a fake REST API using a JSON file.</p> <pre><code>your-project/\n\u251c\u2500\u2500 public/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 layouts/\n\u2502   \u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 utils/\n\u2502   \u251c\u2500\u2500 views/\n\u2502   \u251c\u2500\u2500 App.js\n\u2502   \u251c\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 ... (other source files)\n\u251c\u2500\u2500 db/\n\u2502   \u251c\u2500\u2500 db.json\n\u2502   \u2514\u2500\u2500 start-mock-api.js\n\u251c\u2500\u2500 node_modules/\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 webpack.config.js\n\u2514\u2500\u2500 ... (other configuration files)\n</code></pre> db.jsonstart-mock-api.jspackage.json <pre><code>{\n    \"posts\": [\n        { \"id\": 1, \"title\": \"Hello World\" },\n        { \"id\": 2, \"title\": \"json-server is awesome\" }\n    ],\n    \"comments\": [\n        { \"id\": 1, \"body\": \"some comment\", \"postId\": 1 }\n    ],\n    \"profile\": { \"name\": \"typicode\" }\n}\n</code></pre> <pre><code>const jsonServer = require('json-server');\nconst path = require('path');\nconst server = jsonServer.create();\nconst router = jsonServer.router(path.join(__dirname, 'db.json'));\nconst middlewares = jsonServer.defaults();\n\nserver.use(middlewares);\nserver.use(router);\n\nconst PORT = 5000;\nserver.listen(PORT, () =&gt; {\n    console.log(`JSON Server is running on port ${PORT}`);\n});\n</code></pre> <pre><code>\"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"dockerbuild\": \"react-scripts --openssl-legacy-provider build\",\n    \"mac-start-run\": \"react-scripts --openssl-legacy-provider start\",\n    \"test\": \"react-scripts test\",\n    \"eject\": \"react-scripts eject\",\n    \"product\": \"set PORT=4200 &amp;&amp; react-scripts start\",\n    \"start:mock-api\": \"node db/start-mock-api.js\",\n    \"start:all\": \"concurrently \\\"npm run product\\\" \\\"npm run start:mock-api\\\"\"\n}\n</code></pre> Setup json-server: <ol> <li> <p>Install <code>json-server</code>:</p> <pre><code>npm install json-server --save-dev\n\n//or\n\nnpm install json-server@0.16.3 --save-dev\n</code></pre> </li> <li> <p>Create a <code>db.json</code> file with your mock data:</p> <pre><code>{\n    \"posts\": [\n        { \"id\": 1, \"title\": \"Hello World\" }\n    ]\n}\n</code></pre> </li> <li> <p>Add a script to your <code>package.json</code> to start the server:</p> <pre><code>\"scripts\": {\n    \"start:mock-api\": \"json-server --watch db.json --port 5000\"\n}\n</code></pre> </li> <li> <p>Run the mock API server:</p> <pre><code>npm run start:mock-api\n</code></pre> </li> </ol> <p>You can now make requests to <code>http://localhost:5000/posts</code>.</p> <p>Start Both Servers:</p> <p>Use <code>concurrently</code> to start both the React app and the mock API server.</p> <pre><code>npm run start:all\n</code></pre>"},{"location":"frontend/react/fake-api/intro/#3-using-a-simple-mock-with-axios-or-fetch","title":"3. Using a Simple Mock with Axios or Fetch","text":"<p>You can create a simple mock directly in your React application by intercepting API calls with Axios or Fetch.</p> Example using Axios: <ol> <li> <p>Install Axios:</p> <pre><code>npm install axios\n</code></pre> </li> <li> <p>Create a mock API file (<code>apiMock.js</code>):</p> <pre><code>import axios from 'axios';\n\nconst mockResponse = {\n    data: { message: 'This is a mock response' },\n};\n\naxios.interceptors.request.use(request =&gt; {\n    if (request.url === '/api/your-endpoint') {\n        return Promise.resolve(mockResponse);\n    }\n    return request;\n});\n</code></pre> </li> <li> <p>Import and use the mock API file in your application (<code>App.js</code>):</p> <pre><code>import './apiMock';\n</code></pre> </li> </ol> <p>Now, when your app makes requests to <code>/api/your-endpoint</code>, it will receive the mock response.</p> <p>These methods allow you to simulate API responses and test how your React application handles different scenarios without needing a real backend.</p>"},{"location":"frontend/react/fake-api/intro/#among-the-methods-mentioned","title":"Among the methods mentioned:","text":"<ol> <li> <p>Mock Service Workers (MSW) is the most popular and widely used method for mocking APIs in modern React applications. It provides a comprehensive and flexible solution for intercepting network requests and mocking responses. MSW is especially popular in testing environments due to its ability to handle various HTTP methods and work with both REST and GraphQL APIs. It integrates well with testing libraries like Jest and React Testing Library.</p> </li> <li> <p>json-server is also popular, particularly for creating a quick and simple REST API with a JSON file. It is commonly used for local development and prototyping. While it\u2019s less flexible compared to MSW in terms of handling different types of requests and responses, it's still a useful tool for generating mock data and endpoints quickly.</p> </li> <li> <p>Using a Simple Mock with Axios or Fetch is less common compared to the other methods but can be useful for very basic scenarios or when you need a quick solution without setting up additional libraries. It\u2019s typically used for simpler use cases or when integrating mocks directly into the application code is sufficient.</p> </li> </ol> <p>For most React applications, MSW is the go-to choice due to its robust features and flexibility in handling various mocking scenarios.</p>"},{"location":"frontend/react/fake-api/json-server/","title":"Use Mocking Libraries","text":""},{"location":"frontend/react/fake-api/json-server/#2-use-mocking-libraries-eg-json-server-miragejs","title":"2. Use Mocking Libraries (e.g., <code>json-server</code>, <code>MirageJS</code>):","text":"<ul> <li><code>json-server</code>: A full fake REST API server that you can run locally.</li> </ul> <pre><code>npm install json-server\n</code></pre> Steps: <ol> <li> <p>Install json-server:</p> <pre><code>npm install -g json-server\n</code></pre> </li> <li> <p>Create a <code>db.json</code> file with some mock data:</p> json<pre><code>{\n    \"users\": [\n        { \"id\": 1, \"name\": \"John Doe\" },\n        { \"id\": 2, \"name\": \"Jane Smith\" }\n    ]\n}\n</code></pre> </li> <li> <p>Run the server:</p> <pre><code>json-server --watch db.json --port 5000\n</code></pre> </li> <li> <p>Now, you can access your API at <code>http://localhost:5000/users</code>.</p> </li> </ol> Example in Vue/React/Angular: <pre><code>fetch(\"http://localhost:5000/users\")\n.then((response) =&gt; response.json())\n.then((data) =&gt; console.log(data));\n</code></pre>"},{"location":"frontend/react/fake-api/json-server/#example","title":"Example","text":"Abstract 1. Basic Example2. Intermediate Example3. Advanced Example <p>This example will create a simple REST API using json-server to serve basic user data.</p> Steps: <ol> <li> <p>Install <code>json-server</code> globally (if not already installed):</p> <pre><code>npm install -g json-server\n</code></pre> </li> <li> <p>Create a <code>db.json</code> file:</p> <pre><code>{\n    \"users\": [\n        { \"id\": 1, \"name\": \"John Doe\", \"email\": \"john@example.com\" },\n        { \"id\": 2, \"name\": \"Jane Smith\", \"email\": \"jane@example.com\" }\n    ]\n}\n</code></pre> </li> <li> <p>Run <code>json-server</code>:</p> <pre><code>json-server --watch db.json --port 5000\n</code></pre> </li> <li> <p>Access the API:</p> <ul> <li><code>GET http://localhost:5000/users</code> will return the list of users.</li> <li><code>GET http://localhost:5000/users/1</code> will return the user with id <code>1</code>.</li> <li><code>POST</code>, <code>PUT</code>, <code>DELETE</code> operations will work automatically for <code>users</code>.</li> </ul> </li> </ol> <p>Result:</p> <ul> <li>Simple API with RESTful routes for basic CRUD operations.</li> </ul> <p>In this example, we\u2019ll add:</p> <ul> <li>Custom Routes for more control over the API.</li> <li>Pagination and Filtering using query parameters.</li> </ul> Steps: <ol> <li> <p>Create an extended <code>db.json</code> file with multiple resources:</p> <pre><code>{\n    \"users\": [\n        { \"id\": 1, \"name\": \"John Doe\", \"email\": \"john@example.com\" },\n        { \"id\": 2, \"name\": \"Jane Smith\", \"email\": \"jane@example.com\" },\n        { \"id\": 3, \"name\": \"Bill Gates\", \"email\": \"bill@microsoft.com\" },\n        { \"id\": 4, \"name\": \"Elon Musk\", \"email\": \"elon@spacex.com\" }\n    ],\n    \"posts\": [\n        { \"id\": 1, \"title\": \"Post 1\", \"content\": \"Lorem Ipsum\", \"userId\": 1 },\n        { \"id\": 2, \"title\": \"Post 2\", \"content\": \"Dolor Sit\", \"userId\": 2 },\n        { \"id\": 3, \"title\": \"Post 3\", \"content\": \"Amet Consectetur\", \"userId\": 1 }\n    ]\n}\n</code></pre> </li> <li> <p>Add a <code>routes.json</code> file to define custom routes:</p> <pre><code>{\n    \"/api/users\": \"/users\",\n    \"/api/posts\": \"/posts\"\n}\n</code></pre> </li> <li> <p>Run <code>json-server</code> with the custom routes:</p> <pre><code>json-server --watch db.json --routes routes.json --port 5000\n</code></pre> </li> <li> <p>API Features:</p> <ul> <li>Pagination: <code>GET http://localhost:5000/users?_page=1&amp;_limit=2</code> will return 2 users per page.</li> <li>Filtering: <code>GET http://localhost:5000/posts?userId=1</code> will return all posts for user with <code>userId=1</code>.</li> <li>Custom Routes: Access users via <code>GET http://localhost:5000/api/users</code>.</li> </ul> </li> </ol> <p>Result:</p> <ul> <li>More control over API routes.</li> <li>Added pagination and filtering for more realistic data operations.</li> </ul> <p>In this example, we\u2019ll demonstrate:</p> <ul> <li>Custom Middlewares for request logging.</li> <li>Delayed Responses to simulate network delays.</li> <li>Advanced Relationships between resources (users and posts).</li> </ul> Steps: <ol> <li> <p>Create a <code>db.json</code> file with more complex relationships:</p> <pre><code>{\n    \"users\": [\n        { \"id\": 1, \"name\": \"John Doe\", \"email\": \"john@example.com\" },\n        { \"id\": 2, \"name\": \"Jane Smith\", \"email\": \"jane@example.com\" }\n    ],\n    \"posts\": [\n        { \"id\": 1, \"title\": \"Post 1\", \"userId\": 1 },\n        { \"id\": 2, \"title\": \"Post 2\", \"userId\": 1 },\n        { \"id\": 3, \"title\": \"Post 3\", \"userId\": 2 }\n    ],\n    \"comments\": [\n        { \"id\": 1, \"body\": \"Nice post!\", \"postId\": 1 },\n        { \"id\": 2, \"body\": \"Thanks for sharing!\", \"postId\": 1 },\n        { \"id\": 3, \"body\": \"Great article\", \"postId\": 2 }\n    ]\n}\n</code></pre> </li> <li> <p>Create a <code>server.js</code> file to customize the server:</p> <pre><code>const jsonServer = require('json-server');\nconst server = jsonServer.create();\nconst router = jsonServer.router('db.json');\nconst middlewares = jsonServer.defaults();\nconst port = 5000;\n\n// Custom middleware to log requests\nserver.use(middlewares);\nserver.use((req, res, next) =&gt; {\n    console.log(`[LOG] Request: ${req.method} ${req.url}`);\n    next();\n});\n\n// Custom route for delayed response\nserver.get('/api/delayed-response', (req, res) =&gt; {\n    setTimeout(() =&gt; {\n        res.status(200).jsonp({ message: \"This response is delayed!\" });\n    }, 3000); // 3-second delay\n});\n\n// Use default router with pagination, filters, etc.\nserver.use(router);\n\n// Start server\nserver.listen(port, () =&gt; {\n    console.log(`JSON Server is running on http://localhost:${port}`);\n});\n</code></pre> </li> <li> <p>Run the custom server:</p> <pre><code>node server.js\n</code></pre> </li> <li> <p>API Features:</p> <ul> <li>Logging Middleware: Logs all incoming requests with their method and URL.</li> <li>Delayed Response: <code>GET http://localhost:5000/api/delayed-response</code> simulates a 3-second delay before responding.</li> <li>Relationships: <code>GET http://localhost:5000/posts?userId=1</code> will fetch posts for a specific user, and you can fetch comments for a post with <code>GET http://localhost:5000/comments?postId=1</code>.</li> </ul> </li> </ol> <p>Result:</p> <ul> <li>Advanced API with custom middlewares, delayed responses, and relationships between entities.</li> <li>You can simulate real-world scenarios with complex data structures.</li> </ul> <p>Summary:</p> <ul> <li>Basic Example: Simple CRUD operations using <code>json-server</code>.</li> <li>Intermediate Example: Added custom routes, pagination, and filtering.</li> <li>Advanced Example: Custom middlewares, delayed responses, and more complex relationships between entities.</li> </ul> <p>These progressively advanced examples help you mock an API for frontend development, simulate realistic scenarios, and add more flexibility to your workflow.</p>"},{"location":"frontend/react/fake-api/json-server/#my-json-server","title":"My JSON Server","text":"How to <ol> <li>Create a repository on GitHub (<code>&lt;your-username&gt;/&lt;your-repo&gt;</code>)</li> <li>Create a <code>db.json</code> file</li> <li>Visit https://my-json-server.typicode.com// to access your server</li> </ol> <p>No registration. Nothing to install.</p> <ul> <li>my-json-server: github</li> </ul>"},{"location":"frontend/react/fake-api/json-server/#reference","title":"Reference","text":"<ul> <li>json server: github</li> <li>my-json-server.typicode.com</li> </ul>"},{"location":"frontend/react/fake-api/topic/","title":"Topic","text":""},{"location":"frontend/react/fake-api/topic/#overview","title":"Overview","text":"<p>Mocking APIs in a React application using Redux Toolkit, Axios, and Ant Design can be effectively done using a few different approaches. Here are some of the best methods:</p>"},{"location":"frontend/react/fake-api/topic/#1-using-mock-service-worker-msw","title":"1. Using Mock Service Worker (MSW)","text":"<p>Mock Service Worker is a powerful tool for mocking API requests at the network level. It allows you to intercept network requests and provide mock responses without changing your application code.</p> <p>Setup:</p> <ol> <li> <p>Install MSW:</p> <pre><code>npm install msw --save-dev\n</code></pre> </li> <li> <p>Create a mock service worker: Create a file (e.g., <code>src/mocks/handlers.js</code>) to define your request handlers.</p> <pre><code>import { rest } from \"msw\";\n\nexport const handlers = [\n  rest.get(\"/api/data\", (req, res, ctx) =&gt; {\n    return res(ctx.status(200), ctx.json({ message: \"Success\" }));\n  }),\n  // Add more handlers as needed\n];\n</code></pre> </li> <li> <p>Set up the MSW in your application: Create a file (e.g., <code>src/mocks/browser.js</code>):</p> <pre><code>import { setupWorker } from \"msw\";\nimport { handlers } from \"./handlers\";\n\nexport const worker = setupWorker(...handlers);\n</code></pre> </li> <li> <p>Start the worker: In your main entry file (e.g., <code>index.js</code>), start the MSW worker:</p> <pre><code>import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport { worker } from \"./mocks/browser\";\n\n// Start the Mock Service Worker\nworker.start();\n\nReactDOM.render(&lt;App /&gt;, document.getElementById(\"root\"));\n</code></pre> </li> </ol>"},{"location":"frontend/react/fake-api/topic/#2-using-axios-mock-adapter","title":"2. Using Axios Mock Adapter","text":"<p>If you prefer a simpler solution, you can use the Axios Mock Adapter to mock requests.</p> <p>Setup:</p> <ol> <li> <p>Install Axios Mock Adapter:</p> <pre><code>npm install axios-mock-adapter --save-dev\n</code></pre> </li> <li> <p>Create a mock instance: You can create a file to configure your mock adapter (e.g., <code>src/mocks/axiosMock.js</code>):</p> <pre><code>import axios from \"axios\";\nimport MockAdapter from \"axios-mock-adapter\";\n\nconst mock = new MockAdapter(axios);\n\nmock.onGet(\"/api/data\").reply(200, {\n  message: \"Success\",\n});\n\nexport default mock;\n</code></pre> </li> <li> <p>Import the mock in your main entry file: Ensure that the mock is set up before your application runs:</p> <pre><code>import './mocks/axiosMock';\n</code></pre> </li> <li> <p>Static JSON Files</p> <p>For simple use cases, you can also serve static JSON files from your public folder.</p> <ol> <li> <p>Create a JSON file: Place a JSON file (e.g., <code>public/mockData.json</code>) with your mock data.</p> </li> <li> <p>Fetch the data: Use Axios to fetch this static JSON file:</p> </li> </ol> <pre><code>const fetchData = async () =&gt; {\n  const response = await axios.get(\"/mockData.json\");\n  console.log(response.data);\n};\n</code></pre> </li> </ol>"},{"location":"frontend/react/fake-api/topic/#choosing-the-best-method","title":"Choosing the Best Method","text":"<ul> <li>MSW is recommended for its flexibility and ability to simulate various scenarios (errors, delays, etc.) without changing the code.</li> <li>Axios Mock Adapter is suitable for quick setups and smaller projects where you want to mock only Axios requests.</li> <li>Static JSON files are great for very basic needs but might not cover all edge cases.</li> </ul>"},{"location":"frontend/react/fake-api/topic/#conclusion","title":"Conclusion","text":"<p>For a robust solution that integrates well with your Redux and Axios setup, Mock Service Worker is generally the best choice. It allows for easy testing and simulating real-world scenarios without much overhead.</p>"},{"location":"frontend/react/fake-api/topic/#only-run-in-development","title":"Only run in development","text":"<pre><code>// src/index.js\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport { worker } from \"./mocks/browser\";\n\nif (process.env.NODE_ENV === \"development\") {\n  worker.start();\n}\n\nReactDOM.render(&lt;App /&gt;, document.getElementById(\"root\"));\n</code></pre>"},{"location":"frontend/react/fake-api/msw/msw-version/","title":"Version","text":""},{"location":"frontend/react/fake-api/msw/msw-version/#key-changes-in-msw-v2x","title":"Key Changes in MSW <code>v2.x</code>:","text":"<p>In MSW v2.x, you\u2019ll notice the following updates compared to v1.x:</p> <ol> <li> <p>Module Name Change: rest is replaced by http. This is now a more general and flexible approach.</p> Example <ul> <li> <p>v1.x:</p> <pre><code>import { rest } from 'msw';\n</code></pre> </li> <li> <p>v2.x:</p> <pre><code>import { http } from 'msw';\n</code></pre> </li> </ul> </li> <li> <p>HTTP Method Changes: CRUD operations are handled using the new http methods: <code>.get</code>, <code>.post</code>, <code>.put</code>, <code>.delete</code>.</p> </li> <li> <p>Better Flexibility: The <code>http</code> module gives you a more consistent and extendable way to mock requests across different types of HTTP methods.</p> </li> </ol>"},{"location":"frontend/react/fake-api/msw/msw-version/#curd-in-msw","title":"CURD in msw","text":"<pre><code>import { http } from \"msw\";\n\nconst handlers = [\n  // Create: POST\n  http.post(\"/create\", (req, res, ctx) =&gt; {\n    const { name, email } = req.body;\n    return res(\n      ctx.status(201),\n      ctx.json({ message: \"User created\", name, email })\n    );\n  }),\n\n  // Read: GET\n  http.get(\"/user\", (req, res, ctx) =&gt; {\n    return res(\n      ctx.status(200),\n      ctx.json({ name: \"John Doe\", email: \"john@example.com\" })\n    );\n  }),\n\n  // Update: PUT\n  http.put(\"/update\", (req, res, ctx) =&gt; {\n    const { name, email } = req.body;\n    return res(\n      ctx.status(200),\n      ctx.json({ message: \"User updated\", name, email })\n    );\n  }),\n\n  // Delete: DELETE\n  http.delete(\"/delete\", (req, res, ctx) =&gt; {\n    return res(ctx.status(200), ctx.json({ message: \"User deleted\" }));\n  }),\n];\n\nexport { handlers };\n</code></pre>"},{"location":"frontend/react/fake-api/msw/msw-version/#reference","title":"Reference","text":"<ul> <li>msw 2.0</li> </ul>"},{"location":"frontend/react/fake-api/msw/msw/","title":"Mock Services with Browser APIs","text":"<p>To fake an API for consumption in your frontend (React, Vue, Angular), you can use different tools and techniques, such as setting up a mock server or using third-party libraries. Here are a few common approaches:</p> 1. Use Mock Services in JavaScript: <p>You can define mock data directly in your frontend project for development and testing.</p> <pre><code>// Sample mock data\nconst mockData = [\n{ id: 1, name: \"John Doe\", age: 30 },\n{ id: 2, name: \"Jane Smith\", age: 25 },\n];\n\n// Mock API call\nexport const fetchMockData = () =&gt; {\nreturn new Promise((resolve) =&gt; {\n    setTimeout(() =&gt; {\n    resolve(mockData);\n    }, 1000); // Simulating network delay\n});\n};\n\n// In your React component\nuseEffect(() =&gt; {\nfetchMockData().then((data) =&gt; {\n    console.log(data); // Handle the data\n});\n}, []);\n</code></pre> 3. Use Axios Interceptors (or Fetch Mocking): <p>You can intercept network requests in your frontend using Axios or Fetch to return fake responses.</p> Axios Example:<pre><code>import axios from 'axios';\n\n// Create a mock Axios instance\nconst mockAxios = axios.create();\n\n// Intercept requests and return mock data\nmockAxios.interceptors.request.use((config) =&gt; {\n    if (config.url === '/api/users') {\n        return Promise.resolve({\n            data: [{ id: 1, name: 'John Doe' }, { id: 2, name: 'Jane Smith' }],\n        });\n    }\n    return config;\n});\n\n// In your component\nuseEffect(() =&gt; {\n    mockAxios.get('/api/users').then((response) =&gt; {\n        console.log(response.data); // Fake data\n    });\n}, []);\n</code></pre>"},{"location":"frontend/react/fake-api/msw/msw/#4-mock-services-with-browser-apis-eg-fetch-mock-msw","title":"4. Mock Services with Browser APIs (e.g., <code>fetch-mock</code>, <code>msw</code>):","text":"<ul> <li><code>fetch-mock</code>: Mock fetch requests.</li> <li>MSW (Mock Service Worker): An API mocking library that works by intercepting requests via Service Workers.</li> </ul> MSW Example: <ol> <li> <p>Install <code>msw</code>:</p> <pre><code>npm install msw --save-dev\n</code></pre> </li> <li> <p>Setup <code>msw</code>:</p> <pre><code>import { setupWorker, rest } from \"msw\";\n\n// Define request handlers\nconst worker = setupWorker(\n    rest.get(\"/api/users\", (req, res, ctx) =&gt; {\n        return res(\n            ctx.json([\n                { id: 1, name: \"John Doe\" },\n                { id: 2, name: \"Jane Smith\" },\n            ])\n        );\n    })\n);\n\n// Start the worker\nworker.start();\n</code></pre> <p>These methods let you easily fake APIs to speed up frontend development without depending on a backend. You can choose the best approach depending on your stack and workflow!</p> </li> <li> <p>Browser integration </p> <pre><code>npx msw init &lt;PUBLIC_DIR&gt; --save\n\nnpx msw init public --save\n</code></pre> </li> </ol>"},{"location":"frontend/react/folder-structure/feature-based-pattern/","title":"Feature Based","text":""},{"location":"frontend/react/folder-structure/feature-based-pattern/#overview","title":"Overview","text":"<pre><code>src/\n\u251c\u2500\u2500 app/                              # Application-wide configuration and logic\n\u2502   \u251c\u2500\u2500 api/                          # RTK Query base API and custom APIs\n\u2502   \u2502   \u251c\u2500\u2500 apiSlice.js               # Base RTK Query API slice\n\u2502   \u2502   \u251c\u2500\u2500 authApi.js                # Custom RTK Query API for auth\n\u2502   \u2502   \u2514\u2500\u2500 balanceApi.js             # Custom RTK Query API for balance\n\u2502   \u251c\u2500\u2500 socket.js                     # WebSocket setup and instance\n\u2502   \u251c\u2500\u2500 store.js                      # Redux store configuration\n\u2502   \u2514\u2500\u2500 theme.js                      # Ant Design theme customization\n\u2502\n\u251c\u2500\u2500 features/                         # Feature-specific folders\n\u2502   \u251c\u2500\u2500 auth/                         # Authentication feature\n\u2502   \u2502   \u251c\u2500\u2500 components/               # Reusable components for auth\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 LoginForm.js          # Login form\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 SignupForm.js         # Signup form\n\u2502   \u2502   \u251c\u2500\u2500 hooks/                    # Custom hooks for auth\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 useAuth.js            # Hook for authentication logic\n\u2502   \u2502   \u251c\u2500\u2500 pages/                    # Page components for auth\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 LoginPage.js          # Login page\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 SignupPage.js         # Signup page\n\u2502   \u2502   \u2514\u2500\u2500 index.js                  # Barrel export for the feature\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 dashboard/                    # Dashboard feature\n\u2502   \u2502   \u251c\u2500\u2500 components/               # Reusable dashboard components\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 SummaryCards.js       # Summary card component\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 ActivityTable.js      # Table for recent activities\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 BalanceChart.js       # Graph for balance tracking\n\u2502   \u2502   \u251c\u2500\u2500 hooks/                    # Custom hooks for dashboard\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 useDashboardData.js   # Hook for fetching dashboard data\n\u2502   \u2502   \u251c\u2500\u2500 pages/                    # Page components for dashboard\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 DashboardPage.js      # Dashboard main page\n\u2502   \u2502   \u2514\u2500\u2500 index.js                  # Barrel export for the feature\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 balance/                      # Balance management feature\n\u2502   \u2502   \u251c\u2500\u2500 components/               # Reusable components for balance\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 BalanceForm.js        # Form for balance management\n\u2502   \u2502   \u251c\u2500\u2500 hooks/                    # Custom hooks for balance\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 useBalance.js         # Hook for balance-related logic\n\u2502   \u2502   \u251c\u2500\u2500 pages/                    # Page components for balance\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 BalancePage.js        # Balance management page\n\u2502   \u2502   \u2514\u2500\u2500 index.js                  # Barrel export for the feature\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 spending/                     # Spending management feature\n\u2502   \u2502   \u251c\u2500\u2500 components/               # Components for spending\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 SpendingTable.js      # Table for spending breakdown\n\u2502   \u2502   \u251c\u2500\u2500 hooks/                    # Custom hooks for spending\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 useSpending.js        # Hook for spending-related logic\n\u2502   \u2502   \u251c\u2500\u2500 pages/                    # Page components for spending\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 SpendingPage.js       # Spending management page\n\u2502   \u2502   \u2514\u2500\u2500 index.js                  # Barrel export for the feature\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 reports/                      # Reports feature\n\u2502   \u2502   \u251c\u2500\u2500 components/               # Components for reports\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 ReportsChart.js       # Chart for reports\n\u2502   \u2502   \u251c\u2500\u2500 hooks/                    # Custom hooks for reports\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 useReports.js         # Hook for reports data\n\u2502   \u2502   \u251c\u2500\u2500 pages/                    # Page components for reports\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 ReportsPage.js        # Reports main page\n\u2502   \u2502   \u2514\u2500\u2500 index.js                  # Barrel export for the feature\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 profile/                      # User profile feature\n\u2502       \u251c\u2500\u2500 components/               # Components for profile\n\u2502       \u2502   \u2514\u2500\u2500 ProfileForm.js        # Form for editing user profile\n\u2502       \u251c\u2500\u2500 hooks/                    # Hooks for profile logic\n\u2502       \u2502   \u2514\u2500\u2500 useProfile.js         # Hook for user profile logic\n\u2502       \u251c\u2500\u2500 pages/                    # Page components for profile\n\u2502       \u2502   \u2514\u2500\u2500 ProfilePage.js        # User profile page\n\u2502       \u2514\u2500\u2500 index.js                  # Barrel export for the feature\n\u2502\n\u251c\u2500\u2500 mocks/                            # Mock APIs using MSW\n\u2502   \u251c\u2500\u2500 browser.js                    # MSW setup for the browser\n\u2502   \u251c\u2500\u2500 handlers/                     # Handlers for API routes\n\u2502   \u2502   \u251c\u2500\u2500 balanceHandlers.js        # Handlers for balance routes\n\u2502   \u2502   \u251c\u2500\u2500 spendingHandlers.js       # Handlers for spending routes\n\u2502   \u2502   \u2514\u2500\u2500 userHandlers.js           # Handlers for user routes\n\u2502   \u2514\u2500\u2500 mockData/                     # Predefined mock data\n\u2502       \u2514\u2500\u2500 users.js                  # Sample user data\n\u2502\n\u251c\u2500\u2500 routes/                           # Centralized routing logic\n\u2502   \u251c\u2500\u2500 AppRoutes.js                  # Application routes\n\u2502   \u251c\u2500\u2500 ProtectedRoute.js             # Auth-guarded route\n\u2502   \u251c\u2500\u2500 Layout.js                     # Layout component for nested routes\n\u2502   \u2514\u2500\u2500 SidebarConfig.js              # Configuration for sidebar navigation\n\u2502\n\u251c\u2500\u2500 shared/                           # Shared resources\n\u2502   \u251c\u2500\u2500 components/                   # Generic components\n\u2502   \u2502   \u251c\u2500\u2500 Header.js                 # App header\n\u2502   \u2502   \u251c\u2500\u2500 Footer.js                 # App footer\n\u2502   \u2502   \u2514\u2500\u2500 Sidebar.js                # Sidebar navigation\n\u2502   \u251c\u2500\u2500 constants/                    # Constants and enums\n\u2502   \u2502   \u2514\u2500\u2500 roles.js                  # User role definitions\n\u2502   \u251c\u2500\u2500 hooks/                        # Shared hooks\n\u2502   \u2502   \u251c\u2500\u2500 useAuth.js                # Authentication hook\n\u2502   \u2502   \u2514\u2500\u2500 useSocket.js              # WebSocket connection hook\n\u2502   \u251c\u2500\u2500 utils/                        # Utility functions\n\u2502   \u2502   \u251c\u2500\u2500 formatDate.js             # Date formatting\n\u2502   \u2502   \u2514\u2500\u2500 formatCurrency.js         # Currency formatting\n\u2502   \u251c\u2500\u2500 HOC/                          # Higher-order components\n\u2502   \u2502   \u2514\u2500\u2500 withErrorBoundary.js      # Error boundary wrapper\n\u2502   \u251c\u2500\u2500 styles/                       # Global styles\n\u2502   \u2502   \u2514\u2500\u2500 variables.less            # Ant Design style overrides\n\u2502   \u2514\u2500\u2500 theme.js                      # Ant Design theme setup\n\u2502\n\u251c\u2500\u2500 styles/                           # Global styling\n\u2502   \u251c\u2500\u2500 index.css                     # Base styles\n\u2502   \u251c\u2500\u2500 overrides.css                 # Ant Design overrides\n\u2502   \u2514\u2500\u2500 themes/                       # Additional themes\n\u2502       \u2514\u2500\u2500 dark.css                  # Dark theme styles\n\u2502\n\u251c\u2500\u2500 App.js                            # Main application component\n\u251c\u2500\u2500 main.js                           # React and Redux entry point\n\u2514\u2500\u2500 index.html                        # HTML entry point . give me code example of balance pages example and components example\n</code></pre> <p>Here's an example of how the code for the Balance feature in your structure might look. I'll provide the following:</p> <ul> <li><code>BalancePage.js</code> \u2014 A page component that uses the balance-related functionality.</li> <li><code>BalanceForm.js</code> \u2014 A form component for adding or managing balance.</li> </ul> BalancePage.jsBalanceForm.jsuseBalance.js (Hook)store.js (Redux store) <pre><code>// src/features/balance/pages/BalancePage.js\n\nimport React, { useEffect } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { fetchBalance } from \"../hooks/useBalance\";\nimport BalanceForm from \"../components/BalanceForm\";\nimport { Card, Typography, Spin } from \"antd\";\n\nconst { Title } = Typography;\n\nconst BalancePage = () =&gt; {\n    const dispatch = useDispatch();\n\n    // Assuming you have a balance state in the store\n    const balanceData = useSelector((state) =&gt; state.balance.data);\n    const isLoading = useSelector((state) =&gt; state.balance.isLoading);\n    const error = useSelector((state) =&gt; state.balance.error);\n\n    useEffect(() =&gt; {\n        dispatch(fetchBalance());\n    }, [dispatch]);\n\n    if (isLoading) {\n        return &lt;Spin size=\"large\" /&gt;;\n    }\n\n    if (error) {\n        return &lt;div&gt;Error loading balance: {error.message}&lt;/div&gt;;\n    }\n\n    return (\n        &lt;div&gt;\n            &lt;Title level={2}&gt;Manage Balance&lt;/Title&gt;\n\n            {/* Display balance summary */}\n            &lt;Card title=\"Current Balance\"&gt;\n                &lt;p&gt;\n                {balanceData\n                    ? `Balance: $${balanceData.amount}`\n                    : \"No balance available\"}\n                &lt;/p&gt;\n            &lt;/Card&gt;\n\n            {/* Balance management form */}\n            &lt;BalanceForm /&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default BalancePage;\n</code></pre> <p>This is the form component for managing the balance, including updating the balance.</p> <pre><code>// src/features/balance/components/BalanceForm.js\n\nimport React, { useState } from \"react\";\nimport { useDispatch } from \"react-redux\";\nimport { Form, Input, Button, message } from \"antd\";\nimport { updateBalance } from \"../hooks/useBalance\";\n\nconst BalanceForm = () =&gt; {\n    const [form] = Form.useForm();\n    const dispatch = useDispatch();\n    const [isSubmitting, setIsSubmitting] = useState(false);\n\n    const handleSubmit = async (values) =&gt; {\n        setIsSubmitting(true);\n        try {\n            // Dispatch action to update balance\n            await dispatch(updateBalance(values.amount));\n            message.success(\"Balance updated successfully!\");\n            form.resetFields();\n        } catch (error) {\n            message.error(\"Failed to update balance\");\n        } finally {\n            setIsSubmitting(false);\n        }\n    };\n\n    return (\n        &lt;Form form={form} layout=\"vertical\" onFinish={handleSubmit}&gt;\n            &lt;Form.Item\n                label=\"Amount\"\n                name=\"amount\"\n                rules={[\n                    { required: true, message: \"Please input the balance amount!\" },\n                ]}\n            &gt;\n                &lt;Input type=\"number\" placeholder=\"Enter amount\" /&gt;\n            &lt;/Form.Item&gt;\n\n            &lt;Button type=\"primary\" htmlType=\"submit\" loading={isSubmitting}&gt;\n                Update Balance\n            &lt;/Button&gt;\n        &lt;/Form&gt;\n    );\n};\n\nexport default BalanceForm;\n</code></pre> <p>To handle the logic for fetching and updating the balance, you would typically use a custom hook like <code>useBalance.js</code>. Here's an example of that:</p> <pre><code>// src/features/balance/hooks/useBalance.js\n\nimport { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\nimport { api } from '../../app/api/apiSlice';  // Assuming apiSlice is configured\n\n// Thunk for fetching balance\nexport const fetchBalance = createAsyncThunk(\n    'balance/fetchBalance',\n    async () =&gt; {\n        const response = await api.get('/balance');  // Replace with actual endpoint\n        return response.data;\n    }\n);\n\n// Thunk for updating balance\nexport const updateBalance = createAsyncThunk(\n    'balance/updateBalance',\n    async (amount) =&gt; {\n        const response = await api.post('/balance/update', { amount });\n        return response.data;\n    }\n);\n\n// Slice for balance state\nconst balanceSlice = createSlice({\n    name: 'balance',\n    initialState: {\n        data: null,\n        isLoading: false,\n        error: null,\n    },\n    reducers: {},\n    extraReducers: (builder) =&gt; {\n        builder\n            .addCase(fetchBalance.pending, (state) =&gt; {\n                state.isLoading = true;\n            })\n            .addCase(fetchBalance.fulfilled, (state, action) =&gt; {\n                state.isLoading = false;\n                state.data = action.payload;\n            })\n            .addCase(fetchBalance.rejected, (state, action) =&gt; {\n                state.isLoading = false;\n                state.error = action.error;\n            })\n            .addCase(updateBalance.pending, (state) =&gt; {\n                state.isLoading = true;\n            })\n            .addCase(updateBalance.fulfilled, (state, action) =&gt; {\n                state.isLoading = false;\n                state.data = action.payload;\n            })\n            .addCase(updateBalance.rejected, (state, action) =&gt; {\n                state.isLoading = false;\n                state.error = action.error;\n            });\n    },\n});\n\nexport default balanceSlice.reducer;\n</code></pre> <p>Make sure the balance slice is added to the Redux store configuration.</p> <pre><code>// src/app/store.js\n\nimport { configureStore } from '@reduxjs/toolkit';\nimport balanceReducer from '../features/balance/hooks/useBalance';\n\nexport const store = configureStore({\n    reducer: {\n        balance: balanceReducer,\n    },\n});\n</code></pre>"},{"location":"frontend/react/folder-structure/feature-based-pattern/#explanation","title":"Explanation:","text":"<ul> <li><code>BalancePage.js</code>: This page is responsible for fetching and displaying balance-related data, including rendering the <code>BalanceForm</code> for updating the balance.</li> <li><code>BalanceForm.js</code>: A form that allows the user to update their balance. It uses Ant Design's <code>Form</code> and <code>Button</code> components to handle the input and submit functionality.</li> <li><code>useBalance.js</code>: A custom hook that manages state related to fetching and updating the balance. It uses Redux Toolkit's <code>createSlice</code> and <code>createAsyncThunk</code> to handle asynchronous operations such as fetching and updating the balance from an API.</li> </ul> <p>This setup provides a clean structure for managing balance-related logic, API calls, and UI components in your application.</p>"},{"location":"frontend/react/folder-structure/feature-based-pattern/#feature-based-folder-structure","title":"Feature-Based Folder Structure","text":"ExampleAdvanced <pre><code>src/\n\u251c\u2500\u2500 app/                              # Application-level configuration\n\u2502   \u251c\u2500\u2500 store.js                      # Redux store setup with RTK Query\n\u2502   \u251c\u2500\u2500 apiSlice.js                   # Base API slice for RTK Query\n\u2502   \u2514\u2500\u2500 socket.js                     # WebSocket configuration (if needed)\n\u2502\n\u251c\u2500\u2500 features/                         # Feature-specific folders\n\u2502   \u251c\u2500\u2500 auth/                         # Authentication feature\n\u2502   \u2502   \u251c\u2500\u2500 components/               # Reusable components for auth\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 LoginForm.js          # Login form component\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 SignupForm.js         # Signup form component\n\u2502   \u2502   \u251c\u2500\u2500 authApiSlice.js           # RTK Query slice for authentication\n\u2502   \u2502   \u251c\u2500\u2500 AuthPage.js               # Authentication page\n\u2502   \u2502   \u2514\u2500\u2500 index.js                  # Feature entry point\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 dashboard/                    # Dashboard feature\n\u2502   \u2502   \u251c\u2500\u2500 components/               # Reusable components for dashboard\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 SummaryCards.js       # Summary cards component\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 BalanceChart.js       # Balance chart component\n\u2502   \u2502   \u251c\u2500\u2500 dashboardApiSlice.js      # RTK Query slice for dashboard data\n\u2502   \u2502   \u251c\u2500\u2500 DashboardPage.js          # Dashboard main page\n\u2502   \u2502   \u2514\u2500\u2500 index.js                  # Feature entry point\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 balance/                      # Balance management feature\n\u2502   \u2502   \u251c\u2500\u2500 components/               # Reusable components for balance\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 BalanceForm.js        # Balance update form component\n\u2502   \u2502   \u251c\u2500\u2500 balanceApiSlice.js        # RTK Query slice for balance data\n\u2502   \u2502   \u251c\u2500\u2500 BalancePage.js            # Balance management page\n\u2502   \u2502   \u2514\u2500\u2500 index.js                  # Feature entry point\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 spending/                     # Spending management feature\n\u2502   \u2502   \u251c\u2500\u2500 components/               # Reusable components for spending\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 SpendingTable.js      # Spending table component\n\u2502   \u2502   \u251c\u2500\u2500 spendingApiSlice.js       # RTK Query slice for spending data\n\u2502   \u2502   \u251c\u2500\u2500 SpendingPage.js           # Spending management page\n\u2502   \u2502   \u2514\u2500\u2500 index.js                  # Feature entry point\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 reports/                      # Reports feature\n\u2502       \u251c\u2500\u2500 components/               # Reusable components for reports\n\u2502       \u2502   \u2514\u2500\u2500 ReportsChart.js       # Reports chart component\n\u2502       \u251c\u2500\u2500 reportsApiSlice.js        # RTK Query slice for reports data\n\u2502       \u251c\u2500\u2500 ReportsPage.js            # Reports main page\n\u2502       \u2514\u2500\u2500 index.js                  # Feature entry point\n\u2502\n\u251c\u2500\u2500 mocks/                            # Mock Service Worker setup\n\u2502   \u251c\u2500\u2500 browser.js                    # MSW browser setup\n\u2502   \u251c\u2500\u2500 handlers.js                   # API handlers\n\u2502   \u2514\u2500\u2500 mockData.js                   # Mock data for testing\n\u2502\n\u251c\u2500\u2500 routes/                           # Centralized route definitions\n\u2502   \u251c\u2500\u2500 ProtectedRoute.js             # Route guard for authenticated access\n\u2502   \u2514\u2500\u2500 AppRoutes.js                  # Application route definitions\n\u2502\n\u251c\u2500\u2500 shared/                           # Shared resources across features\n\u2502   \u251c\u2500\u2500 components/                   # Reusable components\n\u2502   \u2502   \u251c\u2500\u2500 Header.js                 # App header\n\u2502   \u2502   \u251c\u2500\u2500 Sidebar.js                # Navigation sidebar\n\u2502   \u2502   \u2514\u2500\u2500 Footer.js                 # App footer\n\u2502   \u251c\u2500\u2500 hooks/                        # Custom hooks\n\u2502   \u2502   \u251c\u2500\u2500 useAuth.js                # Authentication hook\n\u2502   \u2502   \u2514\u2500\u2500 useSocket.js              # WebSocket hook\n\u2502   \u251c\u2500\u2500 utils/                        # Utility functions\n\u2502   \u2502   \u2514\u2500\u2500 formatCurrency.js         # Utility for formatting currency\n\u2502   \u251c\u2500\u2500 constants.js                  # Shared constants\n\u2502   \u2514\u2500\u2500 theme.js                      # Ant Design theme customization\n\u2502\n\u251c\u2500\u2500 styles/                           # Global styles\n\u2502   \u2514\u2500\u2500 index.css                     # Global CSS styles\n\u2502\n\u251c\u2500\u2500 App.js                            # Main application component\n\u2514\u2500\u2500 main.js                           # Entry point for React and MSW\n</code></pre> <pre><code>src/\n\u251c\u2500\u2500 app/                              # Application-wide configuration and logic\n\u2502   \u251c\u2500\u2500 api/                          # RTK Query base API and custom APIs\n\u2502   \u2502   \u251c\u2500\u2500 apiSlice.js               # Base RTK Query API slice\n\u2502   \u2502   \u251c\u2500\u2500 authApi.js                # Custom RTK Query API for auth\n\u2502   \u2502   \u2514\u2500\u2500 balanceApi.js             # Custom RTK Query API for balance\n\u2502   \u251c\u2500\u2500 socket.js                     # WebSocket setup and instance\n\u2502   \u251c\u2500\u2500 store.js                      # Redux store configuration\n\u2502   \u2514\u2500\u2500 theme.js                      # Ant Design theme customization\n\u2502\n\u251c\u2500\u2500 features/                         # Feature-specific folders\n\u2502   \u251c\u2500\u2500 auth/                         # Authentication feature\n\u2502   \u2502   \u251c\u2500\u2500 components/               # Reusable components for auth\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 LoginForm.js          # Login form\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 SignupForm.js         # Signup form\n\u2502   \u2502   \u251c\u2500\u2500 hooks/                    # Custom hooks for auth\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 useAuth.js            # Hook for authentication logic\n\u2502   \u2502   \u251c\u2500\u2500 pages/                    # Page components for auth\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 LoginPage.js          # Login page\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 SignupPage.js         # Signup page\n\u2502   \u2502   \u2514\u2500\u2500 index.js                  # Barrel export for the feature\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 dashboard/                    # Dashboard feature\n\u2502   \u2502   \u251c\u2500\u2500 components/               # Reusable dashboard components\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 SummaryCards.js       # Summary card component\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 ActivityTable.js      # Table for recent activities\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 BalanceChart.js       # Graph for balance tracking\n\u2502   \u2502   \u251c\u2500\u2500 hooks/                    # Custom hooks for dashboard\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 useDashboardData.js   # Hook for fetching dashboard data\n\u2502   \u2502   \u251c\u2500\u2500 pages/                    # Page components for dashboard\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 DashboardPage.js      # Dashboard main page\n\u2502   \u2502   \u2514\u2500\u2500 index.js                  # Barrel export for the feature\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 balance/                      # Balance management feature\n\u2502   \u2502   \u251c\u2500\u2500 components/               # Reusable components for balance\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 BalanceForm.js        # Form for balance management\n\u2502   \u2502   \u251c\u2500\u2500 hooks/                    # Custom hooks for balance\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 useBalance.js         # Hook for balance-related logic\n\u2502   \u2502   \u251c\u2500\u2500 pages/                    # Page components for balance\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 BalancePage.js        # Balance management page\n\u2502   \u2502   \u2514\u2500\u2500 index.js                  # Barrel export for the feature\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 spending/                     # Spending management feature\n\u2502   \u2502   \u251c\u2500\u2500 components/               # Components for spending\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 SpendingTable.js      # Table for spending breakdown\n\u2502   \u2502   \u251c\u2500\u2500 hooks/                    # Custom hooks for spending\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 useSpending.js        # Hook for spending-related logic\n\u2502   \u2502   \u251c\u2500\u2500 pages/                    # Page components for spending\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 SpendingPage.js       # Spending management page\n\u2502   \u2502   \u2514\u2500\u2500 index.js                  # Barrel export for the feature\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 reports/                      # Reports feature\n\u2502   \u2502   \u251c\u2500\u2500 components/               # Components for reports\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 ReportsChart.js       # Chart for reports\n\u2502   \u2502   \u251c\u2500\u2500 hooks/                    # Custom hooks for reports\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 useReports.js         # Hook for reports data\n\u2502   \u2502   \u251c\u2500\u2500 pages/                    # Page components for reports\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 ReportsPage.js        # Reports main page\n\u2502   \u2502   \u2514\u2500\u2500 index.js                  # Barrel export for the feature\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 profile/                      # User profile feature\n\u2502       \u251c\u2500\u2500 components/               # Components for profile\n\u2502       \u2502   \u2514\u2500\u2500 ProfileForm.js        # Form for editing user profile\n\u2502       \u251c\u2500\u2500 hooks/                    # Hooks for profile logic\n\u2502       \u2502   \u2514\u2500\u2500 useProfile.js         # Hook for user profile logic\n\u2502       \u251c\u2500\u2500 pages/                    # Page components for profile\n\u2502       \u2502   \u2514\u2500\u2500 ProfilePage.js        # User profile page\n\u2502       \u2514\u2500\u2500 index.js                  # Barrel export for the feature\n\u2502\n\u251c\u2500\u2500 mocks/                            # Mock APIs using MSW\n\u2502   \u251c\u2500\u2500 browser.js                    # MSW setup for the browser\n\u2502   \u251c\u2500\u2500 handlers/                     # Handlers for API routes\n\u2502   \u2502   \u251c\u2500\u2500 balanceHandlers.js        # Handlers for balance routes\n\u2502   \u2502   \u251c\u2500\u2500 spendingHandlers.js       # Handlers for spending routes\n\u2502   \u2502   \u2514\u2500\u2500 userHandlers.js           # Handlers for user routes\n\u2502   \u2514\u2500\u2500 mockData/                     # Predefined mock data\n\u2502       \u2514\u2500\u2500 users.js                  # Sample user data\n\u2502\n\u251c\u2500\u2500 routes/                           # Centralized routing logic\n\u2502   \u251c\u2500\u2500 AppRoutes.js                  # Application routes\n\u2502   \u251c\u2500\u2500 ProtectedRoute.js             # Auth-guarded route\n\u2502   \u251c\u2500\u2500 Layout.js                     # Layout component for nested routes\n\u2502   \u2514\u2500\u2500 SidebarConfig.js              # Configuration for sidebar navigation\n\u2502\n\u251c\u2500\u2500 shared/                           # Shared resources\n\u2502   \u251c\u2500\u2500 components/                   # Generic components\n\u2502   \u2502   \u251c\u2500\u2500 Header.js                 # App header\n\u2502   \u2502   \u251c\u2500\u2500 Footer.js                 # App footer\n\u2502   \u2502   \u2514\u2500\u2500 Sidebar.js                # Sidebar navigation\n\u2502   \u251c\u2500\u2500 constants/                    # Constants and enums\n\u2502   \u2502   \u2514\u2500\u2500 roles.js                  # User role definitions\n\u2502   \u251c\u2500\u2500 hooks/                        # Shared hooks\n\u2502   \u2502   \u251c\u2500\u2500 useAuth.js                # Authentication hook\n\u2502   \u2502   \u2514\u2500\u2500 useSocket.js              # WebSocket connection hook\n\u2502   \u251c\u2500\u2500 utils/                        # Utility functions\n\u2502   \u2502   \u251c\u2500\u2500 formatDate.js             # Date formatting\n\u2502   \u2502   \u2514\u2500\u2500 formatCurrency.js         # Currency formatting\n\u2502   \u251c\u2500\u2500 HOC/                          # Higher-order components\n\u2502   \u2502   \u2514\u2500\u2500 withErrorBoundary.js      # Error boundary wrapper\n\u2502   \u251c\u2500\u2500 styles/                       # Global styles\n\u2502   \u2502   \u2514\u2500\u2500 variables.less            # Ant Design style overrides\n\u2502   \u2514\u2500\u2500 theme.js                      # Ant Design theme setup\n\u2502\n\u251c\u2500\u2500 styles/                           # Global styling\n\u2502   \u251c\u2500\u2500 index.css                     # Base styles\n\u2502   \u251c\u2500\u2500 overrides.css                 # Ant Design overrides\n\u2502   \u2514\u2500\u2500 themes/                       # Additional themes\n\u2502       \u2514\u2500\u2500 dark.css                  # Dark theme styles\n\u2502\n\u251c\u2500\u2500 App.js                            # Main application component\n\u251c\u2500\u2500 main.js                           # React and Redux entry point\n\u2514\u2500\u2500 index.html                        # HTML entry point\n</code></pre>"},{"location":"frontend/react/folder-structure/feature-based-pattern/#related-blogs","title":"Related Blogs","text":"<ul> <li>Application Structure for React</li> </ul>"},{"location":"frontend/react/folder-structure/intro/","title":"Intro","text":"<p>React Folder Structure Patterns Explained: From Simple to Scalable Architectures</p> <p>Choosing the right folder structure depends on the size of your project, the complexity of the app, and how you intend to scale it. Here's a recap of which structure works best for which scenario:</p> <ul> <li>Flat Structure: Good for small apps and quick prototypes.</li> <li>Feature-Based Structure: Ideal for medium to large apps, especially for teams working on separate features.</li> <li>Domain-Based Structure: Best for large apps with multiple business domains.</li> <li>Component-Based Structure: Great for smaller apps or component libraries where reuse is key.</li> <li>Container/Presentational: Useful for separating UI from logic, especially in larger apps.</li> <li>Atomic Design: Perfect for design systems or large applications with a need for reusable UI components.</li> </ul> <p>In the end, choose a structure that balances maintainability, scalability, and the ability for your team to work independently</p>"},{"location":"frontend/react/folder-structure/react-architecture/","title":"Architecture","text":""},{"location":"frontend/react/folder-structure/react-architecture/#overview","title":"Overview","text":"<p>When designing a web application with React, it's crucial to establish a solid architecture that promotes maintainability, scalability, and reusability. Below is an architecture that works well for most medium-to-large-scale React applications. This architecture is modular, separates concerns, and is flexible enough to adapt to changes as your app grows.</p>"},{"location":"frontend/react/folder-structure/react-architecture/#1-folder-structure","title":"1. Folder Structure","text":"<p>Here's a common folder structure for a React web application:</p> <pre><code>/src\n  /assets               # Images, fonts, icons, etc.\n  /components           # Reusable UI components (buttons, modals, etc.)\n  /hooks                # Custom hooks\n  /pages                # Components tied to routes (representing a screen)\n  /services             # API calls, data fetching logic\n  /store                # State management (Redux, Zustand, Recoil, etc.)\n  /utils                # Utility functions (helpers, formatters, validators, etc.)\n  /context              # React Context providers\n  /styles               # Global CSS, or styled-components\n  /tests                # Unit and integration tests\n  App.js                # Root component, can include global layout\n  index.js              # Entry point for React (where rendering occurs)\n</code></pre>"},{"location":"frontend/react/folder-structure/react-architecture/#2-key-architectural-concepts","title":"2. Key Architectural Concepts","text":"<p>2.1 Component-Based Architecture</p> <p>React encourages a component-based structure. Components are modular, self-contained pieces of UI and logic. In large applications, it's common to break down components into:</p> <ul> <li>Atomic Components: These are small UI building blocks, like buttons, inputs, modals, etc.</li> <li>Container/Presentational Components: Container components handle business logic (state, side effects), while presentational components focus solely on rendering.</li> <li>Page Components: Components tied to routes, representing whole pages or sections of the app.</li> </ul> <p>2.2 State Management</p> <p>State management is key to a React app\u2019s scalability. You have several options:</p> <ul> <li>Local State: Managed using React's <code>useState</code> and <code>useReducer</code>.</li> <li>Context API: Good for passing down state globally (e.g., for authentication state or theme).</li> <li>External State Management (e.g., Redux, Zustand, Recoil): If your app grows complex with a lot of shared state, using a more robust state management solution like Redux or Zustand might be necessary.</li> </ul> <p>Consider the complexity of your app before jumping into a large state management library like Redux. If the app is small to medium-sized, React's built-in <code>useState</code>, <code>useContext</code>, or <code>useReducer</code> might suffice.</p> <p>2.3 Routing</p> <p>For routing, use a library like react-router-dom to handle different pages in the application. The routes are typically defined at a higher level in your app, often in App.js or a dedicated Routes.js file.</p> <p>2.4 Component Libraries and Design Systems</p> <p>To speed up UI development, you can use a component library or build your own design system. Popular libraries include:</p> <ul> <li>Material-UI: A popular React component library.</li> <li>Chakra UI: A flexible, accessible UI library.</li> <li>Ant Design: A robust set of UI components.</li> </ul> <p>You can also design a custom UI kit with styled-components or Tailwind CSS.</p> <p>2.5 API Layer</p> <p>For API calls, abstract the logic in separate services (in <code>/services</code>) to keep components decoupled from data-fetching logic. Use libraries like axios or the native fetch API.</p> <p>A service file could look like this:</p> <pre><code>// services/api.js\nimport axios from \"axios\";\n\nconst api = axios.create({\n  baseURL: \"https://api.example.com\",\n  timeout: 5000,\n});\n\nexport const fetchData = async () =&gt; {\n  try {\n    const response = await api.get(\"/data\");\n    return response.data;\n  } catch (error) {\n    console.error(error);\n    throw error;\n  }\n};\n</code></pre> <p>2.6 Styling</p> <p>There are several approaches to styling React apps:</p> <ul> <li>CSS-in-JS: Use libraries like styled-components or emotion for scoped, dynamic styling.</li> <li>CSS Modules: Localized CSS scoped to a component, which avoids global CSS conflicts.</li> <li>Tailwind CSS: A utility-first CSS framework that speeds up UI development with pre-defined classes.</li> <li>Traditional CSS: If you prefer, you can still stick to regular CSS files (but using scoped styles with CSS Modules is recommended).</li> </ul> <p>Example of a styled-component:</p> <pre><code>import styled from \"styled-components\";\n\nconst Button = styled.button`\n  background-color: ${(props) =&gt; (props.primary ? \"blue\" : \"gray\")};\n  color: white;\n  padding: 10px 20px;\n  border-radius: 5px;\n`;\n\nexport default Button;\n</code></pre> <p>2.7 Testing</p> <p>Testing your React app is essential. There are several tools available for this:</p> <ul> <li>Jest: A test runner that works well with React applications.</li> <li>React Testing Library: Focuses on testing components in a way that mimics user interaction.</li> <li>Cypress: For end-to-end testing.</li> </ul> <p>Write unit tests for components, integration tests for API services, and end-to-end tests for user workflows.</p>"},{"location":"frontend/react/folder-structure/react-architecture/#3-folder-breakdown-example","title":"3. Folder Breakdown Example","text":"<p>Let\u2019s look at an example of the folder structure with files inside it:</p> <pre><code>/src\n  /assets\n    /images           # Image assets used throughout the app\n    /icons            # Icons for different UI elements\n  /components\n    Button.js         # Atomic component for button UI\n    Modal.js          # Reusable modal component\n    Navbar.js         # Navigation bar component\n  /hooks\n    useAuth.js        # Custom hook for authentication logic\n    useFetch.js       # Custom hook for fetching data\n  /pages\n    HomePage.js       # Page component for the homepage\n    Dashboard.js      # Page component for the user dashboard\n  /services\n    api.js            # API service for managing HTTP requests\n  /store\n    authSlice.js      # Redux slice for auth state\n    userSlice.js      # Redux slice for user data\n  /styles\n    global.css        # Global CSS file or base styles\n  /tests\n    Button.test.js    # Test for the Button component\n    HomePage.test.js  # Test for the HomePage component\n  App.js              # Main App component, contains routes\n  index.js            # App entry point\n</code></pre>"},{"location":"frontend/react/folder-structure/react-architecture/#4-development-best-practices","title":"4. Development Best Practices","text":"<ul> <li>Separation of Concerns: Keep business logic separate from UI. For example, use container components for stateful logic and pass props down to presentational components.</li> <li>Component Reusability: Break down your UI into reusable, atomic components.</li> <li>Error Boundaries: Use error boundaries to catch JavaScript errors in components and display fallback UI.</li> <li>Code Splitting: Use React's built-in support for lazy loading and code-splitting (e.g., <code>React.lazy</code> and <code>Suspense</code>) to load only the necessary parts of your app.</li> <li>Environment Variables: Use <code>.env</code> files to manage environment-specific configurations, such as API keys.</li> </ul>"},{"location":"frontend/react/folder-structure/react-architecture/#5-example-code-snippet-appjs","title":"5. Example Code Snippet (App.js)","text":"<p>Here\u2019s how your <code>App.js</code> might look with routing and basic state management:</p> <pre><code>import React, { useState, useEffect } from \"react\";\nimport { BrowserRouter as Router, Route, Switch } from \"react-router-dom\";\nimport { fetchData } from \"./services/api\";\nimport HomePage from \"./pages/HomePage\";\nimport Dashboard from \"./pages/Dashboard\";\nimport Navbar from \"./components/Navbar\";\nimport Loading from \"./components/Loading\";\n\nfunction App() {\n  const [data, setData] = useState(null);\n\n  useEffect(() =&gt; {\n    async function loadData() {\n      try {\n        const response = await fetchData();\n        setData(response);\n      } catch (error) {\n        console.error(\"Error loading data:\", error);\n      }\n    }\n    loadData();\n  }, []);\n\n  if (!data) {\n    return &lt;Loading /&gt;;\n  }\n\n  return (\n    &lt;Router&gt;\n      &lt;Navbar /&gt;\n      &lt;Switch&gt;\n        &lt;Route path=\"/home\" component={HomePage} /&gt;\n        &lt;Route path=\"/dashboard\" component={Dashboard} /&gt;\n        &lt;Route path=\"/\" exact component={HomePage} /&gt;\n      &lt;/Switch&gt;\n    &lt;/Router&gt;\n  );\n}\n\nexport default App;\n</code></pre>"},{"location":"frontend/react/folder-structure/react-architecture/#conclusion","title":"Conclusion","text":"<p>The best architecture for your React web app should aim to be modular, maintainable, and scalable. By structuring your app with clear separation of concerns, reusable components, centralized state management, and a clean routing structure, you can ensure your app is easy to develop and scale in the future.</p>"},{"location":"frontend/react/folder-structure/react-architecture/#reference","title":"Reference","text":"<ul> <li>A Definitive Guide to React Architecture Patterns</li> <li>React JS Architecture: Implementation &amp; Best Practices in 2024</li> <li>React Architecture Patterns for Your Projects</li> <li>Reactjs Architecture</li> <li>A Comprehensive Guide to React Architecture: Building Scalable Web Applications with CronJ</li> </ul>"},{"location":"frontend/react/hooks/React.memo-syntax/","title":"React.memo Syntax","text":""},{"location":"frontend/react/hooks/React.memo-syntax/#syntax-of-reactmemo","title":"Syntax of <code>React.memo</code>","text":"<p>The basic syntax of <code>React.memo</code> is:</p> <pre><code>const MemoizedComponent = React.memo(Component, [arePropsEqual?]);\n</code></pre> <ul> <li><code>Component</code>: The functional component to memoize.</li> <li><code>arePropsEqual</code> (optional): A custom comparison function for props. If omitted, React performs a shallow comparison of props.</li> </ul> <pre><code>import { memo } from \"react\";\n\nconst Todos = ({ todos }) =&gt; {\n  console.log(\"child render\");\n  return (\n    &lt;&gt;\n      &lt;h2&gt;My Todos&lt;/h2&gt;\n      {todos.map((todo, index) =&gt; {\n        return &lt;p key={index}&gt;{todo}&lt;/p&gt;;\n      })}\n    &lt;/&gt;\n  );\n};\n\nexport default memo(Todos);\n</code></pre>"},{"location":"frontend/react/hooks/React.memo-syntax/#should-you-use-reactmemo","title":"Should You Use <code>React.memo</code>?","text":"When to Use:When Not to Use: <ol> <li> <p>Avoid Unnecessary Re-renders: If your component:</p> <ul> <li>Receives props that rarely change.</li> <li>Is part of a parent component that re-renders frequently.</li> </ul> <pre><code>const ExpensiveChild = React.memo(({ data }) =&gt; {\n    console.log(\"Rendering ExpensiveChild\");\n    return &lt;div&gt;{data}&lt;/div&gt;;\n});\n</code></pre> </li> <li> <p>Performance Optimization: For components that are expensive to render, like components with:</p> <ul> <li>Complex logic.</li> <li>Heavy computations or rendering.</li> </ul> </li> </ol> <ol> <li>Small Components: If the component is lightweight, like a simple button or label, the overhead of <code>React.memo</code> might not bring noticeable benefits.</li> <li>Frequent Prop Changes: If the component receives props that change frequently, the re-computation of memoization (comparison) can add unnecessary overhead.</li> <li>Premature Optimization: If performance is not an issue, introducing <code>React.memo</code> can make your code more complex without much gain.</li> </ol>"},{"location":"frontend/react/hooks/React.memo-syntax/#decision-making-checklist","title":"Decision-Making Checklist","text":"<p>Ask yourself these questions:</p> <ul> <li>Does the parent component re-render frequently? If yes, consider using <code>React.memo</code>.</li> <li>Are the props of this component stable? If they change rarely, <code>React.memo</code> can be beneficial.</li> <li>Is this component computationally expensive? Use <code>React.memo</code> to avoid redundant expensive operations.</li> </ul>"},{"location":"frontend/react/hooks/React.memo-syntax/#best-practices","title":"Best Practices","text":"<ul> <li> <p>Measure Before Optimization: Use React's <code>Profiler</code> or browser dev tools to identify performance bottlenecks before applying React.memo.</p> </li> <li> <p>Keep Code Readable: Don\u2019t overuse <code>React.memo</code>\u2014only apply it where it truly makes a difference.</p> </li> <li> <p>Combine with Other Optimizations: Pair <code>React.memo</code> with <code>useCallback</code> and <code>useMemo</code> to prevent re-creation of props or callback functions.</p> </li> </ul> <p>Conclusion</p> <p>You should use <code>React.memo</code> selectively. If your application doesn't face performance issues or the component is not part of a frequent rendering bottleneck, you can skip it. Focus on clean and maintainable code first, then optimize as needed.</p>"},{"location":"frontend/react/hooks/React.memo-vs-useMemo/","title":"React.memo vs useMemo","text":"<p><code>React.memo</code> and <code>useMemo</code> are different tools in React, designed for different use cases. Here's a detailed comparison:</p>"},{"location":"frontend/react/hooks/React.memo-vs-useMemo/#1-reactmemo","title":"1. <code>React.memo</code>","text":"<p>What it does:</p> <ul> <li>Optimizes functional components by preventing unnecessary re-renders.</li> <li>Memoizes the entire component and only re-renders it when its props change.</li> </ul> <p>How it works:</p> <ul> <li>Wraps a functional component to ensure it doesn\u2019t re-render if the incoming props are the same (shallow comparison by default).</li> </ul> <p>Usage:</p> <ul> <li> <p>To optimize component re-renders in cases where props don't change frequently.</p> Example<pre><code>const MyComponent = React.memo(({ count }) =&gt; {\n  console.log(\"Rendering MyComponent\");\n  return &lt;div&gt;Count: {count}&lt;/div&gt;;\n});\n</code></pre> </li> </ul> <p>Even if the parent component re-renders, <code>MyComponent</code> will not re-render unless the <code>count</code> prop changes.</p>"},{"location":"frontend/react/hooks/React.memo-vs-useMemo/#2-usememo","title":"2. useMemo","text":"<p>What it does:</p> <ul> <li>Optimizes expensive computations or derived values within a component by memoizing the result of a calculation.</li> <li>Returns a memoized value that is recalculated only when its dependencies change.</li> </ul> <p>How it works:</p> <ul> <li>Used inside a functional component to avoid re-computing values unnecessarily.</li> </ul> <p>Usage:</p> <ul> <li> <p>To optimize expensive calculations or prevent re-creation of objects or arrays.</p> Example<pre><code>import React, { useMemo } from \"react\";\n\nconst MyComponent = ({ items }) =&gt; {\n  const expensiveComputation = (items) =&gt; {\n    console.log(\"Computing...\");\n    return items.reduce((total, item) =&gt; total + item, 0);\n  };\n\n  const total = useMemo(() =&gt; expensiveComputation(items), [items]);\n\n  return &lt;div&gt;Total: {total}&lt;/div&gt;;\n};\n</code></pre> </li> </ul> <p>Here, the <code>expensiveComputation</code> function is only recalculated when the <code>items</code> array changes.</p>"},{"location":"frontend/react/hooks/React.memo-vs-useMemo/#key-differences","title":"Key Differences","text":"Aspect <code>React.memo</code> <code>useMemo</code> Purpose Prevents unnecessary component re-renders. Optimizes expensive calculations or derived values. What it Memoizes An entire functional component. A return value (calculated inside the component). Usage Context Wraps a functional component. Used inside a functional component. Dependencies Props of the memoized component. Explicit dependencies array (e.g., <code>[dep1, dep2]</code>). Trigger for Recalc Changes"},{"location":"frontend/react/hooks/React.memo-vs-useMemo/#when-to-use-each","title":"When to Use Each","text":"Note Use React.memo:Use useMemo: <p>When you want to optimize a functional component that:</p> <ul> <li>Re-renders frequently.</li> <li>Receives props that rarely change.</li> </ul> <p>Example: A component displaying static data passed as props.</p> <ul> <li>When you want to optimize a calculation or derived value inside a component.</li> <li>Example: Calculating filtered or aggregated data based on a dependency.</li> </ul>"},{"location":"frontend/react/hooks/React.memo-vs-useMemo/#combining-both","title":"Combining Both","text":"<p>You can use both together for maximum optimization:</p> <ul> <li>Use <code>React.memo</code> to optimize the component.</li> <li>Use <code>useMemo</code> to optimize expensive computations inside the component.</li> </ul> Example<pre><code>const MyComponent = React.memo(({ items }) =&gt; {\n  const total = useMemo(() =&gt; {\n    console.log(\"Calculating total...\");\n    return items.reduce((sum, item) =&gt; sum + item, 0);\n  }, [items]);\n\n  return &lt;div&gt;Total: {total}&lt;/div&gt;;\n});\n</code></pre> <p>Here:</p> <ul> <li><code>React.memo</code> ensures the component only re-renders if its props (<code>items</code>) change.</li> <li><code>useMemo</code> ensures the calculation only runs when <code>items</code> change.</li> </ul>"},{"location":"frontend/react/hooks/React.memo-vs-useMemo/#conclusion","title":"Conclusion","text":"<ul> <li>Use <code>React.memo</code> to optimize re-renders of entire components.</li> <li>Use <code>useMemo</code> to optimize calculations or derived values within a component.</li> <li>They complement each other but serve different purposes.</li> </ul>"},{"location":"frontend/react/hooks/React.memo/","title":"React.memo","text":""},{"location":"frontend/react/hooks/React.memo/#what-is-reactmemo","title":"What is React.memo?","text":"<p><code>React.memo</code> is a higher-order component (HOC) in React that optimizes functional components by preventing unnecessary re-renders. It works by memoizing the result of the component\u2019s render and re-rendering only when its props change.</p>"},{"location":"frontend/react/hooks/React.memo/#how-to-use-reactmemo","title":"How to Use React.memo?","text":"<p>Wrap your functional component with <code>React.memo</code>:</p> <pre><code>import React from \"react\";\n\nconst MyComponent = React.memo(({ value }) =&gt; {\n  console.log(\"Rendering MyComponent\");\n  return &lt;div&gt;{value}&lt;/div&gt;;\n});\n\nexport default MyComponent;\n</code></pre> <p>With Custom Comparison Logic</p> <p>By default, <code>React.memo</code> performs a shallow comparison of props. For custom comparison:</p> <pre><code>const MyComponent = React.memo(\n  ({ value }) =&gt; {\n    console.log(\"Rendering MyComponent\");\n    return &lt;div&gt;{value}&lt;/div&gt;;\n  },\n  (prevProps, nextProps) =&gt; {\n    // Return true if props are equal; false otherwise\n    return prevProps.value === nextProps.value;\n  }\n);\n</code></pre> When to, why, When not to <p>When to Use <code>React.memo</code>?</p> <ol> <li> <p>Pure Components:</p> <ul> <li>When your component renders the same output for the same props.</li> </ul> </li> <li> <p>Performance Optimization:</p> <ul> <li> <p>Use it for components that:</p> <pre><code>-   Receive props that rarely change.\n-   Are part of a large tree where unnecessary renders are costly.\n</code></pre> </li> </ul> </li> <li> <p>Avoid Frequent Re-renders:</p> <ul> <li>When parent components re-render often but the child component's props don't change.</li> </ul> </li> </ol> <p>Why Use <code>React.memo</code>?</p> <ol> <li> <p>Reduce Render Cycles:</p> <ul> <li>Prevents re-renders for unchanged props, saving computational resources.</li> </ul> </li> <li> <p>Performance Boost:</p> <ul> <li>Useful for performance-critical applications with deep component trees.</li> </ul> </li> <li> <p>Cleaner Logic:</p> <ul> <li>Encapsulates memoization, avoiding manual checks inside the component.</li> </ul> </li> </ol> <p>When Not to Use <code>React.memo</code>?</p> <ol> <li> <p>Small Components:</p> <ul> <li>If the component is lightweight, the overhead of <code>React.memo</code> might outweigh its benefits.</li> </ul> </li> <li> <p>Dynamic Content:</p> <ul> <li>When props or state change frequently, <code>React.memo</code> won't help much.</li> </ul> </li> <li> <p>Inefficient Comparisons:</p> <ul> <li>If the comparison logic is complex or expensive, it can negate the optimization.</li> </ul> </li> </ol>"},{"location":"frontend/react/hooks/React.memo/#example-scenario","title":"Example Scenario","text":"Without <code>React.memo</code>:With <code>React.memo</code>: <pre><code>const Parent = () =&gt; {\n    const [count, setCount] = React.useState(0);\n    const [value, setValue] = React.useState(\"Hello\");\n\n    return (\n        &lt;div&gt;\n            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;\n            &lt;Child value={value} /&gt;\n        &lt;/div&gt;\n    );\n};\n\nconst Child = ({ value }) =&gt; {\n    console.log(\"Rendering Child\");\n    return &lt;div&gt;{value}&lt;/div&gt;;\n};\n</code></pre> <p>The <code>Child</code> component will re-render every time <code>Parent</code> re-renders, even though <code>value</code> doesn\u2019t change.</p> <pre><code>const Child = React.memo(({ value }) =&gt; {\n    console.log(\"Rendering Child\");\n    return &lt;div&gt;{value}&lt;/div&gt;;\n});\n</code></pre> <p>Now, <code>Child</code> re-renders only when value changes.</p> <p>In summary:</p> <ul> <li>Use React.memo to optimize functional components when props rarely change.</li> <li>It\u2019s not a silver bullet\u2014profile your app to confirm it improves performance.</li> </ul>"},{"location":"frontend/react/hooks/guides/","title":"Guide","text":"<p>React Design Patterns and Best Practices page number: 82</p> <p>Props are the way a parent component can pass its data down the tree to every component that needs it (or part of it).</p> <p>When a component passes some props to another component, it is called the Owner, irrespective of the parent-child relation between them.</p>"},{"location":"frontend/react/hooks/guides/#children","title":"Children","text":"<p>There is a special prop that can be passed from the owners to the components defined inside their render method; it is called children.</p> <p>In the React documentation, it is described as <code>opaque</code> because it is a property that does not tell anything about the value it contains.</p>"},{"location":"frontend/react/hooks/guides/#react-hooks-reference","title":"React Hooks Reference","text":"<ul> <li>Learn core Redux \u2014 The easiest way you can imagine</li> <li> <p>Redux Toolkit \u2014 The cheat sheet for Redux development</p> </li> <li> <p>React Hooks cheat sheet: Best practices with examples</p> </li> <li> <p>React Hooks Cheat Sheet</p> </li> <li> <p>React Hooks Cheatsheet \u2014 Most commonly used hooks in ReactJS</p> </li> <li> <p>The React Cheatsheet for 2021 (+ Real-World Examples)</p> </li> </ul>"},{"location":"frontend/react/hooks/guides/#reference","title":"Reference","text":"<p>LinkedIn React Post</p>"},{"location":"frontend/react/hooks/migrating-cra-vite/","title":"Migrating Cra to vite","text":""},{"location":"frontend/react/hooks/migrating-cra-vite/#migrating-create-react-app-to-vite","title":"Migrating create-react-app to Vite","text":"<pre><code>for x in src/**/*.js; do mv \"$x\" \"${x%.js}.jsx\"; done\n</code></pre>"},{"location":"frontend/react/hooks/migrating-cra-vite/#heres-a-modified-version","title":"Here's a modified version","text":"<p>You can use the find command along with exec to achieve this more efficiently.</p> bash<pre><code>find src -type f -name '*.js' -exec sh -c 'mv \"$1\" \"${1%.js}.jsx\"' _ {} \\;\n</code></pre> <p>Explanation of the command:</p> <ul> <li> <p><code>find src -type f -name '*.js'</code>:</p> <p>This part finds all files (<code>-type f</code>) with a .js extension in the <code>src</code> directory.</p> </li> <li> <p><code>-exec sh -c 'mv \"$1\" \"${1%.js}.jsx\"' _ {} \\;</code>:</p> <p>For each file found, it executes the given shell command to rename the file. The <code>{}</code> is a placeholder for the file name, and the <code>_</code> is a placeholder for <code>$0</code> in the shell command.</p> <p>So, when you run this command, it will find all <code>.js</code> files in the src directory and rename them to <code>.jsx</code>. Make sure to run this command from the parent directory containing the src directory.</p> </li> </ul>"},{"location":"frontend/react/hooks/migrating-cra-vite/#editor-in-react","title":"Editor in React","text":"<ul> <li>TinyMCE React</li> <li>ckeditor5-react</li> </ul>"},{"location":"frontend/react/hooks/migrating-cra-vite/#outdated-library","title":"Outdated Library","text":"<ul> <li>react-kanban: archived</li> </ul>"},{"location":"frontend/react/hooks/migrating-cra-vite/#reference","title":"Reference","text":"<ul> <li>Upgrade React: w3schools</li> <li>create-react-app to vite: youtube</li> <li>Bash Scripting to changes all file name</li> </ul>"},{"location":"frontend/react/hooks/react-context-api/","title":"react context api","text":""},{"location":"frontend/react/hooks/react-context-api/#react-context-api","title":"React Context API","text":"<pre><code># Context API Folder Structure\n\nsrc/\n|-- components/\n|-- context/\n|   |-- MyContext.js\n|   |-- MyContextProvider.js\n|-- pages/\n|-- App.js\n|-- index.js\n</code></pre> <p>The React Context API allows you to share state or behavior across your React components without having to pass props manually through each level of the component tree. Here's a simple guide on how to use the React Context API:</p>"},{"location":"frontend/react/hooks/react-context-api/#step-1-create-a-context","title":"Step 1: Create a Context","text":"<p>You can create a new context using the <code>createContext</code> function from React.</p> MyContext.js<pre><code>import { createContext } from \"react\";\n\nconst MyContext = createContext();\n\nexport default MyContext;\n</code></pre>"},{"location":"frontend/react/hooks/react-context-api/#step-2-create-a-provider-component","title":"Step 2: Create a Provider Component","text":"<p>Create a provider component that will wrap the part of your component tree where you want to make the context available. This provider component will be responsible for managing the state that you want to share.</p> MyContextProvider.js<pre><code>import React, { useState } from \"react\";\nimport MyContext from \"./MyContext\";\n\nconst MyContextProvider = ({ children }) =&gt; {\n  const [myState, setMyState] = useState(\"Initial value\");\n\n  const updateState = (newValue) =&gt; {\n    setMyState(newValue);\n  };\n\n  return (\n    &lt;MyContext.Provider value={{ myState, updateState }}&gt;\n      {children}\n    &lt;/MyContext.Provider&gt;\n  );\n};\n\nexport default MyContextProvider;\n</code></pre>"},{"location":"frontend/react/hooks/react-context-api/#step-3-wrap-your-app-with-the-provider","title":"Step 3: Wrap Your App with the Provider","text":"<p>Wrap your main App component (or any parent component) with the provider component you created. This will make the context and its state available to all the components within that part of the component tree.</p> App.js<pre><code>import React from \"react\";\nimport MyContextProvider from \"./MyContextProvider\";\nimport MyComponent from \"./MyComponent\";\n\nconst App = () =&gt; {\n  return (\n    &lt;MyContextProvider&gt;\n      &lt;MyComponent /&gt;\n    &lt;/MyContextProvider&gt;\n  );\n};\n\nexport default App;\n</code></pre>"},{"location":"frontend/react/hooks/react-context-api/#step-4-consume-the-context-in-a-component","title":"Step 4: Consume the Context in a Component","text":"<p>Now, any component within the wrapped part of the tree can consume the context using the useContext hook.</p> MyComponent.js<pre><code>import React, { useContext } from \"react\";\nimport MyContext from \"./MyContext\";\n\nconst MyComponent = () =&gt; {\n  const { myState, updateState } = useContext(MyContext);\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Value from context: {myState}&lt;/p&gt;\n      &lt;button onClick={() =&gt; updateState(\"New value\")}&gt;Update Context&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default MyComponent;\n</code></pre> <p>Notes</p> <p>The key idea is that the state or functions you provide through the context provider become accessible to all the components that consume that context within the wrapped part of the component tree.</p>"},{"location":"frontend/react/hooks/react-context-api/#reference","title":"Reference","text":"<ul> <li>How to Use the React Context API in Your Projects: good</li> <li>React Context API: What is it and How it works?</li> </ul>"},{"location":"frontend/react/hooks/react-router/","title":"react router","text":""},{"location":"frontend/react/hooks/react-router/#router","title":"Router","text":"<pre><code>// Installation\n\n$ pnpm install react-router-dom\n</code></pre>"},{"location":"frontend/react/hooks/react-router/#how-to-install-react-router","title":"How to Install React Router?","text":"<p>React router contains 3 different packages for routing.</p> <ul> <li><code>react-router</code>: contains most of the core functionality of React Router including the route matching algorithm and most of the core components and react hooks</li> <li><code>react-router-native</code>: It is designed for mobile applications.</li> <li><code>react-router-dom</code>: It is designed for web applications.</li> </ul>"},{"location":"frontend/react/hooks/react-router/#components-in-react-router","title":"Components in React Router","text":"<p>React router components are divided into 3 main categories -</p> <ul> <li><code>Routers</code> - for instance, <code>&lt;BrowserRouter&gt;</code> and <code>&lt;HashRouter&gt;</code> components</li> <li><code>Route matchers</code> - for instance, <code>&lt;Routes&gt;</code> and <code>&lt;Route&gt;</code> components</li> <li><code>Navigation</code> \u2013 for instance, <code>&lt;Link&gt;</code> and <code>&lt;NavLink&gt;</code> components</li> </ul> <p></p>"},{"location":"frontend/react/hooks/react-router/#code","title":"Code","text":"<pre><code>import { BrowserRouter as Router, Switch, Route } from \"react-router-dom\";\n\nexport default function App() {\n  return (\n    &lt;Router&gt;\n      &lt;Navbar /&gt;\n      &lt;Switch&gt;\n        &lt;Route exact path=\"/\" component={Home} /&gt;\n        &lt;Route path=\"/about\" component={About} /&gt;\n      &lt;/Switch&gt;\n    &lt;/Router&gt;\n  );\n}\n</code></pre>"},{"location":"frontend/react/hooks/react-router/#redirect-component","title":"Redirect Component","text":"<pre><code>import {\n  BrowserRouter as Router,\n  Switch,\n  Route,\n  Redirect\n} from \"react-router-dom\";\n\nexport default function App() {\n  return (\n    &lt;Router&gt;\n      &lt;Switch&gt;\n        &lt;Route exact path=\"/\" component={Home} /&gt;\n        &lt;PrivateRoute path=\"/hidden\" component={Hidden} /&gt;\n      &lt;/Switch&gt;\n    &lt;/Router&gt;\n  );\n}\n\nfunction PrivateRoute({ component: Component, ...rest }) {\n  // useAuth is some custom hook to get the current user's auth state\n  const isAuth = useAuth();\n\n  return (\n    &lt;Route\n      {...rest}\n      render={(props) =&gt;\n        isAuth ? &lt;Component {...props} /&gt; : &lt;Redirect to=\"/\" /&gt;\n      }\n    /&gt;\n  );\n}\n\nfunction Home() {\n  return &lt;&gt;home&lt;/&gt;;\n}\n\nfunction Hidden() {\n  return &lt;&gt;hidden&lt;/&gt;;\n}\n</code></pre> <p>The redirect component is very simple to use, very declarative, and allows us to see the great benefit of React Router DOM being component-based, just like everything in React.</p>"},{"location":"frontend/react/hooks/react-router/#react-router-hooks","title":"React Router Hooks","text":"<ul> <li>useHistory Hook</li> <li>useLocation Hook</li> <li>useParams Hook + Dynamic Routes</li> <li>useRouteMatch Hook</li> </ul> <pre><code>import { useHistory } from \"react-router-dom\";\n\n\nfunction About() {\n  const history = useHistory();\n\n  console.log(history.location.pathname); // '/about'\n\n  return (\n    &lt;&gt;\n     &lt;h1&gt;The about page is on: {history.location.pathname}&lt;/h1&gt;\n     &lt;button onClick={() =&gt; history.push('/')}&gt;Go to home page&lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre>"},{"location":"frontend/react/hooks/react-router/#upgrading-fro-v5-to-v6","title":"Upgrading fro <code>v5</code> to <code>v6</code>","text":"<ul> <li>Upgrade all <code>&lt;Switch&gt;</code> elements to <code>&lt;Routes&gt;</code></li> <li>Use <code>useNavigate</code> instead of <code>useHistory</code></li> <li>Replace <code>useRouteMatch</code> with <code>useMatch</code></li> </ul> <p>Replacing Switch component with Routes</p> <pre><code>// old with Switch\n\nexport function App() {\n  return (\n    &lt;div&gt;\n      &lt;Switch&gt;\n        &lt;Route path=\"/about\"&gt;\n          &lt;AboutPage /&gt;\n        &lt;/Route&gt;\n        &lt;Route exact path=\"/profile\"&gt;\n          &lt;ProfilePage /&gt;\n        &lt;/Route&gt;\n        &lt;Route path=\"/profile/:id\"&gt;\n          &lt;ProfileUserPage /&gt;\n        &lt;/Route&gt;\n      &lt;/Switch&gt;\n    &lt;/div&gt;\n  )\n}\n\n// new with Routes\n\nexport function App() {\n  return (\n    &lt;div&gt;\n      &lt;Routes&gt;\n        &lt;Route path=\"/about\" element={&lt;AboutPage /&gt;} /&gt;\n        &lt;Route exact path=\"/profile\" element={&lt;ProfilePage /&gt;} /&gt;\n        &lt;Route path=\"/profile/:id\" element={&lt;ProfileUserPage /&gt;} /&gt;\n      &lt;/Routes&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre> <p>Internal changes &amp; path evaluation (no more needed exact prop) For V5 we needed to put the exact prop on the component to go for that specific route we want</p> <pre><code>// old\n\nexport function App() {\n  return (\n    &lt;div&gt;\n      &lt;Routes&gt;\n        &lt;Route path=\"/about\" element={&lt;AboutPage /&gt;} /&gt;\n        &lt;Route exact path=\"/profile\" element={&lt;ProfilePage /&gt;} /&gt;\n        &lt;Route path=\"/profile/:id\" element={&lt;ProfileUserPage /&gt;} /&gt;\n      &lt;/Routes&gt;\n    &lt;/div&gt;\n  )\n}\n\n// new\nexport function App() {\n  return (\n    &lt;div&gt;\n      &lt;Routes&gt;\n        &lt;Route path=\"/about\" element={&lt;AboutPage /&gt;} /&gt;\n        &lt;Route path=\"/profile\" element={&lt;ProfilePage /&gt;} /&gt;\n        &lt;Route path=\"/profile/:id\" element={&lt;ProfileUserPage /&gt;} /&gt;\n      &lt;/Routes&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre>"},{"location":"frontend/react/hooks/react-router/#history","title":"History","text":"<pre><code>$ npm i history\n</code></pre> <p>There are three types of history</p> <ul> <li>browser</li> <li>hash</li> <li>memory</li> </ul> <pre><code>import {\n  createBrowserHistory,\n  createHashHistory,\n  createMemoryHistory\n} from 'history'\n</code></pre> <p>If you are using React Router, it can automatically create history objects for you, so you may never have to actually interact with history directly. Still, it is important to understand the differences between each type of history so that you can determine which one is right for your project.</p>"},{"location":"frontend/react/hooks/react-router/#reference","title":"Reference","text":"<ul> <li>React router overview</li> <li>React Router - Types, Mechanism, Installation And Examples</li> <li>The React Router Cheatsheet \u2013 Everything You Need to Know - (BEST)</li> <li>Using Hashrouter With React - Definitive Guide</li> <li>What is Hash Routing?</li> <li>upgrading v5 - v6: oficial doc</li> <li>React router V6: Some of the new changes </li> <li>A little bit of history - npm</li> <li>history - npm</li> </ul>"},{"location":"frontend/react/hooks/useCallback/","title":"useCallback","text":""},{"location":"frontend/react/hooks/useCallback/#usecallback-hook","title":"useCallback Hook","text":"<p><code>useCallback</code> is a React hook that is used to memoize functions so that they do not get recreated on each render, which can be useful to optimize performance in certain scenarios. Here's a simple real example to illustrate the use of <code>useCallback</code>.</p> <p></p> <pre><code>import React, { useState, useCallback } from \"react\";\n\nconst ExampleComponent = () =&gt; {\n  const [count, setCount] = useState(0);\n\n  // Without useCallback\n  const handleClickWithoutCallback = () =&gt; {\n    console.log(\"Button clicked!\");\n    setCount(count + 1);\n  };\n\n  // With useCallback\n  const handleClickWithCallback = useCallback(() =&gt; {\n    console.log(\"Button clicked!\");\n    setCount(count + 1);\n  }, [count]);\n  // Dependency array: specify dependencies that should trigger function re-creation\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Count: {count}&lt;/p&gt;\n\n      &lt;button onClick={handleClickWithoutCallback}&gt;\n        Click Without useCallback\n      &lt;/button&gt;\n\n      &lt;button onClick={handleClickWithCallback}&gt;Click With useCallback&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default ExampleComponent;\n</code></pre> <p>In this example:</p> <ul> <li>The component renders a count state variable.</li> <li>There are two buttons: one <code>without useCallback</code> and one <code>with useCallback</code>.</li> <li>The <code>handleClickWithoutCallback</code> function is created inside the component body, so it is recreated on every render. This can lead to unnecessary re-renders of child components if passed down as props.</li> <li>The <code>handleClickWithCallback</code> function is memoized using useCallback, and the dependency array <code>[count]</code> specifies that the function should be recreated only when the <code>count</code> variable changes. This can be useful to prevent unnecessary function recreation and optimize performance.</li> </ul> <p>In this simple example, the difference might not be significant, but in larger applications, especially when passing functions down to child components, using <code>useCallback</code> can help optimize performance by avoiding unnecessary re-renders triggered by new function instances.</p> <p>Scenario: When to use useCallback &amp; when not to use</p> <p>Here are some scenarios where using useCallback in React can be beneficial, and situations where it may not be necessary:</p> <p>Use useCallback:</p> <ol> <li> <p>Optimizing Child Components:</p> <ul> <li>When passing callback functions as props to child components.</li> <li>It prevents unnecessary re-renders of child components if the callback function reference changes.</li> </ul> <pre><code>const ParentComponent = () =&gt; {\n  const handleClick = useCallback(() =&gt; {\n    console.log(\"Button clicked!\");\n  }, []);\n\n  return &lt;ChildComponent onClick={handleClick} /&gt;;\n};\n</code></pre> </li> <li> <p>Event Handlers in Dependencies:</p> <ul> <li>When using callback functions in the dependency array of <code>useEffect</code> to avoid unnecessary re-execution of the effect.   <pre><code>useEffect(() =&gt; {\n  // Effect logic\n}, [callbackFunction]);\n</code></pre></li> </ul> </li> <li> <p>Preventing Unnecessary Function Recreation:</p> <ul> <li>When you want to avoid recreating functions on each render, especially if those functions are passed as dependencies to other hooks or functions.   <pre><code>const memoizedFunction = useCallback(() =&gt; {\n  // Function logic\n}, [dependency1, dependency2]);\n</code></pre></li> </ul> </li> </ol> <p>Might Not Need useCallback:</p> <ol> <li> <p>Local Functions:</p> <ul> <li>If a function is defined inside a component and doesn't need to be referenced outside that component or passed down to child components, it may not need <code>useCallback</code></li> </ul> <pre><code>const MyComponent = () =&gt; {\n  const localFunction = () =&gt; {\n    // Local function logic\n  };\n\n  // No need for useCallback if localFunction is not passed as a prop or used in dependencies.\n  // ...\n};\n</code></pre> </li> <li> <p>Static Dependencies:</p> <ul> <li>If the function doesn't depend on any external variables or props, and its behavior is consistent across renders, <code>useCallback</code> might not be necessary.</li> </ul> <pre><code>const simpleFunction = () =&gt; {\n  // Function logic without dependencies\n};\n\n// No need for useCallback if simpleFunction doesn't depend on external variables.\n</code></pre> </li> <li> <p>Performance Impact is Negligible:</p> <ul> <li>In some cases, the performance impact of not using useCallback might be negligible, especially for smaller components or when function recreation does not affect the overall performance.</li> </ul> </li> </ol> <p>It's important to use <code>useCallback</code> judiciously and consider the specific use case and performance requirements of your application. If in doubt, you can start without <code>useCallback</code> and optimize later if performance becomes an issue.</p>"},{"location":"frontend/react/hooks/useCallback/#reference","title":"Reference","text":"<ul> <li>Your Guide to React.useCallback()</li> <li>Demystifying React Hooks: useCallback and useMemo </li> </ul>"},{"location":"frontend/react/hooks/useEffect-cleanup/","title":"useEffect cleanup","text":"<p>A cleanup function in React is typically used to perform necessary cleanup or resource disposal when a component unmounts. Here are some scenarios in which you should consider writing a cleanup function using the <code>useEffect</code> hook:</p>"},{"location":"frontend/react/hooks/useEffect-cleanup/#1-clearing-subscriptions-or-timers","title":"1. Clearing Subscriptions or Timers:","text":"<p>If your component sets up subscriptions (e.g., using <code>addEventListener</code>) or timers (e.g., using <code>setTimeout</code> or <code>setInterval</code>), it's crucial to clean them up when the component is unmounted to avoid memory leaks and unexpected behavior.</p> jsx<pre><code>useEffect(() =&gt; {\n  const timerId = setInterval(() =&gt; {\n    // Your logic here\n  }, 1000);\n\n  return () =&gt; {\n    // Cleanup: Clear the timer when the component unmounts\n    clearInterval(timerId);\n  };\n}, []);\n</code></pre>"},{"location":"frontend/react/hooks/useEffect-cleanup/#2-canceling-network-requests","title":"2. Canceling Network Requests:","text":"<p>If your component makes asynchronous requests (e.g., using <code>fetch</code>), you might want to cancel or abort the request if the component is unmounted to prevent setting state on an unmounted component.</p> jsx<pre><code>useEffect(() =&gt; {\n  const abortController = new AbortController();\n\n  const fetchData = async () =&gt; {\n    try {\n      const response = await fetch(\"https://api.example.com/data\", {\n        signal: abortController.signal,\n      });\n      const data = await response.json();\n      setData(data);\n    } catch (error) {\n      if (error.name === \"AbortError\") {\n        // Request was canceled (component unmounted)\n      } else {\n        console.error(\"Error fetching data:\", error);\n      }\n    }\n  };\n\n  fetchData();\n\n  return () =&gt; {\n    // Cleanup: Cancel the request if the component unmounts\n    abortController.abort();\n  };\n}, []);\n</code></pre>"},{"location":"frontend/react/hooks/useEffect-cleanup/#3-cleaning-up-external-resources","title":"3. Cleaning Up External Resources:","text":"<p>If your component interacts with external resources or libraries (e.g., closing a WebSocket connection, cleaning up a third-party library instance), the cleanup function is the right place to perform these actions.</p> jsx<pre><code>useEffect(() =&gt; {\n  const socket = new WebSocket(\"wss://example.com\");\n\n  socket.addEventListener(\"open\", () =&gt; {\n    // Your logic here\n  });\n\n  return () =&gt; {\n    // Cleanup: Close the WebSocket connection when the component unmounts\n    socket.close();\n  };\n}, []);\n</code></pre>"},{"location":"frontend/react/hooks/useEffect-cleanup/#4-resetting-state-or-side-effects","title":"4. Resetting State or Side Effects:","text":"<p>If your component needs to reset certain state variables or undo side effects when it unmounts, the cleanup function can be used for such purposes.</p> jsx<pre><code>useEffect(() =&gt; {\n  // Your effect logic here\n\n  return () =&gt; {\n    // Cleanup: Reset state or undo side effects when the component unmounts\n    resetState();\n  };\n}, [dependency]);\n</code></pre> <p>Remember that the cleanup function is an essential part of the useEffect lifecycle. It ensures that resources are properly released, preventing potential memory leaks or unintended behavior when a component is no longer in use. Always use the cleanup function to perform any necessary cleanup actions specific to the effects you've set up in your component.</p>"},{"location":"frontend/react/hooks/useEffect-technique-used/","title":"useEffect mostly used","text":"<p>The choice of <code>useEffect</code> technique often depends on the specific requirements of your application. However, one commonly used and versatile pattern is using <code>useEffect</code> for data fetching. This is especially relevant in applications that interact with APIs or external data sources. The pattern typically involves:</p> <ol> <li>Fetching data when the component mounts.</li> <li>Optionally fetching data based on changes in certain dependencies.</li> </ol> <p>Here's a breakdown of this pattern:</p>"},{"location":"frontend/react/hooks/useEffect-technique-used/#1-fetching-data-on-mount","title":"1. Fetching Data on Mount:","text":"<p>Use <code>useEffect</code> with an empty dependency array to fetch data when the component mounts. This ensures that the effect runs only once after the initial render.</p> jsx<pre><code>useEffect(() =&gt; {\n  const fetchData = async () =&gt; {\n    try {\n      const response = await fetch(\"https://api.example.com/data\");\n      const data = await response.json();\n      setData(data);\n    } catch (error) {\n      console.error(\"Error fetching data:\", error);\n    }\n  };\n\n  fetchData();\n}, []); // Empty dependency array means this effect runs once on mount\n</code></pre>"},{"location":"frontend/react/hooks/useEffect-technique-used/#2-fetching-data-based-on-dependencies","title":"2. Fetching Data Based on Dependencies:","text":"<p>Use <code>useEffect</code> with specific dependencies to refetch data when those dependencies change. This is useful for scenarios where you need to update data in response to user interactions or changes in the application state.</p> jsx<pre><code>useEffect(() =&gt; {\n  const fetchData = async () =&gt; {\n    try {\n      const response = await fetch(`https://api.example.com/data/${userId}`);\n      const data = await response.json();\n      setData(data);\n    } catch (error) {\n      console.error(\"Error fetching data:\", error);\n    }\n  };\n\n  fetchData();\n}, [userId]); // Refetch data when 'userId' changes\n</code></pre>"},{"location":"frontend/react/hooks/useEffect-technique-used/#3-cleanup-and-cancellation","title":"3. Cleanup and Cancellation:","text":"<p>Consider incorporating cleanup functions to handle scenarios like canceling pending requests or unsubscribing from external subscriptions when the component unmounts.</p> jsx<pre><code>useEffect(() =&gt; {\n  const abortController = new AbortController();\n\n  const fetchData = async () =&gt; {\n    try {\n      const response = await fetch(\"https://api.example.com/data\", {\n        signal: abortController.signal,\n      });\n      const data = await response.json();\n      setData(data);\n    } catch (error) {\n      if (error.name === \"AbortError\") {\n        // Request was canceled (component unmounted)\n      } else {\n        console.error(\"Error fetching data:\", error);\n      }\n    }\n  };\n\n  fetchData();\n\n  return () =&gt; {\n    // Cleanup: Cancel the request if the component unmounts\n    abortController.abort();\n  };\n}, []);\n</code></pre>"},{"location":"frontend/react/hooks/useEffect-technique-used/#4-combining-multiple-useeffect-hooks","title":"4. Combining Multiple useEffect Hooks:","text":"<p>Break down complex logic into multiple <code>useEffect</code> hooks for better readability and maintainability. For example, separate data fetching from UI-related side effects.</p> jsx<pre><code>useEffect(() =&gt; {\n  // Fetch initial data\n  const fetchData = async () =&gt; {\n    // ...\n  };\n  fetchData();\n}, []);\n\nuseEffect(() =&gt; {\n  // Handle UI-related side effects\n  // ...\n}, [data, userId]);\n</code></pre>"},{"location":"frontend/react/hooks/useEffect-technique-used/#5-asyncawait-pattern","title":"5. Async/Await Pattern:","text":"<p>Use the <code>async</code> keyword and <code>await</code> syntax for cleaner asynchronous code within the <code>useEffect</code>.</p> jsx<pre><code>useEffect(() =&gt; {\n  const fetchData = async () =&gt; {\n    try {\n      const response = await fetch(\"https://api.example.com/data\");\n      const data = await response.json();\n      setData(data);\n    } catch (error) {\n      console.error(\"Error fetching data:\", error);\n    }\n  };\n\n  fetchData();\n}, []);\n</code></pre> <p>This data-fetching pattern is commonly used because it covers a wide range of scenarios, from initial data loading to updating data based on changes in specific dependencies. It provides a clean and organized way to manage asynchronous operations in React components.</p>"},{"location":"frontend/react/hooks/useEffect-technique/","title":"useEffect Technique","text":""},{"location":"frontend/react/hooks/useEffect-technique/#_1","title":"useEffect Technique","text":"<p>The <code>useEffect</code> hook in React is used for handling side effects in functional components. It is a powerful tool that allows you to perform operations such as data fetching, subscriptions, or manually changing the DOM in response to component lifecycle events. Here are some advanced techniques and use cases for the <code>useEffect</code> hook:</p>"},{"location":"frontend/react/hooks/useEffect-technique/#1-conditional-execution","title":"1. Conditional Execution:","text":"<p>Use <code>useEffect</code> with dependencies to conditionally execute code when certain dependencies change. This is useful for optimizing performance and avoiding unnecessary computations.</p> jsx<pre><code>useEffect(() =&gt; {\n  // Effect will run when 'dependency' changes\n  fetchData(dependency);\n}, [dependency]);\n</code></pre>"},{"location":"frontend/react/hooks/useEffect-technique/#2-cleanup-function","title":"2. Cleanup Function:","text":"<p>Use the cleanup function returned by <code>useEffect</code> for cleanup operations, such as canceling subscriptions or clearing intervals.</p> jsx<pre><code>useEffect(() =&gt; {\n  const subscription = subscribe();\n  return () =&gt; {\n    // Cleanup function: unsubscribe when the component unmounts\n    subscription.unsubscribe();\n  };\n}, []); // Empty dependency array means this effect runs once on mount\n</code></pre>"},{"location":"frontend/react/hooks/useEffect-technique/#3-debouncing-and-throttling","title":"3. Debouncing and Throttling:","text":"<p>Use <code>useEffect</code> in combination with debouncing or throttling techniques to limit the rate at which a function is called.</p> jsx<pre><code>useEffect(() =&gt; {\n  const debouncedFunction = debounce(() =&gt; {\n    // Code to run after debounce\n  }, 300);\n\n  // Attach the debounced function to an event listener, for example\n  window.addEventListener(\"scroll\", debouncedFunction);\n\n  return () =&gt; {\n    // Cleanup: remove the event listener when the component unmounts\n    window.removeEventListener(\"scroll\", debouncedFunction);\n  };\n}, []);\n</code></pre>"},{"location":"frontend/react/hooks/useEffect-technique/#4-global-state-synchronization","title":"4. Global State Synchronization:","text":"<p>Use <code>useEffect</code> to synchronize the component's state with a global state management solution, like Redux.</p> jsx<pre><code>useEffect(() =&gt; {\n  // Update local state when global state changes\n  setLocalState(globalState);\n}, [globalState]);\n</code></pre>"},{"location":"frontend/react/hooks/useEffect-technique/#5-dependency-arrays-and-stale-closures","title":"5. Dependency Arrays and Stale Closures:","text":"<p>Be careful with dependencies and closures to avoid stale values. Use the functional form of <code>setState</code> to capture the latest state or props.</p> jsx<pre><code>useEffect(() =&gt; {\n  // Avoid stale closures\n  const fetchData = async () =&gt; {\n    const result = await fetch(url);\n    // Use result and capture the latest 'mounted' value\n    if (mounted.current) {\n      setData(result);\n    }\n  };\n\n  fetchData();\n\n  return () =&gt; {\n    // Cleanup: Set 'mounted' to false when the component unmounts\n    mounted.current = false;\n  };\n}, [url]);\n</code></pre>"},{"location":"frontend/react/hooks/useEffect-technique/#6-multiple-useeffect-for-separation-of-concerns","title":"6. Multiple useEffect for Separation of Concerns:","text":"<p>Use multiple <code>useEffect</code> blocks to separate different concerns, making your code more readable and maintainable.</p> jsx<pre><code>useEffect(() =&gt; {\n  // Code for fetching data\n  fetchData();\n}, [dependencyForDataFetching]);\n\nuseEffect(() =&gt; {\n  // Code for handling UI updates\n  updateUI();\n}, [dependencyForUIUpdate]);\n</code></pre>"},{"location":"frontend/react/hooks/useEffect-technique/#7-promise-in-useeffect","title":"7. Promise in useEffect:","text":"<p>If you want to work with asynchronous code in <code>useEffect</code>, you can use the async keyword and await syntax.</p> jsx<pre><code>useEffect(() =&gt; {\n  const fetchData = async () =&gt; {\n    try {\n      const result = await fetchDataFromAPI();\n      setData(result);\n    } catch (error) {\n      console.error(\"Error fetching data:\", error);\n    }\n  };\n\n  fetchData();\n}, [dependency]);\n</code></pre>"},{"location":"frontend/react/hooks/useEffect-technique/#8-combining-useeffect-with-other-hooks","title":"8. Combining useEffect with Other Hooks:","text":"<p>Combine useEffect with other hooks like useMemo or useCallback for more fine-grained control over the memoization of values and functions.</p> jsx<pre><code>const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);\n\nuseEffect(() =&gt; {\n  // Effect using memoizedValue\n  performEffectWithMemoizedValue(memoizedValue);\n}, [memoizedValue]);\n</code></pre> <p>Notes</p> <p>By mastering these advanced techniques, you can make the most of the useEffect hook in your React applications and handle complex scenarios with ease. Always consider the specific requirements of your application and choose the approach that best fits your use case.</p>"},{"location":"frontend/react/hooks/useReducer-and-reducer/","title":"useReducer & Reducer","text":"<p>what is difference between useReudcer and redux reducer</p>"},{"location":"frontend/react/hooks/useReducer-and-reducer/#overview","title":"Overview","text":"<p><code>useReducer</code> and <code>Redux reducers</code> both handle state management, but they are used in different contexts and have different scopes.</p> <p>Here\u2019s a detailed comparison between useReducer and Redux reducers:</p>"},{"location":"frontend/react/hooks/useReducer-and-reducer/#1-scope-and-usage","title":"1. Scope and Usage","text":"useReducerRedux Reducers <ul> <li>Scope: Local to a single component or a small part of your application.</li> <li>Usage: Typically used for managing complex state logic within a single React component or within a small component tree.</li> </ul> <ul> <li>Scope: Global state management across an entire application.</li> <li>Usage: Used to manage application-wide state that can be shared across multiple components and accessed from different parts of the app.</li> </ul>"},{"location":"frontend/react/hooks/useReducer-and-reducer/#2-state-management","title":"2. State Management","text":"useReducerRedux Reducers <ul> <li>State: Manages state within a React component.</li> <li>Setup: Defined and used directly in a component. The state is local to that component and its children (if context is used). Integration: No need for additional libraries or setup beyond React itself.</li> </ul> <ul> <li>State: Manages global state that can be accessed by any component in the application.</li> <li>Setup: Requires setting up a Redux store, reducers, and possibly middleware (like <code>redux-thunk</code> or <code>redux-saga</code>) for handling side effects. Integration: Integrated with the Redux library, often using <code>react-redux</code> to connect components to the Redux store.</li> </ul>"},{"location":"frontend/react/hooks/useReducer-and-reducer/#3-side-effects-and-middleware","title":"3. Side Effects and Middleware","text":"useReducerRedux Reducers <ul> <li>Side Effects: Managed using <code>useEffect</code> within the component where <code>useReducer</code> is used.</li> <li>Middleware: Does not use middleware directly. Side effects are managed separately.</li> </ul> <ul> <li>Side Effects: Handled using middleware like <code>redux-thunk</code> or <code>redux-saga</code>, which allows asynchronous actions and complex side effects.</li> <li>Middleware: Redux has a robust middleware system that extends its capabilities for handling side effects, logging, and more.</li> </ul>"},{"location":"frontend/react/hooks/useReducer-and-reducer/#4-data-flow-and-architecture","title":"4. Data Flow and Architecture","text":"useReducerRedux Reducers <ul> <li>Data Flow: Local data flow within a component. Actions are dispatched to the reducer, which updates the component\u2019s local state.</li> <li>Architecture: Simplified, ideal for encapsulated state management within a component or small component tree.</li> </ul> <ul> <li>Data Flow: Centralized data flow. Actions are dispatched to the Redux store, and reducers update the global state. Components connect to the store to access or modify state.</li> <li>Architecture: More complex, designed for larger applications with centralized state management. Encourages a predictable state container pattern.</li> </ul>"},{"location":"frontend/react/hooks/useReducer-and-reducer/#5-example-comparisons","title":"5. Example Comparisons","text":"Example with <code>useReducer</code>Example with Redux <p>Here\u2019s a basic example of managing a counter with <code>useReducer</code>:</p> <pre><code>import React, { useReducer } from 'react';\n\n// Reducer function\nfunction counterReducer(state, action) {\n    switch (action.type) {\n        case 'INCREMENT':\n            return { count: state.count + 1 };\n        case 'DECREMENT':\n            return { count: state.count - 1 };\n        default:\n            throw new Error('Unknown action type');\n    }\n}\n\nfunction Counter() {\n    const [state, dispatch] = useReducer(counterReducer, { count: 0 });\n\n    return (\n        &lt;div&gt;\n            &lt;p&gt;Count: {state.count}&lt;/p&gt;\n            &lt;button onClick={() =&gt; dispatch({ type: 'INCREMENT' })}&gt;Increment&lt;/button&gt;\n            &lt;button onClick={() =&gt; dispatch({ type: 'DECREMENT' })}&gt;Decrement&lt;/button&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default Counter;\n</code></pre> <p>Here\u2019s a basic example of managing a counter with Redux:</p> ReducerStore SetupComponentProvider Setup <pre><code>// counterReducer.js\nconst initialState = { count: 0 };\n\nfunction counterReducer(state = initialState, action) {\n    switch (action.type) {\n        case 'INCREMENT':\n            return { count: state.count + 1 };\n        case 'DECREMENT':\n            return { count: state.count - 1 };\n        default:\n            return state;\n    }\n}\n\nexport default counterReducer;\n</code></pre> <pre><code>// store.js\nimport { createStore } from 'redux';\nimport counterReducer from './counterReducer';\n\nconst store = createStore(counterReducer);\n\nexport default store;\n</code></pre> <pre><code>import React from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\n\nfunction Counter() {\n    const count = useSelector(state =&gt; state.count);\n    const dispatch = useDispatch();\n\n    return (\n        &lt;div&gt;\n            &lt;p&gt;Count: {count}&lt;/p&gt;\n            &lt;button onClick={() =&gt; dispatch({ type: 'INCREMENT' })}&gt;Increment&lt;/button&gt;\n            &lt;button onClick={() =&gt; dispatch({ type: 'DECREMENT' })}&gt;Decrement&lt;/button&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default Counter;\n</code></pre> <pre><code>// index.js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport store from './store';\nimport Counter from './Counter';\n\nReactDOM.render(\n    &lt;Provider store={store}&gt;\n        &lt;Counter /&gt;\n    &lt;/Provider&gt;,\n    document.getElementById('root')\n);\n</code></pre>"},{"location":"frontend/react/hooks/useReducer-and-reducer/#summary","title":"Summary","text":"<ul> <li> <p><code>useReducer</code>: Ideal for managing local or component-specific state with complex logic in a React component. It is simple and integrates seamlessly with React's hooks.</p> </li> <li> <p>Redux Reducers: Best for managing global state in larger applications where state needs to be shared across multiple components. Redux provides a centralized state management solution with robust middleware support for side effects.</p> </li> </ul> <p>Choosing between <code>useReducer</code> and Redux often depends on the scale and complexity of your application's state management needs. For simpler or isolated state management, <code>useReducer</code> is a great choice. For more extensive and shared state management, Redux offers a more powerful and scalable solution.</p>"},{"location":"frontend/react/hooks/useReducer-example/","title":"useReducer Example","text":""},{"location":"frontend/react/hooks/useReducer-example/#overview","title":"Overview","text":"<p>Sure! Let\u2019s dive into a more advanced real-time example using both <code>useState</code> and <code>useReducer</code>. We\u2019ll create a more complex form for managing a list of items where you can add, edit, and delete items.</p>"},{"location":"frontend/react/hooks/useReducer-example/#scenario","title":"Scenario","text":"<p>We'll build a form to manage a list of tasks with the following features:</p> Tip <ul> <li>Add: Add a new task to the list.</li> <li>Edit: Edit an existing task.</li> <li>Delete: Remove a task from the list.</li> <li>Complete/Uncomplete: Mark a task as complete or incomplete.</li> </ul> <p>We'll start with a basic example using <code>useState</code> and then move to a more complex example using <code>useReducer</code>.</p>"},{"location":"frontend/react/hooks/useReducer-example/#example","title":"Example","text":"Using <code>useState</code>Using <code>useReducer</code> <p>Here\u2019s a simple example using <code>useState</code> for managing tasks:</p> CodeExplanation <pre><code>import React, { useState } from 'react';\n\nfunction TaskManagerWithState() {\n    const [tasks, setTasks] = useState([]);\n    const [newTask, setNewTask] = useState('');\n    const [editingTask, setEditingTask] = useState(null);\n    const [editedTaskText, setEditedTaskText] = useState('');\n\n    const handleAddTask = () =&gt; {\n        if (newTask.trim()) {\n            setTasks([...tasks, { id: Date.now(), text: newTask, completed: false }]);\n            setNewTask('');\n        }\n    };\n\n    const handleEditTask = (task) =&gt; {\n        setEditingTask(task);\n        setEditedTaskText(task.text);\n    };\n\n    const handleSaveTask = () =&gt; {\n        setTasks(tasks.map(task =&gt;\n            task.id === editingTask.id\n                ? { ...task, text: editedTaskText }\n                : task\n        ));\n        setEditingTask(null);\n        setEditedTaskText('');\n    };\n\n    const handleDeleteTask = (taskId) =&gt; {\n        setTasks(tasks.filter(task =&gt; task.id !== taskId));\n    };\n\n    const handleToggleComplete = (taskId) =&gt; {\n        setTasks(tasks.map(task =&gt;\n            task.id === taskId\n                ? { ...task, completed: !task.completed }\n                : task\n        ));\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Task Manager with useState&lt;/h1&gt;\n            &lt;input\n                type=\"text\"\n                value={newTask}\n                onChange={(e) =&gt; setNewTask(e.target.value)}\n                placeholder=\"Add new task\"\n            /&gt;\n            &lt;button onClick={handleAddTask}&gt;Add Task&lt;/button&gt;\n\n            {editingTask &amp;&amp; (\n                &lt;div&gt;\n                    &lt;input\n                        type=\"text\"\n                        value={editedTaskText}\n                        onChange={(e) =&gt; setEditedTaskText(e.target.value)}\n                    /&gt;\n                    &lt;button onClick={handleSaveTask}&gt;Save&lt;/button&gt;\n                &lt;/div&gt;\n            )}\n\n            &lt;ul&gt;\n                {tasks.map(task =&gt; (\n                    &lt;li key={task.id} style={{ textDecoration: task.completed ? 'line-through' : 'none' }}&gt;\n                        {task.text}\n                        &lt;button onClick={() =&gt; handleToggleComplete(task.id)}&gt;\n                        {task.completed ? 'Uncomplete' : 'Complete'}\n                        &lt;/button&gt;\n                        &lt;button onClick={() =&gt; handleEditTask(task)}&gt;Edit&lt;/button&gt;\n                        &lt;button onClick={() =&gt; handleDeleteTask(task.id)}&gt;Delete&lt;/button&gt;\n                    &lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default TaskManagerWithState;\n</code></pre> <ul> <li>State Management: Manages the list of tasks and their state using <code>useState</code>.</li> <li>Add, Edit, Delete: Functions to add, edit, and delete tasks are directly managing the state.</li> <li>Toggle Completion: Toggles the completion status of a task.</li> </ul> <p>Now let\u2019s use <code>useReducer</code> for a more structured approach:</p> CodeExplanation <pre><code>import React, { useReducer, useState } from 'react';\n\n// Define action types\nconst ADD_TASK = 'ADD_TASK';\nconst EDIT_TASK = 'EDIT_TASK';\nconst SAVE_TASK = 'SAVE_TASK';\nconst DELETE_TASK = 'DELETE_TASK';\nconst TOGGLE_COMPLETE = 'TOGGLE_COMPLETE';\n\n// Define initial state\nconst initialState = {\n    tasks: [],\n    editingTask: null,\n    editedTaskText: ''\n};\n\n// Define reducer function\nfunction taskReducer(state, action) {\n    switch (action.type) {\n        case ADD_TASK:\n            return {\n                ...state,\n                tasks: [...state.tasks, { id: Date.now(), text: action.payload, completed: false }],\n                editingTask: null,\n                editedTaskText: ''\n            };\n        case EDIT_TASK:\n            return {\n                ...state,\n                editingTask: action.payload,\n                editedTaskText: action.payload.text\n            };\n        case SAVE_TASK:\n            return {\n                ...state,\n                tasks: state.tasks.map(task =&gt;\n                    task.id === state.editingTask.id\n                        ? { ...task, text: state.editedTaskText }\n                        : task\n                ),\n                editingTask: null,\n                editedTaskText: ''\n            };\n        case DELETE_TASK:\n            return {\n                ...state,\n                tasks: state.tasks.filter(task =&gt; task.id !== action.payload)\n            };\n        case TOGGLE_COMPLETE:\n            return {\n                ...state,\n                tasks: state.tasks.map(task =&gt;\n                    task.id === action.payload\n                        ? { ...task, completed: !task.completed }\n                        : task\n                )\n            };\n        default:\n            throw new Error('Unknown action type');\n    }\n}\n\nfunction TaskManagerWithReducer() {\n    const [state, dispatch] = useReducer(taskReducer, initialState);\n    const [newTask, setNewTask] = useState('');\n\n    const handleAddTask = () =&gt; {\n        if (newTask.trim()) {\n            dispatch({ type: ADD_TASK, payload: newTask });\n            setNewTask('');\n        }\n    };\n\n    const handleSaveTask = () =&gt; {\n        dispatch({ type: SAVE_TASK });\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Task Manager with useReducer&lt;/h1&gt;\n            &lt;input\n                type=\"text\"\n                value={newTask}\n                onChange={(e) =&gt; setNewTask(e.target.value)}\n                placeholder=\"Add new task\"\n            /&gt;\n            &lt;button onClick={handleAddTask}&gt;Add Task&lt;/button&gt;\n\n            {state.editingTask &amp;&amp; (\n                &lt;div&gt;\n                    &lt;input\n                        type=\"text\"\n                        value={state.editedTaskText}\n                        onChange={(e) =&gt; dispatch({ type: 'EDIT_TASK_TEXT', payload: e.target.value })}\n                    /&gt;\n                    &lt;button onClick={handleSaveTask}&gt;Save&lt;/button&gt;\n                &lt;/div&gt;\n            )}\n\n            &lt;ul&gt;\n                {state.tasks.map(task =&gt; (\n                    &lt;li key={task.id} style={{ textDecoration: task.completed ? 'line-through' : 'none' }}&gt;\n                        {task.text}\n                        &lt;button onClick={() =&gt; dispatch({ type: TOGGLE_COMPLETE, payload: task.id })}&gt;\n                            {task.completed ? 'Uncomplete' : 'Complete'}\n                        &lt;/button&gt;\n                        &lt;button onClick={() =&gt; dispatch({ type: EDIT_TASK, payload: task })}&gt;Edit&lt;/button&gt;\n                        &lt;button onClick={() =&gt; dispatch({ type: DELETE_TASK, payload: task.id })}&gt;Delete&lt;/button&gt;\n                    &lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default TaskManagerWithReducer;\n</code></pre> <ul> <li>Reducer Function: Manages state changes in a structured way with different actions for adding, editing, saving, deleting, and toggling tasks.</li> <li>State Management: The state and actions are handled by <code>useReducer</code>, which makes managing multiple state updates more organized.</li> <li>Dispatching Actions: Uses <code>dispatch</code> to send actions to the reducer, which then updates the state based on the action type.</li> </ul>"},{"location":"frontend/react/hooks/useReducer-example/#summary","title":"Summary","text":"<ul> <li><code>useState</code>: Simple and suitable for cases where state management is straightforward.</li> <li><code>useReducer</code>: More structured and useful for complex state logic involving multiple actions and state updates.</li> </ul> <p>Both approaches are demonstrated here to show how they fit different scenarios in managing state in a React application.</p>"},{"location":"frontend/react/hooks/useReducer-example/#which-scenarior-to-usereducer","title":"Which Scenarior to <code>useReducer</code>","text":"<p>Certainly! There are specific scenarios where <code>useReducer</code> is a better fit than <code>useState</code> due to its structured approach to state management. Here are some topics and examples where <code>useReducer</code> shines:</p>"},{"location":"frontend/react/hooks/useReducer-example/#1-complex-state-logic","title":"1. Complex State Logic","text":"<ul> <li> <p>Scenario: When state updates involve complex logic or multiple conditions.</p> </li> <li> <p>Example: Managing the state of a form with multiple fields that have interdependent validations or dynamic field updates.</p> </li> <li> <p>Why <code>useReducer</code>: It allows you to manage complex state transitions in a more organized way by defining a reducer function that processes different action types and updates the state accordingly.</p> </li> </ul>"},{"location":"frontend/react/hooks/useReducer-example/#2-multiple-actions-affecting-state","title":"2. Multiple Actions Affecting State","text":"<ul> <li> <p>Scenario: When your component needs to handle various actions that modify the state in different ways.</p> </li> <li> <p>Example: A todo list application where tasks can be added, edited, deleted, and marked as completed. Each action requires a different update to the state.</p> </li> <li> <p>Why <code>useReducer</code>: It provides a clear structure for handling different types of actions (e.g., <code>ADD_TASK</code>, <code>DELETE_TASK</code>) through a single reducer function, making the state management more predictable.</p> </li> </ul>"},{"location":"frontend/react/hooks/useReducer-example/#3-state-dependencies","title":"3. State Dependencies","text":"<ul> <li> <p>Scenario: When state updates are dependent on the previous state or other parts of the state.</p> </li> <li> <p>Example: A multi-step form where the content of later steps depends on user inputs from earlier steps.</p> </li> <li> <p>Why <code>useReducer</code>: It can handle complex state transitions that depend on the current state by allowing you to use the reducer function to apply changes based on the current state.</p> </li> </ul>"},{"location":"frontend/react/hooks/useReducer-example/#4-large-and-scalable-state-management","title":"4. Large and Scalable State Management","text":"<ul> <li> <p>Scenario: When managing a large state object with many properties that need to be updated in different ways.</p> </li> <li> <p>Example: A complex user profile where you need to update user details, preferences, and settings in different ways based on user actions.</p> </li> <li> <p>Why <code>useReducer</code>: It helps in keeping the state management scalable and maintainable by encapsulating all state updates within a reducer function, especially when the state object is large and involves multiple fields.</p> </li> </ul>"},{"location":"frontend/react/hooks/useReducer-example/#5-debugging-and-testing","title":"5. Debugging and Testing","text":"<ul> <li> <p>Scenario: When you need a predictable way to test and debug state changes.</p> </li> <li> <p>Example: An application with multiple components that interact with shared state in complex ways, such as a shopping cart with various actions (add, remove, update quantities).</p> </li> <li> <p>Why <code>useReducer</code>: The reducer function provides a clear way to see how different actions affect the state, which makes it easier to test and debug state transitions.</p> </li> </ul>"},{"location":"frontend/react/hooks/useReducer-example/#real-life-example-managing-a-multi-step-form","title":"Real-Life Example: Managing a Multi-Step Form","text":"<p>Consider a multi-step form where the user inputs data across several steps, and the data from previous steps affects the options or visibility of fields in later steps.</p> Using <code>useState</code>Using <code>useReducer</code> <pre><code>import React, { useState } from 'react';\n\nfunction MultiStepFormWithState() {\n    const [step, setStep] = useState(1);\n    const [formData, setFormData] = useState({\n        name: '',\n        email: '',\n        address: '',\n        age: '',\n    });\n\n    const handleChange = (e) =&gt; {\n        setFormData({\n            ...formData,\n            [e.target.name]: e.target.value\n        });\n    };\n\n    const handleNextStep = () =&gt; setStep(step + 1);\n    const handlePreviousStep = () =&gt; setStep(step - 1);\n\n    return (\n        &lt;div&gt;\n            {step === 1 &amp;&amp; (\n                &lt;div&gt;\n                    &lt;h1&gt;Step 1: Personal Info&lt;/h1&gt;\n                    &lt;input name=\"name\" value={formData.name} onChange={handleChange} placeholder=\"Name\" /&gt;\n                    &lt;input name=\"email\" value={formData.email} onChange={handleChange} placeholder=\"Email\" /&gt;\n                    &lt;button onClick={handleNextStep}&gt;Next&lt;/button&gt;\n                &lt;/div&gt;\n            )}\n\n            {step === 2 &amp;&amp; (\n                &lt;div&gt;\n                    &lt;h1&gt;Step 2: Address&lt;/h1&gt;\n                    &lt;input name=\"address\" value={formData.address} onChange={handleChange} placeholder=\"Address\" /&gt;\n                    &lt;button onClick={handlePreviousStep}&gt;Previous&lt;/button&gt;\n                    &lt;button onClick={handleNextStep}&gt;Next&lt;/button&gt;\n                &lt;/div&gt;\n            )}\n\n            {step === 3 &amp;&amp; (\n                &lt;div&gt;\n                    &lt;h1&gt;Step 3: Age&lt;/h1&gt;\n                    &lt;input name=\"age\" value={formData.age} onChange={handleChange} placeholder=\"Age\" /&gt;\n                    &lt;button onClick={handlePreviousStep}&gt;Previous&lt;/button&gt;\n                    &lt;button onClick={() =&gt; alert('Form Submitted')}&gt;Submit&lt;/button&gt;\n                &lt;/div&gt;\n            )}\n        &lt;/div&gt;\n    );\n}\n\nexport default MultiStepFormWithState;\n</code></pre> <pre><code>import React, { useReducer } from 'react';\n\n// Define action types\nconst NEXT_STEP = 'NEXT_STEP';\nconst PREVIOUS_STEP = 'PREVIOUS_STEP';\nconst UPDATE_FIELD = 'UPDATE_FIELD';\n\n// Define initial state\nconst initialState = {\n    step: 1,\n    formData: {\n        name: '',\n        email: '',\n        address: '',\n        age: ''\n    }\n};\n\n// Define reducer function\nfunction formReducer(state, action) {\n    switch (action.type) {\n        case NEXT_STEP:\n            return { ...state, step: state.step + 1 };\n        case PREVIOUS_STEP:\n            return { ...state, step: state.step - 1 };\n        case UPDATE_FIELD:\n            return {\n                ...state,\n                formData: { ...state.formData, [action.payload.name]: action.payload.value }\n            };\n        default:\n            throw new Error('Unknown action type');\n    }\n}\n\nfunction MultiStepFormWithReducer() {\n    const [state, dispatch] = useReducer(formReducer, initialState);\n\n    const handleChange = (e) =&gt; {\n        dispatch({ type: UPDATE_FIELD, payload: { name: e.target.name, value: e.target.value } });\n    };\n\n    const handleNextStep = () =&gt; dispatch({ type: NEXT_STEP });\n    const handlePreviousStep = () =&gt; dispatch({ type: PREVIOUS_STEP });\n\n    return (\n        &lt;div&gt;\n            {state.step === 1 &amp;&amp; (\n                &lt;div&gt;\n                    &lt;h1&gt;Step 1: Personal Info&lt;/h1&gt;\n                    &lt;input name=\"name\" value={state.formData.name} onChange={handleChange} placeholder=\"Name\" /&gt;\n                    &lt;input name=\"email\" value={state.formData.email} onChange={handleChange} placeholder=\"Email\" /&gt;\n                    &lt;button onClick={handleNextStep}&gt;Next&lt;/button&gt;\n                &lt;/div&gt;\n            )}\n\n            {state.step === 2 &amp;&amp; (\n                &lt;div&gt;\n                    &lt;h1&gt;Step 2: Address&lt;/h1&gt;\n                    &lt;input name=\"address\" value={state.formData.address} onChange={handleChange} placeholder=\"Address\" /&gt;\n                    &lt;button onClick={handlePreviousStep}&gt;Previous&lt;/button&gt;\n                    &lt;button onClick={handleNextStep}&gt;Next&lt;/button&gt;\n                &lt;/div&gt;\n            )}\n\n            {state.step === 3 &amp;&amp; (\n                &lt;div&gt;\n                    &lt;h1&gt;Step 3: Age&lt;/h1&gt;\n                    &lt;input name=\"age\" value={state.formData.age} onChange={handleChange} placeholder=\"Age\" /&gt;\n                    &lt;button onClick={handlePreviousStep}&gt;Previous&lt;/button&gt;\n                    &lt;button onClick={() =&gt; alert('Form Submitted')}&gt;Submit&lt;/button&gt;\n                &lt;/div&gt;\n            )}\n        &lt;/div&gt;\n    );\n}\n\nexport default MultiStepFormWithReducer;\n</code></pre>"},{"location":"frontend/react/hooks/useReducer-example/#benefits-of-usereducer-in-this-scenario","title":"Benefits of useReducer in This Scenario","text":"<ul> <li>Structured State Management: All state transitions are handled in a single reducer function, making it easier to manage and understand the state logic.</li> <li>Clear Actions: Each action (<code>NEXT_STEP</code>, <code>PREVIOUS_STEP</code>, <code>UPDATE_FIELD</code>) is handled in a predictable way, simplifying debugging and maintenance.</li> <li>Scalability: Adding more steps or fields involves updating the reducer and actions, rather than adding more individual state updates.</li> </ul> <p>In summary, <code>useReducer</code> is best used when you have complex state logic, multiple actions, or need to manage large and interconnected pieces of state. It provides a more organized and scalable approach compared to <code>useState</code> in such scenarios.</p>"},{"location":"frontend/react/hooks/useReducer-with-api/","title":"useReducer with API","text":""},{"location":"frontend/react/hooks/useReducer-with-api/#overview","title":"Overview","text":"<p><code>useReducer</code> itself does not handle API calls or any side effects directly. It is solely focused on managing state changes within your component based on dispatched actions. However, you can use <code>useReducer</code> in combination with <code>useEffect</code> (or other side effect management techniques) to handle API calls or perform other side effects in your React components.</p>"},{"location":"frontend/react/hooks/useReducer-with-api/#combining-usereducer-with-useeffect","title":"Combining <code>useReducer</code> with <code>useEffect</code>","text":"<p>Here\u2019s how you can use <code>useReducer</code> to manage the state and <code>useEffect</code> to perform API calls:</p> <ol> <li>State Management with <code>useReducer</code>: Manage the local state transitions within your component.</li> <li>Fetching Data with <code>useEffect</code>: Perform API calls or other side effects based on the component's lifecycle or state changes.</li> </ol>"},{"location":"frontend/react/hooks/useReducer-with-api/#example-fetching-data-from-an-api","title":"Example: Fetching Data from an API","text":"<p>Let\u2019s say you have a component that fetches a list of users from an API. You want to handle loading, success, and error states using <code>useReducer</code>.</p> ExampleExplanationOther Considerations <pre><code>import React, { useReducer, useEffect } from 'react';\n\n// Define action types\nconst FETCH_REQUEST = 'FETCH_REQUEST';\nconst FETCH_SUCCESS = 'FETCH_SUCCESS';\nconst FETCH_FAILURE = 'FETCH_FAILURE';\n\n// Define initial state\nconst initialState = {\n    loading: false,\n    data: [],\n    error: null\n};\n\n// Define reducer function\nfunction reducer(state, action) {\n    switch (action.type) {\n        case FETCH_REQUEST:\n            return { ...state, loading: true, error: null };\n        case FETCH_SUCCESS:\n            return { ...state, loading: false, data: action.payload };\n        case FETCH_FAILURE:\n            return { ...state, loading: false, error: action.payload };\n        default:\n            throw new Error('Unknown action type');\n    }\n}\n\nfunction UserList() {\n    const [state, dispatch] = useReducer(reducer, initialState);\n\n    useEffect(() =&gt; {\n        const fetchData = async () =&gt; {\n            dispatch({ type: FETCH_REQUEST });\n\n            try {\n                const response = await fetch('https://jsonplaceholder.typicode.com/users');\n                const data = await response.json();\n                dispatch({ type: FETCH_SUCCESS, payload: data });\n            } catch (error) {\n                dispatch({ type: FETCH_FAILURE, payload: error.message });\n            }\n        };\n\n        fetchData();\n    }, []); // Empty dependency array means this runs once on component mount\n\n    const { loading, data, error } = state;\n\n    if (loading) return &lt;p&gt;Loading...&lt;/p&gt;;\n    if (error) return &lt;p&gt;Error: {error}&lt;/p&gt;;\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;User List&lt;/h1&gt;\n            &lt;ul&gt;\n                {data.map(user =&gt; (\n                    &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default UserList;\n</code></pre> <ol> <li> <p>Reducer: The reducer handles three action types:</p> <ul> <li><code>FETCH_REQUEST</code>: Sets the loading state to <code>true</code> and clears any previous errors.</li> <li><code>FETCH_SUCCESS</code>: Updates the state with the fetched data and sets loading to <code>false</code>.</li> <li><code>FETCH_FAILURE</code>: Sets the error state and stops loading.</li> </ul> </li> <li> <p>Effect Hook: <code>useEffect</code> is used to perform the API call when the component mounts (empty dependency array). It dispatches actions based on the success or failure of the API call.</p> </li> <li> <p>Component Logic: Displays loading, error, or data based on the current state managed by <code>useReducer</code>.</p> </li> </ol> <ul> <li> <p>Handling Side Effects: For more complex scenarios or if side effects need to be managed differently, you might consider using libraries like <code>react-query</code>, <code>redux-thunk</code>, or <code>redux-saga</code>, which offer advanced solutions for handling side effects in conjunction with state management.</p> </li> <li> <p>Separation of Concerns: Using <code>useReducer</code> to manage state and <code>useEffect</code> to handle side effects helps maintain a clear separation of concerns, making your code easier to understand and maintain.</p> </li> </ul> <p>In summary, while <code>useReducer</code> doesn't handle API calls directly, it can be effectively combined with <code>useEffect</code> to manage state transitions based on the results of API calls or other side effects.</p>"},{"location":"frontend/react/hooks/useReducer/","title":"useReducer","text":"<p><code>useReducer</code> is a React Hook that is used to manage complex state logic in functional components. It is an alternative to <code>useState</code>, providing more control over state updates and handling complex state transitions more cleanly.</p>"},{"location":"frontend/react/hooks/useReducer/#overview","title":"Overview","text":""},{"location":"frontend/react/hooks/useReducer/#what-is-usereducer","title":"What is <code>useReducer</code>?","text":"<p><code>useReducer</code> is a Hook that helps manage state in a React component by providing a way to handle complex state logic. It works similarly to a reducer function in Redux, where you define how your state updates in response to various actions.</p>"},{"location":"frontend/react/hooks/useReducer/#how-does-it-work","title":"How does it work?","text":"<p><code>useReducer</code> takes two arguments:</p> <ol> <li> <p>Reducer Function: A function that determines how the state changes based on the action dispatched. It takes the current state and an action object, then returns the new state.</p> <pre><code>function reducer(state, action) {\n    switch (action.type) {\n        case 'INCREMENT':\n            return { count: state.count + 1 };\n        case 'DECREMENT':\n            return { count: state.count - 1 };\n        default:\n            throw new Error();\n    }\n}\n</code></pre> </li> <li> <p>Initial State: The initial state of your component.</p> <pre><code>const initialState = { count: 0 };\n</code></pre> </li> </ol> <p>The <code>useReducer</code> hook returns an array with two elements:</p> <ol> <li>Current State: The current state of your component.</li> <li> <p>Dispatch Function: A function that you call with an action to trigger a state update.</p> <pre><code>const [state, dispatch] = useReducer(reducer, initialState);\n</code></pre> </li> </ol> Why do we need useReducer?When to use useReducer?What problem does it solve? <p><code>useReducer</code> is useful when:</p> <ol> <li> <p>Complex State Logic: If you have a component with complex state transitions, <code>useReducer</code> can make it easier to manage compared to multiple <code>useState</code> calls. It centralizes the state logic in one place.</p> </li> <li> <p>Multiple State Variables: When you have multiple related state variables that need to be updated together, <code>useReducer</code> helps manage them more coherently.</p> </li> <li> <p>Predictable State Updates: It enforces a clear pattern for how state updates occur, which can improve maintainability and debugability.</p> </li> <li> <p>State Transitions Based on Actions: If your state updates based on specific actions (like in a Redux-like setup), <code>useReducer</code> aligns well with this pattern.</p> </li> </ol> <ul> <li>When state updates are dependent on complex logic or multiple actions.</li> <li>When the state is an object and you need to update specific fields.</li> <li>When you want to centralize state management and make it easier to trace how state changes.</li> </ul> <ul> <li>Complex State Logic: Simplifies and organizes state transitions, making the component easier to understand and maintain.</li> <li>Centralized State Management: Provides a single location (the reducer function) for handling all state updates, which can be easier to manage than scattering state logic across multiple <code>useState</code> calls.</li> <li>Predictable Updates: Ensures that state updates are predictable and consistent, improving the reliability of the component.</li> </ul>"},{"location":"frontend/react/hooks/useReducer/#explain-to-5-years-old","title":"Explain to 5 years old","text":""},{"location":"frontend/react/hooks/useReducer/#question-1","title":"Question 1","text":"<p>explain useReducer to 5 years old</p> <p>Okay! Let's imagine you have a toy that needs to be fixed or changed in different ways. We\u2019ll use a simple story to explain useReducer.</p> <p>The Toy Box</p> <ol> <li> <p>Your Toy Box: Imagine you have a toy box where you keep your toys. This toy box can look different depending on how you play with it. Sometimes you want to put toys in, sometimes you want to take toys out, or maybe you want to tidy it up.</p> </li> <li> <p>Toy Fixer: You have a special toy fixer who knows exactly how to make changes to your toy box. This toy fixer listens to what you want and then decides how to change the toy box.</p> </li> </ol> <p>How It Works:</p> <ol> <li> <p>What You Want: When you tell the toy fixer what you want (like putting in a new toy or taking one out), you\u2019re giving it a \u201cmessage\u201d or \u201caction.\u201d For example, you might say, \u201cPut a teddy bear in the box\u201d or \u201cTake out the truck.\u201d</p> </li> <li> <p>Fixing the Toy Box: The toy fixer reads your message and knows exactly how to change the toy box. It uses a set of rules to make the changes, like if you say \u201cAdd a teddy bear,\u201d it puts the teddy bear in the box.</p> </li> <li> <p>New Look: After the toy fixer does its job, the toy box looks different, with the teddy bear now inside or the truck taken out.</p> </li> </ol> <p>In Simple Steps:</p> <ol> <li>Tell What You Want: You give a message to the toy fixer (like \u201cAdd a toy\u201d).</li> <li>Toy Fixer Makes Changes: The toy fixer reads the message and changes the toy box accordingly.</li> <li>New Toy Box: Now your toy box looks just the way you wanted it!</li> </ol> <p>In code, <code>useReducer</code> is like that toy fixer. It helps us manage changes to our \u201ctoy box\u201d (which is our state) by following rules and handling messages (actions) to update things correctly.</p>"},{"location":"frontend/react/hooks/useReducer/#question-2","title":"Question 2","text":"<p>now explain to 5 years old, when to use useState and useReducer.</p> <p>Sure! Let\u2019s think about <code>useState</code> and <code>useReducer</code> using simple toys and games.</p> useStateuseReducer <p>Imagine you have a box of crayons, and you only have a few crayons. You want to keep track of how many crayons you have, and it\u2019s pretty easy because you don\u2019t have too many.</p> <ol> <li>Counting Crayons: When you want to know how many crayons you have, you just look in the box.</li> <li>Adding Crayons: If you get a new crayon, you just add it to the box.</li> <li>Simple and Easy: It\u2019s easy to keep track because you only have a few crayons and it\u2019s not complicated.</li> </ol> <p>When to use <code>useState</code>: You use useState when you have something simple, like counting your crayons. It\u2019s easy and quick to manage because you don\u2019t have too many things to keep track of.</p> <p>Now, let\u2019s say you have a big toy box with lots of different toys. Some toys need to be fixed, some need to be put away, and some need to be cleaned. It\u2019s more complicated because you have different kinds of toys and many actions to handle.</p> <ol> <li>Different Actions: You might want to put toys away, fix broken ones, or organize them in different ways.</li> <li>Toy Fixer: You need a special toy fixer who knows all the rules for changing the toy box, like how to handle each type of toy and what to do with them.</li> <li>More Organized: The toy fixer follows a set of rules to make sure everything is handled correctly, and your toy box stays organized even though it\u2019s more complicated.</li> </ol> <p>When to use <code>useReducer</code>: You use <code>useReducer</code> when you have a big toy box with lots of different toys and many things to manage. It helps you keep everything organized by following rules and handling different actions in a structured way.</p> <p>Summary</p> <ul> <li><code>useState</code> is like counting crayons in a simple way. It\u2019s easy and works well when you don\u2019t have a lot to manage.</li> <li><code>useReducer</code> is like having a toy fixer for a big toy box with many different toys and actions. It helps manage everything in a more organized way when things get more complicated.</li> </ul> <p>So, if you\u2019re just keeping track of a few things, use <code>useState</code>. If you have a lot of things and need to handle them in different ways, use <code>useReducer</code>.</p>"},{"location":"frontend/react/hooks/useRef/","title":"useRef","text":""},{"location":"frontend/react/hooks/useRef/#useref-hooks","title":"useRef hooks","text":"<p><code>useRef</code> is a React hook that provides a way to create a mutable object that persists across renders. It's commonly used to access and interact with a DOM element or to persist values across renders without causing re-renders.</p> <p>Here's a beginner's guide on how to use useRef in React:</p>"},{"location":"frontend/react/hooks/useRef/#basic-usage","title":"Basic Usage:","text":"<ol> <li> <p>Import <code>useRef</code>:</p> <p>Import the useRef hook from React.</p> <pre><code>import React, { useRef } from \"react\";\n</code></pre> </li> <li> <p>Create a Ref:</p> <p>Use useRef() to create a ref object.</p> <pre><code>const myRef = useRef();\n</code></pre> </li> <li> <p>Attach Ref to a JSX Element:</p> <p>Attach the ref to a JSX element using the <code>ref</code> attribute.</p> <pre><code>return &lt;div ref={myRef}&gt;Hello, useRef!&lt;/div&gt;;\n</code></pre> </li> <li> <p>Accessing the DOM Element:</p> <p>Use the <code>.current</code> property of the ref object to access the DOM element.</p> <pre><code>console.log(myRef.current); // Outputs the DOM element\n</code></pre> </li> </ol>"},{"location":"frontend/react/hooks/useRef/#example-with-a-functional-component","title":"Example with a Functional Component:","text":"<pre><code>import React, { useRef, useEffect } from \"react\";\n\nconst MyComponent = () =&gt; {\n  const myRef = useRef();\n\n  useEffect(() =&gt; {\n    // Access the DOM element after the component is mounted\n    console.log(myRef.current);\n  }, []); // Empty dependency array ensures the effect runs only once after mount\n\n  return &lt;div ref={myRef}&gt;Hello, useRef!&lt;/div&gt;;\n};\n\nexport default MyComponent;\n</code></pre>"},{"location":"frontend/react/hooks/useRef/#use-cases-and-when-to-use-useref","title":"Use Cases and When to Use useRef:","text":"<ol> <li> <p>Accessing or Modifying DOM Elements:</p> <ul> <li>Use <code>useRef</code> when you need to access or modify a DOM element directly. For example, focusing an input field, measuring an element, or triggering imperative animations.</li> </ul> <pre><code>const inputRef = useRef();\n\nuseEffect(() =&gt; {\n  inputRef.current.focus();\n}, []);\n</code></pre> </li> <li> <p>Holding Mutable Values Without Causing Rerenders:</p> <ul> <li><code>useRef</code> can hold mutable values that persist across renders without causing re-renders. This is useful for storing values that shouldn't trigger component updates.</li> </ul> <pre><code>const countRef = useRef(0);\n\nuseEffect(() =&gt; {\n  countRef.current += 1;\n  console.log(\"Render count:\", countRef.current);\n});\n</code></pre> </li> <li> <p>Storing Previous Values:</p> <ul> <li>Use <code>useRef</code> to store and compare previous values, useful for certain scenarios like tracking changes in dependencies.</li> </ul> <pre><code>const prevValueRef = useRef();\nuseEffect(() =&gt; {\n  if (value !== prevValueRef.current) {\n    console.log(\"Value changed!\");\n  }\n  prevValueRef.current = value;\n}, [value]);\n</code></pre> <p>Remember that the ref value persists between renders, so changes to <code>.current</code> do not trigger a re-render. This makes <code>useRef</code> suitable for scenarios where you need to hold mutable values across renders without causing unnecessary updates.</p> </li> </ol>"},{"location":"frontend/react/miscellaneous/books/","title":"Books","text":""},{"location":"frontend/react/miscellaneous/books/#api-refresh-logic","title":"API Refresh Logic","text":"store.jsapiMiddleware.js <pre><code>import { configureStore } from \"@reduxjs/toolkit\";\nimport {\n    persistStore,\n    persistReducer,\n    FLUSH,\n    REHYDRATE,\n    PAUSE,\n    PERSIST,\n    PURGE,\n    REGISTER,\n} from \"redux-persist\";\nimport storage from \"redux-persist/lib/storage\";\nimport { authApi } from \"@features/auth/services/authApi\";\nimport { postsApi } from \"@features/dashboard/services/dashboardApi\";\nimport authReducer from \"@features/auth/services/authSlice\";\nimport { combineReducers } from \"@reduxjs/toolkit\";\nimport apiRefreshMiddleware from \"./apiMiddleware\"; // Import the custom API middleware\n\n// Persist config for redux-persist\nconst persistConfig = {\n    key: \"root\",\n    storage,\n    whitelist: [\"auth\"], // Only persist the auth state\n};\n\n// Combine your reducers (if using multiple slices)\nconst rootReducer = combineReducers({\n    auth: authReducer,\n    [authApi.reducerPath]: authApi.reducer,\n    [postsApi.reducerPath]: postsApi.reducer,\n});\n\n// Persisted reducer configuration\nconst persistedAuthReducer = persistReducer(persistConfig, rootReducer);\n\n// Configure the Redux store\nexport const store = configureStore({\n    reducer: persistedAuthReducer,\n    middleware: (getDefaultMiddleware) =&gt;\n        getDefaultMiddleware({\n            serializableCheck: {\n                ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER],\n            },\n        }).concat(\n        // Add the custom apiRefreshMiddleware along with RTK Query middlewares\n            apiRefreshMiddleware,\n            authApi.middleware,\n            postsApi.middleware\n        ),\n});\n\n// Create the persistor for redux-persist\nexport const persistor = persistStore(store);\n</code></pre> <pre><code>const apiRefreshMiddleware = (store) =&gt; (next) =&gt; async (action) =&gt; {\n    if (action.type === 'API_CALL') {\n        const state = store.getState();\n        const token = state.auth.token;\n        const refreshToken = state.auth.refreshToken;\n\n        try {\n            const response = await fetch(action.payload.url, {\n                method: action.payload.method || 'GET',\n                headers: {\n                'Content-Type': 'application/json',\n                Authorization: `Bearer ${token}`,\n                },\n                body: JSON.stringify(action.payload.body),\n            });\n\n            if (response.status === 401) {\n                // Handle token refresh\n                const refreshResponse = await fetch('/refresh', {\n                    method: 'POST',\n                    headers: { 'Content-Type': 'application/json' },\n                    body: JSON.stringify({ refreshToken }),\n                });\n\n                if (refreshResponse.ok) {\n                    const { token: newToken } = await refreshResponse.json();\n                    store.dispatch({ type: 'SET_TOKEN', payload: newToken });\n\n                    // Retry the original request with the new token\n                    return next({\n                        ...action,\n                        payload: { ...action.payload, headers: { Authorization: `Bearer ${newToken}` } },\n                    });\n                } else {\n                    store.dispatch({ type: 'CLEAR_TOKEN' });\n                }\n            }\n\n            return response;\n        } catch (error) {\n            console.error('API Error:', error);\n        }\n    }\n\n    return next(action);\n};\n\nexport default apiRefreshMiddleware;\n</code></pre> <pre><code>const customMiddlewares = [\n  apiMiddleware,\n  authApi.middleware,\n  postsApi.middleware,\n  // Add more middlewares here as needed\n];\n\nexport const store = configureStore({\n  reducer: persistedAuthReducer,\n  middleware: (getDefaultMiddleware) =&gt;\n    getDefaultMiddleware({\n      serializableCheck: {\n        ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER],\n      },\n    }).concat(...customMiddlewares), // Spread the array of middlewares\n});\n</code></pre>"},{"location":"frontend/react/miscellaneous/books/#overview","title":"Overview","text":"<p>The best option to inject a JWT token into headers and handle token refresh depends on your project's requirements. Here's a comparison of the options and recommendations for handling token expiration with Axios, fetchBaseQuery, and Redux Toolkit Middleware.</p>"},{"location":"frontend/react/miscellaneous/books/#use-environment-variables-for-different-environments","title":"Use Environment Variables for Different Environments","text":"<p>You can also set different base URLs for different environments (e.g., development, staging, production) by using environment variables.</p> <p>In your .env files (e.g., <code>.env</code>, <code>.env.development</code>, <code>.env.production</code>), set the <code>REACT_APP_API_BASE_URL</code> like so:</p> <pre><code>// .env\nVITE_API_BASE_URLL=https://cqnovalid.info.com.np/connect/token\n</code></pre> <p>For different environments, you can have different <code>.env</code> files:</p> <pre><code>// .env.production\nVITE_API_BASE_URL=https://prod-api.example.com/connect/token\n\n// .env.development\nVITE_API_BASE_URL=https://dev-api.example.com/connect/token\n</code></pre> <p>Make sure you restart your development server after changing <code>.env</code> files so that the environment variables are properly loaded.</p>"},{"location":"frontend/react/miscellaneous/books/#centralized-config-file","title":"Centralized Config File","text":"<p>Create a separate <code>config.js</code> file to handle different environment URLs and any other configuration, and export them as needed.</p> <pre><code>// config.js\nexport const CONFIG = {\n  BASE_URL: import.meta.env.VITE_API_BASE_URL,\n  LOGIN_URL: import.meta.env.VITE_LOGIN_URL,\n  // Add other URLs or settings here\n};\n</code></pre> <p>You can then import <code>CONFIG</code> throughout your app:</p> <pre><code>import { CONFIG } from \"./config\";\n\nconst loginUrl = CONFIG.LOGIN_URL;\nconst apiUrl = CONFIG.BASE_URL;\n</code></pre>"},{"location":"frontend/react/miscellaneous/books/#feature-based-folder-structure","title":"feature-based folder structure","text":"Folder Structure <pre><code>src/\n\u251c\u2500\u2500 shared/                          # Shared resources across the app\n\u2502   \u251c\u2500\u2500 components/                  # Reusable UI components\n\u2502   \u2502   \u251c\u2500\u2500 Button.jsx               # Button component\n\u2502   \u2502   \u251c\u2500\u2500 InputField.jsx           # Input field component\n\u2502   \u2502   \u251c\u2500\u2500 Modal.jsx                # Modal component\n\u2502   \u2502   \u2514\u2500\u2500 Header.jsx               # Header component\n\u2502   \u251c\u2500\u2500 routes/                      # Shared routing logic (e.g., private/public routes)\n\u2502   \u2502   \u251c\u2500\u2500 PrivateRoute.jsx         # Route that requires authentication\n\u2502   \u2502   \u251c\u2500\u2500 PublicRoute.jsx          # Route accessible without authentication\n\u2502   \u2502   \u2514\u2500\u2500 AppRoutes.jsx            # Centralized route management\n\u2502   \u251c\u2500\u2500 utils/                       # Utility functions/helpers\n\u2502   \u2502   \u251c\u2500\u2500 formatDate.js            # Utility to format dates\n\u2502   \u2502   \u251c\u2500\u2500 validateEmail.js         # Utility to validate email format\n\u2502   \u2502   \u2514\u2500\u2500 localStorageHelper.js    # Helper for localStorage operations\n\u2502   \u251c\u2500\u2500 store/                       # Global state management (Redux slices, context)\n\u2502   \u2502   \u251c\u2500\u2500 store.js                 # Redux store configuration\n\u2502   \u2502   \u251c\u2500\u2500 rootReducer.js           # Root reducer combining all slices\n\u2502   \u2502   \u251c\u2500\u2500 authSlice.js             # Redux slice for authentication state\n\u2502   \u2502   \u2514\u2500\u2500 userSlice.js             # Redux slice for user data\n\u2502   \u2514\u2500\u2500 hooks/                       # Reusable hooks\n\u2502       \u251c\u2500\u2500 useAuth.js               # Custom hook for authentication logic\n\u2502       \u251c\u2500\u2500 useFetch.js              # Custom hook for fetching data\n\u2502       \u2514\u2500\u2500 useLocalStorage.js       # Custom hook for managing localStorage\n\u2502\n\u251c\u2500\u2500 features/                        # Feature-based organization\n\u2502   \u251c\u2500\u2500 auth/                        # Authentication feature\n\u2502   \u2502   \u251c\u2500\u2500 components/              # UI components specific to auth\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 LoginForm.jsx        # Login form component\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 SignupForm.jsx       # Signup form component\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 ForgotPassword.jsx   # Forgot password component\n\u2502   \u2502   \u251c\u2500\u2500 api/                     # API logic for authentication\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 authApi.js           # Authentication API slice (authApi)\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 authService.js       # Auth service for handling login/signup\n\u2502   \u2502   \u251c\u2500\u2500 store/                   # Auth-specific Redux logic\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 authSlice.js         # Auth Redux slice\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 authSelectors.js     # Selectors for auth state\n\u2502   \u2502   \u251c\u2500\u2500 routes/                  # Feature-specific routes for auth\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 authRoutes.js        # Routes like /login, /signup, /forgot-password\n\u2502   \u2502   \u2514\u2500\u2500 utils/                   # Utility functions specific to auth\n\u2502   \u2502       \u2514\u2500\u2500 validateCredentials.js # Validation utility for auth forms\n\u2502   \u251c\u2500\u2500 dashboard/                   # Dashboard feature (example)\n\u2502   \u2502   \u251c\u2500\u2500 components/              # Dashboard UI components\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 DashboardHeader.jsx  # Dashboard header component\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Sidebar.jsx          # Sidebar component\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 DashboardContent.jsx # Dashboard main content\n\u2502   \u2502   \u251c\u2500\u2500 api/                     # Dashboard-related API calls\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 dashboardApi.js      # API logic for dashboard\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 dashboardService.js  # Service to fetch dashboard data\n\u2502   \u2502   \u251c\u2500\u2500 store/                   # Redux slice for dashboard\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 dashboardSlice.js    # Dashboard Redux slice\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 dashboardSelectors.js # Selectors for dashboard state\n\u2502   \u2502   \u2514\u2500\u2500 routes/                  # Routes for dashboard feature\n\u2502   \u2502       \u2514\u2500\u2500 dashboardRoutes.js   # Dashboard routes\n\u2502   \u2514\u2500\u2500 user/                         # User profile feature (example)\n\u2502       \u251c\u2500\u2500 components/               # User-related UI components\n\u2502       \u2502   \u251c\u2500\u2500 UserProfile.jsx       # User profile component\n\u2502       \u2502   \u251c\u2500\u2500 EditProfile.jsx       # Edit profile component\n\u2502       \u2502   \u2514\u2500\u2500 UserSettings.jsx      # User settings component\n\u2502       \u251c\u2500\u2500 api/                      # User-related API logic\n\u2502       \u2502   \u251c\u2500\u2500 userApi.js            # User-related API calls\n\u2502       \u2502   \u2514\u2500\u2500 userService.js        # Service to fetch and update user data\n\u2502       \u251c\u2500\u2500 store/                    # Redux slice for user state\n\u2502       \u2502   \u251c\u2500\u2500 userSlice.js          # User state slice\n\u2502       \u2502   \u2514\u2500\u2500 userSelectors.js      # Selectors for user state\n\u2502       \u2514\u2500\u2500 routes/                   # Routes specific to user profile\n\u2502           \u2514\u2500\u2500 userRoutes.js         # Routes for user profile pages\n\u2502\n\u251c\u2500\u2500 types/                           # TypeScript types (if applicable)\n\u2502   \u251c\u2500\u2500 auth.d.ts                    # Types for auth state or API responses\n\u2502   \u251c\u2500\u2500 user.d.ts                    # Types for user-related data\n\u2502   \u2514\u2500\u2500 api.d.ts                     # Types for API responses\n\u2514\u2500\u2500 App.jsx                           # Root application component\n</code></pre> <p>Example Usage:</p> authApi.jsauthSlice.jsuseAuth.js <p>authApi.js (API slice for auth)</p> <pre><code>// src/features/auth/api/authApi.js\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';\nimport { BASE_URL } from '../../../shared/utils/config';\n\nexport const authApi = createApi({\n    reducerPath: 'authApi',\n    baseQuery: fetchBaseQuery({ baseUrl: BASE_URL }),\n    endpoints: (builder) =&gt; ({\n        login: builder.mutation({\n            query: (credentials) =&gt; ({\n                url: '/login',\n                method: 'POST',\n                body: credentials,\n            }),\n        }),\n    }),\n});\n\nexport const { useLoginMutation } = authApi;\n</code></pre> <p>authSlice.js (Redux slice for auth state)</p> <pre><code>// src/features/auth/store/authSlice.js\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst initialState = {\n    user: null,\n    isAuthenticated: false,\n};\n\nconst authSlice = createSlice({\n    name: 'auth',\n    initialState,\n    reducers: {\n        setUser: (state, action) =&gt; {\n            state.user = action.payload;\n            state.isAuthenticated = true;\n        },\n        logout: (state) =&gt; {\n            state.user = null;\n            state.isAuthenticated = false;\n        },\n    },\n});\n\nexport const { setUser, logout } = authSlice.actions;\nexport default authSlice.reducer;\n</code></pre> <p>useAuth.js (Custom hook to manage authentication)</p> <pre><code>// src/shared/hooks/useAuth.js\nimport { useSelector, useDispatch } from 'react-redux';\nimport { setUser, logout } from '../../features/auth/store/authSlice';\n\nexport const useAuth = () =&gt; {\n    const dispatch = useDispatch();\n    const user = useSelector((state) =&gt; state.auth.user);\n\n    const login = (userData) =&gt; {\n        dispatch(setUser(userData));\n    };\n\n    const logoutUser = () =&gt; {\n        dispatch(logout());\n    };\n\n    return { user, login, logoutUser };\n};\n</code></pre> <p>Conclusion:</p> <p>This file and folder structure follows a feature-based approach, making it scalable and maintainable. Each feature (e.g., authentication, dashboard, user profile) has its own folder containing related components, services, store, and routes. Shared resources such as UI components, hooks, and utilities are centralized in the shared/ folder for reuse across the app.</p> <p>This organization will help you manage a growing codebase as your application scales.</p> <p></p>"},{"location":"frontend/react/miscellaneous/handling-side-effects/","title":"Handling Side Effects","text":"<p>Handling side effects in React is crucial for building robust and maintainable applications. Side effects are operations that affect something outside the scope of the function being executed, such as data fetching, subscriptions, or manually changing the DOM. Here\u2019s a breakdown of techniques and standards to manage side effects effectively in React:</p> Handling Side Effects <p>In React, side effects are operations that interact with the outside world or affect other parts of your application, such as:</p> <ul> <li>API Calls: Fetching data from a server.</li> <li>Subscriptions: Setting up connections to external services.</li> <li>Manual DOM Manipulation: Directly modifying the DOM outside of React\u2019s typical rendering flow.</li> <li>Timers: Using <code>setTimeout</code> or <code>setInterval</code>.</li> </ul> <p>These side effects can\u2019t be managed directly within the pure functions of React components because they need to be handled at specific points in the component lifecycle.</p>"},{"location":"frontend/react/miscellaneous/handling-side-effects/#choosing-between-react-hooks-and-redux-middleware","title":"Choosing Between React Hooks and Redux Middleware","text":"<p>In React applications, managing side effects can be done using various approaches, and React hooks and Redux are two prominent tools for handling side effects. Here\u2019s a breakdown of how each approach works and when you might use them:</p> Use React Hooks WhenUse Redux Middleware WhenSummary <ul> <li>You need to manage side effects within individual components.</li> <li>Your side effects are specific to component logic and don\u2019t require global state management.</li> <li>You want a straightforward, declarative approach to handling side effects directly within your components.</li> </ul> <ul> <li>You have a more complex application with global state management needs.</li> <li>Side effects involve multiple components or require coordinating between various parts of your application. You need to manage actions and state updates across different parts of your app in a more centralized manner.</li> </ul> <ul> <li>React Hooks are great for managing side effects within individual components or when creating reusable logic with custom hooks.</li> <li>Redux Middleware (like Thunk or Saga) is useful for managing complex asynchronous flows and side effects that involve global state or require coordination across multiple components.</li> </ul> <p>In practice, you might use both approaches together in a single application: React hooks for local component-level effects and Redux for global state management and complex side effects.</p>"},{"location":"frontend/react/miscellaneous/handling-side-effects/#using-redux-middleware-eg-redux-thunk-redux-saga","title":"Using Redux Middleware (e.g., Redux Thunk, Redux Saga)","text":"Redux ThunkRedux Saga <ul> <li>Purpose: Middleware for handling asynchronous actions in Redux, such as data fetching.</li> <li>Usage: Allows you to write action creators that return functions instead of action objects, enabling async logic.</li> </ul> <pre><code>// actions.js\nexport const fetchData = () =&gt; {\n    return dispatch =&gt; {\n        dispatch({ type: 'FETCH_DATA_REQUEST' });\n            fetch('https://api.example.com/data')\n            .then(response =&gt; response.json())\n            .then(data =&gt; dispatch({ type: 'FETCH_DATA_SUCCESS', payload: data }))\n            .catch(error =&gt; dispatch({ type: 'FETCH_DATA_FAILURE', error }));\n    };\n};\n</code></pre> <ul> <li>Purpose: A middleware library for managing side effects in Redux applications using generator functions.</li> <li>Usage: Ideal for complex asynchronous flows, handling multiple actions, and performing more advanced control flow.</li> </ul> <pre><code>import { call, put, takeEvery } from 'redux-saga/effects';\n\nfunction* fetchData() {\n    try {\n        const response = yield call(fetch, 'https://api.example.com/data');\n        const data = yield response.json();\n        yield put({ type: 'FETCH_DATA_SUCCESS', payload: data });\n    } catch (error) {\n        yield put({ type: 'FETCH_DATA_FAILURE', error });\n    }\n}\n\nfunction* watchFetchData() {\n    yield takeEvery('FETCH_DATA_REQUEST', fetchData);\n}\n\nexport default watchFetchData;\n</code></pre>"},{"location":"frontend/react/miscellaneous/namespace-import/","title":"Namespace Import","text":""},{"location":"frontend/react/miscellaneous/namespace-import/#overview","title":"Overview","text":"<pre><code>import * as test from \"react\";\nconsole.log(test);\n</code></pre> <p>The line <code>import * as test from \"react\";</code> imports everything from the <code>react</code> package and assigns it to the <code>test</code> object. So, when you log <code>test</code> to the console, it will display an object that contains all of React's exports.</p> <p>The output of <code>console.log(test)</code> would be an object that looks like this (depending on the version of React you're using):</p> <p>So, when you run <code>console.log(test)</code>, the output will be an object with these categories of exports, including <code>functions</code>, <code>hooks</code>, <code>components</code>, and <code>utilities</code>. Here's a basic idea of what it might look like in the console:</p> <pre><code>{\n  Component: [Function: Component],\n  createElement: [Function: createElement],\n  Fragment: [Function: Fragment],\n  PureComponent: [Function: PureComponent],\n  useState: [Function: useState],\n  useEffect: [Function: useEffect],\n  useContext: [Function: useContext],\n  useReducer: [Function: useReducer],\n  useRef: [Function: useRef],\n  useMemo: [Function: useMemo],\n  useCallback: [Function: useCallback],\n  useLayoutEffect: [Function: useLayoutEffect],\n  createContext: [Function: createContext],\n  forwardRef: [Function: forwardRef],\n  memo: [Function: memo],\n  StrictMode: [Function: StrictMode],\n  Children: { /* methods for working with children */ },\n  isValidElement: [Function: isValidElement],\n  cloneElement: [Function: cloneElement],\n  version: 'X.X.X',  // The version of React you're using\n  PropTypes: { /* PropTypes validation methods */ },\n  ... // Other internal or exported methods.\n}\n</code></pre>"},{"location":"frontend/react/miscellaneous/namespace-import/#categories-of-react-exports","title":"Categories of React Exports","text":"<ol> <li> <p>React Component Functions:</p> <p>React's component-related functions are often part of the exports. For example:</p> <ul> <li><code>React.Component</code> (the base class for class components)</li> <li><code>React.createElement</code> (to create JSX elements)</li> <li><code>React.Fragment</code> (used to group multiple children without adding extra nodes to the DOM)</li> <li><code>React.PureComponent</code> (a version of Component that implements shouldComponentUpdate with shallow props and state comparison)</li> </ul> </li> <li> <p>Hooks (from React 16.8 onwards):</p> <ul> <li><code>useState</code> (a hook for managing state in functional components)</li> <li><code>useEffect</code> (a hook for side-effects in functional components)</li> <li><code>useContext</code> (a hook for accessing context values)</li> <li><code>useReducer</code> (for complex state logic in functional components)</li> <li><code>useRef</code> (for creating mutable references that persist across renders)</li> <li><code>useMemo</code> (for optimizing expensive calculations)</li> <li><code>useCallback</code> (for memoizing functions)</li> <li><code>useLayoutEffect</code> (similar to <code>useEffect</code>, but it fires synchronously after all DOM mutations)</li> </ul> </li> <li> <p>Context API:</p> <ul> <li><code>React.createContext</code> (to create a context object)</li> <li><code>React.useContext</code> (hook for consuming context)</li> </ul> </li> <li> <p>Higher-Order Components (HOCs):</p> <ul> <li><code>React.forwardRef</code> (to forward refs in functional components)</li> <li><code>React.memo</code> (to memoize a component and prevent unnecessary re-renders)</li> </ul> </li> <li> <p>Error Boundaries and Lifecycle:</p> <ul> <li><code>React.Component</code> (class component with lifecycle methods)</li> <li><code>React.StrictMode</code> (a wrapper component that helps with development issues)</li> </ul> </li> <li> <p>Utilities:</p> <ul> <li><code>React.Children</code> (API for dealing with props.children)</li> <li><code>React.isValidElement</code> (to check if an object is a valid React element)</li> <li><code>React.cloneElement</code> (to clone and modify React elements)</li> </ul> </li> <li> <p>PropTypes (for type checking props in non-TypeScript React applications):</p> <ul> <li><code>React.PropTypes</code> (deprecated but still available for validation of component props)</li> </ul> </li> <li> <p>Version and Miscellaneous:</p> <p>You might see <code>React.version</code> (which holds the version of React being used). Also, potentially some other internal utilities, although most of these aren't meant to be used directly by developers.</p> </li> </ol>"},{"location":"frontend/react/miscellaneous/namespace-import/#summary-of-features-you-still-use-in-react-besides-hooks","title":"Summary of Features You Still Use in React Besides Hooks","text":"<ul> <li>Class Components: Sometimes necessary for legacy support or when you need lifecycle methods.</li> <li>JSX: Core syntax for writing components.</li> <li>Context API: For managing shared state across components.</li> <li>Error Boundaries: To catch errors in the component tree.</li> <li>Refs: For directly interacting with the DOM or class component instances.</li> <li>PropTypes: For runtime type-checking in non-TypeScript applications.</li> <li>HOCs (Higher-Order Components): For reusing component logic and behavior.</li> <li>React.memo: For performance optimization, especially for functional components.</li> <li>StrictMode: A development tool to help find potential issues.</li> <li>React Router: For managing routing and navigation in React applications.</li> </ul> <p>Long-Term Memory Tips:</p> <ul> <li>Group related concepts: Try to remember concepts based on their purpose. For example, lifecycle and state management together under class components or performance optimization under React.memo.</li> <li>Use real-world analogies: For instance, consider HOCs as \u201cenhancers\u201d that give additional power to components, much like how a superhero can get enhanced abilities.</li> <li>Practice regularly: As you build React apps, you'll naturally encounter and use these features.</li> <li>Focus on common patterns: React\u2019s ecosystem encourages reusable patterns like higher-order components, memoization, and context for managing state, so you\u2019ll encounter these regularly.</li> </ul> <p>By recognizing when to use these features and their specific purposes, you\u2019ll have a more complete understanding of React that will help you in both current and future projects.</p>"},{"location":"frontend/react/miscellaneous/namespace-import/#additional","title":"Additional","text":"<p>Core React Functions</p> <p>Yes, Core React Functions (like <code>React.createElement</code>, <code>React.Component</code>, <code>React.PureComponent</code>, <code>React.Fragment</code>, etc.) can still be relevant to functional components, although their usage has evolved in the context of modern React development.</p> <p>Here's how each core function relates to functional components:</p> <p>1. React.createElement</p> <ul> <li> <p>Relevance: While you rarely call <code>React.createElement</code> directly in your code (because JSX compiles to it), it\u2019s still important to understand that this function is used internally to create elements.</p> </li> <li> <p>In Functional Components: JSX in functional components is ultimately compiled to calls to <code>React.createElement</code>.</p> </li> </ul> <pre><code>const element = &lt;h1&gt;Hello, World!&lt;/h1&gt;;\n// Internally, JSX compiles to:\nconst element = React.createElement(\"h1\", null, \"Hello, World!\");\n</code></pre> <p>Use case in functional components:</p> <ul> <li>Directly using <code>React.createElement</code> is rare unless you are working with more complex dynamic JSX generation. But it\u2019s useful to understand how React transforms your JSX code into React elements.</li> </ul> <p>2. React.Fragment</p> <ul> <li> <p>Relevance: <code>React.Fragment</code> is commonly used in functional components when you need to return multiple elements from a component without adding an extra node to the DOM.</p> </li> <li> <p>In Functional Components: It's extremely useful for wrapping multiple elements that you want to return without introducing an unnecessary wrapper (like a <code>&lt;div&gt;</code>).</p> </li> </ul> <pre><code>const MyComponent = () =&gt; (\n  &lt;React.Fragment&gt;\n    &lt;h1&gt;Hello&lt;/h1&gt;\n    &lt;p&gt;This is a fragment example&lt;/p&gt;\n  &lt;/React.Fragment&gt;\n);\n</code></pre> <p>Use case in functional components:</p> <ul> <li>Wrapping multiple elements in a component without introducing an extra DOM node. You can also use the shorthand <code>&lt;&gt;...</code> for fragments.</li> </ul> <pre><code>const MyComponent = () =&gt; (\n  &lt;&gt;\n    &lt;h1&gt;Hello&lt;/h1&gt;\n    &lt;p&gt;This is a fragment example&lt;/p&gt;\n  &lt;/&gt;\n);\n</code></pre> <p>3. React.Component &amp; React.PureComponent</p> <ul> <li>Relevance: These are primarily used for class-based components, but functional components can achieve similar behavior through hooks and the <code>React.memo</code> higher-order component.</li> <li>In Functional Components: While functional components don\u2019t use React.Component directly, <code>React.memo</code> provides a performance optimization for functional components similar to <code>React.PureComponent</code>.</li> </ul> Example <pre><code>const MyComponent = React.memo((props) =&gt; {\n    return &lt;div&gt;{props.message}&lt;/div&gt;;\n});\n</code></pre> <p>Use case in functional components:</p> <ul> <li>You can use <code>React.memo</code> to avoid unnecessary re-renders in functional components, which mimics the behavior of <code>React.PureComponent</code> (which compares props shallowly to avoid re-renders).</li> </ul> <p>4. <code>React.createRef()</code> and <code>useRef</code></p> <ul> <li>Relevance: <code>React.createRef()</code> is used with class components to get references to DOM elements or class instances, but for functional components, you generally use the <code>useRef</code> hook.</li> <li>In Functional Components: You use <code>useRef</code> to persist a reference across renders without triggering re-renders.</li> </ul> <pre><code>import { useRef } from \"react\";\n\nconst MyComponent = () =&gt; {\n  const inputRef = useRef();\n\n  const focusInput = () =&gt; {\n    inputRef.current.focus();\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;input ref={inputRef} /&gt;\n      &lt;button onClick={focusInput}&gt;Focus Input&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n</code></pre> <p>Use case in functional components:</p> <ul> <li><code>useRef</code> is a direct replacement for <code>createRef</code> in class components and allows you to keep a reference to DOM elements or mutable values in a way that doesn\u2019t cause re-renders.</li> </ul> <p>5. React.StrictMode</p> <ul> <li>Relevance: <code>React.StrictMode</code> is a wrapper component that helps with identifying potential problems in your React codebase. It is typically used in development to highlight issues but does not affect production builds.</li> <li>In Functional Components: <code>React.StrictMode</code> is used in the same way for functional components. It\u2019s a development-only feature to catch unsafe lifecycle methods and other potential issues.</li> </ul> <pre><code>import React from \"react\";\n\nconst App = () =&gt; (\n  &lt;React.StrictMode&gt;\n    &lt;MyComponent /&gt;\n  &lt;/React.StrictMode&gt;\n);\n</code></pre> <p>Use case in functional components:</p> <ul> <li><code>React.StrictMode</code> helps ensure that your functional components adhere to best practices and provides warnings for potential issues in development.</li> </ul> <p>6. React.isValidElement</p> <ul> <li>Relevance: <code>React.isValidElement</code> is used to check whether an object is a valid React element. This can still be useful for functional components, especially when you're dealing with dynamic content and want to check if something is a valid React element before rendering it.</li> <li>In Functional Components: If you're building a library or working with dynamic data, you may need to validate whether something is a valid React element.</li> </ul> <pre><code>const MyComponent = ({ children }) =&gt; {\n  if (React.isValidElement(children)) {\n    return &lt;div&gt;{children}&lt;/div&gt;;\n  }\n  return &lt;div&gt;Invalid child element&lt;/div&gt;;\n};\n</code></pre> <p>Use case in functional components:</p> <ul> <li>Useful when building dynamic UI elements or libraries that involve checking if something is a React element before rendering it.</li> </ul> Summary of Core React Functions in Functional Components <ul> <li><code>React.createElement</code>: Compiled from JSX. Typically not used directly, but important to understand how React elements are created.</li> <li><code>React.Fragment</code>: Commonly used to group multiple elements without adding extra nodes to the DOM.</li> <li><code>React.Component</code> &amp; <code>React.PureComponent</code>: Not used directly in functional components, but similar behavior can be achieved with hooks (e.g., <code>React.memo</code> for optimization).</li> <li><code>useRef</code> (or <code>React.createRef</code>): Used to reference DOM elements or persist values across renders without triggering re-renders.</li> <li><code>React.StrictMode</code>: Used for development to catch potential issues.</li> <li><code>React.isValidElement</code>: Can be used to check if a value is a valid React element, useful for dynamic rendering.</li> <li><code>React.memo</code>: Used to memoize functional components and prevent unnecessary re-renders, similar to React.PureComponent for class components.</li> </ul> Conclusion <ul> <li>Core React functions like <code>createElement</code>, <code>Fragment</code>, and <code>React.memo</code> are still used in functional components, though in modern React, they are often abstracted away in the form of JSX or hooks. Understanding these functions helps deepen your understanding of how React works under the hood, but in most day-to-day coding with functional components, you will use JSX, <code>useRef</code>, <code>React.memo</code>, and <code>React.Fragment</code> the most.</li> </ul>"},{"location":"frontend/react/miscellaneous/react-depth/","title":"React Depth","text":"<p>React is a powerful JavaScript library used to build user interfaces, but beyond its fundamental concepts, there are deeper aspects and lesser-known features that can help developers better understand and utilize its full potential. These \"deep secrets\" can improve performance, maintainability, and the flexibility of your applications. Let's explore some of these:</p>"},{"location":"frontend/react/miscellaneous/react-depth/#overview","title":"Overview","text":""},{"location":"frontend/react/miscellaneous/react-depth/#1-react-fiber-architecture","title":"1. React Fiber Architecture","text":"<ul> <li>What it is: The React Fiber architecture is a complete rewrite of React's core algorithm for rendering. It allows React to break down rendering work into smaller chunks, which helps improve performance, especially for complex UI updates.</li> <li>Why it\u2019s a secret: Fiber enables features like asynchronous rendering, which helps React avoid blocking the UI thread and gives it the ability to prioritize work. This is particularly important for React\u2019s performance optimizations, such as Concurrent Mode and Suspense.</li> <li>How to use it: Fiber is used automatically when React is in Concurrent Mode, but to fully exploit this, you need to leverage the right patterns (like Suspense for data fetching or lazy loading).</li> </ul>"},{"location":"frontend/react/miscellaneous/react-depth/#2-reacts-reconciliation-process","title":"2. React\u2019s Reconciliation Process","text":"<ul> <li>What it is: The reconciliation process is how React compares the new virtual DOM with the previous one and decides how to update the real DOM efficiently.</li> <li>Why it\u2019s a secret: React\u2019s algorithm tries to minimize changes to the DOM by applying heuristics (e.g., comparing the type of elements or the keys of lists), but understanding how reconciliation works can help you optimize rendering and reduce unnecessary updates.</li> <li>How to use it: Use keys when rendering lists to help React identify which items have changed. Also, avoid using the <code>index</code> as a key in dynamic lists, as it can break the reconciliation process.</li> </ul>"},{"location":"frontend/react/miscellaneous/react-depth/#3-hooks-internals","title":"3. Hooks Internals","text":"<ul> <li>What it is: React\u2019s hooks API provides a way to manage state, side effects, context, and other features in functional components, but their internal implementation can reveal interesting insights.</li> <li>Why it\u2019s a secret: Under the hood, hooks like <code>useState</code> and <code>useEffect</code> rely on a linked list of \"work in progress\" for each component instance, allowing React to track and manage the state across multiple renders.</li> <li>How to use it: Understanding this helps you avoid anti-patterns such as improper hook dependencies or unnecessary re-renders. <code>useCallback</code>, <code>useMemo</code>, and <code>React.memo</code> are crucial tools for preventing unnecessary re-renders.</li> </ul>"},{"location":"frontend/react/miscellaneous/react-depth/#4-react-suspense-and-concurrent-mode","title":"4. React Suspense and Concurrent Mode","text":"<p>What it is: React Suspense is a way to handle asynchronous data fetching, allowing you to defer rendering parts of the UI until data is ready. When combined with Concurrent Mode, it can make rendering more responsive and less jarring for users. Why it\u2019s a secret: Although still considered experimental in some cases, when used correctly, Concurrent Mode allows React to work on multiple tasks at once, prioritizing urgent updates (such as user input) while rendering other components in the background. How to use it: Suspense allows you to wrap async components and show loading states while waiting for the data to be fetched. To use it effectively, you need to ensure your app is ready for async rendering, which may involve careful data-fetching strategies.</p>"},{"location":"frontend/react/miscellaneous/react-depth/#5-custom-hooks-for-reusable-logic","title":"5. Custom Hooks for Reusable Logic","text":"<ul> <li>What it is: Custom hooks are a way to reuse stateful logic across components without modifying the component hierarchy.</li> <li>Why it\u2019s a secret: Many developers use built-in hooks, but few tap into the power of custom hooks. Custom hooks can encapsulate complex logic such as form handling, fetching data, or managing component lifecycle effects in a modular and reusable way.</li> <li>How to use it: A custom hook is just a JavaScript function that starts with <code>use</code>, and you can include any logic or hook calls that you want to share between components. This is particularly useful for separating concerns and promoting code reuse.</li> </ul>"},{"location":"frontend/react/miscellaneous/react-depth/#6-context-api-for-global-state","title":"6. Context API for Global State","text":"<ul> <li>What it is: React\u2019s Context API provides a way to pass data through the component tree without having to manually prop-drill.</li> <li>Why it\u2019s a secret: While many use Context for theming or localization, its real potential shines when used for global state management (like user authentication or settings). However, if used improperly, it can lead to performance issues, as all components that consume context will re-render whenever the context value changes.</li> <li>How to use it: Use <code>React.memo</code> and <code>useMemo</code> in combination with context to prevent unnecessary re-renders. For large-scale apps, you might want to pair the Context API with a state management library like Redux or Recoil.</li> </ul>"},{"location":"frontend/react/miscellaneous/react-depth/#7-reacts-useeffect-dependency-array","title":"7. React\u2019s useEffect Dependency Array","text":"<ul> <li>What it is: The useEffect hook runs after every render, and the second argument (dependency array) determines when the effect should run.</li> <li>Why it\u2019s a secret: Developers often get confused with the dependency array. Omitting dependencies or setting them incorrectly can lead to bugs (e.g., stale closures or unnecessary re-renders).</li> <li>How to use it: Always ensure the dependencies are correctly set, and when necessary, use the useCallback or useMemo hooks to ensure that stable references are passed to useEffect to avoid unnecessary side effects.</li> </ul>"},{"location":"frontend/react/miscellaneous/react-depth/#8-error-boundaries","title":"8. Error Boundaries","text":"<ul> <li>What it is: Error boundaries are components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of crashing the app.</li> <li>Why it\u2019s a secret: While error boundaries are widely used for catching UI errors, they are often overlooked when building robust error-handling systems. Additionally, they only catch errors in the render phase, not during event handlers or async functions.</li> <li>How to use it: Use error boundaries around critical UI sections to avoid app crashes. Make sure to integrate them with logging systems to capture detailed error information.</li> </ul>"},{"location":"frontend/react/miscellaneous/react-depth/#9-reactmemo-for-performance-optimization","title":"9. React.memo for Performance Optimization","text":"<ul> <li>What it is: <code>React.memo</code> is a higher-order component that helps optimize the performance of functional components by preventing unnecessary re-renders when props have not changed.</li> <li>Why it\u2019s a secret: While <code>React.memo</code> can drastically reduce render times, it\u2019s often underused. Developers sometimes don't apply it correctly or use it where it's not needed.</li> <li>How to use it: Wrap stateless components in <code>React.memo</code> if they only render based on props that are unlikely to change often. It\u2019s important to remember that <code>React.memo</code> only shallowly compares props, so if deep objects or arrays are passed, you may still need to use <code>useMemo</code> or <code>useCallback</code> to optimize performance.</li> </ul>"},{"location":"frontend/react/miscellaneous/react-depth/#10-react-server-side-rendering-ssr-and-static-site-generation-ssg","title":"10. React Server-Side Rendering (SSR) and Static Site Generation (SSG)","text":"<ul> <li>What it is: Server-Side Rendering (SSR) and Static Site Generation (SSG) are techniques for rendering React applications on the server before sending them to the client.</li> <li>Why it\u2019s a secret: SSR and SSG improve performance and SEO by sending fully rendered HTML to the client instead of JavaScript, but implementing them correctly requires some understanding of React's hydration process and how data fetching works.</li> <li>How to use it: React can be set up with frameworks like Next.js, which simplifies SSR and SSG. Use SSR when you need to render dynamic content based on user interaction or data, and SSG for static content that doesn\u2019t change often.</li> </ul>"},{"location":"frontend/react/miscellaneous/react-depth/#conclusion","title":"Conclusion:","text":"<p>While React is widely known for its core concepts like components, JSX, and hooks, diving deeper into the architecture and advanced features such as Suspense, Concurrent Mode, and React\u2019s reconciliation process can unlock significant performance improvements and new capabilities. By leveraging these deep features thoughtfully, you can build more optimized, scalable, and responsive applications.</p>"},{"location":"frontend/react/optimization/code-splitting/","title":"Code Splitting","text":"<pre><code>import React, { Suspense } from \"react\";\nimport { BrowserRouter as Router, Routes, Route } from \"react-router-dom\";\n\nconst Login = React.lazy(() =&gt; import(\"../features/auth/components/Login\"));\nconst Dashboard = React.lazy(() =&gt;\n  import(\"../features/dashboard/components/Dashboard\")\n);\n\nconst AppRoutes = () =&gt; {\n  return (\n    &lt;Router&gt;\n      &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;\n        &lt;Routes&gt;\n          &lt;Route path=\"/\" element={&lt;Login /&gt;} /&gt;\n          &lt;Route path=\"/dashboard\" element={&lt;Dashboard /&gt;} /&gt;\n        &lt;/Routes&gt;\n      &lt;/Suspense&gt;\n    &lt;/Router&gt;\n  );\n};\n\nexport default AppRoutes;\n</code></pre>"},{"location":"frontend/react/optimization/code-splitting/#techniques-and-patterns","title":"Techniques and patterns","text":"<p>Below are some advanced code splitting techniques and patterns that you can use in large applications.</p>"},{"location":"frontend/react/optimization/code-splitting/#1-split-by-routes-route-based-code-splitting","title":"1. Split by Routes (Route-based Code Splitting)","text":"<p>The most common and effective form of code splitting in React is <code>route-based splitting</code>. Each route is dynamically loaded, meaning that only the JavaScript required for the current route is loaded.</p> <p>This pattern reduces the initial loading time because the user only downloads the JavaScript they need for the page they are visiting.</p> <pre><code>import React, { Suspense } from \"react\";\nimport { BrowserRouter as Router, Routes, Route } from \"react-router-dom\";\n\n// Lazily load components\nconst Login = React.lazy(() =&gt; import(\"../features/auth/components/Login\"));\nconst Dashboard = React.lazy(() =&gt;\n  import(\"../features/dashboard/components/Dashboard\")\n);\nconst Profile = React.lazy(() =&gt;\n  import(\"../features/profile/components/Profile\")\n);\nconst Settings = React.lazy(() =&gt;\n  import(\"../features/settings/components/Settings\")\n);\n\nconst AppRoutes = () =&gt; {\n  return (\n    &lt;Router&gt;\n      &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;\n        &lt;Routes&gt;\n          &lt;Route path=\"/\" element={&lt;Login /&gt;} /&gt;\n          &lt;Route path=\"/dashboard\" element={&lt;Dashboard /&gt;} /&gt;\n          &lt;Route path=\"/profile\" element={&lt;Profile /&gt;} /&gt;\n          &lt;Route path=\"/settings\" element={&lt;Settings /&gt;} /&gt;\n        &lt;/Routes&gt;\n      &lt;/Suspense&gt;\n    &lt;/Router&gt;\n  );\n};\n\nexport default AppRoutes;\n</code></pre>"},{"location":"frontend/react/optimization/code-splitting/#2-split-by-component-component-level-code-splitting","title":"2. Split by Component (Component-level Code Splitting)","text":"<p>If you have a large component that isn't needed immediately on the first render but may be required later, you can split those components into separate bundles. You can use <code>React.lazy</code> for this.</p> <p>For example, let's say you have a large admin panel or a settings page that isn't needed on the first load.</p> <pre><code>const AdminPanel = React.lazy(() =&gt; import(\"../features/admin/AdminPanel\"));\nconst SettingsPage = React.lazy(() =&gt;\n  import(\"../features/settings/SettingsPage\")\n);\n</code></pre> <p>You can conditionally load these components on demand based on user interaction:</p> <pre><code>const SettingsButton = () =&gt; {\n  const [isSettingsOpen, setIsSettingsOpen] = useState(false);\n\n  const openSettings = () =&gt; {\n    setIsSettingsOpen(true);\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;button onClick={openSettings}&gt;Open Settings&lt;/button&gt;\n      {isSettingsOpen &amp;&amp; (\n        &lt;Suspense fallback={&lt;div&gt;Loading Settings...&lt;/div&gt;}&gt;\n          &lt;SettingsPage /&gt;\n        &lt;/Suspense&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n</code></pre> <p>This ensures that the <code>SettingsPage</code> component is only loaded when the user clicks the button, thus improving the performance.</p>"},{"location":"frontend/react/optimization/code-splitting/#3-lazy-loading-non-ui-code-utility-functions-services-and-api-calls","title":"3. Lazy Loading Non-UI Code (Utility Functions, Services, and API Calls)","text":"<p>Sometimes, your application might have large utility libraries, API calls, or configuration files that aren\u2019t immediately needed when the page loads. By using <code>dynamic imports</code> for these non-UI assets, you can defer loading until they're actually needed.</p> <pre><code>const fetchData = React.lazy(() =&gt; import(\"../services/fetchData\"));\nconst userService = React.lazy(() =&gt; import(\"../services/userService\"));\n</code></pre> <p>Then, you can load and use these services inside your components:</p> <pre><code>import React, { Suspense, useState, useEffect } from \"react\";\n\nconst App = () =&gt; {\n  const [data, setData] = useState(null);\n\n  useEffect(() =&gt; {\n    // Lazy load the fetchData service\n    const loadData = async () =&gt; {\n      const { fetchData } = await import(\"../services/fetchData\");\n      const result = await fetchData();\n      setData(result);\n    };\n\n    loadData();\n  }, []);\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Data: {data ? JSON.stringify(data) : \"Loading...\"}&lt;/h1&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n</code></pre> <p>This ensures that your data-fetching logic and services are loaded only when needed, reducing the bundle size.</p>"},{"location":"frontend/react/optimization/code-splitting/#4-lazy-loading-large-third-party-libraries","title":"4. Lazy Loading Large Third-Party Libraries","text":"<p>Some third-party libraries can be quite large and are not always needed immediately. Using <code>dynamic imports</code> for these libraries will ensure that they are only loaded when required.</p> <p>For instance, let's say you are using a large charting library like <code>Chart.js</code> or <code>D3.js</code> that\u2019s only required for a particular section of the app (e.g., a dashboard):</p> <pre><code>const ChartJS = React.lazy(() =&gt; import(\"chart.js\"));\n\nconst Dashboard = () =&gt; (\n  &lt;Suspense fallback={&lt;div&gt;Loading Chart...&lt;/div&gt;}&gt;\n    &lt;ChartJS /&gt;\n  &lt;/Suspense&gt;\n);\n</code></pre> <p>This ensures that <code>Chart.js</code> is only loaded when the user navigates to the dashboard or a page that requires the chart.</p>"},{"location":"frontend/react/optimization/code-splitting/#5-split-css-files-css-code-splitting","title":"5. Split CSS Files (CSS Code Splitting)","text":"<p>You can dynamically load styles along with components using libraries like <code>styled-components</code>, <code>@emotion/css</code>, or using Webpack's splitChunks feature to split CSS for components that are lazily loaded.</p> <p>For example, with <code>styled-components</code>, you could dynamically load a component and apply its styles:</p> <pre><code>import styled from \"styled-components\";\n\nconst Button = styled.button`\n  background-color: blue;\n  color: white;\n`;\n\nconst LazyLoadedComponent = React.lazy(() =&gt; import(\"./LazyComponent\"));\n\nconst App = () =&gt; {\n  return (\n    &lt;div&gt;\n      &lt;Button&gt;Click Me&lt;/Button&gt;\n      &lt;Suspense fallback={&lt;div&gt;Loading Component...&lt;/div&gt;}&gt;\n        &lt;LazyLoadedComponent /&gt;\n      &lt;/Suspense&gt;\n    &lt;/div&gt;\n  );\n};\n</code></pre> <p>Alternatively, with Webpack's <code>splitChunks</code> option, you can configure CSS and JavaScript to be split into separate chunks based on routes or other criteria.</p>"},{"location":"frontend/react/optimization/code-splitting/#6-lazy-load-images-and-assets","title":"6. Lazy Load Images and Assets","text":"<p>For media-heavy applications, images and assets can significantly increase the page load time. You can <code>lazy-load images</code> to ensure they are only loaded when they appear in the viewport.</p> <p>You can use a package like react-lazyload to implement this:</p> <pre><code>import LazyLoad from \"react-lazyload\";\n\nconst MyComponent = () =&gt; (\n  &lt;div&gt;\n    &lt;LazyLoad height={200} offset={100}&gt;\n      &lt;img src=\"large-image.jpg\" alt=\"Lazy loaded\" /&gt;\n    &lt;/LazyLoad&gt;\n  &lt;/div&gt;\n);\n</code></pre> Summary of Code Splitting Techniques: <ul> <li>Route-based Code Splitting: Split code by routes to load JavaScript for each page only when the user visits that page.</li> <li>Component-level Code Splitting: Lazy-load heavy components only when needed.</li> <li>Lazy-load Non-UI Code: Defer loading of utility functions, services, or data files.</li> <li>Lazy-load Third-Party Libraries: Dynamically load large libraries that are not needed immediately.</li> <li>CSS Code Splitting: Split CSS files for components that are loaded lazily.</li> <li>Preloading and Prefetching: Preload or prefetch resources for anticipated user interactions.</li> <li>Split by Dependencies: Use shared libraries across pages to reduce duplication and leverage caching.</li> <li>Lazy-load Images/Assets: Load images and media only when they enter the viewport to improve page load time.</li> </ul> <p>By combining these strategies, you can significantly reduce the initial load time and improve the performance of large React applications.</p>"},{"location":"frontend/react/optimization/error-boundaries/","title":"Error Boundaries","text":""},{"location":"frontend/react/optimization/error-boundaries/#overview","title":"Overview","text":"<p>Error boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI. They help prevent the entire app from crashing when an error occurs in a part of the UI.</p> <p></p> Note <ul> <li> <p>When to use it? Use error boundaries around components that may throw errors, especially in production apps, to improve the user experience and prevent a full app crash.</p> </li> <li> <p>Why use it? They allow you to handle runtime errors gracefully and keep your app functional even when some parts break.</p> </li> <li> <p>When not to use it? You don\u2019t need an error boundary in every component, only around parts of your app where errors are more likely or critical.</p> </li> <li> <p>Example: In functional components, you can't use class-based error boundaries directly, but you can use <code>React.ErrorBoundary</code> from libraries like react-error-boundary.</p> </li> </ul>"},{"location":"frontend/react/optimization/error-boundaries/#react-version-that-introduced-error-boundaries","title":"React Version that Introduced Error Boundaries","text":"<p>Error boundaries were introduced in React 16 (released in September 2017). They provide a way to catch JavaScript errors anywhere in a component tree and log those errors, preventing them from crashing the entire app.</p> <p>Key Changes in React 16:</p> <ul> <li><code>getDerivedStateFromError()</code>: A static method that allows you to update the state when an error occurs.</li> <li><code>componentDidCatch()</code>: A lifecycle method that is called when an error is thrown in a descendant component.</li> </ul> Summary <ul> <li>Error boundaries were introduced in React 16 (2017) and are primarily used in class components.</li> <li>In functional components, React doesn't directly support error boundaries, but you can use libraries like react-error-boundary for a hook-based approach.</li> <li>If you're using React 16.6 or later, you can safely use error boundaries to catch errors in components and display fallback UI to improve the user experience.</li> </ul>"},{"location":"frontend/react/optimization/error-boundaries/#advanced","title":"Advanced","text":"<p>In a React functional component, error boundaries were traditionally implemented using class components. However, with the introduction of hooks, you can use libraries like react-error-boundary to implement error boundaries in a more idiomatic way for functional components.</p>"},{"location":"frontend/react/optimization/error-boundaries/#basic-example-using-react-error-boundary","title":"Basic Example Using react-error-boundary","text":"<p>To handle errors in a functional component, you can use the ErrorBoundary component from the react-error-boundary package. First, you'll need to install it:</p> <pre><code>npm install react-error-boundary\n</code></pre> 1. ErrorBoundary Setup2. When to Use 3. Where to Place 4. When NOT to Use  <p>Here's a simple example of how to create an error boundary around a component in a functional component setup.</p> <pre><code>import React, { useState } from 'react';\nimport { ErrorBoundary } from 'react-error-boundary';\n\n// This will be the component that might throw an error\nconst BuggyComponent = () =&gt; {\n    const [counter, setCounter] = useState(0);\n\n    if (counter === 3) {\n        // Simulate an error\n        throw new Error('Oops! Something went wrong');\n    }\n\n    return (\n        &lt;div&gt;\n            &lt;h2&gt;Buggy Component&lt;/h2&gt;\n            &lt;button onClick={() =&gt; setCounter(counter + 1)}&gt;Increment&lt;/button&gt;\n            &lt;p&gt;Counter: {counter}&lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n\n// This is a fallback UI to show in case of an error\nconst FallbackComponent = ({ error, resetErrorBoundary }) =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;h2&gt;Something went wrong: {error.message}&lt;/h2&gt;\n            &lt;button onClick={resetErrorBoundary}&gt;Try again&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\n// Main App Component with ErrorBoundary around BuggyComponent\nconst App = () =&gt; {\n    return (\n        &lt;ErrorBoundary FallbackComponent={FallbackComponent}&gt;\n            &lt;BuggyComponent /&gt;\n        &lt;/ErrorBoundary&gt;\n    );\n};\n\nexport default App;\n</code></pre> <p>Key Concepts</p> <ul> <li> <p><code>ErrorBoundary</code> Component: This component will catch any errors that happen in its child components (like <code>BuggyComponent</code>) and display a fallback UI (<code>FallbackComponent</code>) instead of the default error screen.</p> </li> <li> <p><code>FallbackComponent</code>: This is a custom fallback UI that will be shown when an error is caught. It has access to the error object and a <code>resetErrorBoundary</code> function that can be used to retry or reset the error state.</p> </li> <li> <p><code>BuggyComponent</code>: A sample component that simulates an error when the counter reaches 3.</p> </li> </ul> <p>When to Use Error Boundaries in a Large Codebase</p> <p>In a large codebase, you would want to use error boundaries strategically rather than wrapping every single component in one. Here\u2019s when and how to use them effectively:</p> <ul> <li> <p>Around Critical Sections: If you have areas in your app that are particularly prone to errors (e.g., third-party integrations, dynamic data fetching, complex UI rendering), wrap those sections in error boundaries to prevent them from breaking the entire app.</p> </li> <li> <p>Higher-Level Component Wrapping: Rather than placing an error boundary around every component, it's more common to wrap major sections or \"features\" of the app. For example:</p> <ul> <li>Top-level error boundaries: You could place an error boundary around the entire app or major sections (e.g., routing, page components, etc.).</li> <li>Nested error boundaries: You can have smaller, more focused error boundaries around specific parts of the UI, like a widget or a specific feature page (e.g., a user profile page or a dashboard).</li> </ul> </li> <li> <p>Fallback UI: Make sure to provide user-friendly fallback UIs. This is where you can show a message like \"Something went wrong\" or a \"Retry\" button that gives the user an option to attempt the operation again. This makes the app feel more resilient.</p> </li> </ul> <p>Where to Place Error Boundaries in a Large Codebase</p> <ul> <li> <p>At the Route Level: If you're using React Router, you can wrap each route in an error boundary. This helps isolate errors that occur in different parts of the app, like in the ProfilePage or DashboardPage, without crashing the whole app.</p> <pre><code>&lt;ErrorBoundary FallbackComponent={FallbackComponent}&gt;\n    &lt;Route path=\"/profile\" component={ProfilePage} /&gt;\n&lt;/ErrorBoundary&gt;\n</code></pre> </li> <li> <p>At the Feature Level: If you have specific components or feature areas that are more complex or prone to errors (e.g., components with lots of state or interaction), wrap them individually.</p> </li> <li> <p>Around Data Fetching Logic: Components that fetch data (e.g., using useEffect) may throw errors in case of network failures or unexpected responses. Wrapping those components in an error boundary can help manage those errors gracefully.</p> </li> </ul> <p>When NOT to Use Error Boundaries</p> <p>While error boundaries are great, there are scenarios where they may not be needed:</p> <ul> <li> <p>Inside Event Handlers: You don\u2019t need an error boundary around event handlers (e.g., button clicks, form submissions). Errors inside event handlers don't propagate to the component tree; they are caught by React's built-in error handling.</p> </li> <li> <p>For Expected Errors: If you know a component might fail, it might be better to handle those errors directly with <code>try-catch</code> or conditional rendering rather than relying on an error boundary. For example, if you are fetching data and know that a network request might fail, you can use state and <code>try-catch</code> logic to handle it locally.</p> </li> <li> <p>For Every Component: You don't need to add error boundaries around every component in your app. It's better to apply them where they make the most sense (e.g., critical UI, third-party integrations).</p> </li> </ul>"},{"location":"frontend/react/optimization/error-boundaries/#conclusion","title":"Conclusion","text":"<p>In a large React app, you should use error boundaries to catch and handle errors gracefully, but not everywhere. Focus on wrapping parts of your app where errors are likely or critical. Keep your app responsive and user-friendly by providing fallback UI, and consider using libraries like react-error-boundary to make it easier to work with error boundaries in functional components.</p> <p>If you want more control over specific error handling, you can use the <code>componentDidCatch</code> and <code>getDerivedStateFromError</code> methods in class-based error boundaries, or you can combine error boundaries with your custom error-handling logic.</p>"},{"location":"frontend/react/optimization/error-boundaries/#reference","title":"Reference","text":"<ul> <li>Error Boundaries in React - Handling Errors Gracefully</li> <li>Error Handling in React With Error Boundary</li> <li>Mastering Advanced Error Handling in Functional React Components</li> </ul> <p>Video</p> <p> </p> <p> </p>"},{"location":"frontend/react/optimization/intro/","title":"Intro","text":"<p>Optimizing performance in functional components in React involves a variety of techniques to prevent unnecessary re-renders and ensure efficient rendering. Here\u2019s a detailed look at some key strategies:</p>"},{"location":"frontend/react/optimization/intro/#1-memoization","title":"1. Memoization:","text":"<ul> <li> <p><code>React.memo()</code>: Wrap functional components with React.memo() to prevent unnecessary re-renders if the props haven't changed.</p> <pre><code>const MyComponent = React.memo((props) =&gt; {\n    // component code\n});\n</code></pre> </li> <li> <p><code>React.memo()</code> performs a shallow comparison of props by default. For custom comparison logic, pass a second argument, areEqual:</p> <pre><code>const MyComponent = React.memo((props) =&gt; {\n    // component code\n    }, (prevProps, nextProps) =&gt; {\n    // custom comparison logic\n    return prevProps.someValue === nextProps.someValue;\n});\n</code></pre> </li> </ul>"},{"location":"frontend/react/optimization/intro/#2-callback-memoization","title":"2. Callback Memoization:","text":"<ul> <li> <p><code>useCallback()</code>: Use <code>useCallback()</code> to memoize callback functions, preventing them from being recreated on every render unless dependencies change.</p> <pre><code>const handleClick = useCallback(() =&gt; {\n    // handle click\n}, [dependencies]);\n</code></pre> <p>This ensures that the function identity remains stable, which is especially useful when passing callbacks to child components.</p> </li> </ul>"},{"location":"frontend/react/optimization/intro/#3-memoizing-computed-values","title":"3. Memoizing Computed Values:","text":"<ul> <li> <p><code>useMemo()</code>: Use <code>useMemo()</code> to memoize expensive computations, so they are only recalculated when their dependencies change.</p> <pre><code>const computedValue = useMemo(() =&gt; {\n    return expensiveFunction(input);\n}, [input]);\n</code></pre> <p>This can help avoid recalculating values on every render.</p> </li> </ul>"},{"location":"frontend/react/optimization/intro/#4-avoid-inline-functions-and-objects","title":"4.  Avoid Inline Functions and Objects:","text":"<ul> <li> <p>Avoid Creating New References: Inline functions and objects can create new references on each render, causing unnecessary re-renders of child components.</p> <pre><code>// Instead of this\n&lt;ChildComponent onClick={() =&gt; doSomething()} /&gt;\n\n// Do this\nconst handleClick = useCallback(() =&gt; {\n    doSomething();\n}, []);\n\n&lt;ChildComponent onClick={handleClick} /&gt;\n</code></pre> </li> </ul>"},{"location":"frontend/react/optimization/intro/#5-optimize-context-usage","title":"5. Optimize Context Usage:","text":"<p>Minimize Context Updates: Passing large objects or frequently changing values through context can cause performance issues. Keep context values as stable and minimal as possible.</p> <p>Split Contexts: Use multiple contexts if needed to avoid unnecessary re-renders.</p>"},{"location":"frontend/react/optimization/intro/#6-reactlazy-and-suspense-for-code-splitting","title":"6. React.lazy and Suspense for Code Splitting:","text":"<ul> <li> <p>Lazy Loading Components: Use <code>React.lazy()</code> to dynamically import components, reducing the initial bundle size and improving load times.</p> <pre><code>const LazyComponent = React.lazy(() =&gt; import('./LazyComponent'));\n\nfunction App() {\n    return (\n        &lt;React.Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;\n            &lt;LazyComponent /&gt;\n        &lt;/React.Suspense&gt;\n    );\n}\n</code></pre> </li> </ul>"},{"location":"frontend/react/optimization/intro/#7-avoid-expensive-operations-in-render","title":"7. Avoid Expensive Operations in Render:","text":"<ul> <li> <p>Move Computations Out of Render: Perform expensive operations outside the render method or inside <code>useMemo</code> to avoid recalculating them on every render.</p> <pre><code>const expensiveValue = useMemo(() =&gt; calculateExpensiveValue(data), [data]);\n</code></pre> </li> </ul>"},{"location":"frontend/react/optimization/intro/#8-optimize-lists-and-keys","title":"8. Optimize Lists and Keys:","text":"<ul> <li> <p>Provide Unique Keys: Ensure that list items have unique and stable keys to help React efficiently manage list updates.</p> <pre><code>{items.map(item =&gt; (\n    &lt;ListItem key={item.id} item={item} /&gt;\n))}\n</code></pre> </li> </ul>"},{"location":"frontend/react/optimization/intro/#9-debounce-or-throttle-expensive-operations","title":"9. Debounce or Throttle Expensive Operations:","text":"<ul> <li> <p>Debouncing and Throttling: Use debouncing or throttling for input handlers or scroll events to limit the frequency of function calls.</p> <pre><code>const handleChange = useDebounce((event) =&gt; {\n    // handle change\n}, 300);\n</code></pre> </li> </ul>"},{"location":"frontend/react/optimization/intro/#10-avoid-frequent-re-renders","title":"10. Avoid Frequent Re-renders:","text":"<ul> <li>Component Design: Design components to avoid frequent re-renders. Use React DevTools to inspect render behavior and optimize accordingly.</li> </ul>"},{"location":"frontend/react/optimization/intro/#11-conditional-rendering","title":"11. Conditional Rendering:","text":"<ul> <li> <p>Render Only What\u2019s Needed: Use conditional rendering to display only what is necessary, reducing the amount of work React has to do.</p> <pre><code>return isVisible ? &lt;Component /&gt; : null;\n</code></pre> </li> </ul>"},{"location":"frontend/react/optimization/intro/#12-clean-up-with-useeffect","title":"12. Clean Up with useEffect:","text":"<ul> <li> <p>Proper Cleanup: Use the cleanup function in useEffect to avoid memory leaks and unnecessary operations on component unmount.</p> <pre><code>useEffect(() =&gt; {\n    const timer = setTimeout(() =&gt; {\n        // do something\n    }, 1000);\n\n    return () =&gt; clearTimeout(timer);\n}, []);\n</code></pre> </li> </ul> <p>By applying these techniques, you can enhance the performance of your React functional components, leading to faster and more efficient applications.</p>"},{"location":"frontend/react/optimization/react-suspense/","title":"React Suspense","text":""},{"location":"frontend/react/optimization/react-suspense/#react-lazy-suspense-vs-error-boundaries-an-overview","title":"React Lazy &amp; Suspense vs Error Boundaries: An Overview","text":"<p>React provides several tools to handle component loading and error handling in modern web applications. React Lazy and Suspense help with lazy loading components and improving the performance of your React application. On the other hand, Error Boundaries are used to catch errors that occur in the rendering process, lifecycle methods, and constructors of React components, allowing the app to recover gracefully from crashes.</p> <p>Let's break these down to understand their purpose, differences, and use cases:</p>"},{"location":"frontend/react/optimization/react-suspense/#react-lazy-suspense","title":"React Lazy &amp; Suspense","text":""},{"location":"frontend/react/optimization/react-suspense/#1-react-lazy","title":"1. React Lazy","text":"<ul> <li> <p>Purpose: <code>React.lazy()</code> allows you to dynamically import a component only when it is needed (i.e., lazy loading). This is useful for code splitting, where components or sections of your app are only loaded when required, improving the initial loading time of your application.</p> </li> <li> <p>How it works: You use <code>React.lazy()</code> to import a component, and React will automatically load it when the component is rendered. It defers the loading of components to reduce the initial bundle size.</p> </li> <li> <p>Syntax:</p> </li> </ul> <pre><code>import React, { lazy } from \"react\";\n\nconst MyComponent = lazy(() =&gt; import(\"./MyComponent\"));\n\nfunction App() {\n  return (\n    &lt;div&gt;\n      &lt;MyComponent /&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre> Key Notes <ul> <li><code>React.lazy</code> works with default exports only.</li> <li>This is particularly useful for larger applications where loading everything upfront would negatively impact performance.</li> </ul>"},{"location":"frontend/react/optimization/react-suspense/#2-react-suspense","title":"2. React Suspense","text":"<ul> <li> <p>Purpose: <code>React.Suspense</code> is a higher-order component that you wrap around components that are being lazy-loaded (using <code>React.lazy()</code>) to handle the loading state (e.g., a spinner or a loading message) while the lazy-loaded component is being fetched.</p> </li> <li> <p>How it works: When a lazy-loaded component is still being downloaded (i.e., not yet available), <code>Suspense</code> shows a fallback UI (like a loading spinner). Once the component is ready, it renders normally.</p> </li> <li> <p>Syntax:</p> </li> </ul> <pre><code>import React, { lazy, Suspense } from \"react\";\n\nconst MyComponent = lazy(() =&gt; import(\"./MyComponent\"));\n\nfunction App() {\n  return (\n    &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;\n      &lt;MyComponent /&gt;\n    &lt;/Suspense&gt;\n  );\n}\n</code></pre> Key Notes <ul> <li>The <code>fallback</code> prop in <code>Suspense</code> is a UI element or component that will be shown until the wrapped component is ready.</li> <li><code>Suspense</code> can also be used with other asynchronous operations like data fetching (though data fetching with Suspense is still experimental).</li> </ul>"},{"location":"frontend/react/optimization/react-suspense/#error-boundaries","title":"Error Boundaries","text":""},{"location":"frontend/react/optimization/react-suspense/#1-purpose-of-error-boundaries","title":"1. Purpose of Error Boundaries","text":"<ul> <li> <p>An Error Boundary is a React component that catches JavaScript errors anywhere in the component tree, logs those errors, and displays a fallback UI instead of crashing the whole app.</p> </li> <li> <p>Use Case: Error boundaries are used to prevent your app from crashing when an error occurs in a part of the component tree. Instead of the entire UI breaking, you can show an error message or an alternative UI.</p> </li> <li> <p>How it works: You define an error boundary by implementing a component with <code>componentDidCatch()</code> lifecycle method (in class components) or static <code>getDerivedStateFromError()</code> method (in functional components). If any error occurs in the component tree, the error boundary catches the error and allows you to handle it gracefully.</p> </li> <li> <p>Syntax:</p> </li> </ul> <pre><code>class ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, info) {\n    // You can log error information to an external service here\n    console.log(error, info);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return &lt;h1&gt;Something went wrong!&lt;/h1&gt;;\n    }\n\n    return this.props.children;\n  }\n}\n\n// Usage:\nfunction App() {\n  return (\n    &lt;ErrorBoundary&gt;\n      &lt;MyComponent /&gt;\n    &lt;/ErrorBoundary&gt;\n  );\n}\n</code></pre> Key Notes <ul> <li>Error boundaries do not catch errors in event handlers, asynchronous code (e.g., <code>setTimeout</code>, <code>fetch</code>), or server-side rendering (SSR) unless you wrap those calls in specific try-catch blocks or handle them separately.</li> <li>The purpose of error boundaries is to avoid entire app crashes by isolating errors to parts of the UI, allowing the rest of the application to continue running.</li> </ul>"},{"location":"frontend/react/optimization/react-suspense/#differences-between-react-lazy-suspense-and-error-boundaries","title":"Differences Between React Lazy &amp; Suspense and Error Boundaries","text":"Aspect React Lazy &amp; Suspense Error Boundaries Purpose Lazy loading components and displaying a loading fallback while components are loading. Catching JavaScript errors in components and displaying a fallback UI when errors occur. When used Used for performance optimization by splitting your app\u2019s code into smaller bundles and loading them on demand. Used to handle runtime errors in the UI so the app doesn't crash unexpectedly. Error Handling Does not handle runtime errors. It only helps to load components lazily. Catches JavaScript errors during rendering, lifecycle methods, and constructors in the React component tree. Use case Useful for code-splitting to improve performance by loading components only when needed. Useful for gracefully handling errors that might occur during rendering and lifecycle events. Fallback UI Shows a fallback UI (e.g., loading spinner) while a lazy-loaded component is being fetched. Shows a fallback UI (e.g., error message) if an error occurs in the child components. Where to use Wrap components or sections of your app that can be lazily loaded. Wrap entire sections or the whole app to catch and handle errors in any component. Works with Works with lazy-loaded components using <code>React.lazy()</code>. Works with any component in the React tree, catching errors during rendering and lifecycle methods."},{"location":"frontend/react/optimization/react-suspense/#key-differences-summarized","title":"Key Differences Summarized:","text":"<ul> <li>React.lazy &amp; Suspense are primarily concerned with performance optimization through code splitting and displaying a loading state when a component is being fetched.</li> <li>Error Boundaries are about error handling, catching runtime errors that might occur during component rendering or lifecycle methods and ensuring the rest of the app doesn\u2019t crash.</li> </ul>"},{"location":"frontend/react/optimization/react-suspense/#example-scenario","title":"Example Scenario:","text":"<ul> <li> <p>React.lazy + Suspense: If you have a large, resource-intensive component that you want to load only when the user visits a particular part of your app, you would use <code>React.lazy</code> and wrap it with <code>Suspense</code> to show a loading spinner while the component is being fetched.</p> </li> <li> <p>Error Boundary: If there\u2019s a bug in one of your components (say a JavaScript error occurs), you would use an <code>Error Boundary</code> to prevent the entire app from crashing, and instead, display a fallback UI like \"Something went wrong.\"</p> </li> </ul>"},{"location":"frontend/react/optimization/react-suspense/#conclusion","title":"Conclusion:","text":"<p>Both React.lazy &amp; Suspense and Error Boundaries improve your React app in different ways. React.lazy &amp; Suspense focus on loading performance, while Error Boundaries focus on error resilience. They are not mutually exclusive and can be used together in the same app to enhance both performance and error handling.</p>"},{"location":"frontend/react/optimization/react-suspense/#questions","title":"Questions","text":"<p>React.lazy works with default exports only. what does it mean explain me clearly</p> <p>When we say that <code>React.lazy()</code> works with default exports only, it refers to the way JavaScript modules are exported and imported. Let\u2019s break this down to understand what this means in simple terms:</p> <p>Understanding Exports and Imports in JavaScript:</p> <p>In JavaScript, when you want to share a piece of code (like a function, class, or object) between different files, you need to export it from one file and import it in another.</p> <p>There are two primary ways to export and import things in JavaScript: default exports and named exports.</p> Example 1. Default Export:2. Named Export: <ul> <li>You can export a single value, function, or class as the \"default\" export from a module.</li> <li>There can be only one default export in a module.</li> </ul> <p>Example of default export:</p> <pre><code>// File: MyComponent.js\nexport default function MyComponent() {\n    return &lt;div&gt;Hello World&lt;/div&gt;;\n}\n</code></pre> <p>When importing this in another file, you can use any name for the import (the name does not need to match the name of the exported function or class):</p> <pre><code>// File: App.js\nimport MyComponent from './MyComponent';  // Importing default export\n</code></pre> <ul> <li>You can export multiple named values from a module. Each export must be explicitly named.</li> <li>Named exports can be used in any combination (you can export many things).</li> </ul> <p>Example of named export:</p> <pre><code>// File: MyComponents.js\nexport function MyComponent() {\n    return &lt;div&gt;Hello World&lt;/div&gt;;\n}\n\nexport function AnotherComponent() {\n    return &lt;div&gt;Goodbye World&lt;/div&gt;;\n}\n</code></pre> <p>When importing, you must use the same name as the one you used in the export:</p> <pre><code>// File: App.js\nimport { MyComponent, AnotherComponent } from './MyComponents';  // Named imports\n</code></pre> <p>Why React.lazy() Works with Default Exports Only</p> <p><code>React.lazy()</code> is a function provided by React that allows you to <code>dynamically load components</code> (lazy loading) only when they are needed. This helps improve your app's performance by reducing the initial bundle size.</p> <p>However, <code>React.lazy()</code> expects the modules to be exported as default exports, not named exports. This is due to the way <code>React.lazy()</code> is designed to handle the default import of a module.</p> <p>Let\u2019s look at how this plays out:</p> Example 1. Works with Default Export:2. Does Not Work with Named Export: <pre><code>// File: MyComponent.js\nexport default function MyComponent() {\n    return &lt;div&gt;Hello World&lt;/div&gt;;\n}\n</code></pre> <p>Now, you can use <code>React.lazy()</code> with the default export:</p> <pre><code>// File: App.js\nimport React, { Suspense, lazy } from 'react';\n\nconst MyComponent = lazy(() =&gt; import('./MyComponent'));  // Default import\n\nfunction App() {\n    return (\n        &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;\n            &lt;MyComponent /&gt;\n        &lt;/Suspense&gt;\n    );\n}\n\nexport default App;\n</code></pre> <p>In this case, <code>React.lazy()</code> works fine because <code>MyComponent</code> is the default export of <code>./MyComponent</code>, so <code>import('./MyComponent')</code> will load the default export.</p> <p>If you try to use <code>React.lazy()</code> with a named export, it will not work correctly. For example:</p> <pre><code>// File: MyComponents.js\nexport function MyComponent() {\n    return &lt;div&gt;Hello World&lt;/div&gt;;\n}\n\n// File: App.js\nconst MyComponent = lazy(() =&gt; import('./MyComponents'));  // Incorrect: Named export doesn't work here\n</code></pre> <p>This will not work because <code>React.lazy()</code> expects the module to have a default export. In the example above, <code>MyComponent</code> is a named export, not the default export, so it won't be properly loaded by <code>React.lazy()</code>.</p> <p>Correct Way to Use Named Exports with React.lazy()</p> <p>If you want to use named exports in conjunction with <code>React.lazy()</code>, you need to import the named export explicitly using the standard JavaScript import syntax. Here's how you can do it:</p> <pre><code>// File: MyComponents.js\nexport function MyComponent() {\n  return &lt;div&gt;Hello World&lt;/div&gt;;\n}\n</code></pre> <pre><code>// File: App.js\nimport React, { Suspense, lazy } from \"react\";\n\n// To use a named export, you need to import it like this:\nconst MyComponent = lazy(() =&gt;\n  import(\"./MyComponents\").then((module) =&gt; ({ default: module.MyComponent }))\n);\n\nfunction App() {\n  return (\n    &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;\n      &lt;MyComponent /&gt;\n    &lt;/Suspense&gt;\n  );\n}\n\nexport default App;\n</code></pre> <p>Why Is This the Case?</p> <ul> <li><code>React.lazy()</code> is designed to work with default exports for simplicity and to make it easier to load a single module.</li> <li>JavaScript's dynamic <code>import()</code> syntax can handle both default and named imports, but <code>React.lazy()</code> is simplified to expect just one export: the default.</li> <li>If you want to dynamically load named exports, you need to use a slightly more complex approach (as shown above).</li> </ul> <p>Summary</p> <ul> <li><code>React.lazy()</code> expects the module to have a default export because it simplifies the process of dynamic importing and rendering.</li> <li>If you try to import a module that uses named exports directly with <code>React.lazy()</code>, it won't work.   To use named exports with <code>React.lazy()</code>, you would have to rewrite the import to map the named export to a default one, as shown in the example.</li> </ul> <p>In practice, this is why default exports are often recommended when using <code>React.lazy()</code> for code splitting in React applications.</p>"},{"location":"frontend/react/optimization/topic/","title":"Topic","text":""},{"location":"frontend/react/optimization/topic/#overview","title":"Overview","text":"<p>In modern React development, there are several advanced concepts and patterns that can help you build more efficient, scalable, and maintainable applications. Below are some advanced topics, including React Suspense, that can elevate your React skills:</p>"},{"location":"frontend/react/optimization/topic/#1-react-suspense-and-concurrent-mode","title":"1. React Suspense and Concurrent Mode","text":"<ul> <li> <p>React Suspense: Suspense is used for data fetching and code splitting. It allows components to \"wait\" for some asynchronous operation (like fetching data) before rendering. This helps in improving the user experience by avoiding loading states scattered throughout the app.</p> <ul> <li>Data Fetching with Suspense: Paired with tools like React Query or Relay, you can use Suspense to handle asynchronous data fetching.</li> <li>Code Splitting: Suspense can also be used with <code>React.lazy</code> to lazy load components, showing a loading fallback until the component has been fetched.</li> </ul> </li> <li> <p>Concurrent Mode: This is an experimental feature that optimizes React rendering for smoother interactions. When enabled, React can work on multiple tasks at once, prioritizing important updates over less important ones. Features like Concurrent Rendering, Concurrent Suspense, and- Transitions can help you build highly responsive applications.</p> <ul> <li>Enables interruptible rendering, where React can pause, resume, and prioritize updates.</li> <li>React 18 introduces features like Automatic Batching and Suspense for Data Fetching that take full advantage of Concurrent Mode.</li> </ul> </li> </ul>"},{"location":"frontend/react/optimization/topic/#2-react-server-components","title":"2. React Server Components","text":"<ul> <li>React Server Components allow you to render parts of your React app on the server while still delivering an interactive, client-side experience. This can significantly reduce the amount of JavaScript sent to the client, improving initial load performance.</li> <li>You can offload heavy rendering work (e.g., complex layouts or static content) to the server, while keeping the interactivity on the client.</li> </ul>"},{"location":"frontend/react/optimization/topic/#3-context-api-usereducer-for-state-management","title":"3. Context API + useReducer for State Management","text":"<ul> <li> <p>React Context: React\u2019s built-in Context API can be used for global state management, although it\u2019s generally recommended for lower-level global state (like theme, user authentication, etc.). For larger applications, combine it with <code>useReducer</code> for more complex state management that mimics the Redux pattern without needing an external library.</p> </li> <li> <p>useReducer: A hook that\u2019s especially useful for managing state with more complicated logic (e.g., multiple actions or deep state changes) within a component or an app. It integrates seamlessly with <code>Context</code> for a global store.</p> </li> </ul>"},{"location":"frontend/react/optimization/topic/#4-custom-hooks-and-hook-composition","title":"4. Custom Hooks and Hook Composition","text":"<ul> <li>Custom Hooks: Create reusable logic for components. Custom hooks abstract away common functionality into functions that you can use across different components.</li> <li> <p>Hook Composition: This involves using multiple hooks together to compose functionality in your components. It enables you to create clean and modular code by combining small pieces of logic into reusable hooks.</p> </li> <li> <p>Example: <code>useFetch</code>, <code>useLocalStorage</code>, or <code>useOnClickOutside</code>.</p> </li> </ul>"},{"location":"frontend/react/optimization/topic/#5-react-memoization-reactmemo-usememo-usecallback","title":"5. React Memoization (React.memo, useMemo, useCallback)","text":"<ul> <li>React.memo: A higher-order component that optimizes functional components by memoizing them. If the props don't change, React skips re-rendering the component.</li> <li>useMemo: A hook that memoizes a computed value so it doesn't need to be recalculated on every render, which can improve performance for expensive calculations.</li> <li>useCallback: A hook that memoizes a function so that it doesn\u2019t get recreated on every render, preventing unnecessary re-renders of child components that depend on it.</li> </ul>"},{"location":"frontend/react/optimization/topic/#6-react-fragments-and-portals","title":"6. React Fragments and Portals","text":"<ul> <li>React Fragments: Allow you to return multiple elements from a component without adding extra nodes to the DOM. This is useful for grouping children elements without introducing unnecessary wrapper divs.</li> <li>React Portals: Allow you to render children into a DOM node that exists outside the hierarchy of the parent component, typically used for modals, tooltips, and popups.</li> </ul>"},{"location":"frontend/react/optimization/topic/#7-error-boundaries","title":"7. Error Boundaries","text":"<ul> <li>Error Boundaries: A component that catches JavaScript errors anywhere in the component tree and logs those errors, while also displaying a fallback UI instead of crashing the entire app. This is useful for building resilient applications.   You can create your own error boundaries using the <code>componentDidCatch</code> lifecycle method or the <code>ErrorBoundary</code> hook (experimental).</li> </ul>"},{"location":"frontend/react/optimization/topic/#8-react-devtools-and-performance-profiling","title":"8. React DevTools and Performance Profiling","text":"<ul> <li>React DevTools: Use the React DevTools extension for debugging and performance profiling. The Profiler tab helps track component render performance and diagnose performance bottlenecks.   You can visualize render times and analyze the performance of individual components to optimize rendering behavior.</li> </ul>"},{"location":"frontend/react/optimization/topic/#9-higher-order-components-hocs","title":"9. Higher Order Components (HOCs)","text":"<ul> <li>Higher Order Components: A pattern that allows you to reuse component logic by wrapping a component with a function that injects new functionality. For example, an HOC can be used to handle authentication, logging, or error handling.   Although HOCs have fallen out of favor with the introduction of hooks, they are still useful in certain cases.</li> </ul>"},{"location":"frontend/react/optimization/topic/#10-lazy-loading-and-code-splitting","title":"10. Lazy Loading and Code Splitting","text":"<ul> <li>Lazy Loading: Lazy loading allows you to load parts of your application only when needed. This reduces the initial load time of your app. Use <code>React.lazy</code> to dynamically import components and wrap them in <code>&lt;Suspense&gt;</code> to show a fallback UI while the component is loading.   Code Splitting: Split your app into smaller bundles to improve loading performance. Tools like Webpack and React.lazy can help with this.</li> </ul>"},{"location":"frontend/react/optimization/topic/#11-typescript-with-react","title":"11. TypeScript with React","text":"<ul> <li>TypeScript: Adding TypeScript to your React projects can help prevent bugs by enforcing static types. TypeScript works seamlessly with React, and the integration allows for better tooling (e.g., code completion, error checking).</li> <li>TypeScript + React Hooks: Learn how to type custom hooks, context providers, and event handlers. With TypeScript, you can also enforce stricter types for props and state.</li> </ul>"},{"location":"frontend/react/optimization/topic/#12-react-hooks-with-observables-rxjs","title":"12. React Hooks with Observables (RxJS)","text":"<ul> <li>RxJS: If you're dealing with complex asynchronous data flows (such as websockets, or multiple streams of data), integrating RxJS with React can help manage these streams using hooks.</li> <li>This can be especially useful when building apps that need to handle real-time data or other complex async behavior.</li> </ul>"},{"location":"frontend/react/optimization/topic/#13-react-and-graphql","title":"13. React and GraphQL","text":"<ul> <li>GraphQL Integration: Learn how to fetch data using GraphQL and libraries like Apollo Client or Relay. These libraries integrate well with React and allow for more flexible and efficient data fetching compared to REST APIs.</li> <li>GraphQL allows you to request exactly the data you need, reducing over-fetching and under-fetching issues, and supports features like pagination, caching, and subscriptions for real-time data.</li> </ul>"},{"location":"frontend/react/optimization/topic/#14-styled-components-and-css-in-js","title":"14. Styled Components and CSS-in-JS","text":"<ul> <li>Styled Components: A popular CSS-in-JS library for React that allows you to write actual CSS code inside JavaScript files, scoped to the component. This pattern helps you avoid global styles, and you can easily theme your components dynamically.</li> <li>There are other libraries for CSS-in-JS like Emotion and Stitches, each with its own set of optimizations.</li> </ul>"},{"location":"frontend/react/optimization/topic/#15-service-workers-and-progressive-web-apps-pwas","title":"15. Service Workers and Progressive Web Apps (PWAs)","text":"<ul> <li>Service Workers: Service workers are background scripts that allow you to cache assets and data for offline usage, creating more resilient web applications.</li> <li>Building a PWA (Progressive Web App) with React lets you build fast, reliable, and engaging apps that work offline or in low-network conditions.</li> </ul>"},{"location":"frontend/react/optimization/topic/#16-unit-testing-with-react-testing-library-and-jest","title":"16. Unit Testing with React Testing Library and Jest","text":"<ul> <li>React Testing Library: Encourages testing from the user's perspective by focusing on how the components behave, rather than testing their internal implementation.</li> <li>Jest: Jest is a popular testing framework that works well with React. It supports features like mocking, assertions, and snapshot testing.</li> </ul> <p>These topics can take your React applications to the next level, making them more efficient, maintainable, and scalable. You don\u2019t necessarily need to learn all of them at once, but exploring them progressively as your project\u2019s complexity grows will help you create better React apps.</p>"},{"location":"frontend/react/pattern/antipattern/","title":"Anti Pattern","text":"<ol> <li> <p>Using <code>indexes</code> as a key</p> <p>Bug</p> <pre><code>return (\n&lt;div&gt;\n    &lt;ul&gt;\n    {items.map((item, index) =&gt; (\n        &lt;li key={index}&gt;\n            {item}\n            &lt;input type=\"text\" /&gt;\n        &lt;/li&gt;\n    ))}\n    &lt;/ul&gt;\n\n    &lt;button onClick={handleClick}&gt;+&lt;/button&gt;\n&lt;/div&gt;\n)\n</code></pre> <p>To solve this problem, we can, for example, use the value of the item if we expect it not to be repeated within the list, or create a unique identifier, for example:</p> <p>Success</p> <pre><code>{items.map((item, index) =&gt; (\n    &lt;li key={`${item}-${index}`}&gt;\n        {item}\n        &lt;input type=\"text\" /&gt;\n    &lt;/li&gt;\n))}\n</code></pre> </li> <li> <p>Spreading properties on DOM elements</p> </li> </ol>"},{"location":"frontend/react/pattern/compound-pattern/","title":"Compound Pattern","text":"<p>Let's create a compound component for a <code>Modal</code> that can be used to display various types of content. The compound components will include <code>Modal</code>, <code>ModalHeader</code>, <code>ModalBody</code>, and <code>ModalFooter</code>.</p> Modal.jsModalHeader.jsModalBody.jsModalFooter.js <pre><code>import React, { useState } from 'react';\n\nconst Modal = ({ children, isOpen, onClose }) =&gt; {\n    return isOpen ? (\n        &lt;div className=\"modal-overlay\" onClick={onClose}&gt;\n            &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n                {children}\n            &lt;/div&gt;\n        &lt;/div&gt;\n    ) : null;\n};\n\nexport default Modal;\n</code></pre> <pre><code>import React from 'react';\n\nconst ModalHeader = ({ children }) =&gt; {\n    return &lt;div className=\"modal-header\"&gt;{children}&lt;/div&gt;;\n};\n\nexport default ModalHeader;\n</code></pre> <pre><code>import React from 'react';\n\nconst ModalBody = ({ children }) =&gt; {\n    return &lt;div className=\"modal-body\"&gt;{children}&lt;/div&gt;;\n};\n\nexport default ModalBody;\n</code></pre> <pre><code>import React from 'react';\n\nconst ModalFooter = ({ children }) =&gt; {\n    return &lt;div className=\"modal-footer\"&gt;{children}&lt;/div&gt;;\n};\n\nexport default ModalFooter;\n</code></pre> <p>Now, let's use these components in an example application:</p> App.js<pre><code>// App.js\nimport React, { useState } from \"react\";\nimport Modal from \"./Modal\";\nimport ModalHeader from \"./ModalHeader\";\nimport ModalBody from \"./ModalBody\";\nimport ModalFooter from \"./ModalFooter\";\n\nconst App = () =&gt; {\n  const [isModalOpen, setIsModalOpen] = useState(false);\n\n  const openModal = () =&gt; {\n    setIsModalOpen(true);\n  };\n\n  const closeModal = () =&gt; {\n    setIsModalOpen(false);\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Compound Pattern in React - Modal Example&lt;/h1&gt;\n      &lt;button onClick={openModal}&gt;Open Modal&lt;/button&gt;\n\n      &lt;Modal isOpen={isModalOpen} onClose={closeModal}&gt;\n        &lt;ModalHeader&gt;\n          &lt;h2&gt;Modal Title&lt;/h2&gt;\n        &lt;/ModalHeader&gt;\n        &lt;ModalBody&gt;\n          &lt;p&gt;This is the content of the modal.&lt;/p&gt;\n        &lt;/ModalBody&gt;\n        &lt;ModalFooter&gt;\n          &lt;button onClick={closeModal}&gt;Close&lt;/button&gt;\n        &lt;/ModalFooter&gt;\n      &lt;/Modal&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n</code></pre> <p>In this example, the <code>Modal</code> component serves as the container for the modal content. The <code>ModalHeader</code>, <code>ModalBody</code>, and <code>ModalFooter</code> components are used within the <code>Modal</code> component to structure and style the different parts of the modal.</p> <p>This compound pattern allows you to create a reusable and flexible modal component by composing smaller components together. Each smaller component focuses on a specific part of the modal, making the code more modular and maintainable.</p>"},{"location":"frontend/react/pattern/container-presentational-patterns/","title":"container presentational patterns","text":"<p>React components typically contain a mix of logic and presentation. By logic, we refer to anything that is unrelated to the UI, such as API calls, data manipulation, and event handlers. The presentation is the part of the render where we create the elements to be displayed on the UI.</p> <p>In React, there are simple and powerful patterns, known as container and presentational, which we can apply when creating components that help us to separate those two concerns.</p>"},{"location":"frontend/react/pattern/function-as-child/","title":"FaC Pattern","text":""},{"location":"frontend/react/pattern/function-as-child/#function-as-child-fac-pattern","title":"Function as Child (FaC) pattern","text":"<p>In React, the \"<code>Function as Child</code>\" (FaC) pattern involves passing a function as a child of a component. This pattern is also known as \"Render Props.\" The basic idea is to pass a function as a child to a component, allowing the component to render content or behavior based on the result of that function.</p> <p>Here's a simple example to illustrate the Function as Child pattern:</p> ParentComponent.js<pre><code>import React from \"react\";\n\nconst ParentComponent = ({ children }) =&gt; {\n  // Execute the function (child) and pass data to it\n  return &lt;div&gt;{children(\"Data from Parent\")}&lt;/div&gt;;\n};\n\nexport default ParentComponent;\n</code></pre> <p>Now, you can use <code>ParentComponent</code> in another component and pass a function as its child:</p> App.js<pre><code>import React from \"react\";\nimport ParentComponent from \"./ParentComponent\";\n\nconst App = () =&gt; {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Function as Child Pattern&lt;/h1&gt;\n\n      {/* Using ParentComponent and passing a function as its child */}\n      &lt;ParentComponent&gt;\n        {(dataFromParent) =&gt; (\n          &lt;p&gt;{`Received data in child component: ${dataFromParent}`}&lt;/p&gt;\n        )}\n      &lt;/ParentComponent&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n</code></pre> <p>In this example, the <code>ParentComponent</code> takes a <code>children</code> prop, which is a function. Inside <code>ParentComponent</code>, it calls the <code>children</code> function and passes some data (\"<code>Data from Parent</code>\" in this case). The child component (the function passed as a child) then receives this data and can use it to render content.</p> <p>The main benefit of the Function as Child pattern is that it allows you to inject dynamic behavior or data into a component from its parent without the need for complex props or state management. It provides a way to share functionality between components in a more flexible and composable manner.</p> <p>This pattern is commonly used in React, especially in cases where you want to abstract away some logic or behavior into a component but allow customization in its usage by passing functions as children.</p> <p>Real Example</p> <p>Lets create <code>Toggle</code> component that can be used to toggle the visibility of content.</p> Toggle.js<pre><code>import React, { useState } from \"react\";\n\nconst Toggle = ({ children }) =&gt; {\n  const [isVisible, setIsVisible] = useState(false);\n\n  const toggleVisibility = () =&gt; {\n    setIsVisible(!isVisible);\n  };\n\n  // Render the child function and pass the toggleVisibility function and the current visibility state\n  return children({ isVisible, toggleVisibility });\n};\n\nexport default Toggle;\n</code></pre> <p>Now, let's use the <code>Toggle</code> component in another component:</p> App.js<pre><code>import React from \"react\";\nimport Toggle from \"./Toggle\";\n\nconst App = () =&gt; {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Function as Child Pattern - Toggle Example&lt;/h1&gt;\n\n      {/* Using Toggle and passing a function as its child */}\n      &lt;Toggle&gt;\n        {({ isVisible, toggleVisibility }) =&gt; (\n          &lt;div&gt;\n            &lt;button onClick={toggleVisibility}&gt;Toggle Visibility&lt;/button&gt;\n\n            {isVisible &amp;&amp; &lt;p&gt;This content is now visible!&lt;/p&gt;}\n          &lt;/div&gt;\n        )}\n      &lt;/Toggle&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n</code></pre> <p>In this example, the <code>Toggle</code> component encapsulates the state and logic for toggling visibility. It takes a function as a child, and that function receives an object with two properties: <code>isVisible</code> (a boolean indicating whether the content is visible) and <code>toggleVisibility</code> (a function to toggle the visibility).</p> <p>The <code>App</code> component uses the <code>Toggle</code> component, passing a function as its child. Inside the function, it receives the <code>isVisible</code> state and the <code>toggleVisibility</code> function, and it uses these to conditionally render content.</p> <p>This pattern is powerful because it allows you to encapsulate state and behavior within a component while giving the consumer of that component full control over the rendering and customization of the UI based on the component's state.</p>"},{"location":"frontend/react/pattern/hoc-pattern/","title":"HoC Pattern","text":"<p>Higher-Order Components (HOCs) are a design pattern in React that allows the reuse of component logic.</p> <p>A Higher-Order Component is a function that takes a component and returns a new component with additional props or behavior. HOCs are commonly used for cross-cutting concerns such as authentication, logging, and data fetching.</p> <p>Here's an example of a Higher-Order Component using a functional component:</p> withLogging.js (HOC file):MyComponent.jsApp.js jsx<pre><code>import React, { useEffect } from 'react';\n\nconst withLogging = (WrappedComponent) =&gt; {\n    const WithLogging = (props) =&gt; {\n        useEffect(() =&gt; {\n            console.log(`Component ${WrappedComponent.name || 'Anonymous'} is mounted`);\n            return () =&gt; {\n                console.log(`Component ${WrappedComponent.name || 'Anonymous'} is unmounted`);\n            };\n        }, []);\n\n        return &lt;WrappedComponent {...props} /&gt;;\n    };\n\n    return WithLogging;\n};\n\nexport default withLogging;\n</code></pre> jsx<pre><code>import React from 'react';\n\nconst MyComponent = () =&gt; {\n    return &lt;div&gt;Hello, I'm a functional component!&lt;/div&gt;;\n};\n\nexport default MyComponent;\n</code></pre> jsx<pre><code>import React from 'react';\nimport withLogging from './withLogging';\nimport MyComponent from './MyComponent';\n\nconst MyComponentWithLogging = withLogging(MyComponent);\n\nconst App = () =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;MyComponentWithLogging /&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default App;\n</code></pre> <p>In this structure:</p> <ul> <li><code>withLogging.js</code> contains the HOC (withLogging).</li> <li><code>MyComponent.js</code> contains the functional component (MyComponent).</li> <li><code>App.js</code> uses the HOC by importing it and applying it to MyComponent.</li> </ul> <p>This modular approach allows you to organize your code better and promotes reusability. You can easily apply the withLogging HOC to other components in different files without duplicating the logic.</p>"},{"location":"frontend/react/pattern/hoc-pattern/#when-naming-higher-order-component-hoc-files-in-a-react-application","title":"When naming Higher-Order Component (HOC) files in a React application","text":"<ul> <li> <p>Prefix with \"with\":</p> <p>It's a common convention to prefix the HOC file name with \"with\" to indicate that it is a Higher-Order Component.</p> <pre><code>withExampleHOC.js\nwithAuthentication.js\nwithTheme.js\n</code></pre> </li> <li> <p>Suffix with \"HOC\":</p> <p>Optionally, you can suffix the file name with \"HOC\" to make it explicit that it is a Higher-Order Component.</p> <pre><code>ExampleComponentHOC.js\nAuthenticationHOC.js\n</code></pre> </li> </ul>"},{"location":"frontend/react/pattern/hoc-pattern/#real-example","title":"Real Example","text":"<p>You can organize your code in a way that makes sense for your project structure. Here's an example of how you might structure the file:</p> withConditionalFormItem.js<pre><code>import React from \"react\";\nimport { Form } from \"antd\";\n\nconst withConditionalFormItem = (WrappedComponent, condition) =&gt; {\n  return (props) =&gt; {\n    if (condition) {\n      return &lt;WrappedComponent {...props} /&gt;;\n    } else {\n      return null; // or you can render an alternative component/message\n    }\n  };\n};\n\nexport default withConditionalFormItem;\n</code></pre> <p>Then, in your main component file:</p> YourFormComponent.js<pre><code>//\nimport React from \"react\";\nimport { Form, Input } from \"antd\";\nimport withConditionalFormItem from \"./withConditionalFormItem\";\n\n// Usage\nconst ConditionalRemarksFormItem = withConditionalFormItem(\n  Form.Item,\n  !isCircular // Condition based on your boolean value\n);\n\nconst YourFormComponent = () =&gt; {\n  return (\n    &lt;Form&gt;\n      {/* Other Form items */}\n      &lt;ConditionalRemarksFormItem label=\"Remarks\" name=\"remarks\"&gt;\n        &lt;Input.TextArea rows={4} placeholder=\"Remarks\" /&gt;\n      &lt;/ConditionalRemarksFormItem&gt;\n      {/* Other Form items */}\n    &lt;/Form&gt;\n  );\n};\n\nexport default YourFormComponent;\n</code></pre> <p>This way, you have a separate file for the higher-order component, making it easy to reuse across different components in your project.</p>"},{"location":"frontend/react/pattern/misc/","title":"Misc","text":""},{"location":"frontend/react/pattern/misc/#conditional-rendering-pattern","title":"<code>Conditional Rendering</code> pattern","text":"<pre><code>import React from \"react\";\n\nconst YourComponent = ({ singleCircularReferenceTemplateResponse }) =&gt; {\n  // Check if the response is still loading\n  const isLoading = !singleCircularReferenceTemplateResponse;\n\n  // Check if the response has content\n  const hasContent = !!singleCircularReferenceTemplateResponse?.content;\n\n  return (\n    &lt;div&gt;\n      {isLoading &amp;&amp; &lt;p&gt;Loading...&lt;/p&gt;}\n      {!isLoading &amp;&amp; !hasContent &amp;&amp; &lt;p&gt;No Content available.&lt;/p&gt;}\n      {!isLoading &amp;&amp; hasContent &amp;&amp; (\n        &lt;div\n          dangerouslySetInnerHTML={{\n            __html: singleCircularReferenceTemplateResponse.content,\n          }}\n        &gt;&lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default YourComponent;\n</code></pre>"},{"location":"frontend/react/pattern/react-pattern-intro/","title":"Introduction","text":""},{"location":"frontend/react/pattern/react-pattern-intro/#react-design-patterns","title":"React Design Patterns","text":"<ul> <li><code>Compound</code> Pattern</li> <li><code>HOC</code> Pattern</li> <li><code>Hooks</code> Pattern</li> <li><code>Container/Presentational</code> Pattern</li> <li><code>Render Props</code> Pattern</li> </ul>"},{"location":"frontend/react/pattern/react-pattern-intro/#reference","title":"Reference","text":"<ul> <li>reactpatterns.js.org</li> <li>patterns.dev</li> <li> <p>reactpatterns.com</p> </li> <li> <p>React Design Patterns</p> </li> </ul>"},{"location":"frontend/react/testing/cypress/","title":"Cypress","text":""},{"location":"frontend/react/testing/cypress/#theory","title":"Theory","text":"<p>Cypress is an end-to-end testing framework that provides a fast, reliable, and easy-to-use way to test your web applications.</p>"},{"location":"frontend/react/testing/cypress/#key-features-of-cypress","title":"Key Features of Cypress:","text":"<ol> <li>Real Browser Testing: Cypress runs tests directly in the browser, giving you a realistic testing environment.</li> <li>Automatic Waiting: Cypress automatically waits for commands and assertions to pass, making your tests more reliable without adding manual waits.</li> <li>Time Travel: Cypress captures snapshots as your tests run, allowing you to hover over commands in the Command Log to see what happened at each step.</li> <li>Debuggability: With detailed error messages and stack traces, Cypress makes debugging failed tests straightforward.</li> <li>Network Traffic Control: Cypress lets you stub and spy on network requests, giving you control over your application's API interactions during tests.</li> <li>Integration with CI/CD: Cypress integrates seamlessly with continuous integration and continuous deployment (CI/CD) pipelines.</li> </ol>"},{"location":"frontend/react/testing/cypress/#when-to-use-cypress","title":"When to Use Cypress","text":"<ul> <li>End-to-End Testing: Cypress is perfect for testing the complete user journey, from loading the application to interacting with various elements and verifying outcomes.</li> <li>Integration Testing: When you need to test how different parts of your application work together, Cypress's realistic browser environment is beneficial.</li> <li>Real Browser Interactions: If you need to test how your application behaves in a real browser, including handling of network requests, cookies, and local storage, Cypress is the right tool.</li> <li>User Interface Testing: Cypress excels at simulating real user interactions and verifying the application's response.</li> </ul>"},{"location":"frontend/react/testing/cypress/#example-use-cases","title":"Example Use Cases","text":"<p>Cypress Example (End-to-End Testing a Login Flow)</p> <ol> <li> <p>Install Cypress:</p> <pre><code>npm install --save-dev cypress\n</code></pre> </li> <li> <p>Example Test File (login.spec.js):</p> <pre><code>describe('Login Flow', () =&gt; {\n    it('should log in successfully', () =&gt; {\n        cy.visit('http://localhost:3000/login');\n        cy.get('input[name=username]').type('user');\n        cy.get('input[name=password]').type('password');\n        cy.get('button[type=submit]').click();\n        cy.url().should('include', '/dashboard');\n        cy.contains('Welcome, user!');\n    });\n});\n</code></pre> </li> <li> <p>Run Tests:</p> <pre><code>npx cypress open\n</code></pre> </li> </ol>"},{"location":"frontend/react/testing/cypress/#summary","title":"Summary","text":"<p>Use Cypress for end-to-end testing, integration testing, and when you need to simulate real user interactions in a browser.</p> <p>In many projects, both tools are used together: Jest for unit and component tests, and Cypress for end-to-end tests. This combination ensures comprehensive test coverage and a robust testing strategy.</p>"},{"location":"frontend/react/testing/intro/","title":"Intro","text":"<p>Mastering React testing in a large codebase can be challenging but is crucial for maintaining a robust and reliable application. Here\u2019s a comprehensive approach to get you started:</p>"},{"location":"frontend/react/testing/intro/#1-understand-the-fundamentals","title":"1.  Understand the Fundamentals","text":"<p>Before diving into complex scenarios, ensure you\u2019re comfortable with the basics:</p> <ul> <li>React Testing Library: Focus on testing components in a way that resembles how users interact with them. It encourages testing components from the user's perspective rather than the implementation details.</li> <li>Jest: A popular testing framework for React applications, providing utilities for assertions, mocking, and more.</li> </ul>"},{"location":"frontend/react/testing/intro/#2-set-up-a-testing-strategy","title":"2.  Set Up a Testing Strategy","text":"<p>Define Objectives:</p> <ul> <li>Unit Tests: Test individual components or functions in isolation.</li> <li>Integration Tests: Ensure that different parts of your application work together as expected.</li> <li>End-to-End Tests: Test the full application flow to simulate real user interactions.</li> </ul> <p>Testing Pyramid:</p> <ul> <li>Unit Tests: Most numerous, quick to run.</li> <li>Integration Tests: Fewer than unit tests, validate interactions.</li> <li>End-to-End Tests: Least frequent but cover the entire workflow.</li> </ul>"},{"location":"frontend/react/testing/intro/#3-establish-a-testing-framework","title":"3.  Establish a Testing Framework","text":"<p>Tools and Libraries:</p> <ul> <li>React Testing Library: For rendering components and querying the DOM.</li> <li>Jest: For assertions, mocking, and test utilities.</li> <li>Cypress or Playwright: For end-to-end testing.</li> <li>Storybook: For visual component testing and development.</li> </ul> <p>Configuration:</p> <ul> <li>Set up Jest and React Testing Library with a consistent configuration. Ensure that Jest is configured for handling imports and processing files correctly.</li> </ul>"},{"location":"frontend/react/testing/intro/#4-write-effective-tests","title":"4. Write Effective Tests","text":"<p>Component Testing:</p> <ul> <li>Render the Component: Use render from React Testing Library to render your component.</li> <li>Query Elements: Use queries like getByText, getByRole, etc., to select elements.</li> <li>Assertions: Use expect to assert conditions about your component.</li> </ul> <pre><code>import { render, screen } from '@testing-library/react';\nimport MyComponent from './MyComponent';\n\ntest('renders the correct text', () =&gt; {\n  render(&lt;MyComponent /&gt;);\n  expect(screen.getByText(/expected text/i)).toBeInTheDocument();\n});\n</code></pre> <p>Integration Testing:</p> <ul> <li>Mock Dependencies: Use tools like jest.mock to mock out dependencies or services.</li> <li>Test User Interactions: Simulate user interactions and verify the outcomes.</li> </ul> <pre><code>import { render, screen, fireEvent } from '@testing-library/react';\nimport MyForm from './MyForm';\n\ntest('submits form data correctly', () =&gt; {\n  render(&lt;MyForm /&gt;);\n  fireEvent.change(screen.getByLabelText(/name/i), { target: { value: 'John Doe' } });\n  fireEvent.click(screen.getByRole('button', { name: /submit/i }));\n  expect(screen.getByText(/form submitted/i)).toBeInTheDocument();\n});\n</code></pre>"},{"location":"frontend/react/testing/intro/#5-maintain-and-scale-tests","title":"5.  Maintain and Scale Tests","text":"<p>Refactor Tests:</p> <ul> <li>Regularly refactor tests to keep them clean and maintainable.</li> <li>Use helper functions or custom hooks for repetitive testing logic.</li> </ul> <p>Test Coverage:</p> <ul> <li>Aim for high test coverage but focus on critical paths and user interactions rather than striving for 100% coverage.</li> </ul> <p>Continuous Integration (CI):</p> <ul> <li>Integrate your tests into a CI pipeline to automatically run tests on code changes and pull requests.</li> </ul>"},{"location":"frontend/react/testing/intro/#6-address-common-challenges","title":"6.  Address Common Challenges","text":"<p>Large Codebase Specifics:</p> <ul> <li>Test Isolation: Ensure tests do not depend on each other. Use mocks and stubs effectively.</li> <li>Performance: Optimize tests to run quickly by avoiding excessive rendering or complex setups.</li> <li>Debugging: Leverage Jest\u2019s debugging tools and React Testing Library\u2019s debugging utilities to troubleshoot failing tests.</li> </ul> <p>Documentation and Best Practices:</p> <ul> <li>Document your testing strategy and best practices for consistency.</li> <li>Conduct regular reviews and updates of your testing approach as the codebase evolves.</li> </ul> <p>By focusing on these areas, you can effectively master React testing and ensure your large codebase remains reliable and maintainable.</p> <p>Testing API calls and optimizing graphs, especially in the context of React applications, involves different strategies for each task. Let\u2019s break down the approaches for both:</p>"},{"location":"frontend/react/testing/intro/#testing-api-calls-in-react","title":"Testing API Calls in React","text":"<ol> <li> <p>Testing API Calls</p> <p>When testing API calls in React components, you'll generally want to isolate the component from the network request to ensure your tests are reliable and fast.</p> <p>Mocking API Calls</p> <ul> <li> <p>Use <code>jest.mock()</code>: You can mock the module that performs the API request (e.g., <code>axios</code>, <code>fetch</code>) to avoid actual network calls during testing.</p> myComponent.jsmyComponent.test.js <pre><code>// myComponent.js\nimport React, { useEffect, useState } from 'react';\nimport axios from 'axios';\n\nconst MyComponent = () =&gt; {\n    const [data, setData] = useState(null);\n\n    useEffect(() =&gt; {\n        axios.get('/api/data')\n        .then(response =&gt; setData(response.data))\n        .catch(error =&gt; console.error(error));\n    }, []);\n\n    if (!data) return &lt;div&gt;Loading...&lt;/div&gt;;\n\n    return &lt;div&gt;{data.message}&lt;/div&gt;;\n};\n\nexport default MyComponent;\n</code></pre> <pre><code>// myComponent.test.js\nimport { render, screen, waitFor } from '@testing-library/react';\nimport axios from 'axios';\nimport MyComponent from './myComponent';\n\n// Mocking axios\njest.mock('axios');\n\ntest('fetches and displays data', async () =&gt; {\n    // Mock implementation\n    axios.get.mockResolvedValue({ data: { message: 'Hello World' } });\n\n    render(&lt;MyComponent /&gt;);\n\n    // Assertion\n    await waitFor(() =&gt; screen.getByText(/hello world/i));\n    expect(screen.getByText(/hello world/i)).toBeInTheDocument();\n});\n</code></pre> </li> </ul> </li> <li> <p>Handling Asynchronous Code</p> <p>When dealing with asynchronous operations:</p> <ul> <li>Use <code>waitFor</code>: To wait for changes in the DOM.</li> <li>Use <code>findBy</code> queries: For assertions involving async updates.</li> </ul> <pre><code>await waitFor(() =&gt; {\n    expect(screen.getByText(/hello world/i)).toBeInTheDocument();\n});\n</code></pre> </li> </ol>"},{"location":"frontend/react/testing/intro/#optimizing-graphs","title":"Optimizing Graphs","text":"<p>Optimizing graphs usually refers to improving the performance of data visualizations. Here\u2019s how to approach this:</p>"},{"location":"frontend/react/testing/intro/#1-before-optimization","title":"1.  Before Optimization","text":"Identify Performance Issues <ul> <li>Large Data Sets: Rendering large amounts of data can be slow.</li> <li>Re-renders: Unnecessary re-renders can impact performance.</li> <li>Complex Calculations: Expensive operations can affect responsiveness.</li> </ul>"},{"location":"frontend/react/testing/intro/#2-optimization-techniques","title":"2.  Optimization Techniques","text":"Optimize Data Handling <ul> <li>Data Aggregation: Aggregate data on the server side to reduce the amount of data sent to the client.</li> <li>Pagination/Infinite Scroll: Load data in chunks rather than all at once.</li> </ul> Optimize Rendering <ul> <li>Virtualization: Use libraries like <code>react-virtualized</code> or <code>react-window</code> to render only visible parts of the graph.</li> <li>Memoization: Use <code>React.memo</code> or <code>useMemo</code> to prevent unnecessary re-renders.</li> <li>Debouncing: For user interactions that trigger updates, use debouncing to limit the frequency of updates.</li> </ul> <pre><code>import React, { memo } from 'react';\nimport { FixedSizeList as List } from 'react-window';\n\nconst Row = memo(({ index, style }) =&gt; (\n&lt;div style={style}&gt;\n    {/* Row content */}\n&lt;/div&gt;\n));\n\nconst MyGraph = ({ data }) =&gt; (\n&lt;List\n    height={600}\n    itemCount={data.length}\n    itemSize={35}\n    width={1000}\n&gt;\n    {Row}\n&lt;/List&gt;\n);\n</code></pre>"},{"location":"frontend/react/testing/intro/#optimize-graph-calculations","title":"Optimize Graph Calculations","text":"<ul> <li>Web Workers: Offload intensive calculations to web workers.</li> <li>Canvas/SVG: Choose the right technology for rendering. For complex graphs, <code>canvas</code> may be more performant than <code>SVG</code>.</li> </ul> <pre><code>const MyGraph = ({ data }) =&gt; {\n  // Drawing logic using canvas API\n\n  return &lt;canvas id=\"graphCanvas\"&gt;&lt;/canvas&gt;;\n};\n</code></pre>"},{"location":"frontend/react/testing/intro/#profile-and-measure-performance","title":"Profile and Measure Performance","text":"<ul> <li>React DevTools: Use the Profiler tab to identify performance bottlenecks in React components.</li> <li>Browser DevTools: Use performance profiling tools to analyze rendering times and identify slow operations.</li> </ul>"},{"location":"frontend/react/testing/intro/#3-after-optimization","title":"3. After Optimization","text":""},{"location":"frontend/react/testing/intro/#test-and-validate","title":"Test and Validate","text":"<ul> <li>Benchmarking: Measure performance improvements before and after optimization.</li> <li>User Testing: Validate that the optimizations improve user experience and do not introduce new issues.</li> </ul>"},{"location":"frontend/react/testing/intro/#continuous-monitoring","title":"Continuous Monitoring","text":"<ul> <li>Performance Monitoring: Continuously monitor performance in production using tools like Google Lighthouse, New Relic, or custom performance metrics.</li> <li>By focusing on these strategies for both testing API calls and optimizing graphs, you can improve the performance and reliability of your React application.</li> </ul>"},{"location":"frontend/react/testing/jest/","title":"Jest","text":""},{"location":"frontend/react/testing/jest/#theory","title":"Theory","text":"<p>Jest is a delightful JavaScript testing framework developed by Facebook, designed to ensure correctness of any JavaScript codebase. It is widely used for testing React applications, but it can be used with any JavaScript project.</p>"},{"location":"frontend/react/testing/jest/#key-features-of-jest","title":"Key Features of Jest:","text":"<ol> <li>Zero Configuration: Jest works out of the box for most JavaScript projects, especially those using React.</li> <li>Snapshots: Jest can capture the output of your components and compare it to a reference snapshot file to ensure UI consistency.</li> <li>Isolated Tests: Each test runs in its own sandbox environment to avoid global state pollution.</li> <li>Coverage Reporting: Jest can generate code coverage reports, helping you understand how much of your code is tested.</li> <li>Mocking: Jest provides powerful mocking capabilities to simulate different scenarios and behaviors for your code dependencies. Parallel Execution: Tests run in parallel, speeding up the testing process.</li> </ol>"},{"location":"frontend/react/testing/jest/#when-to-use-jest","title":"When to Use Jest","text":"<ul> <li>Unit Testing: Jest is ideal for testing individual functions, modules, or components in isolation.</li> <li>Snapshot Testing: If you want to ensure that your UI components render consistently, snapshot testing with Jest is very effective.</li> <li>Mocking Dependencies: When you need to mock dependencies or simulate different scenarios, Jest's mocking capabilities are highly useful.</li> <li>Fast Feedback Loop: Jest's parallel execution and watch mode provide quick feedback during development.</li> </ul>"},{"location":"frontend/react/testing/jest/#example-use-cases","title":"Example Use Cases","text":"<p>Jest Example (Unit Testing a React Component)</p> <ol> <li> <p>Install Jest:</p> <pre><code>npm install --save-dev jest @testing-library/react @testing-library/jest-dom\n</code></pre> </li> <li> <p>Example Test File (<code>MyComponent.test.js</code>):</p> <pre><code>import React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport MyComponent from './MyComponent';\n\ntest('renders a message', () =&gt; {\n    render(&lt;MyComponent /&gt;);\n    const messageElement = screen.getByText(/hello, world!/i);\n    expect(messageElement).toBeInTheDocument();\n});\n</code></pre> </li> <li> <p>Run Tests:</p> <pre><code>npm test\n</code></pre> </li> </ol>"},{"location":"frontend/react/testing/jest/#summary","title":"Summary","text":"<p>Use Jest for unit testing, snapshot testing, and when you need fast feedback during development.</p> <p>In many projects, both tools are used together: Jest for unit and component tests, and Cypress for end-to-end tests. This combination ensures comprehensive test coverage and a robust testing strategy.</p>"},{"location":"frontend/react/testing/measuring-optimization-tools/","title":"Measuring Tools","text":"<p>Measuring the impact of optimizations, particularly in client-side applications like React, involves evaluating several performance metrics before and after making changes. Here\u2019s a structured approach to assess the effectiveness of your optimizations:</p>"},{"location":"frontend/react/testing/measuring-optimization-tools/#1-define-performance-metrics","title":"1.  Define Performance Metrics","text":"<p>Before you can measure changes, you need to define what metrics you\u2019ll be tracking. Common performance metrics include:</p> <ul> <li>Page Load Time: Time taken from initiating a page load to complete rendering.</li> <li>Time to Interactive (TTI): Time until the page is fully interactive.</li> <li>First Contentful Paint (FCP): Time taken for the first piece of content to be painted on the screen.</li> <li>Largest Contentful Paint (LCP): Time taken for the largest piece of content to be painted.</li> <li>Total Blocking Time (TBT): Time during which the page is blocked from user input.</li> <li>FPS (Frames Per Second): Smoothness of animations and interactions.</li> </ul>"},{"location":"frontend/react/testing/measuring-optimization-tools/#2-use-performance-measurement-tools","title":"2.  Use Performance Measurement Tools","text":"<p>1. Google Lighthouse:</p> <ul> <li>How to Use: Run Lighthouse audits in Chrome DevTools (Lighthouse tab), from the command line, or within CI/CD pipelines.</li> <li>What to Measure: Provides scores for performance, accessibility, SEO, and more. Use the performance score and individual metrics (FCP, LCP, TTI) to assess changes.</li> </ul> <p>2. Web Vitals:</p> <ul> <li>How to Use: Integrate the web-vitals library into your application to collect metrics like FCP, LCP, and CLS (Cumulative Layout Shift).</li> <li>What to Measure: Provides real-world performance data from actual user interactions.</li> </ul> <p>3. Chrome DevTools:</p> <ul> <li>How to Use: Use the Performance tab to record and analyze runtime performance, including rendering and scripting times.</li> <li>What to Measure: Look for metrics like scripting time, rendering time, and network requests.</li> </ul> <p>4. Performance APIs:</p> <ul> <li>How to Use: Use the Performance API in your code to manually measure specific timings and events.</li> <li>What to Measure: Custom timings for specific actions or events in your application.</li> </ul> <p>5. Real User Monitoring (RUM):</p> <ul> <li>How to Use: Tools like Google Analytics, New Relic, or Sentry can provide real-user performance metrics.</li> <li>What to Measure: Collect data from actual users to get insights into performance under real-world conditions.</li> </ul>"},{"location":"frontend/react/testing/measuring-optimization-tools/#3-establish-baseline-metrics","title":"3. Establish Baseline Metrics","text":"Before Optimization: <ul> <li>Run Performance Tests: Use the tools mentioned to capture performance metrics before implementing optimizations.</li> <li>Document Baseline Data: Record the metrics as a reference point for comparison.</li> </ul> <pre><code>import { getCLS, getFCP, getLCP, getFID } from 'web-vitals';\n\ngetCLS(console.log); // Report Cumulative Layout Shift\ngetFCP(console.log); // Report First Contentful Paint\ngetLCP(console.log); // Report Largest Contentful Paint\ngetFID(console.log); // Report First Input Delay\n</code></pre>"},{"location":"frontend/react/testing/measuring-optimization-tools/#4-apply-optimizations","title":"4. Apply Optimizations","text":"<p>Implement the changes you believe will improve performance, such as code splitting, lazy loading, optimizing data fetching, or using virtualized lists.</p>"},{"location":"frontend/react/testing/measuring-optimization-tools/#5-re-measure-performance","title":"5. Re-Measure Performance","text":"After Optimization: <ul> <li>Re-run Tests: Use the same tools and methods to measure performance after optimizations are applied.</li> <li>Compare Metrics: Compare the new data against your baseline to assess the impact of the optimizations.</li> </ul>"},{"location":"frontend/react/testing/measuring-optimization-tools/#6-analyze-results","title":"6. Analyze Results","text":"<p>Compare and Interpret:</p> <ul> <li>Improvement: Determine if metrics have improved, such as faster load times, reduced time to interactive, or smoother animations.</li> <li>Regression: Identify if any metrics have worsened or if new issues have been introduced.</li> </ul>"},{"location":"frontend/react/testing/measuring-optimization-tools/#7-continuous-monitoring","title":"7. Continuous Monitoring","text":"<p>Regular Checks:</p> <ul> <li>Ongoing Monitoring: Integrate performance monitoring into your CI/CD pipeline and regularly review performance metrics.</li> <li>User Feedback: Collect feedback from users to ensure that optimizations align with user experience improvements.</li> </ul> <p>Performance Dashboards:</p> <ul> <li>Create Dashboards: Use tools like Google Data Studio, Grafana, or custom dashboards to visualize performance metrics over time.</li> </ul>"},{"location":"frontend/react/testing/measuring-optimization-tools/#example-process","title":"Example Process","text":"<ol> <li> <p>Baseline Measurement:</p> <ul> <li>Before: Run Lighthouse audit and note down FCP, LCP, TTI.</li> </ul> </li> <li> <p>Optimization:</p> <ul> <li>Implement code splitting and lazy loading.</li> </ul> </li> <li> <p>Re-measure:</p> <ul> <li>After: Run Lighthouse audit again and compare the updated metrics.</li> </ul> </li> <li> <p>Analyze:</p> <ul> <li>Results: If FCP improved from 2s to 1s, LCP improved from 3s to 1.5s, this indicates a successful optimization.</li> </ul> </li> </ol> <p>By following these steps, you can effectively measure the impact of your optimizations and ensure that your changes lead to real performance improvements for your users.</p>"},{"location":"frontend/react/testing/measuring-optimization-tools/#react-tools-for-optimization","title":"React Tools for Optimization","text":"<p>For optimizing and measuring performance in a React web application, you have a variety of tools at your disposal. Here\u2019s a comprehensive list of tools categorized by their primary functions:</p>"},{"location":"frontend/react/testing/measuring-optimization-tools/#1-performance-testing-and-optimization","title":"1. Performance Testing and Optimization","text":"<p>1.1 Google Lighthouse</p> <ul> <li>Purpose: Provides performance audits, accessibility, SEO, and best practices.</li> <li>How to Use: Available in Chrome DevTools (Lighthouse tab), as a CLI tool, or as a GitHub Action.</li> <li>Website: Lighthouse</li> </ul> <p>1.2 Web Vitals</p> <ul> <li>Purpose: Measures key user-centric metrics like First Contentful Paint (FCP), Largest Contentful Paint (LCP), and Cumulative Layout Shift (CLS).</li> <li>How to Use: Integrate the web-vitals library into your application to collect and report metrics.</li> <li>Website: Web Vitals</li> </ul> <p>1.3 Chrome DevTools</p> <ul> <li>Purpose: Provides real-time performance insights, profiling, and debugging.</li> <li>How to Use: Access the Performance tab in Chrome DevTools to record and analyze performance.</li> <li>Website: Chrome DevTools</li> </ul> <p>1.4 React DevTools</p> <ul> <li>Purpose: Helps inspect React component hierarchies, measure component render times, and track state and props.</li> <li>How to Use: Available as a browser extension or standalone app.</li> <li>Website: React DevTools</li> </ul> <p>1.5 Webpack Bundle Analyzer</p> <ul> <li>Purpose: Visualizes the size of webpack output files to help optimize bundling.</li> <li>How to Use: Integrate with your webpack configuration to generate interactive bundle reports.</li> <li>Website: Webpack Bundle Analyzer</li> </ul> <p>1.6 Source Map Explorer</p> <ul> <li>Purpose: Analyzes the size of the bundled code and its dependencies.</li> <li>How to Use: Run as a CLI tool to visualize and understand the size of your code.</li> <li>Website: Source Map Explorer</li> </ul>"},{"location":"frontend/react/testing/measuring-optimization-tools/#2-testing-tools","title":"2. Testing Tools","text":"<p>2.1 Jest</p> <ul> <li>Purpose: A testing framework for unit and integration tests with built-in test runners and assertions.</li> <li>How to Use: Write and run tests for JavaScript and React components.</li> <li>Website: Jest</li> </ul> <p>2.2 React Testing Library</p> <ul> <li>Purpose: Provides utilities for testing React components by interacting with the DOM in a user-centric way.</li> <li>How to Use: Write tests that focus on user interactions rather than implementation details.</li> <li>Website: React Testing Library</li> </ul> <p>2.3 Cypress</p> <ul> <li>Purpose: End-to-end testing framework that allows for writing and running integration and UI tests.</li> <li>How to Use: Write tests that simulate user interactions and validate application behavior.</li> <li>Website: Cypress</li> </ul> <p>2.4 Playwright</p> <ul> <li>Purpose: End-to-end testing framework with cross-browser support and automation capabilities.</li> <li>How to Use: Write tests to verify interactions across different browsers.</li> <li>Website: Playwright</li> </ul>"},{"location":"frontend/react/testing/measuring-optimization-tools/#3-monitoring-and-analytics","title":"3. Monitoring and Analytics","text":"<p>3.1 Google Analytics</p> <ul> <li>Purpose: Tracks user interactions and performance metrics for web applications.</li> <li>How to Use: Integrate with your React app to gather and analyze usage data.</li> <li>Website: Google Analytics</li> </ul> <p>3.2 Sentry</p> <ul> <li>Purpose: Provides error tracking and performance monitoring for web applications.</li> <li>How to Use: Integrate with React to track errors, performance issues, and monitor user interactions.</li> <li>Website: Sentry</li> </ul> <p>3.3 New Relic</p> <ul> <li>Purpose: Application performance monitoring (APM) tool with real-time performance metrics and insights.</li> <li>How to Use: Integrate with your app to monitor performance, errors, and user experience.</li> <li>Website: New Relic</li> </ul>"},{"location":"frontend/react/testing/measuring-optimization-tools/#4-code-quality-and-best-practices","title":"4. Code Quality and Best Practices","text":"<p>4.1 ESLint</p> <ul> <li>Purpose: A linting tool for identifying and fixing problems in your JavaScript code.</li> <li>How to Use: Integrate with your development workflow to enforce coding standards and catch errors.</li> <li>Website: ESLint</li> </ul> <p>4.2 Prettier</p> <ul> <li>Purpose: Code formatter that ensures consistent styling across your codebase.</li> <li>How to Use: Integrate with your code editor to format code automatically.</li> <li>Website: Prettier</li> </ul>"},{"location":"frontend/react/testing/measuring-optimization-tools/#5-documentation-and-development","title":"5. Documentation and Development","text":"<p>5.1 Storybook</p> <ul> <li>Purpose: Develop and test UI components in isolation with interactive documentation.</li> <li>How to Use: Set up Storybook to create a component library and visualize components in various states.</li> <li>Website: Storybook</li> </ul> <p>By leveraging these tools, you can effectively measure, optimize, test, and maintain your React web application, ensuring both performance improvements and code quality.</p>"},{"location":"frontend/react/testing/codereport/bugs/cleanup-function/","title":"Cleanup Function","text":"<p>Cleanup functions in React are essential for managing resources and avoiding memory leaks, especially when dealing with asynchronous operations, side effects, or subscriptions. Here\u2019s a breakdown of when and how to use cleanup functions, including patterns and common practices:</p>"},{"location":"frontend/react/testing/codereport/bugs/cleanup-function/#when-to-use-cleanup-functions","title":"When to Use Cleanup Functions","text":"<ol> <li> <p>Asynchronous Operations:</p> <ul> <li>Scenario: You make API calls or other asynchronous tasks in <code>useEffect</code> that might still be running when the component unmounts.</li> <li>Solution: Use a flag or an <code>AbortController</code> to cancel the request if the component unmounts.</li> </ul> </li> <li> <p>Subscriptions:</p> <ul> <li>Scenario: You subscribe to external data sources, like WebSocket connections, event listeners, or other subscriptions.</li> <li>Solution: Unsubscribe or clean up listeners when the component unmounts to prevent memory leaks.</li> </ul> </li> <li> <p>Timers:</p> <ul> <li>Scenario: You set up timers or intervals using <code>setTimeout</code> or <code>setInterval</code>.</li> <li>Solution: Clear the timers when the component unmounts to prevent unexpected behavior.</li> </ul> </li> <li> <p>Event Listeners:</p> <ul> <li>Scenario: You add event listeners to the <code>window</code>, <code>document</code>, or other elements.</li> <li>Solution: Remove these event listeners when the component unmounts to avoid memory leaks.</li> </ul> </li> </ol>"},{"location":"frontend/react/testing/codereport/bugs/cleanup-function/#popular-cleanup-patterns","title":"Popular Cleanup Patterns","text":"<ol> <li> <p>Using a Mounted Flag:</p> <ul> <li> <p>Pattern: Maintain a flag that tracks whether the component is mounted and use it to conditionally perform state updates.</p> </li> <li> <p>Example:</p> <pre><code>useEffect(() =&gt; {\n    let isMounted = true;\n\n    const fetchData = async () =&gt; {\n        const result = await fetchSomeData();\n        if (isMounted) {\n            setData(result);\n        }\n    };\n\n    fetchData();\n\n    return () =&gt; {\n        isMounted = false;\n    };\n}, []);\n</code></pre> </li> </ul> </li> <li> <p>AbortController for Fetch Requests:</p> <ul> <li> <p>Pattern: Use AbortController to cancel ongoing fetch requests when the component unmounts.</p> </li> <li> <p>Example:</p> <pre><code>useEffect(() =&gt; {\n    const controller = new AbortController();\n\n    const fetchData = async () =&gt; {\n        try {\n            const response = await fetch('/data', { signal: controller.signal });\n            const data = await response.json();\n            setData(data);\n        } catch (err) {\n            if (err.name === 'AbortError') {\n                console.log('Fetch aborted');\n            }\n        }\n    };\n\n    fetchData();\n\n    return () =&gt; {\n        controller.abort();\n    };\n}, []);\n</code></pre> </li> </ul> </li> <li> <p>Cleanup for Event Listeners:</p> <ul> <li> <p>Pattern: Remove event listeners added to global objects or elements.</p> </li> <li> <p>Example:</p> <pre><code>useEffect(() =&gt; {\n    const handleResize = () =&gt; {\n        console.log('Resized');\n    };\n\n    window.addEventListener('resize', handleResize);\n\n    return () =&gt; {\n        window.removeEventListener('resize', handleResize);\n    };\n}, []);\n</code></pre> </li> </ul> </li> <li> <p>Clearing Timers:</p> <ul> <li> <p>Pattern: Clear any intervals or timeouts when the component unmounts.</p> </li> <li> <p>Example:</p> <pre><code>useEffect(() =&gt; {\n    const timer = setTimeout(() =&gt; {\n        console.log('Timer triggered');\n    }, 1000);\n\n    return () =&gt; {\n        clearTimeout(timer);\n    };\n}, []);\n</code></pre> </li> </ul> </li> </ol>"},{"location":"frontend/react/testing/codereport/bugs/cleanup-function/#summary","title":"Summary","text":"<ul> <li>Asynchronous Operations: Use a mounted flag or <code>AbortController</code> to cancel ongoing tasks.</li> <li>Subscriptions: Clean up by unsubscribing or removing listeners.</li> <li>Timers: Clear <code>setTimeout</code> or <code>setInterval</code> when the component unmounts.</li> <li>Event Listeners: Remove listeners added to global objects or specific elements.</li> </ul> <p>Using these cleanup techniques helps ensure that your components are efficient and free from memory leaks, providing a better user experience and more reliable performance.</p>"},{"location":"frontend/react/testing/codereport/bugs/cleanup-function/#mail-module","title":"Mail Module","text":""},{"location":"frontend/react/testing/codereport/bugs/cleanup-function/#memory-leak-in-your-application","title":"memory leak in your application","text":"<p>Warning: Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in a useEffect cleanup function.</p> TheoryExample <p>\"Warning: Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application.\"</p> <p>occurs when your React component is unmounted (removed from the UI), but an asynchronous operation (like an API call, event listener, or timeout) tries to update the component\u2019s state after it\u2019s already unmounted. This can lead to a memory leak because the state update is unnecessary and React doesn\u2019t know how to handle it anymore.</p> <p>Why This Happens:</p> <p>When a component is unmounted, it no longer exists in the React tree. However, if asynchronous tasks like API requests, <code>setTimeout</code>, or event listeners are still running, they might try to update the state of the unmounted component, which React warns against.</p> <p>How to Fix It:</p> <p>The solution is to clean up any asynchronous tasks when the component unmounts using the <code>cleanup</code> function in the <code>useEffect</code> hook. This ensures that any pending operations like API calls, subscriptions, or timeouts are canceled before the component unmounts, preventing state updates on unmounted components.</p> <p>Fixing a Memory Leak in <code>useEffect</code></p> Before (Potential Problem)After (With Cleanup) <pre><code>useEffect(() =&gt; {\n    const fetchData = async () =&gt; {\n        const result = await fetchSomeData();\n        setData(result);  // This may cause a state update on an unmounted component\n    };\n\n    fetchData();\n}, []);  // No cleanup, could cause memory leaks\n</code></pre> <p>To prevent the memory leak, you should clean up the asynchronous task when the component unmounts:</p> <pre><code>useEffect(() =&gt; {\n    let isMounted = true;  // This flag will track if the component is still mounted\n\n    const fetchData = async () =&gt; {\n        const result = await fetchSomeData();\n\n        if (isMounted) {  // Only update the state if the component is still mounted\n            setData(result);\n        }\n    };\n\n    fetchData();\n\n    return () =&gt; {\n        isMounted = false;  // Clean up when the component unmounts\n    };\n}, []);  // Cleanup ensures that no updates occur if the component is unmounted\n</code></pre> How to Identify the Issue <ul> <li> <p>Look at <code>ReplyChatBox.js</code>, line 292 (based on the error message). There may be an asynchronous operation, such as an API request, event listener, or timeout, that's trying to update the component's state after it has been unmounted.</p> </li> <li> <p>Check all <code>useEffect</code> hooks in that component to ensure you're properly cleaning up any asynchronous tasks, such as:</p> <ul> <li>API calls (e.g., <code>fetch</code>)</li> <li>WebSocket connections</li> <li><code>setTimeout</code> or <code>setInterval</code></li> <li>Event listeners (<code>addEventListener</code>)</li> </ul> </li> </ul> General Steps to Fix <ul> <li>Identify the asynchronous task that is trying to update state after the component has unmounted.</li> <li>Use <code>useEffect</code> cleanup by returning a function that cancels or cleans up any ongoing async operations or event listeners.</li> <li>Use a mounted flag or <code>AbortController</code> for fetch requests to ensure that state is only updated while the component is still mounted.</li> </ul> <p>Example for Fetch Requests with AbortController:</p> <p>If you are using <code>fetch</code>, you can cancel the request using an <code>AbortController</code>:</p> <pre><code>useEffect(() =&gt; {\n  const controller = new AbortController();\n  const signal = controller.signal;\n\n  const fetchData = async () =&gt; {\n    try {\n      const result = await fetchSomeData({ signal });\n      setData(result);  // Only update if fetch is successful\n    } catch (err) {\n      if (err.name === \"AbortError\") {\n        console.log(\"Fetch aborted\");\n      }\n    }\n  };\n\n  fetchData();\n\n  return () =&gt; {\n    controller.abort();  // Clean up the fetch request when the component unmounts\n  };\n}, []);\n</code></pre> Summary <ul> <li>The warning indicates that some asynchronous task is trying to update state after the component has unmounted.</li> <li>To prevent this, clean up those tasks using <code>useEffect</code> cleanup functions.</li> <li>Be sure to use techniques like the <code>isMounted</code> flag or <code>AbortController</code> to ensure that no state updates occur on unmounted components.</li> </ul>"},{"location":"frontend/react/testing/codereport/bugs/cleanup-function/#improved-code-with-cleanup","title":"Improved Code with Cleanup","text":"Bug CodeImporved CodeKey Improvements <pre><code>useEffect(() =&gt; {\n    fetchAllParticipants();\n}, []);\n\n\nconst fetchAllParticipants = async () =&gt; {\n    const resp = await getAllUsers().catch((err) =&gt; {\n        message.error(\"Failure\");\n    });\n\n    if (resp &amp;&amp; resp.status === 200) {\n        let participantFrom = storage.getItem(\"userId\");\n        let allUsers = resp.data.filter(\n            (obj) =&gt; obj.appUserId == participantFrom\n        );\n\n        setUsers(allUsers);\n    }\n};\n</code></pre> <p>Yes, there\u2019s a potential issue with the code related to asynchronous operations and component unmounting. Specifically, if <code>fetchAllParticipants</code> completes after the component has unmounted, it could attempt to call <code>setUsers</code>, which would lead to the warning you saw: \"Can't perform a React state update on an unmounted component.\"</p> <pre><code>import { useEffect, useState } from 'react';\nimport { message } from 'antd'; // Assuming you're using Ant Design for messages\nimport storage from 'some-storage-module'; // Adjust import based on your setup\nimport { getAllUsers } from 'some-api-module'; // Adjust import based on your setup\n\nconst MyComponent = () =&gt; {\n    const [users, setUsers] = useState([]);\n\n    useEffect(() =&gt; {\n        let isMounted = true; // Flag to track component mount status\n\n        const fetchAllParticipants = async () =&gt; {\n            try {\n                const resp = await getAllUsers();\n                if (isMounted &amp;&amp; resp &amp;&amp; resp.status === 200) {\n                    let participantFrom = storage.getItem(\"userId\");\n                    let allUsers = resp.data.filter(\n                        (obj) =&gt; obj.appUserId == participantFrom\n                    );\n                    setUsers(allUsers);\n                }\n            } catch (err) {\n                message.error(\"Failure\");\n            }\n        };\n\n        fetchAllParticipants();\n\n        return () =&gt; {\n            isMounted = false; // Cleanup function to update the flag on unmount\n        };\n    }, []);\n\n\n    return (\n        &lt;div&gt;\n            {/* Render your users or other components here */}\n        &lt;/div&gt;\n    );\n};\n\nexport default MyComponent;\n</code></pre> <ol> <li> <p>Mounted Flag: Added <code>let isMounted = true;</code> and updated it in the cleanup function to <code>isMounted = false;</code>. This ensures that state updates only occur if the component is still mounted.</p> </li> <li> <p>Error Handling: Moved the <code>catch</code> block into the <code>try...catch</code> statement to handle any potential errors and show a message if something goes wrong with <code>getAllUsers()</code>.</p> </li> <li> <p>Cleanup Function: Ensured that <code>isMounted</code> is set to <code>false</code> when the component unmounts, which prevents <code>setUsers</code> from being called if the component is no longer present.</p> </li> </ol> <p>Summary:</p> <p>By implementing the mounted flag, you prevent the warning about state updates on an unmounted component. This approach ensures that asynchronous operations don't attempt to update state after the component has unmounted, thereby avoiding potential memory leaks and other issues.</p>"},{"location":"frontend/react/testing/codereport/bugs/debouncing/","title":"debouncing","text":""},{"location":"frontend/react/testing/codereport/bugs/debouncing/#overview","title":"Overview","text":"<p>Debouncing is a technique used in programming to improve performance and efficiency, particularly in scenarios where certain actions are triggered repeatedly in a short period. Here\u2019s a breakdown of what debouncing is, why it\u2019s needed, and when to use it:</p>"},{"location":"frontend/react/testing/codereport/bugs/debouncing/#what-is-debouncing","title":"What is Debouncing?","text":"<p>Debouncing is a method used to ensure that a function is only executed after a certain amount of time has passed since the last time it was invoked. In other words, it limits the rate at which a function can fire by postponing the execution until a period of inactivity has been observed.</p>"},{"location":"frontend/react/testing/codereport/bugs/debouncing/#why-do-we-need-debouncing","title":"Why Do We Need Debouncing?","text":"<ol> <li> <p>Performance Improvement: Frequent triggering of functions can cause performance issues, especially if the function involves heavy computations or makes network requests. Debouncing helps to minimize these issues by consolidating multiple triggers into a single execution.</p> </li> <li> <p>User Experience: In web applications, debouncing is often used to improve user experience. For instance, it prevents a search query from being sent to the server on every keystroke, which can be annoying and inefficient.</p> </li> <li> <p>Resource Management: It helps to manage resources better by avoiding unnecessary function calls, reducing the load on both the client and server sides.</p> </li> </ol>"},{"location":"frontend/react/testing/codereport/bugs/debouncing/#when-to-use-debouncing","title":"When to Use Debouncing?","text":"<ol> <li> <p>Search Inputs: When implementing search functionality with real-time suggestions, debouncing can prevent excessive querying of a backend server as users type.</p> </li> <li> <p>Window Resizing: If you have functionality that adjusts based on the window size, debouncing can help avoid multiple calls to resize handlers while the user is actively resizing the window.</p> </li> <li> <p>Scroll Events: Debouncing is useful for handling scroll events, especially if you have features that trigger actions based on scrolling.</p> </li> <li> <p>Form Validation: In forms where validation occurs as the user types, debouncing can prevent constant validation checks on every keystroke.</p> </li> </ol>"},{"location":"frontend/react/testing/codereport/bugs/debouncing/#example","title":"Example","text":"<p>How to Implement Debouncing</p> <p>Here\u2019s a basic example of how to implement debouncing in JavaScript:</p> <pre><code>function debounce(func, delay) {\n    let timeoutId;\n    return function(...args) {\n        clearTimeout(timeoutId);\n        timeoutId = setTimeout(() =&gt; func.apply(this, args), delay);\n    };\n}\n\n// Usage example:\nfunction search(query) {\n    console.log('Searching for:', query);\n}\n\nconst debouncedSearch = debounce(search, 300);\n\n// Attach debouncedSearch to an input event\ndocument.getElementById('searchInput').addEventListener('input', (event) =&gt; {\n    debouncedSearch(event.target.value);\n});\n</code></pre> <p>In this example:</p> <ul> <li><code>debounce</code> is a higher-order function that takes a function <code>func</code> and a delay in milliseconds.</li> <li>It returns a new function that, when invoked, clears the previous timeout and sets a new one. If the function is invoked again within the delay period, the previous timeout is cleared and a new one is set.</li> <li><code>debouncedSearch</code> is a debounced version of the <code>search</code> function, which will only be called 300 milliseconds after the user stops typing.</li> </ul> <p>By using debouncing, you ensure that <code>search</code> is not called too frequently and is executed only after the user has paused their input.</p>"},{"location":"frontend/react/testing/codereport/bugs/debouncing/#react","title":"React","text":"<p>What is Debouncing?</p> <p>Debouncing is a technique to limit how often a function is called. It makes sure that the function is only executed after a certain amount of time has passed since the last call. This is useful in scenarios where a function might be called repeatedly in a short period of time.</p> <p>When to Use Debounce in React</p> Use Debounce WhenDon\u2019t Use Debounce When <ol> <li> <p>User Input: If you have a search input field that triggers an API call or filtering every time the user types.</p> <ul> <li>Why? To avoid making an API call for every keystroke, which could overwhelm the server and slow down the app.</li> </ul> </li> <li> <p>Window Resize: If you have functionality that reacts to window resizing, like adjusting layout or reloading data.</p> <ul> <li>Why? To prevent excessive calls while the user is actively resizing the window.</li> </ul> </li> <li> <p>Scroll Events: If you\u2019re implementing infinite scrolling or tracking scroll position.</p> <ul> <li>Why? To limit how often you perform actions based on the scroll position, improving performance.</li> </ul> </li> </ol> <ol> <li> <p>Instant Feedback: If the action needs to happen immediately without delay, such as a submit button.</p> <ul> <li>Why? Debouncing would introduce a delay, which might not be suitable for actions requiring immediate response.</li> </ul> </li> <li> <p>Non-Frequent Actions: If the function is not triggered frequently or doesn\u2019t affect performance significantly.</p> <ul> <li>Why? Debouncing is unnecessary for actions that don\u2019t occur often or are already well-managed.</li> </ul> </li> </ol> <p>Simple Example with lodash</p> InstallImplementationExplanation <pre><code>npm install lodash\n</code></pre> <p>Here\u2019s a basic React component with a debounced search input:</p> <pre><code>import React, { useState, useCallback } from 'react';\nimport debounce from 'lodash/debounce';\n\nconst SearchComponent = () =&gt; {\n    const [query, setQuery] = useState('');\n    const [results, setResults] = useState([]);\n\n    // Create a debounced function for searching\n    const debouncedSearch = useCallback(\n        debounce(async (searchTerm) =&gt; {\n            if (searchTerm) {\n                try {\n                    const response = await fetch(`https://api.example.com/search?q=${searchTerm}`);\n                    const data = await response.json();\n                    setResults(data);\n                } catch (error) {\n                    console.error('Error fetching data:', error);\n                }\n            } else {\n                setResults([]);\n            }\n        }, 300), // Debounce with a 300ms delay\n        []\n    );\n\n    // Call the debounced search function whenever the query changes\n    const handleChange = (event) =&gt; {\n        const newQuery = event.target.value;\n        setQuery(newQuery);\n        debouncedSearch(newQuery);\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;input\n                type=\"text\"\n                value={query}\n                onChange={handleChange}\n                placeholder=\"Search...\"\n            /&gt;\n            &lt;ul&gt;\n                {results.map((result, index) =&gt; (\n                    &lt;li key={index}&gt;{result.name}&lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default SearchComponent;\n</code></pre> <ul> <li> <p>State Variables: <code>query</code> holds the current search input, and <code>results</code> holds the search results.</p> </li> <li> <p>Debounce Function: <code>debouncedSearch</code> is created using <code>lodash</code>'s <code>debounce</code>. It\u2019s called with a 300ms delay, meaning it waits 300ms after the last change before making an API request.</p> </li> <li> <p>Handle Input Change: When the input changes, <code>handleChange</code> updates <code>query</code> and calls the debounced function. The debounced function will only trigger the API call 300ms after the user stops typing.</p> </li> <li> <p>Display Results: The results from the API call are displayed in a list.</p> </li> </ul> Summary <ul> <li>Use Debounce: When you want to limit the frequency of function calls, especially with user input or events that can fire rapidly.</li> <li>Don\u2019t Use Debounce: When immediate action is required or the function is not called frequently enough to benefit from debouncing.</li> </ul> <p>Using lodash for debouncing simplifies this process and ensures efficient performance.</p> COdeExplanation <pre><code>import React, { useCallback, useState } from 'react';\nimport debounce from 'lodash/debounce';\nimport { useDispatch } from 'react-redux'; // or wherever your dispatch is from\n\n// Example of the component\nconst MyComponent = () =&gt; {\n    const [selectedAttendees, setSelectedAttendees] = useState([]);\n    const [hasSelectedAttentionTos, setHasSelectedAttentionTos] = useState(false);\n    const dispatch = useDispatch(); // Assuming you are using Redux for state management\n\n    // Define the debounced version of your dispatch function\n    const debouncedDispatch = useCallback(\n        debounce((selectedPersonIds, selectedCompanyId) =&gt; {\n            dispatch(getCompanyorPersonEmailAddess(selectedPersonIds, selectedCompanyId));\n        }, 300), // Adjust the debounce delay as needed (300ms here)\n        [dispatch]\n    );\n\n    // The handleSelectChange function\n    const handleSelectChange = (values, options) =&gt; {\n        const selectedData = options.map((option) =&gt; ({\n            AttentionTo: option.props.children,\n            AttentionId: option.key,\n        }));\n\n        let selectedPersonIds = selectedData.map((item) =&gt; ({\n            contactPersonIds: item.AttentionId,\n        }));\n\n        setSelectedAttendees(selectedData);\n        setHasSelectedAttentionTos(!isEmpty(values));\n\n        // Call the debounced dispatch function\n        debouncedDispatch(selectedPersonIds, selectedCompanyId);\n    };\n\n    // Your component render logic here\n    return (\n        &lt;div&gt;\n            {/* Render your component here */}\n        &lt;/div&gt;\n    );\n};\n\nexport default MyComponent;\n</code></pre> <ol> <li> <p>Install and Import <code>debounce</code>: Import <code>debounce</code> from <code>lodash</code>.</p> </li> <li> <p>Create a Debounced Dispatch Function:</p> <ul> <li>Use <code>useCallback</code> to memoize the debounced function so that it doesn't get recreated on every render.</li> <li>The <code>debouncedDispatch</code> function is created using <code>debounce</code>. It wraps the dispatch call and delays its execution until after 300 milliseconds have passed since the last call. You can adjust this delay as needed.</li> </ul> </li> <li> <p>Update <code>handleSelectChange</code>:</p> <ul> <li>Inside <code>handleSelectChange</code>, instead of calling <code>dispatch</code> directly, call debouncedDispatch with the necessary parameters.</li> <li><code>debouncedDispatch</code> will now ensure that the <code>dispatch</code> function is only called after the specified delay, which prevents it from being called too frequently if <code>handleSelectChange</code> is triggered multiple times in quick succession.</li> </ul> </li> <li> <p>Include Dependencies:</p> <p>Make sure to include <code>dispatch</code> as a dependency in <code>useCallback</code> so that the debounced function is recreated if <code>dispatch</code> changes.</p> </li> </ol> <p>This approach will help you manage performance and reduce the number of times <code>dispatch</code> is called, especially if <code>handleSelectChange</code> is triggered frequently.</p>"},{"location":"frontend/react/testing/codereport/bugs/intro/","title":"Intro","text":""},{"location":"frontend/react/testing/codereport/bugs/intro/#dashboard-module","title":"Dashboard Module:","text":"Warning: Invalid DOM property <code>class</code>. Did you mean <code>className</code>? Solution <p>search gloal with <code>class=\"</code> and replace with className.</p> Warning: Each child in a list should have a unique \"key\" prop. IssueSolution <p>`PublicEvents.js:183``</p> <pre><code>{data?.length &gt; 0 ? (\n    data?.map((list, i) =&gt; (\n        &lt;&gt;\n            {list.event !== \"day\" ? (\n                &lt;li\n                    key={i}\n                    className=\"dashboards__events--list\"\n                    style={{ padding: \"0px\" }}\n                &gt;&lt;/li&gt;\n            ) : null }\n        &lt;/&gt;\n    )) : null)\n}\n</code></pre> <p>use unique <code>id</code> instead of <code>index</code>.</p> <pre><code>{data?.length &gt; 0 ? (\n    data?.map((list, i) =&gt; (\n        &lt;&gt;\n            {list.event !== \"day\" ? (\n                &lt;li\n                    key={i}\n                    className=\"dashboards__events--list\"\n                    style={{ padding: \"0px\" }}\n                &gt;&lt;/li&gt;\n            ) : null }\n        &lt;/&gt;\n    )) : null)\n}\n</code></pre> Warning: Each child in a list should have a unique \"key\" prop. <pre><code>children HonorRollPagiantion.js:153\nHonorRollPagination HonorRollPagiantion.js:139\n</code></pre> IssueSolved <pre><code>HonorRollPagiantion.js\n\n&lt;div\n    className=\"honor__card--circle\"\n\n    // ISSUE HERE\n    key={i}\n&gt;\n</code></pre> <pre><code>&lt;Carousel autoplay={true} dots={false}&gt;\n    {list?.honorRollCandidateDtos?.map(\n    (picture, i) =&gt; {\n        let name = picture?.candidateName;\n        let profilePicNameFL = name\n        ?.match(/\\b(\\w)/g)\n        .join(\"\");\n\n        return (\n        &lt;&gt;\n            &lt;div\n            className=\"honor__card--circle\"\n            key={i}\n            &gt;\n            {!isEmpty(\n                picture.candiateProfilePictureURL\n            ) ? (\n                &lt;img\n                src={\n                    cqBaseUrl +\n                    \"/\" +\n                    picture.candiateProfilePictureURL +\n                    token\n                }\n                alt=\"profile\"\n                /&gt;\n            ) : (\n                &lt;div\n                className=\"default-profile-name\"\n                style={{\n                    width: \"52px\",\n                    height: \"52px\",\n                }}\n                key={i}\n                &gt;\n                {profilePicNameFL}\n                &lt;/div&gt;\n            )}\n            &lt;/div&gt;\n        &lt;/&gt;\n        )\n    })\n    }\n&lt;/Carousel&gt;\n</code></pre> <p>updated the <code>key={i}</code> to <code>key={picture?.id}</code></p> <pre><code>&lt;&gt;\n    &lt;div\n    className=\"honor__card--circle\"\n    key={picture?.id}\n    &gt;\n    {!isEmpty(\n        picture.candiateProfilePictureURL\n    ) ? (\n        &lt;img\n        src={\n            cqBaseUrl +\n            \"/\" +\n            picture.candiateProfilePictureURL +\n            token\n        }\n        alt=\"profile\"\n        /&gt;\n    ) : (\n        &lt;div\n        className=\"default-profile-name\"\n        style={{\n            width: \"52px\",\n            height: \"52px\",\n        }}\n        key={picture?.id}\n        &gt;\n        {profilePicNameFL}\n        &lt;/div&gt;\n    )}\n    &lt;/div&gt;\n&lt;/&gt;\n</code></pre>"},{"location":"frontend/react/testing/codereport/bugs/intro/#mail-module","title":"Mail Module","text":"<p>Warning: Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application.</p> BugSolution ReplyChatBox.js<pre><code>// pg: 192\nuseEffect(() =&gt; {\n    fetchAllParticipants();\n}, []);\n\n// pg: 281\nconst fetchAllParticipants = async () =&gt; {\n    const resp = await getAllUsers().catch((err) =&gt; {\n        message.error(\"Failure\");\n    });\n\n    if (resp &amp;&amp; resp.status === 200) {\n        let participantFrom = storage.getItem(\"userId\");\n        let allUsers = resp.data.filter(\n            (obj) =&gt; obj.appUserId == participantFrom\n        );\n\n        setUsers(allUsers);\n    }\n};\n</code></pre> ReplyChatBox.js<pre><code>useEffect(() =&gt; {\n    // fetchAllParticipants();\n    let isMounted = true; // Flag to track component mount status\n\n    const fetchAllParticipants = async () =&gt; {\n        try {\n            const resp = await getAllUsers();\n\n            if (isMounted &amp;&amp; resp &amp;&amp; resp.status === 200) {\n                let participantFrom = storage.getItem(\"userId\");\n                let allUsers = resp.data.filter(\n                    (obj) =&gt; obj.appUserId == participantFrom\n                );\n                setUsers(allUsers);\n            }\n        } catch (err) {\n            message.error(\"Failure\");\n        }\n    };\n\n    fetchAllParticipants();\n\n    return () =&gt; {\n        isMounted = false; // Cleanup function to update the flag on unmount\n    };\n}, []);\n</code></pre>"},{"location":"frontend/react/testing/codereport/bugs/master-topic/","title":"master topic","text":"<p>To fully master React and build robust, maintainable applications, you'll want to familiarize yourself with a variety of techniques, patterns, and libraries. Here\u2019s a comprehensive guide to what you should know:</p>"},{"location":"frontend/react/testing/codereport/bugs/master-topic/#techniques","title":"Techniques","text":"<ol> <li> <p>Component-Based Architecture:</p> <ul> <li>Understand: How to build reusable and composable components.</li> <li>Key Concepts: Props, state, lifecycle methods, hooks.</li> </ul> </li> <li> <p>State Management:</p> <ul> <li>Local State: Use <code>useState</code> and <code>useReducer</code>.</li> <li>Global State: Understand Context API and third-party libraries like Redux or Zustand.</li> </ul> </li> <li> <p>Effect Management:</p> <ul> <li>Understand: Side effects in components using <code>useEffect</code>.</li> <li>Best Practices: Cleanup functions, dependencies.</li> </ul> </li> <li> <p>Performance Optimization:</p> <ul> <li>Techniques: Memoization with <code>useMemo</code> and <code>useCallback</code>, code splitting, lazy loading components with <code>React.lazy</code> and <code>Suspense</code>.</li> <li>Tools: React Profiler, performance monitoring tools.</li> </ul> </li> <li> <p>Form Handling:</p> <ul> <li>Understand: Controlled vs. uncontrolled components.</li> <li>Libraries: React Hook Form, Formik.</li> </ul> </li> <li> <p>Routing:</p> <ul> <li>Library: React Router.</li> <li>Concepts: Dynamic routing, nested routes, route guards.</li> </ul> </li> <li> <p>Error Handling:</p> <ul> <li>Technique: Error boundaries to catch JavaScript errors anywhere in the component tree.</li> <li>Best Practices: Display user-friendly error messages.</li> </ul> </li> <li> <p>Testing:</p> <ul> <li>Tools: Jest for unit testing, React Testing Library for component testing.</li> <li>Concepts: Mocking, snapshot testing.</li> </ul> </li> <li> <p>Styling:</p> <ul> <li>Options: CSS-in-JS libraries (styled-components, Emotion), CSS modules, and traditional CSS/Sass.</li> </ul> </li> <li> <p>Server-Side Rendering (SSR) and Static Site Generation (SSG):</p> <ul> <li>Frameworks: Next.js for SSR and SSG.</li> <li>Concepts: Benefits of SSR, SSG vs. CSR (Client-Side Rendering).</li> </ul> </li> <li> <p>Internationalization (i18n):</p> <ul> <li>Library: react-i18next for localization.</li> </ul> </li> <li> <p>Accessibility:</p> <ul> <li>Best Practices: Use semantic HTML, ARIA attributes, and tools like Lighthouse.</li> </ul> </li> </ol>"},{"location":"frontend/react/testing/codereport/bugs/master-topic/#patterns","title":"Patterns","text":"<ol> <li> <p>Functional vs. Class Components:</p> <ul> <li>Understand: Differences and when to use each.</li> </ul> </li> <li> <p>Higher-Order Components (HOCs):</p> <ul> <li>Concept: A pattern for reusing component logic.</li> </ul> </li> <li> <p>Render Props:</p> <ul> <li>Concept: A pattern for sharing code between components using a function that returns a React element.</li> </ul> </li> <li> <p>Custom Hooks:</p> <ul> <li>Concept: Encapsulate reusable logic into custom hooks.</li> </ul> </li> <li> <p>Context API for Dependency Injection:</p> <ul> <li>Concept: Provide and consume context to avoid prop drilling.</li> </ul> </li> <li> <p>Controlled and Uncontrolled Components:</p> <ul> <li>Concept: Managing form inputs and state.</li> </ul> </li> <li> <p>Compound Components:</p> <ul> <li>Concept: Design components that work together and share implicit state.</li> </ul> </li> <li> <p>Function-as-Child (Render Props):</p> <ul> <li>Concept: Sharing component logic with a function that provides children.</li> </ul> </li> </ol>"},{"location":"frontend/react/testing/codereport/bugs/master-topic/#libraries-and-tools","title":"Libraries and Tools","text":"<ol> <li> <p>State Management Libraries:</p> <ul> <li>Redux: For complex state management.</li> <li>Zustand: Lightweight state management.</li> <li>Recoil: For managing state with atoms and selectors.</li> </ul> </li> <li> <p>Data Fetching Libraries:</p> <ul> <li>Axios: For HTTP requests.</li> <li>React Query: For server-state management and data fetching.</li> </ul> </li> <li> <p>Routing Libraries:</p> <ul> <li>React Router: For client-side routing.</li> </ul> </li> <li> <p>Styling Libraries:</p> <ul> <li>styled-components: For CSS-in-JS styling.</li> <li>Emotion: Another CSS-in-JS library.</li> </ul> </li> <li> <p>Form Handling Libraries:</p> <ul> <li>React Hook Form: Simplifies form handling and validation.</li> <li>Formik: Another popular form management library.</li> </ul> </li> <li> <p>Testing Libraries:</p> <ul> <li>Jest: For unit testing.</li> <li>React Testing Library: For testing React components.</li> </ul> </li> <li> <p>Development Tools:</p> <ul> <li>ESLint: For code quality and consistency.</li> <li>Prettier: For code formatting.</li> </ul> </li> <li> <p>Build Tools:</p> <ul> <li>Webpack: For module bundling.</li> <li>Vite: A modern build tool that provides fast development server and optimized builds.</li> </ul> </li> <li> <p>Server-Side Frameworks:</p> <ul> <li>Next.js: For SSR and static site generation.</li> </ul> </li> <li> <p>Internationalization Libraries:</p> <ul> <li>react-i18next: For managing translations.</li> </ul> </li> <li> <p>Accessibility Tools:</p> <ul> <li>React Axe: For accessibility auditing.</li> </ul> </li> <li> <p>GraphQL Libraries:</p> <ul> <li>Apollo Client: For managing GraphQL data.</li> </ul> </li> </ol>"},{"location":"frontend/react/testing/codereport/bugs/master-topic/#summary","title":"Summary","text":"<ul> <li>Master React Basics: Components, state, props, hooks.</li> <li>Adopt Advanced Patterns: HOCs, render props, custom hooks.</li> <li>Optimize Performance: Memoization, code splitting, lazy loading.</li> <li>Use Libraries Wisely: State management (Redux, Zustand), data fetching (React Query), styling (styled-components), routing (React Router).</li> <li>Test Your Code: With Jest and React Testing Library.</li> <li>Handle Forms and Internationalization: With React Hook Form or Formik, and react-i18next.</li> <li>Stay Updated: With new React features and best practices.</li> </ul> <p>By understanding and applying these techniques, patterns, and libraries, you'll be well-equipped to build robust, efficient, and maintainable React applications.</p>"},{"location":"frontend/react/testing/codereport/bugs/solution/","title":"Solution","text":""},{"location":"frontend/react/testing/codereport/bugs/solution/#dashboard-module","title":"Dashboard Module","text":""},{"location":"frontend/react/testing/codereport/bugs/solution/#each-child-in-a-list-should-have-a-unique-key-prop","title":"Each child in a list should have a unique \"key\" prop","text":"Warning: Each child in a list should have a unique \"key\" prop. <p>Check the render method of <code>PublicEvents</code>. See https://reactjs.org/link/warning-keys for more information. PublicEvents@http://localhost:3000/static/js/main.chunk.js:218280:7</p> <p><code>PublicEvents.js:183</code></p> SourceSolutionTheory <pre><code># PublicEvents.js\n# page number : 189\n</code></pre> PublicEvents.js<pre><code>    &lt;&gt;\n        {data?.length &gt; 0 ? (\n          data?.map((list, i) =&gt; (\n            &lt;&gt;\n              {list.event !== \"day\" ? (\n                &lt;li\n                  key={i}\n                  className=\"dashboards__events--list\"\n                  style={{ padding: \"0px\" }}\n                &gt;\n                  &lt;div\n                    className={`dashboards__events--listTitle ${list?.event} `}\n                    style={{ flex: 6 }}\n                  &gt;\n                    &lt;span\n                      style={{ width: \"20px\", display: \"inline-block\" }}\n                    &gt;\n                      {i + 1}.\n                    &lt;/span&gt;\n\n                    {/* COMMENT */} \n                )})))}\n</code></pre> <pre><code>{data?.length &gt; 0 ? (\n    data.map((list, index) =&gt; (\n        &lt;li key={index}&gt;{list.name}&lt;/li&gt; // Using the index as a fallback\n    ))\n) : null}\n</code></pre> <p>Key changes:</p> <ul> <li>Used <code>list.id</code> as the key prop: React expects each item in a list to have a unique key for efficient rendering. Using list.id ensures that React can uniquely identify each item.</li> <li>Avoided using i (the index) as the key: Using the index as a key can lead to issues when items in the list are reordered or when items are added/removed, causing incorrect re-rendering.</li> </ul> <p>If list.id is guaranteed to be unique, this should fix the warning you're seeing.</p>"},{"location":"frontend/react/testing/codereport/bugs/solution/#problem-title","title":"Problem Title","text":"<p>Problem Title: React List Rendering Warning: \"Each child in a list should have a unique 'key' prop\"</p> Problem Explanation <p>In React, when rendering a list of elements using the <code>.map()</code> method, each element must have a unique <code>key</code> prop. This key helps React efficiently identify and manage each item in the list, especially when items are added, removed, or reordered.</p> <p>If you don\u2019t provide a unique key for each list item, or if you use an unstable key (like an index <code>i</code>), React will display a warning: \"Each child in a list should have a unique 'key' prop\".</p> Why It Happens <p>When React renders a list, it needs to know which items are which. If items change order or some are removed/added, React uses the <code>key</code> prop to track these changes. If the key isn\u2019t unique or stable, React might:</p> <ol> <li>Re-render items unnecessarily.</li> <li>Confuse one item with another, leading to incorrect behavior (e.g., losing input values in a form).</li> </ol> <p>To avoid this issue, always provide a unique identifier (such as <code>id</code> from the list object) as the <code>key</code> prop instead of using something that might change, like an array index.</p>"},{"location":"frontend/react/testing/codereport/bugs/solution/#few-strategies","title":"Few strategies","text":"<p>If you don't receive a unique ID from the API, there are a few strategies you can use to provide a stable <code>key</code> for each list item in React. Here are some common solutions:</p> <ol> <li> <p>Generate a Unique ID Locally (Using a Library)</p> <p>You can use libraries like <code>uuid</code> or <code>nanoid</code> to generate unique IDs for each item when you don't have one from the API. This is a good approach if the list doesn't change frequently or you're fine with generating new IDs on each render.</p> <p>Using <code>uuid</code>:</p> <pre><code>npm install uuid\n</code></pre> <pre><code>import { v4 as uuidv4 } from 'uuid';\n\n{data?.length &gt; 0 ? (\n    data.map((list) =&gt; (\n        &lt;li key={uuidv4()}&gt;{list.name}&lt;/li&gt; // Generate a unique key for each item\n    ))\n) : null}\n</code></pre> <p>This ensures each item has a stable, unique key.</p> </li> <li> <p>Combine Multiple Properties to Form a Unique Key</p> <p>If the items have other properties that are relatively unique, you can combine those properties to create a unique key.</p> <p>For example, if you have a list of users but no unique <code>id</code>, you can combine <code>name</code> and <code>email</code> or other available fields:</p> <pre><code>{data?.length &gt; 0 ? (\n    data.map((list) =&gt; (\n        &lt;li key={`${list.name}-${list.email}`}&gt;{list.name}&lt;/li&gt; // Combine properties\n    ))\n) : null}\n</code></pre> <p>This method works as long as the combination of properties guarantees uniqueness.</p> </li> <li> <p>Use the Index with Caution</p> <p>If none of the above options are available and the list is static (i.e., the order of the items doesn't change, and items are never added/removed), you can use the index as the key temporarily:</p> <pre><code>{data?.length &gt; 0 ? (\n    data.map((list, index) =&gt; (\n        &lt;li key={index}&gt;{list.name}&lt;/li&gt; // Using the index as a fallback\n    ))\n) : null}\n</code></pre> <p>However, using the index as a key is not ideal for dynamic lists, because:</p> <ul> <li>If the list changes (items are reordered, added, or removed), React can misidentify the items.</li> <li>Component states could get mixed up when using the index.</li> </ul> </li> </ol> Summary <ul> <li>Best Practice: Use a unique <code>id</code> if available.</li> <li>Fallback Options: Generate unique IDs locally, combine fields to create a unique key, or cautiously use the index if the list doesn't change frequently.</li> </ul>"},{"location":"frontend/react/testing/codereport/bugs/solution/#best-choice","title":"Best choice","text":"<p>The best choice depends on the specific use case, but generally speaking:</p> <ol> <li> <p>Use a Unique ID from the Data (Best Option)</p> <p>If the API provides a unique <code>id</code> (like a database <code>id</code>, <code>uuid</code>, etc.), this is always the best option. It ensures stability and guarantees uniqueness even when the list changes (items added, removed, or reordered).</p> </li> <li> <p>Generate a Unique ID Locally (Good Alternative)</p> <p>If the API doesn\u2019t provide a unique <code>id</code>, generating a unique ID using a library like <code>uuid</code> or <code>nanoid</code> is the next best option. This approach creates a stable unique key for each item.</p> <ul> <li>Why it's good: Each key is truly unique and doesn\u2019t depend on changing data.</li> <li>When to use: When the list items are dynamic, and you need stable keys even after re-renders.</li> </ul> </li> <li> <p>Combine Properties to Form a Key (Depends on Uniqueness)</p> <p>If there are certain properties that can be combined to create a unique value (like combining <code>name</code> and <code>email</code>), this is a valid approach. However, this method only works if the combination is guaranteed to be unique across all items.</p> <ul> <li>Why it's good: It avoids adding external dependencies.</li> <li>When to use: If the list contains objects with multiple consistent properties, but no single unique identifier.</li> </ul> </li> <li> <p>Use the Index (Last Resort)</p> <p>Using the array index (<code>i</code>) as the key should be the last resort and only in very specific cases where:</p> <ul> <li>The list won\u2019t change (no new items added, no reordering).</li> <li> <p>It\u2019s acceptable to lose performance and stability benefits.</p> </li> <li> <p>Why it's risky: Keys based on the index can lead to incorrect updates when items are added, removed, or reordered.</p> </li> </ul> </li> </ol> Best Choice Recommendation <ol> <li>Unique ID from API (best).</li> <li>Generated unique ID using libraries like <code>uuid</code>.</li> <li>Combine properties (if you can guarantee uniqueness).</li> <li>Index as key (last resort, use with caution).</li> </ol> <p>In general, using a unique identifier from the data or generating a unique key locally is the most stable and reliable approach for React's list rendering.</p>"},{"location":"frontend/react/topic/abort-controller-solved/","title":"Abort Controller Solved","text":""},{"location":"frontend/react/topic/abort-controller-solved/#solution","title":"Solution","text":"<p>how to solve the fetching data in the react 18 inside useEffect</p> <p>Fetching data inside a <code>useEffect</code> hook in React 18 is similar to how it\u2019s done in previous versions, but you need to handle some additional considerations due to changes and improvements in React 18, particularly with Strict Mode.</p> <p>Here\u2019s a step-by-step guide to handling data fetching inside <code>useEffect</code> effectively:</p> <ol> <li> <p>Basic Data Fetching with <code>useEffect</code></p> <p>Here\u2019s a simple example of how to fetch data in useEffect:</p> CodeFull Code <pre><code>useEffect(() =&gt; {\n    const fetchData = async () =&gt; {\n        try {\n            const response = await fetch('https://api.example.com/data');\n            if (!response.ok) {\n                throw new Error('Network response was not ok');\n            }\n            const result = await response.json();\n            setData(result);\n        } catch (error) {\n            setError(error.message);\n        } finally {\n            setLoading(false);\n        }\n    };\n\n    fetchData();\n\n    return () =&gt; {\n        // Optional: You can clean up here if needed\n    };\n}, []); \n</code></pre> <pre><code>import React, { useState, useEffect } from 'react';\n\nfunction App() {\n    const [data, setData] = useState(null);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n\n    useEffect(() =&gt; {\n        // Define an async function inside useEffect\n        const fetchData = async () =&gt; {\n            try {\n                const response = await fetch('https://api.example.com/data');\n                if (!response.ok) {\n                    throw new Error('Network response was not ok');\n                }\n                const result = await response.json();\n                setData(result);\n            } catch (error) {\n                setError(error.message);\n            } finally {\n                setLoading(false);\n            }\n        };\n\n        fetchData();\n\n        // Cleanup function to run when the component unmounts\n        return () =&gt; {\n            // Optional: You can clean up here if needed\n        };\n    }, []); // Empty dependency array means this effect runs once when the component mounts\n\n    // Render the component UI based on the state\n    if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;\n    if (!data) return &lt;div&gt;No data found&lt;/div&gt;;\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Data:&lt;/h1&gt;\n            &lt;pre&gt;{JSON.stringify(data, null, 2)}&lt;/pre&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default App;\n</code></pre> </li> <li> <p>Handling Component Unmounts</p> <p>React\u2019s Strict Mode might cause components to mount and unmount multiple times during development to help identify potential issues. To handle this, you should ensure that your data fetching logic can gracefully handle unmounting:</p> <ul> <li><code>AbortController</code>: This is a good way to cancel ongoing network requests if the component unmounts.</li> </ul> CodeExample <pre><code>useEffect(() =&gt; {\n    const controller = new AbortController(); // Create a new AbortController\n    const { signal } = controller;\n\n    const fetchData = async () =&gt; {\n        try {\n            const response = await fetch('https://api.example.com/data', { signal });\n            if (!response.ok) {\n                throw new Error('Network response was not ok');\n            }\n            const result = await response.json();\n            setData(result);\n        } catch (error) {\n            if (error.name !== 'AbortError') { // Ignore AbortError errors\n                setError(error.message);\n            }\n        } finally {\n            setLoading(false);\n        }\n    };\n\n    fetchData();\n\n    // Cleanup function\n    return () =&gt; {\n        controller.abort(); // Abort the fetch request when component unmounts\n    };\n}, []);\n</code></pre> <p>Here\u2019s how you can use <code>AbortController</code>:</p> <pre><code>import React, { useState, useEffect } from 'react';\n\nfunction App() {\n    const [data, setData] = useState(null);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n\n    useEffect(() =&gt; {\n        const controller = new AbortController(); // Create a new AbortController\n        const { signal } = controller;\n\n        const fetchData = async () =&gt; {\n            try {\n                const response = await fetch('https://api.example.com/data', { signal });\n                if (!response.ok) {\n                    throw new Error('Network response was not ok');\n                }\n                const result = await response.json();\n                setData(result);\n            } catch (error) {\n                if (error.name !== 'AbortError') { // Ignore AbortError errors\n                    setError(error.message);\n                }\n            } finally {\n                setLoading(false);\n            }\n        };\n\n        fetchData();\n\n        // Cleanup function\n        return () =&gt; {\n            controller.abort(); // Abort the fetch request when component unmounts\n        };\n    }, []); // Empty dependency array means this effect runs once when the component mounts\n\n    // Render the component UI based on the state\n    if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;\n    if (!data) return &lt;div&gt;No data found&lt;/div&gt;;\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Data:&lt;/h1&gt;\n            &lt;pre&gt;{JSON.stringify(data, null, 2)}&lt;/pre&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default App;\n</code></pre> </li> <li> <p>Understanding Strict Mode Behavior</p> <p>React 18 Strict Mode is designed to help you find problems in your components by intentionally running certain lifecycle methods twice. Here\u2019s what you should know:</p> <ul> <li> <p>Development Only: Strict Mode\u2019s double-mount behavior happens only in development mode and not in production.</p> </li> <li> <p>Focus on Cleanup: Ensure that any side effects (like data fetching) are properly cleaned up in the cleanup function of <code>useEffect</code>.</p> </li> </ul> </li> </ol> Summary <ul> <li>Data Fetching: Use an async function inside <code>useEffect</code> to handle data fetching.</li> <li>Abort Requests: Use <code>AbortController</code> to cancel requests if the component unmounts.</li> <li>Strict Mode: React\u2019s Strict Mode may cause double mounting in development, so handle cleanup properly to avoid issues.</li> </ul> <p>By following these practices, you can ensure that your data fetching logic works correctly and efficiently in React 18, even with Strict Mode\u2019s additional checks.</p>"},{"location":"frontend/react/topic/abort-controller-solved/#updated-example","title":"Updated Example","text":"<p>In React's Strict Mode, components can be intentionally rendered twice to help identify potential side effects and ensure that your components are resilient to such situations. This double-rendering happens in development mode only, not in production.</p> <p>In your <code>fetchData</code> function, you've used an <code>AbortController</code> to manage the fetch request and handle the cancellation of the request if the component unmounts or if the <code>useEffect</code> cleanup function is called. This is an effective way to prevent updates to unmounted components and avoid potential memory leaks.</p> ExplanationUpdatedUseEffect and Cleanup <p>Here's a breakdown of why your <code>catch</code> block works correctly in Strict Mode:</p> <ol> <li> <p>AbortController and Cleanup:</p> <ul> <li><code>AbortController</code> is used to cancel the fetch request if the component unmounts or if the <code>useEffect</code> cleanup function is triggered.</li> <li>When <code>controller.abort()</code> is called, the fetch request is aborted, and an <code>AbortError</code> is thrown. 0   The <code>catch</code> block in your <code>fetchData</code> function handles this <code>AbortError</code> and ignores it, so it doesn't interfere with the component's state updates.</li> </ul> </li> <li> <p>Strict Mode Behavior:</p> <ul> <li>Strict Mode causes your component to render twice in development mode to help identify side effects. This means that <code>fetchData</code> may be called twice, and both calls would receive the same <code>signal</code> from the <code>AbortController</code>.</li> <li>When the component is unmounted or cleaned up, <code>controller.abort()</code> will be called, leading to an <code>AbortError</code>. The <code>catch</code> block will then handle this error by checking its name.</li> </ul> </li> <li> <p>Handling <code>AbortError</code>:</p> <ul> <li>You correctly handle <code>AbortError</code> by checking <code>error.name !== 'AbortError'</code>. This ensures that the <code>AbortError</code> is ignored and does not set the error state (<code>setError</code>).</li> <li>For other types of errors (e.g., network errors), you set the error state (<code>setError(error.message)</code>), which allows you to handle and display those errors appropriately.</li> </ul> </li> </ol> <p>Here\u2019s your <code>fetchData</code> function with comments explaining each part:</p> <pre><code>const fetchData = async (url, apiKey, signal) =&gt; {\n    try {\n        const response = await fetch(url, {\n            method: 'GET',\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Bearer ${apiKey}`, // Include the API key if needed\n            },\n            signal, // Pass the signal to abort the request if needed\n        });\n\n        if (!response.ok) {\n            throw new Error('Network response was not ok');\n        }\n        const data = await response.json();\n        setData(data); // Update state with fetched data\n    } catch (error) {\n        // Handle errors except for AbortError\n        if (error.name !== 'AbortError') {\n            setError(error.message); // Update state with the error message\n        }\n    } finally {\n        setLoading(false); // Ensure loading state is updated\n    }\n};\n</code></pre> <p>The <code>useEffect</code> ensures that the fetch operation is properly cleaned up when the component unmounts:</p> <pre><code>useEffect(() =&gt; {\n    const API_URL = process.env.REACT_APP_API_URL;\n    const API_KEY = process.env.REACT_APP_API_KEY;\n\n    const controller = new AbortController();\n    const signal = controller.signal;\n\n    fetchData(API_URL, API_KEY, signal);\n\n    return () =&gt; {\n        controller.abort(); // Abort the fetch request when the component unmounts\n    };\n}, []); // Empty dependency array ensures this effect runs only once\n</code></pre> <p>In summary, your approach is correct. The <code>AbortError</code> is handled gracefully, ensuring that it doesn\u2019t interfere with other potential errors and allows for clean-up and proper handling in Strict Mode.</p>"},{"location":"frontend/react/topic/abort-controller-solved/#improvement","title":"Improvement","text":"<p>Yes, the approach you've taken is generally good for production, but there are a few considerations to ensure that it remains robust and optimized:</p> Production ReadinessEnhanced <code>fetchData</code>Example of <code>useEffect</code> <p>Key Points for Production Readiness</p> <ol> <li> <p>AbortController:</p> <p>Using <code>AbortController</code> is a good practice to avoid potential memory leaks and update attempts on unmounted components. It ensures that the fetch request is properly canceled if the component is unmounted or if the request is no longer needed.</p> </li> <li> <p>Error Handling:</p> <p>Handling <code>AbortError</code> gracefully is important. Ignoring <code>AbortError</code> ensures that your error handling only focuses on actual issues with the network request, rather than interruptions you expect and handle.</p> </li> <li> <p>Environment Variables:</p> <p>Make sure your environment variables (<code>REACT_APP_API_URL</code> and <code>REACT_APP_API_KEY</code>) are correctly set in your production environment and are secure. Avoid exposing sensitive information directly in your client-side code.</p> </li> <li> <p>Performance:</p> <p>While the double rendering in React's Strict Mode is only in development, you should ensure that your <code>useEffect</code> and state management are efficient. Avoid unnecessary state updates and ensure that your fetch logic is optimized.</p> </li> <li> <p>Error Reporting:</p> <p>For production, consider implementing a more robust error logging and reporting mechanism. Libraries like Sentry or LogRocket can help track and report errors that occur in your production environment.</p> </li> <li> <p>API Key Management:</p> <p>If you\u2019re using an API key, consider using environment variables or a secure method to manage it. Exposing API keys in the client code is generally not recommended, as it can lead to security vulnerabilities. Instead, consider server-side handling of sensitive information where possible.</p> </li> <li> <p>Loading State:</p> <p>Ensure that the loading state (<code>setLoading(false)</code>) is managed correctly to provide feedback to users while data is being fetched. This helps improve user experience.</p> </li> </ol> <p>Example of an Enhanced <code>fetchData</code></p> <p>Here\u2019s an enhanced version of your <code>fetchData</code> function with additional comments and considerations:</p> <pre><code>const fetchData = async (url, apiKey, signal) =&gt; {\n    try {\n        // Prepare the request headers\n        const headers = {\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer ${apiKey}`, // Include the API key if needed\n        };\n\n        // Perform the fetch request\n        const response = await fetch(url, { method: 'GET', headers, signal });\n\n        // Check if the response was successful\n        if (!response.ok) {\n            throw new Error(`Network response was not ok: ${response.statusText}`);\n        }\n\n        // Parse the JSON data from the response\n        const data = await response.json();\n        setData(data); // Update state with fetched data\n\n    } catch (error) {\n        // Handle errors except for AbortError\n        if (error.name !== 'AbortError') {\n            setError(error.message); // Update state with the error message\n            console.error('Fetch error:', error); // Log the error for debugging\n        }\n    } finally {\n        setLoading(false); // Ensure loading state is updated\n    }\n};\n</code></pre> <p>Here\u2019s a more complete example of how you might use <code>fetchData</code> in a <code>useEffect</code>:</p> <pre><code>useEffect(() =&gt; {\n    const API_URL = process.env.REACT_APP_API_URL;\n    const API_KEY = process.env.REACT_APP_API_KEY;\n\n    // Ensure API_URL and API_KEY are defined\n    if (!API_URL || !API_KEY) {\n        console.error('API_URL or API_KEY is not defined');\n        return;\n    }\n\n    const controller = new AbortController();\n    const signal = controller.signal;\n\n    fetchData(API_URL, API_KEY, signal);\n\n    return () =&gt; {\n        controller.abort(); // Abort the fetch request when the component unmounts\n    };\n}, []); // Empty dependency array ensures this effect runs only once\n</code></pre> <p>Conclusion</p> <p>Your approach is solid for production with the current implementation. Ensure to follow best practices for error handling, performance optimization, and secure management of sensitive data. With these considerations, your data fetching and component management should be effective and reliable in a production environment.</p>"},{"location":"frontend/react/topic/cleanup/","title":"Cleanup","text":""},{"location":"frontend/react/topic/cleanup/#what-is-cleanup","title":"What is Cleanup?","text":"<p>Cleanup is a way of making sure that when a component is removed from the screen (unmounted), any ongoing operations or resources it was using are properly cleaned up to avoid problems like memory leaks or unexpected behavior.</p>"},{"location":"frontend/react/topic/cleanup/#when-do-you-need-cleanup","title":"When Do You Need Cleanup?","text":"<p>Here are some broad categories and everyday examples to help illustrate:</p>"},{"location":"frontend/react/topic/cleanup/#1-ongoing-operations","title":"1.  Ongoing Operations","text":"<ul> <li>Example: You have a timer that does something every few seconds (like a clock or a poller).</li> <li>Why Cleanup: If the component using the timer gets removed, you don\u2019t want that timer still running in the background. It could keep trying to update a component that no longer exists, which could lead to errors or waste resources.</li> </ul> <pre><code>useEffect(() =&gt; {\n    const intervalId = setInterval(() =&gt; {\n        console.log('Tick');\n    }, 1000);\n\n    // Cleanup\n    return () =&gt; clearInterval(intervalId);\n}, []);\n</code></pre>"},{"location":"frontend/react/topic/cleanup/#2-asynchronous-requests","title":"2. Asynchronous Requests","text":"<ul> <li>Example: You\u2019re making a network request to fetch data from a server.</li> <li>Why Cleanup: If the request takes time and the component gets removed before it finishes, you might try to update a component that no longer exists, which can cause errors. Cleanup ensures you stop the request if it\u2019s no longer needed.</li> </ul> <pre><code>useEffect(() =&gt; {\n    const controller = new AbortController();\n    fetch('https://api.example.com/data', { signal: controller.signal })\n        .then(response =&gt; response.json())\n        .then(data =&gt; {\n            // Handle data\n        });\n\n    // Cleanup\n    return () =&gt; controller.abort();\n}, []);\n</code></pre>"},{"location":"frontend/react/topic/cleanup/#3-subscriptions","title":"3. Subscriptions","text":"<ul> <li>Example: You\u2019re listening to a data stream or a real-time event (like a WebSocket connection).</li> <li>Why Cleanup: If you\u2019re listening to events and the component is removed, you should stop listening to avoid unnecessary network usage or errors.</li> </ul> <pre><code>useEffect(() =&gt; {\n    const socket = new WebSocket('ws://example.com');\n    socket.onmessage = (event) =&gt; {\n        console.log('Message:', event.data);\n    };\n\n    // Cleanup\n    return () =&gt; socket.close();\n}, []);\n</code></pre>"},{"location":"frontend/react/topic/cleanup/#4-event-listeners","title":"4. Event Listeners","text":"<ul> <li>Example: You\u2019re adding a listener to the <code>window</code> to detect when the user resizes the browser.</li> <li>Why Cleanup: If the component is removed, the event listener should be removed to avoid potential memory leaks or errors.</li> </ul> <pre><code>useEffect(() =&gt; {\n    const handleResize = () =&gt; {\n        console.log('Window resized');\n    };\n\n    window.addEventListener('resize', handleResize);\n\n    // Cleanup\n    return () =&gt; window.removeEventListener('resize', handleResize);\n}, []);\n</code></pre>"},{"location":"frontend/react/topic/cleanup/#general-rule-for-cleanup","title":"General Rule for Cleanup","text":"<p>If your component does something that might continue after it\u2019s removed from the screen (like running timers, making network requests, listening to events), you should provide a cleanup function to stop or undo that activity.</p>"},{"location":"frontend/react/topic/cleanup/#why-cleanup-is-important","title":"Why Cleanup is Important","text":"<ul> <li>Prevents Memory Leaks: If you don\u2019t clean up resources, they might keep using memory even after the component is gone.</li> <li>Avoids Errors: Ensures that your app doesn\u2019t try to update or interact with components that no longer exist.</li> <li>Improves Performance: Frees up resources when they\u2019re no longer needed, leading to better performance.</li> </ul> <p>In summary, cleanup in React is about making sure your components are good neighbors\u2014tidying up after themselves so they don\u2019t leave messes behind when they\u2019re done.</p>"},{"location":"frontend/react/topic/cleanup/#block-or-concise-body-in-return","title":"Block or Concise Body in <code>return</code>","text":"<p>Both of these syntax options for cleanup functions in React's <code>useEffect</code> hook are functionally equivalent, but they have subtle differences in style and readability. Let\u2019s break down each option and discuss when to use each:</p>"},{"location":"frontend/react/topic/cleanup/#1-using-a-block-body","title":"1. Using a Block Body:","text":"Basic ExampleCharacteristicsWhen to Use <pre><code>return () =&gt; {\n    controller.abort();\n};\n</code></pre> <ul> <li>Block Body: The <code>return</code> statement uses a block body <code>{}</code> which allows for multiple statements inside the cleanup function.</li> <li>Readability: This syntax can be more readable and flexible when the cleanup function needs to perform multiple actions or when additional logic is needed.</li> </ul> <ul> <li>Multiple Statements: Use this syntax if your cleanup function involves multiple operations. For example, you might need to abort a fetch request and also remove event listeners or perform other cleanup tasks.</li> </ul> <pre><code>return () =&gt; {\n    controller.abort();\n    console.log('Cleanup complete');\n    // Additional cleanup tasks\n};\n</code></pre> <ul> <li>Complex Logic: When you need to include more complex logic or conditions within the cleanup function, a block body is preferable for clarity.</li> </ul>"},{"location":"frontend/react/topic/cleanup/#2-using-a-concise-body","title":"2. Using a Concise Body:","text":"Basic ExampleCharacteristicsWhen to Use <pre><code>return () =&gt; controller.abort();\n</code></pre> <ul> <li>Concise Body: The <code>return</code> statement uses a single expression without a block body. It\u2019s often more compact and concise.</li> <li>Readability: This syntax is clear and succinct when the cleanup function only needs to execute a single line of code.</li> </ul> <ul> <li>Single Statement: Use this syntax when the cleanup function consists of a single operation. It\u2019s a more streamlined approach for simple cleanup tasks.</li> </ul>"},{"location":"frontend/react/topic/cleanup/#example-usage","title":"Example Usage","text":"<p>Single Statement Cleanup: If you only need to abort a fetch request, the concise body is sufficient and keeps your code clean.</p> <pre><code>useEffect(() =&gt; {\n    const controller = new AbortController();\n\n    fetch('https://api.example.com/data', { signal: controller.signal })\n        .then(response =&gt; response.json())\n        .then(data =&gt; {\n            // Handle data\n        });\n\n    return () =&gt; controller.abort();\n}, []);\n</code></pre> <p>Multiple Statements Cleanup: If you need to perform several cleanup actions, the block body is more appropriate.</p> BasicAdvanced <pre><code>useEffect(() =&gt; {\n    const controller = new AbortController();\n\n    fetch('https://api.example.com/data', { signal: controller.signal })\n        .then(response =&gt; response.json())\n        .then(data =&gt; {\n            // Handle data\n        });\n\n    return () =&gt; {\n        controller.abort();\n        console.log('Fetch aborted and cleanup complete');\n        // Additional cleanup tasks if needed\n    };\n}, []);\n</code></pre> <pre><code>useEffect(() =&gt; {\n    // Establishing a WebSocket connection\n    const socket = new WebSocket('ws://example.com/chat');\n\n    // Function to handle incoming messages\n    const handleMessage = (event) =&gt; {\n        console.log('Message received:', event.data);\n    };\n\n    // Function to handle window resize events\n    const handleResize = () =&gt; {\n        console.log('Window resized');\n    };\n\n    // Adding event listeners\n    window.addEventListener('resize', handleResize);\n    socket.addEventListener('message', handleMessage);\n\n    // Cleanup function\n    return () =&gt; {\n        // Close WebSocket connection\n        socket.close();\n        console.log('WebSocket connection closed');\n\n        // Remove event listeners\n        window.removeEventListener('resize', handleResize);\n        socket.removeEventListener('message', handleMessage);\n        console.log('Event listeners removed');\n    };\n}, []);\n</code></pre>"},{"location":"frontend/react/topic/cleanup/#summary","title":"Summary","text":"<ul> <li> <p>Use a Block Body when you need to perform multiple cleanup actions or when including additional logic is necessary. It\u2019s more versatile and readable for complex cleanup scenarios.</p> </li> <li> <p>Use a Concise Body for simple cleanup tasks that involve only a single action. It\u2019s more succinct and keeps your code neat for straightforward scenarios.</p> </li> </ul> <p>Both approaches are valid and serve different needs based on the complexity of your cleanup logic. Choose the one that best fits the task at hand and improves code readability and maintainability.</p>"},{"location":"frontend/react/topic/code-for-change/","title":"Code For Change","text":""},{"location":"frontend/react/topic/code-for-change/#question","title":"Question","text":"How to: api, reducer, action <pre><code>src\n    services\n        redux\n            groupchat\n                action.js\n                reducer.js\n                api.js\n            contact\n                action.js\n                reducer.js\n                api.js\n        store\n            middlewares\n                app.js\n            index.js\n            StoreProvider.js\n    common.js\n    commonService.js\n    remanentCalls.js\n    types.js\n</code></pre> APIAction api<pre><code>import queryString from \"query-string\";\nimport { appBaseUrl } from \"utils/config\";\nimport { getService, postService, putService } from \"../../commonServices\";\n\nexport class FingerPrintService {\n    addFingerPrint(q) {\n        let query = queryString.stringify(q);\n        let url = `${appBaseUrl}/attendance/allFingerPrintDataByDateRangeAdd?${query}`;\n        // local\n        // let url = `http://localhost:7143/FingerPrintData/GetRevisedFingerPrintDataByDateRange?${query}`;\n        let data = postService(url);\n        return data;\n    }\n}\n</code></pre> action.js<pre><code>import  { FINGER_PRINT_TYPES } from '../../types';\nimport { init, success, finish, error } from 'services/common';\nimport { message } from 'antd';\nimport { FingerPrintService } from \"./api\"\n\nconst fingerPrintService = new FingerPrintService();\n\nexport const fingerPrintAdd = (body) =&gt; {\n    return async(dispatch) =&gt; {\n        dispatch(init(FINGER_PRINT_TYPES.CREATE_FINGER_PRINT));\n        const resp = await fingerPrintService.addFingerPrint(body);\n        dispatch(finish(FINGER_PRINT_TYPES.CREATE_FINGER_PRINT));\n        if(resp.isSuccess) {\n            dispatch(success(FINGER_PRINT_TYPES.CREATE_FINGER_PRINT, resp.data))\n            message.success(\"Data pull successfully\")\n        } else if(!resp.isSuccess) {\n            dispatch(error(resp.errorMessage))\n        }\n\n    }\n} \n</code></pre> Redux Folder Structure Example 1. Basic Structure2. Intermediate Structure3. Advanced Structure <p>For a small to medium-sized application, you might keep things straightforward:</p> <pre><code>src/\n|-- components/\n|-- pages/\n|-- redux/\n|   |-- actions/\n|   |   |-- exampleActions.js\n|   |-- reducers/\n|   |   |-- exampleReducer.js\n|   |-- store.js\n|-- App.js\n|-- index.js\n</code></pre> <p>Description:</p> <ul> <li>actions/: Contains action creators.</li> <li>reducers/: Contains reducer functions.</li> <li>store.js: Configures and exports the Redux store.</li> </ul> store.js<pre><code>import { createStore, combineReducers } from 'redux';\nimport exampleReducer from './reducers/exampleReducer';\n\nconst rootReducer = combineReducers({\n    example: exampleReducer,\n});\n\nconst store = createStore(rootReducer);\n\nexport default store;\n</code></pre> <p>As your application grows, you might want to organize things a bit more and introduce concepts like feature modules:</p> <pre><code>src/\n|-- components/\n|-- pages/\n|-- redux/\n|   |-- feature1/\n|   |   |-- actions.js\n|   |   |-- reducer.js\n|   |   |-- types.js\n|   |-- feature2/\n|   |   |-- actions.js\n|   |   |-- reducer.js\n|   |   |-- types.js\n|   |-- store.js\n|-- App.js\n|-- index.js\n</code></pre> <p>Description:</p> <ul> <li>feature1/ and feature2/: Feature-specific folders that include actions, reducers, and types (action type constants).</li> <li>types.js: Contains action type constants to avoid typos and make actions easier to manage.</li> </ul> feature1/actions.jsfeature1/reducer.jsstore.js actions.js<pre><code>import { FEATURE1_ACTION } from './types';\n\nexport const feature1Action = (payload) =&gt; ({\n    type: FEATURE1_ACTION,\n    payload,\n});\n</code></pre> reducer.js<pre><code>import { FEATURE1_ACTION } from './types';\nconst initialState = {};\n\nconst feature1Reducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case FEATURE1_ACTION:\n        return { ...state, ...action.payload };\n        default:\n        return state;\n    }\n};\n\nexport default feature1Reducer;\n</code></pre> <pre><code>import { createStore, combineReducers } from 'redux';\nimport feature1Reducer from './feature1/reducer';\nimport feature2Reducer from './feature2/reducer';\n\nconst rootReducer = combineReducers({\n    feature1: feature1Reducer,\n    feature2: feature2Reducer,\n});\n\nconst store = createStore(rootReducer);\n\nexport default store;\n</code></pre> <p>For larger applications, a more scalable and maintainable structure is often needed. This includes organizing by feature and separating concerns:</p> <pre><code>src/\n|-- components/\n|-- pages/\n|-- redux/\n|   |-- features/\n|   |   |-- feature1/\n|   |   |   |-- actions.js\n|   |   |   |-- reducer.js\n|   |   |   |-- selectors.js\n|   |   |   |-- types.js\n|   |   |-- feature2/\n|   |   |   |-- actions.js\n|   |   |   |-- reducer.js\n|   |   |   |-- selectors.js\n|   |   |   |-- types.js\n|   |-- rootReducer.js\n|   |-- store.js\n|   |-- thunks/\n|   |   |-- feature1Thunks.js\n|   |   |-- feature2Thunks.js\n|-- App.js\n|-- index.js\n</code></pre> <p>Description:</p> <ul> <li>features/: Organizes Redux code by feature or domain.</li> <li>selectors.js: Contains selector functions to derive data from the state.</li> <li>rootReducer.js: Combines all reducers into a single root reducer.</li> <li>thunks/: Contains asynchronous action creators (thunks) if using Redux Thunk for async operations.</li> </ul> selectors.jsactions.jsreducer.js javascript<pre><code>// features/feature1/selectors.js\n\nexport const getFeature1Data = (state) =&gt; state.feature1.data;\n</code></pre> javascript<pre><code>// features/feature1/actions.js\n\nimport { FEATURE1_ACTION } from './types';\n\nexport const feature1Action = (payload) =&gt; ({\n    type: FEATURE1_ACTION,\n    payload,\n});\n</code></pre> javascript<pre><code>// features/feature1/reducer.js\n\nimport { FEATURE1_ACTION } from './types';\n\nconst initialState = { data: [] };\n\nconst feature1Reducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case FEATURE1_ACTION:\n            return { ...state, data: action.payload };\n        default:\n            return state;\n    }\n};\n\nexport default feature1Reducer;\n</code></pre> <p>Types</p> <pre><code>// feature1/types.js\nexport const FEATURE1_ACTION = 'FEATURE1_ACTION';\nexport const FEATURE1_LOAD_REQUEST = 'FEATURE1_LOAD_REQUEST';\nexport const FEATURE1_LOAD_SUCCESS = 'FEATURE1_LOAD_SUCCESS';\nexport const FEATURE1_LOAD_FAILURE = 'FEATURE1_LOAD_FAILURE';\n</code></pre> <p>Reducer</p> rootReducer.jsstore.js <pre><code>import { combineReducers } from 'redux';\nimport feature1Reducer from './features/feature1/reducer';\nimport feature2Reducer from './features/feature2/reducer';\n\nconst rootReducer = combineReducers({\n    feature1: feature1Reducer,\n    feature2: feature2Reducer,\n});\n\nexport default rootReducer;\n</code></pre> <pre><code>import { createStore, applyMiddleware } from 'redux';\nimport rootReducer from './rootReducer';\nimport thunk from 'redux-thunk';\n\nconst store = createStore(rootReducer, applyMiddleware(thunk));\n\nexport default store;\n</code></pre> <p>This advanced structure helps in managing larger codebases by organizing Redux logic more effectively and separating concerns for better maintainability and scalability.</p> To determine if a React application is using Redux Thunk or Redux Saga middleware <p>To determine if a React application is using Redux Thunk or Redux Saga middleware, you can follow these steps:</p> <p>1. Check the Redux Store Configuration</p> <p>The most direct way to find out which middleware is being used is to examine the store configuration. The store is usually set up in a file like <code>store.js</code> or <code>configureStore.js</code>. For Redux Thunk:</p> <p>In the store configuration, look for <code>applyMiddleware</code> and see if <code>thunk</code> is being used:</p> <p>For Redux Thunk:</p> <p>In the store configuration, look for applyMiddleware and see if thunk is being used:</p> javascript<pre><code>// store.js or configureStore.js\nimport { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk'; // Import thunk middleware\nimport rootReducer from './rootReducer';\n\nconst store = createStore(\n    rootReducer,\n    applyMiddleware(thunk) // Apply thunk middleware\n);\n\nexport default store;\n</code></pre> <p>If you see <code>thunk</code> being imported and used with <code>applyMiddleware</code>, then Redux Thunk is being used.</p> <p>For Redux Saga:</p> <p>If Redux Saga is being used, the store configuration will include <code>redux-saga</code> and <code>sagaMiddleware</code>:</p> javascript<pre><code>// store.js or configureStore.js\nimport { createStore, applyMiddleware } from 'redux';\nimport createSagaMiddleware from 'redux-saga'; // Import saga middleware\nimport rootReducer from './rootReducer';\nimport rootSaga from './sagas'; // Import root saga\n\nconst sagaMiddleware = createSagaMiddleware(); // Create saga middleware\n\nconst store = createStore(\n    rootReducer,\n    applyMiddleware(sagaMiddleware) // Apply saga middleware\n);\n\nsagaMiddleware.run(rootSaga); // Run the root saga\n\nexport default store;\n</code></pre> <p>In this case, you\u2019ll find <code>createSagaMiddleware</code> and <code>sagaMiddleware.run(rootSaga)</code> in the store configuration.</p> <p>2. Check Dependencies in package.json</p> <p>Look at the <code>dependencies</code> or <code>devDependencies</code> in your <code>package.json</code> file.</p> <p>For Redux Thunk:</p> <p>You will see <code>redux-thunk</code> listed:</p> json<pre><code>\"dependencies\": {\n    \"redux-thunk\": \"^2.3.0\"\n}\n</code></pre> <p>For Redux Saga:</p> <p>You will see redux-saga listed:</p> json<pre><code>\"dependencies\": {\n    \"redux-saga\": \"^1.1.3\"\n}\n</code></pre> <p>3. Search the Codebase</p> <p>You can perform a search in your codebase to see if any <code>thunk</code> or <code>saga</code> related code is present:</p> <ul> <li>Search for <code>thunk</code>: Look for <code>import thunk from 'redux-thunk' or applyMiddleware(thunk)</code>.</li> <li>Search for <code>saga</code>: Look for <code>import createSagaMiddleware from 'redux-saga', sagaMiddleware.run</code>, or <code>import { call, put } from 'redux-saga/effects'</code>.</li> </ul> <p>4. Inspect Middleware in DevTools</p> <p>If you are using Redux DevTools, you can inspect the middleware in your application:</p> <ol> <li>Open Redux DevTools in your browser.</li> <li>Look at the middleware section or check the logs to see which middleware is being applied.</li> </ol> <p>Summary</p> <ol> <li>Check Store Configuration: Look at the <code>applyMiddleware</code> in the store setup.</li> <li>Check package.json: See which middleware libraries are listed in dependencies.</li> <li>Search Codebase: Look for imports and usage related to <code>redux-thunk</code> or <code>redux-saga</code>.</li> <li>Inspect DevTools: Use Redux DevTools to examine applied middleware.</li> </ol> <p>By using these methods, you can determine whether your React application is utilizing Redux Thunk or Redux Saga middleware.</p>"},{"location":"frontend/react/topic/code-for-change/#code-for-change-cfc","title":"Code For Change (CFC)","text":""},{"location":"frontend/react/topic/code-for-change/#redux","title":"REDUX","text":"Improved Error Handling and Asynchronous Code Management in Redux-Thunk with React Component Integration Old CodeNew CodeKey Differences Explained Action Creator:<pre><code>export const actionForGroupChatTitleAdd = (body) =&gt; {\n    return async(dispatch) =&gt; {\n        dispatch(init(GROUPCHAT_TYPES.CREATE_GROUPCHAT_TITLE));\n        const resp = await groupChatService.apiForGroupChatTitleAdd(body);\n        if(resp.isSuccess) {\n            dispatch(success(GROUPCHAT_TYPES.CREATE_GROUPCHAT_TITLE, resp.data))\n            message.success(\"Newly added Group Chat\")\n        } else if(!resp.isSuccess) {\n            dispatch(error(resp.errorMessage))\n        }\n        dispatch(finish(GROUPCHAT_TYPES.CREATE_GROUPCHAT_TITLE));\n    }\n}\n</code></pre> Component:<pre><code>const onFinish = (values) =&gt; {\n    let errorReq = {\n        \"chatGroupName\": \"ICTC \",\n        \"referenceId\": \"f9f8bf40-067e-42aa-8538-e9d4dbd8e2fe\"\n    };\n\n    // dispatch(actionForGroupChatTitleAdd(values));\n    dispatch(actionForGroupChatTitleAdd(errorReq))\n        .then(() =&gt; {\n            console.log(\"Successfully added group chat title\");\n            onClose();\n        })\n        .catch((error) =&gt; {\n            console.log(\"error: \", error);\n            // Do not close the drawer in case of an error\n        });\n};\n</code></pre> <p>Updated Action Creator</p> <p>Your current action creator looks good, but for better error handling, we can ensure it throws an error when the response is not successful:</p> Action Creator:<pre><code>export const actionForGroupChatTitleAdd = (body) =&gt; {\n    return async(dispatch) =&gt; {\n        dispatch(init(GROUPCHAT_TYPES.CREATE_GROUPCHAT_TITLE));\n        try {\n            const resp = await groupChatService.apiForGroupChatTitleAdd(body);\n            if(resp.isSuccess) {\n                dispatch(success(GROUPCHAT_TYPES.CREATE_GROUPCHAT_TITLE, resp.data));\n                message.success(\"Newly added Group Chat\");\n                return resp.data; // Return data for success\n            } else {\n                dispatch(error(resp.errorMessage));\n                throw new Error(resp.errorMessage); // Throw error to be caught in the component\n            }\n        } catch (err) {\n            dispatch(error(err.message || 'Unknown error occurred'));\n            throw err; // Re-throw error to be caught in the component\n        } finally {\n            dispatch(finish(GROUPCHAT_TYPES.CREATE_GROUPCHAT_TITLE));\n        }\n    }\n};\n</code></pre> <p>Component Handling the API Call</p> <p>In your component, handle the promise returned by the dispatch function to conditionally call <code>onClose</code>:</p> Component:<pre><code>const onFinish = async (values) =&gt; {\n    let errorReq = {\n        \"chatGroupName\": \"ICTC \",\n        \"referenceId\": \"f9f8bf40-067e-42aa-8538-e9d4dbd8e2fe\"\n    };\n\n    try {\n        await dispatch(actionForGroupChatTitleAdd(errorReq));\n        console.log(\"Successfully added group chat title\");\n        onClose();\n    } catch (error) {\n        console.log(\"error: \", error);\n        message.error(\"Failed to add group chat title\");\n        // Drawer remains open\n    }\n};\n</code></pre> Explanation <p>Action Creator:</p> <ul> <li>If the API response is successful, it dispatches the <code>success</code> action and returns the response data.</li> <li>If the API response is not successful, it dispatches the <code>error</code> action and throws an error to be caught by the calling component.</li> <li>Errors caught within the <code>try</code> block are dispatched as errors and re-thrown to be handled by the component.</li> </ul> <p>Component:</p> <ul> <li>The <code>onFinish</code> function is modified to use <code>async/await</code> for handling the dispatch.</li> <li>On success (<code>await dispatch(actionForGroupChatTitleAdd(errorReq));</code>), it logs the success message and calls onClose() to close the drawer.</li> <li>On error (<code>catch</code> block), it logs the error and displays an error message using <code>message.error</code>. The drawer remains open.</li> </ul> <ol> <li> <p>Error Handling in Action Creator:</p> <p>Original Code:</p> <ul> <li>The action creator does not throw an error when the response is unsuccessful. It only dispatches the error message.</li> <li>This means the component cannot directly catch errors thrown by the action creator.</li> </ul> <p>Updated Code:</p> <ul> <li>The action creator explicitly throws an error when the response is unsuccessful. This allows the component to catch and handle the error.</li> <li>It uses a try-catch block to handle both the API call and any unexpected errors, re-throwing them to be caught in the component.</li> </ul> </li> <li> <p>Promise Handling in Component:</p> <p>Original Code:</p> <ul> <li>Uses <code>.then()</code> and <code>.catch()</code> to handle the promise returned by the action creator.</li> <li>If an error occurs, it is logged, but the drawer remains open because <code>onClose()</code> is not called in the <code>catch</code> block.</li> </ul> <p>Updated Code:</p> <ul> <li>Uses <code>async/await</code> syntax for better readability and error handling.</li> <li>The <code>try-catch</code> block allows for more straightforward handling of success and error cases.</li> <li>On success, it logs a message and calls <code>onClose()</code> to close the drawer.</li> <li>On error, it logs the error, displays an error message using <code>message.error</code>, and ensures the drawer remains open.</li> </ul> </li> </ol> <p>Summary</p> <p>The updated code improves error handling and readability:</p> <p>Action Creator:</p> <ul> <li>Handles both success and error cases explicitly.</li> <li>Throws errors to be caught by the component, ensuring better error propagation.</li> </ul> <p>Component:</p> <ul> <li>Uses <code>async/await</code> for cleaner, more readable asynchronous code.</li> <li>Handles success and error cases more clearly with a <code>try-catch</code> block.</li> <li>Ensures the drawer only closes on a successful API call, keeping it open on error.</li> </ul> <p>By documenting these changes, you can ensure a clear understanding of the improvements made and the rationale behind them.</p>"},{"location":"frontend/react/topic/code-for-change/#redux-middleware","title":"Redux Middleware","text":"which redux middleware is more advance thunk or saga? <p>Both Redux Thunk and Redux Saga are popular middleware options for managing side effects in a Redux application, but they have different approaches and capabilities. Here\u2019s a comparison to help you determine which might be more advanced or suitable for your needs:</p> Redux ThunkRedux Saga <p>Advantages:</p> <ul> <li>Simplicity: Thunks are functions that can be dispatched like normal actions, making them simple to understand and implement.</li> <li>Familiarity: It feels similar to regular JavaScript, especially for handling asynchronous logic using promises or async/await.</li> <li>Learning Curve: It has a lower learning curve compared to Redux Saga.</li> </ul> <p>Disadvantages:</p> <ul> <li>Readability: As applications grow, complex async flows can become harder to manage and read.</li> <li>Error Handling: Handling complex error scenarios can be cumbersome.</li> </ul> <p>Advantages:</p> <ul> <li>Advanced Control: Provides more powerful control over complex async flows using generators, making it easier to manage and test.</li> <li>Concurrency: Better at handling concurrent actions and coordinating complex async processes.</li> <li>Testability: Sagas are more straightforward to test due to their generator-based nature.</li> <li>Composability: Easier to compose multiple sagas to work together and handle more advanced patterns like race conditions or parallel execution.</li> </ul> <p>Disadvantages:</p> <ul> <li>Complexity: Has a steeper learning curve due to the use of ES6 generators and more advanced patterns.</li> <li>Boilerplate: Can introduce more boilerplate code compared to Thunk.</li> </ul> <p>Conclusion</p> <p>When to Use Redux Thunk:</p> <ul> <li>For simpler applications or those just starting with Redux.</li> <li>When you need straightforward async logic handling.</li> <li>If you want a lower learning curve and less boilerplate.</li> </ul> <p>When to Use Redux Saga:</p> <ul> <li>For larger applications with complex async needs.</li> <li>When you need advanced control over side effects and better testability.</li> <li>If you are comfortable with generators and more complex patterns.</li> </ul> <p>Overall, Redux Saga is generally considered more advanced due to its powerful capabilities and fine-grained control over side effects. However, it also comes with more complexity, so the choice between Thunk and Saga should be based on your specific application needs and your team's familiarity with these tools.</p>"},{"location":"frontend/react/topic/code-for-change/#which-one-to-use","title":"Which one to use","text":"Which One to Master First: Thunk or Saga? <p>Start with Redux Thunk:</p> <ul> <li>Simplicity: Thunk is simpler and easier to grasp, making it a good starting point for understanding how to manage side effects in Redux.</li> <li>Foundational Knowledge: Learning Thunk first provides a solid foundation in handling asynchronous actions, which is beneficial before tackling the more advanced concepts in Redux Saga.</li> </ul> How to Master Redux ThunkHow to Master Redux Saga <ol> <li> <p>Understand the Basics:</p> <ul> <li>Learn how to create and dispatch actions in Redux.</li> <li>Understand synchronous vs. asynchronous actions.</li> </ul> </li> <li> <p>Set Up Redux Thunk:</p> <ul> <li>Integrate Redux Thunk into your Redux store configuration.</li> </ul> </li> <li> <p>Create Thunk Actions:</p> <ul> <li>Write action creators that return functions instead of plain objects.</li> <li>Use <code>dispatch</code> and <code>getState</code> inside these functions to manage async operations.</li> </ul> </li> <li> <p>Handle Asynchronous Logic:</p> <ul> <li>Use promises or async/await within Thunk actions to perform API calls or other async tasks.</li> <li>Manage loading states and error handling within Thunk actions.</li> </ul> </li> <li> <p>Read Documentation and Tutorials:</p> <ul> <li>Follow the Redux Thunk documentation.</li> <li>Explore tutorials and examples on managing async actions with Thunk.</li> </ul> </li> <li> <p>Build Projects:</p> <ul> <li>Apply your knowledge in real projects to gain practical experience.</li> <li>Refactor existing Redux code to use Thunk for async actions.</li> </ul> </li> </ol> <ol> <li> <p>Understand ES6 Generators:</p> <ul> <li>Familiarize yourself with ES6 generator functions, as they are fundamental to Redux Saga.</li> <li>Practice using <code>yield</code>, <code>next()</code>, and generator control flow.</li> </ul> </li> <li> <p>Learn Redux Saga Basics:</p> <ul> <li>Understand the core concepts of Redux Saga, including sagas, effects, watchers, and workers.</li> </ul> </li> <li> <p>Set Up Redux Saga:</p> <ul> <li>Integrate Redux Saga into your Redux store configuration.</li> </ul> </li> <li> <p>Create Simple Sagas:</p> <ul> <li>Write sagas to handle asynchronous actions using <code>takeEvery</code>, <code>takeLatest</code>, and <code>call</code>.</li> <li>Learn to manage side effects like API calls, delays, and parallel execution.</li> </ul> </li> <li> <p>Handle Complex Scenarios:</p> <ul> <li>Use advanced patterns like <code>race</code>, <code>all</code>, and <code>cancellation</code> to manage complex async flows.</li> <li>Handle concurrency and manage multiple sagas.</li> </ul> </li> <li> <p>Read Documentation and Tutorials:</p> <ul> <li>Follow the Redux Saga documentation.</li> <li>Explore tutorials and examples to understand advanced use cases.</li> </ul> </li> <li> <p>Build Projects:</p> <ul> <li>Apply Redux Saga in real projects to tackle more complex async logic.</li> <li>Refactor existing Thunk code to use Redux Saga for better control and testability.</li> </ul> </li> </ol> <p>Additional Tips for Mastery</p> <ul> <li>Practice Regularly: Consistent practice and application in real projects are key to mastering both Thunk and Saga.</li> <li>Join Communities: Participate in online forums, communities, and discussions to learn from others and share your experiences.</li> <li>Keep Updated: Both Thunk and Saga are actively maintained, so keep an eye on updates and best practices by following their repositories and release notes.</li> <li>Experiment: Don't be afraid to experiment with different patterns and techniques to find what works best for your use case.</li> </ul> <p>Starting with Redux Thunk provides a solid foundation, and mastering Redux Saga will give you advanced tools for handling complex asynchronous logic in your Redux applications.</p>"},{"location":"frontend/react/topic/code-for-change/#jest","title":"Jest","text":"<p>In the context of package management, like with <code>npm</code> (Node Package Manager) for JavaScript projects, <code>--save</code> and <code>--save-dev</code> are options used during the installation of packages. Here's a simple explanation of the difference:</p> <ul> <li> <p>--save: When you install a package using --save, it means the package will be listed as a dependency in your project's <code>package.json</code> file. This indicates that your project needs this package to run properly. These dependencies are typically packages required for the application to function correctly in production.</p> </li> <li> <p>--save-dev: On the other hand, when you install a package using --save-dev, it means the package will be listed as a development dependency in your project's <code>package.json</code> file. This indicates that your project only needs this package during development, such as for testing, building, or other development-related tasks. These dependencies are typically tools or libraries used during the development process, but not necessary for the application to run in production.</p> </li> </ul> <p>So, in summary:</p> <ul> <li>Use --save for packages your project needs to run.</li> <li>Use --save-dev for packages your project needs during development but not for running the final application.</li> </ul> <ul> <li>--save <code>vs</code> --save-dev</li> <li>jest testing</li> <li>How To Structure React Projects From Beginner To Advanced</li> <li>useEffect by Example</li> </ul>"},{"location":"frontend/react/topic/code-for-change/#easy-thumbnail","title":"Easy Thumbnail","text":"<ul> <li>easy-thumbnails 2.8.5: pypi</li> <li>easy thumbnail: readthedocs</li> <li>easy thumbnail: github</li> </ul> <pre><code>from easy_thumbnails.fields import ThumbnailerImageField\n\nclass Profile(models.Model):\n    user = models.OneToOneField('auth.User')\n    photo = ThumbnailerImageField(upload_to='photos', blank=True)\n</code></pre>"},{"location":"frontend/react/topic/code-for-change/#step-1","title":"Step 1:","text":"<pre><code>Run pip install easy-thumbnails.\n</code></pre>"},{"location":"frontend/react/topic/code-for-change/#step-2","title":"Step 2:","text":"<pre><code>Add `easy_thumbnails` to your INSTALLED_APPS setting:\n\n```python\nINSTALLED_APPS = (\n    ...\n    'easy_thumbnails',\n)\n```\n</code></pre>"},{"location":"frontend/react/topic/code-for-change/#step-3","title":"Step 3:","text":"<pre><code>Run `manage.py` migrate `easy_thumbnails`\n</code></pre>"},{"location":"frontend/react/topic/react-strict-mode/","title":"Strict Mode","text":"<p>React\u2019s Strict Mode is a development tool designed to help identify potential problems in an application by intentionally invoking certain lifecycle methods and hooks more than once. It is meant to help developers catch issues early, but it does not affect production builds. Here\u2019s an explanation of what Strict Mode is, why it might cause behavior like double API calls, and when you should use it.</p>"},{"location":"frontend/react/topic/react-strict-mode/#what-is-react-strict-mode","title":"What is React Strict Mode?","text":"<p>React Strict Mode is a tool provided by React to help developers identify and fix potential problems in their applications. It does the following:</p> <ol> <li> <p>Double Invokes Certain Lifecycle Methods: In development mode, Strict Mode will intentionally invoke lifecycle methods and hooks like <code>useEffect</code> twice. This helps identify side effects that are not correctly handled, such as improper cleanup or unintended behaviors.</p> </li> <li> <p>Warns About Deprecated Features: It helps find usage of deprecated lifecycle methods and legacy APIs that might lead to bugs.</p> </li> <li> <p>Detects Unsafe Lifecycle Methods: It identifies unsafe lifecycle methods that may lead to issues in future React versions.</p> </li> </ol>"},{"location":"frontend/react/topic/react-strict-mode/#why-does-strict-mode-cause-double-api-calls","title":"Why Does Strict Mode Cause Double API Calls?","text":"<p>In development mode, React Strict Mode invokes <code>useEffect</code> twice to ensure that effects are properly <code>cleaned up</code> and that the application is resilient to unexpected behavior. This behavior is intended to catch issues related to side effects and is not present in production builds.</p> <ul> <li>Development Mode Only: The double invocation occurs only in development mode to help identify issues. It does not happen in production builds.</li> <li>Strict Mode\u2019s Purpose: This behavior helps ensure that side effects, cleanup, and other lifecycle aspects are handled correctly and can be safely cleaned up.</li> </ul>"},{"location":"frontend/react/topic/react-strict-mode/#when-and-why-to-use-strict-mode","title":"When and Why to Use Strict Mode","text":"<p>Strict Mode is used during development for several reasons:</p> <ol> <li> <p>Identify Potential Issues: It helps catch issues related to side effects, deprecated methods, and other unsafe patterns early in the development process.</p> </li> <li> <p>Improve Code Quality: It encourages developers to write code that adheres to best practices and is more robust against potential issues.</p> </li> <li> <p>Prepare for Future Versions: It helps identify code that might not be compatible with future React versions, allowing developers to update their code proactively.</p> </li> </ol>"},{"location":"frontend/react/topic/react-strict-mode/#when-to-remove-strict-mode","title":"When to Remove Strict Mode","text":"<p>Strict Mode should generally be used during development to help catch issues early. Here\u2019s when you might consider removing it:</p> <ol> <li> <p>Testing Production Behavior: To test your application\u2019s behavior as it would be in production, where Strict Mode\u2019s additional checks and double invocations are not present.</p> </li> <li> <p>Debugging Specific Issues: If you are experiencing issues like double API calls and have confirmed that they are due to Strict Mode, you might temporarily remove Strict Mode to isolate and debug the problem. However, this is only for debugging purposes; you should re-enable Strict Mode during development to benefit from its checks.</p> </li> </ol>"},{"location":"frontend/react/topic/react-strict-mode/#summary","title":"Summary","text":"<ul> <li>React Strict Mode is a development-only feature that helps identify potential issues by double-invoking certain lifecycle methods and hooks.</li> <li>In Production: Strict Mode's behavior does not affect production builds; the double invocation and additional checks are only present during development.</li> <li>Use During Development: Strict Mode is valuable during development to ensure your code adheres to best practices and to catch potential issues early.</li> <li>Remove Temporarily for Testing: If you\u2019re encountering specific issues related to Strict Mode, you can temporarily remove it to debug. However, ensure it\u2019s used during development to catch potential problems.</li> </ul> <p>In conclusion, React Strict Mode is a useful tool for improving code quality and ensuring robustness, but its effects should be understood and managed during the development phase.</p>"},{"location":"frontend/react/topic/react-strict-mode/#reference","title":"Reference","text":""},{"location":"frontend/react/topic/slides/","title":"Slides","text":""},{"location":"frontend/react/topic/slides/#presentation","title":"Presentation","text":""},{"location":"frontend/react/topic/mastering/batching-react/","title":"Batching","text":""},{"location":"frontend/react/topic/mastering/batching-react/#overview","title":"Overview","text":"<p>Understanding batching in React is important because it directly affects performance and the behavior of state updates. Here's a breakdown of what you need to understand about batching:</p>"},{"location":"frontend/react/topic/mastering/batching-react/#1-what-is-batching-in-react","title":"1. What is Batching in React?","text":"<p>Batching in React refers to the grouping of multiple state updates together so that React can process them all at once and trigger a single re-render of the component. Without batching, React would re-render after each state update, which could be inefficient, especially if many updates happen in a short period.</p>"},{"location":"frontend/react/topic/mastering/batching-react/#2-why-is-batching-important","title":"2. Why is Batching Important?","text":"<ul> <li>Performance: By grouping state updates, React avoids unnecessary re-renders, which improves performance, especially in complex components or large applications.</li> <li>Consistency: Batching ensures that all state updates happen before React re-renders the component. This ensures that the UI is updated consistently, reflecting all the changes made to the state in one go.</li> </ul>"},{"location":"frontend/react/topic/mastering/batching-react/#3-how-does-batching-work","title":"3. How Does Batching Work?","text":"<ul> <li>Synchronous Updates: In React, state updates are batched when triggered from synchronous event handlers (like <code>onClick</code>, <code>onChange</code>, etc.). This means if you call <code>setState</code> multiple times in a single function, React will batch those updates and <code>re-render only once</code>.</li> </ul> <pre><code>const handleClick = () =&gt; {\n  setCounter(counter + 1); // 1st update\n  setText(\"Hello\"); // 2nd update\n  setVisible(true); // 3rd update\n  // React batches these 3 updates and re-renders only once\n};\n</code></pre> <ul> <li> <p>Asynchronous Updates (React 18+): Starting with <code>React 18</code>, React also batches updates that occur in asynchronous operations, such as:</p> </li> <li> <p>Promises</p> </li> <li><code>setTimeout</code></li> <li><code>async</code> functions</li> </ul> <p>Before React 18, batching only worked in synchronous events. React 18 extends this feature to include async code, so multiple updates in async code also result in just one re-render.</p> Example (React 18+)<pre><code>const handleAsyncUpdate = async () =&gt; {\n  setCounter(counter + 1); // 1st update\n  await fetchData(); // Async operation\n  setText(\"Updated\"); // 2nd update after async operation\n  // React batches both updates and re-renders once\n};\n</code></pre>"},{"location":"frontend/react/topic/mastering/batching-react/#4-when-does-batching-not-happen","title":"4. When Does Batching Not Happen?","text":"<p>There are some cases where React does not batch updates:</p> <ul> <li>Outside React event handlers: If you trigger a state update outside of a React event handler (e.g., in a <code>callback</code> function from a third-party library or non-React event), React doesn't batch updates by default.</li> </ul> <pre><code>setTimeout(() =&gt; {\n  setCounter(counter + 1); // React will NOT batch this update\n  setText(\"Hello\");\n}, 1000);\n</code></pre> <p>However, starting with React 18, asynchronous updates inside <code>setTimeout</code>, <code>Promise</code>, and <code>async</code> functions are batched.</p> <ul> <li>State updates inside a loop: While React will batch state updates inside loops if those updates are in a single event handler or function, if you make asynchronous or out-of-scope updates within loops, batching may not work as expected.</li> </ul> <pre><code>for (let i = 0; i &lt; 10; i++) {\n  setState(newValue); // React batches all state updates in this loop\n}\n</code></pre>"},{"location":"frontend/react/topic/mastering/batching-react/#5-why-is-batching-important-for-performance","title":"5. Why is Batching Important for Performance?","text":"<p>Batching helps minimize the number of re-renders in your React components:</p> <ul> <li>Reducing reflows and repaints in the DOM: Every time React re-renders a component, it may cause the browser to recalculate styles, layout, and re-render parts of the page. Reducing the number of re-renders improves the app\u2019s overall speed and responsiveness.</li> <li>Fewer computational resources: By reducing unnecessary renders, you also reduce the computational resources required to update the UI.</li> </ul>"},{"location":"frontend/react/topic/mastering/batching-react/#6-how-react-18-improved-batching","title":"6. How React 18 Improved Batching:","text":"<p>Before React 18, batching was limited to synchronous code. With React 18, batching now works even in asynchronous code (such as in <code>async</code> functions, <code>promises</code>, or <code>setTimeout</code>).</p> For example, with React 18:<pre><code>const handleClick = async () =&gt; {\n  setCounter(counter + 1);\n  await someAsyncOperation(); // Async operation\n  setText(\"Updated\");\n  // React batches both updates and triggers only one re-render\n};\n</code></pre> <p>In React 18, even though <code>setCounter</code> is called before <code>await</code>, and <code>setText</code> is called <code>after</code> the async operation completes, both state updates are batched together and result in only one re-render.</p>"},{"location":"frontend/react/topic/mastering/batching-react/#7-when-should-you-worry-about-batching","title":"7. When Should You Worry About Batching?","text":"<p>In most cases, React's built-in batching will take care of performance optimizations automatically. However, if you notice performance issues, such as frequent re-renders in large applications, or if you're managing complex state updates, you might need to:</p> <ul> <li>Optimize how you structure state updates.</li> <li>Avoid unnecessary state updates inside loops or async operations that might prevent batching from working properly.</li> <li>Use <code>useCallback</code> or <code>useMemo</code> to prevent unnecessary re-renders caused by props or state changes in child components.</li> </ul>"},{"location":"frontend/react/topic/mastering/batching-react/#8-potential-pitfalls","title":"8. Potential Pitfalls:","text":"<ul> <li>Stale state in batch updates: When using batching, if you rely on the current state to compute the next state, ensure you are correctly using the functional form of <code>setState</code> to avoid stale state.</li> </ul> <pre><code>setCounter((prev) =&gt; prev + 1); // Correct: Using functional form\nsetCounter(counter + 1); // Potential issue: may use stale state\n</code></pre> <p>Summary:</p> <ul> <li>Batching is React's way of grouping multiple state updates to minimize re-renders and improve performance.</li> <li>React batches updates during synchronous event handlers and async operations (from React 18 onwards).</li> <li>Understanding when batching occurs and when it doesn't is important to ensure you're writing efficient, performant React components.</li> <li>React 18 extends batching capabilities, including asynchronous state updates, for better performance optimization in modern React apps.</li> </ul> <p>By understanding these concepts, you'll be able to write more optimized React code and handle state updates efficiently.</p>"},{"location":"frontend/react/topic/mastering/batching-stale-state/","title":"Batching Stale State","text":""},{"location":"frontend/react/topic/mastering/batching-stale-state/#overview","title":"Overview","text":"<p>The issue you're encountering, where you get <code>World World World World</code> instead of the expected string like <code>Hello World</code>, is a classic case of stale state in React when using asynchronous state updates.</p>"},{"location":"frontend/react/topic/mastering/batching-stale-state/#the-problem","title":"The Problem:","text":"<pre><code>const appendText = () =&gt; {\n  setMessage(message + \" Hello\"); // First setMessage call\n  setMessage(message + \" World\"); // Second setMessage call\n};\n</code></pre> <ul> <li>React batches the updates, meaning that both <code>setMessage</code> calls are scheduled in the same event cycle (or click event).</li> <li>Since React state updates are asynchronous and do not immediately update the state, both calls to <code>setMessage</code> use the same stale value of <code>message</code>. This happens because at the time React schedules the updates, <code>message</code> is still the initial value (e.g., an empty string <code>''</code> or the previous value from the last render).</li> </ul>"},{"location":"frontend/react/topic/mastering/batching-stale-state/#the-solution","title":"The Solution:","text":"<p>To fix this issue and ensure that each update depends on the latest value of <code>message</code>, you should use the functional form of <code>setState</code>, which takes the previous state value and ensures that each update is applied correctly in sequence.</p> Updated Code with the Functional Form:<pre><code>const appendText = () =&gt; {\n  setMessage((prevMessage) =&gt; prevMessage + \" Hello\"); // Uses the most recent `prevMessage`\n  setMessage((prevMessage) =&gt; prevMessage + \" World\"); // Also uses the most recent `prevMessage`\n};\n</code></pre>"},{"location":"frontend/react/topic/mastering/batching-stale-state/#why-this-works","title":"Why This Works:","text":"<p>By using the functional form of <code>setState</code>, each update will be based on the most recent state. React will take care of processing the updates sequentially, so each setMessage will work with the latest value of message.</p>"},{"location":"frontend/react/topic/mastering/batching-stale-state/#recap","title":"Recap:","text":"<ol> <li>Without functional form (<code>setMessage(message + ' Hello')</code>), React batches updates and uses the same stale state for all updates in quick succession.</li> <li>With functional form (<code>setMessage((prevMessage) =&gt; prevMessage + ' Hello')</code>), React ensures each update gets the latest state, avoiding the stale state issue.</li> </ol> <p>In conclusion, when updating the state based on its previous value (like appending text to a string), you should always use the functional form of <code>setState</code> to ensure you get the latest value and avoid stale state issues.</p>"},{"location":"frontend/react/topic/mastering/batching-stale-state/#why-is-the-functional-form-important-in-some-cases","title":"Why Is the Functional Form Important in Some Cases?","text":"<p>When state updates depend on the previous state, React batches updates and processes them asynchronously. If you call <code>setState</code> multiple times in quick succession without using the functional form, each update could be using the same initial state, leading to incorrect results.</p> <p>The functional form <code>(setState((prev) =&gt; prev + 1))</code> ensures that each update is based on the most recent state value, preventing stale state issues.</p> <p>Summary:</p> <ul> <li>Stale state occurs when multiple state updates happen in quick succession, and React uses the initial state for each update, rather than the most recent value.</li> <li>Always use the functional form of <code>setState</code> (e.g., <code>setCounter((prev) =&gt; prev + 1)</code>) when your state update depends on the previous state value.</li> <li>For independent state updates (when the new value doesn\u2019t depend on the previous state), you don\u2019t need the functional form.</li> </ul>"},{"location":"frontend/react/topic/mastering/batching-stale-state/#summary-of-when-to-use-the-functional-form","title":"Summary of When to Use the Functional Form","text":"<ul> <li>Arrays: Use the functional form when you're updating an array based on its previous value (e.g., adding/removing items).</li> <li>Objects: Use the functional form when you're updating an object based on its previous value (e.g., updating one property of the object).</li> <li>Strings: Use the functional form when you're updating a string based on its previous value (e.g., appending or modifying parts of the string).</li> </ul>"},{"location":"frontend/react/topic/mastering/batching-stale-state/#general-rule-of-thumb","title":"General Rule of Thumb:","text":"<ul> <li>Use the functional form of <code>setState</code> (or <code>setX</code>) whenever the new state depends on the previous state. This ensures that you always get the most up-to-date value for state.</li> <li>If you're not depending on the previous state (e.g., setting a static value), you can use the regular <code>setState</code> approach.</li> </ul> Final Example Using All Three (Array, Object, String)<pre><code>import React, { useState } from \"react\";\n\nconst StateUpdateExample = () =&gt; {\n  const [counter, setCounter] = useState(0);\n  const [items, setItems] = useState([]);\n  const [user, setUser] = useState({ name: \"John\", age: 25 });\n  const [message, setMessage] = useState(\"\");\n\n  const handleCounterIncrement = () =&gt; {\n    setCounter((prev) =&gt; prev + 1); // Correct for counter\n  };\n\n  const handleAddItem = () =&gt; {\n    setItems((prevItems) =&gt; [...prevItems, \"New Item\"]); // Correct for array\n  };\n\n  const handleUpdateUser = () =&gt; {\n    setUser((prevUser) =&gt; ({ ...prevUser, age: prevUser.age + 1 })); // Correct for object\n  };\n\n  const handleAppendMessage = () =&gt; {\n    setMessage((prevMessage) =&gt; prevMessage + \" Hello\"); // Correct for string\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Counter: {counter}&lt;/p&gt;\n      &lt;p&gt;Items: {items.join(\", \")}&lt;/p&gt;\n      &lt;p&gt;\n        Name: {user.name}, Age: {user.age}\n      &lt;/p&gt;\n      &lt;p&gt;Message: {message}&lt;/p&gt;\n      &lt;button onClick={handleCounterIncrement}&gt;Increment Counter&lt;/button&gt;\n      &lt;button onClick={handleAddItem}&gt;Add Item&lt;/button&gt;\n      &lt;button onClick={handleUpdateUser}&gt;Update User&lt;/button&gt;\n      &lt;button onClick={handleAppendMessage}&gt;Append Message&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default StateUpdateExample;\n</code></pre>"},{"location":"frontend/react/topic/mastering/batching-stale-state/#why-it-might-be-working","title":"Why It Might Be Working:","text":"<p>React 18 introduced a feature called concurrent rendering, which allows React to batch updates more intelligently and make updates feel smoother. In particular, React 18 can batch multiple state updates and render them together, avoiding unnecessary re-renders. However, concurrent rendering doesn't automatically solve the stale state issue caused by asynchronous state updates when you're using the same state variable (like <code>message</code>) in quick succession.</p> <p>Here\u2019s why it may seem to work in your case:</p> <ol> <li> <p>React 18's Automatic Batching: React 18 batches state updates automatically. This means React can delay updates to state until after the current event handler (like the click event) finishes. This doesn't eliminate stale state, but the fact that you're seeing smooth rendering could be due to React batching the updates together efficiently and handling the DOM re-renders in a way that doesn't cause noticeable lag.</p> </li> <li> <p>The Case of Single <code>setState</code> Call: If you\u2019re clicking the \"Append Text\" button only a few times, and you don't have multiple state updates in quick succession (or too many re-renders), the update to <code>message</code> will often look smooth. React might be able to re-render quickly even without the functional form in such scenarios. This is especially true when you aren't triggering multiple updates simultaneously or relying on the most recent state value (in this case, the <code>\"Hello\"</code> string you're appending).</p> </li> <li> <p>Minimal Delay: React's internal implementation, particularly with concurrent rendering, ensures that updates are processed efficiently. So, even though you are using the stale state <code>(message + ' Hello')</code>, React 18 might be handling your simple state updates efficiently enough that you don't notice a lag or stale state, especially with a relatively simple example like this.</p> </li> <li> <p>User Interaction and Timing: The problem with stale state generally arises when multiple <code>setState</code> calls happen rapidly, like in a loop or with fast user interactions. If you're only appending text to the message once per click (and not rapidly), React may successfully update the message without noticeable issues.</p> </li> </ol>"},{"location":"frontend/react/topic/mastering/batching-stale-state/#why-stale-state-can-still-be-a-concern","title":"Why Stale State Can Still Be a Concern:","text":"<ul> <li>Multiple Rapid Updates: If you clicked the button many times quickly, you might run into the stale state issue. React schedules updates asynchronously and batches them together, which can cause it to not use the latest value of <code>message</code> for each click.</li> </ul> <pre><code>const appendText = () =&gt; {\n  setMessage(message + \" Hello\"); // Multiple quick clicks might cause stale updates\n  setMessage(message + \" World\");\n};\n</code></pre> <p>In this case, even though both <code>setMessage</code> calls are triggered quickly, React may batch them together and use the stale value of <code>message</code> for both updates. So, the final value might be <code>\"HelloWorld\"</code>, even though you wanted <code>\"Hello World\"</code>.</p>"},{"location":"frontend/react/topic/mastering/batching-stale-state/#how-react-18-handles-it","title":"How React 18 Handles It:","text":"<p>React 18 introduced Concurrent Mode and the Automatic Batching of Updates (even across multiple event handlers), so React intelligently groups these updates together. This can prevent the UI from \"flickering\" or lagging, making it feel like state updates are happening faster.</p> <p>However, it does not automatically solve the stale state issue when you're relying on the previous state for an update (like <code>message + ' Hello'</code>). React still schedules updates asynchronously, and if you try to update the same state in multiple functions without the functional form, the updates could still use outdated values of the state.</p> <p>So, Why Is It Working for You Now?</p> <ol> <li>Single State Update: You're appending text once per click, and there's no rapid succession of multiple updates that might trigger the stale state issue.</li> <li>Batching and Concurrent Rendering: React 18's concurrent rendering makes updates smoother, even if the state is technically being updated asynchronously.</li> <li>No Immediate Consecutive Updates: You're not calling setMessage multiple times rapidly in a way that would highlight the stale state issue.</li> </ol>"},{"location":"frontend/react/topic/mastering/batching-stale-state/#the-best-practice-to-ensure-correctness","title":"The Best Practice to Ensure Correctness:","text":"<p>Even though your example might be working well right now, it's still best practice to use the functional form of <code>setState</code> when you're updating based on the previous state to avoid stale state issues. This will ensure that your updates work correctly in all cases (especially if state updates become more complex or rapid).</p> <pre><code>const appendText = () =&gt; {\n  setMessage((prevMessage) =&gt; prevMessage + \" Hello\"); // Always use the latest state\n};\n</code></pre> <p>Conclusion:</p> <ul> <li>React 18\u2019s concurrent rendering and automatic batching help smooth out performance and avoid visible lag, but they don\u2019t automatically resolve stale state issues in every case.</li> <li>The example seems to work fine because you\u2019re not rapidly updating the state and there's no immediate need for the latest state in the next update.</li> <li>Use the functional form of <code>setState</code> when the new state depends on the previous state to ensure correctness in all scenarios, especially when updates happen quickly or frequently.</li> </ul>"},{"location":"frontend/react/topic/mastering/component-re-rendering/","title":"Component Re-rendering Deep","text":""},{"location":"frontend/react/topic/mastering/component-re-rendering/#overview","title":"Overview","text":"<p>A deep understanding of React's rendering mechanics is crucial for optimizing performance and avoiding common pitfalls when building React applications. Here's an overview of the key concepts involved:</p>"},{"location":"frontend/react/topic/mastering/component-re-rendering/#1-virtual-dom-and-reconciliation","title":"1. Virtual DOM and Reconciliation","text":"<ul> <li> <p>Virtual DOM: React uses a Virtual DOM to optimize the process of updating the real DOM. When the state or props of a component change, React doesn\u2019t immediately change the actual DOM. Instead, it creates a virtual representation (a \"diff\") of the updated DOM, compares it with the previous one, and then updates only the parts that have changed.</p> </li> <li> <p>Reconciliation: This is the process by which React updates the DOM based on the differences between the old and new Virtual DOM. React uses an efficient algorithm called \"diffing\" to minimize the number of DOM updates.</p> </li> </ul> <p>The diffing algorithm has certain assumptions:</p> <ul> <li>It assumes components with the same type will generate the same subtree.</li> <li>It compares the component trees efficiently, only updating what is necessary, using keys in lists to optimize the process.</li> </ul>"},{"location":"frontend/react/topic/mastering/component-re-rendering/#2-component-re-renders","title":"2. Component Re-renders","text":"When Does React Re-render Components? <ul> <li>State Changes: When a component\u2019s state (<code>useState</code>) changes, React re-renders that component and its children.</li> <li>Props Changes: If a component\u2019s props change (i.e., the parent component passes new values), React will re-render that child component.</li> <li>Context Changes: If the value passed through a React Context provider changes, any components consuming that context will re-render.</li> </ul> <p>This re-rendering behavior is designed for correctness, but it can lead to performance issues if not managed properly, particularly in large applications with complex component trees.</p>"},{"location":"frontend/react/topic/mastering/component-re-rendering/#3-memoization-and-preventing-unnecessary-re-renders","title":"3. Memoization and Preventing Unnecessary Re-renders","text":"<ul> <li>Pure Components: A pure component is one that only re-renders when its props or state change. React provides <code>React.memo</code> (for functional components) and <code>PureComponent</code> (for class components) to automatically implement shallow comparison of props and prevent unnecessary re-renders.</li> </ul> <p>useMemo and useCallback Hooks:</p> <ul> <li> <p><code>useMemo</code>: Used to memoize expensive calculations and avoid recalculating them on every render.</p> </li> <li> <p><code>useCallback</code>: Used to memoize functions to ensure that functions aren't recreated on every render unless their dependencies change.</p> </li> <li> <p>Shallow Comparison: React performs a shallow comparison of props and state. If the object references remain the same, React assumes the component\u2019s data hasn\u2019t changed, and therefore, no re-render is necessary. However, this can cause issues when working with mutable objects like arrays and objects, as React might not detect changes if the reference hasn\u2019t changed.</p> </li> </ul>"},{"location":"frontend/react/topic/mastering/component-re-rendering/#4-key-prop-in-lists","title":"4. Key Prop in Lists","text":"<ul> <li>The <code>key</code> prop is essential when rendering lists in React. React uses keys to identify which items have changed, been added, or removed, which helps optimize the reconciliation process. Without proper keys, React may fail to efficiently update the list, leading to performance issues and unexpected behaviors.</li> </ul>"},{"location":"frontend/react/topic/mastering/component-re-rendering/#5-state-and-prop-updates-are-batched","title":"5. State and Prop Updates Are Batched","text":"<ul> <li> <p>Batching: React batches multiple state updates together for performance optimization. This means that when you call multiple <code>setState</code> or state-updating functions, React groups these updates and processes them in a single re-render cycle.</p> </li> <li> <p>However, state updates may still cause multiple renders if they happen in different event handlers (or in different life cycle methods for class components). React batches updates in event handlers, but not in asynchronous callbacks (e.g., <code>setTimeout</code>, <code>Promises</code>).</p> </li> </ul>"},{"location":"frontend/react/topic/mastering/component-re-rendering/#6-re-rendering-with-hooks","title":"6. Re-rendering with Hooks","text":"<ul> <li> <p>Hooks like <code>useState</code>, <code>useEffect</code>, <code>useReducer</code>, and <code>useContext</code> can cause components to re-render when state or context values change. However, React doesn\u2019t automatically re-render a component for every hook call, and this can sometimes be confusing:</p> </li> <li> <p><code>useEffect</code>: The <code>useEffect</code> hook runs after a render, and its behavior can be controlled by its dependency array. This allows for fine-grained control over when side effects are executed and can help avoid unnecessary re-renders.</p> </li> <li> <p><code>useReducer</code>: This hook can be used to manage complex state logic and helps avoid excessive re-renders by keeping state updates in a single dispatch cycle.</p> </li> </ul> <p>Understanding how each hook causes re-renders (and under what conditions) is crucial for efficient performance.</p>"},{"location":"frontend/react/topic/mastering/component-re-rendering/#7-concurrent-mode-and-suspense","title":"7. Concurrent Mode and Suspense","text":"<ul> <li> <p>Concurrent Mode is an experimental feature in React designed to make rendering more responsive by allowing React to pause work and come back to it later. This feature is particularly helpful in large applications with complex UIs, as it prevents the UI from becoming unresponsive during heavy computations.</p> </li> <li> <p>Suspense: Suspense allows React to delay rendering a part of the UI until some condition is met (e.g., waiting for data to load). It is often used with React.lazy for code-splitting, where large components are loaded only when necessary.</p> </li> </ul>"},{"location":"frontend/react/topic/mastering/component-re-rendering/#8-fiber-architecture","title":"8. Fiber Architecture","text":"<ul> <li> <p>React Fiber is the reimplementation of React's core algorithm. It enables asynchronous rendering, which allows React to pause work and come back to it later, improving the performance of complex applications.</p> </li> <li> <p>Fiber allows React to prioritize updates based on their importance. For instance, a user interaction might take priority over less critical updates (like an animation).</p> </li> </ul>"},{"location":"frontend/react/topic/mastering/component-re-rendering/#9-updating-state-in-functional-components","title":"9. Updating State in Functional Components","text":"<ul> <li>When you call <code>setState</code> (in class components) or the <code>useState</code> hook (in functional components), React schedules a re-render. However, due to batching, the state update might not be applied immediately. This can lead to unexpected results if you try to use the updated state value immediately after calling <code>setState</code>. Instead, React applies the new state in the next render cycle.</li> </ul>"},{"location":"frontend/react/topic/mastering/component-re-rendering/#10-event-handling-and-re-renders","title":"10. Event Handling and Re-renders","text":"<ul> <li>React\u2019s synthetic event system can impact re-render behavior. When an event handler is triggered, React may update the component state or props, which causes the component to re-render. It\u2019s important to understand how events work in React, and how to manage event listeners to avoid unnecessary re-renders.</li> </ul>"},{"location":"frontend/react/topic/mastering/component-re-rendering/#conclusion","title":"Conclusion","text":"<p>A deep understanding of React\u2019s rendering mechanics revolves around efficiently managing state, minimizing unnecessary re-renders, optimizing performance, and leveraging hooks and memoization techniques. By mastering these concepts, React developers can ensure their applications remain performant, even as they grow in complexity.</p>"},{"location":"frontend/react/topic/mastering/explainingothers/","title":"Explain to 5 Year","text":""},{"location":"frontend/react/topic/mastering/explainingothers/#hooks","title":"Hooks","text":""},{"location":"frontend/react/topic/mastering/explainingothers/#when-to-use-hooks","title":"When to Use Hooks","text":"<p>Hooks are a powerful feature in React that allow you to use state and other React features without writing a class. Here\u2019s when and why you should use them:</p> <ol> <li> <p>Functional Components</p> <ul> <li>When to Use: When you\u2019re building a component using a function rather than a class.</li> <li>Why: Hooks are designed to work with functional components, making them simpler and easier to manage compared to class components.</li> </ul> <pre><code>function MyComponent() {\n    const [count, setCount] = useState(0);\n\n    return (\n        &lt;div&gt;\n            &lt;p&gt;You clicked {count} times&lt;/p&gt;\n            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Click me&lt;/button&gt;\n        &lt;/div&gt;\n    );\n}\n</code></pre> </li> <li> <p>State Management</p> <ul> <li>When to Use: When you need to manage state in a functional component.</li> <li>Why: The <code>useState</code> hook lets you add state to functional components, which was previously only possible with class components.</li> </ul> <pre><code>function Counter() {\n    const [count, setCount] = useState(0);\n\n    return (\n        &lt;div&gt;\n            &lt;p&gt;Count: {count}&lt;/p&gt;\n            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;\n        &lt;/div&gt;\n    );\n}\n</code></pre> </li> <li> <p>Side Effects</p> <ul> <li>When to Use: When you need to perform side effects (like data fetching, subscriptions, or manually changing the DOM) in a functional component.</li> <li>Why: The <code>useEffect</code> hook helps you handle side effects in a way that\u2019s clean and integrated with the React lifecycle.</li> </ul> <pre><code>function DataFetcher() {\n    const [data, setData] = useState(null);\n\n    useEffect(() =&gt; {\n        fetch('https://api.example.com/data')\n            .then(response =&gt; response.json())\n            .then(data =&gt; setData(data));\n    }, []); // Empty array means this runs once when the component mounts\n\n    return &lt;div&gt;{data ? &lt;p&gt;Data: {data}&lt;/p&gt; : &lt;p&gt;Loading...&lt;/p&gt;}&lt;/div&gt;;\n}\n</code></pre> </li> <li> <p>Context</p> <ul> <li>When to Use: When you want to share state or functions across multiple components.</li> <li>Why: The <code>useContext</code> hook allows you to access values from a context provider without having to pass props down through every level of your component tree.</li> </ul> <pre><code>const ThemeContext = React.createContext('light');\n\nfunction ThemedButton() {\n    const theme = useContext(ThemeContext);\n\n    return &lt;button style={{ background: theme === 'dark' ? '#333' : '#FFF' }}&gt;Click me&lt;/button&gt;;\n}\n</code></pre> </li> </ol>"},{"location":"frontend/react/topic/mastering/explainingothers/#when-not-to-use-hooks","title":"When Not to Use Hooks","text":"<p>Hooks are powerful, but there are cases where they might not be the best fit:</p> <ol> <li> <p>Class Components</p> <ul> <li>When Not to Use: When you are working with class components that already use lifecycle methods and state management.</li> <li>Why: Hooks are meant to simplify functional components. If you are comfortable with class components and their lifecycle methods, you might not need to switch.</li> </ul> </li> <li> <p>Complex State Logic</p> <ul> <li>When Not to Use: When you have very complex state logic that might be better managed with a class component or external state management library (like <code>Redux</code>).</li> <li>Why: While hooks can manage complex state, there are scenarios where state management libraries might offer better solutions for very complex state interactions.</li> </ul> </li> <li> <p>Performance Considerations</p> <ul> <li> <p>When Not to Use: When using hooks in a way that causes unnecessary re-renders or performance issues.</p> </li> <li> <p>Why: Some hooks like <code>useEffect</code> can lead to performance issues if not used carefully. For example, a <code>useEffect</code> that runs on every render can cause excessive updates. Always optimize hooks and consider memoization or <code>useCallback</code> to prevent performance issues.</p> </li> </ul> <pre><code>function ExpensiveComponent({ data }) {\n    const [filteredData, setFilteredData] = useState([]);\n\n    // This useEffect will run every time `data` changes\n    useEffect(() =&gt; {\n        const newFilteredData = filterData(data);\n        setFilteredData(newFilteredData);\n    }, [data]); // Dependencies array controls when this runs\n\n    return &lt;div&gt;{filteredData}&lt;/div&gt;;\n}\n</code></pre> </li> </ol> Summary <p>Use Hooks:</p> <ul> <li>In functional components.</li> <li>For managing state with <code>useState</code>.</li> <li>For handling side effects with <code>useEffect</code>.</li> <li>To access and share values with <code>useContext</code>.</li> </ul> <p>Avoid Using Hooks:</p> <ul> <li>In class components that already handle lifecycle methods and state.</li> <li>When dealing with very complex state that might need external libraries.</li> <li>In ways that could lead to performance problems, such as unnecessary re-renders.</li> </ul> <p>By understanding when and how to use hooks, you can take full advantage of their power to make your React applications more efficient and easier to maintain.</p>"},{"location":"frontend/react/topic/mastering/explainingothers/#hooks-in-functional-components-cheatsheet","title":"Hooks in Functional Components Cheatsheet","text":"<ul> <li><code>useState</code>: For managing local state.</li> <li><code>useEffect</code>: For performing side effects like data fetching or subscribing to events.</li> <li><code>useContext</code>: For accessing context values.</li> <li><code>useMemo</code> and <code>useCallback</code>: For performance optimizations</li> </ul>"},{"location":"frontend/react/topic/mastering/explainingothers/#overview-of-react-hooks","title":"Overview of React Hooks","text":"<p>From Initial Release to Latest Versions</p> React 16.8React 18 <ul> <li><code>useState</code>: For managing local state within a functional component.</li> <li><code>useEffect</code>: For performing side effects like data fetching, subscriptions, or manually changing the DOM.</li> <li><code>useContext</code>: For accessing context values directly without needing to pass props down the component tree.</li> <li><code>useReducer</code>: For managing more complex state logic with a reducer function, an alternative to useState.</li> <li><code>useLayoutEffect</code>: For performing effects that need to happen synchronously after DOM mutations but before the browser repaints.</li> <li><code>useImperativeHandle</code>: For customizing the instance value exposed by ref when using forwardRef.</li> <li><code>useMemo</code>: For memoizing the result of a computation to avoid recalculating on every render, improving performance.</li> <li><code>useCallback</code>: For memoizing callback functions to prevent unnecessary re-renders of components.</li> </ul> <ul> <li><code>useTransition</code>: For managing state updates that are less critical and can be deferred to maintain a responsive UI.</li> <li><code>useDeferredValue</code>: For deferring the rendering of less critical updates, allowing the browser to paint more smoothly.</li> <li><code>useId</code>: For generating unique IDs that persist across server and client renders, aiding in accessibility and form handling.</li> <li><code>useSyncExternalStore</code>: For subscribing to external stores and ensuring your component is synchronized with changes to the store.</li> </ul>"},{"location":"frontend/react/topic/mastering/explainingothers/#react-major-version","title":"React Major Version","text":"<ul> <li>React 0.x: Initial release with core concepts like components and Virtual DOM.</li> <li>React 15.x: Performance improvements and new API updates.</li> <li>React 16.x: Fiber architecture, error boundaries, and the introduction of Hooks.</li> <li>React 17.x: Focused on stability and upgrade ease.</li> <li>React 18.x: Concurrent features, new hooks, and performance enhancements.</li> </ul>"},{"location":"frontend/react/topic/mastering/function-declaration-and-expression/","title":"Function Declaration & Expression","text":""},{"location":"frontend/react/topic/mastering/function-declaration-and-expression/#1-function-declarations","title":"1. Function Declarations","text":"When to UseWhen to Use <ul> <li> <p>Utility Functions:</p> <p>When you have utility functions <code>or</code> helper functions that are used across multiple components or files, function declarations are a good choice due to their hoisting behavior. This allows you to reference them before they are defined in your code.</p> <pre><code>// Utility function declared at the top\nfunction calculateSomething(x) {\n    return x * 2;\n}\n\nfunction MyComponent() {\n    const result = calculateSomething(5);\n    return &lt;div&gt;{result}&lt;/div&gt;;\n}\n</code></pre> </li> <li> <p>Top-Level Scope:</p> <p>When defining functions at the top level of a module that should be available throughout the file or across various parts of your code, function declarations can be more intuitive.</p> </li> </ul> <ul> <li> <p>Hoisting:</p> <p>Function declarations are hoisted, meaning they are available throughout the scope they are defined in, which can be useful for organizing code.</p> </li> </ul>"},{"location":"frontend/react/topic/mastering/function-declaration-and-expression/#2-function-expressions","title":"2. Function Expressions","text":"When to UseWhy <ul> <li> <p>Component Definitions:</p> <p>When defining React functional components, function expressions (often with arrow functions) are commonly used. This is because they offer a concise syntax and align well with React\u2019s functional programming paradigm.</p> <pre><code>const MyComponent = () =&gt; {\n    return &lt;div&gt;Hello World&lt;/div&gt;;\n};\n</code></pre> </li> <li> <p>Event Handlers and Callbacks:</p> <p>For inline event handlers or callbacks, arrow functions provide a more succinct syntax and handle <code>this</code> context automatically.</p> <pre><code>const handleClick = () =&gt; {\n    console.log('Clicked!');\n};\n\nfunction MyComponent() {\n    return &lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt;;\n}\n</code></pre> </li> <li> <p>Inline Functions:</p> <p>When passing functions as props or defining functions inside render methods or functional components, function expressions (especially arrow functions) help keep the code concise and readable.</p> <pre><code>const MyComponent = () =&gt; {\n    return (\n        &lt;div&gt;\n            {[1, 2, 3].map(number =&gt; (\n                &lt;div key={number}&gt;{number}&lt;/div&gt;\n            ))}\n        &lt;/div&gt;\n    );\n};\n</code></pre> </li> </ul> <ul> <li>Conciseness: Function expressions and arrow functions provide a more compact syntax, which is particularly useful in modern React codebases.</li> <li>Lexical <code>this</code>: Arrow functions inherit <code>this</code> from their surrounding context, avoiding common pitfalls with <code>this</code> binding in event handlers or methods.</li> </ul>"},{"location":"frontend/react/topic/mastering/function-declaration-and-expression/#summary","title":"Summary","text":"<ul> <li> <p>Function Declarations: Use them for utility functions, and top-level functions that benefit from hoisting or need to be referenced before their definition. They are more traditional and offer clear readability.</p> </li> <li> <p>Function Expressions and Arrow Functions: Use them for defining React components, inline functions, event handlers, and callbacks due to their concise syntax and lexical scoping of <code>this</code>.</p> </li> </ul> <p>Ultimately, the choice between function declarations and function expressions often comes down to the specific needs of your code and your team\u2019s coding style preferences. In modern React development, function expressions, especially with arrow functions, are prevalent due to their ease of use and alignment with functional programming principles.</p>"},{"location":"frontend/react/topic/mastering/function-declaration-and-expression/#utility-functions","title":"Utility functions","text":"<p>Utility functions are helper functions designed to perform common tasks or calculations that are not specific to a particular component but are used across various parts of your application. They help keep your code DRY (Don't Repeat Yourself) by encapsulating reusable logic that can be shared and maintained independently.</p>"},{"location":"frontend/react/topic/mastering/function-declaration-and-expression/#overview","title":"Overview","text":"Characteristics of Utility Functions <ul> <li>Reusable: Utility functions are generic and can be used in multiple places throughout your application.</li> <li>Single Responsibility: They generally do one thing well, making them easy to test and maintain.</li> <li>Stateless: They do not maintain or modify internal state; they operate based on the inputs provided and return a result.</li> </ul>"},{"location":"frontend/react/topic/mastering/function-declaration-and-expression/#example","title":"Example","text":"<p>Examples of Utility Functions in React</p> <ol> <li> <p>Simple Calculation Utility</p> <p>Suppose you have a function that formats numbers as currency. This function is not tied to a specific component but is used across your application wherever you need currency formatting.</p> JSUsage in a Component utils/formatCurrency.js<pre><code>// Utility function for formatting numbers as currency\nexport function formatCurrency(amount) {\n    return new Intl.NumberFormat('en-US', {\n        style: 'currency',\n        currency: 'USD',\n    }).format(amount);\n}\n</code></pre> <pre><code>import React from 'react';\nimport { formatCurrency } from './utils/formatCurrency';\n\nconst ProductPrice = ({ price }) =&gt; {\n    return &lt;div&gt;Price: {formatCurrency(price)}&lt;/div&gt;;\n};\n\nexport default ProductPrice;\n</code></pre> </li> <li> <p>Data Transformation Utility</p> <p>Imagine you need a utility to filter out users who are active from a list of users.</p> JSUsage in a Component utils/filterActiveUsers.js<pre><code>// Utility function for filtering active users\nexport function filterActiveUsers(users) {\n    return users.filter(user =&gt; user.isActive);\n}\n</code></pre> <pre><code>import React from 'react';\nimport { filterActiveUsers } from './utils/filterActiveUsers';\n\nconst UserList = ({ users }) =&gt; {\n    const activeUsers = filterActiveUsers(users);\n\n    return (\n        &lt;ul&gt;\n            {activeUsers.map(user =&gt; (\n                &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;\n            ))}\n        &lt;/ul&gt;\n    );\n};\n\nexport default UserList;\n</code></pre> </li> <li> <p>Date Formatting Utility</p> <p>If you need to format dates in various parts of your app, you might use a date formatting utility.</p> JSUsage in a Component utils/formatDate.js<pre><code>// Utility function for formatting dates\nexport function formatDate(date) {\n    return new Intl.DateTimeFormat('en-US').format(new Date(date));\n}\n</code></pre> <pre><code>import React from 'react';\nimport { formatDate } from './utils/formatDate';\n\nconst EventDate = ({ date }) =&gt; {\n    return &lt;div&gt;Event Date: {formatDate(date)}&lt;/div&gt;;\n};\n\nexport default EventDate;\n</code></pre> </li> </ol> Summary <p>Utility functions are designed to be reusable and to perform common operations that can be used across various components or modules in your application. By isolating these functions into separate files or modules, you make your codebase cleaner, more modular, and easier to maintain.</p> <p>In a React application, you would typically place utility functions in a dedicated <code>utils</code> directory or similar structure, and then import them into your components or other parts of your application as needed.</p>"},{"location":"frontend/react/topic/mastering/hooks-mastering-topic/","title":"Hooks Mastering","text":""},{"location":"frontend/react/topic/mastering/hooks-mastering-topic/#topic","title":"Topic","text":"<p>Mastering React functional hooks involves understanding their fundamentals, exploring advanced use cases, and practicing their application in real-world scenarios. Here\u2019s a structured approach to deepening your knowledge of React hooks:</p> <ol> <li> <p>Understand the Basics</p> <ul> <li> <p>React Hooks Overview: Learn about the basic hooks such as <code>useState</code>, <code>useEffect</code>, <code>useContext</code>, <code>useReducer</code>, and <code>useCallback</code>. Understand their signatures, use cases, and lifecycle implications.</p> <ul> <li><code>useState</code>: Manages local component state.</li> <li><code>useEffect</code>: Handles side effects (e.g., data fetching, subscriptions).</li> <li><code>useContext</code>: Accesses context values.</li> <li><code>useReducer</code>: Manages state using a reducer function.</li> <li><code>useCallback</code>: Memoizes callback functions.</li> <li><code>useMemo</code>: Memoizes expensive computations.</li> </ul> </li> <li> <p>Component Lifecycle: Understand how hooks map to lifecycle methods in class components (e.g., <code>useEffect</code> is similar to <code>componentDidMount</code> and <code>componentDidUpdate</code>).</p> </li> </ul> </li> <li> <p>Dive Deeper into Each Hook</p> <ul> <li> <p><code>useState</code>:</p> <ul> <li>Multiple state variables.</li> <li>State initialization and lazy initialization.</li> <li>Handling complex state.</li> </ul> </li> <li> <p><code>useEffect</code>:</p> <ul> <li>Cleanup functions.</li> <li>Dependency arrays and how they affect the execution.</li> <li>Managing asynchronous operations.</li> </ul> </li> <li> <p><code>useReducer</code>:</p> <ul> <li>Comparing with <code>useState</code>.</li> <li>When to use <code>useReducer</code> over <code>useState</code>.</li> <li>Handling complex state logic and actions.</li> </ul> </li> <li> <p><code>useContext</code>:</p> <ul> <li>Creating and providing context.</li> <li>Consuming context efficiently.</li> </ul> </li> <li> <p><code>useCallback</code> and <code>useMemo</code>:</p> <ul> <li>When to use them to optimize performance.</li> <li>Understanding dependencies and their impact.</li> </ul> </li> </ul> </li> <li> <p>Explore Advanced Hooks and Patterns</p> <ul> <li> <p>Custom Hooks: Learn to create reusable hooks to encapsulate logic. Practice building custom hooks for common patterns in your applications.</p> </li> <li> <p>Performance Optimization:</p> <ul> <li>Learn how hooks like <code>useMemo</code> and <code>useCallback</code> help prevent unnecessary re-renders.</li> <li>Understand the <code>React.memo</code> for memoizing components.</li> </ul> </li> <li> <p>Error Boundaries: Implement error handling using <code>Error Boundaries</code> in combination with hooks for better user experience.</p> </li> <li> <p>Custom Hook Patterns:</p> <ul> <li>Data fetching and synchronization (e.g., <code>useFetch</code>).</li> <li>Form handling and validation.</li> <li>Animation and timing effects.</li> </ul> </li> </ul> </li> <li> <p>Practice and Apply</p> <ul> <li> <p>Build Projects: Apply hooks in real-world projects. Build components that use various hooks and integrate them with APIs or complex state management.</p> </li> <li> <p>Refactor Class Components: Convert class components to functional components with hooks to understand their practical use.</p> </li> <li> <p>Code Reviews and Community: Participate in code reviews and seek feedback. Engage with the React community to learn from others\u2019 experiences and practices.</p> </li> </ul> </li> <li> <p>Stay Updated and Experiment</p> <ul> <li> <p>React Documentation: Regularly check the official React documentation for updates and new features.</p> </li> <li> <p>Blogs and Tutorials: Follow reputable blogs and tutorials to keep up with advanced techniques and best practices.</p> </li> <li> <p>Experiment: Try implementing new patterns and experimenting with different hook combinations to understand their behavior better.</p> </li> </ul> </li> <li> <p>Deep Dive into Related Libraries</p> <ul> <li> <p>React Query or SWR: Explore libraries like React Query for data fetching and caching. They often use hooks internally and provide a lot of utilities that complement your understanding of hooks.</p> </li> <li> <p>Form Libraries: Libraries like Formik or React Hook Form offer hooks for managing form state and validation, which can deepen your understanding of hooks in different contexts.</p> </li> </ul> </li> </ol> <p>By systematically studying these aspects, you\u2019ll be well on your way to mastering React functional hooks and applying them effectively in your projects.</p>"},{"location":"frontend/react/topic/mastering/hooks-mastering-topic/#god-tier","title":"God Tier","text":"<p>To reach a \"god level\" mastery of React functional hooks, you'll need to progress from foundational knowledge to complex and nuanced applications. Here's a structured and comprehensive approach to achieving this:</p> <ol> <li> <p>Master the Fundamentals</p> <ul> <li> <p>Core Hooks:</p> <ul> <li><code>useState</code>: Practice managing simple and complex state, using state initialization, and handling asynchronous updates.</li> <li><code>useEffect</code>: Understand different ways to use effects, including cleanup, dependency management, and handling async operations.</li> <li><code>useContext</code>: Implement and consume context, understand context performance implications, and create context providers.</li> <li><code>useReducer</code>: Implement complex state logic and actions, understand when to use useReducer versus useState.</li> <li><code>useCallback</code>: Learn when and how to memoize callbacks to avoid unnecessary re-renders.</li> <li><code>useMemo</code>: Memoize values to avoid expensive recalculations, and understand how to use dependencies properly.</li> </ul> </li> <li> <p>Component Lifecycle Mapping:</p> <ul> <li>Map hooks to lifecycle methods in class components (e.g., <code>useEffect</code> to <code>componentDidMount</code>/<code>componentDidUpdate</code>).</li> </ul> </li> </ul> </li> <li> <p>Build Strong Intermediate Skills</p> <ul> <li> <p>Custom Hooks:</p> <ul> <li>Create Reusable Logic: Develop custom hooks to encapsulate logic that is used across multiple components (e.g., form handling, data fetching).</li> <li>Combine Hooks: Create custom hooks that use other hooks to manage complex state or effects.</li> </ul> </li> <li> <p>Performance Optimization:</p> <ul> <li>Avoid Re-renders: Use <code>React.memo</code> and <code>useCallback</code> to prevent unnecessary re-renders of components.</li> <li>Optimize Effects: Use the dependency array correctly in <code>useEffect</code> to avoid running effects unnecessarily.</li> </ul> </li> <li> <p>Error Handling:</p> <ul> <li>Implement error boundaries in functional components, and combine them with hooks to manage and handle errors effectively.</li> </ul> </li> </ul> </li> <li> <p>Achieve Advanced Mastery</p> <ul> <li> <p>Complex Custom Hooks:</p> <ul> <li>Abstract Logic: Build custom hooks that abstract complex logic such as pagination, authentication, or offline storage.</li> <li>Complex Interactions: Develop hooks that manage complex interactions between components, such as synchronized state across different parts of an app.</li> </ul> </li> <li> <p>Advanced Patterns:</p> <ul> <li>Render Props and Higher-Order Components (HOCs): Compare and contrast hooks with these patterns, and understand when and why to use hooks over them.</li> <li>Compound Components: Use hooks to create compound component patterns that share state and behavior seamlessly.</li> </ul> </li> <li> <p>Performance Tuning:</p> <ul> <li>Code Splitting and Lazy Loading: Utilize React\u2019s lazy loading and code splitting features to optimize performance.</li> <li>Memoization Strategies: Dive deep into memoization techniques and understand their impact on performance.</li> </ul> </li> </ul> </li> <li> <p>Deep Dive into Ecosystem and Libraries</p> <ul> <li> <p>React Query/SWR:</p> <ul> <li>Master libraries that manage server state with hooks, such as React Query or SWR. Learn their advanced features like caching, pagination, and optimistic updates.</li> </ul> </li> <li> <p>Form Libraries:</p> <ul> <li>Formik/React Hook Form: Deep dive into form handling libraries and their hooks. Understand how they simplify complex form logic and validation.</li> </ul> </li> <li> <p>Animation Libraries:</p> <ul> <li>React Spring/Framer Motion: Explore animation libraries that use hooks to manage animations and transitions.</li> </ul> </li> </ul> </li> <li> <p>Practice and Real-World Application</p> <ul> <li> <p>Build and Refactor Projects:</p> <ul> <li>Refactor Existing Code: Take existing class-based components and refactor them to functional components using hooks.</li> <li>Build New Projects: Create projects from scratch using hooks to reinforce your understanding.</li> </ul> </li> <li> <p>Code Reviews and Collaboration:</p> <ul> <li>Participate in Code Reviews: Review code written by others and provide feedback on hook usage and best practices.</li> <li>Collaborate on Open Source: Contribute to open source projects to see how experienced developers use hooks in various contexts.</li> </ul> </li> </ul> </li> <li> <p>Stay Updated and Continue Learning</p> <ul> <li> <p>React Documentation and Releases:</p> <ul> <li>Follow Official Docs: Regularly check the official React documentation for updates on hooks and new features.</li> <li>Stay Current: Keep up with the latest React releases and changes to hooks.</li> </ul> </li> <li> <p>Community and Thought Leaders:</p> <ul> <li>Read Blogs and Watch Talks: Follow influential React developers and stay updated with the latest techniques and best practices.</li> <li>Engage with the Community: Participate in forums, attend meetups, and join discussions to learn from peers and experts.</li> </ul> </li> </ul> </li> </ol> <p>By following this structured approach and continuously challenging yourself with new projects and concepts, you\u2019ll develop a profound and comprehensive mastery of React functional hooks.</p>"},{"location":"frontend/react/topic/mastering/one-most-important-in-react/","title":"One Most IMP","text":""},{"location":"frontend/react/topic/mastering/one-most-important-in-react/#overview","title":"Overview","text":"<p>What is the most challenging about react</p> <p>One of the most challenging aspects of React development is state management, especially as an application grows in complexity. While React itself provides a straightforward way to manage component state locally, scaling this across larger applications can quickly become difficult. Here's why:</p> <ol> <li> <p>Complex State Management: As an application grows, managing state at the component level becomes cumbersome. Passing state down through many layers of components (often referred to as \"prop drilling\") can lead to messy code and performance issues. Managing global state can also become tricky, especially when components rely on shared data or need to react to changes in real-time.</p> </li> <li> <p>Choosing the Right State Management Solution: React offers various options for state management, ranging from React\u2019s built-in <code>useState</code> and <code>useReducer</code> hooks to more advanced libraries like Redux, Context API, or third-party solutions like Recoil or Zustand. Deciding which tool to use, or how to organize state efficiently, can be overwhelming, especially for beginners or in large-scale applications.</p> </li> <li> <p>Component Re-rendering: React\u2019s re-rendering behavior can sometimes be hard to control. While React uses a virtual DOM for performance optimization, unnecessary re-renders can still occur if state updates or props change unintentionally. Optimizing renders using techniques like memoization (e.g., <code>React.memo</code>, <code>useMemo</code>, <code>useCallback</code>) requires a deep understanding of React\u2019s rendering mechanics.</p> </li> <li> <p>Asynchronous Data Handling: Working with asynchronous data (e.g., fetching data from APIs) can create challenges, such as managing loading states, error handling, and ensuring that UI is updated correctly when data arrives. React hooks like <code>useEffect</code> or libraries like React Query can help, but handling side effects and asynchronous behavior still requires careful attention to avoid race conditions or inconsistent state.</p> </li> <li> <p>Understanding Hooks: React hooks, like <code>useState</code>, <code>useEffect</code>, <code>useContext</code>, and custom hooks, are powerful but can be tricky to master, especially for developers coming from a class-based component background. Understanding the rules of hooks (e.g., they must be called in the same order in every render) and dealing with hooks' dependency arrays in useEffect can be confusing.</p> </li> <li> <p>Context API Performance Issues: While React's Context API is a simple way to manage global state, using it incorrectly or excessively can cause performance problems because any update to the context triggers a re-render of all components that consume that context. Managing context efficiently is essential for preventing unnecessary re-renders.</p> </li> <li> <p>TypeScript Integration: As React applications grow, incorporating TypeScript for type safety is increasingly common. While TypeScript brings many benefits, it can be challenging to integrate correctly, especially when working with complex component props, states, and third-party libraries that may not have proper type definitions.</p> </li> <li> <p>Testing: React applications often require careful testing of components, hooks, and integration. Tools like Jest and React Testing Library are commonly used, but writing tests that accurately simulate real user interactions and ensure proper state management can be time-consuming and complex.</p> </li> </ol> <p>React offers a lot of flexibility and power, but these challenges require a solid understanding of its core concepts and best practices to build maintainable, performant, and scalable applications.</p>"},{"location":"frontend/react/topic/mastering/one-most-important-in-react/#additional","title":"Additional","text":"<p>what is the one of the most important to understand in react to master in depth</p> <p>One of the most important concepts to understand in React to master it in depth is State Management. This concept is crucial because it drives how data flows and is managed in your application. Here's why state management is central to React development:</p> <ol> <li> <p>State and Re-rendering:</p> <ul> <li>In React, state is used to hold data that affects the rendering of a component. Understanding how state works and triggers re-renders is key to ensuring that your application behaves as expected.</li> <li>React's reconciliation algorithm (the process of updating the DOM) relies on detecting changes in state, so understanding this process helps you write more efficient applications and optimize performance.</li> </ul> </li> <li> <p>Component Lifecycle:</p> <ul> <li>React components go through a lifecycle, and understanding this lifecycle helps you manage state at various stages of a component\u2019s existence (e.g., mounting, updating, unmounting).</li> <li>Managing state properly in different lifecycle methods (in class components) or hooks (in functional components) like useEffect or useState is essential for building dynamic, responsive applications.</li> </ul> </li> <li> <p>State Management Libraries:</p> <ul> <li> <p>As applications grow in complexity, managing state across multiple components can become challenging. This is where state management libraries come into play. The most commonly used ones in React are:</p> <ul> <li>Redux: For global state management across the entire application.</li> <li>Context API: React\u2019s built-in solution for sharing state between components without prop drilling.</li> <li>Recoil or Zustand: Modern alternatives to Redux that offer simpler, more flexible state management.</li> </ul> </li> <li> <p>Mastering these tools (and understanding when and why to use them) is essential for managing complex state in large-scale applications.</p> </li> </ul> </li> <li> <p>Performance Optimization:</p> <ul> <li>React\u2019s re-rendering can sometimes lead to performance issues, especially in large applications. Understanding how to optimize state management to reduce unnecessary re-renders (using techniques like memoization, <code>React.memo</code>, <code>useMemo</code>, and <code>useCallback</code>) is vital.</li> <li>Proper state management allows you to ensure that only necessary parts of the application are re-rendered when state changes.</li> </ul> </li> <li> <p>State Immutability:</p> <ul> <li>React relies on the concept of immutability (i.e., not directly modifying the state). Instead, state should be updated in an immutable way (e.g., using spread operators, <code>Object.assign</code>, or libraries like <code>Immer</code>).</li> <li>Understanding immutability is key to preventing bugs and ensuring React's efficient re-rendering process works properly.</li> </ul> </li> <li> <p>Asynchronous State Management:</p> <ul> <li>Many times, state needs to be updated asynchronously, especially when working with APIs or handling user inputs. React\u2019s hooks (such as <code>useState</code> with asynchronous updates, and <code>useEffect</code> for side effects) are important tools in dealing with this complexity.</li> <li>Learning how to manage state updates effectively in an asynchronous environment is essential for building smooth, user-friendly applications.</li> </ul> </li> </ol> <p>Conclusion:</p> <p>Mastering state management in React involves understanding how state drives the UI, how to optimize re-renders, how to manage state across components, and how to handle it efficiently in large-scale applications. This knowledge is fundamental to becoming proficient in React, as it underpins almost every aspect of building React applications.</p>"},{"location":"frontend/react/topic/mastering/shallow-comparison/","title":"Shallow Comparison","text":"<p>Understanding Immutability and State Change Detection in React</p>"},{"location":"frontend/react/topic/mastering/shallow-comparison/#overview","title":"Overview","text":"<p>In React, state and props are fundamental to how the component behaves. When working with state, it is important to understand whether the data has changed or not to optimize re-renders and ensure that React is efficiently managing updates. Here's how you can determine whether an object or array (or any data structure) has changed its original value in React:</p>"},{"location":"frontend/react/topic/mastering/shallow-comparison/#1-using-object-references-to-detect-changes","title":"1. Using Object References to Detect Changes","text":"<p>In JavaScript, objects and arrays are reference types. This means when you assign an object or array to a variable, that variable doesn't hold the actual data but instead holds a reference (or pointer) to the original object or array in memory.</p> <p>In React, the most efficient way to detect whether a value has changed is by comparing the reference of the value, not the value itself (for non-primitive types like arrays and objects).</p> Key Concept: <ul> <li>Primitive types: (e.g., <code>number</code>, <code>string</code>, <code>boolean</code>) are compared by value.</li> <li>Reference types: (e.g., <code>array</code>, <code>object</code>) are compared by reference.</li> </ul> <p>In React, you can use shallow comparison (comparing the references) to check if something has changed, and React will re-render when the reference changes.</p>"},{"location":"frontend/react/topic/mastering/shallow-comparison/#2-how-to-compare-changes-in-react","title":"2. How to Compare Changes in React","text":"<p>To compare if a value has changed, you can look at whether the reference of the object or array has changed. If the reference has changed, the object/array is considered \"new\" and React will update the component accordingly.</p> <p>Here are a few ways to check if a value has changed:</p> <p>For Primitive Types (numbers, strings, booleans):</p> <p>You can simply compare the previous and current values.</p> <pre><code>let prevValue = 5;\nlet currentValue = 6;\n\nif (prevValue !== currentValue) {\n  console.log(\"The value has changed!\");\n}\n</code></pre> <p>For Objects and Arrays (reference types):</p> <p>You cannot compare objects and arrays directly by value in JavaScript. Instead, you compare their references. If the reference changes, it means the data has changed.</p> <pre><code>const prevArray = [1, 2, 3];\nconst newArray = [...prevArray, 4]; // Creating a new array\n\nif (prevArray !== newArray) {\n  console.log(\"The array has changed!\"); // This will log\n}\n\nconst prevObject = { name: \"Alice\" };\nconst newObject = { ...prevObject, age: 25 }; // Creating a new object\n\nif (prevObject !== newObject) {\n  console.log(\"The object has changed!\"); // This will log\n}\n</code></pre>"},{"location":"frontend/react/topic/mastering/shallow-comparison/#3-how-react-detects-changes-using-usestate-and-useeffect","title":"3. How React Detects Changes (Using <code>useState</code> and <code>useEffect</code>)","text":"<p>In React, the core way to update the UI is by using state. When state changes, React checks if the state reference has changed (using shallow comparison). If the reference has changed, it triggers a re-render.</p> <p>Here's how you might typically check for changes in React components:</p> Example using useState and useEffect:<pre><code>import React, { useState, useEffect } from \"react\";\n\nfunction ExampleComponent() {\n  const [state, setState] = useState({ count: 0 });\n\n  // Using useEffect to watch for changes in state\n  useEffect(() =&gt; {\n    console.log(\"State has changed:\", state);\n  }, [state]); // Only triggers when `state` changes\n\n  const handleClick = () =&gt; {\n    // Updating state by creating a new object (immutable update)\n    setState((prevState) =&gt; ({ ...prevState, count: prevState.count + 1 }));\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Count: {state.count}&lt;/p&gt;\n      &lt;button onClick={handleClick}&gt;Increment&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default ExampleComponent;\n</code></pre> Key Points: <ul> <li><code>useState</code>: React checks the state reference to see if it has changed. If the new state reference is different from the previous state reference, React re-renders the component.</li> <li><code>useEffect</code>: You can use <code>useEffect</code> with a dependency array to run side effects only when a value (state or props) changes. The dependency array is compared shallowly for changes.</li> <li>Immutable updates: You should always update state immutably by creating a new object or array (using spread syntax or methods like <code>concat()</code> for arrays). Direct mutation of state can cause unpredictable behavior in React.</li> </ul>"},{"location":"frontend/react/topic/mastering/shallow-comparison/#4-shallow-vs-deep-comparison","title":"4. Shallow vs Deep Comparison","text":"<ul> <li> <p>Shallow Comparison: Compares only the references for objects and arrays. This is how React determines whether a state change has occurred, by comparing the <code>reference</code> of the previous and new state.</p> </li> <li> <p>Deep Comparison: Compares the actual contents of objects or arrays, which is more expensive computationally and generally not needed in React.</p> </li> </ul> <p>For React, shallow comparison is used by default. When you update state by creating a new reference (new object or array), React will re-render the component.</p>"},{"location":"frontend/react/topic/mastering/shallow-comparison/#5-example-of-detecting-change-in-react-state","title":"5. Example of Detecting Change in React State","text":"<p>Here\u2019s an example of detecting changes using <code>useState</code> and <code>useEffect</code>:</p> <pre><code>import React, { useState, useEffect } from \"react\";\n\nfunction App() {\n  const [state, setState] = useState({ name: \"Alice\", age: 25 });\n\n  // Log when state changes\n  useEffect(() =&gt; {\n    console.log(\"State has changed:\", state);\n  }, [state]); // Only triggers when `state` reference changes\n\n  const changeState = () =&gt; {\n    // Immutable update (creates a new object)\n    setState((prevState) =&gt; ({ ...prevState, age: prevState.age + 1 }));\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Name: {state.name}&lt;/p&gt;\n      &lt;p&gt;Age: {state.age}&lt;/p&gt;\n      &lt;button onClick={changeState}&gt;Increment Age&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default App;\n</code></pre> <p>In this example:</p> <ul> <li>We use the spread operator (<code>{ ...prevState, age: prevState.age + 1 }</code>) to create a new state object.</li> <li>React detects the change by comparing the new <code>state</code> reference with the old one.</li> </ul>"},{"location":"frontend/react/topic/mastering/shallow-comparison/#6-reacts-performance-optimization-with-shouldcomponentupdate-or-reactmemo","title":"6. React's Performance Optimization with <code>shouldComponentUpdate</code> or <code>React.memo()</code>","text":"<p>React provides ways to optimize how and when components re-render. For functional components, you can use <code>React.memo()</code> to prevent unnecessary re-renders based on state or props changes:</p> <pre><code>const MyComponent = React.memo(function MyComponent({ data }) {\n  return &lt;div&gt;{data}&lt;/div&gt;;\n});\n</code></pre> <p>React will shallowly compare the props, and only re-render the component if the props have changed.</p>"},{"location":"frontend/react/topic/mastering/shallow-comparison/#conclusion-how-to-compare-changes-in-react","title":"Conclusion: How to Compare Changes in React","text":"<ul> <li>Reference comparison is the most important concept. When state or props change, React compares their references, not their contents.</li> <li>To trigger a re-render, always create new references (by using immutable patterns like <code>spread</code> or array methods like <code>concat()</code>).</li> <li>Use <code>useEffect</code> with a dependency array to react to changes in state.</li> <li>Avoid mutating state directly\u2014always make an immutable update.</li> <li>React does shallow comparisons by default, which compares references for objects and arrays, so always ensure that you are updating state immutably.</li> </ul> <p>By following these principles, React can efficiently manage state changes and optimize re-renders, ensuring your app runs smoothly.</p>"},{"location":"frontend/react/topic/mastering/state-immutability/","title":"State Immutability","text":"<p>State Immutability: explain me in depth what is is in js and react and how does it effect in react</p>"},{"location":"frontend/react/topic/mastering/state-immutability/#state-immutability-in-javascript-and-react","title":"State Immutability in JavaScript and React","text":"<p>Immutability refers to the concept that once an object or data structure is created, it cannot be changed. Instead of directly modifying the original object, a new copy of the object is created with the updated values. This principle is critical in both JavaScript and React for ensuring that your code works predictably and efficiently, especially when it comes to state management.</p>"},{"location":"frontend/react/topic/mastering/state-immutability/#immutability-in-javascript","title":"Immutability in JavaScript","text":"<p>In JavaScript, objects and arrays are mutable by default, meaning that you can modify them directly (e.g., change a property of an object or append to an array). However, immutability means you should avoid direct modifications. For example:</p> <ul> <li> <p>Mutable Operation (Not Immutable):</p> <pre><code>let obj = { name: \"John\" };\nobj.name = \"Jane\"; // Direct modification\n</code></pre> </li> <li> <p>Immutable Operation (Using Immutability):</p> <pre><code>let obj = { name: \"John\" };\nobj = { ...obj, name: \"Jane\" }; // Create a new object with updated values\n</code></pre> </li> </ul> <p>Instead of directly modifying <code>obj</code>, you create a new object with the updated properties. This ensures that the original object remains unchanged.</p>"},{"location":"frontend/react/topic/mastering/state-immutability/#immutability-in-react","title":"Immutability in React","text":"<p>Immutability plays a critical role in React because it directly affects re-rendering and state updates.</p> <p>In React, the UI is a function of state. React tracks the changes in state to decide when and how to re-render components. If state is directly mutated, React can\u2019t easily detect changes, which can lead to unexpected behavior, such as:</p> <ul> <li>UI not updating properly</li> <li>State not being tracked correctly</li> <li>Unnecessary re-renders</li> </ul> <p>To understand why immutability matters, let\u2019s break down its effects in React:</p>"},{"location":"frontend/react/topic/mastering/state-immutability/#why-immutability-is-important-in-react","title":"Why Immutability is Important in React","text":"<ol> <li> <p>Efficient Re-rendering:</p> <ul> <li>React uses a reconciliation process to determine what has changed in the UI. If you mutate the state directly, React will not be able to detect that a change has occurred because the reference to the object or array remains the same.</li> <li>Immutability allows React to detect changes: When you create a new object or array with updated values, React can compare the new reference with the old one and quickly determine that something has changed, triggering a re-render.</li> </ul> </li> <li> <p>Predictability of State Updates:</p> <ul> <li>Immutability ensures that the state is predictable. When the state is directly modified, it becomes difficult to reason about how the state changes over time because one part of the app might change the state while another part might depend on the old state.</li> <li>With immutability, state changes are clear and explicit. The new state is distinct from the previous one, which makes debugging and understanding the flow of data easier.</li> </ul> </li> <li> <p>Performance Optimization:</p> <ul> <li>In React, especially with large applications, unnecessary re-renders can hurt performance. Direct mutation can lead to re-renders that might not be needed.</li> <li>Immutability helps in performance optimization: By comparing references (shallow comparison) instead of values, React can skip unnecessary updates to components, especially when the state or props haven\u2019t actually changed.</li> </ul> </li> <li> <p>Working with Pure Components:</p> <ul> <li> <p>React encourages the use of pure components, which are components that only depend on the props and state they receive. A pure component re-renders only if the props or state change.</p> </li> <li> <p>Mutating state directly prevents React from recognizing changes: If a component\u2019s state is mutated directly, React might not detect that the component\u2019s data has changed, leading to stale UI.</p> </li> </ul> </li> </ol>"},{"location":"frontend/react/topic/mastering/state-immutability/#examples-of-immutability-in-react","title":"Examples of Immutability in React","text":"<p>Let's explore how immutability works in React with a few examples.</p> <p>Example 1: Updating State in a React Component</p> <p>In React, state is often updated using the <code>useState</code> hook (or <code>this.setState</code> in class components). To update state in an immutable way, you must ensure that you create a new copy of the state rather than modifying it directly.</p> <ul> <li> <p>Mutable Approach (Incorrect):</p> <pre><code>const [state, setState] = useState({ count: 0 });\n\nconst increment = () =&gt; {\n  state.count += 1; // Mutating state directly (Incorrect)\n  setState(state); // Doesn't trigger re-render correctly\n};\n</code></pre> </li> <li> <p>Immutable Approach (Correct):</p> <pre><code>const [state, setState] = useState({ count: 0 });\n\nconst increment = () =&gt; {\n  setState((prevState) =&gt; ({ count: prevState.count + 1 })); // Create a new object\n};\n</code></pre> </li> </ul> <p>In the immutable approach, instead of modifying the <code>state.count</code> directly, we return a new object with an updated count. This ensures React will detect a change and trigger a re-render.</p> <p>Example 2: Updating Arrays or Objects</p> <p>When updating arrays or objects in React, you need to make sure you're not directly modifying them. Here\u2019s how you would do it immutably.</p> <ul> <li> <p>Updating an Array (Mutable Way)</p> <pre><code>const [items, setItems] = useState([1, 2, 3]);\n\nconst addItem = () =&gt; {\n  items.push(4); // Mutating the array directly (Incorrect)\n  setItems(items);\n};\n</code></pre> </li> <li> <p>Updating an Array (Immutable Way)</p> <pre><code>const [items, setItems] = useState([1, 2, 3]);\n\nconst addItem = () =&gt; {\n  setItems((prevItems) =&gt; [...prevItems, 4]); // Create a new array with added item\n};\n</code></pre> </li> </ul> <p>In the immutable approach, you use the spread operator (...) to create a new array with the updated item, rather than modifying the existing array.</p> <p>Example 3: Using <code>map()</code> or <code>filter()</code> to Update Arrays</p> <p>Let\u2019s say you need to update an item in an array or remove it.</p> <ul> <li> <p>Immutable Array Update (Correct):</p> <pre><code>const [items, setItems] = useState([1, 2, 3]);\n\nconst updateItem = (id, newValue) =&gt; {\n  setItems((prevItems) =&gt;\n    prevItems.map((item) =&gt; (item === id ? newValue : item))\n  ); // Map to create a new array with updated value\n};\n</code></pre> </li> <li> <p>Immutable Array Removal (Correct):</p> <pre><code>const [items, setItems] = useState([1, 2, 3]);\n\nconst removeItem = (id) =&gt; {\n  setItems((prevItems) =&gt; prevItems.filter((item) =&gt; item !== id)); // Create new array excluding item\n};\n</code></pre> </li> </ul> <p>In both examples, you are not modifying the original array (prevItems). Instead, you create a new array using map() or filter().</p>"},{"location":"frontend/react/topic/mastering/state-immutability/#why-mutating-state-can-cause-issues-in-react","title":"Why Mutating State Can Cause Issues in React","text":"<ol> <li> <p>Inconsistent Rendering: If you mutate the state, React won\u2019t be able to compare the new and old state properly, resulting in missed updates to the UI.</p> </li> <li> <p>Hard to Track Changes: When state is mutated directly, it\u2019s harder to know when and where changes happen. This leads to debugging difficulties.</p> </li> <li> <p>Unintended Side Effects: Mutating state directly can lead to unintended consequences, as other parts of the code might be expecting the original state.</p> </li> </ol>"},{"location":"frontend/react/topic/mastering/state-immutability/#summary","title":"Summary","text":"<ul> <li>Immutability is a core principle in React that ensures proper state updates and component re-renders.</li> <li>By creating new objects or arrays with updated values instead of directly modifying the original state, React can detect changes efficiently.</li> <li>This leads to better performance, easier debugging, and predictable state behavior in your application.</li> </ul> <p>Mastering immutability in React helps you write more efficient, maintainable, and bug-free applications.</p>"},{"location":"frontend/router/intro/","title":"Intro","text":"<p>router</p> <p></p>"},{"location":"frontend/router/docs/auth-techniques/","title":"Technique","text":"<p>Techniques for Managing Authentication in React</p> <p>Here's a comprehensive overview of various techniques for managing authentication and state in React applications, presented in a structured format for easy reference.</p>"},{"location":"frontend/router/docs/auth-techniques/#categorized","title":"Categorized","text":"<p>Here\u2019s a categorized overview of various techniques for managing authentication in React applications, grouped by their complexity and use cases. This should help with memorization!</p>"},{"location":"frontend/router/docs/auth-techniques/#1-simple-state-management-techniques","title":"1. Simple State Management Techniques","text":"<ul> <li> <p>Context API</p> <ul> <li>Best For: Small to medium-sized applications.</li> <li>Use Case: Sharing authentication state across multiple components without prop drilling.</li> </ul> </li> <li> <p>Zustand</p> <ul> <li>Best For: Lightweight state management.</li> <li>Use Case: Applications needing a simple and fast solution for state management.</li> </ul> </li> </ul>"},{"location":"frontend/router/docs/auth-techniques/#2-intermediate-state-management-techniques","title":"2. Intermediate State Management Techniques","text":"<ul> <li> <p>Recoil</p> <ul> <li>Best For: Medium to large applications.</li> <li>Use Case: Efficient local and global state management with an intuitive API.</li> </ul> </li> <li> <p>MobX</p> <ul> <li>Best For: Reactive programming needs.</li> <li>Use Case: Applications requiring automatic UI updates with minimal boilerplate.</li> </ul> </li> </ul>"},{"location":"frontend/router/docs/auth-techniques/#3-advanced-state-management-techniques","title":"3. Advanced State Management Techniques","text":"<ul> <li> <p>Redux</p> <ul> <li>Best For: Large applications with complex state management.</li> <li>Use Case: Centralized state management, especially when using middleware for async actions.</li> </ul> </li> </ul>"},{"location":"frontend/router/docs/auth-techniques/#4-server-dependent-techniques","title":"4. Server-Dependent Techniques","text":"<ul> <li> <p>React Query</p> <ul> <li>Best For: Data-heavy applications.</li> <li>Use Case: Efficient data fetching, caching, and synchronizing server data alongside authentication.</li> </ul> </li> <li> <p>Firebase Authentication</p> <ul> <li>Best For: Easy and secure user authentication.</li> <li>Use Case: Applications needing quick integration of various authentication methods (Google, email/password).</li> </ul> </li> </ul>"},{"location":"frontend/router/docs/auth-techniques/#summary-table","title":"Summary Table","text":"Category Technique Best For Use Case Simple State Management Context API Small to medium apps State sharing without prop drilling Zustand Lightweight apps Simple and fast state management Intermediate State Management Recoil Medium to large apps Local and global state management MobX Reactive programming Automatic UI updates with minimal boilerplate Advanced State Management Redux Large apps with complex state Centralized state management Server-Dependent Techniques React Query Data-heavy apps Efficient data fetching and caching Firebase Authentication Easy and secure user auth Quick integration of authentication methods"},{"location":"frontend/router/docs/auth-techniques/#conclusion","title":"Conclusion","text":"<p>By categorizing these techniques, you can better recall which method to use based on your project's size, complexity, and specific requirements. This structure makes it easier to remember the right tools for different scenarios in React applications!</p>"},{"location":"frontend/router/docs/best-method-for-auth/","title":"Best Method","text":"<p>The \"best\" method for implementing login and logout functionality in a React application depends on several factors, including the project's complexity, your team's familiarity with the technologies, and the specific requirements of the application. Here's a breakdown to help you choose the most suitable approach:</p>"},{"location":"frontend/router/docs/best-method-for-auth/#1-simple-applications","title":"1. Simple Applications","text":"<ul> <li>Best Method: Context API with Custom Hooks</li> <li>Why: For smaller apps, using the Context API with custom hooks is straightforward, requires minimal setup, and keeps the code clean. It's easy to understand and maintain.</li> </ul>"},{"location":"frontend/router/docs/best-method-for-auth/#2-medium-to-large-applications","title":"2. Medium to Large Applications","text":"<ul> <li>Best Method: Redux with Middleware (e.g., Redux Thunk)</li> <li>Why: If your application has multiple interconnected states and requires complex state management, Redux is a robust solution. It provides a clear structure for managing authentication alongside other global states, with middleware allowing for handling asynchronous actions like API calls.</li> </ul>"},{"location":"frontend/router/docs/best-method-for-auth/#3-reactive-applications","title":"3. Reactive Applications","text":"<ul> <li>Best Method: MobX</li> <li>Why: If you prefer a more reactive and less boilerplate-heavy approach, MobX is excellent for managing authentication state in a simpler manner. It's particularly beneficial for applications that require frequent state updates.</li> </ul>"},{"location":"frontend/router/docs/best-method-for-auth/#4-data-driven-applications","title":"4. Data-Driven Applications","text":"<ul> <li>Best Method: React Query</li> <li>Why: If your app heavily relies on data fetching, using React Query can simplify authentication as part of your data management strategy. It automatically handles caching, loading, and error states, making it efficient for managing authentication requests.</li> </ul>"},{"location":"frontend/router/docs/best-method-for-auth/#5-full-featured-authentication-solutions","title":"5. Full-Featured Authentication Solutions","text":"<ul> <li>Best Method: Firebase Authentication or Auth0</li> <li>Why: If you need a robust, secure, and scalable solution with built-in user management, using Firebase or Auth0 is ideal. They provide a wide range of authentication methods and handle security concerns, allowing you to focus on the frontend.</li> </ul>"},{"location":"frontend/router/docs/best-method-for-auth/#summary","title":"Summary","text":"<ul> <li>For Simplicity: Context API is great for small projects.</li> <li>For Complexity: Redux is best for larger, more complex applications.</li> <li>For Reactivity: MobX is good for applications needing frequent state updates.</li> <li>For Data Focus: React Query excels in data-driven contexts.</li> <li>For Full Solutions: Firebase and Auth0 are excellent for ready-made authentication systems.</li> </ul> <p>Ultimately, the choice should align with your team's skills, project needs, and how you foresee the application scaling in the future. If unsure, starting with the Context API for smaller projects and transitioning to Redux or a third-party service as complexity grows is a sound strategy.</p>"},{"location":"frontend/router/docs/not-found-component/","title":"Not Found","text":"<p>Here\u2019s an example of how you might implement a simple <code>NotFound</code> component to be used with a catch-all route in React Router v6.</p>"},{"location":"frontend/router/docs/not-found-component/#example","title":"Example","text":"NotFound ComponentUsage in Your RoutesExplanation <pre><code>import React from 'react';\n\nconst NotFound = () =&gt; {\n    return (\n        &lt;div style={{ textAlign: 'center', marginTop: '50px' }}&gt;\n            &lt;h1&gt;404 - Page Not Found&lt;/h1&gt;\n            &lt;p&gt;Sorry, the page you are looking for does not exist.&lt;/p&gt;\n            &lt;a href=\"/\"&gt;Go to Homepage&lt;/a&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default NotFound;\n</code></pre> <p>You can then use this <code>NotFound</code> component in your routing setup like this:</p> <pre><code>import React from 'react';\nimport { BrowserRouter as Router, Routes, Route } from 'react-router-dom';\nimport About from './About'; // Your About component\nimport Home from './Home';   // Your Home component\nimport NotFound from './NotFound'; // Your NotFound component\n\nconst App = () =&gt; {\n    return (\n        &lt;Router&gt;\n            &lt;Routes&gt;\n                &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n                &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n                &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt; {/* Catch-all route */}\n            &lt;/Routes&gt;\n        &lt;/Router&gt;\n    );\n};\n\nexport default App;\n</code></pre> <ul> <li>NotFound Component: This component simply displays a message and provides a link to return to the homepage.</li> <li>Catch-All Route: The <code>path=\"*\"</code> route captures any undefined paths and renders the <code>NotFound</code> component, ensuring users have feedback when they navigate to a nonexistent route.</li> </ul> <p>This setup provides a user-friendly experience by guiding users back to valid pages!</p>"},{"location":"frontend/router/docs/not-found-component/#folder-struture","title":"Folder Struture","text":"<p>Here\u2019s a suggested folder structure for a React application that includes a NotFound component. This structure promotes organization and scalability:</p> Suggested Folder StructureExplanation of Structure <pre><code>/my-react-app\n\u2502\n\u251c\u2500\u2500 /public\n\u2502   \u251c\u2500\u2500 index.html\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u251c\u2500\u2500 /src\n\u2502   \u251c\u2500\u2500 /components\n\u2502   \u2502   \u251c\u2500\u2500 About.jsx\n\u2502   \u2502   \u251c\u2500\u2500 Home.jsx\n\u2502   \u2502   \u2514\u2500\u2500 NotFound.jsx   // Store your NotFound component here\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 /pages             // Optional: for more complex structures\n\u2502   \u2502   \u251c\u2500\u2500 AboutPage.jsx\n\u2502   \u2502   \u2514\u2500\u2500 HomePage.jsx\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 /styles            // Optional: for CSS or styled components\n\u2502   \u2502   \u2514\u2500\u2500 App.css\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 App.jsx\n\u2502   \u251c\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u251c\u2500\u2500 package.json\n\u2514\u2500\u2500 ...\n</code></pre> <ul> <li><code>/public</code>: Contains static assets and the main HTML file.</li> <li><code>/src</code>: Main source folder for your application.<ul> <li><code>/components</code>: This folder holds your React components, including the <code>NotFound</code> component.</li> <li><code>/pages</code>: (Optional) Useful if you want to separate different pages of your app into their own components, enhancing organization.</li> <li><code>/styles</code>: (Optional) Store your CSS or styled components here.</li> <li><code>App.jsx</code>: The main application file where you can set up your routes.</li> <li><code>index.js</code>: The entry point of your React application.</li> </ul> </li> </ul> <p>By organizing your components this way, you can easily manage and locate your files as your application grows!</p>"},{"location":"frontend/router/docs/not-found-component/#advanced","title":"Advanced","text":"<p>Here\u2019s a more advanced example of a React application that uses the <code>NotFound</code> component along with several routes, including nested routes, dynamic routing, and a simple layout.</p> <p>Folder Structure</p> <pre><code>/my-react-app\n\u2502\n\u251c\u2500\u2500 /public\n\u2502   \u251c\u2500\u2500 index.html\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u251c\u2500\u2500 /src\n\u2502   \u251c\u2500\u2500 /components\n\u2502   \u2502   \u251c\u2500\u2500 About.jsx\n\u2502   \u2502   \u251c\u2500\u2500 Home.jsx\n\u2502   \u2502   \u251c\u2500\u2500 NotFound.jsx\n\u2502   \u2502   \u251c\u2500\u2500 Navbar.jsx\n\u2502   \u2502   \u2514\u2500\u2500 UserProfile.jsx\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 /pages\n\u2502   \u2502   \u251c\u2500\u2500 AboutPage.jsx\n\u2502   \u2502   \u2514\u2500\u2500 HomePage.jsx\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 /styles\n\u2502   \u2502   \u2514\u2500\u2500 App.css\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 App.jsx\n\u2502   \u251c\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 ...\n</code></pre> <p>Example</p> index.jsApp.jsxNavbar.jsxHomePage.jsxAboutPage.jsxUserProfile.jsxNotFound.jsx <pre><code>import React from \"react\";\nimport ReactDOM from \"react-dom/client\";\nimport App from \"./App\";\nimport \"./styles/App.css\";\n\nconst root = ReactDOM.createRoot(document.getElementById(\"root\"));\nroot.render(&lt;App /&gt;);\n</code></pre> <pre><code>import React from \"react\";\nimport { BrowserRouter as Router, Routes, Route } from \"react-router-dom\";\nimport HomePage from \"./pages/HomePage\";\nimport AboutPage from \"./pages/AboutPage\";\nimport NotFound from \"./components/NotFound\";\nimport Navbar from \"./components/Navbar\";\n\nconst App = () =&gt; {\n    return (\n        &lt;Router&gt;\n            &lt;Navbar /&gt;\n            &lt;Routes&gt;\n                &lt;Route path=\"/\" element={&lt;HomePage /&gt;} /&gt;\n                &lt;Route path=\"/about\" element={&lt;AboutPage /&gt;} /&gt;\n                &lt;Route path=\"/user/:id\" element={&lt;UserProfile /&gt;} /&gt;\n                &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt; {/* Catch-all route */}\n            &lt;/Routes&gt;\n        &lt;/Router&gt;\n    );\n};\n\nexport default App;\n</code></pre> <pre><code>import React from \"react\";\nimport { Link } from \"react-router-dom\";\n\nconst Navbar = () =&gt; {\n    return (\n        &lt;nav&gt;\n            &lt;Link to=\"/\"&gt;Home&lt;/Link&gt;\n            &lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n            &lt;Link to=\"/user/1\"&gt;User 1 Profile&lt;/Link&gt;\n            &lt;Link to=\"/user/2\"&gt;User 2 Profile&lt;/Link&gt;\n        &lt;/nav&gt;\n    );\n};\n\nexport default Navbar;\n</code></pre> <pre><code>import React from \"react\";\n\nconst HomePage = () =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Welcome to the Home Page!&lt;/h1&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default HomePage;\n</code></pre> <pre><code>import React from \"react\";\n\nconst AboutPage = () =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;About Us&lt;/h1&gt;\n            &lt;p&gt;This is the about page.&lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default AboutPage;\n</code></pre> <pre><code>import React from \"react\";\nimport { useParams } from \"react-router-dom\";\n\nconst UserProfile = () =&gt; {\n    const { id } = useParams();\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;User Profile&lt;/h1&gt;\n            &lt;p&gt;Displaying profile for user ID: {id}&lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default UserProfile;\n</code></pre> <pre><code>import React from \"react\";\n\nconst NotFound = () =&gt; {\n    return (\n        &lt;div style={{ textAlign: \"center\", marginTop: \"50px\" }}&gt;\n            &lt;h1&gt;404 - Page Not Found&lt;/h1&gt;\n            &lt;p&gt;Sorry, the page you are looking for does not exist.&lt;/p&gt;\n            &lt;a href=\"/\"&gt;Go to Homepage&lt;/a&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default NotFound;\n</code></pre> <p>Explanation</p> <ol> <li>Routing Setup: The <code>App</code> component uses <code>BrowserRouter</code> to wrap the application and Routes to define paths.</li> <li>Dynamic Routing: The <code>UserProfile</code> component uses <code>useParams</code> to extract the user ID from the URL.</li> <li>Catch-All Route: The route <code>path=\"*\"</code> ensures that any undefined paths render the <code>NotFound</code> component.</li> <li>Navigation: The <code>Navbar</code> component provides links to navigate between the home page, about page, and user profiles.</li> </ol> <p>This setup showcases a more advanced application structure with routing, making it easier to manage and expand as your application grows!</p>"},{"location":"frontend/router/docs/react-router/","title":"React Router","text":"<p>React Router is a library that enables routing in React applications. It allows you to create single-page applications with navigation and different views without reloading the page. With React Router, you can define routes in your app, manage navigation, and render specific components based on the current URL.</p> <p>Since you've created a React app using npx create-react-app, you'll need to install React Router separately, as it's not included by default. You can install it using npm:</p> <pre><code>npm install react-router-dom\n</code></pre>"},{"location":"frontend/router/docs/react-router/#what-react-router-does","title":"What React Router Does:","text":"<ul> <li>Routing: Maps URLs to components, allowing different components to render based on the current path.</li> <li>Navigation: Provides components like <code>&lt;Link&gt;</code> and <code>&lt;NavLink&gt;</code> for navigation without full page reloads.</li> <li>Dynamic Routing: Supports parameters in routes, enabling you to create dynamic routes based on data.</li> <li>Nested Routes: Allows you to nest routes for better organization of your components.</li> <li>Programmatic Navigation: Offers functionality to navigate programmatically using hooks like <code>useNavigate</code>.</li> </ul> Basic Example <p>Here\u2019s a simple example to illustrate how to use React Router:</p> <ol> <li>Install it (as mentioned above).</li> <li> <p>Create some basic components:</p> <pre><code>// Home.js\nconst Home = () =&gt; &lt;h2&gt;Home&lt;/h2&gt;;\n\n// About.js\nconst About = () =&gt; &lt;h2&gt;About&lt;/h2&gt;;\n</code></pre> </li> <li> <p>Set up routing in your main component (e.g., <code>App.js</code>):</p> <pre><code>import { BrowserRouter as Router, Routes, Route, Link } from 'react-router-dom';\nimport Home from './Home';\nimport About from './About';\n\nfunction App() {\n    return (\n        &lt;Router&gt;\n            &lt;nav&gt;\n                &lt;Link to=\"/\"&gt;Home&lt;/Link&gt;\n                &lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n            &lt;/nav&gt;\n            &lt;Routes&gt;\n                &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n                &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n            &lt;/Routes&gt;\n        &lt;/Router&gt;\n    );\n}\n\nexport default App;\n</code></pre> <p>This example sets up a basic navigation between a home page and an about page. When you click the links, React Router will render the corresponding component without reloading the page.</p> </li> </ol>"},{"location":"frontend/router/docs/router-version/","title":"Version","text":"<ul> <li>React Router v4 - October 2017</li> <li>React Router v5 - February 2019</li> <li>React Router v6 - November 2021</li> <li>React Router v6.4 - June 2022</li> <li>React Router v6.8 - August 2023</li> </ul>"},{"location":"frontend/router/docs/router-version/#major-updates","title":"Major Updates","text":"<p>Here are the major updates from the key React Router versions that you should remember:</p> React Router v4React Router v5React Router v6React Router v6.4React Router v6.8 <ul> <li>Component-based API: Introduced a declarative way to define routes using components.</li> <li>Nested Routes: Allowed for easier management of nested routing.</li> <li> <p>Key Update: Component-based API and Nested Routes</p> Example<pre><code>import { BrowserRouter as Router, Route, Link } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;nav&gt;\n            &lt;Link to=\"/\"&gt;Home&lt;/Link&gt;\n            &lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n        &lt;/nav&gt;\n        &lt;Route path=\"/\" exact component={Home} /&gt;\n        &lt;Route path=\"/about\" component={About} /&gt;\n    &lt;/Router&gt;\n);\n</code></pre> </li> </ul> <ul> <li>Hooks: Introduced <code>useParams</code>, <code>useLocation</code>, and other hooks for better access to routing data.</li> <li>Improved Redirects: Added more control over route rendering with props on <code>&lt;Route&gt;</code>.</li> <li> <p>Key Update: Hooks (<code>useParams</code>, <code>useLocation</code>)</p> Example<pre><code>import { BrowserRouter as Router, Route, Link, useParams } from 'react-router-dom';\n\nconst User = () =&gt; {\n    const { id } = useParams();\n    return &lt;h2&gt;User ID: {id}&lt;/h2&gt;;\n};\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;nav&gt;\n            &lt;Link to=\"/user/1\"&gt;User 1&lt;/Link&gt;\n        &lt;/nav&gt;\n        &lt;Route path=\"/user/:id\" component={User} /&gt;\n    &lt;/Router&gt;\n);\n</code></pre> </li> </ul> <ul> <li><code>Routes</code> Component: Replaced <code>Switch</code> for improved route matching.</li> <li>Route Ranking: Enhanced routing logic for better performance.</li> <li>Nested Routes: Simplified nested route definitions.</li> <li> <p>Key Update: <code>Routes</code> Component and Route Ranking</p> Example<pre><code>import { BrowserRouter as Router, Routes, Route, Link } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;nav&gt;\n            &lt;Link to=\"/\"&gt;Home&lt;/Link&gt;\n            &lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n        &lt;/nav&gt;\n        &lt;Routes&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n        &lt;/Routes&gt;\n    &lt;/Router&gt;\n);\n</code></pre> </li> </ul> <ul> <li>Data APIs: Introduced loaders and actions for handling data fetching directly in routes.</li> <li>Layout Routes: Enhanced support for layouts in nested routes.</li> <li> <p>Key Update: Data APIs (Loaders and Actions)</p> Example<pre><code>import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';\n\nconst loader = async () =&gt; {\n    const data = await fetch('/api/data'); // Fetch data\n    return data.json();\n};\n\nconst DataComponent = () =&gt; {\n    // Use data in your component\n};\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Routes&gt;\n            &lt;Route path=\"/data\" element={&lt;DataComponent /&gt;} loader={loader} /&gt;\n        &lt;/Routes&gt;\n    &lt;/Router&gt;\n);\n</code></pre> </li> </ul> <ul> <li>Refinements: Continued improvements based on user feedback, focusing on data handling and route management.</li> <li> <p>Key Update: Refinements for improved data handling</p> <p><code>(Similar to v6.4 but with more refined API usage)</code></p> Example<pre><code>import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Routes&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n            &lt;Route path=\"/data\" element={&lt;DataComponent /&gt;} loader={loader} /&gt;\n        &lt;/Routes&gt;\n    &lt;/Router&gt;\n);\n</code></pre> </li> </ul>"},{"location":"frontend/router/docs/router-version/#additional","title":"Additional","text":"<p>In React Router v6, the <code>Routes</code> component replaced the <code>Switch</code> component from previous versions, and this change brought several improvements in how route matching works. Here\u2019s what it means:</p> <ol> <li> <p>Improved Route Matching</p> <ul> <li>Order of Matching:</li> </ul> <p>With <code>Switch</code>, the first route that matched was rendered, which could lead to issues if more specific routes were placed after more general ones. The new <code>Routes</code> component performs better by automatically ranking routes, meaning it will always match the most specific route first.</p> <ul> <li>Simplified Syntax:</li> </ul> <p><code>Routes</code> allows you to define routes using the <code>element</code> prop directly, making the syntax cleaner and easier to read.</p> Using <code>Switch</code> (v5)Using Routes (v6) <pre><code>import { BrowserRouter as Router, Switch, Route } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Switch&gt;\n            &lt;Route path=\"/about\" component={About} /&gt;\n            &lt;Route path=\"/\" component={Home} /&gt;\n        &lt;/Switch&gt;\n    &lt;/Router&gt;\n);\n</code></pre> <p>In this example, if you navigate to <code>/</code>, the <code>Home</code> component will render because it's matched first. However, if you had a more specific route, such as <code>/about</code>, it could potentially lead to unexpected behavior if not ordered correctly.</p> <pre><code>import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Routes&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n        &lt;/Routes&gt;\n    &lt;/Router&gt;\n);\n</code></pre> <p>In this version with <code>Routes</code>, it handles matching more efficiently. It automatically prioritizes more specific paths, so you can be confident that the correct component will render based on the current URL.</p> </li> <li> <p>No Need for <code>exact</code></p> <p>In <code>v5</code>, you often had to use the <code>exact</code> prop to ensure that a route only matched when the path was exactly as specified. With <code>Routes</code>, the matching logic is more intuitive, and <code>exact</code> is no longer necessary.</p> </li> </ol> <p>Conclusion</p> <p>Overall, the shift from Switch to Routes in React Router v6 enhances route handling by making it more efficient, reducing potential errors, and simplifying the syntax for developers.</p>"},{"location":"frontend/router/docs/router-version/#route-ordering","title":"Route Ordering","text":""},{"location":"frontend/router/docs/router-version/#before-v6","title":"Before v6","text":"<p>Before React Router v6, specifically in versions 4 and 5, the order of matching was important when using the <code>Switch</code> component. Here's how it worked:</p> Key Points on Order of Matching with Switch <ol> <li> <p>First Match Wins:</p> <ul> <li>The <code>Switch</code> component rendered the first <code>&lt;Route&gt;</code> that matched the current location. This meant that if you had more specific routes after less specific ones, those specific routes would never be reached because the first matching route would take precedence.</li> </ul> </li> <li> <p>Using <code>exact</code>:</p> <ul> <li>To prevent more general routes from matching, you often had to use the <code>exact</code> prop. This ensured that a route only matched if the path was exactly as specified.</li> </ul> </li> </ol> <p>Example</p> <p>Here's a demonstration of the matching behavior with <code>Switch</code>:</p> Incorrect Order Without <code>exact</code>Correct Order With <code>exact</code> <pre><code>import { BrowserRouter as Router, Switch, Route } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Switch&gt;\n            &lt;Route path=\"/about\" component={About} /&gt;\n            &lt;Route path=\"/\" component={Home} /&gt;\n        &lt;/Switch&gt;\n    &lt;/Router&gt;\n);\n</code></pre> <ul> <li>If you navigate to <code>/</code>, this setup would render the <code>Home</code> component, and the <code>About</code> route would never be reached because it comes after the <code>/</code> route.</li> </ul> <pre><code>import { BrowserRouter as Router, Switch, Route } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Switch&gt;\n            &lt;Route path=\"/about\" component={About} /&gt;\n            &lt;Route path=\"/\" exact component={Home} /&gt;\n        &lt;/Switch&gt;\n    &lt;/Router&gt;\n);\n</code></pre> <ul> <li>In this setup, using exact on the <code>/</code> route means it will only match when the path is exactly <code>/</code>. This allows the <code>/about</code> route to be matched correctly when you navigate to <code>/about</code>.</li> </ul> <p>Conclusion</p> <p>In summary, before v6, the order of routes and the use of the <code>exact</code> prop were crucial for ensuring the correct component rendered based on the URL. With the introduction of <code>Routes</code> in v6, these concerns have largely been alleviated, allowing for more intuitive and error-free routing!</p> <p>Sure! Here\u2019s an example of a React Router setup with multiple routes using Switch in versions 4 or 5. I'll illustrate how to properly order them to ensure the correct components render.</p> <p>Example with Multiple Routes</p> <p>Let\u2019s consider a scenario where we have the following components:</p> <ul> <li><code>Home</code></li> <li><code>About</code></li> <li><code>Contact</code></li> <li><code>AboutDetails</code></li> <li><code>UserProfile</code></li> </ul> ComponentsProper Ordering with <code>Switch</code>Explanation of Route OrderingConclusion <pre><code>// Home.js\nconst Home = () =&gt; &lt;h2&gt;Home&lt;/h2&gt;;\n\n// About.js\nconst About = () =&gt; &lt;h2&gt;About&lt;/h2&gt;;\n\n// Contact.js\nconst Contact = () =&gt; &lt;h2&gt;Contact&lt;/h2&gt;;\n\n// AboutDetails.js\nconst AboutDetails = () =&gt; &lt;h2&gt;About Details&lt;/h2&gt;;\n\n// UserProfile.js\nconst UserProfile = () =&gt; &lt;h2&gt;User Profile&lt;/h2&gt;;\n</code></pre> <pre><code>import { BrowserRouter as Router, Switch, Route, Link } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;nav&gt;\n            &lt;Link to=\"/\"&gt;Home&lt;/Link&gt;\n            &lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n            &lt;Link to=\"/contact\"&gt;Contact&lt;/Link&gt;\n            &lt;Link to=\"/about/details\"&gt;About Details&lt;/Link&gt;\n            &lt;Link to=\"/user/john\"&gt;User Profile&lt;/Link&gt;\n        &lt;/nav&gt;\n\n        &lt;Switch&gt;\n            {/* Specific routes should come first */}\n            &lt;Route path=\"/about/details\" component={AboutDetails} /&gt;\n            &lt;Route path=\"/about\" component={About} /&gt;\n            &lt;Route path=\"/contact\" component={Contact} /&gt;\n            &lt;Route path=\"/user/:username\" component={UserProfile} /&gt;\n\n            {/* This should be the last route to match the root path */}\n            &lt;Route path=\"/\" exact component={Home} /&gt;\n        &lt;/Switch&gt;\n    &lt;/Router&gt;\n);\n</code></pre> <ol> <li> <p>Specific Routes First:</p> <ul> <li>The <code>/about/details</code> route is placed first because it is more specific than the <code>/about</code> route. If you placed <code>/about</code> first, navigating to <code>/about/details</code> would incorrectly render the About component.</li> </ul> </li> <li> <p>General Routes Last:</p> <ul> <li>The root path (<code>/</code>) is placed last. If it were placed earlier, it would match any path and render the <code>Home</code> component, preventing any of the more specific routes from rendering.</li> </ul> </li> <li> <p>Using <code>exact</code>:</p> <ul> <li>The <code>exact</code> prop on the root path (<code>/</code>) ensures it only matches the exact URL <code>/</code>, allowing all other routes to be matched properly without interference.</li> </ul> </li> </ol> <p>This setup demonstrates how to structure and order your routes effectively using the <code>Switch</code> component before React Router v6. Proper ordering is crucial to ensure that the intended components render based on the URL, especially when dealing with multiple routes and nested paths!</p>"},{"location":"frontend/router/docs/router-version/#after-v6","title":"After v6","text":"<p>In React Router v6, you do not need to worry about the order of matching in the same way you did in previous versions with Switch. Here\u2019s why:</p> Automatic Route Ranking <ul> <li> <p>Specificity:</p> <p>React Router v6 automatically ranks routes based on their specificity. This means that it will match the most specific route first, regardless of the order you define them in your <code>Routes</code>.</p> </li> <li> <p>No Need for <code>exact</code>:</p> <p>Unlike in v5, where you often had to use the <code>exact</code> prop to avoid unintentional matches, v6 handles this internally. A route will only match if it corresponds precisely to the current URL.</p> </li> </ul> Example <p>Here\u2019s an example to illustrate this:</p> <pre><code>import { BrowserRouter as Router, Routes, Route } from \"react-router-dom\";\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Routes&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/about/details\" element={&lt;AboutDetails /&gt;} /&gt;\n        &lt;/Routes&gt;\n    &lt;/Router&gt;\n);\n</code></pre> <p>In this case:</p> <ul> <li>If you navigate to <code>/about/details</code>, it will render the <code>AboutDetails</code> component.</li> <li>If you navigate to <code>/about</code>, it will render the <code>About</code> component.</li> <li>If you navigate to <code>/</code>, it will render the <code>Home</code> component.</li> </ul> <p>Conclusion</p> <p>You can define your routes in any order, and React Router v6 will ensure that the correct component is rendered based on the URL, making it easier to manage your routes without worrying about their sequence. This significantly simplifies routing logic and reduces the potential for errors!</p>"},{"location":"frontend/router/docs/routing/","title":"Routing","text":"<p>Routing logic in web applications defines how different URLs (or paths) correspond to various components or views in the application. In React, this is primarily handled by libraries like react-router-dom.</p> <pre><code>-   Basic Routing\n-   Dynamic Routing\n-   Nested Routes\n-   Redirects\n-   Protected Routes\n-   404 Handling\n-   Lazy Loading\n-   History Management\n-   Custom Hooks for Routing\n-   Route Guards\n</code></pre> Install React Router <p>First, ensure you have <code>react-router-dom</code> installed:</p> <pre><code>npm install react-router-dom\n</code></pre> <p>Here are some key concepts and techniques related to routing logic:</p>"},{"location":"frontend/router/docs/routing/#1-basic-routing","title":"1. Basic Routing","text":"<ul> <li> <p>Single Page Application (SPA): In SPAs, routing is done client-side. The browser loads a single HTML page and JavaScript takes care of changing views without reloading the page.</p> </li> <li> <p>Route Definition: Routes are defined to map URL paths to React components, usually using <code>&lt;Route&gt;</code> components. Each route specifies a <code>path</code> and the corresponding <code>element</code> to render.</p> </li> </ul> AppRoutes.js (Basic Example) <pre><code>import React from 'react';\nimport { Routes, Route } from 'react-router-dom';\nimport Home from '../components/Home/Home';\nimport About from '../components/About/About';\nimport NotFound from '../components/NotFound/NotFound';\n\nconst AppRoutes = () =&gt; {\n    return (\n        &lt;Routes&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n            &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt;\n        &lt;/Routes&gt;\n    );\n};\n\nexport default AppRoutes;\n</code></pre>"},{"location":"frontend/router/docs/routing/#2-dynamic-routing","title":"2. Dynamic Routing","text":"<ul> <li>Route Parameters: You can create dynamic routes that accept parameters. For example, <code>/user/:id</code> can capture the <code>id</code> of a user, allowing you to render user-specific components based on the URL.</li> </ul> User.js (Dynamic Example) <pre><code>import React from 'react';\nimport { useParams } from 'react-router-dom';\n\nconst User = () =&gt; {\n    const { id } = useParams(); // Fetching dynamic parameter\n    return &lt;h1&gt;User Profile: {id}&lt;/h1&gt;;\n};\n\nexport default User;\n</code></pre>"},{"location":"frontend/router/docs/routing/#3-nested-routes","title":"3. Nested Routes","text":"<ul> <li>Hierarchy: You can have routes within routes, enabling more complex structures. This is useful for layouts where certain components (like a sidebar or header) are always present.</li> </ul> AppRoutes.js (Advanced with Nested Routes) <pre><code>import User from '../components/User/User';\nimport UserProfile from '../components/User/UserProfile';\n\nconst AppRoutes = () =&gt; {\n    return (\n        &lt;Routes&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n            &lt;Route path=\"/user/:id\" element={&lt;User /&gt;}&gt;\n                &lt;Route path=\"profile\" element={&lt;UserProfile /&gt;} /&gt; {/* Nested route */}\n            &lt;/Route&gt;\n            &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt;\n        &lt;/Routes&gt;\n    );\n};\n</code></pre>"},{"location":"frontend/router/docs/routing/#4-redirects","title":"4. Redirects","text":"<ul> <li>Redirecting Users: You can use redirect logic to send users to different paths based on certain conditions, like authentication status or specific URL patterns.</li> </ul> AppRoutes.js (Redirect Example) <p>You can use <code>&lt;Navigate /&gt;</code> for redirects:</p> <pre><code>import { Navigate } from 'react-router-dom';\n\nconst AppRoutes = () =&gt; {\n    return (\n        &lt;Routes&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n            &lt;Route path=\"/old-path\" element={&lt;Navigate to=\"/new-path\" replace /&gt;} /&gt;\n            &lt;Route path=\"/user/:id\" element={&lt;User /&gt;} /&gt;\n            &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt;\n        &lt;/Routes&gt;\n    );\n};\n</code></pre>"},{"location":"frontend/router/docs/routing/#5-protected-routes","title":"5. Protected Routes","text":"<ul> <li>Authentication Checks: Certain routes can be protected, requiring users to be authenticated. You can create higher-order components (HOCs) or render logic that checks authentication before allowing access.</li> </ul> AuthContext.jsProtectedRoute.jsAdmin.jsAppRoutes.js <pre><code>import React, { createContext, useContext, useState } from \"react\";\n\nconst AuthContext = createContext();\n\nexport const AuthProvider = ({ children }) =&gt; {\n    const [isAuthenticated, setIsAuthenticated] = useState(false);\n\n    const login = () =&gt; setIsAuthenticated(true);\n    const logout = () =&gt; setIsAuthenticated(false);\n\n    return (\n        &lt;AuthContext.Provider value={{ isAuthenticated, login, logout }}&gt;\n            {children}\n        &lt;/AuthContext.Provider&gt;\n    );\n};\n\nexport const useAuth = () =&gt; useContext(AuthContext);\n</code></pre> <pre><code>import React from 'react';\nimport { Navigate } from 'react-router-dom';\nimport { useAuth } from '../context/AuthContext';\n\nconst ProtectedRoute = ({ element }) =&gt; {\n    const { isAuthenticated } = useAuth();\n    return isAuthenticated ? element : &lt;Navigate to=\"/\" /&gt;;\n};\n\nexport default ProtectedRoute;\n</code></pre> <p><code>Admin.js</code> (Protected Route Example)</p> <pre><code>import React from 'react';\n\nconst Admin = () =&gt; {\n    return &lt;h1&gt;Admin Page - Access Restricted&lt;/h1&gt;;\n};\n</code></pre> <p><code>AppRoutes.js</code> (Including Protected Routes)</p> <pre><code>import ProtectedRoute from '../components/ProtectedRoute';\nimport Admin from '../components/Admin/Admin';\n\nconst AppRoutes = () =&gt; {\n    return (\n        &lt;Routes&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n            &lt;Route path=\"/admin\" element={&lt;ProtectedRoute element={&lt;Admin /&gt;} /&gt;} /&gt;\n            &lt;Route path=\"/user/:id\" element={&lt;User /&gt;} /&gt;\n            &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt;\n        &lt;/Routes&gt;\n    );\n};\n</code></pre>"},{"location":"frontend/router/docs/routing/#6-404-not-found-routes","title":"6. 404 Not Found Routes","text":"<ul> <li>Catch-All Route: A route can be defined to catch all unmatched paths, typically rendering a \"Not Found\" component. This helps in providing a better user experience for invalid URLs.</li> </ul> Example <p>This is already covered in the earlier examples, but the wildcard route (<code>path=\"*\"</code>) ensures that any unmatched route renders the <code>NotFound</code> component.</p>"},{"location":"frontend/router/docs/routing/#7-lazy-loading-routes","title":"7. Lazy Loading Routes","text":"<ul> <li>Code Splitting: Use React\u2019s <code>lazy</code> and <code>Suspense</code> to load components only when needed, improving initial load times. This is particularly useful for larger applications with many routes.</li> </ul> User.js (Lazy Loading Example) <p>You can use <code>React.lazy</code> to lazily load components.</p> <pre><code>import React, { lazy, Suspense } from 'react';\n\nconst UserProfile = lazy(() =&gt; import('./UserProfile'));\n\nconst User = () =&gt; {\n    return (\n        &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;\n            &lt;UserProfile /&gt;\n        &lt;/Suspense&gt;\n    );\n};\n</code></pre>"},{"location":"frontend/router/docs/routing/#8-history-management","title":"8. History Management","text":"<ul> <li>Browser History: React Router uses the browser's history API to manage navigation. This allows for back and forward navigation without reloading the page.</li> </ul> <p>react-router-dom handles browser history automatically, allowing for back and forward navigation. You can also use <code>useNavigate</code> for programmatic navigation.</p> Example of <code>useNavigate</code> <pre><code>import { useNavigate } from 'react-router-dom';\n\nconst SomeComponent = () =&gt; {\n    const navigate = useNavigate();\n\n    const handleClick = () =&gt; {\n        navigate('/about'); // Programmatically navigate to about\n    };\n\n    return &lt;button onClick={handleClick}&gt;Go to About&lt;/button&gt;;\n};\n</code></pre>"},{"location":"frontend/router/docs/routing/#9-custom-route-logic","title":"9. Custom Route Logic","text":"<ul> <li>Custom Hooks: You can create custom hooks for complex routing logic, like checking user roles or fetching data before rendering a route.</li> </ul> useCurrentPath.js <p>You can create custom hooks to access the current path.</p> <pre><code>import { useLocation } from 'react-router-dom';\n\nconst useCurrentPath = () =&gt; {\n    const location = useLocation();\n    return location.pathname;\n};\n\nexport default useCurrentPath;\n</code></pre>"},{"location":"frontend/router/docs/routing/#10-using-route-guards","title":"10. Using Route Guards","text":"<ul> <li>Authorization Checks: Implement route guards to restrict access to certain components based on user roles or permissions, enhancing security in your application</li> </ul> Custom Guard Example <p>You can create more complex guards using custom logic.</p> <pre><code>import { Navigate } from 'react-router-dom';\n\nconst RoleBasedRoute = ({ element, allowedRoles }) =&gt; {\n    const { userRole } = useAuth(); // Assume you have user roles in context\n    return allowedRoles.includes(userRole) ? element : &lt;Navigate to=\"/\" /&gt;;\n};\n</code></pre> <p>Final Setup in <code>App.js</code></p> App.js<pre><code>import React from \"react\";\nimport { BrowserRouter as Router } from \"react-router-dom\";\nimport Navbar from \"./components/Navbar/Navbar\";\nimport AppRoutes from \"./routes/AppRoutes\";\nimport { AuthProvider } from \"./context/AuthContext\";\n\nfunction App() {\n  return (\n    &lt;AuthProvider&gt;\n      &lt;Router&gt;\n        &lt;div className=\"App\"&gt;\n          &lt;Navbar /&gt;\n          &lt;AppRoutes /&gt;\n        &lt;/div&gt;\n      &lt;/Router&gt;\n    &lt;/AuthProvider&gt;\n  );\n}\n\nexport default App;\n</code></pre>"},{"location":"frontend/router/docs/routing/#summary","title":"Summary","text":"<p>Routing logic can be simple or complex depending on the application's requirements. Understanding these techniques allows you to create more robust, maintainable, and user-friendly web applications. Here's a brief summary of techniques:</p>"},{"location":"frontend/router/docs/routing/#summary-of-concepts","title":"Summary of Concepts","text":"<ol> <li>Basic Routing: Defined straightforward paths to components.</li> <li>Dynamic Routing: Used URL parameters to dynamically render content.</li> <li>Nested Routes: Demonstrated child routes for complex layouts.</li> <li>Redirects: Redirected users based on certain conditions.</li> <li>Protected Routes: Restricted access based on authentication.</li> <li>404 Handling: Managed unmatched routes gracefully.</li> <li>Lazy Loading: Improved performance by loading components only when needed.</li> <li>History Management: Utilized the built-in browser history.</li> <li>Custom Hooks for Routing: Created reusable hooks for accessing routing data.</li> <li>Route Guards: Implemented role-based access control.</li> </ol>"},{"location":"frontend/router/docs/routing/#folder-structure","title":"Folder Structure","text":"<pre><code>/src\n  /components\n    /Navbar\n      Navbar.js\n      Navbar.css\n    /Home\n      Home.js\n    /About\n      About.js\n    /NotFound\n      NotFound.js\n    /User\n      User.js\n      UserProfile.js\n    /Admin\n      Admin.js\n  /routes\n    AppRoutes.js\n  /context\n    AuthContext.js\n  App.js\n  index.js\n</code></pre>"},{"location":"frontend/router/docs/why-react-router/","title":"Why React Router","text":"<p>React Router is beneficial for several reasons:</p> <ol> <li>Dynamic Routing: It allows you to create routes that can change based on user interaction or application state, enabling a more dynamic user experience.</li> <li>Nested Routing: You can set up nested routes, which helps maintain a clear structure in larger applications, making it easier to manage related components.</li> <li>Code Splitting: React Router supports lazy loading of routes, which improves performance by loading only the necessary code for the current view.</li> <li>Browser History Management: It simplifies managing browser history, allowing users to navigate back and forth seamlessly.</li> <li>URL Management: React Router enables clean and meaningful URLs, which is important for usability and SEO.</li> <li>Declarative Routing: You define routes in a declarative manner, which integrates well with the React component model.</li> <li>State Preservation: It allows you to maintain state across different routes, making it easier to build a consistent user experience.</li> </ol> <p>Overall, while you can build applications without it, React Router makes managing navigation and routing in React apps much easier and more efficient, especially as they grow in complexity.</p>"},{"location":"frontend/router/docs/why-react-router/#additional","title":"Additional","text":"<p>Here are some lesser-known aspects and potential pitfalls of React Router that you might want to be aware of:</p> <ol> <li> <p>Route Rendering: The way you render routes can affect your app\u2019s performance. Using <code>component</code> vs. <code>render</code> props can lead to unnecessary re-renders if not handled carefully.</p> </li> <li> <p>Data Fetching: While React Router itself doesn\u2019t handle data fetching, it\u2019s common to implement data loading in route components, which can lead to duplicated logic if not structured properly.</p> </li> <li> <p>Context Issues: If you\u2019re using multiple routers or nesting, managing context can become complex. Be cautious about how context providers interact with router components.</p> </li> <li> <p>Use of <code>Link</code>: Always use the <code>Link</code> component for navigation instead of anchor (<code>&lt;a&gt;</code>) tags. This prevents a full page reload and ensures that React Router can manage the app\u2019s history correctly.</p> </li> <li> <p>Nested Routes Complexity: While nested routes can be powerful, they can also add complexity to your routing logic. It\u2019s important to manage props and state effectively when dealing with deeply nested routes.</p> </li> <li> <p>404 Handling: Setting up a catch-all route for handling 404 pages can sometimes be overlooked, leading to a poor user experience when users navigate to nonexistent routes.</p> </li> <li> <p>Browser History Management: Understanding how React Router interacts with the browser\u2019s history stack is crucial. Mismanagement can lead to issues with the back and forward buttons.</p> </li> <li> <p>Version Changes: Keep an eye on version changes and breaking changes. React Router has gone through significant changes over versions, particularly from v5 to v6.</p> </li> <li> <p>Custom Route Matching: You can create custom route matching logic, but it can get tricky if not well-documented within your codebase.</p> </li> <li> <p>Accessibility: Ensure that your routing and navigation components are accessible, as React Router does not automatically handle ARIA roles and attributes.</p> </li> </ol> <p>Being aware of these nuances can help you use React Router more effectively and avoid common pitfalls!</p>"},{"location":"frontend/router/docs/why-react-router/#example","title":"Example","text":"<p>Sure! Here are some examples of good and bad practices with React Router:</p>"},{"location":"frontend/router/docs/why-react-router/#1-route-rendering","title":"1. Route Rendering","text":"Bad Example: Using <code>component</code> Prop <pre><code>&lt;Route path=\"/about\" component={About} /&gt;\n</code></pre> <p>This approach can lead to unnecessary re-renders if the About component's props change.</p> <p><code>Fine with v5</code></p> Good Example: Using <code>element</code> Prop (React Router v6) <pre><code>&lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n</code></pre> <p>Using the <code>element</code> prop helps maintain a clean render and optimizes performance.</p>"},{"location":"frontend/router/docs/why-react-router/#2-conditional-rendering","title":"2. Conditional Rendering","text":"Bad Example: Conditional Logic in Route Definition <pre><code>&lt;Route path=\"/profile\" render={() =&gt; user ? &lt;Profile /&gt; : &lt;Redirect to=\"/login\" /&gt;} /&gt;\n</code></pre> <p>This can be harder to read and maintain.</p> Good Example: Use a Wrapper Component <pre><code>const PrivateRoute = ({ children }) =&gt; {\n    return user ? children : &lt;Navigate to=\"/login\" /&gt;;\n};\n\n// Usage\n&lt;Route path=\"/profile\" element={&lt;PrivateRoute&gt;&lt;Profile /&gt;&lt;/PrivateRoute&gt;} /&gt;\n</code></pre> <p>This keeps your routes cleaner and separates concerns.</p>"},{"location":"frontend/router/docs/why-react-router/#3-handling-404-pages","title":"3. Handling 404 Pages","text":"Bad Example: Not Defining a Catch-All Route <p>If you forget to handle undefined routes, users might just see a blank page.</p> Good Example: Defining a Catch-All Route <pre><code>&lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt;\n</code></pre> <p>This way, users will always have feedback if they navigate to a nonexistent route.</p>"},{"location":"frontend/router/docs/why-react-router/#4-navigation-with-link","title":"4. Navigation with <code>Link</code>","text":"Bad Example: Using <code>&lt;a&gt;</code> Tag for Navigation <pre><code>&lt;a href=\"/about\"&gt;About&lt;/a&gt;\n</code></pre> <p>This causes a full page reload, losing the single-page app experience.</p> Good Example: Using <code>&lt;Link&gt;</code> <pre><code>&lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n</code></pre> <p>This enables React Router to manage navigation without reloading the page.</p>"},{"location":"frontend/router/docs/why-react-router/#5-nested-routes","title":"5. Nested Routes","text":"Bad Example: Deeply Nested Routes Without Organization <pre><code>&lt;Route path=\"/dashboard\" element={&lt;Dashboard /&gt;}&gt;\n    &lt;Route path=\"settings\" element={&lt;Settings /&gt;} /&gt;\n    &lt;Route path=\"users\" element={&lt;Users /&gt;} /&gt;\n    // more deeply nested routes...\n&lt;/Route&gt;\n</code></pre> <p>This can get confusing and hard to manage.</p> Good Example: Clear Nested Structure <pre><code>&lt;Route path=\"/dashboard/*\" element={&lt;Dashboard /&gt;}&gt;\n    &lt;Route path=\"settings\" element={&lt;Settings /&gt;} /&gt;\n    &lt;Route path=\"users\" element={&lt;Users /&gt;} /&gt;\n&lt;/Route&gt;\n</code></pre> <p>Using <code>/*</code> makes it clear that more routes are nested under <code>/dashboard</code>.</p> <p>Summary</p> <p>Using React Router effectively involves keeping your code organized, making good use of props, and handling navigation and state management thoughtfully. Following these good practices will lead to a cleaner, more maintainable, and more user-friendly application!</p>"},{"location":"frontend/router/docs/why-react-router/#changes-v5-vs-v6","title":"Changes <code>v5</code> vs <code>v6</code>","text":"<p>Exactly! Here\u2019s a breakdown:</p> In React Router v5In React Router v6Why the Change? <p>Using this syntax is perfectly acceptable:</p> <pre><code>&lt;Route path=\"/about\" component={About} /&gt;\n</code></pre> <p>This correctly renders the <code>About</code> component when the path matches. It\u2019s a standard practice for v5.</p> <p>This syntax becomes outdated and not recommended:</p> <pre><code>&lt;Route path=\"/about\" component={About} /&gt;\n</code></pre> <p>In v6, you should use:</p> <pre><code>&lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n</code></pre> <ul> <li>Simpler API: The v6 <code>element</code> prop allows you to directly pass a React element, which can help avoid issues with re-renders and make the code cleaner.</li> <li>Consistency: It aligns better with how React works, encouraging the use of JSX for rendering.</li> </ul> <p>So, in summary, while the original example is good practice in v5, it becomes a bad example in v6 due to the API changes. Always make sure to follow the guidelines specific to the version you\u2019re using!</p>"},{"location":"frontend/router/example/context-auth/","title":"Context API","text":""},{"location":"frontend/router/example/context-auth/#context","title":"context","text":"AuthContext.jsx <pre><code>import React, { createContext, useContext, useState, useEffect } from \"react\";\n\n// Create an Auth Context\nconst AuthContext = createContext();\n\n// AuthProvider component to wrap the app\nexport const AuthProvider = ({ children }) =&gt; {\n    const [isAuthenticated, setIsAuthenticated] = useState(false);\n    const [token, setToken] = useState(null); // For storing JWT or session token\n\n    // Check local storage for the token on initial load\n    useEffect(() =&gt; {\n        const storedToken = localStorage.getItem(\"token\");\n        console.log(\"Stored Token:\", storedToken);\n\n        if (storedToken) {\n            setIsAuthenticated(true);\n            setToken(storedToken);\n        }\n    }, []);\n\n    // Login function to set authentication state\n    const login = (token) =&gt; {\n        setIsAuthenticated(true);\n        setToken(token);\n        // Optionally, store the token in localStorage\n        localStorage.setItem(\"token\", token);\n    };\n\n    // Logout function to clear authentication state\n    const logout = () =&gt; {\n        setIsAuthenticated(false);\n        setToken(null);\n        localStorage.removeItem(\"token\"); // Clear token from localStorage\n    };\n\n    return (\n        &lt;AuthContext.Provider value={{ isAuthenticated, login, logout }}&gt;\n            {children}\n        &lt;/AuthContext.Provider&gt;\n    );\n};\n\n// Custom hook to use the AuthContext\nexport const useAuth = () =&gt; {\n    return useContext(AuthContext);\n};\n</code></pre>"},{"location":"frontend/router/example/context-auth/#routes","title":"routes","text":"AppRoutes.jsxProtectedRoute.jsx <pre><code>import { Routes, Route, Navigate } from \"react-router-dom\";\nimport Home from \"../components/Home\";\nimport Login from \"../components/Login/login\";\nimport NotFound from \"../components/NotFound\";\nimport ProtectedRoute from \"./ProtectedRoute\";\nimport { useAuth } from \"../context/AuthContext\";\n\nconst AppRoutes = () =&gt; {\n    const { isAuthenticated } = useAuth();\n\n    return (\n        &lt;Routes&gt;\n            &lt;Route\n                path=\"/\"\n                element={isAuthenticated ? &lt;Navigate to=\"/home\" /&gt; : &lt;Login /&gt;}\n            /&gt;\n            &lt;Route\n                path=\"/home\"\n                element={\n                    &lt;ProtectedRoute&gt;\n                        &lt;Home /&gt;\n                    &lt;/ProtectedRoute&gt;\n                }\n            /&gt;\n            &lt;Route path=\"\\*\" element={&lt;NotFound /&gt;} /&gt;\n        &lt;/Routes&gt;\n    );\n};\n\nexport default AppRoutes;\n</code></pre> <pre><code>import React from \"react\";\nimport { Navigate } from \"react-router-dom\";\nimport { useAuth } from \"../context/AuthContext\";\n\nconst ProtectedRoute = ({ children }) =&gt; {\n    const { isAuthenticated } = useAuth();\n    return isAuthenticated ? children : &lt;Navigate to=\"/\" /&gt;;\n};\n\nexport default ProtectedRoute;\n</code></pre>"},{"location":"frontend/router/example/context-auth/#app-index","title":"App &amp; index","text":"App.jsindex.js <pre><code>import React, { useState } from \"react\";\nimport { BrowserRouter as Router } from \"react-router-dom\";\nimport AppRoutes from \"./routes/AppRoutes\";\nimport Navbar from \"./components/Navbar\";\nimport { AuthProvider } from \"./context/AuthContext\";\nimport \"./App.css\";\n\nfunction App() {\n    return (\n        &lt;AuthProvider&gt;\n            &lt;Router&gt;\n                &lt;div className=\"App\"&gt;\n                    &lt;Navbar /&gt;\n                    {/* {isAuthenticated &amp;&amp; &lt;Navbar /&gt;} */}\n                    &lt;AppRoutes /&gt;\n                &lt;/div&gt;\n            &lt;/Router&gt;\n        &lt;/AuthProvider&gt;\n    );\n}\n\nexport default App;\n</code></pre> <pre><code>import React from \"react\";\nimport ReactDOM from \"react-dom/client\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nconst root = ReactDOM.createRoot(document.getElementById(\"root\"));\nroot.render(\n&lt;React.StrictMode&gt;\n    &lt;App /&gt;\n&lt;/React.StrictMode&gt;\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n</code></pre>"},{"location":"frontend/router/example/context-auth/#component","title":"Component","text":"login.jsxNavbar/index.js <pre><code>import React, { useState } from \"react\";\nimport { Form, Input, Button, Card, message } from \"antd\";\nimport { useNavigate } from \"react-router-dom\";\nimport { login } from \"../../api/auth\";\nimport { useAuth } from \"../../context/AuthContext\";\n\nconst Login = () =&gt; {\n    const { login: authenticate } = useAuth();\n    const [loading, setLoading] = useState(false);\n    const navigate = useNavigate();\n\n    const onFinish = async (values) =&gt; {\n        setLoading(true);\n        try {\n            const response = await login(values.username, values.password);\n            console.log(\"API Response:\", response); // Log the response\n            authenticate(response.access); // Call login method from context\n            message.success(\"login successfull\");\n            navigate(\"/home\"); // Navigate to home after successful login\n        } catch (error) {\n            message.error(error.message || \"Login failed. Please try again.\");\n        } finally {\n            setLoading(false);\n        }\n    };\n\n    return (\n        &lt;Card title=\"Login\" style={{ width: 300, margin: \"auto\", marginTop: 100 }}&gt;\n            &lt;Form name=\"login\" initialValues={{ remember: true }} onFinish={onFinish}&gt;\n                &lt;Form.Item\n                    name=\"username\"\n                    rules={[{ required: true, message: \"Please input your username!\" }]}\n                &gt;\n                    &lt;Input placeholder=\"Username\" /&gt;\n                &lt;/Form.Item&gt;\n\n                &lt;Form.Item\n                    name=\"password\"\n                    rules={[{ required: true, message: \"Please input your password!\" }]}\n                &gt;\n                    &lt;Input.Password placeholder=\"Password\" /&gt;\n                &lt;/Form.Item&gt;\n\n                &lt;Form.Item&gt;\n                    &lt;Button type=\"primary\" htmlType=\"submit\" loading={loading} block&gt;\n                        Login\n                    &lt;/Button&gt;\n                &lt;/Form.Item&gt;\n            &lt;/Form&gt;\n        &lt;/Card&gt;\n    );\n};\n\nexport default Login;\n</code></pre> <pre><code>import { Link } from \"react-router-dom\";\nimport { Layout, Menu } from \"antd\";\nimport { useAuth } from \"../../context/AuthContext\";\n\nconst { Header } = Layout;\n\nconst Navbar = () =&gt; {\n    const { isAuthenticated, logout } = useAuth();\n\n    return (\n        &lt;Layout&gt;\n            &lt;Header&gt;\n                &lt;Menu theme=\"dark\" mode=\"horizontal\"&gt;\n                    {isAuthenticated ? (\n                        &lt;&gt;\n                        &lt;Menu.Item key=\"home\"&gt;\n                            &lt;Link to=\"/home\"&gt;Dashboard&lt;/Link&gt;\n                        &lt;/Menu.Item&gt;\n                        &lt;Menu.Item key=\"logout\"&gt;\n                            &lt;button onClick={logout}&gt;Logout&lt;/button&gt;\n                        &lt;/Menu.Item&gt;\n                        &lt;/&gt;\n                    ) : (\n                        &lt;&gt;\n                        &lt;Menu.Item key=\"login\"&gt;\n                            &lt;Link to=\"/\"&gt;Login&lt;/Link&gt;\n                        &lt;/Menu.Item&gt;\n                        &lt;/&gt;\n                    )}\n                &lt;/Menu&gt;\n            &lt;/Header&gt;\n        &lt;/Layout&gt;\n    );\n};\n\nexport default Navbar;\n</code></pre>"},{"location":"frontend/router/example/simple-login/","title":"Simple login","text":""},{"location":"frontend/router/example/simple-login/#full-code-example","title":"Full Code Example","text":"<ol> <li> <p>Create Your Project Structure</p> <pre><code>src/\n\u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 Home.js\n\u2502   \u251c\u2500\u2500 Login.js\n\u2502   \u2514\u2500\u2500 NotFound.js\n\u251c\u2500\u2500 routes/\n\u2502   \u251c\u2500\u2500 AppRoutes.js\n\u2502   \u2514\u2500\u2500 ProtectedRoute.js\n\u251c\u2500\u2500 App.js\n\u2514\u2500\u2500 index.js\n</code></pre> </li> <li> <p>Install Required Packages Make sure you have React Router and Ant Design installed:</p> <pre><code>npm install react-router-dom antd\n</code></pre> </li> <li> <p>Code for Each Component</p> index &amp; AppRoutesComponent index.js<pre><code>import React from \"react\";\nimport ReactDOM from \"react-dom/client\";\nimport App from \"./App\";\nimport \"antd/dist/antd.css\"; // Import Ant Design styles\n\nconst root = ReactDOM.createRoot(document.getElementById(\"root\"));\nroot.render(&lt;App /&gt;);\n</code></pre> App.js<pre><code>import React, { useState } from \"react\";\nimport { BrowserRouter as Router } from \"react-router-dom\";\nimport AppRoutes from \"./routes/AppRoutes\";\nimport Navbar from \"./components/Navbar\"; // Import your Navbar component\n\nconst App = () =&gt; {\n    const [isAuthenticated, setIsAuthenticated] = useState(false);\n\n    const handleLogin = (status) =&gt; {\n        setIsAuthenticated(status);\n    };\n\n    return (\n        &lt;Router&gt;\n            {isAuthenticated &amp;&amp; &lt;Navbar /&gt;} {/* Show Navbar only if authenticated */}\n            &lt;AppRoutes isAuthenticated={isAuthenticated} onLogin={handleLogin} /&gt;\n        &lt;/Router&gt;\n    );\n};\n\nexport default App;\n</code></pre> AppRoutes.js<pre><code>import { Routes, Route } from \"react-router-dom\";\nimport Home from \"../components/Home\";\nimport NotFound from \"../components/NotFound\";\nimport Login from \"../components/Login\";\nimport ProtectedRoute from \"./ProtectedRoute\";\n\nconst AppRoutes = ({ isAuthenticated, onLogin }) =&gt; {\n    return (\n        &lt;Routes&gt;\n            &lt;Route path=\"/login\" element={&lt;Login onLogin={onLogin} /&gt;} /&gt;\n            &lt;Route\n                path=\"/home\"\n                element={\n                &lt;ProtectedRoute isAuthenticated={isAuthenticated}&gt;\n                    &lt;Home /&gt;\n                &lt;/ProtectedRoute&gt;\n                }\n            /&gt;\n            &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt;\n        &lt;/Routes&gt;\n    );\n};\n\nexport default AppRoutes;\n</code></pre> ProtectedRoute.js<pre><code>import React from \"react\";\nimport { Navigate } from \"react-router-dom\";\n\nconst ProtectedRoute = ({ isAuthenticated, children }) =&gt; {\n    return isAuthenticated ? children : &lt;Navigate to=\"/login\" /&gt;;\n};\n\nexport default ProtectedRoute;\n</code></pre> Home.js<pre><code>import React from \"react\";\n\nconst Home = () =&gt; {\n    return &lt;h1&gt;Welcome to the Home Page!&lt;/h1&gt;;\n};\n\nexport default Home;\n</code></pre> NotFound.js<pre><code>import React from \"react\";\n\nconst NotFound = () =&gt; {\n    return &lt;h1&gt;404 - Page Not Found&lt;/h1&gt;;\n};\n\nexport default NotFound;\n</code></pre> Login.js<pre><code>import React, { useState } from \"react\";\nimport { Form, Input, Button, Card, message } from \"antd\";\nimport { useNavigate } from \"react-router-dom\";\n\nconst Login = ({ onLogin }) =&gt; {\n    const [loading, setLoading] = useState(false);\n    const navigate = useNavigate(); // Initialize useNavigate\n\n    const onFinish = async (values) =&gt; {\n        setLoading(true);\n        try {\n            // Simulate an API call\n            const response = await fakeLoginAPI(values);\n            if (response.success) {\n                onLogin(true); // Update the authentication state\n                navigate(\"/home\"); // Navigate to the home (dashboard) route\n            } else {\n                message.error(response.message);\n            }\n        } catch (error) {\n            message.error(\"Login failed. Please try again.\");\n        } finally {\n            setLoading(false);\n        }\n    };\n\n    const fakeLoginAPI = async ({ username, password }) =&gt; {\n        // Simulating an API call\n        return new Promise((resolve) =&gt; {\n            setTimeout(() =&gt; {\n                if (username === \"user\" &amp;&amp; password === \"pass\") {\n                    resolve({ success: true });\n                } else {\n                    resolve({ success: false, message: \"Invalid credentials\" });\n                }\n            }, 1000);\n        });\n    };\n\n    return (\n        &lt;Card title=\"Login\" style={{ width: 300, margin: \"auto\", marginTop: 100 }}&gt;\n            &lt;Form name=\"login\" onFinish={onFinish}&gt;\n                &lt;Form.Item name=\"username\" rules={[{ required: true, message: 'Please input your username!' }]}&gt;\n                    &lt;Input placeholder=\"Username\" /&gt;\n                &lt;/Form.Item&gt;\n                &lt;Form.Item name=\"password\" rules={[{ required: true, message: 'Please input your password!' }]}&gt;\n                    &lt;Input.Password placeholder=\"Password\" /&gt;\n                &lt;/Form.Item&gt;\n                &lt;Form.Item&gt;\n                    &lt;Button type=\"primary\" htmlType=\"submit\" loading={loading} block&gt;\n                        Login\n                    &lt;/Button&gt;\n                &lt;/Form.Item&gt;\n            &lt;/Form&gt;\n        &lt;/Card&gt;\n    );\n};\n\nexport default Login;\n</code></pre> </li> </ol>"},{"location":"frontend/router/example/simple-login/#summary","title":"Summary","text":"<ul> <li>Login Component: Handles user authentication and simulates an API call.</li> <li>Protected Route: Redirects to the login page if the user is not authenticated.</li> <li>App Component: Manages the authentication state and routes.</li> </ul>"},{"location":"frontend/router/example/simple-login/#running-the-application","title":"Running the Application","text":"<ol> <li> <p>Start your React application:</p> <pre><code>npm start\n</code></pre> </li> <li> <p>Navigate to <code>http://localhost:3000/login</code> to access the login page. Use <code>username: user and password: pass</code> to log in and access the home page.</p> <p>This setup provides a complete example of a React application with protected routing and a login flow using Ant Design and React Router. If you have any further questions or need additional features, feel free to ask!</p> </li> </ol>"},{"location":"frontend/router/example/antd/active-link/","title":"Active link","text":""},{"location":"frontend/router/example/antd/active-link/#best-approach-to-active-state","title":"Best Approach to active state","text":"<p>The best way to handle the active state of a <code>Menu</code> in Ant Design, especially when using routing (like with <code>react-router-dom</code>), is to dynamically highlight the active menu item based on the current route. There are a few approaches to achieving this, but the most efficient and maintainable one involves using React Router's <code>useLocation</code> hook and leveraging the <code>selectedKeys</code> prop of the Ant Design <code>Menu</code> component.</p> <pre><code>const findSelectedKey = (items) =&gt; {\n  for (const item of items) {\n    if (item.children) {\n      const selectedChild = findSelectedKey(item.children);\n      if (selectedChild) return selectedChild;\n    }\n    if (\n      React.isValidElement(item.label) &amp;&amp;\n      item.label.props.to === location.pathname\n    ) {\n      return item.key;\n    }\n  }\n  return null;\n};\n\nconst selectedKey = findSelectedKey(items);\n\n\n// Menu\n&lt;Menu\n    selectedKeys={[selectedKey]}\n&gt;\n</code></pre>"},{"location":"frontend/router/example/antd/active-link/#best-approach-to-implement","title":"Best Approach to Implement:","text":"<ol> <li> <p>Using <code>selectedKeys</code> and <code>useLocation</code>:</p> <p>We'll use selectedKeys to highlight the active menu item and Link components in the menu items to properly associate routes with menu items.</p> <pre><code>import React from \"react\";\nimport { Link, useLocation } from \"react-router-dom\"; // Import useLocation\nimport {\n  AppstoreOutlined,\n  ContainerOutlined,\n  DesktopOutlined,\n  MailOutlined,\n  PieChartOutlined,\n} from \"@ant-design/icons\";\nimport { Menu } from \"antd\";\n\nconst Sidebar = ({ collapsed, width }) =&gt; {\n  const location = useLocation(); // Get the current location (path)\n\n  // Define the items for the sidebar\n  const items = [\n    {\n      key: \"1\", // The unique key for the menu item\n      icon: &lt;PieChartOutlined /&gt;,\n      label: &lt;Link to=\"/dashboard\"&gt;Dashboard&lt;/Link&gt;,\n    },\n    {\n      key: \"2\",\n      icon: &lt;DesktopOutlined /&gt;,\n      label: &lt;Link to=\"/balance\"&gt;Balance&lt;/Link&gt;,\n    },\n    {\n      key: \"3\",\n      icon: &lt;ContainerOutlined /&gt;,\n      label: &lt;Link to=\"/spending\"&gt;Spending&lt;/Link&gt;,\n    },\n    {\n      key: \"sub1\",\n      label: \"Reports\",\n      icon: &lt;MailOutlined /&gt;,\n      children: [\n        {\n          key: \"5\",\n          label: &lt;Link to=\"/reports/monthly\"&gt;Monthly&lt;/Link&gt;,\n        },\n        {\n          key: \"6\",\n          label: &lt;Link to=\"/reports/yearly\"&gt;Yearly&lt;/Link&gt;,\n        },\n      ],\n    },\n    {\n      key: \"sub2\",\n      label: \"Profile\",\n      icon: &lt;AppstoreOutlined /&gt;,\n      children: [\n        {\n          key: \"9\",\n          label: &lt;Link to=\"/profile/edit\"&gt;Edit Profile&lt;/Link&gt;,\n        },\n        {\n          key: \"10\",\n          label: &lt;Link to=\"/profile/change-password\"&gt;Change Password&lt;/Link&gt;,\n        },\n      ],\n    },\n  ];\n\n  // Find the key of the menu item that corresponds to the current path\n  const findSelectedKey = (items) =&gt; {\n    for (const item of items) {\n      if (item.children) {\n        // Check in children if the current path matches\n        const selectedChild = findSelectedKey(item.children);\n        if (selectedChild) return selectedChild;\n      }\n      if (\n        React.isValidElement(item.label) &amp;&amp;\n        item.label.props.to === location.pathname\n      ) {\n        return item.key; // Return the key if the path matches\n      }\n    }\n    return null; // Return null if no match is found\n  };\n\n  const selectedKey = findSelectedKey(items); // Get the selected key based on the current path\n\n  return (\n    &lt;Menu\n      mode=\"inline\"\n      inlineCollapsed={collapsed}\n      selectedKeys={[selectedKey]} // Set the selected key to highlight the active menu item\n      items={items}\n      style={{ width: `${width}px` }}\n    /&gt;\n  );\n};\n\nexport default Sidebar;\n</code></pre> </li> </ol>"},{"location":"frontend/router/example/antd/active-link/#key-parts-of-this-approach","title":"Key Parts of This Approach:","text":"<ol> <li> <p><code>useLocation</code>:</p> <ul> <li>The <code>useLocation</code> hook from <code>react-router-dom</code> is used to get the current route path (<code>location.pathname</code>).</li> </ul> </li> <li> <p><code>findSelectedKey</code>:</p> <ul> <li>We recursively check each menu item and its children to see if their Link's to prop matches the current <code>location.pathname</code>. This ensures we highlight the correct item, even if it's inside a submenu.</li> </ul> </li> <li> <p><code>selectedKeys</code>:</p> <ul> <li>The <code>selectedKeys</code> prop in the <code>Menu</code> is dynamically set to the key of the currently active route. This will highlight the correct menu item automatically.</li> </ul> </li> </ol>"},{"location":"frontend/router/example/antd/active-link/#advantages-of-this-approach","title":"Advantages of This Approach:","text":"<ol> <li> <p>Automatic Sync:</p> <ul> <li>When you navigate through different routes, the active menu item will automatically update. This avoids any manual state management to track which item is active.</li> </ul> </li> <li> <p>Works for Nested Routes:</p> <ul> <li>This solution supports both top-level items and nested routes (submenus). It checks all submenus recursively and highlights the correct menu item, even if the user is deep within a nested route.</li> </ul> </li> <li> <p>No Additional State Management:</p> <ul> <li>Unlike some other approaches that require additional state to track active menu items, this approach directly ties the active menu item to the route, making the code simpler and easier to maintain.</li> </ul> </li> <li> <p>Minimal Code:</p> <ul> <li>The code is concise and easy to understand. We don't need to maintain custom active states or manage complex UI logic outside of what <code>react-router-dom</code> and Ant Design offer out of the box.</li> </ul> </li> </ol>"},{"location":"frontend/router/example/antd/active-link/#alternative-approaches-and-why-this-one-is-better","title":"Alternative Approaches and Why This One is Better:","text":"<ol> <li> <p>Using Custom Active State in <code>Menu.Item</code>:</p> <ul> <li>You could manually track which menu item is active using a custom state (<code>useState</code> or <code>Redux</code>). While this works, it introduces unnecessary complexity. React Router is built for this purpose, so it's better to rely on it to manage the routing logic.</li> </ul> </li> <li> <p>Using Ant Design <code>Menu.Item</code>'s <code>active</code> Prop:</p> <ul> <li>Ant Design's <code>Menu.Item</code> doesn't have an <code>active</code> prop. The active state is determined using <code>selectedKeys</code> or <code>defaultSelectedKeys</code>, making our approach using <code>selectedKeys</code> the most natural and correct way.</li> </ul> </li> </ol>"},{"location":"frontend/router/example/antd/active-link/#summary","title":"Summary:","text":"<ul> <li> <p>Best Practice: The best practice is to use <code>useLocation</code> from <code>react-router-dom</code> in combination with the <code>selectedKeys</code> prop of Ant Design's <code>Menu</code>. This ties the active state directly to the current route and ensures the correct item is highlighted even after page refreshes or when navigating to different routes.</p> </li> <li> <p>This approach is <code>clean</code>, <code>efficient</code>, and <code>maintainable</code>, and it leverages the power of React Router and Ant Design's built-in features for navigation and UI state management.</p> </li> </ul>"},{"location":"frontend/router/example/antd/intro/","title":"Sidebar Menu Route","text":"<p>To add links in the <code>Sidebar</code> component using Ant Design's <code>Menu</code>, you can utilize the <code>Link</code> component from react-router-dom to create navigational links for each menu item. Specifically, you'll need to modify the <code>label</code> property of each menu item to wrap it with the <code>Link</code> component. This allows the menu items to trigger navigation when clicked.</p> Steps to Add Links <ol> <li>Import <code>Link</code> from <code>react-router-dom</code>: This will allow you to navigate between different routes when a user clicks on a menu item.</li> <li>Wrap the <code>label</code> of each menu item with the <code>Link</code> component, and provide the to prop <code>to</code> specify the path for each route.</li> <li>Handle submenu items similarly by wrapping their <code>label</code> in a <code>Link</code>.</li> </ol> ExampleExplanation <pre><code>import React from \"react\";\nimport { Link } from \"react-router-dom\"; // Import Link\nimport {\n    AppstoreOutlined,\n    ContainerOutlined,\n    DesktopOutlined,\n    MailOutlined,\n    PieChartOutlined,\n} from \"@ant-design/icons\";\nimport { Menu } from \"antd\";\n\nconst Sidebar = ({ collapsed, width }) =&gt; {\n    const items = [\n        {\n            key: \"1\",\n            icon: &lt;PieChartOutlined /&gt;,\n            // Add Link here\n            label: &lt;Link to=\"/dashboard\"&gt;Dashboard&lt;/Link&gt;,\n        },\n        {\n            key: \"2\",\n            icon: &lt;DesktopOutlined /&gt;,\n            // Add Link here\n            label: &lt;Link to=\"/balance\"&gt;Balance&lt;/Link&gt;,\n        },\n        {\n            key: \"3\",\n            icon: &lt;ContainerOutlined /&gt;,\n            // Add Link here\n            label: &lt;Link to=\"/spending\"&gt;Spending&lt;/Link&gt;,\n        },\n        {\n            key: \"sub1\",\n            label: \"Reports\",\n            icon: &lt;MailOutlined /&gt;,\n            children: [\n                {\n                    key: \"5\",\n                    // Add Link here\n                    label: &lt;Link to=\"/reports/monthly\"&gt;Monthly&lt;/Link&gt;,\n                },\n                {\n                    key: \"6\",\n                    // Add Link here\n                    label: &lt;Link to=\"/reports/yearly\"&gt;Yearly&lt;/Link&gt;,\n                },\n            ],\n        },\n        {\n            key: \"sub2\",\n            label: \"Profile\",\n            icon: &lt;AppstoreOutlined /&gt;,\n            children: [\n                {\n                    key: \"9\",\n                    // Add Link here\n                    label: &lt;Link to=\"/profile/edit\"&gt;Edit Profile&lt;/Link&gt;,\n                },\n                {\n                    key: \"10\",\n                    // Add Link here\n                    label: &lt;Link to=\"/profile/change-password\"&gt;Change Password&lt;/Link&gt;,\n                },\n            ],\n        },\n    ];\n\n    return (\n        &lt;Menu\n            mode=\"inline\"\n            inlineCollapsed={collapsed}\n            items={items}\n            style={{ width: `${width}px` }}\n        /&gt;\n    );\n};\n\nexport default Sidebar;\n</code></pre> <ol> <li> <p><code>Link</code> Wrapping: Each <code>label</code> property in the <code>items</code> array is now wrapped in a <code>Link</code> component. The <code>to</code> prop on the <code>Link</code> specifies the path to navigate to when the menu item is clicked.</p> <pre><code>label: (\n    &lt;Link to=\"/dashboard\"&gt;Dashboard&lt;/Link&gt; // Add the route path here\n),\n</code></pre> </li> <li> <p>Submenus: For the <code>sub1</code> and <code>sub2</code> keys (the submenus), each child item\u2019s <code>label</code> is also wrapped with a <code>Link</code> to allow navigation inside the submenu.</p> <pre><code>{\n    key: \"5\",\n    label: (\n        &lt;Link to=\"/reports/monthly\"&gt;Monthly&lt;/Link&gt; // Add the route path here\n    ),\n},\n</code></pre> </li> </ol> Note <ul> <li> <p>Paths: Ensure the paths in the <code>to</code> prop (e.g., <code>/dashboard</code>, <code>/balance</code>, <code>/profile/edit</code>) correspond to the routes defined in your AppRoutes component (or wherever you're managing routing).</p> </li> <li> <p>Ant Design Menu with Links: Ant Design\u2019s <code>Menu</code> component supports <code>Link</code> components directly in the <code>label</code>. By doing this, you integrate routing functionality while still using Ant Design\u2019s styled menu.</p> </li> </ul>"},{"location":"frontend/router/example/antd/intro/#example-routes-in-approutes-for-reference","title":"Example Routes in <code>AppRoutes</code> (for reference):","text":"<p>Make sure that these routes are defined in your <code>AppRoutes</code> (or wherever the routing is configured):</p> <pre><code>&lt;Route path=\"/dashboard\" element={&lt;Dashboard /&gt;} /&gt;\n&lt;Route path=\"/balance\" element={&lt;Balance /&gt;} /&gt;\n&lt;Route path=\"/spending\" element={&lt;Spending /&gt;} /&gt;\n&lt;Route path=\"/reports/monthly\" element={&lt;MonthlyReport /&gt;} /&gt;\n&lt;Route path=\"/reports/yearly\" element={&lt;YearlyReport /&gt;} /&gt;\n&lt;Route path=\"/profile/edit\" element={&lt;EditProfile /&gt;} /&gt;\n&lt;Route path=\"/profile/change-password\" element={&lt;ChangePassword /&gt;} /&gt;\n</code></pre>"},{"location":"frontend/router/example/antd/key-and-label/","title":"key & label Link","text":"<p>Avoiding Common Pitfalls: Proper Usage of <code>key</code> in Ant Design Menus</p> <p>Correct, you should not use route paths like <code>/profile</code>, <code>/dashboard</code>, etc., in the <code>key</code> prop of Ant Design <code>Menu</code> items. The <code>key</code> prop is intended to be a unique identifier for each menu item, and it should not directly represent the route path.</p>"},{"location":"frontend/router/example/antd/key-and-label/#overview","title":"Overview","text":"<p>Using <code>/lcy/</code> (or any path-like string) in key for Ant Design Menu items is not a good practice and not recommended for several reasons:</p>"},{"location":"frontend/router/example/antd/key-and-label/#1-ant-designs-key-should-be-unique","title":"1. Ant Design's <code>key</code> Should Be Unique:","text":"<p>The <code>key</code> prop in Ant Design's <code>Menu</code> component is designed to be a unique identifier for each <code>Menu.Item</code> (and <code>SubMenu</code>). It's not meant to represent the path of the route or any URL structure. Instead, it should be a simple string or number that uniquely identifies each item in the menu.</p> Why it's not good <ul> <li><code>key</code> is primarily used to determine the selected item and for efficient re-rendering of menu components. If you use path-like strings (e.g., <code>/dashboard/</code>, <code>/profile/</code>), it can conflict with how keys are expected to behave, especially in nested submenus.</li> <li>It's also not guaranteed that the paths will be unique in all cases, especially if you have dynamic routes or nested routes.</li> </ul>"},{"location":"frontend/router/example/antd/key-and-label/#2-path-matching-is-handled-by-react-router","title":"2. Path Matching is Handled by React Router:","text":"<p>The route path matching (like <code>/dashboard</code>, <code>/profile/edit</code>, etc.) should be handled separately via React Router and not mixed with the <code>key</code> prop of the menu. The <code>key</code> should be used solely for internal identification, and you should rely on the current <code>location.pathname</code> (from <code>useLocation</code> hook) to determine which route is active.</p> Best Practice <ul> <li>Menu <code>key</code> should be a unique identifier for the item itself, not a route path.</li> <li>Use <code>to</code> prop of the <code>Link</code> inside <code>Menu.Item</code> to handle routing, and use <code>location.pathname</code> to match the current active route.</li> </ul>"},{"location":"frontend/router/example/antd/key-and-label/#3-maintainability-and-clarity","title":"3. Maintainability and Clarity:","text":"<p>Using a path string as the <code>key</code> might make the code less maintainable and harder to debug, especially if routes change or get restructured. A simple <code>key</code> (like <code>\"1\"</code>, <code>\"sub1\"</code>, etc.) keeps things clear and decouples the UI logic (menu structure) from the routing logic.</p>"},{"location":"frontend/router/example/antd/key-and-label/#what-to-use-instead","title":"What to Use Instead:","text":"<p>1. Use Unique Identifiers for <code>key</code>:</p> <p>Instead of using the path or URL, use a simple, unique string or number to identify each menu item. This could be something like <code>\"1\"</code>, <code>\"sub1\"</code>, <code>\"profile\",</code> etc.</p> <pre><code>const items = [\n  {\n    key: \"dashboard\", // A unique, descriptive key for this menu item\n    icon: &lt;PieChartOutlined /&gt;,\n    label: &lt;Link to=\"/dashboard\"&gt;Dashboard&lt;/Link&gt;,\n  },\n  {\n    key: \"balance\", // A unique key\n    icon: &lt;DesktopOutlined /&gt;,\n    label: &lt;Link to=\"/balance\"&gt;Balance&lt;/Link&gt;,\n  },\n  {\n    key: \"profile\", // A unique key for the profile menu\n    icon: &lt;AppstoreOutlined /&gt;,\n    label: &lt;Link to=\"/profile\"&gt;Profile&lt;/Link&gt;,\n  },\n];\n</code></pre> <p>2. Use <code>Link</code> for Navigation:</p> <p>The <code>Link</code> component from <code>react-router-dom</code> should be used to navigate between routes. The <code>to</code> prop of <code>Link</code> will automatically match the route for you.</p> <p>3. Use <code>selectedKeys</code> with Simple Matching:</p> <p>Use <code>selectedKeys</code> in combination with the <code>useLocation</code> hook from React Router to highlight the active menu item based on the current path.</p> <pre><code>import { Link, useLocation } from \"react-router-dom\";\nimport { Menu } from \"antd\";\n\nconst Sidebar = ({ collapsed, width }) =&gt; {\n  const location = useLocation();\n\n  // Define menu items with unique keys\n  const items = [\n    {\n      key: \"1\",\n      icon: &lt;PieChartOutlined /&gt;,\n      label: &lt;Link to=\"/dashboard\"&gt;Dashboard&lt;/Link&gt;,\n    },\n    {\n      key: \"2\",\n      icon: &lt;DesktopOutlined /&gt;,\n      label: &lt;Link to=\"/balance\"&gt;Balance&lt;/Link&gt;,\n    },\n    {\n      key: \"3\",\n      icon: &lt;AppstoreOutlined /&gt;,\n      label: &lt;Link to=\"/profile\"&gt;Profile&lt;/Link&gt;,\n    },\n  ];\n\n  // Get the selected key based on the current route\n  const selectedKey = items.find(\n    (item) =&gt;\n      React.isValidElement(item.label) &amp;&amp;\n      item.label.props.to === location.pathname\n  )?.key;\n\n  return (\n    &lt;Menu\n      mode=\"inline\"\n      inlineCollapsed={collapsed}\n      selectedKeys={[selectedKey]} // Set the selected key to highlight the active menu item\n      items={items}\n      style={{ width: `${width}px` }}\n    /&gt;\n  );\n};\n</code></pre>"},{"location":"frontend/router/example/antd/key-and-label/#summary-of-best-practices","title":"Summary of Best Practices:","text":"<ol> <li> <p>Avoid using route paths as keys:</p> <ul> <li>Use simple, unique identifiers for <code>key</code> (e.g., <code>\"dashboard\"</code>, <code>\"profile\"</code>, etc.).</li> </ul> </li> <li> <p>Use <code>Link</code> for route navigation:</p> <ul> <li>The <code>Link</code> component should handle the route path (via the <code>to</code> prop) and not be confused with the <code>key</code> prop of the <code>Menu</code>.</li> </ul> </li> <li> <p>Use <code>location.pathname</code> for active route matching:</p> <ul> <li>Use React Router's <code>useLocation</code> hook to determine which route is active, and then match it to the corresponding menu item to highlight it with selectedKeys.</li> </ul> </li> <li> <p>Keep UI and routing concerns separate:</p> <ul> <li>Your <code>Menu</code> component's <code>key</code> prop should be used for UI-specific identification, not for routing or paths.</li> </ul> </li> </ol> <p>By following these best practices, you ensure your menu system is both efficient and maintainable, and you avoid potential conflicts or issues with Ant Design's <code>Menu</code> component.</p>"},{"location":"frontend/router/example/antd/key-and-label/#additional","title":"Additional","text":"<pre><code>import React from \"react\";\nimport { Link } from \"react-router-dom\";\nimport {\n  AppstoreOutlined,\n  ContainerOutlined,\n  DesktopOutlined,\n  MailOutlined,\n  PieChartOutlined,\n} from \"@ant-design/icons\";\nimport { Menu } from \"antd\";\n\nconst Sidebar = ({ collapsed, width }) =&gt; {\n  const items = [\n    {\n      key: \"dashboard\", // Unique key for top-level item\n      icon: &lt;PieChartOutlined /&gt;,\n      label: &lt;Link to=\"/dashboard\"&gt;Dashboard&lt;/Link&gt;,\n    },\n    {\n      key: \"balance\", // Unique key for top-level item\n      icon: &lt;DesktopOutlined /&gt;,\n      label: &lt;Link to=\"/balance\"&gt;Balance&lt;/Link&gt;,\n    },\n    {\n      key: \"profile\", // Unique key for top-level item\n      icon: &lt;AppstoreOutlined /&gt;,\n      label: &lt;Link to=\"/profile\"&gt;Profile&lt;/Link&gt;,\n    },\n    {\n      key: \"sub1\", // Unique key for submenu \"Reports\"\n      icon: &lt;MailOutlined /&gt;,\n      label: \"Reports\", // No Link here, as it's a parent item\n      children: [\n        {\n          key: \"monthly\",\n          label: &lt;Link to=\"/reports/monthly\"&gt;Monthly&lt;/Link&gt;, // Submenu item\n        },\n        {\n          key: \"yearly\",\n          label: &lt;Link to=\"/reports/yearly\"&gt;Yearly&lt;/Link&gt;, // Submenu item\n        },\n      ],\n    },\n    {\n      key: \"sub2\", // Unique key for submenu \"Settings\"\n      icon: &lt;ContainerOutlined /&gt;,\n      label: \"Settings\", // No Link here, as it's a parent item\n      children: [\n        {\n          key: \"editProfile\",\n          label: &lt;Link to=\"/profile/edit\"&gt;Edit Profile&lt;/Link&gt;, // Submenu item\n        },\n        {\n          key: \"changePassword\",\n          label: &lt;Link to=\"/profile/change-password\"&gt;Change Password&lt;/Link&gt;, // Submenu item\n        },\n      ],\n    },\n  ];\n\n  return (\n    &lt;Menu\n      mode=\"inline\"\n      inlineCollapsed={collapsed}\n      items={items} // Pass the menu items (including submenus) here\n      style={{ width: `${width}px` }}\n    /&gt;\n  );\n};\n\nexport default Sidebar;\n</code></pre>"},{"location":"frontend/router/example/antd/key-and-label/#tips","title":"Tips","text":"<p>Correct Approach: Use Descriptive and Unique Keys for Menu Items</p> <p>Instead of using the route path in the <code>key</code>, you should use a unique identifier for each menu item. The <code>key</code> can be a string (like <code>\"dashboard\"</code>, <code>\"profile\"</code>, etc.) that describes the menu item. You will still use the <code>Link</code> component to navigate to the appropriate path, but the <code>key</code> will be a simpler and more appropriate value.</p> ExampleKey Points to Remember <pre><code>import React from \"react\";\nimport { Link } from \"react-router-dom\";\nimport {\n    AppstoreOutlined,\n    ContainerOutlined,\n    DesktopOutlined,\n    MailOutlined,\n    PieChartOutlined,\n} from \"@ant-design/icons\";\nimport { Menu } from \"antd\";\n\nconst Sidebar = ({ collapsed, width }) =&gt; {\n    const items = [\n        {\n            key: \"dashboard\", // A unique, descriptive key for this menu item\n            icon: &lt;PieChartOutlined /&gt;,\n            label: &lt;Link to=\"/dashboard\"&gt;Dashboard&lt;/Link&gt;, // Link for routing\n        },\n        {\n            key: \"balance\", // A unique key for this menu item\n            icon: &lt;DesktopOutlined /&gt;,\n            label: &lt;Link to=\"/balance\"&gt;Balance&lt;/Link&gt;,\n        },\n        {\n            key: \"profile\", // A unique key for this menu item\n            icon: &lt;AppstoreOutlined /&gt;,\n            label: &lt;Link to=\"/profile\"&gt;Profile&lt;/Link&gt;,\n        },\n        {\n            key: \"sub1\", // Unique key for submenu \"Reports\"\n            icon: &lt;MailOutlined /&gt;,\n            label: \"Reports\", // No Link here, as it's a parent item\n            children: [\n                {\n                    key: \"monthly\", // Unique key for \"Monthly\" report\n                    label: &lt;Link to=\"/reports/monthly\"&gt;Monthly&lt;/Link&gt;, // Submenu item\n                },\n                {\n                    key: \"yearly\", // Unique key for \"Yearly\" report\n                    label: &lt;Link to=\"/reports/yearly\"&gt;Yearly&lt;/Link&gt;, // Submenu item\n                },\n            ],\n        },\n        {\n            key: \"sub2\", // Unique key for submenu \"Settings\"\n            icon: &lt;ContainerOutlined /&gt;,\n            label: \"Settings\", // No Link here, as it's a parent item\n            children: [\n                {\n                    key: \"editProfile\", // Unique key for \"Edit Profile\"\n                    label: &lt;Link to=\"/profile/edit\"&gt;Edit Profile&lt;/Link&gt;, // Submenu item\n                },\n                {\n                    key: \"changePassword\", // Unique key for \"Change Password\"\n                    label: &lt;Link to=\"/profile/change-password\"&gt;Change Password&lt;/Link&gt;, // Submenu item\n                },\n            ],\n        },\n    ];\n\n    return (\n        &lt;Menu\n            mode=\"inline\"\n            inlineCollapsed={collapsed}\n            items={items} // Pass the menu items (including submenus) here\n            style={{ width: `${width}px` }}\n        /&gt;\n    );\n};\n\nexport default Sidebar;\n</code></pre> <ol> <li> <p><code>key</code> is for identification: Use simple strings like <code>\"dashboard\"</code>, <code>\"balance\"</code>, <code>\"profile\"</code>, etc., as unique identifiers for menu items and submenus.</p> </li> <li> <p>Use <code>Link</code> for Routing: The <code>Link</code> component from React Router should be used to handle navigation to the actual route path (<code>to=\"/dashboard\"</code>, <code>to=\"/profile\"</code>, etc.).</p> </li> <li> <p>Match Active Menu Item with <code>location.pathname</code>: To highlight the active menu item, use <code>useLocation</code> from React Router to get the current path and match it to the correct key.</p> </li> <li> <p>Submenus: Use the <code>children</code> property inside the <code>Menu</code> item to define submenus. The <code>key</code> for each submenu item should also be unique and descriptive.</p> </li> </ol> <p>By following this approach, you maintain clear separation between UI behavior (the <code>key</code> for menu item identification) and routing behavior (the <code>Link</code> component for navigation). This makes your code easier to understand, maintain, and scale as your application grows.</p>"},{"location":"frontend/router/question/pervent-layout-flashing-v6/","title":"Privent Flashing Layout","text":"<p>How to Prevent Layout Flashing on Protected Routes in React Router v6</p>"},{"location":"frontend/router/question/pervent-layout-flashing-v6/#overview","title":"Overview","text":"Old Code AppRoutes.jsxProtectedRoute.jsx <pre><code>import {\n    BrowserRouter as Router,\n    Routes,\n    Route,\n    Navigate,\n} from \"react-router-dom\";\nimport Login from \"../pages/Login\";\nimport Signup from \"../pages/Signup\";\nimport Dashboard from \"../pages/Dashboard\";\nimport BalanceManagement from \"../pages/BalanceManagement\";\nimport Spending from \"../pages/Spending\";\nimport Profile from \"../pages/Profile\";\nimport Reports from \"../pages/Reports\";\n\nimport MyLayout from \"../components/layouts/MyLayout\";\nimport ProtectedRoute from \"./ProtectedRoute\";\n\nconst AppRoutes = () =&gt; {\n    return (\n        &lt;Router&gt;\n            &lt;Routes&gt;\n                &lt;Route path=\"/login\" element={&lt;Login /&gt;} /&gt;\n                &lt;Route path=\"/signup\" element={&lt;Signup /&gt;} /&gt;\n\n                &lt;Route\n                    path=\"/*\"\n                    element={\n                        &lt;MyLayout&gt;\n                            &lt;Routes&gt;\n                                &lt;Route\n                                    path=\"/dashboard\"\n                                    element={\n                                        &lt;ProtectedRoute&gt;\n                                        &lt;Dashboard /&gt;\n                                        &lt;/ProtectedRoute&gt;\n                                    }\n                                /&gt;\n                                &lt;Route\n                                    path=\"/balance\"\n                                    element={\n                                        &lt;ProtectedRoute&gt;\n                                        &lt;BalanceManagement /&gt;\n                                        &lt;/ProtectedRoute&gt;\n                                    }\n                                /&gt;\n                                &lt;Route\n                                    path=\"/spending\"\n                                    element={\n                                        &lt;ProtectedRoute&gt;\n                                        &lt;Spending /&gt;\n                                        &lt;/ProtectedRoute&gt;\n                                    }\n                                /&gt;\n                                &lt;Route\n                                    path=\"/reports\"\n                                    element={\n                                        &lt;ProtectedRoute&gt;\n                                        &lt;Reports /&gt;\n                                        &lt;/ProtectedRoute&gt;\n                                    }\n                                /&gt;\n                                &lt;Route\n                                    path=\"/profile\"\n                                    element={\n                                        &lt;ProtectedRoute&gt;\n                                        &lt;Profile /&gt;\n                                        &lt;/ProtectedRoute&gt;\n                                    }\n                                /&gt;\n                            &lt;/Routes&gt;\n                        &lt;/MyLayout&gt;\n                    }\n                /&gt;\n            &lt;/Routes&gt;\n        &lt;/Router&gt;\n    );\n};\n\nexport default AppRoutes;\n</code></pre> <pre><code>import { Navigate } from \"react-router-dom\";\nimport { useSelector } from \"react-redux\";\n\nconst ProtectedRoute = ({ children }) =&gt; {\n    const isAuthenticated = useSelector((state) =&gt; state.auth.isAuthenticated);\n\n    if (!isAuthenticated) {\n        return &lt;Navigate to=\"/login\" replace /&gt;;\n    }\n    return children;\n};\n\nexport default ProtectedRoute;\n</code></pre> <p>The issue you're experiencing with a split-second display of the layout UI when directly navigating to <code>/dashboard</code> can be due to several reasons related to how React Router handles route matching and conditional rendering in your <code>ProtectedRoute</code>.</p>"},{"location":"frontend/router/question/pervent-layout-flashing-v6/#the-issue","title":"The Issue:","text":"<p>When you navigate directly to /dashboard, React Router first tries to load the route associated with /dashboard, and only after this does it evaluate whether the user is authenticated or not through your ProtectedRoute wrapper. If the user is not authenticated, the redirect to /login happens, but this could cause a flicker (split-second UI) as the layout and other components might briefly render before the redirect occurs.</p>"},{"location":"frontend/router/question/pervent-layout-flashing-v6/#why-it-happens","title":"Why It Happens:","text":"<ol> <li> <p>Initial Layout Rendering:</p> <ul> <li>The <code>MyLayout</code> component is rendered immediately because you're using a nested <code>Routes</code> structure. The layout is rendered before the <code>ProtectedRoute</code> has a chance to check the user's authentication status, causing the layout to appear briefly even before the redirect happens.</li> </ul> </li> <li> <p>Redirection Delay:</p> <ul> <li>The <code>Navigate</code> component works asynchronously, and while it performs the redirection, React Router might still render the <code>MyLayout</code> and the inner components (<code>Dashboard</code>, <code>BalanceManagement</code>, etc.) briefly before redirecting, causing that split-second UI flicker.</li> </ul> </li> </ol>"},{"location":"frontend/router/question/pervent-layout-flashing-v6/#solution","title":"Solution:","text":"<p>To prevent the flicker and ensure that the layout is only rendered after authentication is checked, you can refactor your approach slightly to prevent rendering the layout prematurely. One common strategy is to conditionally render the layout or the protected route itself based on the user's authentication status.</p> <p>Refactor to Use Protected Routes Properly:</p> <p>Here\u2019s an updated approach where we conditionally render <code>MyLayout</code> and the protected routes only after checking authentication:</p> AppRoutes.jsx (Refactored):Explanation of Changes: <pre><code>import {\n    BrowserRouter as Router,\n    Routes,\n    Route,\n    Navigate,\n} from \"react-router-dom\";\nimport Login from \"../pages/Login\";\nimport Signup from \"../pages/Signup\";\nimport Dashboard from \"../pages/Dashboard\";\nimport BalanceManagement from \"../pages/BalanceManagement\";\nimport Spending from \"../pages/Spending\";\nimport Profile from \"../pages/Profile\";\nimport Reports from \"../pages/Reports\";\n\nimport MyLayout from \"../components/layouts/MyLayout\";\nimport ProtectedRoute from \"./ProtectedRoute\";\n\nconst AppRoutes = () =&gt; {\n    return (\n        &lt;Router&gt;\n            &lt;Routes&gt;\n                {/* Public Routes */}\n                &lt;Route path=\"/login\" element={&lt;Login /&gt;} /&gt;\n                &lt;Route path=\"/signup\" element={&lt;Signup /&gt;} /&gt;\n\n                {/* Protected Routes with Layout */}\n                &lt;Route\n                    path=\"/*\"\n                    element={\n                        &lt;ProtectedRoute&gt;\n                        &lt;MyLayout&gt;\n                            &lt;Routes&gt;\n                            &lt;Route path=\"/dashboard\" element={&lt;Dashboard /&gt;} /&gt;\n                            &lt;Route path=\"/balance\" element={&lt;BalanceManagement /&gt;} /&gt;\n                            &lt;Route path=\"/spending\" element={&lt;Spending /&gt;} /&gt;\n                            &lt;Route path=\"/reports\" element={&lt;Reports /&gt;} /&gt;\n                            &lt;Route path=\"/profile\" element={&lt;Profile /&gt;} /&gt;\n                            &lt;/Routes&gt;\n                        &lt;/MyLayout&gt;\n                        &lt;/ProtectedRoute&gt;\n                    }\n                /&gt;\n            &lt;/Routes&gt;\n        &lt;/Router&gt;\n    );\n};\n\nexport default AppRoutes;\n</code></pre> <ol> <li> <p>ProtectedRoute Wraps Layout:</p> <ul> <li>The <code>ProtectedRoute</code> now wraps the entire <code>MyLayout</code> and the nested routes.</li> <li>This ensures that the layout and any protected routes are not rendered until the authentication status is checked.</li> <li>If the user is not authenticated, the <code>Navigate</code> component inside <code>ProtectedRoute</code> will redirect them to <code>/login</code> before the layout and routes are rendered.</li> </ul> </li> <li> <p>No Nested Routes in ProtectedRoute:</p> <ul> <li>Instead of nesting the <code>Routes</code> inside <code>MyLayout</code> and wrapping each route with <code>ProtectedRoute</code>, the <code>ProtectedRoute</code> now controls whether the MyLayout (and all nested routes) should be rendered at all. This eliminates the need to check authentication for each route individually.</li> </ul> </li> <li> <p>Flicker-Free UI:</p> <ul> <li>By moving the authentication check to wrap the layout (and routes inside it), we avoid the brief flicker where the layout renders before the user is redirected.</li> </ul> </li> </ol> ProtectedRoute.jsx (Refactor) <p>Your <code>ProtectedRoute</code> component is mostly fine but needs a slight improvement. Make sure you're using the <code>useSelector</code> hook correctly and check authentication before rendering any children.</p> <pre><code>// src/routes/ProtectedRoute.jsx\nimport { useSelector } from \"react-redux\";\nimport { Navigate } from \"react-router-dom\";\n\nconst ProtectedRoute = ({ children }) =&gt; {\n    const isAuthenticated = useSelector((state) =&gt; state.auth.isAuthenticated);\n\n    if (!isAuthenticated) {\n        return &lt;Navigate to=\"/login\" replace /&gt;;\n    }\n\n    return children;\n};\n\nexport default ProtectedRoute;\n</code></pre> <p>Explanation:</p> <ul> <li>The <code>ProtectedRoute</code> will only render its <code>children</code> (the <code>MyLayout</code> and its child routes) if the user is authenticated. Otherwise, it redirects to <code>/login</code>.</li> </ul>"},{"location":"frontend/router/question/pervent-layout-flashing-v6/#why-this-works","title":"Why This Works:","text":"<ul> <li>By wrapping the entire layout and its children inside <code>ProtectedRoute</code>, the authentication check happens before the layout is rendered. This ensures that nothing is displayed (no UI flicker) until the authentication check is complete.</li> <li>With this change, users who are not authenticated will be redirected to the login page immediately, and no layout or protected routes will be rendered.</li> </ul>"},{"location":"frontend/router/question/pervent-layout-flashing-v6/#alternative-option-use-suspense-or-loading-indicator","title":"Alternative Option: Use Suspense or Loading Indicator","text":"<p>If you still experience a slight delay (maybe due to fetching authentication state from a server or external source), you could consider using React's <code>Suspense</code> or a loading indicator to avoid showing blank pages.</p>"},{"location":"frontend/router/types/types-of-access-control-routes/","title":"Route Protection","text":""},{"location":"frontend/router/types/types-of-access-control-routes/#types-of-access-control-routes-in-react","title":"Types of access control routes in React","text":"<p>Understanding Route Protection in React: PrivateRoute, ProtectedRoute, and More</p> Types of Access Control Routes in React: <ol> <li> <p>Public Routes</p> <ul> <li>Accessible to everyone (no authentication or authorization required).</li> </ul> </li> <li> <p>Private Routes (Authenticated Routes)</p> <ul> <li>Only accessible to authenticated users (checks if the user is logged in).</li> </ul> </li> <li> <p>Protected Routes (Authorization Based on Roles)</p> <ul> <li>Accessible only to authenticated users with specific roles or permissions (e.g., admins, managers).</li> </ul> </li> <li> <p>Role-Based Access Control (RBAC) Routes</p> <ul> <li>Routes that are restricted based on a user\u2019s assigned roles or permissions, allowing fine-grained access control.</li> </ul> </li> <li> <p>Unauthorized Access Handling (Redirection)</p> <ul> <li>Involves redirecting users who are not authorized to access certain routes to login or an \"unauthorized\" page.</li> </ul> </li> <li> <p>Global State Management (<code>React Context</code> for Authentication)</p> <ul> <li>Using a global context (like React Context) to manage authentication state, roles, and permissions, which can be checked throughout the application.</li> </ul> </li> </ol> <p>These are the different access control patterns in React that you can apply to your routing logic based on whether users need to be authenticated or authorized (or both) to access certain resources or pages in your app.</p> <p>Different types of access control routes in React</p>"},{"location":"frontend/router/types/types-of-access-control-routes/#access-control","title":"Access Control","text":"<p>Ah, I see! You're referring to the types of routes in terms of access control\u2014like public, protected, and private routes. This is a common pattern when you need to restrict access to certain routes based on the user's authentication or authorization status.</p> <p>Here's how you can classify these types of routes and implement them in a React app (often using React Router and some form of authentication, like JWT or session-based authentication).</p>"},{"location":"frontend/router/types/types-of-access-control-routes/#1-public-routes","title":"1. Public Routes","text":"<ul> <li>Definition: These are routes that are accessible to anyone, regardless of whether they are logged in or not.</li> <li>Examples: A home page, about page, login page, sign-up page, etc.</li> <li>Use Case: Public routes are typically for general information that all users (authenticated or not) can view.</li> </ul> Implementation<pre><code>&lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n&lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n&lt;Route path=\"/login\" element={&lt;Login /&gt;} /&gt;\n</code></pre> <p>In this case, anyone can visit the <code>/</code> or<code>/about</code> routes, regardless of their authentication status.</p>"},{"location":"frontend/router/types/types-of-access-control-routes/#2-private-routes-authenticated-routes","title":"2. Private Routes (Authenticated Routes)","text":"<ul> <li>Definition: These are routes that require the user to be authenticated before they can access them. If a user is not authenticated, they are usually redirected to a login page or shown an error message.</li> <li>Use Case: Private routes are typically for pages that require the user to be logged in, like their profile, dashboard, or account settings.</li> </ul> <p>Implementation: To create a private route, you typically create a wrapper component that checks the user's authentication status and either renders the route's component or redirects them to the login page.</p> Example of a PrivateRoute component<pre><code>const PrivateRoute = ({ element, ...rest }) =&gt; {\n  const isAuthenticated = useAuth(); // Custom hook to check auth status\n\n  if (!isAuthenticated) {\n    return &lt;Navigate to=\"/login\" /&gt;;\n  }\n\n  return &lt;Route {...rest} element={element} /&gt;;\n};\n</code></pre> Usage in your routing configuration<pre><code>&lt;Routes&gt;\n  &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n  &lt;PrivateRoute path=\"/dashboard\" element={&lt;Dashboard /&gt;} /&gt;\n  &lt;Route path=\"/login\" element={&lt;Login /&gt;} /&gt;\n&lt;/Routes&gt;\n</code></pre> <p>Here, the <code>/dashboard</code> route is only accessible if the user is authenticated. Otherwise, they are redirected to the login page.</p>"},{"location":"frontend/router/types/types-of-access-control-routes/#3-protected-routes-authorization-based-on-roles","title":"3. Protected Routes (Authorization Based on Roles)","text":"<ul> <li>Definition: Protected routes can be thought of as a mix of private routes and role-based access control (RBAC). These routes not only require the user to be authenticated, but also to have certain permissions or roles to access them. For example, a user may need to be an \"admin\" to access certain pages like an admin panel.</li> <li>Use Case: Protected routes are for scenarios where access to certain routes depends not just on being logged in, but on the user's role or permissions (e.g., admin dashboard, settings for premium users, etc.).</li> </ul> <p>Implementation: You can extend the logic of private routes by checking the user's role in addition to their authentication status.</p> Example of a ProtectedRoute component<pre><code>const ProtectedRoute = ({ element, requiredRole, ...rest }) =&gt; {\n  const { isAuthenticated, userRole } = useAuth(); // Custom hook to check auth and role\n\n  if (!isAuthenticated) {\n    return &lt;Navigate to=\"/login\" /&gt;;\n  }\n\n  if (userRole !== requiredRole) {\n    return &lt;Navigate to=\"/unauthorized\" /&gt;;\n  }\n\n  return &lt;Route {...rest} element={element} /&gt;;\n};\n</code></pre> Usage in your routing configuration<pre><code>&lt;Routes&gt;\n  &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n  &lt;ProtectedRoute path=\"/admin\" element={&lt;AdminPanel /&gt;} requiredRole=\"admin\" /&gt;\n  &lt;Route path=\"/login\" element={&lt;Login /&gt;} /&gt;\n  &lt;Route path=\"/unauthorized\" element={&lt;Unauthorized /&gt;} /&gt;\n&lt;/Routes&gt;\n</code></pre> <p>In this case, only users who are authenticated and have the admin role can access the <code>/admin</code> route. If the user doesn't have the required role, they are redirected to an unauthorized page.</p>"},{"location":"frontend/router/types/types-of-access-control-routes/#4-adminrole-based-routes","title":"4. Admin/Role-Based Routes","text":"<ul> <li>Definition: A more specific form of protected routes where access depends on the user's role (admin, manager, user, etc.). This is often part of the protected route system, where roles are checked before rendering the component.</li> <li>Use Case: These routes are for applications where different types of users (admin, regular user, etc.) have different levels of access. For example, an admin might have access to an admin dashboard, but a regular user wouldn\u2019t.</li> </ul> <p>Implementation: Here's how you might create role-based access control in your route configuration:</p> <pre><code>const RoleBasedRoute = ({ element, requiredRole, ...rest }) =&gt; {\n  const { isAuthenticated, userRole } = useAuth(); // Check auth and role\n\n  if (!isAuthenticated) {\n    return &lt;Navigate to=\"/login\" /&gt;;\n  }\n\n  if (userRole !== requiredRole) {\n    return &lt;Navigate to=\"/unauthorized\" /&gt;;\n  }\n\n  return &lt;Route {...rest} element={element} /&gt;;\n};\n</code></pre> Usage<pre><code>&lt;Routes&gt;\n  &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n  &lt;RoleBasedRoute path=\"/admin\" element={&lt;Admin /&gt;} requiredRole=\"admin\" /&gt;\n  &lt;RoleBasedRoute\n    path=\"/user-settings\"\n    element={&lt;UserSettings /&gt;}\n    requiredRole=\"user\"\n  /&gt;\n  &lt;Route path=\"/login\" element={&lt;Login /&gt;} /&gt;\n  &lt;Route path=\"/unauthorized\" element={&lt;Unauthorized /&gt;} /&gt;\n&lt;/Routes&gt;\n</code></pre>"},{"location":"frontend/router/types/types-of-access-control-routes/#example-flow-for-public-private-and-protected-routes","title":"Example Flow for Public, Private, and Protected Routes\"","text":"<p>Let\u2019s put it all together in an example where we have:</p> <ul> <li>Public Routes: Accessible to everyone (<code>Home</code>, <code>About</code>, <code>Login</code>)</li> <li>Private Routes: Only accessible to authenticated users (<code>Dashboard</code>)</li> <li>Protected Routes: Only accessible to authenticated users with a specific role (<code>Admin Panel</code>)</li> </ul> <pre><code>&lt;Routes&gt;\n  {/* Public Routes */}\n  &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n  &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n  &lt;Route path=\"/login\" element={&lt;Login /&gt;} /&gt;\n\n  {/* Private Route */}\n  &lt;PrivateRoute path=\"/dashboard\" element={&lt;Dashboard /&gt;} /&gt;\n\n  {/* Protected Route (only accessible by admin) */}\n  &lt;ProtectedRoute path=\"/admin\" element={&lt;AdminPanel /&gt;} requiredRole=\"admin\" /&gt;\n\n  {/* Fallback for unauthorized access */}\n  &lt;Route path=\"/unauthorized\" element={&lt;Unauthorized /&gt;} /&gt;\n&lt;/Routes&gt;\n</code></pre> <p>Summary of Route Types:</p> <ul> <li>Public Routes: Routes that anyone can access, regardless of authentication status.</li> <li>Private Routes: Routes that require the user to be authenticated to access.</li> <li>Protected Routes: Routes that require the user to be authenticated and may require specific permissions or roles.</li> </ul>"},{"location":"frontend/router/types/types-of-access-control-routes/#question","title":"Question","text":"<p>Question</p> <p>The most commonly used types of access control routes in React applications are Private Routes (Authenticated Routes) and Role-Based Access Control (RBAC) Routes. The exact choice depends on the complexity and requirements of your application, but here\u2019s a breakdown of why these two are generally the most used:</p> <p>1. Private Routes (Authenticated Routes)</p> <ul> <li> <p>Why it\u2019s most used: In most web applications, especially those with user accounts (like social networks, dashboards, or e-commerce sites), you typically need to ensure that certain parts of your app are only accessible to users who are logged in.   Private Routes are simple to implement and cover a large portion of authentication requirements.</p> </li> <li> <p>How it's implemented: You protect routes by checking whether a user is authenticated (i.e., logged in). If they are not authenticated, they are redirected to a login page.</p> </li> <li> <p>Example use cases:</p> <ul> <li>Dashboard pages that show user-specific data (e.g., <code>/dashboard</code>).</li> <li>Profile pages where only logged-in users can access their personal details (e.g., <code>/profile</code>).</li> <li>Admin or other restricted sections (if roles are not required for access).</li> </ul> </li> <li> <p>Why it\u2019s widely used: Many applications require a basic authentication flow, so Private Routes are easy to implement and meet the needs of most use cases.</p> </li> </ul> <p>2. Role-Based Access Control (RBAC) Routes</p> <ul> <li> <p>Why it\u2019s most used: When your application has different user roles (e.g., <code>admin</code>, <code>user</code>, <code>manager</code>), you might want to restrict access to certain routes or features based on those roles. RBAC Routes are an extension of Private Routes that check both authentication and authorization (role).</p> </li> <li> <p>How it's implemented: Once a user is authenticated, you check the user's role before granting access to specific routes. For example, only users with the <code>admin</code> role can access the<code>/admin</code> page.</p> </li> <li> <p>Example use cases:</p> <ul> <li>Admin dashboards or settings (e.g., <code>/admin</code>).</li> <li>Role-based content management or moderation pages (e.g., <code>/moderator</code>).</li> <li>Custom user settings based on role (e.g., <code>/manager/settings</code>).</li> </ul> </li> <li> <p>Why it\u2019s widely used:</p> <ul> <li>Many modern applications are built with different levels of access for different users, especially in enterprise or business-focused applications.</li> <li>Role-based access control is a common and scalable way to manage permissions.</li> </ul> </li> </ul> <p>Comparison: Private Routes vs. RBAC Routes</p> <ul> <li> <p>Private Routes are used when you only need to ensure that users are logged in, without worrying about their role. This is typically enough for most simple apps where only authentication is necessary.</p> </li> <li> <p>RBAC Routes add another layer by checking not just if the user is logged in, but also whether they have the correct role for accessing certain routes. This is necessary for applications that have multiple types of users with varying levels of access.</p> </li> </ul> <p>Which One is Most Used?</p> <ul> <li> <p>Private Routes (Authenticated Routes) are the most common for simpler apps or apps where users simply need to be logged in to access protected areas. Examples of this type of access control include personal blogs, e-commerce sites with user accounts, or social networks.</p> </li> <li> <p>Role-Based Access Control (RBAC Routes) are widely used as well, especially in applications with more complex user management. As soon as you have multiple roles with different permissions (like admins, users, or moderators), you\u2019ll need to implement RBAC for more granular control over what each user can do.</p> </li> </ul> <p>Conclusion</p> <p>For a typical React app:</p> <ul> <li>Private Routes are the most commonly used when dealing with basic authentication needs (ensuring users are logged in).</li> <li>RBAC Routes become necessary as the app grows in complexity and needs more detailed user access management based on roles.</li> </ul> <p>In short: if your app involves just logging users in and letting them access certain sections, Private Routes will be sufficient. However, as your app grows in complexity and you need to differentiate between users (e.g., admins vs. regular users), Role-Based Access Control (RBAC) becomes the go-to solution.</p>"},{"location":"frontend/router/types/types-of-router/","title":"Types of Router","text":""},{"location":"frontend/router/types/types-of-router/#overview","title":"Overview","text":"<p>In React, routing is typically handled by a library called React Router. It allows developers to manage navigation within a React application by mapping URLs to different components, thus enabling single-page applications (SPAs).</p> <p>React Router provides several types of routers, each suited to different environments or use cases. Here's a breakdown of the main types of routers in React Router:</p>"},{"location":"frontend/router/types/types-of-router/#1-browserrouter","title":"1. BrowserRouter","text":"<ul> <li>Usage: This is the most common router used for web applications that run in the browser.</li> <li>Description: <code>BrowserRouter</code> uses the HTML5 history API to keep the UI in sync with the URL. It allows for cleaner URLs (e.g., <code>https://example.com/about</code>), without the hash (<code>#</code>) symbol. It is best suited for traditional web apps where the server supports client-side routing.</li> </ul> <pre><code>import { BrowserRouter as Router, Route, Switch } from \"react-router-dom\";\n\n&lt;Router&gt;\n  &lt;Switch&gt;\n    &lt;Route path=\"/\" component={Home} /&gt;\n    &lt;Route path=\"/about\" component={About} /&gt;\n  &lt;/Switch&gt;\n&lt;/Router&gt;;\n</code></pre>"},{"location":"frontend/router/types/types-of-router/#2-hashrouter","title":"2. HashRouter","text":"<ul> <li>Usage: This router is often used for applications that are deployed on static file servers or environments that don't support HTML5 history API.</li> <li>Description: <code>HashRouter</code> uses the URL's hash (#) to manage routing. This is useful for scenarios where server-side configurations cannot handle direct URL routing or for environments where you don't have access to modify the server. It results in URLs like <code>http://example.com/#/about</code> rather than <code>http://example.com/about</code>.</li> </ul> <pre><code>import { HashRouter as Router, Route, Switch } from \"react-router-dom\";\n\n&lt;Router&gt;\n  &lt;Switch&gt;\n    &lt;Route path=\"/\" component={Home} /&gt;\n    &lt;Route path=\"/about\" component={About} /&gt;\n  &lt;/Switch&gt;\n&lt;/Router&gt;;\n</code></pre>"},{"location":"frontend/router/types/types-of-router/#3-memoryrouter","title":"3. MemoryRouter","text":"<ul> <li>Usage: This is often used in testing, React Native applications, or situations where you want to keep the navigation history in memory and don't need it to be reflected in the URL.</li> <li>Description: <code>MemoryRouter</code> keeps track of the history in memory (instead of the URL or the browser's history stack). It's suitable for use cases where the application doesn't need a real browser history, such as in non-browser environments (e.g., React Native, testing).</li> </ul> <pre><code>import { MemoryRouter as Router, Route, Switch } from \"react-router-dom\";\n\n&lt;Router initialEntries={[\"/\"]} initialIndex={0}&gt;\n  &lt;Switch&gt;\n    &lt;Route path=\"/\" component={Home} /&gt;\n    &lt;Route path=\"/about\" component={About} /&gt;\n  &lt;/Switch&gt;\n&lt;/Router&gt;;\n</code></pre>"},{"location":"frontend/router/types/types-of-router/#summary-of-routers","title":"Summary of Routers:","text":"Router Type Usage Description BrowserRouter For client-side routing in web applications. Uses the browser's history API for clean URLs and full control over navigation. HashRouter For environments that cannot use the HTML5 history API. Uses the hash (<code>#</code>) in the URL to track routes (common in static file hosting). MemoryRouter For non-browser environments, such as React Native or tests. Keeps the history stack in memory rather than the URL bar, not reflected in the browser's address. StaticRouter For server-side rendering (SSR) in React apps. Used to render React components on the server, where the location is passed in as a prop."},{"location":"frontend/router/types/types-of-router/#choosing-the-right-router","title":"Choosing the Right Router:","text":"<ul> <li>BrowserRouter is generally the best option for standard web applications that run in modern browsers.</li> <li>HashRouter is useful if you're hosting the app on a static file server or need to work around server limitations.</li> <li>MemoryRouter is helpful for SSR or testing environments, where URL manipulation isn't required.</li> <li>StaticRouter is used specifically in SSR contexts, where you're rendering the app server-side.</li> </ul> <p>If you're building a standard web app, you\u2019ll most likely use BrowserRouter, but depending on your environment and needs, other routers might be more appropriate.</p>"},{"location":"frontend/router/types/types-of-router/#reference","title":"Reference","text":"<ul> <li>Types and Implementation Methods</li> <li>Relative Vs Dynamic Routing in React - Routing Method</li> <li>React JS Types of Routers</li> <li>Understanding the Three Types of Routers in React</li> <li>A complete guide to routing in React</li> <li>Offical doc</li> </ul>"},{"location":"frontend/router/version/v6/","title":"v6","text":""},{"location":"frontend/router/version/v6/#react-router","title":"React Router","text":"<ul> <li>React Router v6 Update: Updated PrivateRoute to use Navigate instead of Redirect.</li> <li>Component Validation: Ensured PrivateRoute validates its props with PropTypes.</li> <li>Router Configuration: Updated App component to use Routes and Route components from react-router-dom v6.</li> </ul> <p>By making these changes, your code will be compatible with react-router-dom version 6, and you should no longer encounter the issue with the Redirect component.</p> <p>React Router is a popular library used for routing in React applications. It allows you to handle navigation and rendering of different components based on the URL, enabling single-page application (SPA) behavior.</p>"},{"location":"frontend/router/version/v6/#versions-of-react-router","title":"Versions of React Router","text":"<p>React Router has undergone several major versions, each introducing significant changes and improvements:</p> <ol> <li>React Router v1 and v2: Early versions focused on basic routing capabilities.</li> <li>React Router v3: Provided a more stable API but started showing limitations in terms of flexibility and ease of use.</li> <li>React Router v4: Introduced a major overhaul with a declarative approach to routing, enabling more powerful and flexible routing capabilities.</li> <li>React Router v5: Built on v4's foundation, providing incremental improvements and more features while maintaining backward compatibility.</li> <li>React Router v6: Another major update with significant changes to the API, simplifying and modernizing routing in React applications.</li> </ol>"},{"location":"frontend/router/version/v6/#major-updates-and-changes","title":"Major Updates and Changes","text":""},{"location":"frontend/router/version/v6/#react-router-v4","title":"React Router v4","text":"<ul> <li>Declarative Routing: Introduced a new approach where routes are declared as components, making the routing logic more intuitive and easier to manage.</li> <li>Dynamic Routing: Allowed routes to be dynamic, enabling more flexibility.</li> <li>Nested Routes: Improved support for nested routes, making it easier to build complex routing structures.</li> <li>Removal of Route Configuration: Moved away from centralized route configuration to a component-based approach.</li> </ul>"},{"location":"frontend/router/version/v6/#react-router-v5","title":"React Router v5","text":"<ul> <li>Incremental Improvements: Built on v4, adding minor enhancements and optimizations while maintaining the same declarative approach.</li> <li>Hooks Support: Introduced hooks like <code>useHistory</code>, <code>useLocation</code>, <code>useParams</code>, and <code>useRouteMatch</code> for more flexible and powerful routing.</li> <li>Suspense Integration: Improved integration with React's Suspense for data fetching and code splitting.</li> </ul>"},{"location":"frontend/router/version/v6/#react-router-v6","title":"React Router v6","text":"<ul> <li>Simplified API: Major overhaul with a more straightforward and simplified API.</li> <li>Routes and Route Elements: Introduced the Routes and Route elements, replacing Switch and Route from previous versions.</li> <li>Nested Routes: Enhanced nested routing with a more intuitive approach.</li> <li>Data Loading: Integrated better support for data loading and fetching, aligning with modern React patterns.</li> <li>Improved TypeScript Support: Enhanced TypeScript support for better type checking and developer experience.</li> <li>URL-based State: Improved handling of state through URLs, making it easier to manage state with routing.</li> <li>Route Definitions: Allowed defining routes as objects or elements, providing more flexibility.</li> </ul>"},{"location":"frontend/router/version/v6/#example-comparison","title":"Example Comparison","text":"React Router v5 <pre><code>import { BrowserRouter as Router, Switch, Route, Redirect } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Switch&gt;\n            &lt;Route path=\"/login\" component={Login} /&gt;\n            &lt;PrivateRoute path=\"/dashboard\" component={Dashboard} /&gt;\n            &lt;Redirect from=\"/\" to=\"/dashboard\" /&gt;\n        &lt;/Switch&gt;\n    &lt;/Router&gt;\n);\n</code></pre> React Router v6 <pre><code>import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Routes&gt;\n            &lt;Route path=\"/login\" element={&lt;Login /&gt;} /&gt;\n            &lt;Route path=\"/dashboard\" element={&lt;PrivateRoute component={Dashboard} /&gt;} /&gt;\n            &lt;Route path=\"*\" element={&lt;Navigate to=\"/dashboard\" /&gt;} /&gt;\n        &lt;/Routes&gt;\n    &lt;/Router&gt;\n);\n</code></pre>"},{"location":"frontend/router/version/v6/#summary-of-major-changes-in-v6","title":"Summary of Major Changes in v6","text":"<ol> <li><code>Switch</code> replaced by <code>Routes</code>: <code>Switch</code> component is replaced by <code>Routes</code>.</li> <li><code>component</code> and <code>render</code> replaced by <code>element</code>: The <code>component</code> and <code>render</code> props are replaced by <code>element</code>.</li> <li><code>Redirect</code> replaced by <code>Navigate</code>: <code>Redirect</code> component is replaced by <code>Navigate</code>.</li> <li>Route Definitions: Routes can now be defined using nested <code>Route</code> elements.</li> <li>Hooks and Context API: Improved hooks and context for routing logic.</li> <li>Improved TypeScript Support: Better TypeScript support for static type checking.</li> </ol> <p>By understanding these changes, you can effectively use React Router in your projects and take advantage of the latest features and improvements.</p>"},{"location":"frontend/state-management/intro/","title":"Intro","text":"<p>Most developers use Redux, Recoil, Mobx, and other third-party libraries to manage the global state in large-scale applications.</p> <ul> <li> <p> Redux</p> <p>A JS library for predictable and maintainable global state management.</p> <p> Reference</p> </li> <li> <p> Mobx</p> <p>MobX is a signal based, battle-tested library that makes state management simple and scalable by transparently applying functional reactive programming. </p> <p> Reference</p> </li> <li> <p> Recoil</p> <p>A state management library for React.</p> <p> Reference</p> </li> <li> <p> Zustand</p> <p>A small, fast, and scalable bearbones state management solution.</p> <p> Reference</p> </li> </ul>"},{"location":"frontend/state-management/middleware/","title":"Intro","text":"<ul> <li> <p> redux-thunk </p> </li> <li> <p> redux-saga </p> </li> </ul>"},{"location":"frontend/state-management/middleware/#question","title":"Question","text":""},{"location":"frontend/state-management/middleware/#middleware-in-react","title":"Middleware in react","text":"<p>why do we need middleware in react. what do we need it. when do we need it. what is the problem. what exactly the problem does it solve. when do we do not need it. example me clearly and simply.</p> <p>Middleware in React is commonly associated with state management libraries like Redux. Middleware provides a way to extend the capabilities of Redux by adding custom functionality to the dispatching of actions. Here's a breakdown of why and when you might need middleware, what problems it solves, and when you might not need it.</p>"},{"location":"frontend/state-management/middleware/#why-do-we-need-middleware","title":"Why Do We Need Middleware?","text":"<ol> <li> <p>Enhance Dispatching:</p> <p>Middleware allows you to enhance the behavior of the dispatch function. This can include logging actions, handling asynchronous actions, or modifying actions before they reach the reducer.</p> </li> <li> <p>Asynchronous Actions:</p> <p>By default, Redux actions are synchronous. Middleware like redux-thunk or redux-saga allows you to handle asynchronous operations (e.g., API calls) within your action creators.</p> </li> <li> <p>Side Effects Management:</p> <p>Middleware helps manage side effects in a predictable manner, ensuring that the state changes in response to actions are manageable and traceable.</p> </li> </ol>"},{"location":"frontend/state-management/middleware/#what-problems-does-middleware-solve","title":"What Problems Does Middleware Solve?","text":"<ol> <li> <p>Handling Async Logic:</p> <p>Middleware allows you to write asynchronous logic that interacts with the Redux store. Without middleware, you'd have to handle async logic outside of Redux, which can lead to a less organized codebase.</p> </li> <li> <p>Action Logging:</p> <p>Middleware can log every action dispatched, along with the state before and after the action. This is helpful for debugging and understanding the flow of actions in your application.</p> </li> <li> <p>Centralized Error Handling:</p> <p>Middleware can be used to catch and handle errors that occur during the dispatching of actions, ensuring that your application remains stable.</p> </li> </ol>"},{"location":"frontend/state-management/middleware/#when-do-you-need-middleware","title":"When Do You Need Middleware?","text":"<ul> <li> <p>Asynchronous Data Fetching:</p> <p>If your application needs to fetch data from an API or handle other asynchronous operations, middleware like redux-thunk or redux-saga is necessary.</p> </li> <li> <p>Complex State Management:</p> <p>When your application has complex state transitions and side effects that need to be managed in a centralized way.</p> </li> <li> <p>Enhanced Debugging:</p> <p>To provide better debugging and logging capabilities, middleware can be very useful.</p> </li> </ul>"},{"location":"frontend/state-management/middleware/#when-do-you-not-need-middleware","title":"When Do You Not Need Middleware?","text":"<ul> <li> <p>Simple Applications:</p> <p>For simple applications with straightforward state management and no asynchronous operations, middleware might be overkill.</p> </li> <li> <p>Local State Management:</p> <p>If your state management needs are limited to a few components, using local component state and React's context API might be sufficient.</p> </li> </ul>"},{"location":"frontend/state-management/middleware/#example","title":"Example","text":"<p>Let's consider a simple example using redux-thunk to handle an asynchronous API call.</p>"},{"location":"frontend/state-management/middleware/#without-middleware-synchronous","title":"Without Middleware (Synchronous)","text":"<pre><code>// actions.js\nexport const increment = () =&gt; ({\n  type: 'INCREMENT'\n});\n\n// reducer.js\nconst counter = (state = 0, action) =&gt; {\n  switch (action.type) {\n    case 'INCREMENT':\n      return state + 1;\n    default:\n      return state;\n  }\n};\n</code></pre>"},{"location":"frontend/state-management/middleware/#with-middleware-asynchronous","title":"With Middleware (Asynchronous)","text":"<pre><code>// actions.js\nexport const fetchUserData = () =&gt; {\n  return async (dispatch) =&gt; {\n    dispatch({ type: 'FETCH_USER_REQUEST' });\n    try {\n      const response = await fetch('https://api.example.com/user');\n      const data = await response.json();\n      dispatch({ type: 'FETCH_USER_SUCCESS', payload: data });\n    } catch (error) {\n      dispatch({ type: 'FETCH_USER_FAILURE', error });\n    }\n  };\n};\n\n// reducer.js\nconst user = (state = { data: null, loading: false, error: null }, action) =&gt; {\n  switch (action.type) {\n    case 'FETCH_USER_REQUEST':\n      return { ...state, loading: true, error: null };\n    case 'FETCH_USER_SUCCESS':\n      return { ...state, loading: false, data: action.payload };\n    case 'FETCH_USER_FAILURE':\n      return { ...state, loading: false, error: action.error };\n    default:\n      return state;\n  }\n};\n</code></pre> <p>In this example, redux-thunk middleware allows us to handle the asynchronous API call within the action creators, making it easier to manage the state transitions related to fetching user data.</p>"},{"location":"frontend/state-management/middleware/#summary","title":"Summary","text":"<p>Middleware in React (typically used with Redux) is essential for managing complex state transitions, especially when dealing with asynchronous operations. It extends the capabilities of the Redux store, allowing for enhanced dispatching, centralized error handling, and better debugging. While it's invaluable for complex applications, simpler applications might not need middleware.</p>"},{"location":"frontend/state-management/mobx/intro/","title":"Intro","text":"<p>mobx</p>"},{"location":"frontend/state-management/recoil/intro/","title":"Intro","text":"<p>recoil</p>"},{"location":"frontend/state-management/redux/intro/","title":"Intro","text":"<ul> <li> <p> Standard Redux</p> <p>Install <code>mkdocs-material</code> with <code>pip</code> and get up and running in minutes</p> <p> Getting started</p> </li> <li> <p> RTK Redux</p> <p>Focus on your content and generate a responsive and searchable static site</p> <p> Reference</p> </li> </ul>"},{"location":"frontend/state-management/redux/intro/#standard-redux-vs-redux-toolkit","title":"Standard Redux <code>vs</code> Redux Toolkit","text":"<p>what is the major difference between the standard redux and redux toolkit</p> <p>Redux Toolkit (RTK) is essentially an official, recommended way to write Redux logic. It simplifies many aspects of using Redux, making it easier to set up and use. Here are the major differences between standard Redux and Redux Toolkit:</p>"},{"location":"frontend/state-management/redux/intro/#1-boilerplate-code","title":"1. Boilerplate Code","text":"<ul> <li>Standard Redux: Requires a lot of boilerplate code for actions, reducers, and store configuration. You need to manually create action types, action creators, and handle state updates in reducers.</li> <li>Redux Toolkit: Reduces boilerplate significantly. It provides functions like <code>createSlice</code>, which automatically generates action creators and action types based on the reducer functions you define.</li> </ul>"},{"location":"frontend/state-management/redux/intro/#2-store-configuration","title":"2. Store Configuration","text":"<ul> <li>Standard Redux: Setting up the store requires a lot of manual configuration, especially if you need middleware or enhancers.</li> <li>Redux Toolkit: <code>configureStore</code> simplifies store setup, automatically applying useful middleware like Redux Thunk and enabling the Redux DevTools extension by default.</li> </ul>"},{"location":"frontend/state-management/redux/intro/#3-immutable-state-updates","title":"3. Immutable State Updates","text":"<ul> <li>Standard Redux: You have to manually ensure immutability in state updates, which can lead to bugs if not done correctly.</li> <li>Redux Toolkit: Uses the Immer library internally, allowing you to write \"mutative\" logic in reducers. You can directly modify the state without worrying about immutability, and Immer takes care of the necessary immutability under the hood.</li> </ul>"},{"location":"frontend/state-management/redux/intro/#4-built-in-middleware","title":"4. Built-in Middleware","text":"<ul> <li>Standard Redux: You need to set up middleware like Thunk or Saga manually for handling asynchronous logic.</li> <li>Redux Toolkit: Comes with built-in support for Thunk. You can easily add custom middleware as needed.</li> </ul>"},{"location":"frontend/state-management/redux/intro/#5-creating-selectors","title":"5. Creating Selectors","text":"<ul> <li>Standard Redux: You often have to write selectors manually and might create a separate file for them.</li> <li>Redux Toolkit: While you can still create selectors, RTK encourages using <code>createSlice</code> and <code>createAsyncThunk</code>, which can simplify the way you handle state and asynchronous operations.</li> </ul>"},{"location":"frontend/state-management/redux/intro/#6-asynchronous-logic-handling","title":"6. Asynchronous Logic Handling","text":"<ul> <li>Standard Redux: Managing side effects and asynchronous logic often involves writing additional code and using middleware like Redux Thunk or Redux Saga.</li> <li>Redux Toolkit: Provides <code>createAsyncThunk</code>, a utility that simplifies the process of handling asynchronous actions, automatically dispatching pending, fulfilled, and rejected action types.</li> </ul>"},{"location":"frontend/state-management/redux/intro/#7-best-practices","title":"7. Best Practices","text":"<ul> <li>Standard Redux: While it\u2019s powerful, it requires a deeper understanding of Redux concepts and often leads to inconsistencies in how developers implement Redux in projects.</li> <li>Redux Toolkit: Encourages best practices and provides a consistent way to write Redux logic, making it easier for new developers to adopt.</li> </ul>"},{"location":"frontend/state-management/redux/intro/#summary","title":"Summary","text":"<p>In summary, Redux Toolkit streamlines the process of using Redux by reducing boilerplate, simplifying store configuration, and encouraging best practices. It makes it easier to manage state in applications, especially for new developers or those working on complex applications. If you're starting a new Redux project, using Redux Toolkit is highly recommended!</p>"},{"location":"frontend/state-management/redux/intro/#reference","title":"Reference","text":"<ul> <li>redux-thunk: github</li> <li>Redux docs: Writing Logic with Thunks</li> <li>Stack Overflow: Dispatching Redux Actions with a Timeout</li> <li>Stack Overflow: Why do we need middleware for async flow in Redux?</li> <li>What the heck is a \"thunk\"?</li> <li>Thunks in Redux: The Basics</li> </ul>"},{"location":"frontend/state-management/redux/react-redux/","title":"react-redux","text":"<p>React-Redux is a binding library that connects React with Redux.</p> <pre><code>npm install react-redux\n</code></pre> What React-Redux DoesWhat Happens if You Don't Use React-Redux <ol> <li>Connects React with Redux: React-Redux provides the necessary bindings to enable React components to interact with the Redux store, allowing them to access the global state and dispatch actions.</li> <li>State Management: It allows components to subscribe to specific parts of the Redux state, enabling them to automatically update when that state changes.</li> <li>Dispatch Actions: React-Redux provides a way to dispatch actions directly from React components, helping to trigger state changes in the Redux store.</li> <li>Performance Optimization: It optimizes performance by ensuring that components only re-render when the specific state slices they use change, rather than re-rendering for every state change.</li> <li>Provides Hooks: It offers hooks like <code>useSelector</code> and <code>useDispatch</code>, which simplify state access and action dispatching in functional components, promoting a cleaner code structure.</li> </ol> <ol> <li>Manual State Management: Without React-Redux, you\u2019d have to manage global state manually, often by passing state and functions through props from parent to child components. This can lead to \"prop drilling,\" where props need to be passed through many layers of components.</li> <li>Complexity and Boilerplate: You might end up writing more boilerplate code to manage state and handle updates, making your application harder to maintain and read.</li> <li>Performance Issues: You may face performance issues, as every component might re-render for any state change if you don\u2019t implement a selective update strategy manually.</li> <li>Difficulty in Scaling: As your application grows, managing state without a centralized solution can become cumbersome and error-prone, making it challenging to keep track of where state is being modified.</li> <li>Limited Tooling: You miss out on the ecosystem of tools and middleware available with Redux (like Redux DevTools) that aid in debugging and state tracking.</li> </ol> <p>Summary</p> <p>Using React-Redux simplifies state management, enhances performance, and keeps your codebase organized, especially in larger applications. Not using it can lead to increased complexity, inefficiencies, and maintenance challenges.</p>"},{"location":"frontend/state-management/redux/react-redux/#example-with-react-redux","title":"Example with React-Redux","text":"Example InstallStoreSliceProviderComponent <ol> <li> <p>Install Dependencies: If you haven't already, install React-Redux and Redux Toolkit:</p> <pre><code>npm install @reduxjs/toolkit react-redux\n</code></pre> </li> </ol> <ol> <li> <p>Set Up Redux Store:</p> <p>Create a file <code>src/app/store.js</code>:</p> <pre><code>import { configureStore } from '@reduxjs/toolkit';\nimport counterReducer from '../features/counterSlice';\n\nconst store = configureStore({\n    reducer: {\n        counter: counterReducer,\n    },\n});\n\nexport default store;\n</code></pre> </li> </ol> <ol> <li> <p>Create a Slice:</p> <p>Create a file <code>src/features/counterSlice.js</code>:</p> <pre><code>import { createSlice } from '@reduxjs/toolkit';\n\nconst counterSlice = createSlice({\n    name: 'counter',\n    initialState: { value: 0 },\n    reducers: {\n        increment: (state) =&gt; {\n            state.value += 1;\n        },\n        decrement: (state) =&gt; {\n            state.value -= 1;\n        },\n    },\n});\n\nexport const { increment, decrement } = counterSlice.actions;\nexport default counterSlice.reducer;\n</code></pre> </li> </ol> <ol> <li> <p>Set Up Provider:</p> <p>Modify <code>src/index.js</code> to wrap your app with the Redux Provider:</p> <pre><code>import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport App from './App';\nimport { Provider } from 'react-redux';\nimport store from './app/store';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\n\nroot.render(\n    &lt;Provider store={store}&gt;\n        &lt;App /&gt;\n    &lt;/Provider&gt;\n);\n</code></pre> </li> </ol> <ol> <li> <p>Create a Counter Component:</p> <p>Modify <code>src/App.js</code>:</p> <pre><code>import React from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { increment, decrement } from './features/counterSlice';\n\nfunction App() {\n    const count = useSelector((state) =&gt; state.counter.value);\n    const dispatch = useDispatch();\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Count: {count}&lt;/h1&gt;\n            &lt;button onClick={() =&gt; dispatch(increment())}&gt;Increment&lt;/button&gt;\n            &lt;button onClick={() =&gt; dispatch(decrement())}&gt;Decrement&lt;/button&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default App;\n</code></pre> </li> </ol>"},{"location":"frontend/state-management/redux/react-redux/#example-without-react-redux","title":"Example Without React-Redux","text":"Example 1. Set Up State in the Component: <p>Modify <code>src/App.js</code> to manage state without Redux:</p> <pre><code>import React, { useState } from \"react\";\n\nfunction App() {\n    const [count, setCount] = useState(0);\n\n    const increment = () =&gt; {\n        setCount((prevCount) =&gt; prevCount + 1);\n    };\n\n    const decrement = () =&gt; {\n        setCount((prevCount) =&gt; prevCount - 1);\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Count: {count}&lt;/h1&gt;\n            &lt;button onClick={increment}&gt;Increment&lt;/button&gt;\n            &lt;button onClick={decrement}&gt;Decrement&lt;/button&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default App;\n</code></pre> <p>Summary</p> <ul> <li>With React-Redux: State is managed globally, allowing easy access and updates from any component. You use useSelector to read state and useDispatch to modify it.</li> <li>Without React-Redux: State is managed locally within the component, requiring you to handle state passing and updates through props when dealing with nested components.</li> </ul> <p>Using React-Redux simplifies state management, especially in larger applications, while managing state locally can quickly become cumbersome in more complex scenarios.</p>"},{"location":"frontend/state-management/redux/react-redux/#additional","title":"Additional","text":"<p>in the counterSlice.js there no counterReducer. how does it import import counterReducer from '../features/counterSlice'; i dont understand</p> <p>Great question! The <code>counterReducer</code> in <code>counterSlice.js</code> is actually the default export of the slice you create with <code>createSlice</code>. Let's clarify how this works.</p> <p>Breakdown of <code>counterSlice.js</code></p> <p>When you create a slice with <code>createSlice</code>, it automatically generates a reducer function for you, which you can export. Here\u2019s the key part of the code:</p> ExampleExplanation <pre><code>import { createSlice } from '@reduxjs/toolkit';\n\nconst counterSlice = createSlice({\n    name: 'counter',\n    initialState: { value: 0 },\n    reducers: {\n        increment: (state) =&gt; {\n            state.value += 1;\n        },\n        decrement: (state) =&gt; {\n            state.value -= 1;\n        },\n    },\n});\n\n// Export actions\nexport const { increment, decrement } = counterSlice.actions;\n\n// Export the reducer\nexport default counterSlice.reducer;  // This is counterReducer\n</code></pre> <ol> <li> <p>Creating the Slice: The <code>createSlice</code> function creates a slice object that contains:</p> <ul> <li>The slice name.</li> <li>The initial state.</li> <li>Reducers that handle state updates.</li> </ul> </li> <li> <p>Exporting the Reducer: The line <code>export default counterSlice.reducer;</code> exports the reducer function, which is the default export of this module. This exported function can be referred to as <code>counterReducer</code> in the <code>store.js</code> file.</p> </li> </ol> <p>In <code>store.js</code></p> <p>When you import it like this:</p> <pre><code>import counterReducer from \"../features/counterSlice\";\n</code></pre> <p>You are actually importing the default export from <code>counterSlice.js</code>, which is the reducer function generated by <code>createSlice</code>.</p> <p>Summary</p> <ul> <li>The <code>counterReducer</code> is the default export from the <code>counterSlice.js</code> file, which is the reducer created by <code>createSlice</code>.</li> <li>You can name it anything when you import it (like <code>counterReducer</code>), as long as you know it's the default export from that file.</li> </ul>"},{"location":"frontend/state-management/redux/core/folder-structure/","title":"Folder Structure","text":"<p>Application Structure for React.js</p>"},{"location":"frontend/state-management/redux/core/folder-structure/#redux-thunk","title":"Redux Thunk","text":"<p>To use an API in a React application with Redux Thunk, you'll need to follow these steps:</p> <ol> <li> <p>Set up Redux Thunk: Ensure you have Redux and Redux Thunk installed and configured in your React application.</p> </li> <li> <p>Create an API Service: Create a file to manage your API calls, typically using a library like axios or fetch.</p> </li> <li> <p>Create Action Types: Define the action types for your API calls.</p> </li> <li> <p>Create Actions: Use Redux Thunk to create asynchronous actions that dispatch the appropriate actions based on the API response.</p> </li> <li> <p>Create Reducers: Create reducers to handle the actions and update the state accordingly.</p> </li> <li> <p>Connect Redux to React Components: Use <code>connect</code> or hooks (<code>useSelector</code> and <code>useDispatch</code>) to connect your React components to the Redux store.</p> </li> </ol>"},{"location":"frontend/state-management/redux/core/folder-structure/#set-up-redux-thunk","title":"Set up Redux Thunk","text":"<pre><code>npm install redux react-redux redux-thunk axios\n</code></pre>"},{"location":"frontend/state-management/redux/core/folder-structure/#basic","title":"Basic","text":"<pre><code>my-app/\n\u251c\u2500\u2500 node_modules/\n\u251c\u2500\u2500 public/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 actions/\n\u2502   \u2502   \u251c\u2500\u2500 actionTypes.js\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u251c\u2500\u2500 api/\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u251c\u2500\u2500 components/\n\u2502   \u2502   \u2514\u2500\u2500 DataComponent.js\n\u2502   \u251c\u2500\u2500 reducers/\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u251c\u2500\u2500 store/\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u251c\u2500\u2500 App.js\n\u2502   \u251c\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 index.css\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 package-lock.json\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"frontend/state-management/redux/core/folder-structure/#folder-structure-explanation","title":"Folder Structure Explanation","text":"<ul> <li> <p>actions/: Contains action types and action creators.</p> </li> <li> <p>actionTypes.js: Defines the action types.</p> </li> <li> <p>index.js: Contains action creators using Redux Thunk.</p> </li> <li> <p>api/: Contains API service functions.</p> </li> <li> <p>index.js: Defines the functions to make API calls (e.g., using axios).</p> </li> <li> <p>components/: Contains React components.</p> </li> <li> <p>DataComponent.js: Example component that uses Redux Thunk to fetch and display data.</p> </li> <li> <p>reducers/: Contains Redux reducers.</p> </li> <li> <p>index.js: Combines and exports all the reducers.</p> </li> <li> <p>store/: Contains the Redux store configuration.</p> </li> <li> <p>index.js: Sets up the Redux store with Thunk middleware.</p> </li> <li> <p>App.js: Main app component.</p> </li> <li> <p>index.js: Entry point of the application, where you set up React and Redux.</p> </li> <li> <p>index.css: Global CSS file for styling.</p> </li> </ul>"},{"location":"frontend/state-management/redux/core/folder-structure/#example-files","title":"Example Files","text":"Example actions/api/components/reducers/store/App.jsindex.js actionTypes.jsindex.js <pre><code>export const FETCH_DATA_REQUEST = 'FETCH_DATA_REQUEST';\nexport const FETCH_DATA_SUCCESS = 'FETCH_DATA_SUCCESS';\nexport const FETCH_DATA_FAILURE = 'FETCH_DATA_FAILURE';\n</code></pre> <pre><code>import {\n    FETCH_DATA_REQUEST,\n    FETCH_DATA_SUCCESS,\n    FETCH_DATA_FAILURE,\n} from './actionTypes';\nimport { fetchData } from '../api';\n\nexport const fetchDataRequest = () =&gt; ({\n    type: FETCH_DATA_REQUEST,\n});\n\nexport const fetchDataSuccess = (data) =&gt; ({\n    type: FETCH_DATA_SUCCESS,\n    payload: data,\n});\n\nexport const fetchDataFailure = (error) =&gt; ({\n    type: FETCH_DATA_FAILURE,\n    payload: error,\n});\n\nexport const fetchDataThunk = () =&gt; {\n    return (dispatch) =&gt; {\n        dispatch(fetchDataRequest());\n        fetchData()\n            .then((response) =&gt; {\n                dispatch(fetchDataSuccess(response.data));\n            })\n            .catch((error) =&gt; {\n                dispatch(fetchDataFailure(error.message));\n            });\n    };\n};\n</code></pre> index.js <pre><code>import axios from 'axios';\n\nconst API_URL = 'https://api.example.com';\n\nexport const fetchData = () =&gt; {\n    return axios.get(`${API_URL}/data`);\n};\n</code></pre> DataComponent.js <pre><code>import React, { useEffect } from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { fetchDataThunk } from '../actions';\n\nconst DataComponent = () =&gt; {\n    const dispatch = useDispatch();\n    const dataState = useSelector((state) =&gt; state.data);\n\n    useEffect(() =&gt; {\n        dispatch(fetchDataThunk());\n    }, [dispatch]);\n\n    return (\n        &lt;div&gt;\n            {dataState.loading ? (\n                &lt;p&gt;Loading...&lt;/p&gt;\n            ) : dataState.error ? (\n                &lt;p&gt;Error: {dataState.error}&lt;/p&gt;\n            ) : (\n                &lt;ul&gt;\n                {dataState.data.map((item) =&gt; (\n                    &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;\n                ))}\n                &lt;/ul&gt;\n            )}\n        &lt;/div&gt;\n    );\n};\n\nexport default DataComponent;\n</code></pre> index.js <pre><code>import {\n    FETCH_DATA_REQUEST,\n    FETCH_DATA_SUCCESS,\n    FETCH_DATA_FAILURE,\n} from '../actions/actionTypes';\n\nconst initialState = {\n    loading: false,\n    data: [],\n    error: '',\n};\n\nconst dataReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case FETCH_DATA_REQUEST:\n            return {\n                ...state,\n                loading: true,\n            };\n        case FETCH_DATA_SUCCESS:\n            return {\n                loading: false,\n                data: action.payload,\n                error: '',\n            };\n        case FETCH_DATA_FAILURE:\n            return {\n                loading: false,\n                data: [],\n                error: action.payload,\n            };\n        default:\n            return state;\n    }\n};\n\nexport default combineReducers({\n    data: dataReducer,\n});\n</code></pre> index.js <pre><code>import { createStore, applyMiddleware, combineReducers } from 'redux';\nimport thunk from 'redux-thunk';\nimport dataReducer from '../reducers';\n\nconst rootReducer = combineReducers({\n    data: dataReducer,\n});\n\nconst store = createStore(rootReducer, applyMiddleware(thunk));\n\nexport default store;\n</code></pre> <pre><code>import React from 'react';\nimport DataComponent from './components/DataComponent';\n\nconst App = () =&gt; (\n    &lt;div className=\"App\"&gt;\n        &lt;DataComponent /&gt;\n    &lt;/div&gt;\n);\n\nexport default App;\n</code></pre> <pre><code>import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport store from './store';\nimport App from './App';\nimport './index.css';\n\nReactDOM.render(\n    &lt;Provider store={store}&gt;\n        &lt;App /&gt;\n    &lt;/Provider&gt;,\n    document.getElementById('root')\n);\n\n// or\n\nReactDOM.createRoot(document.getElementById('root')).render(\n    &lt;React.StrictMode&gt;\n        &lt;Provider store={store}&gt;\n            &lt;App /&gt;\n        &lt;/Provider&gt;\n    &lt;/React.StrictMode&gt;\n);\n</code></pre> <p>This structure helps you organize your code in a modular and maintainable way. Each part of your application is separated by its responsibility, making it easier to manage and scale.</p>"},{"location":"frontend/state-management/redux/core/folder-structure/#intermediate-example","title":"Intermediate Example","text":"<pre><code>src/\n\u251c\u2500\u2500 api/\n\u2502   \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 components/\n\u2502   \u2514\u2500\u2500 DataComponent.js\n\u251c\u2500\u2500 redux/\n\u2502   \u251c\u2500\u2500 actions/\n\u2502   \u2502   \u251c\u2500\u2500 actionTypes.js\n\u2502   \u2502   \u2514\u2500\u2500 dataActions.js\n\u2502   \u251c\u2500\u2500 reducers/\n\u2502   \u2502   \u251c\u2500\u2500 dataReducer.js\n\u2502   \u2502   \u2514\u2500\u2500 rootReducer.js\n\u2502   \u251c\u2500\u2500 store/\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 selectors/\n\u2502       \u2514\u2500\u2500 dataSelectors.js\n\u251c\u2500\u2500 App.js\n\u251c\u2500\u2500 index.js\n\u251c\u2500\u2500 index.css\n\u2514\u2500\u2500 utils/\n    \u2514\u2500\u2500 apiHelpers.js\n</code></pre>"},{"location":"frontend/state-management/redux/core/folder-structure/#folder-structure-explanation_1","title":"Folder Structure Explanation","text":"<ul> <li> <p>api/: Contains files related to API calls.</p> </li> <li> <p>index.js: Manages API requests.</p> </li> <li> <p>components/: Contains reusable React components.</p> </li> <li> <p>DataComponent.js: Example component.</p> </li> <li> <p>redux/: Contains all Redux-related logic.</p> </li> <li> <p>actions/: Contains action types and action creators.</p> <ul> <li>actionTypes.js: Defines action types.</li> <li>dataActions.js: Contains action creators related to data.</li> </ul> </li> <li>reducers/: Contains reducer functions.<ul> <li>dataReducer.js: Reducer for data-related actions.</li> <li>rootReducer.js: Combines all reducers.</li> </ul> </li> <li>store/: Contains the Redux store configuration.<ul> <li>index.js: Sets up the Redux store with middleware.</li> </ul> </li> <li> <p>selectors/: Contains selector functions.</p> <ul> <li>dataSelectors.js: Selectors for accessing data state.</li> </ul> </li> <li> <p>utils/: Contains utility functions and helpers.</p> </li> <li>apiHelpers.js: Helper functions for API calls.</li> </ul>"},{"location":"frontend/state-management/redux/core/folder-structure/#example-files_1","title":"Example Files","text":"redux/ /actions//reducers//store//selectors/ /actionTypes.js/dataActions.js <pre><code>export const FETCH_DATA_REQUEST = 'FETCH_DATA_REQUEST';\nexport const FETCH_DATA_SUCCESS = 'FETCH_DATA_SUCCESS';\nexport const FETCH_DATA_FAILURE = 'FETCH_DATA_FAILURE';\n</code></pre> <pre><code>import {\n    FETCH_DATA_REQUEST,\n    FETCH_DATA_SUCCESS,\n    FETCH_DATA_FAILURE,\n} from './actionTypes';\nimport { fetchData } from '../../api';\n\nexport const fetchDataRequest = () =&gt; ({\n    type: FETCH_DATA_REQUEST,\n});\n\nexport const fetchDataSuccess = (data) =&gt; ({\n    type: FETCH_DATA_SUCCESS,\n    payload: data,\n});\n\nexport const fetchDataFailure = (error) =&gt; ({\n    type: FETCH_DATA_FAILURE,\n    payload: error,\n});\n\nexport const fetchDataThunk = () =&gt; {\n    return (dispatch) =&gt; {\n        dispatch(fetchDataRequest());\n        fetchData()\n            .then((response) =&gt; {\n                dispatch(fetchDataSuccess(response.data));\n            })\n            .catch((error) =&gt; {\n                dispatch(fetchDataFailure(error.message));\n            });\n    };\n};\n</code></pre> /dataReducer.js/rootReducer.js <pre><code>import {\n    FETCH_DATA_REQUEST,\n    FETCH_DATA_SUCCESS,\n    FETCH_DATA_FAILURE,\n} from '../actions/actionTypes';\n\nconst initialState = {\n    loading: false,\n    data: [],\n    error: '',\n};\n\nconst dataReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case FETCH_DATA_REQUEST:\n            return {\n                ...state,\n                loading: true,\n            };\n        case FETCH_DATA_SUCCESS:\n            return {\n                loading: false,\n                data: action.payload,\n                error: '',\n            };\n        case FETCH_DATA_FAILURE:\n            return {\n                loading: false,\n                data: [],\n                error: action.payload,\n            };\n        default:\n            return state;\n    }\n};\n\nexport default dataReducer;\n</code></pre> <pre><code>import { combineReducers } from 'redux';\nimport dataReducer from './dataReducer';\n\nconst rootReducer = combineReducers({\n    data: dataReducer,\n});\n\nexport default rootReducer;\n</code></pre> /index.js <pre><code>import { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport rootReducer from '../reducers/rootReducer';\n\nconst store = createStore(rootReducer, applyMiddleware(thunk));\n\nexport default store;\n</code></pre> /dataSelectors.js <pre><code>export const getDataState = (state) =&gt; state.data;\nexport const getData = (state) =&gt; getDataState(state).data;\nexport const getDataLoading = (state) =&gt; getDataState(state).loading;\nexport const getDataError = (state) =&gt; getDataState(state).error;\n</code></pre>"},{"location":"frontend/state-management/redux/core/folder-structure/#connecting-components","title":"Connecting Components","text":"Example components/App.jsindex.js DataComponent.js<pre><code>import React, { useEffect } from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { fetchDataThunk } from '../redux/actions/dataActions';\nimport { getData, getDataLoading, getDataError } from '../redux/selectors/dataSelectors';\n\nconst DataComponent = () =&gt; {\n    const dispatch = useDispatch();\n    const data = useSelector(getData);\n    const loading = useSelector(getDataLoading);\n    const error = useSelector(getDataError);\n\n    useEffect(() =&gt; {\n        dispatch(fetchDataThunk());\n    }, [dispatch]);\n\n    return (\n        &lt;div&gt;\n            {loading ? (\n                &lt;p&gt;Loading...&lt;/p&gt;\n            ) : error ? (\n                &lt;p&gt;Error: {error}&lt;/p&gt;\n            ) : (\n                &lt;ul&gt;\n                {data.map((item) =&gt; (\n                    &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;\n                ))}\n                &lt;/ul&gt;\n            )}\n        &lt;/div&gt;\n    );\n};\n\nexport default DataComponent;\n</code></pre> <pre><code>//App and index.js\nimport React from 'react';\nimport DataComponent from './components/DataComponent';\n\nconst App = () =&gt; (\n    &lt;div className=\"App\"&gt;\n        &lt;DataComponent /&gt;\n    &lt;/div&gt;\n);\n\nexport default App;\n</code></pre> <pre><code>import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport { Provider } from 'react-redux';\nimport store from './redux/store';\nimport App from './App';\nimport './index.css';\n\nReactDOM.createRoot(document.getElementById('root')).render(\n    &lt;React.StrictMode&gt;\n        &lt;Provider store={store}&gt;\n            &lt;App /&gt;\n        &lt;/Provider&gt;\n    &lt;/React.StrictMode&gt;\n);\n</code></pre> <p>This structure helps maintain a clear separation of concerns, making the codebase easier to manage and scale as the application grows. It also adheres to best practices, making it easier for other developers to understand and contribute to the project.</p>"},{"location":"frontend/state-management/redux/core/folder-structure/#advanced-example","title":"Advanced Example","text":"<pre><code>src/\n\u251c\u2500\u2500 api/\n\u2502   \u2514\u2500\u2500 user.js\n\u251c\u2500\u2500 components/\n\u2502   \u2514\u2500\u2500 UserComponent.js\n\u251c\u2500\u2500 redux/\n\u2502   \u251c\u2500\u2500 actions/\n\u2502   \u2502   \u251c\u2500\u2500 actionTypes.js\n\u2502   \u2502   \u2514\u2500\u2500 userActions.js\n\u2502   \u251c\u2500\u2500 reducers/\n\u2502   \u2502   \u251c\u2500\u2500 entitiesReducer.js\n\u2502   \u2502   \u251c\u2500\u2500 usersReducer.js\n\u2502   \u2502   \u2514\u2500\u2500 rootReducer.js\n\u2502   \u251c\u2500\u2500 selectors/\n\u2502   \u2502   \u2514\u2500\u2500 userSelectors.js\n\u2502   \u251c\u2500\u2500 store/\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 utils/\n\u2502       \u251c\u2500\u2500 normalize.js\n\u2502       \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 App.js\n\u251c\u2500\u2500 index.js\n\u251c\u2500\u2500 index.css\n\u2514\u2500\u2500 utils/\n    \u2514\u2500\u2500 apiHelpers.js\n</code></pre>"},{"location":"frontend/state-management/redux/core/folder-structure/#action","title":"Action","text":"redux/actions/ actionTypes.jsuserActions.js <pre><code>export const FETCH_USER_REQUEST = 'FETCH_USER_REQUEST';\nexport const FETCH_USER_SUCCESS = 'FETCH_USER_SUCCESS';\nexport const FETCH_USER_FAILURE = 'FETCH_USER_FAILURE';\nexport const CREATE_USER_REQUEST = 'CREATE_USER_REQUEST';\nexport const CREATE_USER_SUCCESS = 'CREATE_USER_SUCCESS';\nexport const CREATE_USER_FAILURE = 'CREATE_USER_FAILURE';\n// Other action types...\n</code></pre> <pre><code>import {\n    FETCH_USER_REQUEST,\n    FETCH_USER_SUCCESS,\n    FETCH_USER_FAILURE,\n    CREATE_USER_REQUEST,\n    CREATE_USER_SUCCESS,\n    CREATE_USER_FAILURE,\n} from './actionTypes';\n\nimport {\n    getUserById,\n    createUser,\n    updateUser,\n    deleteUser,\n    searchUsers,\n} from '../../api/user';\n\nimport { normalizeUserData } from '../utils/normalize';\n\n// Fetch user by ID\nexport const fetchUser = (id) =&gt; {\n    return async (dispatch) =&gt; {\n        dispatch({ type: FETCH_USER_REQUEST });\n\n        try {\n            const response = await getUserById(id);\n            const normalizedData = normalizeUserData(response.data);\n            dispatch({ type: FETCH_USER_SUCCESS, payload: normalizedData });\n        } catch (error) {\n            dispatch({ type: FETCH_USER_FAILURE, payload: error.message });\n        }\n    };\n};\n\n// Create user\nexport const addUser = (userData) =&gt; {\n    return async (dispatch) =&gt; {\n        dispatch({ type: CREATE_USER_REQUEST });\n\n        try {\n            const response = await createUser(userData);\n            const normalizedData = normalizeUserData(response.data);\n            dispatch({ type: CREATE_USER_SUCCESS, payload: normalizedData });\n        } catch (error) {\n            dispatch({ type: CREATE_USER_FAILURE, payload: error.message });\n        }\n    };\n};\n\n// Update user\nexport const modifyUser = (id, userData) =&gt; {\n    return async (dispatch) =&gt; {\n        dispatch({ type: UPDATE_USER_REQUEST });\n\n        try {\n            const response = await updateUser(id, userData);\n            const normalizedData = normalizeUserData(response.data);\n            dispatch({ type: UPDATE_USER_SUCCESS, payload: normalizedData });\n        } catch (error) {\n            dispatch({ type: UPDATE_USER_FAILURE, payload: error.message });\n        }\n    };\n};\n\n// Delete user\nexport const removeUser = (id) =&gt; {\n    return async (dispatch) =&gt; {\n        dispatch({ type: DELETE_USER_REQUEST });\n\n        try {\n            await deleteUser(id);\n            dispatch({ type: DELETE_USER_SUCCESS, payload: id });\n        } catch (error) {\n            dispatch({ type: DELETE_USER_FAILURE, payload: error.message });\n        }\n    };\n};\n\n// Search users\nexport const findUsers = (queryParams) =&gt; {\n    return async (dispatch) =&gt; {\n        dispatch({ type: SEARCH_USERS_REQUEST });\n\n        try {\n            const response = await searchUsers(queryParams);\n            const normalizedData = normalizeUserData(response.data);\n            dispatch({ type: SEARCH_USERS_SUCCESS, payload: normalizedData });\n        } catch (error) {\n            dispatch({ type: SEARCH_USERS_FAILURE, payload: error.message });\n        }\n    };\n};\n</code></pre>"},{"location":"frontend/state-management/redux/core/folder-structure/#reducers","title":"Reducers","text":"redux/reducers/ entitiesReducer.jsusersReducer.jsrootReducer.js <p>This reducer handles the normalization of entities, which helps in managing relationships between different entities.</p> <pre><code>import { combineReducers } from 'redux';\nimport {\n    FETCH_USER_SUCCESS,\n    CREATE_USER_SUCCESS,\n    UPDATE_USER_SUCCESS,\n    SEARCH_USERS_SUCCESS,\n} from '../actions/actionTypes';\n\nconst initialState = {\n    users: {},\n};\n\nconst users = (state = initialState.users, action) =&gt; {\n    switch (action.type) {\n        case FETCH_USER_SUCCESS:\n        case CREATE_USER_SUCCESS:\n        case UPDATE_USER_SUCCESS:\n        case SEARCH_USERS_SUCCESS:\n            return {\n                ...state,\n                ...action.payload.entities.users,\n            };\n        default:\n            return state;\n    }\n};\n\nexport default combineReducers({\n    users,\n});\n</code></pre> <p>This reducer handles the specific logic related to users, such as loading states and errors.</p> <pre><code>import {\n    FETCH_USER_REQUEST,\n    FETCH_USER_SUCCESS,\n    FETCH_USER_FAILURE,\n    CREATE_USER_REQUEST,\n    CREATE_USER_SUCCESS,\n    CREATE_USER_FAILURE,\n    UPDATE_USER_REQUEST,\n    UPDATE_USER_SUCCESS,\n    UPDATE_USER_FAILURE,\n    DELETE_USER_REQUEST,\n    DELETE_USER_SUCCESS,\n    DELETE_USER_FAILURE,\n    SEARCH_USERS_REQUEST,\n    SEARCH_USERS_SUCCESS,\n    SEARCH_USERS_FAILURE,\n} from '../actions/actionTypes';\n\nconst initialState = {\n    loading: false,\n    error: null,\n    allIds: [],\n    currentUser: null,\n};\n\nconst usersReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case FETCH_USER_REQUEST:\n        case CREATE_USER_REQUEST:\n        case UPDATE_USER_REQUEST:\n        case DELETE_USER_REQUEST:\n        case SEARCH_USERS_REQUEST:\n            return {\n                ...state,\n                loading: true,\n                error: null,\n            };\n        case FETCH_USER_SUCCESS:\n            return {\n                ...state,\n                loading: false,\n                currentUser: action.payload.result,\n            };\n        case CREATE_USER_SUCCESS:\n            return {\n                ...state,\n                loading: false,\n                allIds: [...state.allIds, action.payload.result],\n            };\n        case UPDATE_USER_SUCCESS:\n            return {\n                ...state,\n                loading: false,\n            };\n        case DELETE_USER_SUCCESS:\n            return {\n                ...state,\n                loading: false,\n                allIds: state.allIds.filter((id) =&gt; id !== action.payload),\n            };\n        case SEARCH_USERS_SUCCESS:\n            return {\n                ...state,\n                loading: false,\n                allIds: action.payload.result,\n            };\n        case FETCH_USER_FAILURE:\n        case CREATE_USER_FAILURE:\n        case UPDATE_USER_FAILURE:\n        case DELETE_USER_FAILURE:\n        case SEARCH_USERS_FAILURE:\n            return {\n                ...state,\n                loading: false,\n                error: action.payload,\n            };\n        default:\n            return state;\n    }\n};\n\nexport default usersReducer;\n</code></pre> <p>Combine the entity and user-specific reducers to create the root reducer.</p> <pre><code>import { combineReducers } from 'redux';\nimport entitiesReducer from './entitiesReducer';\nimport usersReducer from './usersReducer';\n\nconst rootReducer = combineReducers({\n    entities: entitiesReducer,\n    users: usersReducer,\n});\n\nexport default rootReducer;\n</code></pre>"},{"location":"frontend/state-management/redux/core/folder-structure/#normalization","title":"Normalization","text":"<p>Normalize the data received from the API to ensure it is stored in a flat structure, making it easier to manage and update.</p> redux/utils/normalize.js <pre><code>import { normalize, schema } from 'normalizr';\n\n// Define a user schema\nconst user = new schema.Entity('users');\n\n// Define a function to normalize user data\nexport const normalizeUserData = (data) =&gt; {\n    return normalize(data, user);\n};\n</code></pre> <p>Selectors</p> <p>Use selectors to access and derive data from the state, keeping your components clean and focused on rendering.</p> redux/selectors/userSelectors.js <pre><code>import { createSelector } from 'reselect';\n\nexport const getUsersState = (state) =&gt; state.users;\nexport const getEntitiesState = (state) =&gt; state.entities;\n\nexport const getAllUserIds = createSelector(\n    [getUsersState],\n    (usersState) =&gt; usersState.allIds\n);\n\nexport const getUserById = (state, userId) =&gt;\ngetEntitiesState(state).users[userId];\n\nexport const getAllUsers = createSelector(\n    [getAllUserIds, getEntitiesState],\n    (allIds, entities) =&gt; allIds.map((id) =&gt; entities.users[id])\n);\n\nexport const getCurrentUser = createSelector(\n    [getUsersState, getEntitiesState],\n    (usersState, entities) =&gt; entities.users[usersState.currentUser]\n);\n</code></pre>"},{"location":"frontend/state-management/redux/core/folder-structure/#connecting-components_1","title":"Connecting Components","text":"components/UserComponent.js <pre><code>import React, { useEffect } from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { fetchUser, addUser, modifyUser, removeUser, findUsers } from '../redux/actions/userActions';\nimport { getAllUsers, getCurrentUser, getUserLoading, getUserError } from '../redux/selectors/userSelectors';\n\nconst UserComponent = () =&gt; {\n    const dispatch = useDispatch();\n    const users = useSelector(getAllUsers);\n    const currentUser = useSelector(getCurrentUser);\n    const loading = useSelector(getUserLoading);\n    const error = useSelector(getUserError);\n\n    useEffect(() =&gt; {\n        dispatch(fetchUser(1)); // Fetch user with ID 1\n    }, [dispatch]);\n\n    const handleAddUser = (userData) =&gt; {\n        dispatch(addUser(userData));\n    };\n\n    const handleUpdateUser = (id, userData) =&gt; {\n        dispatch(modifyUser(id, userData));\n    };\n\n    const handleDeleteUser = (id) =&gt; {\n        dispatch(removeUser(id));\n    };\n\n    const handleSearchUsers = (queryParams) =&gt; {\n        dispatch(findUsers(queryParams));\n    };\n\n    return (\n        &lt;div&gt;\n            {loading ? (\n                &lt;p&gt;Loading...&lt;/p&gt;\n            ) : error ? (\n                &lt;p&gt;Error: {error}&lt;/p&gt;\n            ) : (\n                &lt;div&gt;\n                &lt;h1&gt;User Details&lt;/h1&gt;\n                {currentUser &amp;&amp; &lt;div&gt;{currentUser.name}&lt;/div&gt;}\n                &lt;h1&gt;All Users&lt;/h1&gt;\n                &lt;ul&gt;\n                    {users.map((u) =&gt; (\n                    &lt;li key={u.id}&gt;{u.name}&lt;/li&gt;\n                    ))}\n                &lt;/ul&gt;\n                &lt;/div&gt;\n            )}\n            &lt;button onClick={() =&gt; handleAddUser({ name: 'New User' })}&gt;Add User&lt;/button&gt;\n            &lt;button onClick={() =&gt; handleUpdateUser(1, { name: 'Updated User' })}&gt;Update User&lt;/button&gt;\n            &lt;button onClick={() =&gt; handleDeleteUser(1)}&gt;Delete User&lt;/button&gt;\n            &lt;button onClick={() =&gt; handleSearchUsers({ name: 'John' })}&gt;Search Users&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default UserComponent;\n</code></pre> <p>Store</p> redux/store/index.js <pre><code>import { createStore, applyMiddleware } from 'redux';\nimport { composeWithDevTools } from 'redux-devtools-extension';\nimport thunk from 'redux-thunk';\nimport rootReducer from '../reducers/rootReducer';\n\nconst store = createStore(rootReducer, composeWithDevTools(applyMiddleware(thunk)));\n\nexport default store;\n</code></pre> <p>This structure allows for scalability, as each part of the state is managed independently and can be easily extended with new entities or additional logic. The use of selectors ensures that the component logic remains clean and focused on rendering, while the normalization of data helps manage relationships and avoid nested state.</p>"},{"location":"frontend/state-management/redux/core/redux-pattern/","title":"Redux Pattern","text":""},{"location":"frontend/state-management/redux/core/redux-pattern/#redux-pattern","title":"Redux Pattern","text":"<p>The Redux pattern is an architecture for managing and centralizing application state in JavaScript applications, particularly those with complex, shared states across multiple components. It follows a unidirectional data flow and is based on the principles of predictability, immutability, and state management.</p> <p>Here's a breakdown of the key concepts:</p>"},{"location":"frontend/state-management/redux/core/redux-pattern/#key-concepts-of-redux-pattern","title":"Key Concepts of Redux Pattern:","text":"<ol> <li> <p>Store:</p> <ul> <li>The store is a single, centralized object that holds the entire state of the application. In Redux, there is usually just one store for the whole app, which contains the global state.</li> </ul> </li> <li> <p>State:</p> <ul> <li>The state is the current state of the application, kept in the store. The state is read-only, meaning it can only be updated through specific actions.</li> </ul> </li> <li> <p>Action:</p> <ul> <li> <p>An action is a plain JavaScript object that describes an event or something that happened in the application. Actions have a <code>type</code> (describing the event) and an optional payload containing additional data.</p> </li> <li> <p>Example: <code>{ type: 'ADD_TODO', payload: { text: 'Learn Redux' } }</code></p> </li> </ul> </li> <li> <p>Reducer:</p> <ul> <li> <p>A reducer is a pure function that takes the current state and an action as arguments, and returns a new state based on the action. Reducers must be pure functions, meaning they should not mutate the state but instead return a new state object.</p> </li> <li> <p>Example:</p> <pre><code>function todoReducer(state = [], action) {\n    switch (action.type) {\n        case 'ADD_TODO':\n            return [...state, { text: action.payload.text, completed: false }];\n        default:\n            return state;\n    }\n}\n</code></pre> </li> </ul> </li> <li> <p>Dispatch:</p> <ul> <li>The dispatch function is used to send actions to the store. When an action is dispatched, Redux passes the action to the reducers, which calculate the new state based on the action type.</li> <li>Example: <code>store.dispatch({ type: 'ADD_TODO', payload: { text: 'Learn Redux' } })</code></li> </ul> </li> <li> <p>Selectors:</p> <ul> <li>Selectors are functions used to access or derive specific pieces of state from the store. They help in keeping the state access logic in one place and promoting reusability.</li> </ul> </li> <li> <p>Middleware:</p> <ul> <li>Middleware functions provide a way to extend Redux with custom behavior, often for things like logging, handling asynchronous actions (e.g., redux-thunk or redux-saga), or intercepting actions before they reach the reducer.</li> </ul> </li> </ol>"},{"location":"frontend/state-management/redux/core/redux-pattern/#unidirectional-data-flow-in-redux","title":"Unidirectional Data Flow in Redux:","text":"<ul> <li>Component -&gt; Dispatch an Action -&gt; Reducer updates the Store -&gt; Component re-renders based on new state.</li> </ul>"},{"location":"frontend/state-management/redux/core/redux-pattern/#benefits-of-the-redux-pattern","title":"Benefits of the Redux Pattern:","text":"<ol> <li>Predictable State Updates: Since all state changes happen through actions and reducers, it's easy to track how and where state is updated.</li> <li>Centralized State: The entire application state is stored in a single place (the store), making it easier to debug and maintain.</li> <li>Time Travel Debugging: Since state updates are predictable and actions are serializable, you can \"time travel\" to different states in the application (with Redux DevTools).</li> <li>Separation of Concerns: The Redux pattern keeps the UI logic separate from the state management logic.</li> <li>Immutability: Redux encourages immutable updates to state, which helps prevent accidental mutations and bugs.</li> </ol>"},{"location":"frontend/state-management/redux/core/redux-pattern/#common-tools-with-redux","title":"Common Tools with Redux:","text":"<ol> <li>Redux Toolkit: A modern, opinionated approach to writing Redux logic with simplified syntax and best practices.</li> <li>Redux Thunk: Middleware for handling asynchronous actions.</li> <li>Redux Saga: A middleware for managing side effects with generator functions.</li> </ol>"},{"location":"frontend/state-management/redux/core/redux-pattern/#basic-folder-structure","title":"Basic Folder Structure:","text":"<ul> <li><code>actions/</code>: Contains the action creators and types.</li> <li><code>reducers/</code>: Contains the reducers for different parts of the state.</li> <li><code>store.js</code>: Configures the store and applies middleware.</li> <li><code>components/</code>: React components that dispatch actions and subscribe to state.</li> </ul>"},{"location":"frontend/state-management/redux/core/redux-pattern/#middleware","title":"Middleware","text":"<p>Let's dive deeper into handling asynchronous logic in Redux, especially focusing on middleware like Redux Thunk and Redux Saga.</p>"},{"location":"frontend/state-management/redux/core/redux-pattern/#1-handling-asynchronous-logic-in-redux","title":"1. Handling Asynchronous Logic in Redux:","text":"<p>By default, Redux only supports synchronous data flow\u2014state is updated immediately after an action is dispatched. However, most modern apps require dealing with asynchronous operations (like API requests). To handle this, Redux uses middleware that allows you to write logic between the action being dispatched and the reducer handling it.</p> <p>Key Middleware for Asynchronous Logic:</p> <ul> <li>Redux Thunk (Simple, widely used for small to medium apps)</li> <li>Redux Saga (More advanced, great for large, complex apps)</li> </ul>"},{"location":"frontend/state-management/redux/core/redux-pattern/#2-redux-thunk","title":"2. Redux Thunk:","text":"<p>Overview:</p> <p>Redux Thunk is the most popular middleware for handling asynchronous logic. It allows you to write action creators that return a function instead of an action object. This function can perform side effects (e.g., API calls) and dispatch actions based on the result.</p> <p>How Thunk Works:</p> <p>Without Redux Thunk, action creators return a plain JavaScript object. With Thunk, they can return a function that takes <code>dispatch</code> as an argument and allows for asynchronous calls.</p> <p>Basic Example:</p> InstallationExampleExplanation <pre><code>npm install redux-thunk\n</code></pre> <pre><code>// actionTypes.js\nexport const FETCH_DATA_REQUEST = 'FETCH_DATA_REQUEST';\nexport const FETCH_DATA_SUCCESS = 'FETCH_DATA_SUCCESS';\nexport const FETCH_DATA_FAILURE = 'FETCH_DATA_FAILURE';\n\n// actions.js\nexport const fetchData = () =&gt; {\n    return async (dispatch) =&gt; {\n        dispatch({ type: FETCH_DATA_REQUEST });\n        try {\n            const response = await fetch('https://api.example.com/data');\n            const data = await response.json();\n            dispatch({ type: FETCH_DATA_SUCCESS, payload: data });\n        } catch (error) {\n            dispatch({ type: FETCH_DATA_FAILURE, payload: error.message });\n        }\n    };\n};\n\n// reducer.js\nconst initialState = {\n    loading: false,\n    data: [],\n    error: null,\n};\n\nexport const dataReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case FETCH_DATA_REQUEST:\n            return { ...state, loading: true };\n        case FETCH_DATA_SUCCESS:\n            return { ...state, loading: false, data: action.payload };\n        case FETCH_DATA_FAILURE:\n            return { ...state, loading: false, error: action.payload };\n        default:\n            return state;\n    }\n};\n</code></pre> <p>Explanation:</p> <ul> <li>Dispatching Actions: The <code>fetchData</code> action first dispatches <code>FETCH_DATA_REQUEST</code>, performs the API call, and based on success or failure, dispatches either <code>FETCH_DATA_SUCCESS</code> or <code>FETCH_DATA_FAILURE</code>.</li> <li>Handling Asynchronous Logic: The middleware intercepts this function and ensures the async operation is executed.</li> </ul> <p>Pros of Redux Thunk:</p> <ul> <li>Simplicity: Easy to understand and use.</li> <li>Direct access to dispatch: You can control when to dispatch actions (before, during, or after async operations).</li> </ul> <p>Cons of Redux Thunk:</p> <ul> <li>Messy code: Thunks can get long and cluttered if there's too much logic in them.</li> <li>Testing challenges: Testing action creators can be more difficult as they contain both logic and side effects.</li> </ul>"},{"location":"frontend/state-management/redux/core/redux-pattern/#3-redux-saga","title":"3. Redux Saga:","text":"<p>Overview:</p> <p>Redux Saga is a middleware that handles more complex asynchronous logic using generator functions. It's great for dealing with complex async workflows (like canceling, debouncing, or retrying actions), managing multiple side effects, and handling intricate state changes.</p> <p>Redux Saga introduces a more declarative style where you \"describe\" side effects in your sagas and then \"yield\" them.</p> <p>How Redux Saga Works:</p> <ul> <li>It listens for dispatched actions and runs sagas in response.</li> <li>Sagas are generator functions that handle side effects like data fetching, background processing, or state updates.</li> </ul> InstallationExampleExplanation <pre><code>npm install redux-saga\n</code></pre> <pre><code>import { call, put, takeLatest } from 'redux-saga/effects';\nimport { FETCH_DATA_REQUEST, FETCH_DATA_SUCCESS, FETCH_DATA_FAILURE } from './actionTypes';\nimport { fetchDataFromApi } from './api';\n\n// Worker Saga: Will be fired on FETCH_DATA_REQUEST actions\nfunction* fetchDataSaga(action) {\n    try {\n        const data = yield call(fetchDataFromApi);\n        yield put({ type: FETCH_DATA_SUCCESS, payload: data });\n    } catch (error) {\n        yield put({ type: FETCH_DATA_FAILURE, payload: error.message });\n    }\n}\n\n// Watcher Saga: Spawn a new fetchDataSaga on each FETCH_DATA_REQUEST\nfunction* watchFetchDataSaga() {\n    yield takeLatest(FETCH_DATA_REQUEST, fetchDataSaga);\n}\n\nexport default watchFetchDataSaga;\n</code></pre> <p>Explanation:</p> <ul> <li>Saga Workflow: The <code>watchFetchDataSaga</code> listens for <code>FETCH_DATA_REQUEST</code> actions and runs the <code>fetchDataSaga</code>. The <code>fetchDataSaga</code> performs an API call using <code>call()</code> and dispatches actions using <code>put()</code>.</li> <li>Effects:<ul> <li><code>call()</code>: Calls the <code>fetchDataFromApi</code> function.</li> <li><code>put()</code>: Dispatches an action (<code>FETCH_DATA_SUCCESS</code> or <code>FETCH_DATA_FAILURE</code>).</li> <li><code>takeLatest()</code>: Ensures only the latest request is handled, canceling previous ones.</li> </ul> </li> </ul> <p>Pros of Redux Saga:</p> <ul> <li>Structured code: Complex async logic is easier to structure and manage.</li> <li>Powerful features: Offers fine-grained control over side effects like cancelation, debouncing, retrying, etc.</li> <li>Testable: Generator functions are easier to test in isolation.</li> </ul> <p>Cons of Redux Saga:</p> <ul> <li>Steeper learning curve: Using generators and understanding Redux Saga\u2019s API can be challenging.</li> <li>More boilerplate: Sagas can add more code overhead.</li> </ul>"},{"location":"frontend/state-management/redux/core/redux-pattern/#4-which-one-should-you-use","title":"4. Which One Should You Use?","text":"<p>Redux Thunk: -   Ideal for simple to moderately complex applications where you only need basic async functionality (like fetching data). -   It's easier to learn and can handle most common use cases.</p> <p>Redux Saga: -   Best for complex applications where you need to handle multiple side effects, complex async flows (like canceling, retrying, or parallel execution), or want more control over async logic. -   It\u2019s suited for larger projects with many async actions and requirements like debouncing or task cancelation.</p>"},{"location":"frontend/state-management/redux/core/redux-pattern/#5-combining-redux-with-other-middleware","title":"5. Combining Redux with Other Middleware:","text":"<p>You can use multiple middleware together (e.g., both Redux Thunk and logging middleware) to enhance Redux functionality.</p> <p>Example of combining middleware:</p> <pre><code>import { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport createSagaMiddleware from 'redux-saga';\nimport logger from 'redux-logger';\nimport rootReducer from './reducers';\nimport rootSaga from './sagas';\n\nconst sagaMiddleware = createSagaMiddleware();\nconst store = createStore(\n  rootReducer,\n  applyMiddleware(thunk, sagaMiddleware, logger)\n);\n\n// Run the saga middleware\nsagaMiddleware.run(rootSaga);\n</code></pre>"},{"location":"frontend/state-management/redux/core/redux-pattern/#conclusion","title":"Conclusion:","text":"<ul> <li>Redux Thunk is straightforward and good for smaller apps with simple async needs.</li> <li>Redux Saga is powerful and suited for larger, more complex applications requiring more control over side effects.</li> </ul> <p>If you're looking for simplicity, start with Thunk. If you're dealing with complex workflows and need advanced side effect management, Saga is the way to go. Would you like to explore any specific real-world scenarios using Thunk or Saga?</p>"},{"location":"frontend/state-management/redux/core/redux-pattern/#example","title":"Example","text":"<p>Let\u2019s explore some real-world scenarios where we can apply Redux Thunk and Redux Saga to manage asynchronous operations effectively.</p>"},{"location":"frontend/state-management/redux/core/redux-pattern/#scenario-1-api-fetching-with-redux-thunk","title":"Scenario 1: API Fetching with Redux Thunk","text":"<p>Scenario:</p> <p>Imagine an e-commerce app where you need to fetch a list of products from an API when a user visits the product page.</p> <p>Step-by-Step Solution Using Redux Thunk:</p> <ol> <li> <p>Set Up the Action Types: Define action types for requesting, succeeding, and failing the product fetch operation.</p> <pre><code>// actionTypes.js\nexport const FETCH_PRODUCTS_REQUEST = 'FETCH_PRODUCTS_REQUEST';\nexport const FETCH_PRODUCTS_SUCCESS = 'FETCH_PRODUCTS_SUCCESS';\nexport const FETCH_PRODUCTS_FAILURE = 'FETCH_PRODUCTS_FAILURE';\n</code></pre> </li> <li> <p>Create the Action Creator with Thunk: Use <code>redux-thunk</code> to create an action creator that fetches the products asynchronously.</p> <pre><code>// actions.js\nimport { FETCH_PRODUCTS_REQUEST, FETCH_PRODUCTS_SUCCESS, FETCH_PRODUCTS_FAILURE } from './actionTypes';\n\nexport const fetchProducts = () =&gt; {\n    return async (dispatch) =&gt; {\n        dispatch({ type: FETCH_PRODUCTS_REQUEST });\n        try {\n            const response = await fetch('https://api.example.com/products');\n            const products = await response.json();\n            dispatch({ type: FETCH_PRODUCTS_SUCCESS, payload: products });\n        } catch (error) {\n            dispatch({ type: FETCH_PRODUCTS_FAILURE, payload: error.message });\n        }\n    };\n};\n</code></pre> </li> <li> <p>Create the Reducer: The reducer will handle the state changes for product fetching. It reacts to the actions dispatched by the thunk.</p> <pre><code>// productReducer.js\nconst initialState = {\n    loading: false,\n    products: [],\n    error: null,\n};\n\nexport const productReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case FETCH_PRODUCTS_REQUEST:\n            return { ...state, loading: true, error: null };\n        case FETCH_PRODUCTS_SUCCESS:\n            return { ...state, loading: false, products: action.payload };\n        case FETCH_PRODUCTS_FAILURE:\n            return { ...state, loading: false, error: action.payload };\n        default:\n            return state;\n    }\n};\n</code></pre> </li> <li> <p>Dispatch the Action in a React Component: Use <code>useEffect</code> to dispatch the <code>fetchProducts</code> action when the product page component mounts.</p> <pre><code>import React, { useEffect } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { fetchProducts } from './actions';\n\nconst ProductPage = () =&gt; {\n    const dispatch = useDispatch();\n    const { products, loading, error } = useSelector(state =&gt; state.productReducer);\n\n    useEffect(() =&gt; {\n        dispatch(fetchProducts());\n    }, [dispatch]);\n\n    if (loading) return &lt;p&gt;Loading...&lt;/p&gt;;\n    if (error) return &lt;p&gt;Error: {error}&lt;/p&gt;;\n\n    return (\n        &lt;div&gt;\n            {products.map(product =&gt; (\n                &lt;div key={product.id}&gt;\n                    &lt;h2&gt;{product.name}&lt;/h2&gt;\n                    &lt;p&gt;{product.description}&lt;/p&gt;\n                &lt;/div&gt;\n            ))}\n        &lt;/div&gt;\n    );\n};\n\nexport default ProductPage;\n</code></pre> </li> </ol> <p>Result:</p> <p>When the <code>ProductPage</code> component is mounted, the <code>fetchProducts</code> thunk is dispatched. It sends a request to the API, and depending on the outcome, either the product list or an error message is rendered.</p>"},{"location":"frontend/state-management/redux/core/redux-pattern/#scenario-2-handling-multiple-concurrent-api-calls-with-redux-saga","title":"Scenario 2: Handling Multiple Concurrent API Calls with Redux Saga","text":"<p>Scenario:</p> <p>Let\u2019s say you\u2019re developing a social media app. When a user logs in, you need to fetch their profile, notifications, and posts concurrently. If any of these requests fail, you want to retry the failed request up to 3 times.</p> <p>Step-by-Step Solution Using Redux Saga:</p> <ol> <li> <p>Set Up Action Types: Define action types for fetching the profile, notifications, and posts.</p> <pre><code>// actionTypes.js\nexport const FETCH_PROFILE_REQUEST = 'FETCH_PROFILE_REQUEST';\nexport const FETCH_PROFILE_SUCCESS = 'FETCH_PROFILE_SUCCESS';\nexport const FETCH_PROFILE_FAILURE = 'FETCH_PROFILE_FAILURE';\nexport const FETCH_NOTIFICATIONS_REQUEST = 'FETCH_NOTIFICATIONS_REQUEST';\nexport const FETCH_NOTIFICATIONS_SUCCESS = 'FETCH_NOTIFICATIONS_SUCCESS';\nexport const FETCH_NOTIFICATIONS_FAILURE = 'FETCH_NOTIFICATIONS_FAILURE';\nexport const FETCH_POSTS_REQUEST = 'FETCH_POSTS_REQUEST';\nexport const FETCH_POSTS_SUCCESS = 'FETCH_POSTS_SUCCESS';\nexport const FETCH_POSTS_FAILURE = 'FETCH_POSTS_FAILURE';\n</code></pre> </li> <li> <p>Create the API Call Functions: These functions will perform the actual API calls to fetch the data.</p> <pre><code>// api.js\nexport const fetchProfileApi = () =&gt; fetch('https://api.example.com/profile').then(res =&gt; res.json());\nexport const fetchNotificationsApi = () =&gt; fetch('https://api.example.com/notifications').then(res =&gt; res.json());\nexport const fetchPostsApi = () =&gt; fetch('https://api.example.com/posts').then(res =&gt; res.json());\n</code></pre> </li> <li> <p>Create the Saga with Retry Logic: The <code>yield</code> keyword allows us to handle async actions declaratively. We can use <code>all</code> to run multiple API requests concurrently and <code>retry</code> to handle failed requests.</p> <pre><code>import { call, put, all, retry } from 'redux-saga/effects';\nimport { FETCH_PROFILE_REQUEST, FETCH_PROFILE_SUCCESS, FETCH_PROFILE_FAILURE, FETCH_NOTIFICATIONS_REQUEST, FETCH_NOTIFICATIONS_SUCCESS, FETCH_NOTIFICATIONS_FAILURE, FETCH_POSTS_REQUEST, FETCH_POSTS_SUCCESS, FETCH_POSTS_FAILURE } from './actionTypes';\nimport { fetchProfileApi, fetchNotificationsApi, fetchPostsApi } from './api';\n\nfunction* fetchUserProfile() {\n    try {\n        const profile = yield retry(3, 1000, fetchProfileApi);  // Retry up to 3 times with 1-second intervals\n        yield put({ type: FETCH_PROFILE_SUCCESS, payload: profile });\n    } catch (error) {\n        yield put({ type: FETCH_PROFILE_FAILURE, payload: error.message });\n    }\n}\n\nfunction* fetchUserNotifications() {\n    try {\n        const notifications = yield retry(3, 1000, fetchNotificationsApi);\n        yield put({ type: FETCH_NOTIFICATIONS_SUCCESS, payload: notifications });\n    } catch (error) {\n        yield put({ type: FETCH_NOTIFICATIONS_FAILURE, payload: error.message });\n    }\n}\n\nfunction* fetchUserPosts() {\n    try {\n        const posts = yield retry(3, 1000, fetchPostsApi);\n        yield put({ type: FETCH_POSTS_SUCCESS, payload: posts });\n    } catch (error) {\n        yield put({ type: FETCH_POSTS_FAILURE, payload: error.message });\n    }\n}\n\nfunction* fetchUserData() {\n    yield all([\n        call(fetchUserProfile),\n        call(fetchUserNotifications),\n        call(fetchUserPosts),\n    ]);\n}\n\nexport default function* watchFetchUserData() {\n    yield takeLatest(FETCH_PROFILE_REQUEST, fetchUserData);\n}\n</code></pre> </li> <li> <p>Dispatch the Action: When the user logs in, dispatch the action to start fetching all required data.</p> <pre><code>// In a component or action creator\ndispatch({ type: FETCH_PROFILE_REQUEST });\n</code></pre> </li> </ol> <p>Result:</p> <p>The <code>fetchUserData</code> saga runs <code>fetchUserProfile</code>, <code>fetchUserNotifications</code>, and <code>fetchUserPosts</code> concurrently using <code>all()</code>. If any of these requests fail, they will be retried up to 3 times using <code>retry()</code>. Once all the requests have succeeded or failed, the appropriate success or failure actions are dispatched.</p>"},{"location":"frontend/state-management/redux/core/redux-pattern/#conclusion_1","title":"Conclusion:","text":"<ul> <li>Thunk Example: Perfect for handling simple API requests, ideal when the logic isn't too complex.</li> <li>Saga Example: Shows the power of Redux Saga in managing multiple asynchronous operations and more advanced control like retrying failed requests or handling concurrent actions.</li> </ul>"},{"location":"frontend/state-management/redux/core/redux-testing/","title":"Redux Testing","text":"<p>Great! Let\u2019s dive deeper into testing Redux Thunk and Redux Saga to ensure that your asynchronous operations behave as expected in real-world applications.</p>"},{"location":"frontend/state-management/redux/core/redux-testing/#testing-redux-thunk","title":"Testing Redux Thunk","text":"<p>When testing actions that use Redux Thunk, we can use a mock store to dispatch actions and check that the correct actions are being dispatched based on the asynchronous logic.</p> <ol> <li> <p>Testing Redux Thunk with Jest</p> <p>Scenario: You want to test the <code>fetchProducts</code> thunk action creator, which dispatches <code>FETCH_PRODUCTS_REQUEST</code>, <code>FETCH_PRODUCTS_SUCCESS</code>, or <code>FETCH_PRODUCTS_FAILURE</code> depending on the result of an API call.</p> <p>Test Setup:</p> <ul> <li>Mocking the API: We'll mock the API call to return some fake data.</li> <li>Mock Store: Use <code>redux-mock-store</code> to simulate Redux store behavior.</li> </ul> </li> </ol> <p>Code:</p> <ol> <li> <p>Install dependencies for testing:</p> <pre><code>npm install redux-mock-store redux-thunk jest --save-dev\n</code></pre> </li> <li> <p>Write the Test for Redux Thunk:</p> ExampleHow the Test Works <pre><code>import configureMockStore from 'redux-mock-store';\nimport thunk from 'redux-thunk';\nimport fetchMock from 'jest-fetch-mock'; // To mock fetch API\nimport { fetchProducts } from './actions'; // Thunk action\nimport { FETCH_PRODUCTS_REQUEST, FETCH_PRODUCTS_SUCCESS, FETCH_PRODUCTS_FAILURE } from './actionTypes';\n\nconst middlewares = [thunk];\nconst mockStore = configureMockStore(middlewares);\n\ndescribe('fetchProducts action', () =&gt; {\n    beforeEach(() =&gt; {\n        fetchMock.resetMocks();\n    });\n\n    it('dispatches FETCH_PRODUCTS_SUCCESS after a successful API request', () =&gt; {\n        const mockProducts = [{ id: 1, name: 'Product 1' }, { id: 2, name: 'Product 2' }];\n        fetchMock.mockResponseOnce(JSON.stringify(mockProducts));\n\n        const expectedActions = [\n            { type: FETCH_PRODUCTS_REQUEST },\n            { type: FETCH_PRODUCTS_SUCCESS, payload: mockProducts },\n        ];\n\n        const store = mockStore({ products: [] });\n\n        return store.dispatch(fetchProducts()).then(() =&gt; {\n            expect(store.getActions()).toEqual(expectedActions);\n        });\n    });\n\n    it('dispatches FETCH_PRODUCTS_FAILURE when the API request fails', () =&gt; {\n        const errorMessage = 'Failed to fetch';\n        fetchMock.mockRejectOnce(new Error(errorMessage));\n\n        const expectedActions = [\n            { type: FETCH_PRODUCTS_REQUEST },\n            { type: FETCH_PRODUCTS_FAILURE, payload: errorMessage },\n        ];\n\n        const store = mockStore({ products: [] });\n\n        return store.dispatch(fetchProducts()).then(() =&gt; {\n            expect(store.getActions()).toEqual(expectedActions);\n        });\n    });\n});\n</code></pre> <ul> <li>Mock Store: <code>redux-mock-store</code> creates a mock version of the Redux store.</li> <li>Action Sequence: The test ensures that the correct sequence of actions (<code>FETCH_PRODUCTS_REQUEST</code>, <code>FETCH_PRODUCTS_SUCCESS</code>, or    <code>FETCH_PRODUCTS_FAILURE</code>) is dispatched based on the result of the API call.</li> <li>Mock API Response: We use <code>fetchMock</code> to simulate different API responses (success and failure).</li> </ul> </li> </ol>"},{"location":"frontend/state-management/redux/core/redux-testing/#testing-redux-saga","title":"Testing Redux Saga","text":"<p>Testing Redux Saga involves verifying the flow of effects (<code>call</code>, <code>put</code>, <code>take</code>, etc.). We can use a library like <code>redux-saga-test-plan</code> to test sagas in isolation.</p> <ol> <li> <p>Testing Redux Saga with Jest and redux-saga-test-plan</p> <p>Scenario: You want to test the <code>fetchUserData</code> saga, which fetches the user profile, notifications, and posts concurrently. You also want to ensure it retries the API calls up to 3 times if they fail.</p> </li> </ol> <p>Code:</p> <ol> <li> <p>Install the necessary testing libraries:</p> <pre><code>npm install redux-saga-test-plan jest --save-dev\n</code></pre> </li> <li> <p>Write the Test for Redux Saga:</p> ExampleHow the Test Works <pre><code>import { testSaga } from 'redux-saga-test-plan';\nimport { fetchUserData } from './sagas';\nimport { fetchProfileApi, fetchNotificationsApi, fetchPostsApi } from './api';\nimport { FETCH_PROFILE_SUCCESS, FETCH_NOTIFICATIONS_SUCCESS, FETCH_POSTS_SUCCESS } from './actionTypes';\n\ndescribe('fetchUserData saga', () =&gt; {\n    it('fetches profile, notifications, and posts concurrently', () =&gt; {\n        const mockProfile = { name: 'John Doe' };\n        const mockNotifications = [{ id: 1, message: 'New notification' }];\n        const mockPosts = [{ id: 1, content: 'New post' }];\n\n        testSaga(fetchUserData)\n            .next()\n            .all([\n                call(fetchProfileApi),\n                call(fetchNotificationsApi),\n                call(fetchPostsApi),\n            ])\n            .next([mockProfile, mockNotifications, mockPosts])\n            .put({ type: FETCH_PROFILE_SUCCESS, payload: mockProfile })\n            .next()\n            .put({ type: FETCH_NOTIFICATIONS_SUCCESS, payload: mockNotifications })\n            .next()\n            .put({ type: FETCH_POSTS_SUCCESS, payload: mockPosts })\n            .next()\n            .isDone();\n    });\n\n    it('retries API calls up to 3 times if they fail', () =&gt; {\n        const error = new Error('API error');\n\n        testSaga(fetchUserData)\n            .next()\n            .all([\n                retry(3, 1000, fetchProfileApi),\n                retry(3, 1000, fetchNotificationsApi),\n                retry(3, 1000, fetchPostsApi),\n            ])\n            .throw(error)\n            .put({ type: FETCH_PROFILE_FAILURE, payload: error.message })\n            .next()\n            .isDone();\n    });\n});\n</code></pre> <ul> <li>Test Flow: <code>redux-saga-test-plan</code> allows you to simulate the exact flow of your saga and assert each step (<code>call</code>, <code>put</code>, etc.).</li> <li>Concurrent API Calls: We use <code>all()</code> to test that profile, notifications, and posts are fetched concurrently.</li> <li>Retry Mechanism: The second test ensures that the API call retries up to 3 times using the <code>retry()</code> effect.</li> </ul> </li> </ol>"},{"location":"frontend/state-management/redux/core/redux-testing/#testing-best-practices-for-redux-thunk-and-redux-saga","title":"Testing Best Practices for Redux Thunk and Redux Saga","text":"<ol> <li> <p>Mock External Dependencies:</p> <ul> <li>For Thunk, mock API calls using <code>jest-fetch-mock</code> or similar libraries.</li> <li>For Saga, use <code>redux-saga-test-plan</code> to simulate effects and test the sequence of actions.</li> </ul> </li> <li> <p>Test Action Sequences:</p> <ul> <li>Ensure the correct actions are dispatched in the expected order.</li> <li>For complex flows, check that the appropriate success or failure actions are dispatched based on the outcome.</li> </ul> </li> <li> <p>Isolate Logic:</p> <ul> <li>Test action creators, reducers, and sagas separately to ensure that each piece of logic works independently before testing them together.</li> </ul> </li> </ol>"},{"location":"frontend/state-management/redux/core/redux-testing/#summary","title":"Summary:","text":"<ul> <li>Thunk Testing: Use <code>redux-mock-store</code> to mock the Redux store and simulate dispatching asynchronous actions.</li> <li>Saga Testing: Use <code>redux-saga-test-plan</code> to test the flow of saga effects like <code>call</code>, <code>put</code>, and <code>all()</code>, and simulate advanced logic such as retries.</li> </ul>"},{"location":"frontend/state-management/redux/core/redux-testing/#testing-reducers","title":"Testing Reducers","text":"<p>Reducers are pure functions in Redux, meaning they should always produce the same output given the same input. This makes them easy to test. The goal of testing reducers is to ensure that they correctly update the state based on the dispatched actions.</p>"},{"location":"frontend/state-management/redux/core/redux-testing/#1-basic-structure-of-a-reducer","title":"1.  Basic Structure of a Reducer","text":"<pre><code>Let\u2019s say you have a reducer that handles fetching products:\n\n```jsx\nconst initialState = {\n    products: [],\n    loading: false,\n    error: null,\n};\n\nfunction productReducer(state = initialState, action) {\n    switch (action.type) {\n        case 'FETCH_PRODUCTS_REQUEST':\n            return { ...state, loading: true };\n        case 'FETCH_PRODUCTS_SUCCESS':\n            return { ...state, loading: false, products: action.payload };\n        case 'FETCH_PRODUCTS_FAILURE':\n            return { ...state, loading: false, error: action.payload };\n        default:\n            return state;\n    }\n}\n```\n</code></pre>"},{"location":"frontend/state-management/redux/core/redux-testing/#writing-unit-tests-for-reducers","title":"Writing Unit Tests for Reducers","text":"<p>Testing reducers is straightforward because they are pure functions. You only need to call the reducer with an action and an initial state, and then check if the output matches the expected state.</p>"},{"location":"frontend/state-management/redux/core/redux-testing/#2-writing-tests-for-the-product-reducer","title":"2.  Writing Tests for the Product Reducer","text":"<p>Here\u2019s an example of how you would test this reducer using Jest:</p> <pre><code>import productReducer from './productReducer';\n\ndescribe('Product Reducer', () =&gt; {\n  const initialState = {\n    products: [],\n    loading: false,\n    error: null,\n  };\n\n  it('should return the initial state', () =&gt; {\n    expect(productReducer(undefined, {})).toEqual(initialState);\n  });\n\n  it('should handle FETCH_PRODUCTS_REQUEST', () =&gt; {\n    const action = { type: 'FETCH_PRODUCTS_REQUEST' };\n    const expectedState = { ...initialState, loading: true };\n    expect(productReducer(initialState, action)).toEqual(expectedState);\n  });\n\n  it('should handle FETCH_PRODUCTS_SUCCESS', () =&gt; {\n    const action = {\n      type: 'FETCH_PRODUCTS_SUCCESS',\n      payload: [{ id: 1, name: 'Product 1' }],\n    };\n    const expectedState = {\n      ...initialState,\n      loading: false,\n      products: action.payload,\n    };\n    expect(productReducer(initialState, action)).toEqual(expectedState);\n  });\n\n  it('should handle FETCH_PRODUCTS_FAILURE', () =&gt; {\n    const action = { type: 'FETCH_PRODUCTS_FAILURE', payload: 'Error' };\n    const expectedState = {\n      ...initialState,\n      loading: false,\n      error: 'Error',\n    };\n    expect(productReducer(initialState, action)).toEqual(expectedState);\n  });\n});\n</code></pre>"},{"location":"frontend/state-management/redux/core/redux-testing/#best-practices-for-testing-reducers","title":"Best Practices for Testing Reducers","text":"<ol> <li> <p>Test for Default State:</p> <ul> <li> <p>Always test that the reducer returns the initial state when the state is <code>undefined</code> and the action is irrelevant (e.g., <code>{}</code>).</p> <pre><code>it('should return the initial state', () =&gt; {\n    expect(productReducer(undefined, {})).toEqual(initialState);\n});\n</code></pre> </li> </ul> </li> <li> <p>Test Each Action Type:</p> <ul> <li>Write a test case for each action type the reducer handles (<code>FETCH_PRODUCTS_REQUEST</code>, <code>FETCH_PRODUCTS_SUCCESS</code>, etc.). Ensure the state is updated as expected.</li> </ul> </li> <li> <p>Use Mocks for Action Payloads:</p> <ul> <li> <p>If an action payload is complex (e.g., an array of products), use mock data to ensure the test is focused on the reducer logic.</p> <pre><code>const action = {\n    type: 'FETCH_PRODUCTS_SUCCESS',\n    payload: [{ id: 1, name: 'Mock Product' }],\n};\n</code></pre> </li> </ul> </li> <li> <p>Test Edge Cases:</p> <ul> <li>Consider testing edge cases like actions that are dispatched with unexpected payloads or malformed data.</li> </ul> </li> <li> <p>Avoid Testing Built-in Functions:</p> <ul> <li>Don\u2019t test things like <code>Object.assign</code> or spread operators (<code>...</code>), as these are built-in JavaScript features. Focus on testing that your reducer logic is correct.</li> </ul> </li> </ol>"},{"location":"frontend/state-management/redux/core/redux-testing/#testing-redux-with-thunk-saga-and-reducers-summary","title":"Testing Redux with Thunk, Saga, and Reducers: Summary","text":"<p>Now that you\u2019ve seen how to test thunks, sagas, and reducers, here\u2019s a summary of the flow:</p> <ol> <li> <p>Thunks:</p> <ul> <li>Use <code>redux-mock-store</code> to mock the Redux store.</li> <li>Mock external dependencies like APIs and verify that the correct actions are dispatched based on asynchronous logic.</li> </ul> </li> <li> <p>Sagas:</p> <ul> <li>Use <code>redux-saga-test-plan</code> to simulate effects and check the flow of your saga (e.g., concurrent API calls, retry logic).</li> <li>Focus on verifying the flow of effects (<code>call</code>, <code>put</code>, etc.).</li> </ul> </li> <li> <p>Reducers:</p> <ul> <li>Test reducers by dispatching different actions and ensuring the state is updated correctly.</li> <li>Write one test per action type, ensuring each action\u2019s impact on the state is validated.</li> </ul> </li> </ol> <p>Awesome! Let\u2019s move into testing React components that connect to Redux and handle more advanced testing scenarios, such as dealing with components that rely on Redux state and actions.</p>"},{"location":"frontend/state-management/redux/core/redux-testing/#testing-react-components-connected-to-redux","title":"Testing React Components Connected to Redux","text":"<p>When testing React components that are connected to Redux, we need to ensure:</p> <ol> <li>The component renders correctly with the expected state from Redux.</li> <li>The component dispatches the correct actions when interacting with UI elements (e.g., clicking buttons).</li> </ol> <p>We'll use <code>react-testing-library</code> (or <code>@testing-library/react</code>) and <code>redux-mock-store</code> to test connected components without relying on a real Redux store.</p>"},{"location":"frontend/state-management/redux/core/redux-testing/#1-basic-structure-of-a-connected-component","title":"1. Basic Structure of a Connected Component","text":"<p>Let\u2019s assume we have a React component, <code>ProductList</code>, which is connected to Redux. It fetches products from the store and displays them, and it also has a button to reload the products.</p> <pre><code>import React, { useEffect } from 'react';\nimport { connect } from 'react-redux';\nimport { fetchProducts } from './actions';\n\nconst ProductList = ({ products, loading, fetchProducts }) =&gt; {\n  useEffect(() =&gt; {\n    fetchProducts(); // Fetch products when component mounts\n  }, [fetchProducts]);\n\n  if (loading) {\n    return &lt;div&gt;Loading...&lt;/div&gt;;\n  }\n\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Product List&lt;/h2&gt;\n      &lt;ul&gt;\n        {products.map((product) =&gt; (\n          &lt;li key={product.id}&gt;{product.name}&lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n      &lt;button onClick={fetchProducts}&gt;Reload Products&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nconst mapStateToProps = (state) =&gt; ({\n  products: state.products.items,\n  loading: state.products.loading,\n});\n\nexport default connect(mapStateToProps, { fetchProducts })(ProductList);\n</code></pre>"},{"location":"frontend/state-management/redux/core/redux-testing/#2-writing-tests-for-the-connected-component","title":"2. Writing Tests for the Connected Component","text":"<p>We\u2019ll test two scenarios:</p> <ol> <li>Rendering the component with initial state.</li> <li>Simulating a button click to dispatch the <code>fetchProducts</code> action.</li> </ol> <p>Setting Up Tests for Connected Components</p> <ol> <li> <p>Install necessary libraries:</p> <pre><code>npm install @testing-library/react redux-mock-store jest --save-dev\n</code></pre> </li> <li> <p>Writing Tests with Mock Redux Store:</p> <p>We can use a mock Redux store to simulate different states in our tests. Here\u2019s how to set it up.</p> ExampleExplanation <pre><code>import React from 'react';\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport configureMockStore from 'redux-mock-store';\nimport { Provider } from 'react-redux';\nimport ProductList from './ProductList'; // The connected component\nimport thunk from 'redux-thunk';\n\n// Mock store\nconst middlewares = [thunk];\nconst mockStore = configureMockStore(middlewares);\n\ndescribe('ProductList Component', () =&gt; {\n    let store;\n\n    beforeEach(() =&gt; {\n        // Initial mock state\n        store = mockStore({\n            products: {\n                items: [{ id: 1, name: 'Product 1' }, { id: 2, name: 'Product 2' }],\n                loading: false,\n            },\n        });\n    });\n\n    it('should render product list with products from Redux state', () =&gt; {\n        render(\n            &lt;Provider store={store}&gt;\n                &lt;ProductList /&gt;\n            &lt;/Provider&gt;\n        );\n\n        expect(screen.getByText('Product List')).toBeInTheDocument();\n        expect(screen.getByText('Product 1')).toBeInTheDocument();\n        expect(screen.getByText('Product 2')).toBeInTheDocument();\n    });\n\n    it('should dispatch fetchProducts action when \"Reload Products\" button is clicked', () =&gt; {\n        render(\n            &lt;Provider store={store}&gt;\n                &lt;ProductList /&gt;\n            &lt;/Provider&gt;\n        );\n\n        const reloadButton = screen.getByText('Reload Products');\n        fireEvent.click(reloadButton);\n\n        const actions = store.getActions();\n        expect(actions).toEqual([{ type: 'FETCH_PRODUCTS_REQUEST' }]); // Adjust depending on the action dispatched\n    });\n\n    it('should show loading message when fetching products', () =&gt; {\n        store = mockStore({\n            products: { items: [], loading: true },\n        });\n\n        render(\n            &lt;Provider store={store}&gt;\n                &lt;ProductList /&gt;\n            &lt;/Provider&gt;\n        );\n\n        expect(screen.getByText('Loading...')).toBeInTheDocument();\n    });\n});\n</code></pre> <ol> <li>Mock Store: We create a mock Redux store with an initial state that mimics the real state in your app.</li> <li>Provider: Wrap the component in the Redux <code>Provider</code> and pass the mock store.</li> <li> <p>Assertions:</p> <ul> <li>Check if the component correctly renders data from the mock Redux state.</li> <li>Simulate a button click and verify if the correct action is dispatched.</li> </ul> </li> </ol> </li> </ol>"},{"location":"frontend/state-management/redux/core/redux-testing/#best-practices-for-testing-connected-components","title":"Best Practices for Testing Connected Components:","text":"<ul> <li>Mock the Store: Use a mock store to simulate various Redux states (loading, error, etc.) to thoroughly test how your component handles different scenarios.</li> <li>Test Action Dispatching: Simulate user interactions (like clicking a button) and verify if the correct Redux actions are dispatched.</li> <li>Isolate UI Logic: Focus on testing the UI\u2019s interaction with Redux, not the internal logic of actions or reducers. These can be tested separately.</li> </ul>"},{"location":"frontend/state-management/redux/core/redux-testing/#advanced-testing-scenarios-for-redux-connected-components","title":"Advanced Testing Scenarios for Redux-Connected Components","text":"<ol> <li> <p>Testing with Nested States:</p> <ul> <li> <p>If your Redux state has nested objects (e.g., <code>state.products.items</code>), ensure that you correctly mock and test the nested structure.</p> <pre><code>// Example for a deeply nested state:\n\nstore = mockStore({\n    products: {\n        data: {\n            items: [{ id: 1, name: 'Product 1' }],\n        },\n        loading: false,\n    },\n});\n</code></pre> </li> </ul> </li> <li> <p>Testing with Selectors:</p> <ul> <li> <p>If you\u2019re using selectors to derive data from the Redux store, you should mock the selector\u2019s output and test how the component renders based on it.</p> <pre><code>import { getVisibleProducts } from './selectors';\njest.mock('./selectors');\n\nit('should render visible products', () =&gt; {\n    getVisibleProducts.mockReturnValue([{ id: 1, name: 'Visible Product' }]);\n\n    render(\n        &lt;Provider store={store}&gt;\n        &lt;ProductList /&gt;\n        &lt;/Provider&gt;\n    );\n\n    expect(screen.getByText('Visible Product')).toBeInTheDocument();\n});\n</code></pre> </li> </ul> </li> <li> <p>Testing Middleware:</p> <ul> <li> <p>If you\u2019re using custom middleware or middleware like redux-thunk, ensure you test the interaction with middleware by checking the actions that are dispatched as a result of user interactions.</p> <pre><code>const middlewares = [thunk]; // Include middleware in mock store setup\n</code></pre> </li> </ul> </li> <li> <p>Testing Complex Interactions:</p> <ul> <li>For more complex interactions, simulate multiple steps (e.g., multiple button clicks or form submissions) and verify that the state and actions evolve correctly.</li> </ul> <p>Example: Testing a multi-step form that dispatches multiple actions:</p> <pre><code>fireEvent.click(screen.getByText('Next Step'));\nexpect(store.getActions()).toEqual([\n    { type: 'STEP_1_COMPLETE' },\n    { type: 'LOAD_NEXT_STEP' },\n]);\n</code></pre> </li> </ol> <p>Great! Let\u2019s dive into middleware testing and mocking API calls within Redux-connected components to handle asynchronous behavior.</p>"},{"location":"frontend/state-management/redux/core/redux-testing/#testing-middleware-in-redux","title":"Testing Middleware in Redux","text":"<p>Middleware in Redux is used to extend the functionality of the Redux store, allowing you to intercept actions before they reach the reducers. Common middleware like redux-thunk and redux-saga enable handling side effects such as API calls.</p>"},{"location":"frontend/state-management/redux/core/redux-testing/#1-testing-thunk-middleware","title":"1. Testing Thunk Middleware","text":"<p>If you're using redux-thunk for async operations (like API calls), you\u2019ll often want to ensure that:</p> <ul> <li>Correct actions are dispatched before and after the async logic (e.g., <code>LOADING</code>, <code>SUCCESS</code>, <code>ERROR</code>).</li> <li>The API calls (or any async logic) are correctly mocked.</li> </ul> <p>Example: Async Action with Thunk</p> <p>Let\u2019s assume you have a simple thunk that fetches products from an API:</p> <pre><code>// actions.js\nexport const fetchProducts = () =&gt; {\n  return async (dispatch) =&gt; {\n    dispatch({ type: 'FETCH_PRODUCTS_REQUEST' });\n    try {\n      const response = await fetch('/api/products');\n      const data = await response.json();\n      dispatch({ type: 'FETCH_PRODUCTS_SUCCESS', payload: data });\n    } catch (error) {\n      dispatch({ type: 'FETCH_PRODUCTS_FAILURE', payload: error.message });\n    }\n  };\n};\n</code></pre> <p>Writing Tests for Thunks</p> <p>To test this, we mock the API call and check that the right actions are dispatched.</p> <pre><code>import configureMockStore from 'redux-mock-store';\nimport thunk from 'redux-thunk';\nimport fetchMock from 'jest-fetch-mock'; // or axios-mock-adapter if you use axios\nimport { fetchProducts } from './actions';\n\n// Setup mock store\nconst middlewares = [thunk];\nconst mockStore = configureMockStore(middlewares);\n\ndescribe('fetchProducts thunk', () =&gt; {\n  beforeEach(() =&gt; {\n    fetchMock.resetMocks(); // Reset mock fetch calls\n  });\n\n  it('should dispatch FETCH_PRODUCTS_SUCCESS after successful API call', async () =&gt; {\n    // Mock the API response\n    fetchMock.mockResponseOnce(\n      JSON.stringify([{ id: 1, name: 'Product 1' }])\n    );\n\n    const expectedActions = [\n      { type: 'FETCH_PRODUCTS_REQUEST' },\n      {\n        type: 'FETCH_PRODUCTS_SUCCESS',\n        payload: [{ id: 1, name: 'Product 1' }],\n      },\n    ];\n\n    const store = mockStore({ products: [] });\n\n    await store.dispatch(fetchProducts());\n\n    expect(store.getActions()).toEqual(expectedActions);\n  });\n\n  it('should dispatch FETCH_PRODUCTS_FAILURE after a failed API call', async () =&gt; {\n    // Mock a failed API response\n    fetchMock.mockReject(new Error('Failed to fetch'));\n\n    const expectedActions = [\n      { type: 'FETCH_PRODUCTS_REQUEST' },\n      { type: 'FETCH_PRODUCTS_FAILURE', payload: 'Failed to fetch' },\n    ];\n\n    const store = mockStore({ products: [] });\n\n    await store.dispatch(fetchProducts());\n\n    expect(store.getActions()).toEqual(expectedActions);\n  });\n});\n</code></pre> <p>??+ note \"Key Points\"</p> <pre><code>1.  **Mocking API calls**:\n\n    -   Use `fetch-mock` or `axios-mock-adapter` to simulate successful and failed API responses.\n\n2.  **Asserting Dispatched Actions**:\n\n    -   Verify that the correct actions (e.g., `REQUEST`, `SUCCESS`, `FAILURE`) are dispatched in the right order based on the API call.\n</code></pre>"},{"location":"frontend/state-management/redux/core/redux-testing/#2-testing-redux-saga-middleware","title":"2. Testing Redux Saga Middleware","text":"<p>If you\u2019re using redux-saga for side effects, testing involves simulating the side effects and asserting the correct sequence of events (e.g., dispatching actions, making API calls).</p> <p>Saga Example</p> <p>Let\u2019s say you have a saga that fetches products:</p> <pre><code>// sagas.js\nimport { call, put, takeEvery } from 'redux-saga/effects';\n\nfunction* fetchProductsSaga() {\n  try {\n    yield put({ type: 'FETCH_PRODUCTS_REQUEST' });\n    const response = yield call(fetch, '/api/products');\n    const data = yield call([response, 'json']);\n    yield put({ type: 'FETCH_PRODUCTS_SUCCESS', payload: data });\n  } catch (error) {\n    yield put({ type: 'FETCH_PRODUCTS_FAILURE', payload: error.message });\n  }\n}\n\nexport function* watchFetchProducts() {\n  yield takeEvery('FETCH_PRODUCTS', fetchProductsSaga);\n}\n</code></pre> <p>Testing Sagas with <code>redux-saga-test-plan</code></p> <p>The <code>redux-saga-test-plan</code> library simplifies testing sagas by allowing you to simulate effects and assert their behavior.</p> <ol> <li> <p>Install the library:</p> <pre><code>npm install redux-saga-test-plan --save-dev\n</code></pre> </li> <li> <p>Writing Tests for the Saga:</p> <p>Here\u2019s how you can test the <code>fetchProductsSaga</code>:</p> ExampleKey Points for Saga Testing <pre><code>import { runSaga } from 'redux-saga';\nimport { fetchProductsSaga } from './sagas';\nimport fetchMock from 'jest-fetch-mock';\n\ndescribe('fetchProductsSaga', () =&gt; {\n    beforeEach(() =&gt; {\n        fetchMock.resetMocks(); // Reset mock fetch calls\n    });\n\n    it('should dispatch success action after fetching products', async () =&gt; {\n        // Mock API response\n        fetchMock.mockResponseOnce(JSON.stringify([{ id: 1, name: 'Product 1' }]));\n\n        const dispatchedActions = [];\n\n        // Run the saga\n        await runSaga(\n            {\n                dispatch: (action) =&gt; dispatchedActions.push(action),\n            },\n            fetchProductsSaga\n        ).toPromise();\n\n        expect(dispatchedActions).toContainEqual({\n            type: 'FETCH_PRODUCTS_SUCCESS',\n            payload: [{ id: 1, name: 'Product 1' }],\n        });\n    });\n\n    it('should dispatch failure action if API call fails', async () =&gt; {\n        // Mock API error\n        fetchMock.mockReject(new Error('API Error'));\n\n        const dispatchedActions = [];\n\n        // Run the saga\n        await runSaga(\n            {\n                dispatch: (action) =&gt; dispatchedActions.push(action),\n            },\n            fetchProductsSaga\n        ).toPromise();\n\n        expect(dispatchedActions).toContainEqual({\n            type: 'FETCH_PRODUCTS_FAILURE',\n            payload: 'API Error',\n        });\n    });\n});\n</code></pre> <ol> <li> <p>Use runSaga:</p> <ul> <li>Run your saga with mocked <code>dispatch</code> and <code>state</code> functions to simulate side effects.</li> </ul> </li> <li> <p>Mock API Calls:</p> <ul> <li>Mock the API calls (or any other side effects) to ensure that your saga correctly handles both success and failure cases.</li> </ul> </li> <li> <p>Verify Dispatched Actions:</p> <ul> <li>After running the saga, check that the correct actions were dispatched (e.g., <code>SUCCESS</code>, <code>FAILURE</code>).</li> </ul> </li> </ol> </li> </ol>"},{"location":"frontend/state-management/redux/core/redux-testing/#mocking-api-calls-in-redux-connected-components","title":"Mocking API Calls in Redux-Connected Components","text":"<p>Testing components that rely on async data (like API calls) means you need to mock those API responses and ensure the component behaves correctly.</p> <p>Example: ProductList Component with Thunk</p> <p>Let\u2019s take the <code>ProductList</code> component and test it with mocked API calls:</p> <pre><code>import React, { useEffect } from 'react';\nimport { connect } from 'react-redux';\nimport { fetchProducts } from './actions';\n\nconst ProductList = ({ products, loading, fetchProducts }) =&gt; {\n  useEffect(() =&gt; {\n    fetchProducts();\n  }, [fetchProducts]);\n\n  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Product List&lt;/h2&gt;\n      &lt;ul&gt;\n        {products.map((product) =&gt; (\n          &lt;li key={product.id}&gt;{product.name}&lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n      &lt;button onClick={fetchProducts}&gt;Reload Products&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nconst mapStateToProps = (state) =&gt; ({\n  products: state.products.items,\n  loading: state.products.loading,\n});\n\nexport default connect(mapStateToProps, { fetchProducts })(ProductList);\n</code></pre>"},{"location":"frontend/state-management/redux/core/redux-testing/#testing-the-component-with-api-calls","title":"Testing the Component with API Calls","text":"<p>We\u2019ll mock the API call and test the component rendering.</p> <pre><code>import React from 'react';\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport { Provider } from 'react-redux';\nimport configureMockStore from 'redux-mock-store';\nimport thunk from 'redux-thunk';\nimport fetchMock from 'jest-fetch-mock';\nimport ProductList from './ProductList';\n\n// Mock store and thunk middleware\nconst middlewares = [thunk];\nconst mockStore = configureMockStore(middlewares);\n\ndescribe('ProductList Component', () =&gt; {\n  let store;\n\n  beforeEach(() =&gt; {\n    fetchMock.resetMocks(); // Reset the fetch mocks before each test\n\n    store = mockStore({\n      products: { items: [], loading: false },\n    });\n  });\n\n  it('should fetch and display products', async () =&gt; {\n    // Mock the API response\n    fetchMock.mockResponseOnce(\n      JSON.stringify([{ id: 1, name: 'Product 1' }])\n    );\n\n    render(\n      &lt;Provider store={store}&gt;\n        &lt;ProductList /&gt;\n      &lt;/Provider&gt;\n    );\n\n    // Simulate component mounting and fetching products\n    expect(fetchMock).toHaveBeenCalledTimes(1); // Ensure the API call was made\n\n    // Assert that the product is rendered\n    expect(await screen.findByText('Product 1')).toBeInTheDocument();\n  });\n\n  it('should display loading state', () =&gt; {\n    store = mockStore({\n      products: { items: [], loading: true },\n    });\n\n    render(\n      &lt;Provider store={store}&gt;\n        &lt;ProductList /&gt;\n      &lt;/Provider&gt;\n    );\n\n    expect(screen.getByText('Loading...')).toBeInTheDocument();\n  });\n});\n</code></pre>"},{"location":"frontend/state-management/redux/core/redux-testing/#summary_1","title":"Summary:","text":"<ul> <li>Thunk Testing: Simulate API calls and check dispatched actions using a mock store.</li> <li>Saga Testing: Use <code>runSaga</code> to execute sagas and assert the side effects.</li> <li>Component Testing: Mock API calls using fetchMock or similar tools and verify the component behavior.</li> </ul>"},{"location":"frontend/state-management/redux/core/action/intro/","title":"Intro","text":""},{"location":"frontend/state-management/redux/core/action/intro/#what-is-an-action-in-redux","title":"What is an Action in Redux?","text":"<p>In Redux, an action is a plain JavaScript object that represents an event or change that happened in the application. It is the only source of information for the store, meaning all state changes in the store are triggered by actions.</p> <p>An action has two key properties:</p> <ul> <li>type: A string that defines the type of action (e.g., 'ADD_TODO', 'FETCH_DATA_SUCCESS'). This is mandatory.</li> <li>payload (optional): An additional data object that contains the information needed to perform the action (e.g., the todo item or fetched data).</li> </ul> Basic Example of an Action <pre><code>// Simple action to add a todo\nconst addTodoAction = {\n    type: 'ADD_TODO',               // Mandatory 'type' field\n    payload: {\n        text: 'Learn Redux',        // Optional 'payload' field containing data\n        id: 1\n    }\n};\n</code></pre> <p>The type field tells the Redux store what happened, and the payload field holds the data related to the action.</p> How Actions Work in Redux <ol> <li>Dispatch: Actions are dispatched from the UI or other parts of the app.</li> <li>Reducer: The action is passed to the reducer, which determines how the state should change based on the action's type.</li> <li>State Update: The store updates the state according to the reducer's instructions.</li> </ol>"},{"location":"frontend/state-management/redux/core/action/intro/#action-creator","title":"Action Creator","text":"<p>An action creator is a function that returns an action. It simplifies creating actions and helps avoid manually creating action objects.</p> <pre><code>// Action Creator to add a todo\nconst addTodo = (todo) =&gt; ({\n    type: 'ADD_TODO',\n    payload: { todo }\n});\n</code></pre> Using Action in a Component <pre><code>import React from 'react';\nimport { useDispatch } from 'react-redux';\nimport { addTodo } from './actions/todoActions';\n\nconst TodoComponent = () =&gt; {\n    const dispatch = useDispatch();\n\n    const handleAddTodo = () =&gt; {\n        const newTodo = { text: 'Learn Redux Basics', id: 1 };\n        dispatch(addTodo(newTodo)); // Dispatching the action\n    };\n\n    return (\n        &lt;button onClick={handleAddTodo}&gt;Add Todo&lt;/button&gt;\n    );\n};\n</code></pre> Simple Reducer Example <pre><code>const todoReducer = (state = { todos: [] }, action) =&gt; {\n    switch (action.type) {\n        case 'ADD_TODO':\n            return {\n                ...state,\n                todos: [...state.todos, action.payload.todo],\n            };\n        default:\n            return state;\n    }\n};\n</code></pre>"},{"location":"frontend/state-management/redux/core/action/intro/#difference-between-plain-action-action-creator","title":"Difference between plain action &amp; action creator","text":"<p>In Redux, actions and action creators are related but distinct concepts:</p>"},{"location":"frontend/state-management/redux/core/action/intro/#action","title":"Action","text":"<p>An action is a plain JavaScript object that describes a change or event in your application. It has at least one required property:</p> <ul> <li>type: A string that specifies the action type (e.g., 'ADD_TODO').</li> </ul> <p>Optionally, it can also include other properties:</p> <ul> <li>payload: Additional data needed to describe the action (e.g., the new todo item).</li> </ul> Example of an Action:<pre><code>// actions/todoActions.js (if you want to keep it organized)\nexport const addTodoAction = {\n    type: 'ADD_TODO',\n    payload: {\n        text: 'Learn Redux',\n        id: 1\n    }\n}\n// Usage in component\nconst handleAddTodo = () =&gt; {\n    dispatch(addTodoAction); // Dispatch the plain action object\n};\n</code></pre>"},{"location":"frontend/state-management/redux/core/action/intro/#action-creator_1","title":"Action Creator","text":"<p>An action creator is a function that creates and returns an action. It abstracts away the action object creation process and makes it easier to generate actions with the right structure.</p> <p>Action creators simplify creating actions and are useful for:</p> <ul> <li>Consistent action creation.</li> <li>Dynamically generating actions with specific payloads.</li> <li>Avoiding typos in action types.</li> </ul> <pre><code>// actions/todoActions.js (if you want to keep it organized)\nconst addTodo = (todo) =&gt; ({\n    type: 'ADD_TODO',\n    payload: todo\n});\n\n// Usage\nconst handleAddTodo = () =&gt; {\n  const newTodo = { text: 'Learn Redux', id: 1 };\n  dispatch(addTodo(newTodo)); // Using action creator\n};\n</code></pre> Summary <ul> <li>Action: A plain object that represents an event or change in the application. It has a type and optionally other properties like payload.</li> <li>Action Creator: A function that returns an action object. It helps in creating actions with the right structure and potentially dynamic data.</li> </ul> <p>In practice, action creators are commonly used in Redux applications because they provide a clear and consistent way to create actions and often handle complex logic for creating action objects.</p>"},{"location":"frontend/state-management/redux/core/action/intro/#tips-and-tricks-for-redux-actions","title":"Tips and Tricks for Redux Actions","text":"<ol> <li> <p>Action Types as Constants:</p> <ul> <li> <p>Use constants for action types to prevent typos and make refactoring easier.</p> <pre><code>export const ADD_TODO = 'ADD_TODO';\n</code></pre> </li> </ul> </li> <li> <p>Batched Actions:</p> <ul> <li> <p>Instead of dispatching multiple actions in sequence, you can batch them together.</p> <pre><code>const addTodoAndLog = (todo) =&gt; {\n    return (dispatch) =&gt; {\n        dispatch(addTodoAction(todo));\n        dispatch(logAction(todo));\n    };\n};\n</code></pre> </li> </ul> </li> </ol>"},{"location":"frontend/state-management/redux/core/reducer/example/","title":"Example","text":"<p>Facebook's developers follow a modular and organized approach to manage action types in their projects. Here is a closer look at how Facebook's React and Redux codebases might handle action types, inspired by best practices from projects like React and React Native.</p>"},{"location":"frontend/state-management/redux/core/reducer/example/#directory-structure","title":"Directory Structure","text":"<p>Let's assume a structure similar to how a large project at Facebook might be organized:</p> <pre><code>src/\n\u251c\u2500\u2500 actions/\n\u2502   \u251c\u2500\u2500 userActions.js\n\u2502   \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 actionTypes/\n\u2502   \u251c\u2500\u2500 userActionTypes.js\n\u2502   \u251c\u2500\u2500 notificationActionTypes.js\n\u2502   \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 reducers/\n\u2502   \u251c\u2500\u2500 userReducer.js\n\u2502   \u251c\u2500\u2500 notificationReducer.js\n\u2502   \u2514\u2500\u2500 index.js\n\u2514\u2500\u2500 store.js\n</code></pre>"},{"location":"frontend/state-management/redux/core/reducer/example/#define-action-types-in-separate-files","title":"Define Action Types in Separate Files","text":"<p>Each module or domain (e.g., users, notifications) has its own action types file.</p> <p>actionTypes/userActionTypes.js</p> <pre><code>export const FETCH_USERS_REQUEST = 'FETCH_USERS_REQUEST';\nexport const FETCH_USERS_SUCCESS = 'FETCH_USERS_SUCCESS';\nexport const FETCH_USERS_FAILURE = 'FETCH_USERS_FAILURE';\n</code></pre> <p>actionTypes/notificationActionTypes.js</p> <pre><code>export const FETCH_NOTIFICATIONS_REQUEST = 'FETCH_NOTIFICATIONS_REQUEST';\nexport const FETCH_NOTIFICATIONS_SUCCESS = 'FETCH_NOTIFICATIONS_SUCCESS';\nexport const FETCH_NOTIFICATIONS_FAILURE = 'FETCH_NOTIFICATIONS_FAILURE';\n</code></pre> <p>actionTypes/index.js</p> <p>This file aggregates all the action types from different domains.</p> <pre><code>export * from './userActionTypes';\nexport * from './notificationActionTypes';\n// Export other action types as needed\n</code></pre>"},{"location":"frontend/state-management/redux/core/reducer/example/#define-actions","title":"Define Actions","text":"<p>Each module has its own action creators, which use the specific action types.</p> <p>actions/userActions.js</p> <pre><code>import {\n  FETCH_USERS_REQUEST,\n  FETCH_USERS_SUCCESS,\n  FETCH_USERS_FAILURE\n} from '../actionTypes';\n\n// Action creator for initiating the fetch request\nexport const fetchUsersRequest = () =&gt; ({\n  type: FETCH_USERS_REQUEST\n});\n\n// Action creator for handling successful fetch\nexport const fetchUsersSuccess = (users) =&gt; ({\n  type: FETCH_USERS_SUCCESS,\n  payload: users\n});\n\n// Action creator for handling fetch failure\nexport const fetchUsersFailure = (error) =&gt; ({\n  type: FETCH_USERS_FAILURE,\n  payload: error\n});\n\n// Thunk action creator for fetching users from API\nexport const fetchUsers = () =&gt; {\n  return async (dispatch) =&gt; {\n    dispatch(fetchUsersRequest());\n\n    try {\n      const response = await fetch('https://api.example.com/users');\n      const data = await response.json();\n\n      if (response.ok) {\n        dispatch(fetchUsersSuccess(data));\n      } else {\n        throw new Error(data.message || 'Failed to fetch users');\n      }\n    } catch (error) {\n      dispatch(fetchUsersFailure(error.message));\n    }\n  };\n};\n</code></pre> <p>actions/index.js</p> <p>This file aggregates all action creators from different modules.</p> <pre><code>export * from './userActions';\nexport * from './notificationActions';\n// Export other actions as needed\n</code></pre>"},{"location":"frontend/state-management/redux/core/reducer/example/#define-reducers","title":"Define Reducers","text":"<p>Each module has its own reducer, which handles the specific action types.</p> <p>reducers/userReducer.js</p> <pre><code>import {\n  FETCH_USERS_REQUEST,\n  FETCH_USERS_SUCCESS,\n  FETCH_USERS_FAILURE\n} from '../actionTypes';\n\nconst initialState = {\n  loading: false,\n  users: [],\n  error: ''\n};\n\nconst userReducer = (state = initialState, action) =&gt; {\n  switch (action.type) {\n    case FETCH_USERS_REQUEST:\n      return {\n        ...state,\n        loading: true\n      };\n    case FETCH_USERS_SUCCESS:\n      return {\n        ...state,\n        loading: false,\n        users: action.payload,\n        error: ''\n      };\n    case FETCH_USERS_FAILURE:\n      return {\n        ...state,\n        loading: false,\n        users: [],\n        error: action.payload\n      };\n    default:\n      return state;\n  }\n};\n\nexport default userReducer;\n</code></pre> <p>reducers/index.js</p> <p>This file combines all the reducers from different modules.</p> <pre><code>import { combineReducers } from 'redux';\nimport userReducer from './userReducer';\nimport notificationReducer from './notificationReducer';\n\nconst rootReducer = combineReducers({\n  user: userReducer,\n  notification: notificationReducer,\n  // Add other reducers as needed\n});\n\nexport default rootReducer;\n</code></pre>"},{"location":"frontend/state-management/redux/core/reducer/example/#setting-up-the-redux-store","title":"Setting Up the Redux Store","text":"<p>store.js</p> <pre><code>import { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport rootReducer from './reducers';\n\nconst store = createStore(\n  rootReducer,\n  applyMiddleware(thunk)\n);\n\nexport default store;\n</code></pre>"},{"location":"frontend/state-management/redux/core/reducer/example/#using-actions-in-a-component","title":"Using Actions in a Component","text":"UserList.js<pre><code>import React, { useEffect } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { fetchUsers } from './actions';\n\nconst UserList = () =&gt; {\n  const dispatch = useDispatch();\n  const { loading, users, error } = useSelector((state) =&gt; state.user);\n\n  useEffect(() =&gt; {\n    dispatch(fetchUsers());\n  }, [dispatch]);\n\n  return (\n    &lt;div&gt;\n      {loading &amp;&amp; &lt;p&gt;Loading...&lt;/p&gt;}\n      {error &amp;&amp; &lt;p&gt;Error: {error}&lt;/p&gt;}\n      &lt;ul&gt;\n        {users.map((user) =&gt; (\n          &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default UserList;\n</code></pre> <p>By modularizing the action types, actions, and reducers, the codebase remains clean, maintainable, and scalable. This approach aligns with how large teams, like those at Facebook, manage their code.</p>"},{"location":"frontend/state-management/redux/core/reducer/intro/","title":"Intro","text":"<p>To master the Redux reducer, you should focus on understanding its core principles and progressively advancing to more complex patterns. Here\u2019s a step-by-step guide to mastering Redux reducers:</p>"},{"location":"frontend/state-management/redux/core/reducer/intro/#mastering-reducer","title":"Mastering Reducer","text":"<ol> <li> <p>Understand the Basics of a Reducer</p> <ul> <li>Pure Functions: Reducers must be pure functions. They should return a new state based on the action type without modifying the original state.</li> <li>Action Types: Actions describe what happened, and reducers define how the state changes in response to those actions.</li> <li>State Immutability: Always return a new copy of the state. Use spread syntax (<code>...state</code>) or libraries like <code>immer</code> for immutability.</li> </ul> <pre><code>const initialState = { count: 0 };\n\nconst counterReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case 'INCREMENT':\n            return { ...state, count: state.count + 1 };\n        case 'DECREMENT':\n            return { ...state, count: state.count - 1 };\n        default:\n            return state;\n    }\n};\n</code></pre> </li> <li> <p>Work with Complex State</p> <p>Once comfortable with simple states, move to complex nested state management. This is common in real-world apps, where state contains objects or arrays.</p> <ul> <li>Updating nested properties: For deep nested properties, make sure you understand how to properly update them without mutating the state.</li> </ul> <pre><code>const initialState = {\n    user: { name: 'John', details: { age: 30 } }\n};\n\nconst userReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case 'UPDATE_AGE':\n            return {\n                ...state,\n                user: {\n                    ...state.user,\n                    details: {\n                        ...state.user.details,\n                        age: action.payload.age\n                    }\n                }\n            };\n        default:\n            return state;\n    }\n};\n</code></pre> </li> <li> <p>Handle Arrays in Reducers</p> <p>Understanding how to add, remove, or update items in arrays is crucial for managing lists in Redux.</p> <pre><code>const initialState = { todos: [] };\n\nconst todoReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case 'ADD_TODO':\n            return {\n                ...state,\n                todos: [...state.todos, action.payload.todo]\n            };\n        case 'REMOVE_TODO':\n            return {\n                ...state,\n                todos: state.todos.filter(todo =&gt; todo.id !== action.payload.id)\n            };\n        default:\n            return state;\n    }\n};\n</code></pre> </li> <li> <p>Refactor and Modularize Reducers</p> <p>For large applications, breaking your reducers into smaller, manageable pieces (reducer composition) is crucial.</p> <ul> <li>Combine Reducers: Use <code>combineReducers</code> to split large reducers into smaller ones.</li> </ul> <pre><code>import { combineReducers } from 'redux';\n\nconst rootReducer = combineReducers({\n    counter: counterReducer,\n    todos: todoReducer,\n});\n</code></pre> <ul> <li>Action creators: Define action creators to make your reducer more readable and maintainable.</li> </ul> <pre><code>const increment = () =&gt; ({ type: 'INCREMENT' });\nconst addTodo = (todo) =&gt; ({ type: 'ADD_TODO', payload: { todo } });\n</code></pre> </li> <li> <p>Use Middlewares (for Async Logic)</p> <p>Mastering reducers also involves handling asynchronous logic. Redux Thunk or Redux-Saga are commonly used for side effects.</p> Thunk Example: <pre><code>const fetchData = () =&gt; async (dispatch) =&gt; {\n    dispatch({ type: 'FETCH_DATA_START' });\n    try {\n        const data = await apiCall();\n        dispatch({ type: 'FETCH_DATA_SUCCESS', payload: data });\n    } catch (error) {\n        dispatch({ type: 'FETCH_DATA_FAILURE', payload: error });\n    }\n};\n</code></pre> </li> <li> <p>Learn Advanced Patterns</p> <ul> <li>Normalization of State: As your state grows, it\u2019s crucial to normalize it, particularly for collections of related data like lists of users or posts.</li> <li>Reducer Factories: For repetitive tasks, such as managing similar types of state (e.g., loading/error states), use factory functions to create reusable reducer logic.</li> </ul> <pre><code>const createLoadingReducer = (actionType) =&gt; (state = false, action) =&gt; {\n    switch (action.type) {\n        case `${actionType}_REQUEST`:\n            return true;\n        case `${actionType}_SUCCESS`:\n        case `${actionType}_FAILURE`:\n            return false;\n        default:\n            return state;\n    }\n};\n\nconst loadingReducer = createLoadingReducer('FETCH_DATA');\n</code></pre> </li> <li> <p>Immer for Simplified State Management</p> <p>Immer is a popular library that allows you to write reducers as if you're mutating the state directly while keeping it immutable under the hood.</p> <pre><code>import produce from 'immer';\n\nconst todoReducer = (state = initialState, action) =&gt; \n    produce(state, draft =&gt; {\n        switch (action.type) {\n            case 'ADD_TODO':\n                draft.todos.push(action.payload.todo);\n                break;\n            case 'REMOVE_TODO':\n                const index = draft.todos.findIndex(todo =&gt; todo.id === action.payload.id);\n                if (index !== -1) draft.todos.splice(index, 1);\n                break;\n            }\n    });\n</code></pre> </li> <li> <p>Testing Reducers</p> <p>Testing is key to mastering reducers. Write unit tests for your reducers to ensure they behave as expected.</p> <pre><code>it('should increment the count', () =&gt; {\n    const action = { type: 'INCREMENT' };\n    const initialState = { count: 0 };\n    const newState = counterReducer(initialState, action);\n    expect(newState.count).toEqual(1);\n});\n</code></pre> </li> <li> <p>Master Edge Cases</p> <ul> <li>Handle default states and unknown actions.</li> <li>Ensure your reducer is optimized and scalable, particularly when dealing with large state objects.</li> </ul> </li> <li> <p>Keep Up with Best Practices</p> <ul> <li>Regularly review Redux documentation and explore Redux Toolkit, which simplifies many Redux patterns, such as creating reducers and handling immutability.</li> </ul> <pre><code>import { createSlice } from '@reduxjs/toolkit';\n\nconst todoSlice = createSlice({\n    name: 'todos',\n    initialState: [],\n    reducers: {\n        addTodo: (state, action) =&gt; {\n            state.push(action.payload.todo);\n        },\n        removeTodo: (state, action) =&gt; {\n            return state.filter(todo =&gt; todo.id !== action.payload.id);\n        },\n    },\n});\n\nexport const { addTodo, removeTodo } = todoSlice.actions;\nexport default todoSlice.reducer;\n</code></pre> </li> </ol> <p>By mastering these steps and gradually building more complex reducers, you'll become proficient in managing state in Redux.</p>"},{"location":"frontend/state-management/redux/core/reducer/intro/#what-is-an-action-creator","title":"What is an Action Creator?","text":"<p>An action creator is simply a function that returns an action. Actions are plain JavaScript objects that describe what happened in your application. The action creator is responsible for constructing that action object.</p> <p>In Redux, actions must have a <code>type</code> property that indicates the type of action being performed. Additional data related to the action can be passed as <code>payload</code>.</p>"},{"location":"frontend/state-management/redux/core/reducer/intro/#basic-example-of-an-action-creator","title":"Basic Example of an Action Creator","text":"<p>Here's a simple action creator:</p> <pre><code>// Basic Action Creator\nconst increment = () =&gt; ({\n  type: 'INCREMENT',\n});\n</code></pre> <p>This action creator returns an object with a <code>type</code> property. When dispatched, it will tell the reducer to increment the value in the state.</p> Usage: <pre><code>// Action object returned by the action creator\n{\n    type: 'INCREMENT'\n}\n\n// Dispatch the action\nstore.dispatch(increment());\n</code></pre> With Payload (passing additional data): <pre><code>const addTodo = (todo) =&gt; ({\n    type: 'ADD_TODO',\n    payload: {\n        todo,\n    },\n});\n\n// Example usage:\nstore.dispatch(addTodo('Learn Redux'));\n\n// This returns:\n{\n    type: 'ADD_TODO',\n    payload: { todo: 'Learn Redux' }\n}\n</code></pre> <pre><code>// todoActions.js (Action File)\n\n// Action creator for adding a todo\nexport const addTodo = (todo) =&gt; ({\n    type: 'ADD_TODO',\n    payload: { todo },\n});\n\n// Action creator for deleting a todo\nexport const deleteTodo = (id) =&gt; ({\n    type: 'DELETE_TODO',\n    payload: { id },\n});\n</code></pre> <pre><code>// todoReducer.js (Reducer File)\n\nconst initialState = { todos: [] };\n\n// Reducer function for handling todo actions\nconst todoReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case 'ADD_TODO':\n            return {\n                ...state,\n                todos: [...state.todos, action.payload.todo],\n            };\n        case 'DELETE_TODO':\n            return {\n                ...state,\n                todos: state.todos.filter(todo =&gt; todo.id !== action.payload.id),\n            };\n        default:\n            return state;\n  }\n};\n\nexport default todoReducer;\n</code></pre>"},{"location":"frontend/state-management/redux/core/reducer/modular-reducer/","title":"Modular Reducer","text":""},{"location":"frontend/state-management/redux/core/reducer/modular-reducer/#define-api-urls","title":"Define API URLs","text":"apiUrls.js<pre><code>export const API_URLS = {\n    FETCH_ITEMS: '/api/items',\n    CREATE_ITEM: '/api/items',\n    // Add more URLs as needed\n};\n</code></pre>"},{"location":"frontend/state-management/redux/core/reducer/modular-reducer/#define-headers","title":"Define Headers","text":"headers.js<pre><code>export const DEFAULT_HEADERS = {\n    'Content-Type': 'application/json',\n    // Add more default headers if needed\n};\n</code></pre>"},{"location":"frontend/state-management/redux/core/reducer/modular-reducer/#define-api-request-functions","title":"Define API Request Functions","text":"api.js<pre><code>import { DEFAULT_HEADERS } from './headers';\n\nexport const getApi = async (url, headers = DEFAULT_HEADERS) =&gt; {\n  const response = await fetch(url, { headers });\n  const data = await response.json();\n\n  if (!response.ok) {\n    throw new Error(data.message || 'Something went wrong');\n  }\n\n  return data;\n};\n\nexport const postApi = async (url, body, headers = DEFAULT_HEADERS) =&gt; {\n  const options = {\n    method: 'POST',\n    headers,\n    body: JSON.stringify(body)\n  };\n\n  const response = await fetch(url, options);\n  const data = await response.json();\n\n  if (!response.ok) {\n    throw new Error(data.message || 'Something went wrong');\n  }\n\n  return data;\n};\n\n// Add more methods (PUT, DELETE, etc.) as needed\n</code></pre>"},{"location":"frontend/state-management/redux/core/reducer/modular-reducer/#use-the-api-request-functions-in-action-creators","title":"Use the API Request Functions in Action Creators","text":"actions/itemActions.js<pre><code>import { getApi, postApi } from '../api';\nimport { API_URLS } from '../apiUrls';\nimport {\n  FETCH_ITEMS_REQUEST,\n  FETCH_ITEMS_SUCCESS,\n  FETCH_ITEMS_FAILURE,\n  CREATE_ITEM_REQUEST,\n  CREATE_ITEM_SUCCESS,\n  CREATE_ITEM_FAILURE\n} from '../actionTypes';\n\n// Fetch items\nexport const fetchItems = () =&gt; async (dispatch) =&gt; {\n  dispatch({ type: FETCH_ITEMS_REQUEST });\n  try {\n    const data = await getApi(API_URLS.FETCH_ITEMS);\n    dispatch({ type: FETCH_ITEMS_SUCCESS, payload: data });\n  } catch (error) {\n    dispatch({ type: FETCH_ITEMS_FAILURE, payload: error.message });\n  }\n};\n\n// Create item\nexport const createItem = (item) =&gt; async (dispatch) =&gt; {\n  dispatch({ type: CREATE_ITEM_REQUEST });\n  try {\n    const data = await postApi(API_URLS.CREATE_ITEM, item);\n    dispatch({ type: CREATE_ITEM_SUCCESS, payload: data });\n  } catch (error) {\n    dispatch({ type: CREATE_ITEM_FAILURE, payload: error.message });\n  }\n};\n</code></pre>"},{"location":"frontend/state-management/redux/core/reducer/modular-reducer/#full-example-directory-structure","title":"Full Example Directory Structure","text":"<pre><code>src/\n\u251c\u2500\u2500 actions/\n\u2502   \u251c\u2500\u2500 itemActions.js\n\u2502   \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 actionTypes/\n\u2502   \u251c\u2500\u2500 itemActionTypes.js\n\u2502   \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 api/\n\u2502   \u251c\u2500\u2500 api.js\n\u2502   \u251c\u2500\u2500 apiUrls.js\n\u2502   \u2514\u2500\u2500 headers.js\n\u251c\u2500\u2500 reducers/\n\u2502   \u251c\u2500\u2500 itemReducer.js\n\u2502   \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 store.js\n\u2514\u2500\u2500 components/\n    \u2514\u2500\u2500 ItemList.js\n</code></pre>"},{"location":"frontend/state-management/redux/core/reducer/modular-reducer/#putting-it-all-together","title":"Putting It All Together","text":"src/actions/itemActions.js<pre><code>import { getApi, postApi } from '../api/api';\nimport { API_URLS } from '../api/apiUrls';\nimport {\n  FETCH_ITEMS_REQUEST,\n  FETCH_ITEMS_SUCCESS,\n  FETCH_ITEMS_FAILURE,\n  CREATE_ITEM_REQUEST,\n  CREATE_ITEM_SUCCESS,\n  CREATE_ITEM_FAILURE\n} from '../actionTypes/itemActionTypes';\n\n// Fetch items\nexport const fetchItems = () =&gt; async (dispatch) =&gt; {\n  dispatch({ type: FETCH_ITEMS_REQUEST });\n  try {\n    const data = await getApi(API_URLS.FETCH_ITEMS);\n    dispatch({ type: FETCH_ITEMS_SUCCESS, payload: data });\n  } catch (error) {\n    dispatch({ type: FETCH_ITEMS_FAILURE, payload: error.message });\n  }\n};\n\n// Create item\nexport const createItem = (item) =&gt; async (dispatch) =&gt; {\n  dispatch({ type: CREATE_ITEM_REQUEST });\n  try {\n    const data = await postApi(API_URLS.CREATE_ITEM, item);\n    dispatch({ type: CREATE_ITEM_SUCCESS, payload: data });\n  } catch (error) {\n    dispatch({ type: CREATE_ITEM_FAILURE, payload: error.message });\n  }\n};\n</code></pre>"},{"location":"frontend/state-management/redux/core/reducer/throw-new-error/","title":"Throw New Error","text":""},{"location":"frontend/state-management/redux/core/reducer/throw-new-error/#understanding-throw-new-error","title":"Understanding throw new Error","text":"<p><code>throw new Error</code> is a way to create and throw a custom error in JavaScript. When you throw an <code>Error</code> object, you stop the normal execution flow and send control to the nearest catch block or global error handler, if no catch block is found.</p> Syntax<pre><code>if (!response.ok) {\n  throw new Error(data.message || 'Something went wrong');\n}\n</code></pre>"},{"location":"frontend/state-management/redux/core/reducer/throw-new-error/#importance-in-redux","title":"Importance in Redux","text":"<p>In a Redux-based application, throwing a new <code>Error</code> object is crucial for several reasons:</p> <ol> <li> <p>Consistent Error Handling:</p> <ul> <li> <p>By throwing an <code>Error</code>, you ensure that all errors are handled in a consistent manner. This consistency is vital for debugging and maintenance.</p> </li> <li> <p>Example:</p> <pre><code>try {\n    const data = await apiCall(url);\n} catch (error) {\n    console.error(error.message);\n}\n</code></pre> </li> </ul> </li> <li> <p>Centralized Error Management:</p> <ul> <li> <p>Redux action creators often make asynchronous calls (e.g., API requests). Throwing an <code>Error</code> allows these action creators to handle errors centrally, dispatching appropriate error actions.</p> </li> <li> <p>Example:</p> <pre><code>export const fetchData = () =&gt; async (dispatch) =&gt; {\n    dispatch({ type: FETCH_DATA_REQUEST });\n    try {\n        const data = await apiCall(url);\n        dispatch({ type: FETCH_DATA_SUCCESS, payload: data });\n    } catch (error) {\n        dispatch({ type: FETCH_DATA_FAILURE, payload: error.message });\n    }\n};\n</code></pre> </li> </ul> </li> <li> <p>Enhanced Debugging:</p> <ul> <li> <p>The <code>Error</code> object captures a stack trace, which provides valuable context about where the error occurred. This stack trace can be logged and used for debugging.</p> </li> <li> <p>Example:</p> <pre><code>catch (error) {\n    console.error('Error stack:', error.stack);\n}\n</code></pre> </li> </ul> </li> <li> <p>Flow Control:</p> <ul> <li> <p>Throwing an <code>Error</code> ensures that the normal flow of execution is interrupted, allowing you to handle exceptions appropriately. Without this, errors might go unnoticed, leading to unexpected behavior.</p> </li> <li> <p>Example:</p> <pre><code>const fetchData = async () =&gt; {\n    const response = await fetch(url);\n    if (!response.ok) {\n        throw new Error('Failed to fetch data');\n    }\n    return response.json();\n};\n</code></pre> </li> </ul> </li> </ol>"},{"location":"frontend/state-management/redux/core/reducer/throw-new-error/#consequences-of-not-throwing-an-error","title":"Consequences of Not Throwing an Error","text":"<p>If you don't throw an <code>Error</code>, the consequences can include:</p> <ol> <li> <p>Silent Failures:</p> <ul> <li> <p>Errors may go unnoticed, leading to silent failures where the application continues to run without handling the error.</p> </li> <li> <p>Example:</p> <pre><code>if (!response.ok) {\n    // No error thrown, so the function continues executing\n    console.error('Error fetching data');\n}\n</code></pre> </li> </ul> </li> <li> <p>Inconsistent State::</p> <ul> <li> <p>The application state might become inconsistent if errors are not properly handled, potentially causing further issues down the line.</p> </li> <li> <p>Example:</p> <pre><code>try {\n    const data = await apiCall(url);\n    // State might not update correctly if error is not handled\n} catch (error) {\n    // Handle error here\n}\n</code></pre> </li> </ul> </li> <li> <p>Difficult Debugging:</p> <ul> <li> <p>Without stack traces, debugging becomes more challenging. Developers have less context about where and why the error occurred.</p> </li> <li> <p>Example:</p> <pre><code>if (!response.ok) {\n    // No stack trace available\n    console.error('Error occurred');\n}\n</code></pre> </li> </ul> </li> </ol>"},{"location":"frontend/state-management/redux/core/reducer/throw-new-error/#example-in-redux-action-creator","title":"Example in Redux Action Creator","text":"<p>Here\u2019s a complete example demonstrating the use of throw new Error in a Redux action creator:</p> api.js<pre><code>export const apiCall = async (url, method = 'GET', body = null, headers = { 'Content-Type': 'application/json' }) =&gt; {\n    const options = { method, headers };\n    if (body) {\n        options.body = JSON.stringify(body);\n    }\n    const response = await fetch(url, options);\n    const data = await response.json();\n    if (!response.ok) {\n        throw new Error(data.message || 'Something went wrong');\n    }\n    return data;\n};\n</code></pre> actions/itemActions.js<pre><code>import { apiCall } from '../api/api';\nimport {\n    FETCH_ITEMS_REQUEST,\n    FETCH_ITEMS_SUCCESS,\n    FETCH_ITEMS_FAILURE,\n    CREATE_ITEM_REQUEST,\n    CREATE_ITEM_SUCCESS,\n    CREATE_ITEM_FAILURE\n} from '../actionTypes/itemActionTypes';\n\n// Fetch items\nexport const fetchItems = () =&gt; async (dispatch) =&gt; {\n    dispatch({ type: FETCH_ITEMS_REQUEST });\n    try {\n        const data = await apiCall('/api/items');\n        dispatch({ type: FETCH_ITEMS_SUCCESS, payload: data });\n    } catch (error) {\n        dispatch({ type: FETCH_ITEMS_FAILURE, payload: error.message });\n    }\n};\n\n// Create item\nexport const createItem = (item) =&gt; async (dispatch) =&gt; {\n    dispatch({ type: CREATE_ITEM_REQUEST });\n    try {\n        const data = await apiCall('/api/items', 'POST', item);\n        dispatch({ type: CREATE_ITEM_SUCCESS, payload: data });\n    } catch (error) {\n        dispatch({ type: CREATE_ITEM_FAILURE, payload: error.message });\n    }\n};\n</code></pre> <p>By throwing an <code>Error</code>, you ensure that your Redux actions can handle errors robustly and consistently, leading to a more stable and maintainable application.</p>"},{"location":"frontend/state-management/redux/core/reducer/throw-new-error/#why-we-throw-errors","title":"Why We Throw Errors","text":"<p>The primary reason for throwing errors is to ensure that they can be caught and handled appropriately. When you throw an error using <code>throw new Error</code>, it interrupts the normal execution flow and transfers control to the nearest <code>catch</code> block or an equivalent error-handling mechanism. Without this, errors might not be caught, leading to potential issues such as silent failures or inconsistent application states.</p>"},{"location":"frontend/state-management/redux/core/reducer/throw-new-error/#what-happens-if-we-dont-throw-an-error","title":"What Happens if We Don't Throw an Error","text":"<p>If you don't throw an error, it won't be caught by the catch block, and the execution will continue as if nothing went wrong. This can lead to various issues:</p> <ol> <li> <p>Silent Failures:</p> <p>The error might go unnoticed, leading to the application behaving incorrectly without any indication of what went wrong.</p> </li> <li> <p>Inconsistent State:</p> <p>If an error occurs and is not handled, the application state might become inconsistent, causing further issues down the line.</p> </li> <li> <p>Difficulty in Debugging:</p> <p>Without throwing an error, you lose the stack trace information, making it harder to debug and trace the source of the issue.</p> </li> </ol>"},{"location":"frontend/state-management/redux/core/reducer/throw-new-error/#example-without-throwing-an-error","title":"Example Without Throwing an Error","text":"<p>Here\u2019s an example to illustrate what happens when you don't throw an error:</p> api.js<pre><code>export const apiCall = async (url, method = 'GET', body = null, headers = { 'Content-Type': 'application/json' }) =&gt; {\n    const options = { method, headers };\n    if (body) {\n        options.body = JSON.stringify(body);\n    }\n    const response = await fetch(url, options);\n    const data = await response.json();\n    // Not throwing an error\n    if (!response.ok) {\n        return data.message || 'Something went wrong';\n    }\n    return data;\n};\n</code></pre> actions/itemActions.js<pre><code>import { apiCall } from '../api/api';\nimport {\n  FETCH_ITEMS_REQUEST,\n  FETCH_ITEMS_SUCCESS,\n  FETCH_ITEMS_FAILURE,\n  CREATE_ITEM_REQUEST,\n  CREATE_ITEM_SUCCESS,\n  CREATE_ITEM_FAILURE\n} from '../actionTypes/itemActionTypes';\n\n// Fetch items\nexport const fetchItems = () =&gt; async (dispatch) =&gt; {\n  dispatch({ type: FETCH_ITEMS_REQUEST });\n  try {\n    const data = await apiCall('/api/items');\n    if (!data.ok) {\n      dispatch({ type: FETCH_ITEMS_FAILURE, payload: data.message });\n    } else {\n      dispatch({ type: FETCH_ITEMS_SUCCESS, payload: data });\n    }\n  } catch (error) {\n    dispatch({ type: FETCH_ITEMS_FAILURE, payload: error.message });\n  }\n};\n\n// Create item\nexport const createItem = (item) =&gt; async (dispatch) =&gt; {\n    dispatch({ type: CREATE_ITEM_REQUEST });\n    try {\n        const data = await apiCall('/api/items', 'POST', item);\n        if (!data.ok) {\n            dispatch({ type: CREATE_ITEM_FAILURE, payload: data.message });\n        } else {\n            dispatch({ type: CREATE_ITEM_SUCCESS, payload: data });\n        }\n    } catch (error) {\n        dispatch({ type: CREATE_ITEM_FAILURE, payload: error.message });\n    }\n};\n</code></pre> <p>In this case, you have to handle the error within the action creator itself by checking the response. This approach is cumbersome and error-prone.</p>"},{"location":"frontend/state-management/redux/core/reducer/throw-new-error/#example-with-throwing-an-error","title":"Example With Throwing an Error","text":"<p>By throwing an error, you can simplify the error handling process:</p> api.js<pre><code>export const apiCall = async (url, method = 'GET', body = null, headers = { 'Content-Type': 'application/json' }) =&gt; {\n    const options = { method, headers };\n    if (body) {\n        options.body = JSON.stringify(body);\n    }\n    const response = await fetch(url, options);\n    const data = await response.json();\n    if (!response.ok) {\n        throw new Error(data.message || 'Something went wrong');\n    }\n    return data;\n};\n</code></pre> actions/itemActions.js<pre><code>import { apiCall } from '../api/api';\nimport {\n    FETCH_ITEMS_REQUEST,\n    FETCH_ITEMS_SUCCESS,\n    FETCH_ITEMS_FAILURE,\n    CREATE_ITEM_REQUEST,\n    CREATE_ITEM_SUCCESS,\n    CREATE_ITEM_FAILURE\n} from '../actionTypes/itemActionTypes';\n\n// Fetch items\nexport const fetchItems = () =&gt; async (dispatch) =&gt; {\n    dispatch({ type: FETCH_ITEMS_REQUEST });\n    try {\n        const data = await apiCall('/api/items');\n        dispatch({ type: FETCH_ITEMS_SUCCESS, payload: data });\n    } catch (error) {\n        dispatch({ type: FETCH_ITEMS_FAILURE, payload: error.message });\n    }\n};\n\n// Create item\nexport const createItem = (item) =&gt; async (dispatch) =&gt; {\n    dispatch({ type: CREATE_ITEM_REQUEST });\n    try {\n        const data = await apiCall('/api/items', 'POST', item);\n        dispatch({ type: CREATE_ITEM_SUCCESS, payload: data });\n    } catch (error) {\n        dispatch({ type: CREATE_ITEM_FAILURE, payload: error.message });\n    }\n};\n</code></pre>"},{"location":"frontend/state-management/redux/core/reducer/throw-new-error/#advantages-of-throwing-an-error","title":"Advantages of Throwing an Error","text":"<ol> <li> <p>Centralized Error Handling:</p> <p>By throwing an error, you allow the catch block to handle it centrally, making your code cleaner and easier to maintain.</p> </li> <li> <p>Clear Flow Control:</p> <p>Throwing an error immediately stops execution of the current function and transfers control to the nearest error handler.</p> </li> <li> <p>Detailed Error Information:</p> <p>The Error object includes a message and a stack trace, which are useful for debugging.</p> </li> <li> <p>Consistency:</p> <p>Ensures that all errors are handled consistently, reducing the likelihood of uncaught errors.</p> </li> </ol> <p>By adhering to this pattern, you ensure that your application handles errors robustly, making it more reliable and easier to maintain.</p>"},{"location":"frontend/state-management/redux/core/redux-middleware/intro/","title":"Intro","text":""},{"location":"frontend/state-management/redux/core/redux-middleware/intro/#redux-middleware-saga-and-thunk","title":"Redux middleware \u2013 Saga and Thunk","text":"<p>The basic Redux store can only perform simple synchronous state updates by dispatching an action.</p> <p>Middleware such as Redux Thunk and Redux Saga help extend the store capabilities by writing the async logic to interact with the store. These middleware are helpful to avoid directly causing side effects in our actions, action creators, or components.</p>"},{"location":"frontend/state-management/redux/core/redux-middleware/intro/#what-is-redux-middleware-how-do-you-create-middleware","title":"What is Redux middleware? How do you create middleware?","text":"<p>Redux middleware provides a third-party extension to intercept every action sent to the reducer by modifying the action or canceling the action. It is helpful for logging, error reporting, routing, and making asynchronous API calls. Although Redux middleware is like Node.js middleware (for example, Express and Koa), it solves different problems.</p>"},{"location":"frontend/state-management/redux/core/redux-middleware/intro/#how-do-you-handle-asynchronous-tasks-in-redux","title":"How do you handle asynchronous tasks in Redux?","text":"<p>Most modern web applications need to deal with asynchronous tasks. In React, there are two popular libraries available to handle them: </p> <ol> <li>Redux Thunk &amp;</li> <li>Redux Saga.</li> </ol>"},{"location":"frontend/state-management/redux/core/redux-middleware/intro/#how-do-you-choose-between-redux-saga-and-redux-thunk","title":"How do you choose between Redux Saga and Redux Thunk?","text":"<p>Both Redux Thunk and Redux Saga middleware are helpful in allowing the Redux store to interact with external API calls (or side effects) asynchronously. But the decision to choose one of them totally depends on your project requirements and personal preference. </p> <p>Redux Thunk is a good choice if you are new to the React or Redux ecosystem and the project is small in size. Moreover, Redux Thunk requires less boilerplate code and is easy to understand.</p> <p>On the other hand, Redux Saga is suitable for big projects where you need to split the logic into multiple files. However, the main advantage of Redux Saga over Redux Thunk is the ability to write clean and readable tests for asynchronous code.</p> <p>The plain Redux requires a lot of boilerplate code to fulfill the state management requirements.Developers need to implement common tasks such as store setup, writing reducers and actions, and so on. Also, you may need to import APIs from other packages based on needs. So, this entire process makes it difficult for developers to learn and implement the Redux solution. RTK is going to standardize the process and simplify it with its helpers.</p>"},{"location":"frontend/state-management/redux/core/redux-middleware/intro/#standardizing-redux-logic-using-rtk","title":"Standardizing Redux logic using RTK","text":"<p>The RTK package provides the necessary tools to ease Redux development. This package not only eases development but also prevents common mistakes, provides suggested best practices, and many more features.</p>"},{"location":"frontend/state-management/redux/core/redux-middleware/intro/#what-is-rtk","title":"What is RTK?","text":"<p>Redux Toolkit (RTK) is a set of tools that simplifies Redux development and is used as an officially recommended approach to writing Redux logic. It was previously known as Redux Smarter Kit. The node package for this toolkit is available with the name @reduxjs/toolkit, which is wrapped around the core redux package. In summary, this package provides utilities and common dependencies that are required for building a Redux application.</p> <p>This tool helps cover common use cases such as setting up the store, creating the reducers and actions, writing immutable update logic, and creating entire slices of state at once.</p> <p>By default, RTK automatically supports the following officially recommended set of tools or libraries to cover most of the common use cases:</p> <ul> <li>Redux DevTools</li> <li>Immer</li> <li>Redux Thunk</li> <li>Reselect</li> </ul> <p>RTK supports TypeScript through which APIs provide excellent type safety and reduce the number of types used in the code.</p>"},{"location":"frontend/state-management/redux/core/redux-middleware/intro/#what-are-the-problems-solved-by-rtk","title":"What are the problems solved by RTK?","text":"<p>RTK is helpful to speed up the development process and apply the recommended best practices automatically. It solves the following three major issues found in the Redux library:</p> <ul> <li>Configuring a Redux store that is too complicated</li> <li>This Redux library requires a lot of dependencies for building a large-scale application</li> <li>Redux requires too much boilerplate code, which impacts the efficiency and quality of the code</li> </ul> <p>The toolkit provides certain options to configure the global store, creating actions and reducers that make the development simpler by abstracting the Redux API.</p>"},{"location":"frontend/state-management/redux/core/redux-middleware/intro/#what-is-rtk-query-how-do-you-use-it","title":"What is RTK Query? How do you use it?","text":"<p>RTK Query is a powerful data fetching and client-side caching tool to simplify common use cases in Redux applications. For example, this tool supports use cases such as loading data in the web application, avoiding the need for hand-written data fetching and caching logic, and so on. If you are using the RTK package, this query feature is going to be available as an optional add-on. Also, this feature is built-in on top of the RTK API methods such as <code>createSlice</code> and <code>createAsyncThunk</code> for its implementation.</p>"},{"location":"frontend/state-management/redux/core/redux-middleware/intro/#reference","title":"Reference","text":"<ul> <li>React Interview Guide - packt pg:155</li> </ul>"},{"location":"frontend/state-management/redux/core/redux-middleware/redux-saga/","title":"Redux Saga","text":""},{"location":"frontend/state-management/redux/core/redux-middleware/redux-saga/#what-is-redux-saga","title":"What is Redux Saga?","text":"<p>Redux Saga is a popular competitor for Redux Thunk middleware for handling asynchronous side effects. Redux Saga uses an ES6 feature known as generators that helps in writing asynchronous code. These generators are functions that can be paused, resumed, exited in the middle of execution, and re-entered later during the operations.</p> <p>The side effects will be generated using special helper functions from the <code>redux-saga</code> package. Some of those commonly used functions are listed here:</p> <ul> <li>Call: An effect description that instructs the middleware to call other functions in Saga</li> <li>Put: Used to dispatch an action to the store</li> <li>Yield: A built-in function that allows the use of generator functions sequentially</li> <li>takeLatest: Invokes the function handler only once at a time and cancels the previous tasks by running again with the latest data</li> <li>takeEvery: Invokes the function handler every time infinitely and concurrently whenever the action fires</li> </ul> <ul> <li>React Interview Guide - packt pg:155</li> </ul>"},{"location":"frontend/state-management/redux/core/redux-middleware/redux-thunk/","title":"Redux Thunk","text":"<p>Redux Thunk middleware is used to write an action creator that returns a function instead of just an action object in the Redux application. The functions returned from the action creator are called thunk functions and are used to delay the computation. These functions accept two arguments \u2013 the dispatch and getState methods:</p>"},{"location":"frontend/state-management/redux/core/redux-middleware/redux-thunk/#what-are-the-use-cases-of-redux-thunk","title":"What are the use cases of Redux Thunk?","text":"<p>Redux Thunk can have any arbitrary logic and it can be used for a variety of purposes. The most common use cases of Redux Thunk are listed as follows:</p> <ul> <li>When you\u2019re trying to move complex logic out of React components</li> <li>When you are making async requests such as Ajax calls and other async logic</li> <li>When you need to create a logic that needs to dispatch multiple distinct actions in a row</li> <li>When you are planning to write a logic that needs to access getState or other state values to make decisions</li> </ul> <p>In summary, the main use case of Redux Thunk middleware is for handling actions that are not synchronous.</p> <ul> <li>React Interview Guide - packt pg:155</li> </ul>"},{"location":"frontend/state-management/redux/persist/example/","title":"Example","text":"<p>Redux Persist is a library that helps you save and rehydrate the Redux state in your application, enabling it to persist between page reloads or browser sessions. Essentially, it allows your Redux store to survive page refreshes by storing the Redux state in a storage engine like localStorage or sessionStorage in the browser (or AsyncStorage in React Native).</p>"},{"location":"frontend/state-management/redux/persist/example/#key-concepts-of-redux-persist","title":"Key Concepts of Redux Persist:","text":"<ul> <li>Persisted State: It saves the Redux state in a persistent storage (e.g., localStorage, sessionStorage, etc.).</li> <li>Rehydration: When the app restarts or reloads, it loads the saved state back into the Redux store.</li> </ul>"},{"location":"frontend/state-management/redux/persist/example/#common-use-cases","title":"Common Use Cases:","text":"<ul> <li>User Authentication: To persist user login status, like saving a JWT token or user information.</li> <li>App Preferences: Persisting theme settings, user preferences, etc.</li> <li>Shopping Cart: Storing cart data in eCommerce apps.</li> </ul>"},{"location":"frontend/state-management/redux/persist/example/#where-to-use-redux-persist","title":"Where to Use Redux Persist:","text":"<p>You typically integrate Redux Persist in your Redux setup at the root level, because it needs to wrap your Redux store and ensure that the persistence is set up properly for the entire store. Here's a high-level example of how you can implement Redux Persist:</p>"},{"location":"frontend/state-management/redux/persist/example/#steps-to-set-up-redux-persist","title":"Steps to Set Up Redux Persist:","text":"<ol> <li> <p>Install Redux Persist:</p> <pre><code>npm install redux-persist\n</code></pre> </li> <li> <p>Configure Redux Persist:</p> <p>You need to create a configuration that defines the persist behavior and specify which parts of the state you want to persist.</p> </li> <li> <p>Setup Redux Store with Redux Persist:</p> <p>Example of integrating Redux Persist into a Redux store:</p> <pre><code>import { createStore } from \"redux\";\nimport { persistStore, persistReducer } from \"redux-persist\";\nimport storage from \"redux-persist/lib/storage\"; // Defaults to localStorage in the browser\nimport rootReducer from \"./reducers\"; // Your root reducer\n\n// Redux Persist config\nconst persistConfig = {\n  key: \"root\",\n  storage,\n  whitelist: [\"auth\", \"preferences\"], // Only persist auth and preferences reducers (optional)\n};\n\nconst persistedReducer = persistReducer(persistConfig, rootReducer);\n\n// Create the store\nconst store = createStore(persistedReducer);\n\n// Create the persistor to manage the persistence logic\nconst persistor = persistStore(store);\n\nexport { store, persistor };\n</code></pre> </li> <li> <p>Wrap Your Application with PersistGate:</p> <p>In your main app component (typically <code>App.js</code> or <code>index.js</code>), you'll use the PersistGate component to wrap your app to delay the rendering of the app until the Redux state has been rehydrated (i.e., restored from storage).</p> <pre><code>import React from \"react\";\nimport { PersistGate } from \"redux-persist/integration/react\";\nimport { Provider } from \"react-redux\";\nimport { store, persistor } from \"./store\"; // Import the store and persistor\n\nfunction App() {\n  return (\n    &lt;Provider store={store}&gt;\n      &lt;PersistGate loading={null} persistor={persistor}&gt;\n        {/* Your app components go here */}\n      &lt;/PersistGate&gt;\n    &lt;/Provider&gt;\n  );\n}\n\nexport default App;\n</code></pre> </li> </ol>"},{"location":"frontend/state-management/redux/persist/example/#do-you-need-redux-persist-in-the-root","title":"Do You Need Redux Persist in the Root?","text":"<p>Yes, Redux Persist should be configured at the root level, because:</p> <ul> <li>It needs to wrap your Redux store to persist and rehydrate the global state of your application.</li> <li>It should be set up before the main app starts rendering so that it ensures the persisted state is restored when your application reloads.</li> </ul> In summary: <ul> <li>Root level: Set up Redux Persist in your store configuration (with <code>persistReducer</code> and <code>persistStore</code>).</li> <li>App level: Use <code>PersistGate</code> to ensure the app waits for the Redux state to be rehydrated before rendering the UI.</li> </ul> <p>This ensures that your app has access to the persisted state as soon as it starts, and users can resume their activities after a page reload without losing their data.</p>"},{"location":"frontend/state-management/redux/persist/immer-example/","title":"Immer","text":"<p>To use Immer in your Redux reducer, you can simplify the state updates by leveraging the produce function from Immer. Here's how you can refactor your reducer code using Immer:</p> <ol> <li> <p>Install Immer if you haven't already:</p> </li> <li> <p>Update your reducer to use <code>produce</code>. Here's an example based on your code:</p> ExampleExplanation <pre><code>import { produce } from 'immer';\n\nconst initialState = {\n    exportDailDiary: null,\n    exportDailDiaryLoading: false,\n};\n\nconst dailyDairyReducer = (state = initialState, action) =&gt; {\n    return produce(state, (draft) =&gt; {\n        switch (action.type) {\n            case DAILY_DAIRY.EXPORT_DAILY_DAIRY_INIT:\n                draft.exportDailDiaryLoading = true;\n                break;\n\n            case DAILY_DAIRY.EXPORT_DAILY_DAIRY_SUCCESS:\n                draft.exportDailDiary = action.payload;\n                draft.exportDailDiaryLoading = false;\n                break;\n\n            case DAILY_DAIRY.EXPORT_DAILY_DAIRY_FINISH:\n                draft.exportDailDiaryLoading = false;\n                break;\n\n            default:\n                return state;\n        }\n    });\n};\n\nexport default dailyDairyReducer;\n</code></pre> <ul> <li><code>produce</code>: This function takes the current state and a \"draft\" function, allowing you to modify the draft directly. Immer takes care of creating a new state based on the modifications.</li> <li>Draft Mutability: Within the draft function, you can directly mutate the <code>draft</code> object without worrying about immutability.</li> </ul> </li> </ol> <p>This approach results in cleaner and more readable code while maintaining the benefits of immutability that Redux requires.</p>"},{"location":"frontend/state-management/redux/persist/immer-example/#additional","title":"Additional","text":"question <p>The difference between the two import statements lies in how the <code>produce</code> function is exported from the Immer library:</p> <ol> <li> <p><code>import produce from 'immer';</code>:</p> <ul> <li>This is a default import syntax.</li> <li>It works when a module exports a single entity as its default export.</li> <li>In the case of Immer, <code>produce</code> is not the default export.</li> </ul> </li> <li> <p><code>import { produce } from 'immer';</code>:</p> <ul> <li>This is a named import syntax.</li> <li>It is used to import specific exports from a module.</li> <li>Since <code>produce</code> is a named export in Immer, this is the correct way to import it.</li> </ul> </li> </ol> <p>Which Works in React?</p> <ul> <li>Correct Usage: You should use <code>import { produce } from 'immer';</code> because <code>produce</code> is a named export.</li> <li>Default Import Error: If you use <code>import produce from 'immer';</code>, you will encounter an error stating that Immer does not contain a default export.</li> </ul> <p>Conclusion</p> <p>For React (and any JavaScript code using Immer), always use the named import syntax:</p> <pre><code>import { produce } from \"immer\";\n</code></pre> <p>This is the proper way to import the <code>produce</code> function from Immer.</p>"},{"location":"frontend/state-management/redux/persist/question/","title":"Question","text":"<pre><code>{\n    key: \"auth\",\n    storage,\n};\n\nby default it creates root. where do i need to store it in \"root\" or i can create as many key name like \"auth\" as i like\n</code></pre> <p>Yes, you can create as many key names as you like when configuring Redux Persist. The key name you specify is used to differentiate different parts of the state that you want to persist.</p>"},{"location":"frontend/state-management/redux/persist/question/#key-points-to-understand","title":"Key Points to Understand:","text":"<ol> <li> <p>Default Key (<code>root</code>):</p> <ul> <li>When you use <code>key: 'root'</code>, you're specifying the main key under which the entire Redux state will be persisted. This is the default behavior when you don't specify a custom key.</li> </ul> <pre><code>const persistConfig = {\n  key: \"root\",\n  storage,\n};\n</code></pre> </li> <li> <p>Custom Key Names:</p> <p>You can use any name as the <code>key</code>, such as <code>auth</code>, <code>preferences</code>, or <code>cart</code>, and that key will specifically store the relevant part of the Redux state.</p> <pre><code>const persistConfig = {\n  key: \"auth\", // Store only the 'auth' part of the state\n  storage,\n};\n</code></pre> <p>In this case, only the <code>auth</code> reducer's state will be persisted in storage (e.g., <code>localStorage</code> or <code>sessionStorage</code>), not the entire Redux state.</p> </li> </ol>"},{"location":"frontend/state-management/redux/persist/question/#where-should-you-store-it-root-vs-custom-key-names","title":"Where Should You Store it: \"root\" vs. Custom Key Names","text":"<ul> <li>Root key (root): You should only use the key: 'root' when you want to persist the entire Redux store (all reducers and all state).</li> <li>Custom key names: If you want to persist specific parts of your state, you can use any custom key like 'auth', 'preferences', 'userData', etc.</li> </ul>"},{"location":"frontend/state-management/redux/persist/question/#example-with-multiple-keys","title":"Example with Multiple Keys:","text":"<p>If you want to persist multiple parts of your state (e.g., <code>auth</code> and <code>preferences</code>), you can use a combination of <code>whitelist</code> (or <code>blacklist</code>) in your configuration.</p> Example Configuration for Multiple Keys:<pre><code>import { createStore } from \"redux\";\nimport { persistStore, persistReducer } from \"redux-persist\";\nimport storage from \"redux-persist/lib/storage\";\nimport rootReducer from \"./reducers\"; // Assuming you have an auth and preferences reducer\n\nconst persistConfig = {\n  key: \"root\",\n  storage,\n  whitelist: [\"auth\", \"preferences\"], // Persist only the auth and preferences reducers\n};\n\nconst persistedReducer = persistReducer(persistConfig, rootReducer);\n\nconst store = createStore(persistedReducer);\nconst persistor = persistStore(store);\n\nexport { store, persistor };\n</code></pre> <p>In this case:</p> <ul> <li><code>key: 'root'</code> persists the entire store.</li> <li><code>whitelist: ['auth', 'preferences']</code> ensures that only the <code>auth</code> and <code>preferences</code> reducers are saved in persistent storage (e.g., localStorage).</li> </ul> <p>???+ note title=\"Important Notes:\"</p> <pre><code>`whitelist` vs. `blacklist`:\n\n-   `whitelist`: Specifies which reducers (by key name) to persist.\n-   `blacklist`: Specifies which reducers (by key name) to not persist.\n\nIf you use `whitelist`, only those parts of the state will be persisted. Conversely, if you use `blacklist`, all parts of the state will be persisted except those you specify.\n</code></pre> Important Notes: <pre><code>const persistConfig = {\n    key: 'root',\n    storage,\n    blacklist: ['tempData'], // Don't persist the 'tempData' reducer\n};\n</code></pre>"},{"location":"frontend/state-management/redux/persist/question/#conclusion","title":"Conclusion:","text":"<ul> <li>Root (<code>'root'</code>): If you want to persist the entire store, use <code>key: 'root'</code>.</li> <li>Custom keys: If you want to persist specific parts of the state, use custom keys like <code>'auth'</code>, <code>'preferences'</code>, etc., and configure <code>whitelist</code> or <code>blacklist</code> accordingly.</li> </ul>"},{"location":"frontend/state-management/redux/persist/redux-persist-purge/","title":"Purge","text":""},{"location":"frontend/state-management/redux/persist/redux-persist-purge/#when-to-purge","title":"When to purge","text":"<p>Here are some key topics related to when to purge or clear Redux Persist state:</p> <ol> <li> <p>User Authentication:</p> <ul> <li>On Logout: Purge persisted state when a user logs out to remove sensitive information.</li> <li>On Session Expiry: Clear state if a session is detected to be expired.</li> </ul> <pre><code>// actions.js\nexport const logoutUser = () =&gt; {\n  return async (dispatch) =&gt; {\n    // Perform logout logic\n    dispatch({ type: \"LOGOUT\" });\n\n    // Purge persisted state\n    const persistor = store.persistor; // Access the persistor\n    persistor.purge();\n  };\n};\n</code></pre> </li> <li> <p>User Switching:</p> <ul> <li>On User Switch: Clear state when switching users to prevent carrying over data from one session to another.</li> </ul> <pre><code>// actions.js\nexport const switchUser = (newUser) =&gt; {\n  return async (dispatch) =&gt; {\n    // Update user state\n    dispatch({ type: \"SWITCH_USER\", payload: newUser });\n\n    // Purge persisted state\n    const persistor = store.persistor; // Access the persistor\n    persistor.purge();\n  };\n};\n</code></pre> </li> <li> <p>Account Deletion:</p> <ul> <li>On Account Deletion: Purge data when a user deletes their account to ensure all personal information is removed.</li> </ul> <pre><code>// actions.js\nexport const deleteAccount = () =&gt; {\n  return async (dispatch) =&gt; {\n    // Perform account deletion logic\n    dispatch({ type: \"DELETE_ACCOUNT\" });\n\n    // Purge persisted state\n    const persistor = store.persistor; // Access the persistor\n    persistor.purge();\n  };\n};\n</code></pre> </li> <li> <p>Sensitive Operations:</p> <ul> <li>After Sensitive Actions: Consider clearing state after certain actions that involve sensitive data, like changing passwords or personal details.</li> </ul> <pre><code>// actions.js\nexport const changePassword = (newPassword) =&gt; {\n  return async (dispatch) =&gt; {\n    // Change password logic\n    dispatch({ type: \"CHANGE_PASSWORD\" });\n\n    // Optionally purge state for security\n    const persistor = store.persistor;\n    persistor.purge();\n  };\n};\n</code></pre> </li> <li> <p>Error Handling:</p> <ul> <li>On Critical Errors: Optionally, you can clear state when encountering critical errors that might compromise application integrity.</li> </ul> </li> <li> <p>Testing:</p> <ul> <li>During Tests: Clear the state to ensure tests start with a clean slate.</li> </ul> </li> <li> <p>Application Reset:</p> <ul> <li>On App Reset: If your application has a reset feature, you might want to clear persisted state at that point.</li> </ul> </li> </ol> <p>Implementing these practices ensures that your application maintains security and integrity when handling user data.</p>"},{"location":"frontend/state-management/redux/persist/redux-persist-purge/#using-middleware","title":"Using Middleware","text":"<p>You can also create middleware to listen for specific actions and purge the state accordingly:</p> <pre><code>// middleware.js\nconst purgeMiddleware = (store) =&gt; (next) =&gt; (action) =&gt; {\n  if (action.type === \"LOGOUT\" || action.type === \"DELETE_ACCOUNT\") {\n    const persistor = store.persistor;\n    persistor.purge();\n  }\n  return next(action);\n};\n\n// Applying middleware\nconst store = createStore(reducer, applyMiddleware(purgeMiddleware));\n</code></pre> <p>Using middleware for managing Redux Persist purging can indeed be a great option for several reasons:</p> ExampleAdvantages of Using MiddlewareConclusion <pre><code>// middleware.js\nconst purgeMiddleware = (persistor) =&gt; store =&gt; next =&gt; action =&gt; {\n    if (action.type === 'LOGOUT' || action.type === 'DELETE_ACCOUNT') {\n        persistor.purge();\n    }\n    return next(action);\n};\n\n// Applying middleware in your store setup\nimport { createStore, applyMiddleware } from 'redux';\nimport { persistStore } from 'redux-persist';\nimport rootReducer from './reducers';\n\nconst store = createStore(rootReducer, applyMiddleware(purgeMiddleware(persistor)));\nconst persistor = persistStore(store);\n</code></pre> <ol> <li> <p>Separation of Concerns: Middleware helps keep your action creators clean and focused on dispatching actions rather than handling side effects. This leads to better-organized code.</p> </li> <li> <p>Centralized Logic: By placing purge logic in middleware, you can manage it in one place. This makes it easier to maintain and update the purging behavior without needing to modify multiple action creators.</p> </li> <li> <p>Reusability: If you have multiple actions that require similar purging behavior, middleware allows you to reuse that logic without duplicating code.</p> </li> <li> <p>Easier Testing: Middleware can be tested independently, making it simpler to ensure that your purging logic behaves as expected without tying it to the specifics of your actions.</p> </li> <li> <p>Conditional Purging: Middleware can handle more complex conditions for purging state, allowing you to define when state should be cleared based on various actions or application states.</p> </li> </ol> <p>Using middleware for this purpose is often a good practice, particularly in larger applications where separation of concerns and code maintainability are priorities. However, if your application is smaller and the purging logic is minimal, you might opt to keep it directly in the action creators for simplicity. Ultimately, the best approach depends on your specific application's architecture and requirements.</p>"},{"location":"frontend/state-management/redux/persist/redux-persist-purge/#creating-separate-purge-middleware","title":"Creating Separate <code>purge</code> middleware","text":""},{"location":"frontend/state-management/redux/persist/redux-persist-purge/#standard-redux","title":"Standard Redux","text":"<p>Yes, you can definitely create a separate file to handle the purging logic for Redux Persist. This can further improve the organization of your code. Here\u2019s how you can structure it:</p> 1. Create a New File for Purge Logic2. Update Your Store Configuration3. Optional: Action Types <p>You can create a file named <code>purgeMiddleware.js</code> (or a similar name) to define the middleware that handles purging the persisted state.</p> <pre><code>import { PURGE } from 'redux-persist';\n\nconst purgeMiddleware = (persistor) =&gt; (store) =&gt; (next) =&gt; (action) =&gt; {\n    if (action.type === 'LOGOUT' || action.type === 'DELETE_ACCOUNT') {\n        persistor.purge();\n    }\n    return next(action);\n};\n\nexport default purgeMiddleware;\n</code></pre> <p>Next, import this middleware into your <code>store.js</code> file and apply it.</p> <pre><code>import { configureStore } from \"@reduxjs/toolkit\";\nimport { persistStore } from \"redux-persist\";\nimport rootReducer from \"./rootReducer\";\nimport loggerMiddleware from \"../middleware/loggerMiddleware\";\nimport purgeMiddleware from \"../middleware/purgeMiddleware\"; // Import the purge middleware\n\nexport const store = configureStore({\n    reducer: rootReducer,\n    middleware: (getDefaultMiddleware) =&gt;\n        getDefaultMiddleware().concat(loggerMiddleware, purgeMiddleware(persistor)), // Add purge middleware\n});\n\n// Create the persistor to manage state persistence\nexport const persistor = persistStore(store);\n</code></pre> <p>If you want to keep track of specific actions for purging, you could also define action types in a separate file to manage them more easily:</p> actionTypes.js<pre><code>export const LOGOUT = 'LOGOUT';\nexport const DELETE_ACCOUNT = 'DELETE_ACCOUNT';\n</code></pre> <p>Then use these action types in your <code>purgeMiddleware.js</code>:</p> <pre><code>import { LOGOUT, DELETE_ACCOUNT } from './actionTypes';\n\nconst purgeMiddleware = (persistor) =&gt; (store) =&gt; (next) =&gt; (action) =&gt; {\n    if (action.type === LOGOUT || action.type === DELETE_ACCOUNT) {\n        persistor.purge();\n    }\n    return next(action);\n};\n</code></pre> <p>Conclusion</p> <p>By creating a separate file for your purge middleware, you maintain a clean structure in your Redux setup. This makes it easier to manage and update the purging logic independently from the rest of your store configuration. This modular approach enhances readability and maintainability in larger applications.</p>"},{"location":"frontend/state-management/redux/persist/redux-persist-purge/#redux-toolkit","title":"Redux Toolkit","text":"1. Define Your Action in the Slice2. Update <code>purgeMiddleware.js</code>3. Use Middleware in the Store <p>First, ensure that your <code>logout</code> action is defined in your Redux slice:</p> <pre><code>// exampleSlice.js\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst exampleSlice = createSlice({\n    name: 'example',\n    initialState: { user: null },\n    reducers: {\n        login: (state, action) =&gt; {\n        state.user = action.payload;\n        },\n        logout: (state) =&gt; {\n        state.user = null; // Clear user state\n        },\n    },\n});\n\n// Export actions\nexport const { login, logout } = exampleSlice.actions;\n\n// Export reducer\nexport default exampleSlice.reducer;\n</code></pre> <p>Now, you can use the <code>logout</code> action in your middleware. Import the <code>logout</code> action and check for it in your middleware.</p> <pre><code>import { logout } from './exampleSlice'; // Adjust the import based on your file structure\n\nconst purgeMiddleware = (persistor) =&gt; (store) =&gt; (next) =&gt; (action) =&gt; {\n    // Check if the action is the logout action\n    if (action.type === logout.type) {\n        persistor.purge();\n    }\n    return next(action);\n};\n\nexport default purgeMiddleware;\n</code></pre> <p>Make sure to include the <code>purgeMiddleware</code> in your store setup:</p> <pre><code>import { configureStore } from \"@reduxjs/toolkit\";\nimport { persistStore } from \"redux-persist\";\nimport rootReducer from \"./rootReducer\";\nimport loggerMiddleware from \"../middleware/loggerMiddleware\";\nimport purgeMiddleware from \"../middleware/purgeMiddleware\"; // Import the purge middleware\n\nexport const store = configureStore({\n    reducer: rootReducer,\n    middleware: (getDefaultMiddleware) =&gt;\n        getDefaultMiddleware().concat(loggerMiddleware, purgeMiddleware(persistor)), // Add purge middleware\n});\n\n// Create the persistor to manage state persistence\nexport const persistor = persistStore(store);\n</code></pre> <p>Conclusion</p> <p>With this setup, your <code>purgeMiddleware</code> will automatically call <code>persistor.purge()</code> when the <code>logout</code> action is dispatched. This effectively clears the persisted state when the user logs out, maintaining the integrity of your application\u2019s state. You can extend this logic to handle other actions as needed by simply adding more checks within the middleware.</p>"},{"location":"frontend/state-management/redux/persist/redux-persist/","title":"Intro","text":""},{"location":"frontend/state-management/redux/persist/redux-persist/#overview","title":"Overview","text":"<p>Setting up Redux with Redux Persist involves several steps, and understanding the workflow will help you see how the pieces fit together. Here\u2019s a detailed workflow, including setup and how it works.</p>"},{"location":"frontend/state-management/redux/persist/redux-persist/#workflow-overview","title":"Workflow Overview","text":"<ol> <li>Install Dependencies</li> <li>Set Up Redux Slices</li> <li>Create Persist Configuration</li> <li>Combine Reducers and Create Store</li> <li>Wrap Application with PersistGate</li> <li>Using Redux State in Components</li> </ol>"},{"location":"frontend/state-management/redux/persist/redux-persist/#additional","title":"Additional","text":"Step 1:Step 2:Step 3:Step 4:Step 5:Step 6: <p>Install Dependencies</p> <p>First, ensure you have the necessary libraries installed:</p> <pre><code>npm install @reduxjs/toolkit react-redux redux-persist\n</code></pre> <p>Set Up Redux Slices</p> <p>Create slices using Redux Toolkit for managing state. For example, here\u2019s a simple sidebar slice:</p> <pre><code>// src/redux/features/sidebar/slice.js\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst sidebarSlice = createSlice({\n    name: 'sidebar',\n    initialState: { collapsed: false },\n    reducers: {\n        toggleSidebar: (state) =&gt; {\n            state.collapsed = !state.collapsed;\n        },\n        setSidebar: (state, action) =&gt; {\n            state.collapsed = action.payload;\n        },\n    },\n});\n\nexport const { toggleSidebar, setSidebar } = sidebarSlice.actions;\nexport default sidebarSlice.reducer;\n</code></pre> <p>Create Persist Configuration</p> <p>Create a separate file for your persist configuration:</p> <pre><code>// src/redux/store/persistConfig.js\nimport storage from 'redux-persist/lib/storage'; // defaults to localStorage\nimport { persistReducer } from 'redux-persist';\n\nconst persistConfig = {\n    key: 'root',\n    storage,\n};\n\nexport const createPersistedReducer = (rootReducer) =&gt; {\n    return persistReducer(persistConfig, rootReducer);\n};\n</code></pre> <p>Combine Reducers and Create Store</p> <p>Combine your reducers and create the Redux store with persistence:</p> <pre><code>// src/redux/store/rootReducer.js\nimport { combineReducers } from '@reduxjs/toolkit';\nimport sidebarReducer from '../features/sidebar/slice';\nimport { createPersistedReducer } from './persistConfig'; // Import persist function\n\nconst rootReducer = combineReducers({\n    sidebar: sidebarReducer,\n    // Add other reducers here\n});\n\nconst persistedReducer = createPersistedReducer(rootReducer);\nexport default persistedReducer;\n</code></pre> <pre><code>// src/redux/store/store.js\nimport { configureStore } from '@reduxjs/toolkit';\nimport rootReducer from './rootReducer';\nimport { persistStore } from 'redux-persist';\n\nexport const store = configureStore({\n    reducer: rootReducer,\n    // Add other middleware if needed\n});\n\nexport const persistor = persistStore(store);\n</code></pre> <p>Wrap Application with PersistGate</p> <p>In your main entry file (usually <code>index.js</code>), wrap your application with <code>PersistGate</code> to delay rendering until the persisted state is retrieved.</p> <pre><code>// src/index.js\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport { Provider } from 'react-redux';\nimport { PersistGate } from 'redux-persist/integration/react';\nimport { store, persistor } from './redux/store/store';\nimport App from './App';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n    &lt;React.StrictMode&gt;\n        &lt;Provider store={store}&gt;\n            &lt;PersistGate loading={null} persistor={persistor}&gt;\n                &lt;App /&gt;\n            &lt;/PersistGate&gt;\n        &lt;/Provider&gt;\n    &lt;/React.StrictMode&gt;\n);\n</code></pre> <p>Using Redux State in Components</p> <p>Now you can use Redux state in your components. Here\u2019s an example of how to use the sidebar state:</p> <pre><code>// src/components/Sidebar.js\nimport React from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { toggleSidebar } from '../redux/features/sidebar/slice';\n\nconst Sidebar = () =&gt; {\n    const dispatch = useDispatch();\n    const collapsed = useSelector((state) =&gt; state.sidebar.collapsed);\n\n    return (\n        &lt;div style={{ width: collapsed ? '80px' : '200px' }}&gt;\n            &lt;button onClick={() =&gt; dispatch(toggleSidebar())}&gt;\n                {collapsed ? 'Expand' : 'Collapse'}\n            &lt;/button&gt;\n\n            {/* Sidebar content */}\n        &lt;/div&gt;\n    );\n};\n\nexport default Sidebar;\n</code></pre> <p>How It Works</p> <ol> <li> <p>Initial State: When the app first loads, the Redux store is created with the initial state from your reducers.</p> </li> <li> <p>Persist State: Redux Persist checks local storage (or your configured storage) for any previously saved state. If it finds any, it rehydrates the store with that state.</p> </li> <li> <p>State Updates: When you dispatch actions (like toggling the sidebar), the state in the Redux store is updated.</p> </li> <li> <p>Persisting State: Redux Persist automatically saves the state to storage whenever it changes, so your application can restore that state on the next load.</p> </li> <li> <p>UI Update: The components that are connected to the Redux store will re-render based on the updated state.</p> </li> </ol> <p>Conclusion</p> <p>By following these steps, you can set up Redux with persistence in your React application using Redux Toolkit and Redux Persist. This workflow helps maintain application state across reloads, improving user experience and state management.</p>"},{"location":"frontend/state-management/redux/persist/redux-persist/#blacklist-and-whitelist","title":"BlackList and WhiteList","text":"<p>To persist only certain parts of your Redux state using Redux Persist, you can use the <code>whitelist</code> and <code>blacklist</code> options in your persist configuration. This allows you to specify which slices of the state you want to persist or exclude.</p> <p>Whitelist and Blacklist</p> <ul> <li>Whitelist: An array of reducers that you want to persist. Only these reducers will be saved to storage.</li> <li>Blacklist: An array of reducers that you want to exclude from persistence. All other reducers will be persisted.</li> </ul>"},{"location":"frontend/state-management/redux/persist/redux-persist/#example-configuring-whitelist-and-blacklist","title":"Example: Configuring Whitelist and Blacklist","text":"<p>Here\u2019s how you can modify your <code>persistConfig</code> to include only specific slices of your state.</p> <ol> <li> <p>Using Whitelist:</p> <p>If you want to persist only specific reducers, you can set up your <code>persistConfig</code> like this:</p> <pre><code>// src/redux/store/persistConfig.js\nimport storage from \"redux-persist/lib/storage\";\nimport { persistReducer } from \"redux-persist\";\n\nconst persistConfig = {\n  key: \"root\",\n  storage,\n  whitelist: [\"sidebar\"], // Only persist the sidebar slice\n};\n\nexport const createPersistedReducer = (rootReducer) =&gt; {\n  return persistReducer(persistConfig, rootReducer);\n};\n</code></pre> </li> <li> <p>Using Blacklist:</p> <p>If you want to persist everything except certain reducers, use the blacklist:</p> <pre><code>// src/redux/store/persistConfig.js\nimport storage from \"redux-persist/lib/storage\";\nimport { persistReducer } from \"redux-persist\";\n\nconst persistConfig = {\n  key: \"root\",\n  storage,\n  blacklist: [\"someNonPersistedSlice\"], // Do not persist this slice\n};\n\nexport const createPersistedReducer = (rootReducer) =&gt; {\n  return persistReducer(persistConfig, rootReducer);\n};\n</code></pre> </li> </ol> <p>Best Practices</p> <ol> <li> <p>Decide What to Persist: Determine which slices of state are critical to persist. This is often user preferences, authentication tokens, or UI state (like whether a sidebar is collapsed).</p> </li> <li> <p>Use Whitelist: If you have a small number of reducers you want to persist, use the <code>whitelist</code> approach. It makes it clear what is being persisted.</p> </li> <li> <p>Use Blacklist: If you have a large number of reducers and want to exclude just a few, use <code>blacklist</code>. This keeps your configuration concise.</p> </li> <li> <p>Consider Size and Performance: Persisting large amounts of state can affect performance. Keep the persisted data minimal and relevant.</p> </li> <li> <p>Clear Old Data: Occasionally clear or reset persisted state if certain conditions are met (like user logout).</p> </li> </ol> <p>Example with Whitelist</p> <p>Here\u2019s a complete example to show how you might set up your <code>persistConfig.js</code>:</p> <pre><code>// src/redux/store/persistConfig.js\nimport storage from \"redux-persist/lib/storage\";\nimport { persistReducer } from \"redux-persist\";\n\nconst persistConfig = {\n  key: \"root\",\n  storage,\n  whitelist: [\"sidebar\", \"user\"], // Persist only sidebar and user slices\n  // blacklist: ['someNonPersistedSlice'], // Alternatively, you could use blacklist\n};\n\nexport const createPersistedReducer = (rootReducer) =&gt; {\n  return persistReducer(persistConfig, rootReducer);\n};\n</code></pre> <p>Conclusion</p> <p>Using <code>whitelist</code> and <code>blacklist</code> provides flexibility in controlling which parts of your Redux state are persisted. By following best practices, you can ensure that only relevant data is stored, improving performance and maintaining a clean state management architecture.</p>"},{"location":"frontend/state-management/redux/persist/redux-store-subscribe/","title":"Subscribe","text":""},{"location":"frontend/state-management/redux/persist/redux-store-subscribe/#overview","title":"Overview","text":"<p>In Redux, <code>store.subscribe</code> is a method that allows you to listen for changes in the Redux store. When the state in the store changes, any function you've subscribed will be called. This is a core part of how Redux works, enabling components or other parts of your application to react to state changes.</p>"},{"location":"frontend/state-management/redux/persist/redux-store-subscribe/#usage-in-standard-redux-and-redux-toolkit","title":"Usage in Standard Redux and Redux Toolkit","text":"<p>Both standard Redux and Redux Toolkit (RTK) use <code>store.subscribe</code>. However, in RTK, you often interact with the store in a more abstracted way, utilizing hooks like <code>useSelector</code> and <code>useDispatch</code> that handle subscriptions under the hood.</p>"},{"location":"frontend/state-management/redux/persist/redux-store-subscribe/#when-to-use-storesubscribe","title":"When to Use <code>store.subscribe</code>","text":"<p>You generally use <code>store.subscribe</code> in the following scenarios:</p> <ol> <li> <p>Non-React Applications: In non-React apps or plain JavaScript, you might directly use store.subscribe to listen for state changes.</p> </li> <li> <p>Advanced Cases: If you need to perform side effects when the state changes, such as logging or syncing with an external API.</p> </li> <li> <p>Custom Subscriptions: For situations where you want to trigger an update or calculation based on specific state changes that aren't easily handled through React components.</p> </li> </ol>"},{"location":"frontend/state-management/redux/persist/redux-store-subscribe/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Unsubscribe: Always return a cleanup function from your subscription to avoid memory leaks. If your subscription is tied to a component's lifecycle, use it inside <code>useEffect</code> in React.</p> </li> <li> <p>Keep It Simple: Use <code>store.subscribe</code> only when necessary. In React applications, using hooks like <code>useSelector</code> is often more straightforward and leads to better-optimized re-renders.</p> </li> <li> <p>Limit Logic in Subscribers: Keep the logic within the subscription simple to avoid performance issues.</p> </li> </ol>"},{"location":"frontend/state-management/redux/persist/redux-store-subscribe/#real-example","title":"Real Example","text":"Standard ReduxRedux Toolkit Example <pre><code>import { createStore } from 'redux';\n\n// Reducer\nconst counter = (state = { count: 0 }, action) =&gt; {\n  switch (action.type) {\n    case 'INCREMENT':\n      return { count: state.count + 1 };\n    default:\n      return state;\n  }\n};\n\n// Create store\nconst store = createStore(counter);\n\n// Subscribe to store updates\nconst unsubscribe = store.subscribe(() =&gt; {\n  console.log('State changed:', store.getState());\n});\n\n// Dispatch actions\nstore.dispatch({ type: 'INCREMENT' });\nstore.dispatch({ type: 'INCREMENT' });\n\n// Unsubscribe when no longer needed\nunsubscribe();\n</code></pre> <p>In a React component using Redux Toolkit:</p> <pre><code>import React, { useEffect } from 'react';\nimport { configureStore, createSlice } from '@reduxjs/toolkit';\n\n// Create a slice\nconst counterSlice = createSlice({\n  name: 'counter',\n  initialState: { count: 0 },\n  reducers: {\n    increment: (state) =&gt; {\n      state.count += 1;\n    },\n  },\n});\n\nconst store = configureStore({ reducer: counterSlice.reducer });\n\n// React component\nconst Counter = () =&gt; {\n  useEffect(() =&gt; {\n    const unsubscribe = store.subscribe(() =&gt; {\n      console.log('State changed:', store.getState());\n    });\n    return () =&gt; unsubscribe(); // Cleanup on unmount\n  }, []);\n\n  const increment = () =&gt; {\n    store.dispatch(counterSlice.actions.increment());\n  };\n\n  return &lt;button onClick={increment}&gt;Increment&lt;/button&gt;;\n};\n\nexport default Counter;\n</code></pre>"},{"location":"frontend/state-management/redux/persist/redux-store-subscribe/#summary","title":"Summary","text":"<ul> <li><code>store.subscribe</code> is useful for listening to state changes in both standard Redux and Redux Toolkit.</li> <li>Prefer using hooks in React for easier management.</li> <li>Always manage subscriptions properly to avoid leaks and performance issues.</li> </ul>"},{"location":"frontend/state-management/redux/persist/redux-store-subscribe/#implementation","title":"Implementation","text":"<p>You can use <code>store.subscribe</code> in both standard Redux and Redux Toolkit. However, in most cases with Redux Toolkit, you may not need to use it directly because of the built-in features and patterns that Redux Toolkit provides, such as slices and thunks.</p>"},{"location":"frontend/state-management/redux/persist/redux-store-subscribe/#when-you-might-use-storesubscribe-in-redux-toolkit","title":"When You Might Use <code>store.subscribe</code> in Redux Toolkit","text":"<ol> <li> <p>Side Effects: If you have specific side effects that need to occur in response to state changes and are not covered by the existing middleware or thunk patterns, <code>store.subscribe</code> can be useful.</p> </li> <li> <p>External Libraries: If you need to update external libraries or components that aren't directly connected to your Redux store, subscribing to state changes can help.</p> </li> <li> <p>Debugging: It can still be useful for logging state changes during development or debugging.</p> </li> </ol>"},{"location":"frontend/state-management/redux/persist/redux-store-subscribe/#example-in-redux-toolkit","title":"Example in Redux Toolkit","text":"<p>Here's a simple example of using <code>store.subscribe</code> in a Redux Toolkit setup:</p> store.js<pre><code>import { configureStore } from \"@reduxjs/toolkit\";\nimport rootReducer from \"./rootReducer\";\n\nconst store = configureStore({\n  reducer: rootReducer,\n});\n\n// Subscribe to store updates\nconst unsubscribe = store.subscribe(() =&gt; {\n  console.log(\"State updated:\", store.getState());\n});\n\n// Dispatch actions\nstore.dispatch({ type: \"SOME_ACTION\" });\n\n// Unsubscribe when needed\n// unsubscribe();\n</code></pre>"},{"location":"frontend/state-management/redux/persist/redux-store-subscribe/#conclusion","title":"Conclusion","text":"<p>While you can use <code>store.subscribe</code> with Redux Toolkit, it's often not necessary due to the framework's design that encourages using thunks and slices for handling side effects and state management. If your use case requires direct subscriptions, it's perfectly fine to use it as needed. Just remember to manage performance and memory properly.</p>"},{"location":"frontend/state-management/redux/persist/reduxtoolkit-and-rtkquery/","title":"rtkquery","text":"<ul> <li>How to Use Redux Persist in React Applications</li> </ul>"},{"location":"frontend/state-management/redux/persist/reduxtoolkit-and-rtkquery/#overview","title":"Overview","text":"<p>is the redux tookit and rtk query is different or same</p> <p>Redux Toolkit and RTK Query are related but serve different purposes within the Redux ecosystem.</p>"},{"location":"frontend/state-management/redux/persist/reduxtoolkit-and-rtkquery/#redux-toolkit-rtk","title":"Redux Toolkit (RTK)","text":"<ul> <li>Purpose: It is the official, recommended way to write Redux logic. It simplifies store setup, reduces boilerplate, and provides a set of best practices.</li> <li>Features: Includes utilities like <code>createSlice</code>, <code>createAsyncThunk</code>, and built-in support for immutability with <code>Immer</code>.</li> </ul>"},{"location":"frontend/state-management/redux/persist/reduxtoolkit-and-rtkquery/#rtk-query","title":"RTK Query","text":"<ul> <li>Purpose: It is a powerful data fetching and caching library that is included with Redux Toolkit. It simplifies managing server-side data in your Redux store.</li> <li>Features: Provides tools for making API calls, caching responses, and automatically updating your store based on server responses.</li> </ul> <p>In summary, Redux Toolkit is the overall framework for Redux development, while RTK Query is a specific tool within it designed for handling asynchronous data fetching.</p>"},{"location":"frontend/state-management/redux/persist/reduxtoolkit-and-rtkquery/#using-both-together","title":"Using Both Together","text":"<p>can we mix both in same app or not</p> <p>Yes, you can definitely mix both Redux Toolkit and RTK Query in the same application! In fact, they are designed to work together seamlessly.</p> How to Use Them Together:Benefits of Mixing: <ul> <li>Set Up Redux Toolkit: Start by setting up your Redux store using Redux Toolkit, which can include slices and reducers as needed.</li> <li>Integrate RTK Query: Use RTK Query to manage API calls. You can define API slices using <code>createApi</code>, which allows you to fetch, cache, and manage server data effectively.</li> </ul> <ul> <li>Simplified State Management: Use Redux Toolkit for general state management and RTK Query for server-side data, leading to cleaner and more maintainable code.</li> <li>Optimized Performance: RTK Query handles caching and updates, reducing the need for manual state management and ensuring your UI stays in sync with your data.</li> </ul> <p>Overall, using both together can lead to a more efficient and organized application structure.</p> <p></p>"},{"location":"frontend/state-management/redux/persist/reduxtoolkit-and-rtkquery/#example-1-using-redux-toolkit-with-rtk-quer","title":"Example 1: Using Redux Toolkit with RTK Quer","text":"store.jsapiSlice.jsPosts.js <p>Setting Up the Redux Store</p> <pre><code>// store.js\nimport { configureStore } from '@reduxjs/toolkit';\nimport { apiSlice } from './apiSlice'; // Import the RTK Query API slice\nimport counterReducer from './counterSlice'; // Import a regular slice\n\nconst store = configureStore({\nreducer: {\n    [apiSlice.reducerPath]: apiSlice.reducer, // Add the RTK Query reducer\n    counter: counterReducer,\n},\nmiddleware: (getDefaultMiddleware) =&gt;\n    getDefaultMiddleware().concat(apiSlice.middleware), // Add the RTK Query middleware\n});\n\nexport default store;\n</code></pre> <p>Creating an RTK Query API Slice</p> <pre><code>// apiSlice.js\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';\n\nexport const apiSlice = createApi({\n    reducerPath: 'api',\n    baseQuery: fetchBaseQuery({ baseUrl: '/api' }), // Replace with your API URL\n    endpoints: (builder) =&gt; ({\n        getPosts: builder.query({\n        query: () =&gt; 'posts', // Endpoint for fetching posts\n        }),\n    }),\n});\n\nexport const { useGetPostsQuery } = apiSlice; // Export the hook for using the query\n</code></pre> <p>Using the RTK Query in a Component</p> <pre><code>// Posts.js\nimport React from 'react';\nimport { useGetPostsQuery } from './apiSlice';\n\nconst Posts = () =&gt; {\n    const { data: posts, error, isLoading } = useGetPostsQuery();\n\n    if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;\n\n    return (\n        &lt;ul&gt;\n            {posts.map(post =&gt; (\n                &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;\n            ))}\n        &lt;/ul&gt;\n    );\n};\n\nexport default Posts;\n</code></pre>"},{"location":"frontend/state-management/redux/persist/reduxtoolkit-and-rtkquery/#example-2-using-redux-toolkit-without-rtk-query","title":"Example 2: Using Redux Toolkit Without RTK Query","text":"store.jscounterSlice.jsCounter.js <p>Setting Up the Redux Store</p> <pre><code>// store.js\nimport { configureStore } from '@reduxjs/toolkit';\nimport counterReducer from './counterSlice';\n\nconst store = configureStore({\n    reducer: {\n        counter: counterReducer,\n    },\n});\n\nexport default store;\n</code></pre> <p>Creating a Regular Slice</p> <pre><code>// counterSlice.js\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst counterSlice = createSlice({\n    name: 'counter',\n    initialState: 0,\n    reducers: {\n        increment: (state) =&gt; state + 1,\n        decrement: (state) =&gt; state - 1,\n    },\n});\n\nexport const { increment, decrement } = counterSlice.actions;\nexport default counterSlice.reducer;\n</code></pre> <p>Using the Redux State in a Component</p> <pre><code>// Counter.js\nimport React from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { increment, decrement } from './counterSlice';\n\nconst Counter = () =&gt; {\n    const count = useSelector((state) =&gt; state.counter);\n    const dispatch = useDispatch();\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;{count}&lt;/h1&gt;\n            &lt;button onClick={() =&gt; dispatch(increment())}&gt;Increment&lt;/button&gt;\n            &lt;button onClick={() =&gt; dispatch(decrement())}&gt;Decrement&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Counter;\n</code></pre> <p>Summary</p> <ul> <li>The first example shows how to use both Redux Toolkit and RTK Query together to fetch and manage data from an API.</li> <li>The second example demonstrates how to use just Redux Toolkit for local state management without any asynchronous data fetching.</li> </ul>"},{"location":"frontend/state-management/redux/persist/reduxtoolkit-and-rtkquery/#question-1","title":"Question 1:","text":"<p>Can we use RTK Query with traditional Redux (without Redux Toolkit)?</p> <p>Answer:</p> <p>No, RTK Query is specifically designed to work with Redux Toolkit and relies on its APIs and features. It cannot be directly integrated into a traditional Redux setup without the Redux Toolkit.</p> <p>Explanation:</p> <ul> <li>RTK Query is part of Redux Toolkit and uses its constructs, like <code>createSlice</code> and middleware, to manage API calls, caching, and updates to the Redux store.</li> <li>If you're using traditional Redux (without Redux Toolkit), you would need to implement your own data fetching and state management logic, typically involving more boilerplate code.</li> </ul> <p>Alternative for Traditional Redux:</p> <p>If you're using traditional Redux and want to handle API calls, you might consider using libraries like:</p> <ul> <li>redux-thunk: For handling asynchronous logic in your action creators.</li> <li>redux-saga: For more complex side effects and asynchronous workflows.</li> </ul> <p>These alternatives can help manage API interactions, but they won't offer the same level of integration and simplicity that RTK Query provides within the Redux Toolkit.</p>"},{"location":"frontend/state-management/redux/persist/reduxtoolkit-and-rtkquery/#question-2","title":"Question 2:","text":"<p>How do we persist data in Redux Toolkit and RTK Query? Is the approach the same or different?</p> <p>Answer:</p> <p>The approaches to persisting data in Redux Toolkit and RTK Query are different, primarily due to their distinct purposes and functionalities.</p> <p>Explanation:</p> Persisting Data in Redux Toolkit:Persisting Data in RTK Query: <ol> <li> <p>Manual Persistence: You can manually persist your Redux state using libraries like redux-persist. This allows you to store part of your Redux state in local storage or other storage mechanisms.</p> <ul> <li>Setup: Integrate redux-persist with your Redux store.</li> <li>Configuration: Define which slices of state you want to persist.</li> </ul> <pre><code>import { persistStore, persistReducer } from 'redux-persist';\nimport storage from 'redux-persist/lib/storage'; // defaults to localStorage\nimport { configureStore } from '@reduxjs/toolkit';\nimport rootReducer from './rootReducer';\n\nconst persistConfig = {\n    key: 'root',\n    storage,\n};\n\nconst persistedReducer = persistReducer(persistConfig, rootReducer);\n\nconst store = configureStore({\n    reducer: persistedReducer,\n});\n\nexport const persistor = persistStore(store);\n</code></pre> </li> <li> <p>State Management: You manage the persisted state using Redux Toolkit slices and reducers.</p> </li> </ol> <ol> <li> <p>Automatic Caching: RTK Query automatically caches API responses in the Redux store. You can configure how long data should remain in the cache.</p> <ul> <li>Configuration: You can use <code>keepUnusedDataFor</code> and other cache-related settings in your API slice.</li> </ul> <pre><code>import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';\n\nexport const apiSlice = createApi({\n    reducerPath: 'api',\n    baseQuery: fetchBaseQuery({ baseUrl: '/api' }),\n    endpoints: (builder) =&gt; ({\n        getPosts: builder.query({\n        query: () =&gt; 'posts',\n            keepUnusedDataFor: 60, // Cache for 60 seconds\n        }),\n    }),\n});\n</code></pre> </li> <li> <p>No Manual Persistence: Unlike Redux Toolkit, RTK Query doesn't require additional libraries for persistence, as it handles caching internally.</p> </li> </ol> <p>Summary:</p> <ul> <li>Redux Toolkit: You typically use a library like redux-persist to persist your state manually.</li> <li>RTK Query: It handles caching and persistence of API data automatically, but it doesn't persist data across sessions without additional setup.</li> </ul> <p>Thus, while both can handle data persistence, the methods and complexities involved are different.</p>"},{"location":"frontend/state-management/redux/persist/reduxtoolkit-and-rtkquery/#clear-persist","title":"Clear Persist","text":"<p>Is it standard practice to clear Redux Persist data on user logout?</p> <p>The standard practice is indeed to clear the persisted state when a user logs out. This ensures that sensitive user data is not retained and prevents unauthorized access if a different user logs in afterward.</p> <p>To do this, you can use Redux Persist's <code>purge</code> method to clear the stored state in local storage or wherever it's persisted. This can be done in your logout action or in a middleware that listens for logout events.</p> <p>Overall, clearing the persisted state on logout is a good security measure and helps maintain a clean application state.</p>"},{"location":"frontend/state-management/redux/persist/reduxtoolkit-and-rtkquery/#reference","title":"Reference","text":"<ul> <li>Persistence and Rehydration</li> <li>How to configure redux-persist with redux-toolkit?</li> <li>Setting up Redux Tool Kit (RTK), Redux and Redux-Persist for React.</li> <li>Persisting State in Your React App with Redux-Persist</li> <li>How to Use Redux Persist in React Applications</li> <li>React: API Response Validation</li> <li>The Most Powerful Tool for Redux Management \u2014 @reduxjs/toolkit!</li> </ul>"},{"location":"frontend/state-management/redux/rtk/core-vs-query/","title":"Core vs Query","text":""},{"location":"frontend/state-management/redux/rtk/core-vs-query/#overview","title":"Overview","text":"<p>RTK Core and RTK Query are related but they refer to different aspects of Redux Toolkit (RTK).</p>"},{"location":"frontend/state-management/redux/rtk/core-vs-query/#1-rtk-core","title":"1. RTK Core","text":"<p>RTK Core refers to the central part of Redux Toolkit (RTK), which is the official toolset for efficient Redux development. RTK Core includes the main utilities to work with Redux, such as:</p> <ul> <li><code>configureStore</code>: A helper function to set up a Redux store.</li> <li><code>createSlice</code>: A function to simplify the creation of Redux reducers and actions.</li> <li><code>createAsyncThunk</code>: A function for handling async logic and dispatching actions based on async outcomes.</li> <li><code>createReducer</code>: A utility for handling reducers in a more declarative way.</li> <li><code>createAction</code>: A utility to define Redux action creators.</li> </ul> <p>RTK Core provides foundational tools for managing global state in a Redux store.</p>"},{"location":"frontend/state-management/redux/rtk/core-vs-query/#2-rtk-query","title":"2. RTK Query","text":"<p>RTK Query is a set of tools and utilities built on top of Redux Toolkit to simplify data fetching and caching. It is an advanced feature of RTK that aims to reduce the need for boilerplate code when working with APIs. RTK Query provides tools for:</p> <ul> <li>Fetching data from APIs (via <code>createApi</code>).</li> <li>Caching and automatic re-fetching (with built-in cache management and re-fetching policies).</li> <li>Managing loading, success, and error states.</li> <li>Optimizing performance by avoiding unnecessary requests (through caching).</li> <li>Automatic Redux slice generation for API calls.</li> </ul> <p>RTK Query integrates deeply with Redux Toolkit, providing a more structured and efficient way to handle API interactions compared to traditional approaches in Redux.</p>"},{"location":"frontend/state-management/redux/rtk/core-vs-query/#key-differences","title":"Key Differences:","text":"<ul> <li>RTK Core is the main library for setting up and managing the Redux store, reducers, actions, and state logic.</li> <li>RTK Query is an add-on (a part of RTK) specifically for handling server-side data fetching and caching, reducing the complexity of managing API requests and responses.</li> </ul>"},{"location":"frontend/state-management/redux/rtk/core-vs-query/#in-short","title":"In short:","text":"<ul> <li>RTK Core is the foundational Redux Toolkit library.</li> <li>RTK Query is a specific extension for managing API requests, built on top of RTK Core.</li> </ul> <p>While both are part of the same Redux Toolkit ecosystem, RTK Query builds on RTK Core to handle a particular use case (data fetching and caching).</p> Tip <ul> <li>Use RTK Core if you\u2019re managing local state or custom logic that doesn\u2019t involve interacting with external APIs or server data.</li> <li>Use RTK Query if your app needs to interact with external APIs, manage complex server-side state, and benefit from features like caching, automatic refetching, and request deduplication.</li> </ul> <p>In most modern web applications that involve both local state and server-side data fetching, you'll likely end up using both RTK Core (for managing app state) and RTK Query (for handling API interactions) together.</p>"},{"location":"frontend/state-management/redux/rtk/intro/","title":"Intro","text":"<pre><code>npm install @reduxjs/toolkit react-redux\n</code></pre>"},{"location":"frontend/state-management/redux/rtk/intro/#authorization","title":"Authorization","text":"<p>Implementing login and authorization in a React application can be achieved through various libraries and techniques. Here's a step-by-step guide using common libraries like <code>redux</code>, <code>redux-toolkit</code>, <code>react-router</code>, and <code>jwt-decode</code>.</p>"},{"location":"frontend/state-management/redux/rtk/intro/#libraries-to-use","title":"Libraries to Use","text":"<ol> <li>React Router: For handling routing.</li> <li>Redux/Redux Toolkit: For state management.</li> <li>Axios: For making API requests.</li> <li>JWT-decode: For decoding JSON Web Tokens.</li> <li>React Hook Form: For handling form state.</li> </ol>"},{"location":"frontend/state-management/redux/rtk/intro/#step-by-step-implementation","title":"Step-by-Step Implementation","text":"InstallationStoreSliceComponentRouteRoutingSummary <ol> <li> <p>Setting Up Your Project</p> <p>Install the necessary packages:</p> <pre><code>npm install react-router-dom @reduxjs/toolkit react-redux axios jwt-decode react-hook-form\n</code></pre> </li> </ol> <ol> <li> <p>Configure Redux Store</p> <p>Set up a Redux store with slices for authentication.</p> <pre><code>// store.js\nimport { configureStore } from \"@reduxjs/toolkit\";\nimport authReducer from \"./features/auth/authSlice\";\n\nexport const store = configureStore({\n    reducer: {\n        auth: authReducer,\n    },\n});\n</code></pre> </li> </ol> <ol> <li> <p>Create Authentication Slice</p> <p>Create a slice for authentication state management.</p> <pre><code>// features/auth/authSlice.js\nimport { createSlice, createAsyncThunk } from \"@reduxjs/toolkit\";\nimport axios from \"axios\";\nimport jwt_decode from \"jwt-decode\";\n\nconst initialState = {\n    token: localStorage.getItem(\"token\") || null,\n    user: localStorage.getItem(\"token\")\n        ? jwt_decode(localStorage.getItem(\"token\"))\n        : null,\n    status: \"idle\",\n    error: null,\n};\n\nexport const login = createAsyncThunk(\"auth/login\", async (credentials) =&gt; {\n    const response = await axios.post(\"/api/auth/login\", credentials);\n    return response.data.token;\n});\n\nconst authSlice = createSlice({\n    name: \"auth\",\n    initialState,\n    reducers: {\n        logout: (state) =&gt; {\n            state.token = null;\n            state.user = null;\n            localStorage.removeItem(\"token\");\n        },\n    },\n    extraReducers: (builder) =&gt; {\n        builder\n        .addCase(login.pending, (state) =&gt; {\n            state.status = \"loading\";\n        })\n        .addCase(login.fulfilled, (state, action) =&gt; {\n            state.status = \"succeeded\";\n            state.token = action.payload;\n            state.user = jwt_decode(action.payload);\n            localStorage.setItem(\"token\", action.payload);\n        })\n        .addCase(login.rejected, (state, action) =&gt; {\n            state.status = \"failed\";\n            state.error = action.error.message;\n        });\n    },\n});\n\nexport const { logout } = authSlice.actions;\n\nexport default authSlice.reducer;\n</code></pre> </li> </ol> <ol> <li> <p>Create Login Component</p> <p>Create a component for the login form using react-hook-form.</p> <pre><code>// components/Login.js\nimport React from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { useForm } from \"react-hook-form\";\nimport { login } from \"../features/auth/authSlice\";\nimport { Redirect } from \"react-router-dom\";\n\nconst Login = () =&gt; {\n    const dispatch = useDispatch();\n    const { register, handleSubmit } = useForm();\n    const { token, error, status } = useSelector((state) =&gt; state.auth);\n\n    const onSubmit = (data) =&gt; {\n        dispatch(login(data));\n    };\n\n    if (token) {\n        return &lt;Redirect to=\"/\" /&gt;;\n    }\n\n    return (\n        &lt;div&gt;\n        &lt;h2&gt;Login&lt;/h2&gt;\n\n        &lt;form onSubmit={handleSubmit(onSubmit)}&gt;\n            &lt;div&gt;\n            &lt;label&gt;Email:&lt;/label&gt;\n            &lt;input type=\"email\" {...register(\"email\")} /&gt;\n            &lt;/div&gt;\n            &lt;div&gt;\n            &lt;label&gt;Password:&lt;/label&gt;\n            &lt;input type=\"password\" {...register(\"password\")} /&gt;\n            &lt;/div&gt;\n            &lt;button type=\"submit\"&gt;Login&lt;/button&gt;\n        &lt;/form&gt;\n\n        {status === \"loading\" &amp;&amp; &lt;p&gt;Loading...&lt;/p&gt;}\n        {error &amp;&amp; &lt;p&gt;{error}&lt;/p&gt;}\n        &lt;/div&gt;\n    );\n};\n\nexport default Login;\n</code></pre> </li> </ol> <ol> <li> <p>Protect Routes</p> <p>Create a higher-order component (HOC) to protect routes.</p> <pre><code>// components/PrivateRoute.js\nimport React from \"react\";\nimport { Route, Redirect } from \"react-router-dom\";\nimport { useSelector } from \"react-redux\";\n\nconst PrivateRoute = ({ component: Component, ...rest }) =&gt; {\n    const token = useSelector((state) =&gt; state.auth.token);\n\n    return (\n        &lt;Route\n            {...rest}\n            render={(props) =&gt;\n                token ? &lt;Component {...props} /&gt; : &lt;Redirect to=\"/login\" /&gt;\n            }\n        /&gt;\n    );\n};\n\nexport default PrivateRoute;\n</code></pre> </li> </ol> <ol> <li> <p>Set Up Routing</p> <p>Configure routing in your application using React Router.</p> <pre><code>// App.js\nimport React from \"react\";\nimport { BrowserRouter as Router, Route, Switch } from \"react-router-dom\";\nimport { Provider } from \"react-redux\";\nimport { store } from \"./store\";\nimport Login from \"./components/Login\";\nimport PrivateRoute from \"./components/PrivateRoute\";\nimport Home from \"./components/Home\";\n\nconst App = () =&gt; (\n    &lt;Provider store={store}&gt;\n        &lt;Router&gt;\n            &lt;Switch&gt;\n                &lt;Route path=\"/login\" component={Login} /&gt;\n                &lt;PrivateRoute path=\"/\" component={Home} /&gt;\n            &lt;/Switch&gt;\n        &lt;/Router&gt;\n    &lt;/Provider&gt;\n);\n\nexport default App;\n</code></pre> </li> </ol> <ol> <li>Setup Redux store: Configure the store with <code>redux-toolkit</code>.</li> <li>Create auth slice: Manage authentication state with a slice.</li> <li>Login component: Use <code>react-hook-form</code>for handling the login form.</li> <li>Protect routes: Use a higher-order component to protect routes.</li> <li>Configure routing: Set up routing with React Router.</li> </ol> <p>By using these tools and techniques, you can implement robust login and authorization mechanisms in your React application.</p>"},{"location":"frontend/state-management/redux/rtk/intro/#which-one-to-choose","title":"Which one to choose?","text":"<ul> <li>Standard Redux is still usable and maintained but involves more boilerplate and manual configuration.</li> <li>Redux Toolkit (RTK) is recommended for new projects as it simplifies Redux setup, encourages best practices, and provides tools to reduce boilerplate.</li> </ul> <p>If you are starting a new project or maintaining an existing one, it is highly advisable to use Redux Toolkit for a better development experience.</p>"},{"location":"frontend/state-management/redux/rtk/intro/#predefined-functions-in-redux-toolkit","title":"Predefined Functions in Redux Toolkit","text":"<p>Yes, the items I listed are predefined functions and utilities provided by Redux Toolkit. They are not classes in the traditional object-oriented sense but rather functions that help you implement Redux logic more easily and with less boilerplate code. Here\u2019s a quick recap:</p> <ol> <li><code>configureStore</code>: A function to create a Redux store with default middleware and settings.</li> <li><code>createSlice</code>: A utility that simplifies the process of writing reducers and actions in a single declaration.</li> <li><code>createAsyncThunk</code>: A function to handle asynchronous operations and automatically manage action dispatching for the lifecycle of a promise.</li> <li><code>createEntityAdapter</code>: A utility for managing collections of entities in a normalized format, providing methods for CRUD operations.</li> <li><code>createSelector</code>: A function to create memoized selectors for efficiently deriving and accessing state.</li> <li><code>createReducer</code>: A function to create reducers with a simpler syntax, allowing for mutative state updates.</li> <li><code>createAction</code>: A function to create action creators that return action objects.</li> </ol> <p>These functions are part of the Redux Toolkit library and are designed to enhance the Redux experience by reducing boilerplate, promoting best practices, and making it easier to manage state in applications.</p>"},{"location":"frontend/state-management/redux/rtk/query/anatomy-of-rtkquery/","title":"Anatomy of rtkQuery","text":"<p>fasdfsdf</p>"},{"location":"frontend/state-management/redux/rtk/query/anatomy-of-rtkquery/#onquerystarted","title":"onQueryStarted","text":"<p><code>onQueryStarted</code> is a lifecycle hook provided by RTK Query (part of Redux Toolkit) that allows you to run custom logic before or during the execution of a query or mutation. It's an advanced feature for cases when you need to interact with the Redux state or perform additional side effects as part of the API call process.</p> Key Points about <code>onQueryStarted</code> <ul> <li> <p>Purpose: <code>onQueryStarted</code> is primarily used to trigger side effects (like optimistic updates, cache manipulation, logging, etc.) at the start of an API call before the query or mutation actually completes.</p> </li> <li> <p>Context: It's available within both queries and mutations that are defined with the <code>createApi</code> function in RTK Query.</p> </li> <li> <p>Arguments: <code>onQueryStarted</code> receives the following arguments:</p> <ul> <li><code>arg</code>: The argument passed to the query or mutation.</li> <li><code>api</code>: The API slice instance.</li> <li><code>dispatch</code>: The Redux <code>dispatch</code> function, which allows you to dispatch actions to the Redux store.</li> <li><code>queryFulfilled</code>: A promise that resolves when the query or mutation is successfully completed. You can use this to await the successful completion or failure of the operation.</li> </ul> </li> </ul> Signature<pre><code>onQueryStarted: async (arg, { dispatch, queryFulfilled }) =&gt; {\n  // Your custom logic here\n};\n</code></pre> <p>Example 1: Optimistic Updates with <code>onQueryStarted</code></p> <p>In this example, we use <code>onQueryStarted</code> to optimistically update a post's title before the server responds to the mutation:</p> <pre><code>import { createApi, fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\n\nconst api = createApi({\n  reducerPath: \"api\",\n  baseQuery: fetchBaseQuery({ baseUrl: \"/api\" }),\n  endpoints: (builder) =&gt; ({\n    fetchPosts: builder.query({\n      query: () =&gt; \"posts\",\n    }),\n    updatePost: builder.mutation({\n      query: (post) =&gt; ({\n        url: `posts/${post.id}`,\n        method: \"PUT\",\n        body: post,\n      }),\n      // Using onQueryStarted for optimistic updates\n      onQueryStarted: async (arg, { dispatch, queryFulfilled }) =&gt; {\n        // Optimistic update\n        const patchResult = dispatch(\n          api.util.updateQueryData(\"fetchPosts\", undefined, (draft) =&gt; {\n            // Find the post to update optimistically\n            const postIndex = draft.findIndex((p) =&gt; p.id === arg.id);\n            if (postIndex !== -1) {\n              draft[postIndex] = { ...draft[postIndex], ...arg };\n            }\n          })\n        );\n\n        // Wait for the mutation to complete\n        try {\n          await queryFulfilled; // Wait for success\n        } catch (error) {\n          // Rollback the optimistic update if the mutation fails\n          patchResult.undo();\n        }\n      },\n    }),\n  }),\n});\n\nexport const { useFetchPostsQuery, useUpdatePostMutation } = api;\n</code></pre> <p>In this example:</p> <ul> <li>Optimistic update: We optimistically update the post in the local cache before the mutation is actually completed.</li> <li><code>patchResult.undo()</code>: If the mutation fails, we undo the optimistic update and revert the cache to its previous state.</li> </ul> Key Concepts: <ul> <li> <p><code>queryFulfilled</code>: This is a promise that resolves once the query or mutation completes successfully. It represents the final state of the query after it has been executed. If the query or mutation fails, it throws an error.</p> </li> <li> <p><code>dispatch</code>: You can dispatch Redux actions within <code>onQueryStarted</code>, enabling you to manipulate the state or trigger other actions (like optimistic updates or logging).</p> </li> <li> <p><code>undo()</code>: This function is used to revert any optimistic changes if the mutation fails.</p> </li> </ul>"},{"location":"frontend/state-management/redux/rtk/query/anatomy-of-rtkquery/#what-is-apiutilupdatequerydata-in-rtk-query","title":"What is <code>api.util.updateQueryData</code> in RTK Query?","text":"<p>Yes, <code>api.util.updateQueryData</code> is built-in to RTK Query. It\u2019s a utility function provided by RTK Query\u2019s api slice, and it allows you to optimistically update the cache for a specific query without having to wait for the network response.</p> Syntax of updateQueryData<pre><code>api.util.updateQueryData(queryName, arg, patch);\n</code></pre> <ul> <li><code>queryName</code>: The name of the query you're updating.</li> <li><code>arg</code>: The argument passed to the query when it was originally requested. In most cases, this will be undefined if the query doesn't take any arguments or a specific parameter to identify the cached data.</li> <li><code>patch</code>: A function that receives a draft of the cached data (via Immer). You modify this draft, and Immer takes care of applying those changes immutably.</li> </ul> When to Use undefined? <p>The second argument (<code>undefined</code> in your case) is used when the query doesn't require any parameters to fetch the data. If the query takes parameters (e.g., an ID or a search term), you would pass the argument that you used when the query was initially dispatched.</p> Without argumentsWith arguments <p>Without arguments (undefined)</p> <pre><code>api.util.updateQueryData(\"fetchPosts\", undefined, (draft) =&gt; {\n    // Modify the draft cache for fetchPosts (without arguments)\n    draft.push(newPost);\n});\n</code></pre> <p>With arguments (e.g., for updating a single post by ID):</p> <pre><code>api.util.updateQueryData(\"fetchPostById\", postId, (draft) =&gt; {\n    // Update the specific post with `postId`\n    const post = draft.find(p =&gt; p.id === postId);\n\n    if (post) {\n        post.content = updatedContent; // Modify the specific post\n    }\n});\n</code></pre>"},{"location":"frontend/state-management/redux/rtk/query/anatomy-of-rtkquery/#reference","title":"Reference","text":"<ul> <li> <p>A Beginner\u2019s Guide to Redux Toolkit Query/RTK Query</p> </li> <li> <p>optimistic-updates: official</p> </li> </ul>"},{"location":"frontend/state-management/redux/rtk/query/intro/","title":"Intro","text":""},{"location":"frontend/state-management/redux/rtk/query/intro/#query","title":"Query","text":"<p>RTK Query (Redux Toolkit Query) is a powerful data fetching and caching tool that is integrated into Redux Toolkit, simplifying the process of managing server-side data in your React applications. It's designed to eliminate the need for manually writing action creators, reducers, and thunks for common operations like fetching, caching, and synchronizing data.</p> <p>Here\u2019s a basic overview of how to use RTK Query in a React application:</p>"},{"location":"frontend/state-management/redux/rtk/query/intro/#1-install-redux-toolkit","title":"1. Install Redux Toolkit","text":"<p>If you haven't already, start by installing Redux Toolkit:</p> <pre><code>npm install @reduxjs/toolkit react-redux\n</code></pre>"},{"location":"frontend/state-management/redux/rtk/query/intro/#2-create-an-api-service","title":"2. Create an API Service","text":"<p>The first step is to define an API service using createApi from RTK Query. This service will describe how to interact with your backend.</p> ExampleExplanation <pre><code>// services/api.js\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';\n\n// Define your API service\nconst api = createApi({\n    reducerPath: 'api',  // unique name for the reducer\n    baseQuery: fetchBaseQuery({ baseUrl: 'https://api.example.com/' }),  // API base URL\n    endpoints: (builder) =&gt; ({\n        getPosts: builder.query({\n            query: () =&gt; 'posts',  // Fetches the 'posts' endpoint\n        }),\n        getPostById: builder.query({\n            query: (id) =&gt; `posts/${id}`,  // Fetches a single post by ID\n        }),\n    }),\n});\n\nexport const { useGetPostsQuery, useGetPostByIdQuery } = api; // Export the generated hooks\nexport default api;\n</code></pre> <p>In the example above:</p> <ul> <li><code>createApi</code> creates the service.</li> <li><code>fetchBaseQuery</code> is a utility function that simplifies the base API URL setup.</li> <li><code>endpoints</code> defines different API endpoints and their corresponding queries or mutations.</li> <li><code>useGetPostsQuery</code> and <code>useGetPostByIdQuery</code> are hooks automatically generated by RTK Query for fetching data.</li> </ul>"},{"location":"frontend/state-management/redux/rtk/query/intro/#3-set-up-the-redux-store","title":"3. Set Up the Redux Store","text":"<p>Next, integrate the API service into your Redux store.</p> <pre><code>// store.js\nimport { configureStore } from \"@reduxjs/toolkit\";\nimport api from \"./services/api\";\n\nconst store = configureStore({\n  reducer: {\n    [api.reducerPath]: api.reducer, // Add the API reducer to the store\n  },\n  middleware: (getDefaultMiddleware) =&gt;\n    getDefaultMiddleware().concat(api.middleware), // Add API middleware\n});\n\nexport default store;\n</code></pre>"},{"location":"frontend/state-management/redux/rtk/query/intro/#4-provide-the-redux-store-to-your-application","title":"4. Provide the Redux Store to Your Application","text":"<p>Make sure you wrap your root component with the <code>Provider</code> from react-redux and pass it the store.</p> <pre><code>// index.js or App.js\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { Provider } from \"react-redux\";\nimport store from \"./store\";\nimport App from \"./App\";\n\nReactDOM.render(\n  &lt;Provider store={store}&gt;\n    &lt;App /&gt;\n  &lt;/Provider&gt;,\n  document.getElementById(\"root\")\n);\n</code></pre>"},{"location":"frontend/state-management/redux/rtk/query/intro/#5-use-the-generated-hooks-in-your-components","title":"5. Use the Generated Hooks in Your Components","text":"<p>Finally, use the automatically generated hooks inside your React components to fetch data.</p> ExampleExplanation <pre><code>// PostsList.js\nimport React from 'react';\nimport { useGetPostsQuery } from './services/api';\n\nconst PostsList = () =&gt; {\n    const { data, error, isLoading } = useGetPostsQuery();\n\n    if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error loading posts: {error.message}&lt;/div&gt;;\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Posts&lt;/h1&gt;\n            &lt;ul&gt;\n                {data.map((post) =&gt; (\n                    &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default PostsList;\n</code></pre> <p>In this component:</p> <ul> <li><code>useGetPostsQuery</code> is the hook generated by RTK Query.</li> <li>The hook returns an object with <code>data</code>, <code>error</code>, and <code>isLoading</code> properties that help you manage loading and error states.</li> </ul>"},{"location":"frontend/state-management/redux/rtk/query/intro/#6-running-the-app","title":"6. Running the App","text":"<p>Once everything is set up, your app should now be able to fetch data from your API and display it in your components. RTK Query will automatically cache the data, and handle re-fetching as necessary when the data changes.</p>"},{"location":"frontend/state-management/redux/rtk/query/intro/#conclusion","title":"Conclusion","text":"<p>RTK Query simplifies API data fetching by providing:</p> <ul> <li>Automatic caching and synchronization</li> <li>Reduced boilerplate code</li> <li>Built-in error and loading state management</li> </ul> <p>This is just a basic overview, but RTK Query also supports mutations (for creating/updating data), pagination, optimistic updates, and more advanced features like custom queries or caching strategies. You can refer to the official documentation for more detailed information.</p>"},{"location":"frontend/state-management/redux/rtk/query/intro/#question","title":"Question","text":"<p>Where do the names like <code>useGetPostsQuery</code> and <code>useCreatePostMutation</code> come from, and is it possible to change them?</p> <p>The names like <code>useGetPostsQuery</code> and <code>useCreatePostMutation</code> are auto-generated based on the endpoint name and the type of request (GET, POST, PUT, DELETE, etc.) that you define in your API slice with RTK Query.</p> Naming Convention Breakdown <ol> <li> <p>Base Name:</p> <ul> <li>The first part of the name (e.g., <code>useGetPosts</code> or <code>useCreatePost</code>) corresponds to the name of the endpoint you define in your <code>createApi</code> service. This is the key part that defines the operation you're performing (GET, POST, etc.) and the resource you're interacting with.</li> </ul> </li> <li> <p>Operation Type:</p> <ul> <li>If the endpoint is a GET request, the generated hook will have a suffix of <code>Query</code> (e.g., <code>useGetPostsQuery</code>).</li> <li>If the endpoint is a POST, PUT, or PATCH request (i.e., mutations), the generated hook will have a suffix of <code>Mutation</code> (e.g., <code>useCreatePostMutation</code>).</li> </ul> </li> </ol> Example Example API ServiceHow the Names are Generated <p>Let's look at an example API service to understand how these names are generated.</p> <pre><code>// services/api.js\nimport { createApi, fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\n\nconst api = createApi({\n    reducerPath: \"api\",\n    baseQuery: fetchBaseQuery({\n        baseUrl: \"https://jsonplaceholder.typicode.com/\",\n    }),\n    endpoints: (builder) =&gt; ({\n        getPosts: builder.query({\n            query: () =&gt; \"posts\", // GET request endpoint\n        }),\n        createPost: builder.mutation({\n            query: (newPost) =&gt; ({\n                url: \"posts\",\n                method: \"POST\",\n                body: newPost,\n            }), // POST request endpoint\n        }),\n    }),\n});\n\nexport const { useGetPostsQuery, useCreatePostMutation } = api;\nexport default api;\n</code></pre> <p>In this case:</p> <ol> <li> <p><code>getPosts</code> is the endpoint name (a <code>query</code> for a GET request).</p> <ul> <li>The generated hook will be named useGetPostsQuery.</li> <li>The hook follows this pattern:     <code>use&lt;endpoint name&gt;Query</code></li> </ul> </li> <li> <p><code>createPost</code> is the endpoint name (a <code>mutation</code> for a POST request).</p> <ul> <li>The generated hook will be named useCreatePostMutation.</li> <li>The hook follows this pattern:     <code>use&lt;endpoint name&gt;Mutation</code></li> </ul> </li> </ol> <p>Can You Customize the Hook Names?</p> <p>By default, RTK Query uses this automatic naming convention, but you can customize the names if needed.</p> <ul> <li>You can change the name of the hook directly by renaming the function in the export.</li> </ul> Example ExampleExplanation <p>For example, if you want to change the names of the hooks to something more specific:</p> <pre><code>// services/api.js\nimport { createApi, fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\n\nconst api = createApi({\n    reducerPath: \"api\",\n    baseQuery: fetchBaseQuery({\n        baseUrl: \"https://jsonplaceholder.typicode.com/\",\n    }),\n    endpoints: (builder) =&gt; ({\n        getPosts: builder.query({\n            query: () =&gt; \"posts\",\n        }),\n        createPost: builder.mutation({\n            query: (newPost) =&gt; ({\n                url: \"posts\",\n                method: \"POST\",\n                body: newPost,\n            }),\n        }),\n    }),\n});\n\nexport const {\n    useGetPostsQuery: useFetchPosts,\n    useCreatePostMutation: useSubmitPost,\n} = api;\nexport default api;\n</code></pre> <p>In this example:</p> <ul> <li><code>useGetPostsQuery</code> is renamed to <code>useFetchPosts</code>.</li> <li><code>useCreatePostMutation</code> is renamed to <code>useSubmitPost</code>.</li> </ul> <p>You can name the hooks whatever you like, but it's recommended to follow a consistent naming pattern that reflects the action and type of the request for clarity and maintainability.</p> <p>Recap of Naming Pattern</p> <ul> <li><code>use&lt;endpoint name&gt;Query</code>: For GET requests (queries).</li> <li><code>use&lt;endpoint name&gt;Mutation</code>: For POST, PUT, PATCH, or DELETE requests (mutations).</li> </ul> <p>Example:</p> <p>Given these endpoints:</p> <pre><code>endpoints: (builder) =&gt; ({\n  getPosts: builder.query({ query: () =&gt; \"posts\" }),\n  createPost: builder.mutation({\n    query: (newPost) =&gt; ({ url: \"posts\", method: \"POST\", body: newPost }),\n  }),\n});\n</code></pre> <ul> <li>The GET request hook will be <code>useGetPostsQuery</code> by default (or any name you choose).</li> <li>The POST request hook will be <code>useCreatePostMutation</code> by default (or any name you choose).</li> </ul> <p>You can customize these names, but the default pattern helps maintain consistency in your codebase</p>"},{"location":"frontend/state-management/redux/rtk/query/mnemonic/","title":"Mnemonics","text":"<p>To remember how RTK Query (Redux Toolkit Query) works, you can use a mnemonic that focuses on the key concepts:</p>"},{"location":"frontend/state-management/redux/rtk/query/mnemonic/#mnemonic-create","title":"Mnemonic: \"C.R.E.A.T.E.\"","text":"<p>Each letter represents an essential part of RTK Query's functionality:</p> <ul> <li>C \u2013 Create API Service:</li> </ul> <p>The first step is to define your API service using <code>createApi()</code>. This is where you define the base URL, endpoints, and how to fetch data.</p> <ul> <li>R \u2013 Reducers Automatically Generated:</li> </ul> <p>RTK Query automatically generates reducers for the API service, handling the state (loading, success, error) of each query or mutation.</p> <ul> <li>E \u2013 Endpoints:</li> </ul> <p>Endpoints are key actions inside the API slice. These define the different operations like <code>GET</code>, <code>POST</code>, <code>PUT</code>, etc., that the API will perform. Each endpoint is a function, and it defines how to fetch or mutate data.</p> <ul> <li>A \u2013 Async Thunks:</li> </ul> <p>RTK Query generates async thunks for you automatically. These thunks handle dispatching actions, calling the API, and managing the loading, success, and error states.</p> <ul> <li>T \u2013 Transform Response:</li> </ul> <p>RTK Query allows you to transform the response data before it's added to the Redux store using <code>transformResponse</code>. This is useful for manipulating or formatting data as it comes from the server.</p> <ul> <li>E \u2013 ExtraReducers:</li> </ul> <p>You can add custom logic to handle API responses or integrate with other slices using <code>extraReducers</code>. This gives you flexibility beyond the auto-generated reducers.</p>"},{"location":"frontend/state-management/redux/rtk/query/mnemonic/#full-explanation","title":"Full Explanation:","text":"<ul> <li>Create an API service: Set up the API service using <code>createApi()</code>, which includes base URL and endpoints.</li> <li>Reducers for data management: Redux Toolkit will create reducers for you, managing loading, success, and error states.</li> <li>Endpoints: Define the API operations like GET, POST, etc., with specific parameters and transformations.</li> <li>Async thunks: Automatically generated thunks (async actions) that will make the API calls and update Redux state.</li> <li>Transform response: You can modify the server response before it's stored in Redux.</li> <li>Extra reducers: Add custom logic or additional handlers for specific actions beyond the defaults provided.</li> </ul> <p>By using \"C.R.E.A.T.E.\" as a mnemonic, you can easily remember the essential concepts when working with RTK Query.</p>"},{"location":"frontend/state-management/redux/rtk/query/mnemonic/#step-by-step-example-of-rtk-query","title":"Step-by-Step Example of RTK Query","text":"<p>1. Create an API Service</p> <p>First, we'll define the API service using <code>createApi</code> from Redux Toolkit.</p> <pre><code>// src/services/postsApi.js\nimport { createApi, fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\n\nexport const postsApi = createApi({\n  reducerPath: \"postsApi\", // Name of the slice\n  baseQuery: fetchBaseQuery({\n    baseUrl: \"https://jsonplaceholder.typicode.com/\",\n  }), // Base URL of the API\n  endpoints: (builder) =&gt; ({\n    // Define an endpoint for fetching posts\n    getPosts: builder.query({\n      query: () =&gt; \"posts\", // API call to fetch posts\n    }),\n    // Define an endpoint for creating a new post\n    createPost: builder.mutation({\n      query: (newPost) =&gt; ({\n        url: \"posts\",\n        method: \"POST\",\n        body: newPost,\n      }),\n    }),\n  }),\n});\n\nexport const { useGetPostsQuery, useCreatePostMutation } = postsApi;\n</code></pre> <p>2. Reducers Automatically Generated</p> <p>RTK Query will automatically generate the reducers for the API service defined in <code>postsApi</code>. This includes reducers for handling the loading, success, and error states.</p> <p>In your Redux store setup, you will add <code>postsApi.reducer</code> as a slice of the store:</p> <pre><code>// src/store.js\nimport { configureStore } from \"@reduxjs/toolkit\";\nimport { postsApi } from \"./services/postsApi\";\n\nexport const store = configureStore({\n  reducer: {\n    // Add the API reducer to the store\n    [postsApi.reducerPath]: postsApi.reducer,\n  },\n  // Adding the api middleware enables caching, invalidation, polling, and other features of RTK Query\n  middleware: (getDefaultMiddleware) =&gt;\n    getDefaultMiddleware().concat(postsApi.middleware),\n});\n</code></pre> <p>3. Endpoints</p> <p>Endpoints define how to interact with the API (such as fetching data or creating new resources). In the example above, we defined two endpoints:</p> <ul> <li><code>getPosts</code> (for fetching posts)</li> <li><code>createPost</code> (for creating a new post)</li> </ul> <p>These endpoints are used in your components using the automatically generated hooks.</p> <p>4. Async Thunks</p> <p>RTK Query automatically creates async thunks for you. When you use the <code>useGetPostsQuery</code> hook, it dispatches an action to fetch the posts, and internally manages the loading, success, and error states for you.</p> <p>Example of using the <code>useGetPostsQuery</code> hook to fetch posts in a component:</p> <pre><code>// src/components/PostList.js\nimport React from \"react\";\nimport { useGetPostsQuery } from \"../services/postsApi\";\n\nconst PostList = () =&gt; {\n  const { data, error, isLoading } = useGetPostsQuery();\n\n  if (isLoading) return &lt;p&gt;Loading...&lt;/p&gt;;\n  if (error) return &lt;p&gt;Error: {error.message}&lt;/p&gt;;\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Posts&lt;/h1&gt;\n      &lt;ul&gt;\n        {data.map((post) =&gt; (\n          &lt;li key={post.id}&gt;\n            &lt;h3&gt;{post.title}&lt;/h3&gt;\n            &lt;p&gt;{post.body}&lt;/p&gt;\n          &lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default PostList;\n</code></pre> <p>5. Transform Response</p> <p>You can transform the response before it's saved into the Redux store using the <code>transformResponse</code> option in the endpoint definition.</p> <p>Let's say we want to include a derived field, such as \"postLength\" (the length of the post body):</p> <pre><code>// src/services/postsApi.js\nexport const postsApi = createApi({\n  reducerPath: \"postsApi\",\n  baseQuery: fetchBaseQuery({\n    baseUrl: \"https://jsonplaceholder.typicode.com/\",\n  }),\n  endpoints: (builder) =&gt; ({\n    getPosts: builder.query({\n      query: () =&gt; \"posts\",\n      transformResponse: (response) =&gt; {\n        // Add a \"postLength\" field to each post\n        return response.map((post) =&gt; ({\n          ...post,\n          postLength: post.body.length,\n        }));\n      },\n    }),\n    createPost: builder.mutation({\n      query: (newPost) =&gt; ({\n        url: \"posts\",\n        method: \"POST\",\n        body: newPost,\n      }),\n    }),\n  }),\n});\n</code></pre> <p>Now, the <code>data</code> returned from <code>useGetPostsQuery()</code> will include the <code>postLength</code> field for each post.</p> <p>6. Extra Reducers</p> <p>You can also define custom logic using <code>extraReducers</code> to handle actions dispatched outside of the API service. For example, let's add an extra reducer that listens to changes in posts and updates the UI accordingly:</p> <pre><code>// src/services/postsApi.js\nexport const postsApi = createApi({\n  reducerPath: \"postsApi\",\n  baseQuery: fetchBaseQuery({\n    baseUrl: \"https://jsonplaceholder.typicode.com/\",\n  }),\n  endpoints: (builder) =&gt; ({\n    getPosts: builder.query({\n      query: () =&gt; \"posts\",\n    }),\n    createPost: builder.mutation({\n      query: (newPost) =&gt; ({\n        url: \"posts\",\n        method: \"POST\",\n        body: newPost,\n      }),\n    }),\n  }),\n  extraReducers: (builder) =&gt; {\n    builder.addMatcher(\n      (action) =&gt; action.type.startsWith(\"postsApi/\"),\n      (state, action) =&gt; {\n        // Custom logic for handling state changes\n        console.log(\"API action was dispatched:\", action);\n      }\n    );\n  },\n});\n</code></pre> <p>This example shows how you could handle other custom actions in your app, in addition to the auto-generated ones.</p>"},{"location":"frontend/state-management/redux/rtk/query/mnemonic/#final-directory-structure","title":"Final Directory Structure","text":"<pre><code>/src\n  /services\n    postsApi.js\n  /components\n    PostList.js\n  store.js\n</code></pre>"},{"location":"frontend/state-management/redux/rtk/query/mnemonic/#summary-of-create","title":"Summary of C.R.E.A.T.E.","text":"<ul> <li>Create an API Service: Use <code>createApi</code> to define API endpoints.</li> <li>Reducers Automatically Generated: RTK Query generates reducers for managing state.</li> <li>Endpoints: Define various API operations (e.g., <code>GET</code>, <code>POST</code>).</li> <li>Async Thunks: RTK Query automatically dispatches thunks for asynchronous API calls.</li> <li>Transform Response: Optionally transform the API response before it's stored.</li> <li>Extra Reducers: Use <code>extraReducers</code> to define custom logic outside of RTK Query.</li> </ul> <p>This example should give you a good understanding of how RTK Query simplifies API interaction in a Redux app while following the C.R.E.A.T.E. mnemonic.</p>"},{"location":"frontend/state-management/redux/rtk/query/rtkadvanced/","title":"RTK Advanced","text":""},{"location":"frontend/state-management/redux/rtk/query/rtkadvanced/#basic-about-rtk","title":"Basic about RTK","text":"<p>To get started with RTK Query (Redux Toolkit Query), you only need to understand a few key concepts and features that allow you to integrate API data fetching and state management into your React app. Below are the most basic things you need to learn to use RTK Query effectively:</p>"},{"location":"frontend/state-management/redux/rtk/query/rtkadvanced/#1-what-is-rtk-query","title":"1. What is RTK Query?","text":"<p>RTK Query is a data fetching and caching tool built into Redux Toolkit that provides:</p> <ul> <li>Simplified data fetching: Automatically manages HTTP requests and responses.</li> <li>Caching: Automatically caches data and synchronizes your store.</li> <li>Optimized performance: Provides built-in utilities for handling things like pagination and re-fetching.</li> <li>No need for reducers: Handles API calls without needing additional action types, reducers, or custom middleware.</li> </ul> <p>RTK Query handles <code>data fetching</code>, <code>caching</code>, <code>synchronization</code>, and <code>state management</code> with minimal boilerplate.</p>"},{"location":"frontend/state-management/redux/rtk/query/rtkadvanced/#2-basic-setup","title":"2. Basic Setup","text":"<p>Before diving into how to use RTK Query, you need to set it up in your application. Here's how:</p> <ol> <li> <p>Install Redux Toolkit and React-Redux:</p> <pre><code>npm install @reduxjs/toolkit react-redux\n</code></pre> </li> <li> <p>Create an API service: You use <code>createApi</code> from RTK Query to define API endpoints. Here's a basic example of creating a service to fetch data.</p> <pre><code>// src/services/api.js\nimport { createApi, fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\n\n// Create an API slice\nexport const api = createApi({\n  reducerPath: \"api\", // Name of the slice\n  baseQuery: fetchBaseQuery({\n    baseUrl: \"https://jsonplaceholder.typicode.com\",\n  }), // API base URL\n  endpoints: (builder) =&gt; ({\n    // Define an endpoint to fetch posts\n    getPosts: builder.query({\n      query: () =&gt; \"/posts\", // Endpoint path\n    }),\n  }),\n});\n\n// Export the auto-generated hook for the getPosts endpoint\nexport const { useGetPostsQuery } = api;\n</code></pre> </li> <li> <p>Add the API service to the Redux store: You need to add the API service's reducer to your Redux store and also include the middleware to support caching, polling, and other features.</p> <pre><code>// src/store.js\nimport { configureStore } from \"@reduxjs/toolkit\";\nimport { api } from \"./services/api\";\n\nconst store = configureStore({\n  reducer: {\n    [api.reducerPath]: api.reducer, // Adding API slice reducer\n  },\n  middleware: (getDefaultMiddleware) =&gt;\n    getDefaultMiddleware().concat(api.middleware), // Adding RTK Query middleware\n});\n\nexport default store;\n</code></pre> </li> <li> <p>Provide the Redux store to your app: Wrap your app with the <code>Provider</code> component from react-redux to make the Redux store available throughout the app.</p> <pre><code>// src/index.js\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { Provider } from \"react-redux\";\nimport store from \"./store\";\nimport App from \"./App\";\n\nReactDOM.render(\n  &lt;Provider store={store}&gt;\n    &lt;App /&gt;\n  &lt;/Provider&gt;,\n  document.getElementById(\"root\")\n);\n</code></pre> </li> </ol>"},{"location":"frontend/state-management/redux/rtk/query/rtkadvanced/#3-using-rtk-query-in-components","title":"3. Using RTK Query in Components","text":"<p>Once you have set up the API service, you can use the auto-generated hooks in your components to fetch data.</p> ExampleExplanation <p>Example: Fetching posts with useGetPostsQuery</p> <pre><code>// src/components/Posts.js\nimport React from 'react';\nimport { useGetPostsQuery } from '../services/api';\n\nconst Posts = () =&gt; {\n    // Use the auto-generated hook to fetch data\n    const { data, error, isLoading } = useGetPostsQuery();\n\n    if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Posts&lt;/h1&gt;\n            &lt;ul&gt;\n                {data?.map((post) =&gt; (\n                    &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Posts;\n</code></pre> <ul> <li><code>useGetPostsQuery</code> is the hook that was auto-generated from the <code>getPosts</code> endpoint defined in the API slice.</li> <li> <p>It returns:</p> <ul> <li><code>data</code>: The fetched data (in this case, posts).</li> <li><code>error</code>: Any error that occurred during the request.</li> <li><code>isLoading</code>: Boolean flag indicating whether the data is still being fetched.</li> </ul> </li> </ul>"},{"location":"frontend/state-management/redux/rtk/query/rtkadvanced/#4-key-concepts-you-should-know","title":"4. Key Concepts You Should Know","text":"<p>To use RTK Query effectively, you should understand the following core concepts:</p> <p><code>createApi</code>:</p> <p>This is the function that defines an API service. You use it to:</p> <ul> <li>Define endpoints (API paths like <code>/posts</code>, <code>/users</code>, etc.).</li> <li>Specify a baseQuery to handle the HTTP requests (e.g., using <code>fetchBaseQuery</code> for simple fetch requests or using Axios for more complex ones).</li> </ul> Auto-generated hooks: <p>For each endpoint defined, RTK Query automatically generates hooks such as:</p> <ul> <li><code>useGetPostsQuery</code>: Hook for fetching data (GET request).</li> <li><code>useCreatePostMutation</code>: Hook for creating or modifying data (POST, PUT, DELETE requests).</li> </ul> <p>These hooks simplify the process of interacting with APIs by automatically managing loading states, caching, and error handling.</p> <p><code>fetchBaseQuery</code>:</p> <p>This is a simple query function used to make requests. It's essentially a wrapper around fetch (or you could use Axios). It allows you to define the base URL for your API and handle the actual HTTP requests easily.</p>"},{"location":"frontend/state-management/redux/rtk/query/rtkadvanced/#5-handling-loading-error-and-success-states","title":"5. Handling Loading, Error, and Success States","text":"<p>RTK Query automatically provides you with states like <code>isLoading</code>, <code>error</code>, and <code>data</code> to help you manage your component UI.</p> <p>Here\u2019s how it works in the context of the <code>useGetPostsQuery</code> hook:</p> <ul> <li><code>isLoading</code>: Indicates if the request is still in progress.</li> <li><code>data</code>: Contains the response data once the request is successful.</li> <li><code>error</code>: Contains error information if the request fails.</li> </ul> Displaying loading and error states BasicAdvanced <pre><code>const Posts = () =&gt; {\n    const { data, error, isLoading } = useGetPostsQuery();\n\n    if (isLoading) {\n        return &lt;div&gt;Loading...&lt;/div&gt;; // Show loading state\n    }\n\n    if (error) {\n        return &lt;div&gt;Error: {error.message}&lt;/div&gt;; // Show error message\n    }\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Posts&lt;/h1&gt;\n            &lt;ul&gt;\n                {data?.map((post) =&gt; (\n                    &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n</code></pre>"},{"location":"frontend/state-management/redux/rtk/query/rtkadvanced/#summary-of-what-you-need-to-learn-to-get-started-with-rtk-query","title":"Summary of What You Need to Learn to Get Started with RTK Query:","text":"<ul> <li>Understand <code>createApi</code>: This is where you define your endpoints and how to make HTTP requests.</li> <li>Learn to use auto-generated hooks: These hooks (like <code>useGetQuery</code>, <code>usePostMutation</code>, etc.) simplify API interaction.</li> <li>Handle loading, error, and data states: RTK Query provides automatic states (<code>isLoading</code>, <code>error</code>, <code>data</code>) to manage API requests in your components.</li> <li>Set up your Redux store correctly: Integrate the API service with your Redux store and use the <code>Provider</code> to make the store available.</li> </ul>"},{"location":"frontend/state-management/redux/rtk/query/rtkadvanced/#example-summary","title":"Example Summary:","text":"api.jsstore.jsApp.js <pre><code>import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';\n\nexport const api = createApi({\n    reducerPath: 'api',\n    baseQuery: fetchBaseQuery({ baseUrl: 'https://jsonplaceholder.typicode.com' }),\n    endpoints: (builder) =&gt; ({\n        getPosts: builder.query({ query: () =&gt; '/posts' }),\n    }),\n});\n\nexport const { useGetPostsQuery } = api;\n</code></pre> <pre><code>import { configureStore } from '@reduxjs/toolkit';\nimport { api } from './services/api';\n\nconst store = configureStore({\n    reducer: {\n        [api.reducerPath]: api.reducer,\n    },\n    middleware: (getDefaultMiddleware) =&gt;\n        getDefaultMiddleware().concat(api.middleware),\n});\n\nexport default store;\n</code></pre> <pre><code>import React from 'react';\nimport { useGetPostsQuery } from './services/api';\n\nconst Posts = () =&gt; {\n    const { data, error, isLoading } = useGetPostsQuery();\n\n    if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Posts&lt;/h1&gt;\n            &lt;ul&gt;\n                {data?.map((post) =&gt; (\n                    &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Posts;\n</code></pre> <p>By understanding these basic concepts and steps, you'll be well on your way to using RTK Query for data fetching in a Redux-based React application. Let me know if you have any specific questions or need further examples!</p>"},{"location":"frontend/state-management/redux/rtk/query/rtkadvanced/#rtk-query-auto-generated-hooks","title":"RTK Query Auto-Generated Hooks","text":"<p>Auto-generated hooks like <code>useGetQuery</code>, <code>usePostMutation</code>, and others are typically part of libraries or frameworks that simplify the process of making API requests and managing state. One of the most common tools that provides auto-generated hooks is Redux Toolkit Query (RTK Query), which is a part of Redux Toolkit. This tool allows you to define API endpoints and automatically generate hooks to interact with those endpoints, reducing the boilerplate code required to make requests.</p>"},{"location":"frontend/state-management/redux/rtk/query/rtkadvanced/#understanding-auto-generated-hooks","title":"Understanding Auto-Generated Hooks","text":"<p>When you define your API service with RTK Query, it auto-generates hooks for each operation (GET, POST, PUT, DELETE, etc.). These hooks are ready to be used inside your React components, and they encapsulate the logic for fetching data, posting data, or handling mutations.</p>"},{"location":"frontend/state-management/redux/rtk/query/rtkadvanced/#step-by-step-example-using-rtk-query","title":"Step-by-Step Example Using RTK Query","text":"<ol> <li> <p>Install Redux Toolkit: First, if you haven't installed <code>@reduxjs/toolkit</code>, you need to add it:</p> <pre><code>npm install @reduxjs/toolkit react-redux\n</code></pre> </li> <li> <p>Define an API Service: You use <code>createApi</code> to define endpoints for different HTTP operations. Here\u2019s how you can define GET and POST requests:</p> <pre><code>// services/api.js\nimport { createApi, fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\n\nconst api = createApi({\n  reducerPath: \"api\",\n  baseQuery: fetchBaseQuery({\n    baseUrl: \"https://jsonplaceholder.typicode.com/\",\n  }),\n  endpoints: (builder) =&gt; ({\n    // GET request example\n    getPosts: builder.query({\n      query: () =&gt; \"posts\", // The relative URL for the GET request\n    }),\n    // POST request example\n    createPost: builder.mutation({\n      query: (newPost) =&gt; ({\n        url: \"posts\",\n        method: \"POST\",\n        body: newPost,\n      }),\n    }),\n  }),\n});\n\nexport const { useGetPostsQuery, useCreatePostMutation } = api;\nexport default api;\n</code></pre> <p>In this example, we defined:</p> <ul> <li><code>getPosts</code>: A GET endpoint to fetch posts.</li> <li><code>createPost</code>: A POST endpoint to create a new post.</li> </ul> </li> <li> <p>Add API Reducer to Your Store: Next, add this service to your Redux store so that the auto-generated hooks can access it.</p> <pre><code>// store.js\nimport { configureStore } from \"@reduxjs/toolkit\";\nimport { api } from \"./services/api\";\n\nconst store = configureStore({\n  reducer: {\n    [api.reducerPath]: api.reducer,\n  },\n  middleware: (getDefaultMiddleware) =&gt;\n    getDefaultMiddleware().concat(api.middleware), // Add RTK Query middleware\n});\n\nexport default store;\n</code></pre> </li> <li> <p>Using Auto-Generated Hooks in Components: Now, you can use the generated hooks (<code>useGetPostsQuery</code>, <code>useCreatePostMutation</code>) inside your components to interact with your API.</p> </li> </ol> Fetching Data (GET):Posting Data (POST): <pre><code>// components/Posts.js\nimport React from 'react';\nimport { useGetPostsQuery } from '../services/api';\n\nconst Posts = () =&gt; {\n    const { data, error, isLoading } = useGetPostsQuery();\n\n    if (isLoading) return &lt;p&gt;Loading...&lt;/p&gt;;\n    if (error) return &lt;p&gt;Error: {error.message}&lt;/p&gt;;\n\n    return (\n        &lt;ul&gt;\n            {data.map((post) =&gt; (\n                &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;\n            ))}\n        &lt;/ul&gt;\n    );\n};\n\nexport default Posts;\n</code></pre> <p>In this example:</p> <ul> <li><code>useGetPostsQuery</code> is the hook auto-generated by RTK Query.</li> <li>The hook automatically handles the request, loading state, and error state.</li> </ul> <pre><code>// components/CreatePost.js\nimport React, { useState } from \"react\";\nimport { useCreatePostMutation } from \"../services/api\";\n\nconst CreatePost = () =&gt; {\n    const [title, setTitle] = useState(\"\");\n    const [body, setBody] = useState(\"\");\n    const [createPost, { isLoading, isError }] = useCreatePostMutation();\n\n    const handleSubmit = async (e) =&gt; {\n        e.preventDefault();\n        await createPost({ title, body });\n    };\n\n    return (\n        &lt;form onSubmit={handleSubmit}&gt;\n            &lt;input\n                type=\"text\"\n                placeholder=\"Title\"\n                value={title}\n                onChange={(e) =&gt; setTitle(e.target.value)}\n            /&gt;\n            &lt;textarea\n                placeholder=\"Body\"\n                value={body}\n                onChange={(e) =&gt; setBody(e.target.value)}\n            /&gt;\n            &lt;button type=\"submit\" disabled={isLoading}&gt;\n                {isLoading ? \"Submitting...\" : \"Submit\"}\n            &lt;/button&gt;\n\n            {isError &amp;&amp; &lt;p&gt;Error submitting the post.&lt;/p&gt;}\n        &lt;/form&gt;\n    );\n};\n\nexport default CreatePost;\n</code></pre> <p>In this example:</p> <ul> <li><code>useCreatePostMutation</code> is the hook for creating a new post.</li> <li>The hook returns a function (<code>createPost</code>) that you can call to trigger the POST request, and the hook also returns states like <code>isLoading</code> and <code>isError</code>.</li> </ul>"},{"location":"frontend/state-management/redux/rtk/query/rtkadvanced/#more-example-hooks","title":"More Example Hooks","text":"<p>RTK Query will generate a hook for each endpoint operation you define. Here are some possible auto-generated hooks and how they can be used:</p> <ol> <li> <p>GET Request (e.g., fetching users):</p> <pre><code>const { data, isLoading, error } = useGetUsersQuery();\n</code></pre> </li> <li> <p>POST Request (e.g., creating a comment):</p> <pre><code>const [createComment, { isLoading, error }] = useCreateCommentMutation();\n</code></pre> </li> <li> <p>PUT/PATCH Request (e.g., updating a post):</p> <pre><code>const [updatePost, { isLoading, error }] = useUpdatePostMutation();\n</code></pre> </li> <li> <p>DELETE Request (e.g., deleting a post):</p> <pre><code>const [deletePost, { isLoading, error }] = useDeletePostMutation();\n</code></pre> </li> </ol> Summary <ul> <li>Auto-generated hooks like <code>useGetQuery</code>, <code>usePostMutation</code>, and others simplify working with API requests by automatically managing states like loading, error, and data.</li> <li>You define API endpoints with <code>createApi</code> in Redux Toolkit Query, and the library generates hooks for each operation.</li> <li>The generated hooks provide an easy interface to interact with your API without needing to manually write logic for <code>fetch</code>, <code>loading</code>, <code>error</code>, and <code>success</code> states.</li> </ul> <p>By using these auto-generated hooks, you can focus on building your UI while letting RTK Query handle the underlying complexities of interacting with APIs.</p> <p>Advanced Tips &amp; Tricks 2</p> <p>When using RTK Query (Redux Toolkit Query), there are several advanced techniques, patterns, and best practices you can implement to make your code more efficient, maintainable, and scalable. Here are some of the advanced tips, tricks, and patterns for leveraging RTK Query:</p> <p>1. Optimistic Updates</p> <p>Optimistic updates allow you to update the UI before an API request has completed. This is particularly useful when dealing with actions that take a long time (e.g., submitting a form, deleting an item). You can \"optimistically\" assume success and update the state, then revert if the request fails.</p> <p>Example: Optimistic Update for a Like/Dislike Action</p> <pre><code>// In your API slice\nimport { createApi, fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\n\nexport const postsApi = createApi({\n  reducerPath: \"postsApi\",\n  baseQuery: fetchBaseQuery({ baseUrl: \"/api/\" }),\n  endpoints: (builder) =&gt; ({\n    likePost: builder.mutation({\n      query: (postId) =&gt; ({\n        url: `/posts/${postId}/like`,\n        method: \"POST\",\n      }),\n      // Optimistically update the cache\n      async onQueryStarted(postId, { dispatch, queryFulfilled }) {\n        // Optimistic update\n        dispatch(\n          postsApi.util.updateQueryData(\"getPosts\", undefined, (draft) =&gt; {\n            const post = draft.find((p) =&gt; p.id === postId);\n            if (post) post.likes += 1;\n          })\n        );\n        // Wait for the API response\n        try {\n          await queryFulfilled;\n        } catch (err) {\n          // Revert the optimistic update if the mutation fails\n          dispatch(\n            postsApi.util.updateQueryData(\"getPosts\", undefined, (draft) =&gt; {\n              const post = draft.find((p) =&gt; p.id === postId);\n              if (post) post.likes -= 1;\n            })\n          );\n        }\n      },\n    }),\n  }),\n});\n\nexport const { useLikePostMutation } = postsApi;\n</code></pre> <p>In this example, when the <code>likePost</code> mutation is triggered, the state is updated optimistically by increasing the like count, and if the request fails, the change is rolled back.</p> <p>2. Cache Management and Data Normalization</p> <p>RTK Query provides powerful caching mechanisms, and caching can be further improved with data normalization (e.g., by storing entities in a normalized format).</p> <p>You can use <code>upsert</code> to add or update data in the cache.</p> <p>Example: Normalizing Data and Using <code>upsert</code></p> <pre><code>import { createApi, fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\n\nexport const usersApi = createApi({\n  reducerPath: \"usersApi\",\n  baseQuery: fetchBaseQuery({ baseUrl: \"/api\" }),\n  endpoints: (builder) =&gt; ({\n    getUser: builder.query({\n      query: (id) =&gt; `/users/${id}`,\n      // Normalize the data when fetching users\n      transformResponse: (response) =&gt; ({\n        ...response,\n        __typename: \"User\", // Optional: Add a type for caching\n      }),\n    }),\n    updateUser: builder.mutation({\n      query: (user) =&gt; ({\n        url: `/users/${user.id}`,\n        method: \"PUT\",\n        body: user,\n      }),\n      // Using `upsert` to update or insert in the cache\n      async onQueryStarted(user, { dispatch, queryFulfilled }) {\n        const patchResult = dispatch(\n          usersApi.util.updateQueryData(\"getUser\", user.id, (draft) =&gt; {\n            Object.assign(draft, user);\n          })\n        );\n        try {\n          await queryFulfilled;\n        } catch (err) {\n          patchResult.undo(); // Undo the update if the query fails\n        }\n      },\n    }),\n  }),\n});\n\nexport const { useGetUserQuery, useUpdateUserMutation } = usersApi;\n</code></pre> <p>In this example:</p> <ul> <li>We normalize the <code>user</code> data when it is fetched (<code>transformResponse</code>).</li> <li>We use <code>updateQueryData</code> to update or \"upsert\" data in the cache after a mutation.</li> </ul> <p>3. Polling for Real-time Data</p> <p>You can periodically refetch data (e.g., for real-time updates) by using polling with <code>pollingInterval</code>.</p> <p>Example: Polling for Real-time Data</p> <pre><code>export const postsApi = createApi({\n  reducerPath: \"postsApi\",\n  baseQuery: fetchBaseQuery({ baseUrl: \"/api/\" }),\n  endpoints: (builder) =&gt; ({\n    getPosts: builder.query({\n      query: () =&gt; \"/posts\",\n      // Poll every 30 seconds\n      pollingInterval: 30000,\n    }),\n  }),\n});\n\nexport const { useGetPostsQuery } = postsApi;\n</code></pre> <p>In this example, the <code>getPosts</code> query will automatically refetch the data every 30 seconds. This can be useful for showing real-time updates like live comments, stock prices, or chat messages.</p> <p>4. Handling Multiple Requests with <code>batch</code></p> <p>When you need to fire off multiple API requests in parallel, you can use <code>batch</code> to manage them efficiently.</p> <p>Example: Making Multiple API Requests in Parallel</p> <pre><code>import { createApi, fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\n\nexport const api = createApi({\n  reducerPath: \"api\",\n  baseQuery: fetchBaseQuery({ baseUrl: \"/api\" }),\n  endpoints: (builder) =&gt; ({\n    getUsers: builder.query({\n      query: () =&gt; \"/users\",\n    }),\n    getPosts: builder.query({\n      query: () =&gt; \"/posts\",\n    }),\n  }),\n});\n\nexport const { useGetUsersQuery, useGetPostsQuery } = api;\n\n// In a component:\nconst MyComponent = () =&gt; {\n  const { data: users } = useGetUsersQuery();\n  const { data: posts } = useGetPostsQuery();\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Users&lt;/h1&gt;\n      &lt;ul&gt;\n        {users?.map((user) =&gt; (\n          &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n      &lt;h1&gt;Posts&lt;/h1&gt;\n      &lt;ul&gt;\n        {posts?.map((post) =&gt; (\n          &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n};\n</code></pre> <p>In this case, both <code>getUsers</code> and <code>getPosts</code> will be fetched in parallel, making the app more efficient.</p> <p>5. Lazy Loading with <code>skip</code></p> <p>You can conditionally skip queries or mutations if you don't need to fetch data until a certain condition is met. This can be useful for reducing unnecessary API requests.</p> <p>Example: Lazy Loading Queries with <code>skip</code></p> <pre><code>export const postsApi = createApi({\n  reducerPath: \"postsApi\",\n  baseQuery: fetchBaseQuery({ baseUrl: \"/api\" }),\n  endpoints: (builder) =&gt; ({\n    getPosts: builder.query({\n      query: () =&gt; \"/posts\",\n      // Skip query if no posts are needed\n      skip: ({ isUserLoggedIn }) =&gt; !isUserLoggedIn,\n    }),\n  }),\n});\n\nexport const { useGetPostsQuery } = postsApi;\n</code></pre> <p>In this example, the <code>getPosts</code> query will be skipped unless the user is logged in.</p> <p>6. Custom <code>baseQuery</code> for Complex Scenarios</p> <p>You can customize the <code>baseQuery</code> to handle more complex scenarios, such as adding authorization tokens, handling retries, or logging.</p> <p>Example: Custom <code>baseQuery</code> for Authorization and Retry Logic</p> <pre><code>const baseQueryWithAuth = async (args, api, extraOptions) =&gt; {\n  const token = localStorage.getItem(\"auth_token\");\n\n  const result = await fetchBaseQuery({\n    baseUrl: \"/api\",\n    prepareHeaders: (headers) =&gt; {\n      if (token) {\n        headers.set(\"Authorization\", `Bearer ${token}`);\n      }\n      return headers;\n    },\n  })(args, api, extraOptions);\n\n  // Retry logic (e.g., if token is expired, refresh it and retry)\n  if (result.error?.status === 401) {\n    // Handle retry logic or refresh token here\n  }\n\n  return result;\n};\n\nexport const api = createApi({\n  reducerPath: \"api\",\n  baseQuery: baseQueryWithAuth,\n  endpoints: (builder) =&gt; ({\n    getPosts: builder.query({\n      query: () =&gt; \"/posts\",\n    }),\n  }),\n});\n</code></pre> <p>In this example, the <code>baseQueryWithAuth</code> adds an <code>Authorization</code> header for API requests if a token is present. Additionally, you can extend this to include retry logic or token refreshing if needed.</p> <p>7. Using <code>selectFromResult</code> for Optimized Data Fetching</p> <p>If you're using RTK Query to fetch a large dataset but only need part of the data, use <code>selectFromResult</code> to limit the amount of data returned to just what you need.</p> <p>Example: Using <code>selectFromResult</code></p> <pre><code>const { data } = useGetPostsQuery(undefined, {\n  selectFromResult: (result) =&gt; ({\n    posts: result.data?.filter((post) =&gt; post.isPublished),\n  }),\n});\n</code></pre> <p>In this example, we filter the posts on the fly to only return published posts, optimizing performance when you have a large dataset.</p> <p>8. Error Handling with <code>onError</code></p> <p>For complex error handling (e.g., for logging or user feedback), you can use the <code>onError</code> callback to handle errors globally or within a specific endpoint.</p> <p>Example: Using <code>onError</code> for Error Handling</p> <pre><code>export const postsApi = createApi({\n  reducerPath: \"postsApi\",\n  baseQuery: fetchBaseQuery({ baseUrl: \"/api\" }),\n  endpoints: (builder) =&gt; ({\n    getPosts: builder.query({\n      query: () =&gt; \"/posts\",\n      onError: (error) =&gt; {\n        console.error(\"Error fetching posts:\", error);\n        // Optionally send error info to a logging service\n      },\n    }),\n  }),\n});\n</code></pre> <p>In this example, if an error occurs when fetching posts, it's logged to the console, and you could extend it to handle retries, user notifications, or report the error to a monitoring service.</p> <p>Conclusion</p> <p>These advanced techniques can help you leverage the full power of RTK Query and optimize your application's data fetching, caching, and UI state management:</p> <ol> <li>Optimistic Updates: Improves UI responsiveness by assuming success before receiving the response.</li> <li>Cache Management &amp; Data Normalization: Improves performance and data consistency.</li> <li>Polling: Useful for real-time data updates (e.g., live notifications).</li> <li>Batch Requests: Efficiently handle multiple API requests in parallel.</li> <li>Lazy Loading: Conditionally skip API calls based on certain conditions.</li> <li>Custom <code>baseQuery</code>: Allows for flexible API configuration (e.g., authentication or retries).</li> <li><code>selectFromResult</code>: Limits the returned data to what's necessary.</li> <li>Error Handling with <code>onError</code>: Centralized error handling for logging or reporting.</li> </ol> <p>By implementing these patterns, you'll be able to build more scalable, efficient, and maintainable applications using RTK Query.</p>"},{"location":"frontend/state-management/redux/rtk/query/tools/","title":"Tools","text":""},{"location":"frontend/state-management/redux/rtk/query/tools/#overview","title":"Overview","text":"<p>When building a React application, choosing the right tools is crucial to ensure your app is scalable, maintainable, and performant. Here's a list of the best tools to use in a React project, categorized by different aspects of the development process:</p>"},{"location":"frontend/state-management/redux/rtk/query/tools/#1-development-tools","title":"1. Development Tools","text":"<p>Code Editors</p> <p>VSCode: The most popular code editor for React development, with features like IntelliSense, Git integration, and extensions for React.</p> <p>Recommended Extensions for React:</p> <ul> <li>ESLint: Lint your code to maintain consistent style and catch potential bugs.</li> <li>Prettier: Auto-format your code according to your preferred style.</li> <li>Bracket Pair Colorizer: Color-code matching brackets for better readability.</li> <li>Path Intellisense: Auto-completion for file paths.</li> <li>Reactjs code snippets: Get React code snippets and syntax templates.</li> </ul> <p>TypeScript</p> <p>TypeScript: Highly recommended for large React applications because it provides static typing, which helps catch errors early and enhances IDE support.</p> <ul> <li>Install: <code>npm install typescript --save-dev</code></li> <li>If starting from scratch, use a TypeScript template for React projects: <code>npx create-react-app my-app --template typescript</code></li> </ul>"},{"location":"frontend/state-management/redux/rtk/query/tools/#2-routing","title":"2. Routing","text":"<p>React Router</p> <p>React Router is the standard for client-side routing in React apps.</p> <ul> <li>Install: <code>npm install react-router-dom</code></li> <li>Supports features like nested routing, route protection, dynamic routing, and lazy loading of routes.</li> </ul>"},{"location":"frontend/state-management/redux/rtk/query/tools/#3-state-management","title":"3. State Management","text":"<p>Redux Toolkit</p> <p>Redux Toolkit is the modern approach to Redux, reducing boilerplate and making Redux easier to use.</p> <ul> <li>Install: <code>npm install @reduxjs/toolkit react-redux</code></li> <li>Use Redux Thunk (or Redux Saga) for handling asynchronous actions.</li> </ul> <p>React Context API</p> <p>React Context API: A simpler state management solution for passing data through the component tree without prop drilling.</p> <ul> <li>Good for small to medium-sized applications.</li> </ul> <p>Zustand</p> <p>Zustand: A minimalistic state management tool with a simple API and no boilerplate. It's great for small to medium apps and has better performance than Redux for simple state.</p> <ul> <li>Install: <code>npm install zustand</code></li> </ul> <p>Recoil</p> <p>Recoil: A powerful state management library designed by Facebook, good for large-scale apps with complex state and dependencies.</p> <ul> <li>Install: <code>npm install recoil</code></li> </ul> <p>MobX</p> <p>MobX: An easy-to-use reactive state management library. It's less verbose than Redux and great for applications with a lot of dynamic state.</p> <ul> <li>Install: <code>npm install mobx react-mobx</code></li> </ul>"},{"location":"frontend/state-management/redux/rtk/query/tools/#4-api-data-fetching","title":"4. API Data Fetching","text":"<p>Axios</p> <p>Axios: A promise-based HTTP client for the browser and Node.js. It simplifies making API requests, handling errors, and adding custom configurations.</p> <ul> <li>Install: npm install axios</li> </ul> <p>React Query</p> <p>React Query: A powerful library for fetching, caching, and synchronizing server state in React applications. It helps with data fetching, caching, and background data syncing without complex state management.</p> <ul> <li>Install: npm install react-query</li> </ul> <p>SWR</p> <p>SWR: Another data-fetching library, similar to React Query. It's lighter and focuses on caching and re-fetching data with hooks.</p> <ul> <li>Install: npm install swr</li> </ul>"},{"location":"frontend/state-management/redux/rtk/query/tools/#5-forms","title":"5. Forms","text":"<p>Formik</p> <p>Formik: One of the most popular form libraries for React. It simplifies form validation, handling submission, and managing form state.</p> <ul> <li>Install: <code>npm install formik</code></li> </ul> <p>React Hook Form</p> <p>React Hook Form: A performant, flexible form library that minimizes re-renders and is easier to integrate with the rest of your React app.</p> <ul> <li>Install: <code>npm install react-hook-form</code></li> </ul> <p>Yup</p> <p>Yup: A schema-based validation library commonly used with Formik or React Hook Form to validate form data.</p> <ul> <li>Install: <code>npm install yup</code></li> </ul>"},{"location":"frontend/state-management/redux/rtk/query/tools/#6-styling","title":"6. Styling","text":"<p>Styled Components</p> <p>Styled Components: A CSS-in-JS library that allows you to write traditional CSS syntax within your JavaScript components. It also supports theming, nesting, and dynamic styling.</p> <ul> <li>Install: <code>npm install styled-components</code></li> </ul> <p>Emotion</p> <p>Emotion: A performant CSS-in-JS library for styling React components. It provides both styled-components API and a faster, optimized version.</p> <ul> <li>Install: <code>npm install @emotion/react @emotion/styled</code></li> </ul> <p>Tailwind CSS</p> <p>Tailwind CSS: A utility-first CSS framework that makes it easy to design components without writing custom CSS.</p> <ul> <li>Install: <code>npm install tailwindcss</code></li> <li>Use PostCSS to configure Tailwind.</li> </ul> <p>CSS Modules</p> <p>CSS Modules: Locally scoped CSS for better modularization of styles and avoidance of global styles conflicts.</p> <ul> <li>Works with vanilla CSS, SCSS, or PostCSS.</li> </ul>"},{"location":"frontend/state-management/redux/rtk/query/tools/#7-performance-optimization","title":"7. Performance Optimization","text":"<p>React Lazy &amp; Suspense</p> <p>React.lazy and Suspense: Built-in React features to enable <code>code splitting</code> and lazy loading of components.</p> <pre><code>const MyComponent = React.lazy(() =&gt; import('./MyComponent'));\n</code></pre> <p>React.memo</p> <p>React.memo: A higher-order component that memoizes a component, preventing unnecessary re-renders if the props don't change.</p> <p>React DevTools</p> <p>React DevTools: A browser extension for inspecting the React component tree and props/state, optimizing performance, and debugging.</p> <ul> <li>Install via Chrome/Firefox extensions.</li> </ul> <p>webpack Bundle Analyzer</p> <p>webpack Bundle Analyzer: Helps you visualize the size of webpack output files and optimize the size of your bundles.</p> <ul> <li>Install: <code>npm install --save-dev webpack-bundle-analyzer</code></li> </ul>"},{"location":"frontend/state-management/redux/rtk/query/tools/#8-testing","title":"8. Testing","text":"<p>Jest</p> <p>Jest: A popular testing framework for JavaScript and React. It supports unit testing, snapshots, and code coverage.</p> <ul> <li>Install: <code>npm install --save-dev jest</code></li> </ul> <p>React Testing Library</p> <p>React Testing Library: A testing utility for React components that encourages testing through user interactions and behavior rather than implementation details.</p> <ul> <li>Install: <code>npm install --save-dev @testing-library/react</code></li> </ul> <p>Cypress</p> <p>Cypress: A powerful end-to-end testing framework that allows you to test the full flow of your app in a real browser.</p> <ul> <li>Install: <code>npm install --save-dev cypress</code></li> </ul> <p>MSW (Mock Service Worker)</p> <p>MSW: For mocking API requests in unit or integration tests, useful when you don't want to hit real APIs during tests.</p> <ul> <li>Install: <code>npm install msw</code></li> </ul>"},{"location":"frontend/state-management/redux/rtk/query/tools/#9-code-quality-linting","title":"9. Code Quality &amp; Linting","text":"<p>ESLint</p> <p>ESLint: A tool for identifying and fixing problems in JavaScript code. It ensures consistent coding style and helps catch errors early.</p> <ul> <li>Install: <code>npm install --save-dev eslint</code></li> <li>Recommended Setup: Airbnb ESLint Config for React apps.</li> <li>Install: <code>npm install --save-dev eslint-config-airbnb eslint-plugin-react</code></li> </ul> <p>Prettier</p> <p>Prettier: An opinionated code formatter that automatically formats your code for consistent style.</p> <ul> <li>Install: <code>npm install --save-dev prettier</code></li> </ul> <p>Husky</p> <p>Husky: A tool that enables Git hooks, allowing you to run scripts before commits or pushes, like linting or testing.</p> <ul> <li>Install: <code>npm install --save-dev husky</code></li> </ul> <p>Lint-staged</p> <p>Lint-staged: A tool for running linting or formatting only on the staged files in Git.</p> <ul> <li>Install: <code>npm install --save-dev lint-staged</code></li> </ul>"},{"location":"frontend/state-management/redux/rtk/query/tools/#10-deployment-cicd","title":"10. Deployment &amp; CI/CD","text":"<p>Vercel / Netlify</p> <p>Vercel: A platform for deploying static sites and serverless functions, highly optimized for React applications. Set up continuous deployment directly from GitHub. Netlify: Another great platform for deploying React apps. It offers automatic builds, continuous deployment, and serverless functions.</p> <p>GitHub Actions / CircleCI / Travis CI</p> <p>Set up CI/CD pipelines to automate testing, linting, and deployment.</p>"},{"location":"frontend/state-management/redux/rtk/query/tools/#11-miscellaneous","title":"11. Miscellaneous","text":"<p>Storybook</p> <p>Storybook: An isolated environment to develop and showcase UI components, great for design systems.</p> <ul> <li>Install: <code>npm install @storybook/react</code></li> </ul> <p>React Helmet</p> <p>React Helmet: A library for managing the document head (title, meta tags, etc.), ideal for SEO and SSR (Server-Side Rendering).</p> <ul> <li>Install: <code>npm install react-helmet</code></li> </ul>"},{"location":"frontend/state-management/redux/rtk/query/tools/#conclusion","title":"Conclusion","text":"<p>The tools listed above help optimize various aspects of a React app, from development and testing to deployment and performance optimization. <code>React Router</code>, <code>Redux Toolkit</code>, <code>React Query</code>, <code>Styled Components</code>, <code>Jest</code>, <code>ESLint</code>, and <code>Prettier</code> are some of the most essential libraries and tools that most React apps should incorporate for smooth development and maintenance.</p> <p>Great! Let\u2019s dive deeper into any area that interests you. Here are some topics we can explore:</p> <pre><code>1.  State Management\n    Redux Toolkit vs. Context API vs. Zustand: How to choose the right state management approach for your app.\n\n2. Routing\n    React Router: Advanced patterns for handling nested routes, dynamic routes, and lazy loading.\n\n3. Forms Handling\n    Formik vs. React Hook Form: A deeper comparison, including performance considerations and best practices for form validation.\n\n4. Styling\n    Styled Components vs. Tailwind CSS: Which one should you use based on your app's requirements?\n\n5. API Data Fetching\n    React Query and SWR: When and why to use these libraries for caching and background syncing of data.\n\n6. Testing\n    How to effectively use React Testing Library and Jest to test your components.\n\n7. Performance Optimization\n    Advanced React optimizations (e.g., useMemo, React.memo, lazy loading, etc.).\n\n8. CI/CD\n    Setting up a CI/CD pipeline for React apps using GitHub Actions, CircleCI, or Travis CI.\n\n9. Deployment\n    Deploying to Vercel or Netlify: Best practices for serverless React apps.\n\n10. Code Quality\n    Using ESLint, Prettier, and Husky to ensure your code remains clean, consistent, and maintainable.\n```\n</code></pre>"},{"location":"frontend/state-management/redux/rtk/query/topic/","title":"Topic","text":""},{"location":"frontend/state-management/redux/rtk/query/topic/#overview","title":"Overview","text":"<p>To master RTK Query (Redux Toolkit Query), it's helpful to break it down into key concepts and topics from basic to advanced. Here's a roadmap of topics you can follow to level up your skills, starting from the fundamentals to advanced features:</p> Basic Concepts:Intermediate Concepts:Advanced Concepts:Mastering RTK Query: <ol> <li> <p>Introduction to Redux Toolkit (RTK)</p> <ul> <li>What is Redux Toolkit and how does it simplify Redux?</li> <li>Key concepts: <code>configureStore</code>, <code>createSlice</code>, <code>createAsyncThunk</code></li> </ul> </li> <li> <p>What is RTK Query?</p> <ul> <li>Introduction to RTK Query and how it integrates with Redux Toolkit.</li> <li>Benefits of using RTK Query over traditional redux-thunk or redux-saga for data fetching.</li> </ul> </li> <li> <p>Setting Up RTK Query</p> <ul> <li>Installing dependencies: @reduxjs/toolkit and react-redux</li> <li>Setting up API service using <code>createApi</code>.</li> <li>Defining API endpoints (e.g., <code>get</code>, <code>post</code>, <code>put</code>, <code>delete</code>).</li> </ul> </li> <li> <p>Basic RTK Query Usage</p> <ul> <li><code>createApi</code>: Structure of the <code>baseQuery</code> and endpoints.</li> <li>Example of defining API services and fetching data with <code>useGetQuery</code>.</li> <li>Fetching data within a component using hooks (e.g., <code>useGetExampleQuery</code>).</li> </ul> </li> <li> <p>Handling API Responses &amp; Errors</p> <ul> <li>Using <code>data</code>, <code>error</code>, and <code>isLoading</code> states returned from RTK Query hooks.</li> <li>Displaying loading states, errors, and the fetched data.</li> </ul> </li> </ol> <ol> <li> <p>Caching &amp; Normalization</p> <ul> <li>How RTK Query automatically handles caching.</li> <li>Understanding cache lifetimes and cache invalidation.</li> <li>Normalization of data and how RTK Query helps manage normalized data in the Redux store.</li> </ul> </li> <li> <p>Optimistic Updates</p> <ul> <li>What are optimistic updates and why are they useful for improving UX?</li> <li>Example of implementing optimistic updates in a mutation endpoint.</li> </ul> </li> <li> <p>Polling &amp; Re-fetching</p> <ul> <li>How to set up polling using <code>pollingInterval</code>.</li> <li>Manually triggering re-fetching of data (e.g., using <code>refetch</code>).</li> </ul> </li> <li> <p>Pagination &amp; Infinite Scrolling</p> <ul> <li>Setting up endpoints for pagination.</li> <li>Using <code>useInfiniteQuery</code> for infinite scrolling and managing paginated results.</li> </ul> </li> <li> <p>Batch Requests / Parallel Queries</p> <ul> <li>Sending multiple queries or mutations in parallel and handling their results.</li> <li>Using <code>useLazyQuery</code> and <code>Promise.all</code>.</li> </ul> </li> </ol> <ol> <li> <p>Custom Base Query</p> <ul> <li>How to write a custom base query using <code>baseQuery</code>.</li> <li>Examples of custom base queries using fetch, axios, or other HTTP clients.</li> <li>Handling custom headers, authentication tokens, etc.</li> </ul> </li> <li> <p>Caching &amp; Invalidating Data</p> <ul> <li>Fine-grained control over caching and invalidation.</li> <li>Using <code>providesTags</code> and <code>invalidatesTags</code> for managing cache dependencies.</li> <li>Using <code>cacheKey</code> and <code>refetchOnMount</code> options.</li> </ul> </li> <li> <p>Optimizing RTK Query Performance</p> <ul> <li>Handling large datasets efficiently (pagination, batch requests, caching strategies).</li> <li>Debouncing API requests in cases like search.</li> <li>Using web workers or other background techniques to avoid blocking the UI.</li> </ul> </li> <li> <p>Error Handling &amp; Retries</p> <ul> <li>Implementing custom error handling and retries in RTK Query.</li> <li>Handling HTTP errors, network failures, and server-side issues gracefully.</li> <li>Automatically retrying failed requests with backoff strategies.</li> </ul> </li> <li> <p>RTK Query with WebSockets</p> <ul> <li>Setting up WebSockets or real-time API interactions with RTK Query.</li> <li>Using RTK Query for real-time data updates (e.g., subscriptions, live feeds).</li> </ul> </li> </ol> <ol> <li> <p>Advanced Use Cases</p> <ul> <li>Managing <code>file uploads</code> and <code>downloads</code> using RTK Query.</li> <li><code>Authenticated endpoints</code> and managing tokens or credentials.</li> <li><code>Pagination</code> in the context of large-scale applications (e.g., server-side pagination).</li> </ul> </li> <li> <p>Custom Hooks and Code Reusability</p> <ul> <li>How to create reusable custom hooks with RTK Query.</li> <li>Refactoring common logic into custom hooks and reusable API service logic.</li> </ul> </li> <li> <p>RTK Query with SSR (Server-side rendering)</p> <ul> <li>Using RTK Query with server-side rendering (e.g., Next.js or Gatsby).</li> <li>Hydrating the Redux store on the server and sharing the store state between client and server.</li> </ul> </li> <li> <p>Testing with RTK Query</p> <ul> <li>Unit testing and mocking RTK Query endpoints in unit tests.</li> <li>Writing integration tests that interact with real API endpoints.</li> <li>Using MSW (Mock Service Worker) to mock API responses in tests.</li> </ul> </li> <li> <p>RTK Query Internals</p> <ul> <li>Understanding how RTK Query works internally.</li> <li>How caching and automatic updates happen under the hood.</li> <li>The Redux middleware and how RTK Query interacts with it.</li> </ul> </li> </ol> <p>Additional Resources:</p> <ul> <li>Official Documentation: The RTK Query documentation is a great starting point for each of these topics.</li> <li>Video Tutorials &amp; Blog Posts: Many developers and educators provide in-depth tutorials (e.g., on YouTube or Medium) covering specific use cases and advanced techniques.</li> <li>GitHub Repositories: Look for real-world applications on GitHub that use RTK Query extensively to get hands-on examples of best practices.</li> </ul> <p>This progression from basic to advanced topics should give you a comprehensive understanding of RTK Query. Would you like to dive deeper into any specific section? I can provide examples or explanations for any of the topics above.</p>"},{"location":"frontend/state-management/redux/rtk/query/topic/#example","title":"Example","text":"<p>Below is a step-by-step guide from basic to advanced concepts of RTK Query with examples to help you understand how to use the features in practice.</p> <p>1. Introduction to RTK Query</p> <p>RTK Query is a library within Redux Toolkit that simplifies data fetching, caching, synchronization, and much more.</p> Installation: <pre><code>npm install @reduxjs/toolkit react-redux\n</code></pre> <p>2. Basic RTK Query Usage</p> Step 1Step 2Step 3 <p>Step 1: Setup API Service using <code>createApi</code></p> <p>Create an API service with <code>createApi</code> to define endpoints and fetch data.</p> <pre><code>// services/api.js\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';\n\n// Create an API service\nexport const api = createApi({\n    reducerPath: 'api',\n    baseQuery: fetchBaseQuery({ baseUrl: 'https://jsonplaceholder.typicode.com' }),\n    endpoints: (builder) =&gt; ({\n        // Define a 'getPosts' endpoint to fetch posts data\n        getPosts: builder.query({\n            query: () =&gt; '/posts',\n        }),\n    }),\n});\n\nexport const { useGetPostsQuery } = api;\n</code></pre> <p>Step 2: Setup Redux Store</p> <p>Add the API slice to your store and configure the Redux Toolkit.</p> <pre><code>// store.js\nimport { configureStore } from '@reduxjs/toolkit';\nimport { api } from './services/api';\n\nconst store = configureStore({\n    reducer: {\n        [api.reducerPath]: api.reducer,\n    },\n    middleware: (getDefaultMiddleware) =&gt;\n        getDefaultMiddleware().concat(api.middleware), // Add RTK Query middleware\n});\n\nexport default store;\n</code></pre> <p>Step 3: Using the API in Components</p> <p>Use the generated hook useGetPostsQuery to fetch the data in your component.</p> <pre><code>// components/Posts.js\nimport React from 'react';\nimport { useGetPostsQuery } from '../services/api';\n\nconst Posts = () =&gt; {\n    const { data, error, isLoading } = useGetPostsQuery();\n\n    if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Posts&lt;/h1&gt;\n            &lt;ul&gt;\n                {data?.map((post) =&gt; (\n                    &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Posts;\n</code></pre> <p>3. Handling API Responses &amp; Errors</p> <p>RTK Query provides states like <code>isLoading</code>, <code>data</code>, and <code>error</code> to manage the response and handle errors.</p> Displaying data and errors <pre><code>// components/Posts.js\nimport React from 'react';\nimport { useGetPostsQuery } from '../services/api';\n\nconst Posts = () =&gt; {\n    const { data, error, isLoading } = useGetPostsQuery();\n\n    if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Posts&lt;/h1&gt;\n            &lt;ul&gt;\n                {data?.map((post) =&gt; (\n                &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Posts;\n</code></pre> <p>4. Pagination and Infinite Scrolling</p> <p>You can implement pagination or infinite scrolling using RTK Query's hooks and endpoint parameters.</p> Fetch paginated posts services/api.jscomponents/Posts.js <pre><code>// services/api.js\nexport const api = createApi({\n    reducerPath: 'api',\n    baseQuery: fetchBaseQuery({ baseUrl: 'https://jsonplaceholder.typicode.com' }),\n    endpoints: (builder) =&gt; ({\n        getPosts: builder.query({\n            query: (page = 1) =&gt; `/posts?_page=${page}&amp;_limit=5`, // Implement pagination via query params\n        }),\n    }),\n});\n\nexport const { useGetPostsQuery } = api;\n</code></pre> <pre><code>// components/Posts.js\nimport React, { useState } from 'react';\nimport { useGetPostsQuery } from '../services/api';\n\nconst Posts = () =&gt; {\n    const [page, setPage] = useState(1);\n    const { data, error, isLoading } = useGetPostsQuery(page);\n\n    const loadMore = () =&gt; setPage(page + 1);\n\n    if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Posts (Page {page})&lt;/h1&gt;\n            &lt;ul&gt;\n                {data?.map((post) =&gt; (\n                &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n            &lt;button onClick={loadMore}&gt;Load More&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Posts;\n</code></pre> <ol> <li>Mutations with RTK Query</li> </ol> <p>You can use <code>mutations</code> for creating, updating, or deleting resources. For example, creating a new post.</p> Post a new item using mutation services/api.jscomponents/CreatePost.js <pre><code>// services/api.js\nexport const api = createApi({\n    reducerPath: 'api',\n    baseQuery: fetchBaseQuery({ baseUrl: 'https://jsonplaceholder.typicode.com' }),\n    endpoints: (builder) =&gt; ({\n        createPost: builder.mutation({\n        query: (newPost) =&gt; ({\n            url: '/posts',\n            method: 'POST',\n            body: newPost,\n        }),\n        }),\n    }),\n});\n\nexport const { useCreatePostMutation } = api;\n</code></pre> <pre><code>// components/CreatePost.js\nimport React, { useState } from 'react';\nimport { useCreatePostMutation } from '../services/api';\n\nconst CreatePost = () =&gt; {\n    const [title, setTitle] = useState('');\n    const [body, setBody] = useState('');\n    const [createPost, { isLoading, error }] = useCreatePostMutation();\n\n    const handleSubmit = async (e) =&gt; {\n        e.preventDefault();\n        await createPost({ title, body });\n        setTitle('');\n        setBody('');\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Create a Post&lt;/h1&gt;\n            {isLoading &amp;&amp; &lt;div&gt;Loading...&lt;/div&gt;}\n            {error &amp;&amp; &lt;div&gt;Error: {error.message}&lt;/div&gt;}\n\n            &lt;form onSubmit={handleSubmit}&gt;\n                &lt;input\n                    type=\"text\"\n                    placeholder=\"Title\"\n                    value={title}\n                    onChange={(e) =&gt; setTitle(e.target.value)}\n                /&gt;\n                &lt;textarea\n                    placeholder=\"Body\"\n                    value={body}\n                    onChange={(e) =&gt; setBody(e.target.value)}\n                /&gt;\n                &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n            &lt;/form&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default CreatePost;\n</code></pre> <p>6. Advanced Topics</p> Optimistic Updates <p>Optimistic updates allow you to immediately update the UI before the server responds. Useful for things like adding/deleting items where you want to show immediate feedback.</p> <pre><code>// services/api.js\nexport const api = createApi({\n    reducerPath: 'api',\n    baseQuery: fetchBaseQuery({ baseUrl: 'https://jsonplaceholder.typicode.com' }),\n    endpoints: (builder) =&gt; ({\n        deletePost: builder.mutation({\n            query: (postId) =&gt; ({\n                url: `/posts/${postId}`,\n                method: 'DELETE',\n            }),\n            // Optimistically update the cache by removing the deleted post immediately\n            async onQueryStarted(postId, { dispatch, queryFulfilled }) {\n                const patchResult = dispatch(\n                    api.util.updateQueryData('getPosts', undefined, (draft) =&gt; {\n                        return draft.filter((post) =&gt; post.id !== postId);\n                })\n                );\n                try {\n                    await queryFulfilled;\n                } catch {\n                    patchResult.undo();\n                }\n            },\n            }),\n    }),\n});\n\nexport const { useDeletePostMutation } = api;\n</code></pre> <p>7. Custom Base Query</p> <p>If you need more control over the API request (e.g., adding authentication headers), you can write a custom base query.</p> <pre><code>// services/api.js\nimport { createApi, fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\n\nconst customBaseQuery = async (args, api, extraOptions) =&gt; {\n  const token = localStorage.getItem(\"authToken\"); // Assume authentication token is stored\n  const headers = {\n    Authorization: `Bearer ${token}`,\n  };\n\n  const result = await fetchBaseQuery({\n    baseUrl: \"https://jsonplaceholder.typicode.com\",\n    headers,\n  })(args, api, extraOptions);\n\n  return result;\n};\n\nexport const api = createApi({\n  reducerPath: \"api\",\n  baseQuery: customBaseQuery,\n  endpoints: (builder) =&gt; ({\n    getPosts: builder.query({\n      query: () =&gt; \"/posts\",\n    }),\n  }),\n});\n\nexport const { useGetPostsQuery } = api;\n</code></pre> <p>Conclusion:</p> <p>These examples cover basic to advanced usage of RTK Query to manage API interactions in a Redux-powered React application. As you get more familiar with RTK Query, you can dive deeper into concepts like custom base queries, optimistic updates, caching strategies, pagination, and error handling.</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/code-modularity/","title":"Code Modularity","text":""},{"location":"frontend/state-management/redux/rtk/toolkit/code-modularity/#overview","title":"Overview","text":"<p>In Redux Toolkit, especially when using createSlice, the actions and the reducer logic are closely related. Here's a breakdown of how they are intertwined:</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/code-modularity/#how-actions-and-reducers-are-related","title":"How Actions and Reducers Are Related","text":"<ol> <li> <p>Action Creators: When you define a reducer function within <code>createSlice</code>, Redux Toolkit automatically generates action creators for each reducer. For example, if you define a reducer named <code>increment</code>, Redux Toolkit creates an action creator with the same name.</p> </li> <li> <p>Reducer Logic: The logic inside each reducer function dictates how the state changes in response to an action. For instance, in the <code>increment</code> reducer, the state is updated by incrementing a value.</p> </li> </ol> Example Breakdown <pre><code>import { createSlice } from '@reduxjs/toolkit';\n\nconst counterSlice = createSlice({\n    name: 'counter',\n    initialState: { value: 0 },\n    reducers: {\n        increment: (state) =&gt; {\n            state.value += 1; // This is the reducer logic\n        },\n        decrement: (state) =&gt; {\n            state.value -= 1; // This is the reducer logic\n        },\n        incrementByAmount: (state, action) =&gt; {\n            state.value += action.payload; // This is the reducer logic using action\n        },\n    },\n});\n\n// Action creators\n// Export actions\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions;\n\n// Export the reducer\nexport default counterSlice.reducer;\n</code></pre>"},{"location":"frontend/state-management/redux/rtk/toolkit/code-modularity/#code-modularity","title":"Code Modularity","text":"<p>When breaking the slice into multiple files, you could separate the action creators and reducer logic, but they are often used together. Here\u2019s how you might approach it:</p> <ul> <li>Reducer File: Contains the logic for updating the state.</li> <li>Action File: Defines and exports the action creators.</li> </ul> <p>If you want to separate them, it can look like this:</p> 1. Reducer File:2. Actions File: <pre><code>// counterReducer.js\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst counterSlice = createSlice({\n    name: 'counter',\n    initialState: { value: 0 },\n    reducers: {\n        increment: (state) =&gt; {\n            state.value += 1;\n        },\n        decrement: (state) =&gt; {\n            state.value -= 1;\n        },\n        incrementByAmount: (state, action) =&gt; {\n            state.value += action.payload;\n        },\n    },\n});\n\nexport default counterSlice.reducer;\n</code></pre> <pre><code>// counterActions.js\nimport { createAction } from '@reduxjs/toolkit';\n\nexport const increment = createAction('counter/increment');\nexport const decrement = createAction('counter/decrement');\nexport const incrementByAmount = createAction('counter/incrementByAmount');\n</code></pre>"},{"location":"frontend/state-management/redux/rtk/toolkit/code-modularity/#conclusion","title":"Conclusion","text":"<p>While the actions and reducers are related, they can be separated for clarity in larger applications. This modular approach helps maintain organization, but for many projects, keeping them together in a slice is often simpler and more straightforward. It depends on the complexity and scale of your application.</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/code-modularity/#additional","title":"Additional","text":"<p>Is creating a separate action file in Redux Toolkit beneficial ot unnecessary ?</p> <p>Creating a separate action file in Redux Toolkit can be both beneficial and unnecessary, depending on the scale and complexity of your application. Here are some considerations to help you decide whether it\u2019s a good practice for your project:</p> When It\u2019s a Good PracticeWhen It Might Be Unnecessary <ol> <li> <p>Complex Applications: If your application has many actions, separating them into their own file can improve readability and maintainability. It can help avoid clutter in the slice file.</p> </li> <li> <p>Reusability: If you have actions that need to be used in multiple places or modules, defining them in a separate file makes them easier to import and reuse.</p> </li> <li> <p>Clear Organization: For larger codebases, having a clear structure helps team members understand where to find specific logic, making onboarding and collaboration smoother.</p> </li> <li> <p>Testing: Isolating actions can facilitate testing. You can test action creators independently of the slice logic.</p> </li> </ol> <ol> <li> <p>Simple Applications: If your application is small and only has a few actions, keeping them within the slice can simplify the code and reduce the number of files to manage.</p> </li> <li> <p>Standard Slice Usage: Redux Toolkit is designed to work well with slices. Since createSlice generates action creators automatically, separating them might add unnecessary boilerplate.</p> </li> <li> <p>Action Overhead: For simple state changes, creating separate action files might introduce extra complexity without significant benefits.</p> </li> </ol> <p>Example Scenario</p> <ul> <li> <p>Good Practice: If you have a <code>counterSlice.js</code> with multiple actions related to different features (like adding, subtracting, resetting), creating a separate <code>counterActions.js</code> might be wise.</p> </li> <li> <p>Unnecessary: For a small application with a single slice and a couple of actions, keeping everything in one place would be more straightforward.</p> </li> </ul> <p>Conclusion</p> <p>Ultimately, whether to create separate action files in Redux Toolkit depends on your project\u2019s specific needs. If you anticipate growth or want a clean organizational structure, it can be a good practice. If you\u2019re working on a small project, it might be more efficient to keep everything together.</p> <p>Adapting to your team's preferences and the project's complexity is key. If you have any further questions or need examples, feel free to ask!</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/code-modularity/#suggested-structure-for-a-slice","title":"Suggested Structure for a Slice","text":"<pre><code>my-app/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 features/\n\u2502   \u2502   \u251c\u2500\u2500 counter/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 counterSlice.js\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 counterActions.js\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 counterSelectors.js\n\u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u2514\u2500\u2500 ...\n</code></pre> <p>Breakdown of the Files</p> counterSlice.jscounterActions.jscounterSelectors.js <ol> <li> <p><code>counterSlice.js</code>: This file contains the slice definition, including the initial state and the reducers.</p> <pre><code>// src/features/counter/counterSlice.js\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst initialState = {\n    value: 0,\n};\n\nconst counterSlice = createSlice({\n    name: 'counter',\n    initialState,\n    reducers: {\n        increment: (state) =&gt; {\n            state.value += 1;\n        },\n        decrement: (state) =&gt; {\n            state.value -= 1;\n        },\n        incrementByAmount: (state, action) =&gt; {\n            state.value += action.payload;\n        },\n    },\n});\n\n// Export the reducer\nexport default counterSlice.reducer;\n</code></pre> </li> </ol> <ol> <li> <p><code>counterActions.js</code>: This file can contain exported action creators, which can be useful for grouping related actions.</p> <pre><code>// src/features/counter/counterActions.js\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst counterSlice = createSlice({\n    name: 'counter',\n    initialState: { value: 0 },\n    reducers: {\n        increment: (state) =&gt; {\n            state.value += 1;\n        },\n        decrement: (state) =&gt; {\n            state.value -= 1;\n        },\n        incrementByAmount: (state, action) =&gt; {\n            state.value += action.payload;\n        },\n    },\n});\n\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions;\n</code></pre> </li> </ol> <ol> <li> <p><code>counterSelectors.js</code>: This file can contain selector functions that encapsulate the logic for retrieving specific parts of the state.</p> <pre><code>// src/features/counter/counterSelectors.js\nexport const selectCount = (state) =&gt; state.counter.value;\n</code></pre> </li> </ol> <p>How to Use in Your Component</p> <p>Now, in your component, you would import these parts accordingly:</p> <pre><code>// src/components/Counter.js\nimport React from \"react\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport {\n  increment,\n  decrement,\n  incrementByAmount,\n} from \"../features/counter/counterActions\";\nimport { selectCount } from \"../features/counter/counterSelectors\";\n\nconst Counter = () =&gt; {\n  const count = useSelector(selectCount);\n  const dispatch = useDispatch();\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Count: {count}&lt;/h1&gt;\n      &lt;button onClick={() =&gt; dispatch(increment())}&gt;Increment&lt;/button&gt;\n      &lt;button onClick={() =&gt; dispatch(decrement())}&gt;Decrement&lt;/button&gt;\n      &lt;button onClick={() =&gt; dispatch(incrementByAmount(5))}&gt;\n        Increment by 5\n      &lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default Counter;\n</code></pre> <p>Summary</p> <ul> <li>Modularization: Breaking down the slice into multiple files helps in maintaining and scaling your codebase.</li> <li>Separation of Concerns: This approach provides a clear separation of actions, selectors, and slice definitions.</li> <li>Standard Practice: While it might not be strictly necessary for smaller applications, for larger codebases, this modular approach is considered a best practice.</li> </ul>"},{"location":"frontend/state-management/redux/rtk/toolkit/folder-structure/","title":"Folder Structure","text":""},{"location":"frontend/state-management/redux/rtk/toolkit/folder-structure/#basic-redux-toolkit-rtk-folder-structure","title":"Basic Redux Toolkit (RTK) Folder Structure","text":"<p>A basic folder structure using Redux Toolkit might look something like this:</p> <pre><code>src/\n\u2502\n\u251c\u2500\u2500 app/\n\u2502   \u2514\u2500\u2500 store.js\n\u2502\n\u251c\u2500\u2500 features/\n\u2502   \u2514\u2500\u2500 counter/\n\u2502       \u251c\u2500\u2500 counterSlice.js\n\u2502       \u2514\u2500\u2500 Counter.js\n\u2502\n\u251c\u2500\u2500 App.js\n\u2514\u2500\u2500 index.js\n</code></pre> Example store.jscounterSlice.jsCounter.jsApp.jsindex.js <pre><code>// src/app/store.js\n\nimport { configureStore } from '@reduxjs/toolkit';\nimport counterReducer from '../features/counter/counterSlice';\n\nexport const store = configureStore({\n    reducer: {\n        counter: counterReducer,\n    },\n});\n</code></pre> <pre><code>// src/features/counter/counterSlice.js\n\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst counterSlice = createSlice({\n    name: 'counter',\n    initialState: {\n        value: 0,\n    },\n    reducers: {\n        increment: (state) =&gt; {\n            state.value += 1;\n        },\n        decrement: (state) =&gt; {\n            state.value -= 1;\n        },\n        incrementByAmount: (state, action) =&gt; {\n            state.value += action.payload;\n        },\n    },\n});\n\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions;\n\nexport default counterSlice.reducer;\n</code></pre> <pre><code>import React from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { increment, decrement, incrementByAmount } from './counterSlice';\n\nconst Counter = () =&gt; {\n    const count = useSelector((state) =&gt; state.counter.value);\n    const dispatch = useDispatch();\n\n    return (\n        &lt;div&gt;\n            &lt;div&gt;\n                &lt;button\n                    aria-label=\"Increment value\"\n                    onClick={() =&gt; dispatch(increment())}\n                &gt;\n                +\n                &lt;/button&gt;\n\n                &lt;span&gt;{count}&lt;/span&gt;\n\n                &lt;button\n                    aria-label=\"Decrement value\"\n                    onClick={() =&gt; dispatch(decrement())}\n                &gt;\n                -\n                &lt;/button&gt;\n            &lt;/div&gt;\n\n            &lt;div&gt;\n                &lt;button\n                    onClick={() =&gt; dispatch(incrementByAmount(5))}\n                &gt;\n                    Increment by 5\n                &lt;/button&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Counter;\n</code></pre> <pre><code>// src/App.js\n\nimport React from 'react';\nimport Counter from './features/counter/Counter';\n\nconst App = () =&gt; (\n    &lt;div&gt;\n        &lt;h1&gt;Counter App&lt;/h1&gt;\n        &lt;Counter /&gt;\n    &lt;/div&gt;\n);\n\nexport default App;\n</code></pre> <pre><code>// src/index.js\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport { store } from './app/store';\nimport App from './App';\n\nReactDOM.render(\n    &lt;Provider store={store}&gt;\n        &lt;App /&gt;\n    &lt;/Provider&gt;,\n    document.getElementById('root')\n);\n</code></pre>"},{"location":"frontend/state-management/redux/rtk/toolkit/folder-structure/#advanced-redux-toolkit-rtk-folder-structure","title":"Advanced Redux Toolkit (RTK) Folder Structure","text":"<p>For a more complex application, the folder structure can be expanded to include additional features such as authentication, API calls, and more modular organization.</p> <pre><code>src/\n\u2502\n\u251c\u2500\u2500 app/\n\u2502   \u2514\u2500\u2500 store.js\n\u2502\n\u251c\u2500\u2500 features/\n\u2502   \u251c\u2500\u2500 auth/\n\u2502   \u2502   \u251c\u2500\u2500 authSlice.js\n\u2502   \u2502   \u251c\u2500\u2500 Login.js\n\u2502   \u2502   \u2514\u2500\u2500 Register.js\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 counter/\n\u2502   \u2502   \u251c\u2500\u2500 counterSlice.js\n\u2502   \u2502   \u2514\u2500\u2500 Counter.js\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 api/\n\u2502   \u2502   \u2514\u2500\u2500 apiSlice.js\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 user/\n\u2502       \u251c\u2500\u2500 userSlice.js\n\u2502       \u2514\u2500\u2500 UserProfile.js\n\u2502\n\u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 Navbar.js\n\u2502   \u2514\u2500\u2500 PrivateRoute.js\n\u2502\n\u251c\u2500\u2500 utils/\n\u2502   \u251c\u2500\u2500 authUtils.js\n\u2502   \u2514\u2500\u2500 apiUtils.js\n\u2502\n\u251c\u2500\u2500 App.js\n\u2514\u2500\u2500 index.js\n</code></pre> Example store.jsauthSlice.jsapiSlice.jsuserSlice.jsPrivateRoute.jsauthUtils.js <pre><code>// src/app/store.js\n\nimport { configureStore } from '@reduxjs/toolkit';\nimport counterReducer from '../features/counter/counterSlice';\nimport authReducer from '../features/auth/authSlice';\nimport userReducer from '../features/user/userSlice';\nimport { apiSlice } from '../features/api/apiSlice';\n\nexport const store = configureStore({\n    reducer: {\n        counter: counterReducer,\n        auth: authReducer,\n        user: userReducer,\n        [apiSlice.reducerPath]: apiSlice.reducer,\n    },\n    middleware: (getDefaultMiddleware) =&gt;\n        getDefaultMiddleware().concat(apiSlice.middleware),\n});\n</code></pre> <pre><code>// src/features/auth/authSlice.js\n\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport axios from 'axios';\n\nexport const login = createAsyncThunk('auth/login', async (credentials) =&gt; {\n    const response = await axios.post('/api/auth/login', credentials);\n    return response.data;\n});\n\nconst authSlice = createSlice({\n    name: 'auth',\n    initialState: {\n        user: null,\n        token: null,\n        status: 'idle',\n        error: null,\n    },\n    reducers: {\n        logout: (state) =&gt; {\n            state.user = null;\n            state.token = null;\n        },\n    },\n    extraReducers: (builder) =&gt; {\n        builder\n        .addCase(login.pending, (state) =&gt; {\n            state.status = 'loading';\n        })\n        .addCase(login.fulfilled, (state, action) =&gt; {\n            state.status = 'succeeded';\n            state.user = action.payload.user;\n            state.token = action.payload.token;\n        })\n        .addCase(login.rejected, (state, action) =&gt; {\n            state.status = 'failed';\n            state.error = action.error.message;\n        });\n    },\n});\n\nexport const { logout } = authSlice.actions;\n\nexport default authSlice.reducer;\n</code></pre> <pre><code>// src/features/api/apiSlice.js\n\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';\n\nexport const apiSlice = createApi({\n    reducerPath: 'api',\n    baseQuery: fetchBaseQuery({ baseUrl: '/api' }),\n    endpoints: (builder) =&gt; ({\n            getUserById: builder.query({\n            query: (id) =&gt; `user/${id}`,\n            }),\n            updateUser: builder.mutation({\n            query: (user) =&gt; ({\n                url: `user/${user.id}`,\n                method: 'PUT',\n                body: user,\n            }),\n        }),\n    }),\n});\n\nexport const { useGetUserByIdQuery, useUpdateUserMutation } = apiSlice;\n</code></pre> <pre><code>// src/features/user/userSlice.js\n\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst userSlice = createSlice({\n    name: 'user',\n    initialState: {\n        profile: null,\n    },\n    reducers: {\n        setProfile: (state, action) =&gt; {\n            state.profile = action.payload;\n        },\n    },\n});\n\nexport const { setProfile } = userSlice.actions;\n\nexport default userSlice.reducer;\n</code></pre> <pre><code>// src/components/PrivateRoute.js\nimport React from 'react';\nimport { Route, Redirect } from 'react-router-dom';\nimport { useSelector } from 'react-redux';\n\nconst PrivateRoute = ({ component: Component, ...rest }) =&gt; {\n    const { token } = useSelector((state) =&gt; state.auth);\n\n    return (\n        &lt;Route\n            {...rest}\n            render={(props) =&gt;\n                token ? &lt;Component {...props} /&gt; : &lt;Redirect to=\"/login\" /&gt;\n            }\n        /&gt;\n    );\n};\n\nexport default PrivateRoute;\n</code></pre> <pre><code>// src/utils/authUtils.js\n\nexport const isAuthenticated = () =&gt; {\n    const token = localStorage.getItem('token');\n    return !!token;\n};\n\nexport const getToken = () =&gt; {\n    return localStorage.getItem('token');\n};\n</code></pre> <p>Summary</p> <ul> <li>Basic Structure: Simple setup with essential files and folders.</li> <li>Advanced Structure: More complex organization with features, components, and utility functions separated into dedicated folders.</li> </ul> <p>By organizing your project in this way, you can scale your application more effectively and maintain a clean and manageable codebase.</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/folder-structure/#more-advanced","title":"More Advanced","text":"<pre><code>src/\n\u2502\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 store.js\n\u2502   \u2514\u2500\u2500 rootReducer.js\n\u2502\n\u251c\u2500\u2500 features/\n\u2502   \u251c\u2500\u2500 auth/\n\u2502   \u2502   \u251c\u2500\u2500 authApi.js\n\u2502   \u2502   \u251c\u2500\u2500 authSlice.js\n\u2502   \u2502   \u251c\u2500\u2500 Login.js\n\u2502   \u2502   \u2514\u2500\u2500 Register.js\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 counter/\n\u2502   \u2502   \u251c\u2500\u2500 counterApi.js\n\u2502   \u2502   \u251c\u2500\u2500 counterSlice.js\n\u2502   \u2502   \u2514\u2500\u2500 Counter.js\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 user/\n\u2502   \u2502   \u251c\u2500\u2500 userApi.js\n\u2502   \u2502   \u251c\u2500\u2500 userSlice.js\n\u2502   \u2502   \u251c\u2500\u2500 UserProfile.js\n\u2502   \u2502   \u2514\u2500\u2500 UserList.js\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 dashboard/\n\u2502   \u2502   \u251c\u2500\u2500 dashboardApi.js\n\u2502   \u2502   \u251c\u2500\u2500 dashboardSlice.js\n\u2502   \u2502   \u2514\u2500\u2500 Dashboard.js\n\u2502\n\u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 Navbar.js\n\u2502   \u2514\u2500\u2500 PrivateRoute.js\n\u2502\n\u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 api.js\n\u2502   \u251c\u2500\u2500 auth.js\n\u2502   \u2514\u2500\u2500 user.js\n\u2502\n\u251c\u2500\u2500 utils/\n\u2502   \u251c\u2500\u2500 authUtils.js\n\u2502   \u2514\u2500\u2500 apiUtils.js\n\u2502\n\u251c\u2500\u2500 hooks/\n\u2502   \u2514\u2500\u2500 useAuth.js\n\u2502\n\u251c\u2500\u2500 App.js\n\u2514\u2500\u2500 index.js\n</code></pre> Example store.jsrootReducer.js <pre><code>// src/app/store.js\n\nimport { configureStore } from '@reduxjs/toolkit';\nimport rootReducer from './rootReducer';\n\nexport const store = configureStore({\n    reducer: rootReducer,\n    middleware: (getDefaultMiddleware) =&gt;\n        getDefaultMiddleware().concat(),\n});\n</code></pre> <pre><code>// src/app/rootReducer.js\n\nimport { combineReducers } from 'redux';\nimport authReducer from '../features/auth/authSlice';\nimport counterReducer from '../features/counter/counterSlice';\nimport userReducer from '../features/user/userSlice';\nimport dashboardReducer from '../features/dashboard/dashboardSlice';\n\nconst rootReducer = combineReducers({\n    auth: authReducer,\n    counter: counterReducer,\n    user: userReducer,\n    dashboard: dashboardReducer,\n});\n\nexport default rootReducer;\n</code></pre> <p>Feature Slices and APIs</p> Example authSlice.jsauthApi.jsDashboard.jsx <pre><code>// src/features/auth/authSlice.js\n\nimport { createSlice } from '@reduxjs/toolkit';\nimport { login } from './authApi';\n\nconst authSlice = createSlice({\n    name: 'auth',\n    initialState: {\n        user: null,\n        token: null,\n        status: 'idle',\n        error: null,\n    },\n    reducers: {\n        logout: (state) =&gt; {\n        state.user = null;\n        state.token = null;\n        },\n    },\n    extraReducers: (builder) =&gt; {\n        builder\n        .addCase(login.pending, (state) =&gt; {\n            state.status = 'loading';\n        })\n        .addCase(login.fulfilled, (state, action) =&gt; {\n            state.status = 'succeeded';\n            state.user = action.payload.user;\n            state.token = action.payload.token;\n        })\n        .addCase(login.rejected, (state, action) =&gt; {\n            state.status = 'failed';\n            state.error = action.error.message;\n        });\n    },\n});\n\nexport const { logout } = authSlice.actions;\n\nexport default authSlice.reducer;\n</code></pre> <pre><code>// src/features/auth/authApi.js\n\nimport { createAsyncThunk } from '@reduxjs/toolkit';\nimport axios from 'axios';\n\nexport const login = createAsyncThunk('auth/login', async (credentials) =&gt; {\n    const response = await axios.post('/api/auth/login', credentials);\n    return response.data;\n});\n</code></pre> <pre><code>// src/features/dashboard/Dashbaord.jsx\nimport { useSelector } from 'react-redux';\n\nconst Dashboard = () =&gt; {\n    const { user } = useSelector((state) =&gt; state.auth);\n\n    return (\n        &lt;div className=\"dashboard-container\"&gt;\n        &lt;h1&gt;Welcome to your Dashboard, {user?.name}!&lt;/h1&gt;\n        &lt;p&gt;This is a protected route. Only authenticated users can see this.&lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Dashboard;\n</code></pre> <p>Centralized API Service</p> Example api.jsauth.js <pre><code>// src/services/api.js\n\nimport axios from 'axios';\n\nconst apiClient = axios.create({\n    baseURL: '/api',\n    headers: {\n        'Content-Type': 'application/json',\n    },\n});\n\nexport const setAuthToken = (token) =&gt; {\n    if (token) {\n        apiClient.defaults.headers.common['Authorization'] = `Bearer ${token}`;\n    } else {\n        delete apiClient.defaults.headers.common['Authorization'];\n    }\n};\n\nexport default apiClient;\n</code></pre> <pre><code>// src/services/auth.js\n\nimport apiClient from './api';\n\nexport const login = (credentials) =&gt; {\n    return apiClient.post('/auth/login', credentials);\n};\n\nexport const register = (userData) =&gt; {\n    return apiClient.post('/auth/register', userData);\n};\n</code></pre> <p>Utility Functions</p> Example authUtils.js <pre><code>// src/utils/authUtils.js\n\nexport const isAuthenticated = () =&gt; {\n    const token = localStorage.getItem('token');\n    return !!token;\n};\n\nexport const getToken = () =&gt; {\n    return localStorage.getItem('token');\n};\n</code></pre> <p>Custom Hooks</p> Example useAuth.js <pre><code>// src/hooks/useAuth.js\n\nimport { useSelector } from 'react-redux';\n\nconst useAuth = () =&gt; {\n    const { user, token } = useSelector((state) =&gt; state.auth);\n    return { user, token };\n};\n\nexport default useAuth;\n</code></pre> Example App.jsxmain.jsx <pre><code>// src/App.jsx\nimport { BrowserRouter as Router, Routes, Route } from 'react-router-dom';\nimport Login from './features/auth/login.jsx';\nimport Dashboard from './features/dashboard/Dashboard.jsx';\nimport PrivateRoute from './components/PrivateRoute.jsx';\nimport Navbar from './components/Navbar.jsx';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;div&gt;\n            &lt;Navbar /&gt;\n            &lt;Routes&gt;\n                &lt;Route path=\"/login\" element={&lt;Login /&gt;} /&gt;\n                &lt;PrivateRoute path=\"/dashboard\" component={Dashboard} /&gt;\n            &lt;/Routes&gt;\n        &lt;/div&gt;\n    &lt;/Router&gt;\n);\n\nexport default App;\n</code></pre> <pre><code>// src/main.jsx\n\nimport React from 'react'\nimport ReactDOM from 'react-dom/client'\nimport { Provider } from 'react-redux';\nimport { store } from './app/store';\nimport App from './App.jsx'\nimport './index.css'\n\nReactDOM.createRoot(document.getElementById('root')).render(\n    &lt;Provider store={store}&gt;\n        &lt;React.StrictMode&gt;\n            &lt;App /&gt;\n        &lt;/React.StrictMode&gt;\n    &lt;/Provider&gt;\n)\n</code></pre> <p>Components</p> Navbar.jsxPrivateRoute.jsx <pre><code>// components/Navbar.jsx\nimport { Link } from 'react-router-dom';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { logout } from '../features/auth/authSlice';\n\nconst Navbar = () =&gt; {\n    const dispatch = useDispatch();\n    const { user } = useSelector((state) =&gt; state.auth);\n\n    const handleLogout = () =&gt; {\n        dispatch(logout());\n    };\n\n    return (\n        &lt;nav&gt;\n            &lt;Link to=\"/\"&gt;Home&lt;/Link&gt;\n            {user ? (\n                &lt;&gt;\n                    &lt;Link to=\"/dashboard\"&gt;Dashboard&lt;/Link&gt;\n                    &lt;button onClick={handleLogout}&gt;Logout&lt;/button&gt;\n                &lt;/&gt;\n            ) : (\n                &lt;Link to=\"/login\"&gt;Login&lt;/Link&gt;\n            )}\n        &lt;/nav&gt;\n    );\n};\n\nexport default Navbar;\n</code></pre> <pre><code>// components/PrivateRoute.jsx\n\nimport { Route, Navigate } from 'react-router-dom';\nimport { useSelector } from 'react-redux';\nimport PropTypes from 'prop-types';\n\nconst PrivateRoute = ({ component: Component, ...rest }) =&gt; {\n    const { token } = useSelector((state) =&gt; state.auth);\n\n    return (\n        &lt;Route\n            {...rest}\n            element={token ? &lt;Component /&gt; : &lt;Navigate to=\"/login\" /&gt;}\n        /&gt;\n    );\n};\n\nPrivateRoute.propTypes = {\n    component: PropTypes.elementType.isRequired,\n};\n\nexport default PrivateRoute;\n</code></pre> <p>Summary</p> <ul> <li>Modular Structure: Break down features into separate folders, each containing related slices, API calls, and components.</li> <li>Centralized API Service: Use a single api.js file to configure and manage API calls.</li> <li>Custom Hooks: Create custom hooks for reusable logic.</li> <li>Utility Functions: Use utility functions to manage common operations.</li> </ul> <p>Benefits of this Approach</p> <ol> <li>Scalability: Easy to add new features without disrupting the existing codebase.</li> <li>Maintainability: Clear separation of concerns makes it easier to maintain and update the code.</li> <li>Reusability: Common logic and utilities are centralized, promoting code reuse.</li> <li>Extensibility: Easily extend the application by adding new features, APIs, and components.</li> </ol> <p>By following this modular approach, you can manage a large codebase effectively, ensuring that your application remains organized and maintainable as it grows.</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/intro/","title":"Intro","text":""},{"location":"frontend/state-management/redux/rtk/toolkit/intro/#overview","title":"Overview","text":"<p>To master Redux Toolkit (RTK) and become a top developer, you should focus on the following key areas:</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/intro/#1-understanding-redux-core-concepts","title":"1. Understanding Redux Core Concepts","text":"<ul> <li>Actions, Reducers, and Store: Have a solid grasp of how the Redux flow works, including the role of actions, reducers, and the store.</li> <li>Immutable State: Know how to update state immutably and how RTK simplifies this with <code>createSlice()</code>.</li> </ul>"},{"location":"frontend/state-management/redux/rtk/toolkit/intro/#2-rtk-apis-and-features","title":"2. RTK APIs and Features","text":"<ul> <li><code>createSlice</code>: Master the <code>createSlice()</code> function, which combines actions and reducers, streamlining the Redux workflow.</li> <li><code>createAsyncThunk</code>: Learn to handle asynchronous operations (like API calls) elegantly with <code>createAsyncThunk()</code>.</li> <li>RTK Query: Familiarize yourself with RTK Query to manage data fetching, caching, and synchronization in a declarative way.</li> <li><code>configureStore</code>: Understand how to configure the store with built-in middleware like <code>redux-thunk</code>, and add your own custom middleware if needed.</li> </ul>"},{"location":"frontend/state-management/redux/rtk/toolkit/intro/#3-selectors-and-memoization","title":"3. Selectors and Memoization","text":"<ul> <li>Use selectors to retrieve data from the Redux store efficiently.</li> <li>Learn how to optimize performance using memoized selectors with <code>reselect</code> to avoid unnecessary re-renders.</li> </ul>"},{"location":"frontend/state-management/redux/rtk/toolkit/intro/#4-middleware-and-side-effects","title":"4. Middleware and Side Effects","text":"<ul> <li>Learn how Redux middleware works and master custom middleware to handle complex side effects.</li> <li>Understand how tools like Redux Thunk and Redux-Saga integrate for handling side effects asynchronously.</li> </ul>"},{"location":"frontend/state-management/redux/rtk/toolkit/intro/#5-typescript-with-rtk","title":"5. TypeScript with RTK","text":"<ul> <li>Get comfortable using TypeScript with Redux Toolkit, including typing the state, actions, and thunks to reduce bugs and improve maintainability.</li> </ul>"},{"location":"frontend/state-management/redux/rtk/toolkit/intro/#6-code-structuring-and-best-practices","title":"6. Code Structuring and Best Practices","text":"<ul> <li>Organize your Redux logic (slices, actions, thunks) into well-structured, scalable modules.   Follow the Ducks pattern or other organization patterns to keep Redux code modular and maintainable.</li> </ul>"},{"location":"frontend/state-management/redux/rtk/toolkit/intro/#7-testing-redux","title":"7. Testing Redux","text":"<ul> <li>Write unit tests for reducers, selectors, and async thunks.</li> <li>Learn how to use tools like Jest and React Testing Library to test Redux logic and components integrated with Redux.</li> </ul>"},{"location":"frontend/state-management/redux/rtk/toolkit/intro/#8-performance-optimization","title":"8. Performance Optimization","text":"<ul> <li>Learn how to prevent unnecessary renders with efficient state updates and memoization.</li> <li>Understand how to use tools like Redux DevTools to monitor state changes and improve performance.</li> </ul>"},{"location":"frontend/state-management/redux/rtk/toolkit/intro/#9-debugging-and-developer-tools","title":"9. Debugging and Developer Tools","text":"<ul> <li>Master Redux DevTools for debugging your state, actions, and time travel debugging.</li> <li>Use logging middleware or <code>console.log()</code> effectively to trace issues.</li> </ul>"},{"location":"frontend/state-management/redux/rtk/toolkit/intro/#10-interoperability-with-other-libraries","title":"10. Interoperability with Other Libraries","text":"<ul> <li>Understand how Redux can integrate with React Router, Axios, or other third-party libraries.</li> <li>Ensure you can handle complex scenarios like server-side rendering (SSR) with Redux.</li> </ul> <p>By mastering these concepts and staying updated with the latest features, you'll have the skill set to leverage Redux Toolkit at an expert level.</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/intro/#reference","title":"Reference","text":"<ul> <li>redux-thunk: github</li> <li>Redux docs: Writing Logic with Thunks</li> <li>Stack Overflow: Dispatching Redux Actions with a Timeout</li> <li>Stack Overflow: Why do we need middleware for async flow in Redux?</li> <li>What the heck is a \"thunk\"?</li> <li>Thunks in Redux: The Basics</li> </ul>"},{"location":"frontend/state-management/redux/rtk/toolkit/topic/","title":"Topic","text":"<p>To master Redux Toolkit, there are several key concepts and components you should be familiar with. Here\u2019s a breakdown of the main topics to focus on:</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/topic/#1-core-concepts-of-redux","title":"1. Core Concepts of Redux","text":"<ul> <li>Store: Understand what a Redux store is and how it holds the state of your application.</li> <li>State: Learn how to structure your state and why immutability is important.</li> <li>Actions: Familiarize yourself with actions as plain objects that describe changes to the state.</li> <li>Reducers: Understand how reducers are pure functions that take the current state and an action to return a new state.</li> </ul>"},{"location":"frontend/state-management/redux/rtk/toolkit/topic/#2-redux-toolkit-basics","title":"2. Redux Toolkit Basics","text":"<ul> <li>Installation and Setup: Know how to set up a new project with Redux Toolkit and configure the store using <code>configureStore</code>.</li> <li>createSlice: Learn how to use <code>createSlice</code> to create reducers and action creators in a concise way.</li> </ul>"},{"location":"frontend/state-management/redux/rtk/toolkit/topic/#3-middleware","title":"3. Middleware","text":"<ul> <li>Built-in Middleware: Understand the default middleware included with Redux Toolkit (like Redux Thunk) and how to apply custom middleware using <code>getDefaultMiddleware</code>.</li> <li>Custom Middleware: Know how to create and integrate your own middleware for logging, error handling, etc.</li> </ul>"},{"location":"frontend/state-management/redux/rtk/toolkit/topic/#4-async-logic","title":"4. Async Logic","text":"<ul> <li>createAsyncThunk: Learn how to handle asynchronous actions with <code>createAsyncThunk</code>, which simplifies the process of making API calls or handling async logic.</li> <li>extraReducers: Understand how to manage the lifecycle of asynchronous actions using <code>extraReducers</code> in slices.</li> </ul>"},{"location":"frontend/state-management/redux/rtk/toolkit/topic/#5-selectors","title":"5. Selectors","text":"<ul> <li>Creating Selectors: Know how to create and use selectors to access specific parts of the state.</li> <li>Memoization: Familiarize yourself with using libraries like Reselect for optimizing selector performance.</li> </ul>"},{"location":"frontend/state-management/redux/rtk/toolkit/topic/#6-typescript-support","title":"6. TypeScript Support","text":"<ul> <li>If you're using TypeScript, understand how to type your state, actions, and reducers in Redux Toolkit. Redux Toolkit provides good TypeScript support out of the box.</li> </ul>"},{"location":"frontend/state-management/redux/rtk/toolkit/topic/#7-best-practices","title":"7. Best Practices","text":"<ul> <li>Structuring Your Store: Learn how to organize your slices and reducers effectively, especially in larger applications.   Testing: Understand how to test your slices, reducers, and components that connect to Redux.</li> </ul>"},{"location":"frontend/state-management/redux/rtk/toolkit/topic/#8-integration-with-react","title":"8. Integration with React","text":"<ul> <li>React-Redux: Familiarize yourself with the React-Redux library for connecting your components to the Redux store.</li> <li>useSelector and useDispatch Hooks: Learn how to use these hooks to read from and dispatch actions to the Redux store.</li> </ul>"},{"location":"frontend/state-management/redux/rtk/toolkit/topic/#9-performance-optimization","title":"9. Performance Optimization","text":"<ul> <li>Batching Updates: Understand how to minimize re-renders and optimize performance in your React components connected to Redux.</li> <li>Redux DevTools: Learn how to use Redux DevTools for debugging your application state.</li> </ul>"},{"location":"frontend/state-management/redux/rtk/toolkit/topic/#10-advanced-patterns","title":"10. Advanced Patterns","text":"<ul> <li>Entity Management: Explore patterns for managing collections of entities (like normalizing state).</li> <li>Dynamic Slices: Understand how to create slices dynamically if your application requires it.</li> </ul>"},{"location":"frontend/state-management/redux/rtk/toolkit/topic/#summary","title":"Summary","text":"<p>Mastering these topics will give you a solid foundation in Redux Toolkit and help you build scalable, maintainable applications. As you dive deeper, working on real projects and experimenting with these concepts will solidify your understanding.</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/topic/#reference","title":"Reference","text":"<ul> <li>Quick Start</li> </ul>"},{"location":"frontend/state-management/redux/rtk/toolkit/ultimate/","title":"Utltimate","text":""},{"location":"frontend/state-management/redux/rtk/toolkit/ultimate/#axios-config","title":"Axios Config","text":"<p>Creating a reusable config for your Axios requests can help streamline your API interactions and maintain consistency across your application. Here\u2019s how you can do it:</p> <pre><code>// axiosConfig.js\nimport axios from \"axios\";\n\nconst defaultBaseConfig = {\n  headers: {\n    \"Content-Type\": \"application/json\",\n  },\n  timeout: 10000, // Default timeout of 10 seconds\n};\n\nconst defaultBlogConfig = {\n  headers: {\n    \"Content-Type\": \"application/json\",\n  },\n  timeout: 10000,\n};\n\nconst axiosInstance = {\n  base: axios.create({\n    baseURL: process.env.REACT_APP_BASE_API_URL,\n    ...defaultBaseConfig,\n  }),\n  blog: axios.create({\n    baseURL: process.env.REACT_APP_BLOG_API_URL,\n    ...defaultBlogConfig,\n  }),\n};\n\nexport default axiosInstance;\n</code></pre> 1. Create a Default Axios Configuration2. Centralize Configuration in a Service <p>You can create a default configuration object that includes common headers, base URL, and other settings. This can be extended or overridden on a per-request basis.</p> <pre><code>// axiosConfig.js\nimport axios from \"axios\";\n\nconst defaultConfig = {\n    baseURL: process.env.REACT_APP_BASE_API_URL,\n    headers: {\n        'Content-Type': 'application/json',\n    },\n    timeout: 10000, // Default timeout of 10 seconds\n};\n\nconst axiosInstance = axios.create(defaultConfig);\n\nexport default axiosInstance;\n</code></pre> <p>You can create a service that provides a reusable configuration function. This function can generate specific configurations based on the needs of each request.</p> <pre><code>// dataService.js\nimport axiosInstance from \"./axiosConfig\";\n\nconst createRequestConfig = (overrideConfig = {}) =&gt; {\n    return {\n        headers: {\n            ...axiosInstance.defaults.headers,\n            ...overrideConfig.headers,\n        },\n        timeout: overrideConfig.timeout || axiosInstance.defaults.timeout,\n        // Add more common settings as needed\n        ...overrideConfig,\n    };\n};\n\nexport const fetchData = (url, signal, config = {}) =&gt; {\n    console.log(\"fetchData called with URL:\", url); // Debug log\n    const requestConfig = createRequestConfig(config);\n\n    return axiosInstance.get(url, {\n        cancelToken: signal,\n        ...requestConfig,\n    });\n};\n</code></pre> <p>how to separate axios config</p> <p>1. Create a Configuration File for Axios Instances</p> <p>You can create separate configuration files for different Axios instances. This way, each instance can have its own specific settings and configurations.</p> <p>Separating your Axios configuration can help improve the organization and maintainability of your code. Here\u2019s how you can structure your project to keep the Axios configuration modular and clean.</p> Example Structure <pre><code>src/\n\u2502\n\u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 axios/\n\u2502   \u2502   \u251c\u2500\u2500 axiosBaseConfig.js\n\u2502   \u2502   \u251c\u2500\u2500 axiosBlogConfig.js\n\u2502   \u2502   \u251c\u2500\u2500 axiosInstance.js\n\u2502   \u2502   \u2514\u2500\u2500 axiosInterceptors.js\n\u2502   \u2514\u2500\u2500 dataService.js\n\u2514\u2500\u2500 ...\n</code></pre> <p>2. Create Base and Blog Configuration Files</p> <p>You can define your base and blog configurations in their respective files.</p> axiosBaseConfig.jsaxiosBlogConfig.js <pre><code>import axios from \"axios\";\n\nconst baseConfig = {\n    baseURL: process.env.REACT_APP_BASE_API_URL,\n    headers: {\n        'Content-Type': 'application/json',\n    },\n    timeout: 10000, // Default timeout of 10 seconds\n};\n\nconst axiosBase = axios.create(baseConfig);\n\nexport default axiosBase;\n</code></pre> <pre><code>import axios from \"axios\";\n\nconst blogConfig = {\n    baseURL: process.env.REACT_APP_BLOG_API_URL,\n    headers: {\n        'Content-Type': 'application/json',\n    },\n    timeout: 10000, // Default timeout of 10 seconds\n};\n\nconst axiosBlog = axios.create(blogConfig);\n\nexport default axiosBlog;\n</code></pre> <p>3. Create a Central Instance File</p> <p>You can then create an <code>axiosInstance.js</code> file that imports both configurations and exports them together.</p> axiosInstance.js <pre><code>import axiosBase from './axiosBaseConfig';\nimport axiosBlog from './axiosBlogConfig';\n\nconst axiosInstance = {\n    base: axiosBase,\n    blog: axiosBlog,\n};\n\nexport default axiosInstance;\n</code></pre> <p>4. Set Up Interceptors</p> <p>If you have interceptors that need to apply to both instances, you can create a separate file for them.</p> axiosInterceptors.js <pre><code>import axiosInstance from \"./axiosInstance\";\n\nconst apiKey = process.env.REACT_APP_API_KEY;\n\naxiosInstance.base.interceptors.request.use(\n    (config) =&gt; {\n        console.log(\"Request made to BASE API:\", config.url);\n        return config;\n    },\n    (error) =&gt; {\n        console.error(\"Interceptor error:\", error);\n        return Promise.reject(error);\n    }\n);\n\naxiosInstance.blog.interceptors.request.use(\n    (config) =&gt; {\n        if (apiKey) {\n        config.headers[\"Authorization\"] = `Api-Key ${apiKey}`;\n        }\n        console.log(\"Request made to BLOG API:\", config.url);\n        return config;\n    },\n    (error) =&gt; {\n        console.error(\"Interceptor error:\", error);\n        return Promise.reject(error);\n    }\n    );\n</code></pre> <p>5. Update Your Data Service</p> <p>Now, update your <code>dataService.js</code> to use the centralized <code>axiosInstance</code>.</p> dataService.js <pre><code>import axiosInstance from \"./axios/axiosInstance\";\n\nconst fetchData = (url, signal, instanceType = 'base', config = {}) =&gt; {\n    const instance = instanceType === 'blog' ? axiosInstance.blog : axiosInstance.base;\n\n    console.log(\"fetchData called with URL:\", url); // Debug log\n    return instance.get(url, {\n        cancelToken: signal,\n        ...config,\n    });\n};\n\nexport { fetchData };\n</code></pre> <p>6. Using the Service</p> <p>You can now use the <code>fetchData</code> function with your specified instance type:</p> Example <pre><code>const fetchPosts = async (signal) =&gt; {\n    try {\n        const data = await fetchData(\"/posts\", signal);\n        console.log(data);\n    } catch (error) {\n        console.error(\"Error fetching posts:\", error);\n    }\n};\n\n// Call the function\nfetchPosts(axios.CancelToken.source().token);\n</code></pre>"},{"location":"frontend/state-management/redux/rtk/toolkit/ultimate/#service","title":"Service","text":"<p>To separate the HTTP methods (<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>) into different files, you can create a dedicated service for each method. This will help keep your code organized and maintainable. Here\u2019s how to structure your files:</p> <p>Step 1: Create a Services Directory</p> <p>Create a new directory in your project, e.g., <code>src/services</code>, where you will place your HTTP method files.</p> <p>Step 2: Create Service Files</p> <p>You can create separate files for each HTTP method. Here's how you can structure them:</p> 1. GET Requests2. POST Requests3. PUT Requests4. DELETE Requests <p>Create a file called <code>getService.js</code>:</p> <pre><code>// src/services/getService.js\nimport axiosInstance from '../axiosInstance';\n\nexport const fetchData = async (endpoint) =&gt; {\n    const response = await axiosInstance.base.get(endpoint);\n    return response.data;\n};\n\nexport const fetchBlogPosts = async (endpoint) =&gt; {\n    const response = await axiosInstance.blog.get(endpoint);\n    return response.data;\n};\n</code></pre> <p>Create a file called <code>postService.js</code>:</p> <pre><code>// src/services/postService.js\nimport axiosInstance from '../axiosInstance';\n\nexport const createData = async (endpoint, data) =&gt; {\n    const response = await axiosInstance.base.post(endpoint, data);\n    return response.data;\n};\n\nexport const createBlogPost = async (endpoint, data) =&gt; {\n    const response = await axiosInstance.blog.post(endpoint, data);\n    return response.data;\n};\n</code></pre> <p>Create a file called <code>putService.js</code>:</p> <pre><code>// src/services/putService.js\nimport axiosInstance from '../axiosInstance';\n\nexport const updateData = async (endpoint, data) =&gt; {\n    const response = await axiosInstance.base.put(endpoint, data);\n    return response.data;\n};\n\nexport const updateBlogPost = async (endpoint, data) =&gt; {\n    const response = await axiosInstance.blog.put(endpoint, data);\n    return response.data;\n};\n</code></pre> <p>Create a file called <code>deleteService.js</code>:</p> <pre><code>// src/services/deleteService.js\nimport axiosInstance from '../axiosInstance';\n\nexport const deleteData = async (endpoint) =&gt; {\n    const response = await axiosInstance.base.delete(endpoint);\n    return response.data;\n};\n\nexport const deleteBlogPost = async (endpoint) =&gt; {\n    const response = await axiosInstance.blog.delete(endpoint);\n    return response.data;\n};\n</code></pre> <p>Step 3: Using the Services in Your Slices</p> <p>Now you can use these services in your Redux Toolkit slices. Here\u2019s how you would update the base and blog slices to utilize these services:</p> Example for Base Slice with GETExample for Blog Slice with POST <pre><code>// features/baseSlice.js\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { fetchData } from '../services/getService';\n\nexport const fetchBaseData = createAsyncThunk(\n    'base/fetchData',\n    async () =&gt; {\n        const data = await fetchData('/data'); // Adjust the endpoint\n        return data;\n    }\n);\n\n//... rest of the slice as before\n</code></pre> <pre><code>// features/blogSlice.js\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { createBlogPost } from '../services/postService';\n\nexport const addBlogPost = createAsyncThunk(\n    'blog/addPost',\n    async (newPost) =&gt; {\n        const data = await createBlogPost('/posts', newPost); // Adjust the endpoint\n        return data;\n    }\n);\n\n//... rest of the slice as before\n</code></pre> <p>Conclusion</p> <p>By separating your HTTP methods into different service files, you enhance the organization and readability of your code. Each service file handles its respective HTTP method, making it easier to maintain and test. You can follow a similar structure for other HTTP methods as needed.</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/ultimate/#questions","title":"Questions","text":""},{"location":"frontend/state-management/redux/rtk/toolkit/ultimate/#question-1","title":"Question 1","text":"<pre><code>// features/baseSlice.js\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { fetchData } from '../services/getService';\n\nexport const fetchBaseData = createAsyncThunk(\n  'base/fetchData',\n  async () =&gt; {\n    const data = await fetchData('/data'); // Adjust the endpoint\n    return data;\n  }\n);\n\n\n// servces/getService.js\nimport axiosInstance from \"./axiosInstance\";\n\n// Base\nexport const createData = async (endpoint, data) =&gt; {\n  const response = await axiosInstance.base.post(endpoint, data);\n  return response.data;\n};\n\n\ndo we need to async await both in the createAsyncThunk in slice and async await in slice getService. or we don't need async await in getService because we have already use the asyc await in slice.\n</code></pre> <p>Yes, you need the <code>async/await</code> in both places for different reasons:</p> <ol> <li> <p>In the <code>createAsyncThunk</code>: This is where you're defining the asynchronous action. The <code>async</code> keyword allows you to use <code>await</code> within that function to handle the asynchronous operation (in this case, fetching data from your API).</p> </li> <li> <p>In the <code>getService</code>: The <code>createData</code> function is also an asynchronous function that performs its own asynchronous operation (making an API request). Using <code>await</code> here ensures that you wait for the API call to complete and return the response data before proceeding.</p> </li> </ol> <p>In summary, each function manages its own asynchronous operations, so you need to keep the <code>async/await</code> in both the <code>createAsyncThunk</code> and your service functions.</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/ultimate/#canceltoken","title":"CancelToken","text":"<p>so how to use axios cancelToken in getService</p> <p>To use Axios' <code>CancelToken</code> for cancelling requests in your <code>getService</code> functions, you can follow these steps:</p> <ul> <li>Create a cancel token when you initiate the request.</li> <li>Pass the cancel token to the Axios request.</li> <li>Handle the cancellation as needed in your code.</li> </ul> getService.js <pre><code>import axiosInstance from \"./axiosInstance\";\nimport { CancelToken } from 'axios';\n\n// Base\nexport const createData = async (endpoint, data, cancelToken) =&gt; {\n    const response = await axiosInstance.base.post(endpoint, data, {\n        cancelToken,\n    });\n    return response.data;\n};\n</code></pre>"},{"location":"frontend/state-management/redux/rtk/toolkit/ultimate/#question-3","title":"Question 3","text":"<p>Your code for fetching data and handling API calls looks solid, but there are opportunities to enhance readability, maintainability, and functionality. Here are some suggestions:</p> <p>1. Centralize API URL Management</p> <p>Instead of hardcoding the endpoints in your <code>apiForDashboardTodo</code> and <code>apiForDashboardPicture</code> functions, consider creating a centralized configuration for your API endpoints. This will make it easier to manage and update in the future.</p> <pre><code>// apiConfig.js\nexport const API_ENDPOINTS = {\n  posts: \"/posts\",\n  albumPhotos: \"/albums/1/photos\",\n};\n\n// dashboard/api.js\nimport { postData, fetchData } from \"../../services/dataService\";\nimport { API_ENDPOINTS } from \"./apiConfig\";\n\nexport const apiForDashboardTodo = (signal) =&gt; {\n  return fetchData(API_ENDPOINTS.posts, signal);\n};\n\nexport const apiForDashboardPicture = (signal) =&gt; {\n  return fetchData(API_ENDPOINTS.albumPhotos, signal);\n};\n</code></pre> <p>2. Improve Fetch Functionality</p> <p>You might want to consider adding additional parameters to the fetchData function to allow for more flexibility, such as custom headers or query parameters.</p> <pre><code>export const fetchData = (url, signal, config = {}) =&gt; {\n  console.log(\"fetchData called with URL:\", url); // Debug log\n  return axiosInstance.base.get(url, {\n    cancelToken: signal,\n    ...config, // Allow for additional config options\n  });\n};\n</code></pre> <p>3. Handle Response Transformation and Errors</p> <p>Consider adding response interceptors in your <code>axiosInterceptors.js</code>for handling transformations and errors globally.</p> <pre><code>axiosInstance.base.interceptors.response.use(\n  (response) =&gt; {\n    // Transform or process response data if needed\n    return response.data; // Return only the data\n  },\n  (error) =&gt; {\n    console.error(\"Response error:\", error);\n    return Promise.reject(error); // Propagate error for handling in calling functions\n  }\n);\n</code></pre> <p>Use <code>Async/Await</code> for API Calls</p> <p>When you consume these API functions, consider using <code>async/await</code> for better readability, especially if you need to handle responses or errors.</p> <pre><code>const fetchDataFromAPI = async () =&gt; {\n  const signal = axios.CancelToken.source().token; // Create cancel token\n  try {\n    const todos = await apiForDashboardTodo(signal);\n    const pictures = await apiForDashboardPicture(signal);\n    // Process the data as needed\n  } catch (error) {\n    console.error(\"Error fetching data:\", error);\n  }\n};\n</code></pre>"},{"location":"frontend/state-management/redux/rtk/toolkit/example/example/","title":"Intro","text":""},{"location":"frontend/state-management/redux/rtk/toolkit/example/example/#basic-example","title":"Basic Example","text":"<p>Here's a modular setup for a simple counter application using Redux Toolkit and React-Redux. We will structure the code in separate files to keep it organized.</p> <p>Project Structure</p> <pre><code>my-app/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 app/\n\u2502   \u2502   \u2514\u2500\u2500 store.js\n\u2502   \u251c\u2500\u2500 features/\n\u2502   \u2502   \u2514\u2500\u2500 counterSlice.js\n\u2502   \u251c\u2500\u2500 components/\n\u2502   \u2502   \u2514\u2500\u2500 Counter.js\n\u2502   \u251c\u2500\u2500 App.js\n\u2502   \u251c\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 ...\n</code></pre> store.jscounterSlice.jsCounter.jsApp.jsindex.js <ol> <li> <p>Create Redux Store (<code>store.js</code>)</p> <p>Create the file <code>src/app/store.js</code>:</p> <pre><code>import { configureStore } from '@reduxjs/toolkit';\nimport counterReducer from '../features/counterSlice';\n\nconst store = configureStore({\n    reducer: {\n        counter: counterReducer,\n    },\n});\n\nexport default store;\n</code></pre> </li> </ol> <ol> <li> <p>Create Counter Slice (<code>counterSlice.js</code>)</p> <p>Create the file <code>src/features/counterSlice.js</code>:</p> <pre><code>import { createSlice } from '@reduxjs/toolkit';\n\nconst initialState = {\n    value: 0,\n};\n\nexport const counterSlice = createSlice({\n    name: 'counter',\n    initialState,\n    reducers: {\n        increment: (state) =&gt; {\n            state.value += 1;\n        },\n        decrement: (state) =&gt; {\n            state.value -= 1;\n        },\n        incrementByAmount: (state, action) =&gt; {\n            state.value += action.payload;\n        },\n    },\n});\n\n// Export actions\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions;\n\n// Export the reducer\nexport default counterSlice.reducer;\n</code></pre> </li> </ol> <ol> <li> <p>Create Counter Component (<code>Counter.js</code>)</p> <p>Create the file <code>src/components/Counter.js</code>:</p> <pre><code>import React from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { increment, decrement, incrementByAmount } from '../features/counterSlice';\n\nconst Counter = () =&gt; {\n    const count = useSelector((state) =&gt; state.counter.value);\n    const dispatch = useDispatch();\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Count: {count}&lt;/h1&gt;\n            &lt;button onClick={() =&gt; dispatch(increment())}&gt;Increment&lt;/button&gt;\n            &lt;button onClick={() =&gt; dispatch(decrement())}&gt;Decrement&lt;/button&gt;\n            &lt;button onClick={() =&gt; dispatch(incrementByAmount(5))}&gt;Increment by 5&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Counter;\n</code></pre> </li> </ol> <ol> <li> <p>Set Up the Main App Component (<code>App.js</code>)</p> <p>Modify the file <code>src/App.js</code>:</p> <pre><code>import React from 'react';\nimport Counter from './components/Counter';\n\nconst App = () =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Redux Toolkit Counter Example&lt;/h1&gt;\n            &lt;Counter /&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default App;\n</code></pre> </li> </ol> <ol> <li> <p>Wrap the Application with Provider (<code>index.js</code>)</p> <p>Modify the file <code>src/index.js</code>:</p> <pre><code>import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport App from './App';\nimport { Provider } from 'react-redux';\nimport store from './app/store';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\n    root.render(\n    &lt;Provider store={store}&gt;\n        &lt;App /&gt;\n    &lt;/Provider&gt;\n);\n</code></pre> </li> </ol> <p>Summary</p> <p>In this modular setup:</p> <ul> <li>Store: Defined in <code>store.js</code>, which configures the Redux store.</li> <li>Slice: The <code>counterSlice.js</code> file defines the state, actions, and reducer.</li> <li>Component: The <code>Counter.js</code> file uses hooks to access the Redux state and dispatch actions.</li> <li>App Component: The <code>App.js</code> file serves as the main component that includes the <code>Counter</code>.</li> </ul> <p>This organization helps keep your code clean and maintainable, especially as your application grows.</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/example/example/#additional","title":"Additional","text":"<p>where is action here, and reducer?</p> <p>Let\u2019s break down your <code>counterSlice.js</code> code to clarify where the actions and the reducer are defined and how they work.</p> ActionsReducerSummary <p>In Redux, actions are payloads of information that send data from your application to the Redux store. In your <code>counterSlice.js</code>, the actions are created automatically by <code>createSlice</code>.</p> <p>Here\u2019s how it works:</p> <ol> <li> <p>Define Actions: Inside the <code>reducers</code> object of <code>createSlice</code>, you define functions for each action you want. In your code, you have:</p> <ul> <li><code>increment</code></li> <li><code>decrement</code></li> <li><code>incrementByAmount</code></li> </ul> </li> <li> <p>Export Actions: When you call <code>createSlice</code>, it generates action creators for each of these reducers. You export them like this:</p> <pre><code>export const { increment, decrement, incrementByAmount } = counterSlice.actions;\n</code></pre> </li> </ol> <p>The reducer is a function that determines how the state changes in response to actions. In your <code>counterSlice.js</code>, the reducer is also created automatically by <code>createSlice</code>.</p> <ol> <li> <p>Generated Reducer: The <code>createSlice</code> function creates a reducer based on the functions defined in the <code>reducers</code> object. This reducer handles updates to the state based on the actions dispatched.</p> </li> <li> <p>Export the Reducer: You export the reducer with this line:</p> <pre><code>export default counterSlice.reducer;\n</code></pre> </li> </ol> <ul> <li>Actions: The actions are the functions you defined in the <code>reducers</code> object. They are automatically turned into action creators by <code>createSlice</code> and can be dispatched to update the state.</li> <li>Reducer: The <code>createSlice</code> function generates a reducer that you export, which handles how the state should change based on the actions dispatched.</li> </ul> <p>Example of Using Actions and Reducer</p> <p>Here\u2019s how you would use them in a React component:</p> 1. Dispatching Actions2. Using the Reducer in the Store <pre><code>import { useDispatch } from 'react-redux';\nimport { increment, decrement, incrementByAmount } from './features/counterSlice';\n\nconst MyComponent = () =&gt; {\n    const dispatch = useDispatch();\n\n    return (\n        &lt;&gt;\n        &lt;button onClick={() =&gt; dispatch(increment())}&gt;Increment&lt;/button&gt;\n        &lt;button onClick={() =&gt; dispatch(decrement())}&gt;Decrement&lt;/button&gt;\n        &lt;button onClick={() =&gt; dispatch(incrementByAmount(5))}&gt;Increment by 5&lt;/button&gt;\n        &lt;/&gt;\n    );\n};\n</code></pre> <p>When you set up your Redux store, you include this reducer:</p> <pre><code>import { configureStore } from '@reduxjs/toolkit';\nimport counterReducer from '../features/counterSlice';\n\nconst store = configureStore({\n    reducer: {\n        counter: counterReducer, // This is where the reducer is used\n    },\n});\n\nexport default store;\n</code></pre> <p>This structure allows your application to respond to user actions by updating the state in a predictable way.</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/middleware/intro/","title":"Intro","text":"<p>RTK (Redux Toolkit) middleware is a powerful feature that allows you to extend Redux's capabilities by adding custom behavior to the dispatch process. Middleware can intercept actions before they reach the reducer, enabling you to handle side effects, logging, error reporting, and more.</p> explain to 5 years old <p>Imagine you have a toy box, and every time you want to play, you ask your helper to get a toy for you.</p> <p>Middleware is like that helper. When you ask for a toy (like getting some information), the helper makes sure everything goes smoothly. It can even do some extra things, like making sure the toy is clean before giving it to you or telling you if the toy is broken.</p> <p>In Redux Toolkit, middleware helps handle special tasks (like fetching data) when your app needs to change things. It makes sure everything is done right before you see the results!</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/middleware/setup/","title":"Setup","text":"<p>Redux Thunk is a middleware for async actions</p> <p>You can log the result of <code>configureStore</code> to see its properties, including the middleware and any other configurations. However, since <code>configureStore</code> returns a store object, you won't see the middleware directly. Instead, you can inspect the store object for its properties.</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/middleware/setup/#example-of-logging-configurestore","title":"Example of Logging configureStore","text":"<p>Here\u2019s how you can log the configured store:</p> <pre><code>import { configureStore } from \"@reduxjs/toolkit\";\nimport userReducer from \"./userSlice\"; // Adjust the path accordingly\n\nconst store = configureStore({\n  reducer: {\n    users: userReducer, // Your slice reducer\n  },\n  // You can also add middleware here if needed\n});\n\n// Log the store\nconsole.log(store);\n</code></pre>"},{"location":"frontend/state-management/redux/rtk/toolkit/middleware/setup/#what-you-can-see","title":"What You Can See","text":"<p>When you log the store, you\u2019ll see various properties, such as:</p> <ul> <li><code>dispatch</code>: The dispatch function to send actions to the store.</li> <li><code>getState</code>: A function to access the current state.</li> <li><code>subscribe</code>: A function to listen for changes to the store.</li> <li><code>replaceReducer</code>: A method to replace the current reducer.</li> </ul>"},{"location":"frontend/state-management/redux/rtk/toolkit/middleware/setup/#checking-middleware","title":"Checking Middleware","text":"<p>To see the middleware specifically, you can inspect the store using the Redux DevTools extension in your browser. This tool will show you dispatched actions and the state changes, giving you insight into how the middleware is working.</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/middleware/setup/#redux-toolkit-consolelog","title":"Redux Toolkit <code>console.log</code>","text":"<p>To find out how many utility functions are available in a library like Redux Toolkit, you typically look at the library\u2019s documentation or its source code. However, you can also explore the library's exports using JavaScript. Here\u2019s how you can do that:</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/middleware/setup/#1-check-the-documentation","title":"1. Check the Documentation","text":"<p>The first and best way to find available utility functions is to check the Redux Toolkit documentation. It provides detailed information about the various functions, hooks, and utilities you can use.</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/middleware/setup/#2-log-all-exports","title":"2. Log All Exports","text":"<p>If you want to explore the available functions programmatically, you can log the exports from the Redux Toolkit module. Here\u2019s how to do it:</p> <p>Example: Logging Available Functions</p> <ol> <li>Import the Module: First, import the entire module.</li> <li>Log the Exports: Use <code>console.log</code> to inspect them.</li> </ol> <pre><code>import * as reduxToolkit from \"@reduxjs/toolkit\";\n\n// Log all available exports\nconsole.log(\"Redux Toolkit Exports:\", reduxToolkit);\n</code></pre>"},{"location":"frontend/state-management/redux/rtk/toolkit/middleware/setup/#3-explore-the-logged-object","title":"3. Explore the Logged Object","text":"<p>In the console, you can expand the reduxToolkit object to see all available functions.</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/middleware/setup/#4-using-objectkeys","title":"4. Using <code>Object.keys</code>","text":"<p>If you just want to see the names of the available functions, you can use <code>Object.keys</code>:</p> <pre><code>import * as reduxToolkit from \"@reduxjs/toolkit\";\n\nconst toolkitFunctions = Object.keys(reduxToolkit);\nconsole.log(\"Available Redux Toolkit Functions:\", toolkitFunctions);\n</code></pre> <p>This will give you an array of strings, where each string is the name of an exportable function.</p> Summary <ol> <li>Check Documentation: Always start with the official documentation for the most reliable information.</li> <li>Log Exports: Use <code>console.log</code> to log the entire Redux Toolkit module.</li> <li>Explore: Expand the logged object in the console to see available functions.</li> <li>List Function Names: Use <code>Object.keys</code> to get a simple list of function names.</li> </ol>"},{"location":"frontend/state-management/redux/rtk/toolkit/questions/a.how-to-right-question/","title":"Intro","text":"<p>.....correct me with right question and right answer</p> <p></p> <p></p>"},{"location":"frontend/state-management/redux/rtk/toolkit/questions/how-action-types-are-managed-in-redux-toolkit/","title":"How action types are managed","text":""},{"location":"frontend/state-management/redux/rtk/toolkit/questions/how-action-types-are-managed-in-redux-toolkit/#overview","title":"Overview","text":"<p>In Redux Toolkit, you generally don't need to define action types as separate constants like you do in standard Redux. When you use <code>createSlice</code>, it automatically generates action types based on the names of the reducers you define. Here\u2019s how it works:</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/questions/how-action-types-are-managed-in-redux-toolkit/#how-action-types-are-managed-in-redux-toolkit","title":"How Action Types Are Managed in Redux Toolkit","text":"<ol> <li> <p>Automatic Generation: When you create a slice using <code>createSlice</code>, the action types are automatically created using the format <code>sliceName/actionName</code>. For example, if your slice is named \"<code>counter</code>\" and you have an action called \"<code>increment</code>\", the action type will be \"<code>counter/increment</code>\".</p> </li> <li> <p>No Need for Constants: Because the action types are generated automatically, you don't have to define them as constants manually. This reduces boilerplate code.</p> </li> </ol>"},{"location":"frontend/state-management/redux/rtk/toolkit/questions/how-action-types-are-managed-in-redux-toolkit/#example","title":"Example","text":"<p>Here\u2019s a simple example to illustrate:</p> <pre><code>// counterSlice.js\nimport { createSlice } from \"@reduxjs/toolkit\";\n\nconst counterSlice = createSlice({\n  name: \"counter\",\n  initialState: { value: 0 },\n  reducers: {\n    increment: (state) =&gt; {\n      state.value += 1; // No need to define the action type as a constant\n    },\n    decrement: (state) =&gt; {\n      state.value -= 1;\n    },\n  },\n});\n\n// Action creators are automatically generated\nexport const { increment, decrement } = counterSlice.actions;\n\n// The action types are automatically created:\n// increment -&gt; \"counter/increment\"\n// decrement -&gt; \"counter/decrement\"\n\n// Export the reducer\nexport default counterSlice.reducer;\n</code></pre>"},{"location":"frontend/state-management/redux/rtk/toolkit/questions/how-action-types-are-managed-in-redux-toolkit/#summary","title":"Summary","text":"<ul> <li>No Manual Action Types: You don\u2019t need to define action types manually in Redux Toolkit, which simplifies your code.</li> <li>Automatic Action Type Generation: Action types are generated based on the slice name and reducer names, making it clear and easy to understand.</li> </ul> <p>This design choice in Redux Toolkit aims to reduce boilerplate and make it easier to manage state in applications.</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/questions/how-action-types-are-managed-in-redux-toolkit/#additional","title":"Additional","text":"<p>so this name: 'counter' is important and should be unique, am i correct</p> <p>Yes, you are correct! The <code>name</code> property in <code>createSlice</code> is important and should be unique within your application. Here\u2019s why:</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/questions/how-action-types-are-managed-in-redux-toolkit/#importance-of-the-name-property","title":"Importance of the <code>name</code> Property","text":"<ol> <li> <p>Action Type Prefix: The <code>name</code> you provide becomes the prefix for the automatically generated action types. For example, if you name your slice \"<code>counter</code>\", the actions generated will be \"<code>counter/increment</code>\" and \"<code>counter/decrement</code>\". If you have another slice named \"<code>todos</code>\", its actions will be \"<code>todos/add</code>\" and \"<code>todos/remove</code>\". This helps avoid action name collisions.</p> </li> <li> <p>Clarity and Organization: A unique name helps clarify what the slice represents. It makes it easier to understand the purpose of the slice just by looking at the action types and helps in organizing your code, especially in larger applications.</p> </li> <li> <p>Avoiding Conflicts: If two slices have the same name, it can lead to confusion and unintended behavior, as their action types would clash. Keeping names unique helps prevent such conflicts.</p> </li> </ol>"},{"location":"frontend/state-management/redux/rtk/toolkit/questions/how-action-types-are-managed-in-redux-toolkit/#example_1","title":"Example","text":"<p>Here\u2019s an example demonstrating the importance of unique names:</p> <pre><code>// counterSlice.js\nimport { createSlice } from \"@reduxjs/toolkit\";\n\nconst counterSlice = createSlice({\n  name: \"counter\", // Unique name for the counter slice\n  initialState: { value: 0 },\n  reducers: {\n    increment: (state) =&gt; {\n      state.value += 1;\n    },\n    decrement: (state) =&gt; {\n      state.value -= 1;\n    },\n  },\n});\n\n// todosSlice.js\nconst todosSlice = createSlice({\n  name: \"todos\", // Unique name for the todos slice\n  initialState: { items: [] },\n  reducers: {\n    addTodo: (state, action) =&gt; {\n      state.items.push(action.payload);\n    },\n    removeTodo: (state, action) =&gt; {\n      state.items = state.items.filter((todo) =&gt; todo.id !== action.payload.id);\n    },\n  },\n});\n\n// Action types will be:\n// \"counter/increment\"\n// \"counter/decrement\"\n// \"todos/addTodo\"\n// \"todos/removeTodo\"\n</code></pre>"},{"location":"frontend/state-management/redux/rtk/toolkit/questions/how-action-types-are-managed-in-redux-toolkit/#summary_1","title":"Summary","text":"<ul> <li>Unique and Descriptive: Make sure the name is unique and descriptive of the slice's purpose.</li> <li>Prevents Clashes: Helps prevent naming conflicts in your action types.</li> </ul>"},{"location":"frontend/state-management/redux/rtk/toolkit/questions/how-does-redux-toolkit-use-default-thunk/","title":"How does Redux Toolkit use default thunk middleware","text":"<p>How does Redux Toolkit use default thunk middleware, and can you provide an example?</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/questions/how-does-redux-toolkit-use-default-thunk/#overview","title":"Overview","text":"<p>Redux Toolkit automatically applies thunk middleware when you create a store using <code>configureStore</code>. This allows you to write action creators that return functions (thunks) to handle asynchronous logic, like API calls.</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/questions/how-does-redux-toolkit-use-default-thunk/#example","title":"Example","text":"<p>Here's how you can use Redux Toolkit with default thunk middleware to manage an asynchronous API call:</p> <ol> <li> <p>Set Up Your Slice with Thunks: Create a slice that includes an asynchronous action creator using <code>createAsyncThunk</code> (which is built on top of thunk).</p> </li> <li> <p>Configure the Store: Use <code>configureStore</code> to create your Redux store.</p> </li> <li> <p>Dispatch the Thunk from a Component: Use the <code>useDispatch</code> hook in your React component to trigger the asynchronous action.</p> </li> </ol>"},{"location":"frontend/state-management/redux/rtk/toolkit/questions/how-does-redux-toolkit-use-default-thunk/#step-by-step-example","title":"Step-by-Step Example","text":"<ol> <li> <p>Create a Slice with Thunks</p> <pre><code>// usersSlice.js\nimport { createSlice, createAsyncThunk } from \"@reduxjs/toolkit\";\nimport axios from \"axios\";\n\n// Async thunk for fetching users\nexport const fetchUsers = createAsyncThunk(\"users/fetchUsers\", async () =&gt; {\n  const response = await axios.get(\n    \"https://jsonplaceholder.typicode.com/users\"\n  );\n  return response.data; // This will be the payload in the fulfilled action\n});\n\n// Create the users slice\nconst usersSlice = createSlice({\n  name: \"users\",\n  initialState: {\n    users: [],\n    loading: false,\n    error: null,\n  },\n  reducers: {},\n  extraReducers: (builder) =&gt; {\n    builder\n      .addCase(fetchUsers.pending, (state) =&gt; {\n        state.loading = true; // Set loading to true\n      })\n      .addCase(fetchUsers.fulfilled, (state, action) =&gt; {\n        state.loading = false; // Set loading to false\n        state.users = action.payload; // Store fetched users\n      })\n      .addCase(fetchUsers.rejected, (state, action) =&gt; {\n        state.loading = false; // Set loading to false\n        state.error = action.error.message; // Store error message\n      });\n  },\n});\n\n// Export the reducer\nexport default usersSlice.reducer;\n</code></pre> </li> <li> <p>Configure the Store</p> <pre><code>// store.js\nimport { configureStore } from \"@reduxjs/toolkit\";\nimport usersReducer from \"./usersSlice\";\n\nconst store = configureStore({\n  reducer: {\n    users: usersReducer, // Add users slice reducer\n  },\n});\n\nexport default store;\n</code></pre> </li> <li> <p>Use the Thunk in a Component</p> <pre><code>// UsersList.js\nimport React, { useEffect } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { fetchUsers } from \"./usersSlice\";\n\nconst UsersList = () =&gt; {\n  const dispatch = useDispatch();\n  const { users, loading, error } = useSelector((state) =&gt; state.users);\n\n  useEffect(() =&gt; {\n    dispatch(fetchUsers()); // Dispatch the thunk to fetch users\n  }, [dispatch]);\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;User List&lt;/h1&gt;\n      {loading &amp;&amp; &lt;p&gt;Loading...&lt;/p&gt;}\n      {error &amp;&amp; &lt;p&gt;Error: {error}&lt;/p&gt;}\n      &lt;ul&gt;\n        {users.map((user) =&gt; (\n          &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default UsersList;\n</code></pre> </li> </ol>"},{"location":"frontend/state-management/redux/rtk/toolkit/questions/how-does-redux-toolkit-use-default-thunk/#summary","title":"Summary","text":"<ul> <li>Default Thunk Middleware: Redux Toolkit automatically includes thunk middleware when using <code>configureStore</code>.</li> <li>Using Thunks: You create async action creators with <code>createAsyncThunk</code>, which can be dispatched like regular actions in your components.</li> </ul> <p>This example illustrates how Redux Toolkit leverages the default thunk middleware to handle asynchronous API calls seamlessly, providing a clean and organized way to manage state.</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/questions/is-it-mandatory-to-use-createasyncthunk-for-api-calls/","title":"Is it mandatory to use createAsyncThunk for API calls","text":"<p>Is it mandatory to use createAsyncThunk for API calls in Redux Toolkit?</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/questions/is-it-mandatory-to-use-createasyncthunk-for-api-calls/#overview","title":"Overview","text":"<p>No, it is not mandatory to use <code>createAsyncThunk</code> for API calls in Redux Toolkit. However, it is recommended for several reasons:</p> <ol> <li> <p>Simplifies Code: <code>createAsyncThunk</code> helps reduce boilerplate by automatically handling the pending, fulfilled, and rejected action states, making your code cleaner and more manageable.</p> </li> <li> <p>Consistent Error Handling: It provides a structured way to handle errors, which can improve the robustness of your application.</p> </li> <li> <p>Easier Integration: It seamlessly integrates with Redux Toolkit\u2019s slice structure, allowing for a more streamlined approach to state management.</p> </li> </ol>"},{"location":"frontend/state-management/redux/rtk/toolkit/questions/is-it-mandatory-to-use-createasyncthunk-for-api-calls/#alternatives-to-createasyncthunk","title":"Alternatives to createAsyncThunk:","text":"<p>While <code>createAsyncThunk</code> is highly beneficial, you can manage API calls using:</p> <ol> <li> <p>Custom Thunks: You can create your own thunk action creators using the <code>thunk</code> middleware without <code>createAsyncThunk</code>, though this requires more manual setup.</p> <pre><code>const fetchData = () =&gt; async (dispatch) =&gt; {\n  dispatch({ type: \"data/fetchStart\" });\n  try {\n    const response = await axios.get(\"/api/data\");\n    dispatch({ type: \"data/fetchSuccess\", payload: response.data });\n  } catch (error) {\n    dispatch({ type: \"data/fetchError\", payload: error.message });\n  }\n};\n</code></pre> </li> <li> <p>Direct API Calls in Components: You could also handle API calls directly within your React components using hooks like <code>useEffect</code>, but this approach can lead to tightly coupled components and less reusable code.</p> </li> </ol> <p>Conclusion</p> <p>While <code>createAsyncThunk</code> is not mandatory for API calls in Redux Toolkit, using it is a best practice that can simplify your code and improve the overall structure of your application.</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/questions/should-api-calls-be-in-same-file/","title":"Should API calls be in the same file","text":"<p>Should API calls be in the same file as the Redux slice, or is it better to separate them into different files? What is the standard practice?</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/questions/should-api-calls-be-in-same-file/#overview","title":"Overview","text":"<p>The standard practice is to separate API calls from the Redux slice. Here\u2019s why:</p> <ol> <li> <p>Separation of Concerns: Keeping API logic separate from state management logic promotes better organization and makes the code easier to maintain. It allows each part to evolve independently.</p> </li> <li> <p>Reusability: If API calls are separated, they can be reused across different slices or components without duplicating code.</p> </li> <li> <p>Testing: It\u2019s easier to test API functions independently from the slice, allowing for unit testing of each part.</p> </li> <li> <p>Readability: Separating concerns makes the code more readable. Developers can quickly understand where API calls are made and how they interact with the Redux state.</p> </li> </ol>"},{"location":"frontend/state-management/redux/rtk/toolkit/questions/should-api-calls-be-in-same-file/#example","title":"Example","text":"StructurepostsApi.jspostsSlice.jsComponent <p>Here\u2019s how you might organize the files:</p> <pre><code>/src\n    /api\n        postsApi.js        // Contains API call functions\n    /features\n        postsSlice.js      // Contains the slice and thunks\n</code></pre> <pre><code>import axios from 'axios';\n\nexport const fetchPostsApi = () =&gt; {\n    return axios.get('https://jsonplaceholder.typicode.com/posts');\n};\n\nexport const addPostApi = (newPost) =&gt; {\n    return axios.post('https://jsonplaceholder.typicode.com/posts', newPost);\n};\n\nexport const deletePostApi = (postId) =&gt; {\n    return axios.delete(`https://jsonplaceholder.typicode.com/posts/${postId}`);\n};\n</code></pre> <pre><code>import { createSlice, createAsyncThunk } from \"@reduxjs/toolkit\";\nimport { fetchPostsApi, addPostApi, deletePostApi } from \"../api/postsApi\";\n\n// Async thunk for fetching posts\nexport const fetchPosts = createAsyncThunk(\"posts/fetchPosts\", async () =&gt; {\n    const response = await fetchPostsApi();\n    return response.data;\n});\n\n// Async thunk for adding a post\nexport const addPost = createAsyncThunk(\"posts/addPost\", async (newPost) =&gt; {\n    const response = await addPostApi(newPost);\n    return response.data;\n});\n\n// Async thunk for deleting a post\nexport const deletePost = createAsyncThunk(\n    \"posts/deletePost\",\n    async (postId) =&gt; {\n        await deletePostApi(postId);\n        return postId;\n    }\n);\n\n// Create the posts slice (similar to previous example)\nconst postsSlice = createSlice({\n    name: \"posts\",\n    initialState: {\n        posts: [],\n        loading: false,\n        error: null,\n    },\n    reducers: {\n        // other reducers...\n    },\n    extraReducers: (builder) =&gt; {\n        // handle extra reducers...\n    },\n});\n\n// Export actions and reducer\nexport const { updatePost } = postsSlice.actions;\nexport default postsSlice.reducer;\n</code></pre> <pre><code>// Blog.js\nimport React, { useEffect, useState } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { fetchPosts, addPost, deletePost, updatePost } from './features/postsSlice';\n\nconst Blog = () =&gt; {\n    const dispatch = useDispatch();\n    const { posts, loading, error } = useSelector((state) =&gt; state.posts);\n    const [newPost, setNewPost] = useState({ title: '', body: '' });\n    const [editingPost, setEditingPost] = useState(null);\n\n    // Fetch posts when the component mounts\n    useEffect(() =&gt; {\n        dispatch(fetchPosts());\n    }, [dispatch]);\n\n    const handleAddPost = () =&gt; {\n        if (newPost.title &amp;&amp; newPost.body) {\n            dispatch(addPost(newPost));\n            setNewPost({ title: '', body: '' });\n        }\n    };\n\n    const handleUpdatePost = () =&gt; {\n        if (editingPost) {\n            dispatch(updatePost(editingPost));\n            setEditingPost(null);\n            setNewPost({ title: '', body: '' }); // Reset input fields\n        }\n    };\n\n    const handleEditClick = (post) =&gt; {\n        setEditingPost(post);\n        setNewPost({ title: post.title, body: post.body });\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Blog Posts&lt;/h1&gt;\n            {loading &amp;&amp; &lt;p&gt;Loading...&lt;/p&gt;}\n            {error &amp;&amp; &lt;p&gt;Error: {error}&lt;/p&gt;}\n            &lt;div&gt;\n                &lt;input\n                    value={newPost.title}\n                    onChange={(e) =&gt; setNewPost({ ...newPost, title: e.target.value })}\n                    placeholder=\"Title\"\n                /&gt;\n                &lt;textarea\n                    value={newPost.body}\n                    onChange={(e) =&gt; setNewPost({ ...newPost, body: e.target.value })}\n                    placeholder=\"Body\"\n                /&gt;\n                &lt;button onClick={editingPost ? handleUpdatePost : handleAddPost}&gt;\n                    {editingPost ? 'Update Post' : 'Add Post'}\n                &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;ul&gt;\n                {posts.map(post =&gt; (\n                    &lt;li key={post.id}&gt;\n                        &lt;h2&gt;{post.title}&lt;/h2&gt;\n                        &lt;p&gt;{post.body}&lt;/p&gt;\n                        &lt;button onClick={() =&gt; handleEditClick(post)}&gt;Edit&lt;/button&gt;\n                        &lt;button onClick={() =&gt; dispatch(deletePost(post.id))}&gt;Delete&lt;/button&gt;\n                    &lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Blog;\n</code></pre> <p>Conclusion</p> <p>Separating API calls into their own module is the standard practice. It enhances code maintainability, readability, and reusability, aligning with best practices in software development.</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/questions/what-are-thunk-action-creators/","title":"What are thunk action creators","text":"<p>What are thunk action creators, and does Redux Toolkit use thunk or saga by default?</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/questions/what-are-thunk-action-creators/#1-what-are-thunk-action-creators","title":"1. What are Thunk Action Creators?","text":"<ul> <li> <p>Thunk Action Creators are functions that return another function (the thunk) instead of a plain action object. This thunk can perform asynchronous operations, such as API calls, and then dispatch actions based on the results.</p> </li> <li> <p>In Redux, this allows for side effects like fetching data, waiting for promises to resolve, and conditionally dispatching actions based on the state.</p> </li> </ul> Example<pre><code>const fetchUser = (userId) =&gt; {\n  return async (dispatch) =&gt; {\n    dispatch({ type: \"USER_FETCH_REQUEST\" });\n    try {\n      const response = await fetch(`/api/users/${userId}`);\n      const data = await response.json();\n      dispatch({ type: \"USER_FETCH_SUCCESS\", payload: data });\n    } catch (error) {\n      dispatch({ type: \"USER_FETCH_FAILURE\", error: error.message });\n    }\n  };\n};\n</code></pre>"},{"location":"frontend/state-management/redux/rtk/toolkit/questions/what-are-thunk-action-creators/#2-does-redux-toolkit-use-thunk-or-saga-by-default","title":"2. Does Redux Toolkit Use Thunk or Saga by Default?","text":"<ul> <li>Redux Toolkit uses thunk middleware by default. This means when you create a store using <code>configureStore</code>, it automatically applies the thunk middleware, allowing you to use thunk action creators directly.</li> <li>Redux Saga is not included by default in Redux Toolkit, but it can be added as middleware if needed for handling more complex side effects or managing asynchronous flows.</li> </ul>"},{"location":"frontend/state-management/redux/rtk/toolkit/questions/what-are-thunk-action-creators/#summary","title":"Summary","text":"<ul> <li>Thunk Action Creators: Functions that return another function to handle asynchronous logic and side effects in Redux.</li> <li>Default Middleware: Redux Toolkit uses thunk middleware by default, while Redux Saga can be added as needed for more complex scenarios.</li> </ul> <p>This structure makes Redux Toolkit simpler and more accessible for most applications while still allowing for advanced patterns if required.</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/questions/where-do-we-define-action/","title":"Where do we define action","text":"<p>where do we defined the action in the standa redux vs redux toolk</p> <p>In both standard Redux and Redux Toolkit, actions are a crucial part of managing state, but they are defined and organized differently. Here\u2019s a breakdown of where and how actions are defined in each approach:</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/questions/where-do-we-define-action/#standard-redux","title":"Standard Redux","text":"<p>In standard Redux, actions are typically defined as follows:</p> <ol> <li> <p>Action Types: You define constant action types, usually in a separate file.</p> <pre><code>// actionTypes.js\nexport const INCREMENT = \"INCREMENT\";\nexport const DECREMENT = \"DECREMENT\";\n</code></pre> </li> <li> <p>Action Creators: You create action creators that return action objects. This is usually done in a separate file as well.</p> <pre><code>// actions.js\nimport { INCREMENT, DECREMENT } from \"./actionTypes\";\n\nexport const increment = () =&gt; ({\n  type: INCREMENT,\n});\n\nexport const decrement = () =&gt; ({\n  type: DECREMENT,\n});\n</code></pre> </li> <li> <p>Reducers: In the reducer, you handle the actions based on their type.</p> <pre><code>// reducer.js\nimport { INCREMENT, DECREMENT } from \"./actionTypes\";\n\nconst initialState = { value: 0 };\n\nconst counterReducer = (state = initialState, action) =&gt; {\n  switch (action.type) {\n    case INCREMENT:\n      return { ...state, value: state.value + 1 };\n    case DECREMENT:\n      return { ...state, value: state.value - 1 };\n    default:\n      return state;\n  }\n};\n\nexport default counterReducer;\n</code></pre> </li> </ol>"},{"location":"frontend/state-management/redux/rtk/toolkit/questions/where-do-we-define-action/#redux-toolkit","title":"Redux Toolkit","text":"<p>In Redux Toolkit, actions are defined differently using <code>createSlice</code>, which combines the action creator and reducer definitions into one:</p> <ol> <li> <p>Using <code>createSlice</code>: You define actions along with the reducer in a single slice file.</p> <pre><code>// counterSlice.js\nimport { createSlice } from \"@reduxjs/toolkit\";\n\nconst counterSlice = createSlice({\n  name: \"counter\",\n  initialState: { value: 0 },\n  reducers: {\n    increment: (state) =&gt; {\n      state.value += 1; // Directly mutating the state, thanks to Immer\n    },\n    decrement: (state) =&gt; {\n      state.value -= 1;\n    },\n  },\n});\n\n// Export actions\nexport const { increment, decrement } = counterSlice.actions;\n\n// Export the reducer\nexport default counterSlice.reducer;\n</code></pre> </li> </ol>"},{"location":"frontend/state-management/redux/rtk/toolkit/questions/where-do-we-define-action/#summary-of-differences","title":"Summary of Differences","text":"<ol> <li> <p>Organization:</p> <ul> <li>Standard Redux: Actions are usually defined separately from reducers, leading to more boilerplate code.</li> <li>Redux Toolkit: Actions and reducers are combined in a slice, making it more concise and easier to manage.</li> </ul> </li> <li> <p>Action Creation:</p> <ul> <li>Standard Redux: You manually create action objects and define action types.</li> <li>Redux Toolkit: You use <code>createSlice</code>, which automatically generates action creators based on the defined reducers.</li> </ul> </li> </ol>"},{"location":"frontend/state-management/redux/rtk/toolkit/questions/where-do-we-define-action/#conclusion","title":"Conclusion","text":"<p>Redux Toolkit streamlines the process of defining actions and reducers, making it easier to work with Redux and reducing the amount of boilerplate code required. If you have any further questions or need more examples, feel free to ask!</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/questions/why-does-redux-toolkit-combine/","title":"Why does redux toolkit combine","text":"<p>Why does Redux Toolkit combine action creators and reducers in the same function?</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/questions/why-does-redux-toolkit-combine/#overview","title":"Overview","text":"<p>Redux Toolkit uses a function called <code>createSlice</code> to combine action creators and reducers for several reasons:</p> <ol> <li> <p>Simplicity: By defining actions and reducers together, it reduces boilerplate code and makes the codebase easier to read and maintain.</p> </li> <li> <p>Co-location: Having related logic in one place helps with understanding the flow of data and makes it easier to see how actions affect state.</p> </li> <li> <p>Automatic Action Creation: When you define reducers in <code>createSlice</code>, Redux Toolkit automatically generates corresponding action creators, so you don\u2019t have to define them separately.</p> </li> <li> <p>Type Safety: It enhances type safety in TypeScript projects by linking action types directly with their reducers, minimizing the chance of errors.</p> </li> <li> <p>Improved Maintainability: When the logic for state updates is closely associated with the actions that trigger them, it helps future developers (or yourself) quickly grasp how to modify the state effectively.</p> </li> </ol> <p>By integrating these concepts, Redux Toolkit streamlines state management, making it more efficient and developer-friendly.</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/questions/why-does-redux-toolkit-combine/#example","title":"Example","text":"<p>Here\u2019s a simple example followed by a more advanced example of using Redux Toolkit with <code>createSlice</code>.</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/questions/why-does-redux-toolkit-combine/#simple-example","title":"Simple Example","text":"<p>Goal: A counter application that increments and decrements a counter value.</p> ExampleUsage in a Component <pre><code>// counterSlice.js\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst counterSlice = createSlice({\n    name: 'counter',\n    initialState: { value: 0 },\n    reducers: {\n        increment: (state) =&gt; {\n            state.value += 1;\n        },\n        decrement: (state) =&gt; {\n            state.value -= 1;\n        },\n        reset: (state) =&gt; {\n            state.value = 0;\n        },\n    },\n});\n\n// Export actions\nexport const { increment, decrement, reset } = counterSlice.actions;\n\n// Export reducer\nexport default counterSlice.reducer;\n</code></pre> <pre><code>import React from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { increment, decrement, reset } from './counterSlice';\n\nconst Counter = () =&gt; {\n    const dispatch = useDispatch();\n    const count = useSelector((state) =&gt; state.counter.value);\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;{count}&lt;/h1&gt;\n            &lt;button onClick={() =&gt; dispatch(increment())}&gt;Increment&lt;/button&gt;\n            &lt;button onClick={() =&gt; dispatch(decrement())}&gt;Decrement&lt;/button&gt;\n            &lt;button onClick={() =&gt; dispatch(reset())}&gt;Reset&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Counter;\n</code></pre>"},{"location":"frontend/state-management/redux/rtk/toolkit/questions/why-does-redux-toolkit-combine/#advanced-example","title":"Advanced Example","text":"<p>Goal: A todo application that adds, removes, and toggles the completion status of todos.</p> ExampleComponent <pre><code>// todosSlice.js\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst todosSlice = createSlice({\n    name: 'todos',\n    initialState: [],\n    reducers: {\n        addTodo: {\n            reducer: (state, action) =&gt; {\n                state.push(action.payload);\n            },\n            prepare: (text) =&gt; {\n                return { payload: { id: Date.now(), text, completed: false } };\n            },\n        },\n        removeTodo: (state, action) =&gt; {\n            return state.filter(todo =&gt; todo.id !== action.payload);\n        },\n        toggleTodo: (state, action) =&gt; {\n            const todo = state.find(todo =&gt; todo.id === action.payload);\n            if (todo) {\n                todo.completed = !todo.completed;\n            }\n        },\n    },\n});\n\n// Export actions\nexport const { addTodo, removeTodo, toggleTodo } = todosSlice.actions;\n\n// Export reducer\nexport default todosSlice.reducer;\n</code></pre> <pre><code>import React, { useState } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { addTodo, removeTodo, toggleTodo } from \"./todosSlice\";\n\nconst Todos = () =&gt; {\n    const [text, setText] = useState(\"\");\n    const dispatch = useDispatch();\n    const todos = useSelector((state) =&gt; state.todos);\n\n    const handleAdd = () =&gt; {\n        if (text) {\n            dispatch(addTodo(text));\n            setText(\"\");\n        }\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;input\n                value={text}\n                onChange={(e) =&gt; setText(e.target.value)}\n                placeholder=\"Add a todo\"\n            /&gt;\n            &lt;button onClick={handleAdd}&gt;Add Todo&lt;/button&gt;\n            &lt;ul&gt;\n                {todos.map((todo) =&gt; (\n                    &lt;li key={todo.id}&gt;\n                        &lt;span\n                            onClick={() =&gt; dispatch(toggleTodo(todo.id))}\n                            style={{\n                                textDecoration: todo.completed ? \"line-through\" : \"none\",\n                            }}\n                        &gt;\n                            {todo.text}\n                        &lt;/span&gt;\n                        &lt;button onClick={() =&gt; dispatch(removeTodo(todo.id))}&gt;\n                        Remove\n                        &lt;/button&gt;\n                    &lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Todos;\n</code></pre> <p>Summary</p> <ul> <li>Simple Example: A basic counter with increment, decrement, and reset actions.</li> <li>Advanced Example: A todo app that allows adding, removing, and toggling todos with unique IDs and completion status.</li> </ul> <p>These examples show how Redux Toolkit simplifies the process of defining state management logic by combining actions and reducers, making it more intuitive and easier to manage.</p>"},{"location":"frontend/state-management/redux/rtk/toolkit/questions/why-does-redux-toolkit-combine/#complex-example","title":"Complex Example","text":"<p>Complex Example: Blog Application</p> <p>Goal: A blog application that allows users to create, update, delete, and fetch posts.</p> SetupComponentExplanation <p>Setup: Slice with Async Thunks</p> <p>We'll use <code>createSlice</code> and <code>createAsyncThunk</code> to handle asynchronous actions for fetching posts.</p> <pre><code>// postsSlice.js\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport axios from 'axios';\n\n// Async thunk for fetching posts\nexport const fetchPosts = createAsyncThunk('posts/fetchPosts', async () =&gt; {\n    const response = await axios.get('https://jsonplaceholder.typicode.com/posts');\n    return response.data;\n});\n\n// Async thunk for adding a post\nexport const addPost = createAsyncThunk('posts/addPost', async (newPost) =&gt; {\n    const response = await axios.post('https://jsonplaceholder.typicode.com/posts', newPost);\n    return response.data;\n});\n\n// Async thunk for deleting a post\nexport const deletePost = createAsyncThunk('posts/deletePost', async (postId) =&gt; {\n    await axios.delete(`https://jsonplaceholder.typicode.com/posts/${postId}`);\n    return postId; // Return the post ID to remove it from the state\n});\n\n// Create the posts slice\nconst postsSlice = createSlice({\n    name: 'posts',\n    initialState: {\n        posts: [],\n        loading: false,\n        error: null,\n    },\n    reducers: {\n        updatePost: (state, action) =&gt; {\n            const index = state.posts.findIndex(post =&gt; post.id === action.payload.id);\n            if (index !== -1) {\n                state.posts[index] = action.payload; // Update the post\n            }\n        },\n    },\n    extraReducers: (builder) =&gt; {\n        builder\n            .addCase(fetchPosts.pending, (state) =&gt; {\n                state.loading = true;\n            })\n            .addCase(fetchPosts.fulfilled, (state, action) =&gt; {\n                state.loading = false;\n                state.posts = action.payload;\n            })\n            .addCase(fetchPosts.rejected, (state, action) =&gt; {\n                state.loading = false;\n                state.error = action.error.message;\n            })\n            .addCase(addPost.fulfilled, (state, action) =&gt; {\n                state.posts.push(action.payload);\n            })\n            .addCase(deletePost.fulfilled, (state, action) =&gt; {\n                state.posts = state.posts.filter(post =&gt; post.id !== action.payload);\n            });\n    },\n});\n\n// Export actions\nexport const { updatePost } = postsSlice.actions;\n\n// Export reducer\nexport default postsSlice.reducer;\n</code></pre> <p>Component: Blog Post Management</p> <p>This component will allow you to fetch, add, update, and delete posts.</p> <pre><code>// Blog.js\nimport React, { useEffect, useState } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { fetchPosts, addPost, deletePost, updatePost } from './postsSlice';\n\nconst Blog = () =&gt; {\n    const dispatch = useDispatch();\n    const { posts, loading, error } = useSelector((state) =&gt; state.posts);\n    const [newPost, setNewPost] = useState({ title: '', body: '' });\n    const [editingPost, setEditingPost] = useState(null);\n\n    useEffect(() =&gt; {\n        dispatch(fetchPosts());\n    }, [dispatch]);\n\n    const handleAddPost = () =&gt; {\n        if (newPost.title &amp;&amp; newPost.body) {\n            dispatch(addPost(newPost));\n            setNewPost({ title: '', body: '' });\n        }\n    };\n\n    const handleUpdatePost = () =&gt; {\n        if (editingPost) {\n            dispatch(updatePost(editingPost));\n            setEditingPost(null);\n        }\n    };\n\n    const handleEditClick = (post) =&gt; {\n        setEditingPost(post);\n        setNewPost({ title: post.title, body: post.body });\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Blog Posts&lt;/h1&gt;\n            {loading &amp;&amp; &lt;p&gt;Loading...&lt;/p&gt;}\n            {error &amp;&amp; &lt;p&gt;Error: {error}&lt;/p&gt;}\n            &lt;div&gt;\n                &lt;input\n                    value={newPost.title}\n                    onChange={(e) =&gt; setNewPost({ ...newPost, title: e.target.value })}\n                    placeholder=\"Title\"\n                /&gt;\n                &lt;textarea\n                    value={newPost.body}\n                    onChange={(e) =&gt; setNewPost({ ...newPost, body: e.target.value })}\n                    placeholder=\"Body\"\n                /&gt;\n                &lt;button onClick={editingPost ? handleUpdatePost : handleAddPost}&gt;\n                    {editingPost ? 'Update Post' : 'Add Post'}\n                &lt;/button&gt;\n            &lt;/div&gt;\n            &lt;ul&gt;\n                {posts.map(post =&gt; (\n                    &lt;li key={post.id}&gt;\n                        &lt;h2&gt;{post.title}&lt;/h2&gt;\n                        &lt;p&gt;{post.body}&lt;/p&gt;\n                        &lt;button onClick={() =&gt; handleEditClick(post)}&gt;Edit&lt;/button&gt;\n                        &lt;button onClick={() =&gt; dispatch(deletePost(post.id))}&gt;Delete&lt;/button&gt;\n                    &lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Blog;\n</code></pre> <ol> <li> <p>Asynchronous Actions: The example uses <code>createAsyncThunk</code> to handle API requests for fetching, adding, and deleting posts. This separates the side effects (like API calls) from the reducers.</p> </li> <li> <p>Loading and Error Handling: The slice keeps track of loading states and errors, which are displayed in the component.</p> </li> <li> <p>Edit Functionality: Users can edit posts by filling in the input fields, which updates the corresponding post in the state.</p> </li> <li> <p>Combined Actions: The slice uses both synchronous reducers (like <code>updatePost</code>) and asynchronous thunks, allowing for complex interactions.</p> </li> </ol> <p>Conclusion</p> <p>This example illustrates a more complex use case for Redux Toolkit, demonstrating how to manage a list of items with asynchronous operations while handling loading and error states effectively. It provides a good foundation for building out a more complete application.</p>"},{"location":"frontend/state-management/redux/standard-redux/intro/","title":"Intro","text":""},{"location":"frontend/state-management/redux/standard-redux/intro/#redux-toolkit-a-modern-approach-to-redux","title":"Redux Toolkit: a modern approach to Redux","text":"<p>Redux Toolkit is the official, opinionated, and batteries-included toolset for efficient Redux development. It was created to help developers write better and more efficient Redux code with less boilerplate.</p> <p>Intallation</p>"},{"location":"frontend/state-management/redux/standard-redux/intro/#install-redux-toolkit-and-react-redux","title":"Install Redux Toolkit and React-Redux","text":"<p>Add the Redux Toolkit and React-Redux packages to your project:</p> <pre><code>npm install @reduxjs/toolkit react-redux\n</code></pre> <ul> <li>ofiical redux tookit</li> </ul>"},{"location":"frontend/state-management/redux/standard-redux/intro/#key-features","title":"Key features","text":"<p>Redux Toolkit comes with several key features that simplify the Redux development process:</p> <ul> <li>configureStore: A function that sets up a Redux store with sensible defaults.</li> <li>createSlice: A function that automatically generates action creators and reducers based on a provided configuration.</li> <li>createAction: A utility function to create action creators with a specific type and payload.</li> <li>createReducer: A utility function that simplifies reducer creation using Immer, enabling direct state manipulation.</li> </ul> <p>Redux Middleware is code that lets us intercept redux actions before they reach the reducer. <code>redux-thunk</code> is an example of Redux Middleware, along with other popular <code>redux</code> libraries like <code>redux-logger</code> , <code>redux-promise-middleware</code> , and <code>redux-saga</code> (an alternative to <code>redux-thunk</code> ).</p> <p></p>"},{"location":"frontend/state-management/redux/standard-redux/intro/#redux-thunk-gives-redux-side-effects","title":"Redux Thunk Gives Redux Side-Effects","text":"<p>In <code>redux</code>, actions creators are functions that return an action, which is a plain javascript objects with a <code>type</code> property.</p> <ul> <li><code>redux-thunk</code> is a Redux Middleware that lets your action creators return a function called a thunk, instead of an action. </li> <li>This thunk can return an action when invoked but it also has access to the Redux store's <code>dispatch</code> function, meaning it can also dispatch other actions. </li> <li>Typically, API calls are invoked inside these thunks and different actions are dispatched depending on these API responses.</li> </ul> <p>For example, below are two action creators, the first returns a plain redux action. The second returns a <code>thunk</code>, thanks to <code>redux-thunk</code>.</p> <pre><code>// action creators\n\n// Action Creator returns action\nloadUser = (userData) =&gt; ({\n  type: \"LOAD_USER_DATA\", userData\n})\n\n/* \n  Action Creator which returns function which dispatches other actions\n*/\nfetchUser = (usersUrl) =&gt; (dispatch) =&gt; {\n  dispatch({ type: \"DISPLAY_LOADING_SCREEN\" })\n\n  return fetch(usersUrl)\n    .then(response =&gt; response.json())\n    .then((json) =&gt; {\n      if (json.success) {\n        dispatch({ type: \"LOAD_USER_DATA\", json.userData })\n      } else {\n        dispatch({ type: \"LOAD_USER_FAILED\" })\n      }\n    })\n}\n</code></pre>"},{"location":"frontend/state-management/redux/standard-redux/intro/#summary","title":"Summary","text":"<ul> <li><code>redux-thunk</code> lets us create actions which are functions that can dispatch other functions instead of just objects.</li> <li><code>redux-thunk</code> is an example of Redux Middleware and as such, needs to adhere to the Redux Middleware signature of <code>validMiddleware =&gt; (store) =&gt; (next) =&gt; (action)</code></li> <li>The core logic of <code>redux-thunk</code> is essentially a simple if statement that checks if the action is a thunk (ie. a function) and invokes it if it is. By default, it exports the Middleware with no <code>extraArgument</code> but it then attaches the <code>createThunkMiddleware</code> function onto the exported Middleware to be used if needed.</li> </ul>"},{"location":"frontend/state-management/redux/standard-redux/intro/#differences-between-standard-redux-and-redux-toolkit-rtk","title":"Differences between <code>standard Redux</code> and <code>Redux Toolkit</code> (RTK)","text":"<p>The key differences between standard Redux and Redux Toolkit (RTK) revolve around simplification, boilerplate reduction, and built-in best practices. RTK is a set of tools and recommendations to help write Redux logic more efficiently and with fewer bugs.</p>"},{"location":"frontend/state-management/redux/standard-redux/intro/#standard-redux","title":"Standard Redux","text":"Characteristics: <ol> <li> <p>Boilerplate Code:</p> <p>Writing actions, action creators, and reducers involves a lot of repetitive boilerplate code.</p> </li> <li> <p>Manual Immutable Updates:</p> <p>You must ensure immutability by manually copying and updating state slices, which can be error-prone.</p> </li> <li> <p>Middleware Setup:</p> <p>Middleware like <code>redux-thunk</code> or <code>redux-saga</code> must be manually added and configured.</p> </li> <li> <p>Configure Store:</p> <p>Creating and configuring the store involves several steps and manual setup for middleware, devtools, etc.</p> </li> <li> <p>Async Logic:</p> <p>Handling asynchronous logic typically requires custom middleware and manually structured action types and creators.</p> </li> <li> <p>Code Organization:</p> <p>Developers need to decide how to organize actions, reducers, and constants, leading to varied and inconsistent project structures.</p> </li> </ol>"},{"location":"frontend/state-management/redux/standard-redux/intro/#standard-redux-example","title":"Standard Redux Example","text":"Example ActionsReducerStore Configuration <pre><code>// actions.js\nexport const INCREMENT = 'INCREMENT';\n\nexport const increment = () =&gt; ({\n    type: INCREMENT,\n});\n</code></pre> <pre><code>// reducer.js\nimport { INCREMENT } from './actions';\n\nconst initialState = { value: 0 };\n\nconst counterReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case INCREMENT:\n            return { ...state, value: state.value + 1 };\n        default:\n            return state;\n    }\n};\n\nexport default counterReducer;\n</code></pre> <pre><code>// store.js\nimport { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport counterReducer from './reducer';\n\nconst store = createStore(counterReducer, applyMiddleware(thunk));\n\nexport default store;\n</code></pre>"},{"location":"frontend/state-management/redux/standard-redux/intro/#redux-toolkit-rtk","title":"Redux Toolkit (RTK)","text":"Characteristics: <ol> <li> <p>Reduced Boilerplate:</p> <p>Provides utilities like <code>createSlice</code>, <code>createAsyncThunk</code>, and <code>createAction</code> that automate and reduce boilerplate.</p> </li> <li> <p>Automatic Immutable Updates:</p> <p>Uses Immer under the hood to handle immutable state updates automatically.</p> </li> <li> <p>Integrated Middleware:</p> <p>Pre-configures the store with useful middleware like <code>redux-thunk</code>, and you can easily add more.</p> </li> <li> <p>Simplified Store Configuration:</p> <p>The <code>configureStore</code> function simplifies the store creation process, integrating devtools, middleware, and enhancers by default.</p> </li> <li> <p>Built-in Async Logic:</p> <p>The <code>createAsyncThunk</code> utility standardizes and simplifies handling asynchronous actions.</p> </li> <li> <p>Standardized Code Organization:</p> <p>Encourages a standardized way to organize slices, reducers, and actions, leading to more consistent codebases.</p> </li> </ol>"},{"location":"frontend/state-management/redux/standard-redux/intro/#redux-toolkit-example","title":"Redux Toolkit Example","text":"Example SliceStore Configuration <pre><code>// counterSlice.js\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst counterSlice = createSlice({\n    name: 'counter',\n    initialState: { value: 0 },\n    reducers: {\n        increment: (state) =&gt; {\n            state.value += 1;\n        },\n    },\n});\n\nexport const { increment } = counterSlice.actions;\nexport default counterSlice.reducer;\n</code></pre> <pre><code>// store.js\nimport { configureStore } from '@reduxjs/toolkit';\nimport counterReducer from './counterSlice';\n\nconst store = configureStore({\n    reducer: {\n        counter: counterReducer,\n    },\n});\n\nexport default store;\n</code></pre>"},{"location":"frontend/state-management/redux/standard-redux/intro/#key-benefits-of-rtk","title":"Key Benefits of RTK","text":"<ol> <li>Boilerplate Reduction: By automating repetitive tasks, RTK reduces boilerplate, making the codebase cleaner and easier to maintain.</li> <li>Immutability Handling: Automatic handling of immutable updates using Immer simplifies state updates and reduces bugs.</li> <li>Pre-configured Store: configureStore streamlines the store setup process, providing good defaults and simplifying middleware addition.</li> <li>Async Thunks: createAsyncThunk offers a standardized way to handle async logic, reducing the need for custom middleware.</li> <li>Code Structure: Encourages a modular and consistent way to structure code using slices, leading to more maintainable projects.</li> </ol> <p>Overall, RTK provides a more modern and efficient way to write Redux logic, addressing many of the pain points associated with standard Redux.</p>"},{"location":"frontend/state-management/redux/standard-redux/intro/#reference","title":"Reference","text":"<ul> <li> <p>React 18 Design Patterns - 2023</p> </li> <li> <p>RTK</p> </li> <li>official redux rtk</li> <li>Understanding Redux Toolkit</li> <li> <p>reduxt toolkit</p> </li> <li> <p>Middleware</p> </li> <li>Understanding redux thunk</li> <li>What is the use of middleware Redux thunk ?</li> </ul>"},{"location":"frontend/state-management/webstorage/intro/","title":"Intro","text":""},{"location":"frontend/state-management/webstorage/intro/#overview","title":"Overview","text":"<p>In web development, there are primarily two types of web storage: LocalStorage and SessionStorage. Both are part of the Web Storage API and provide a way to store data in a user's browser, but they serve different purposes and have different characteristics.</p>"},{"location":"frontend/state-management/webstorage/intro/#1-localstorage","title":"1. LocalStorage","text":"<ul> <li>Persistence: Data stored in LocalStorage remains until explicitly deleted by the user or the application. It does not expire.</li> <li>Scope: Data is accessible across multiple tabs and windows within the same origin (protocol, domain, port).</li> <li>Capacity: Typically allows for around 5 to 10 MB of storage.</li> <li>Use Cases: Suitable for storing user preferences, themes, or any data that should persist beyond a single session.</li> </ul> ExampleReact BasicReact Advanced <pre><code>// Set an item\nlocalStorage.setItem('username', 'JohnDoe');\n\n// Get an item\nconst username = localStorage.getItem('username');\n\n// Remove an item\nlocalStorage.removeItem('username');\n</code></pre> <pre><code>// src/App.js\nimport React, { useState, useEffect } from 'react';\n\nconst App = () =&gt; {\n    const [username, setUsername] = useState('');\n\n    // Load username from LocalStorage when the component mounts\n    useEffect(() =&gt; {\n        const savedUsername = localStorage.getItem('username');\n        if (savedUsername) {\n            setUsername(savedUsername);\n        }\n    }, []);\n\n    // Update LocalStorage whenever the username changes\n    const handleUsernameChange = (event) =&gt; {\n        const newUsername = event.target.value;\n        setUsername(newUsername);\n        localStorage.setItem('username', newUsername); // Save to LocalStorage\n    };\n\n    // Clear the username from LocalStorage\n    const clearUsername = () =&gt; {\n        setUsername('');\n        localStorage.removeItem('username'); // Remove from LocalStorage\n    };\n\n    return (\n        &lt;div style={{ padding: '20px' }}&gt;\n            &lt;h1&gt;LocalStorage Example&lt;/h1&gt;\n            &lt;input\n                type=\"text\"\n                value={username}\n                onChange={handleUsernameChange}\n                placeholder=\"Enter your username\"\n            /&gt;\n            &lt;button onClick={clearUsername}&gt;Clear Username&lt;/button&gt;\n            &lt;p&gt;Current Username: {username || 'No username set'}&lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default App;\n</code></pre> <pre><code>// src/App.js\nimport React, { useState, useEffect } from 'react';\n\nconst App = () =&gt; {\n    const [tasks, setTasks] = useState([]);\n    const [taskInput, setTaskInput] = useState('');\n\n    // Load tasks from LocalStorage when the component mounts\n    useEffect(() =&gt; {\n        const savedTasks = JSON.parse(localStorage.getItem('tasks'));\n        if (savedTasks) {\n            setTasks(savedTasks);\n        }\n    }, []);\n\n    // Update LocalStorage whenever tasks change\n    useEffect(() =&gt; {\n        localStorage.setItem('tasks', JSON.stringify(tasks));\n    }, [tasks]);\n\n    const handleInputChange = (event) =&gt; {\n        setTaskInput(event.target.value);\n    };\n\n    const addTask = () =&gt; {\n        if (taskInput.trim() !== '') {\n            const newTask = {\n                id: Date.now(),\n                text: taskInput,\n                completed: false,\n            };\n            setTasks([...tasks, newTask]);\n            setTaskInput('');\n        }\n    };\n\n    const toggleTaskCompletion = (taskId) =&gt; {\n        const updatedTasks = tasks.map((task) =&gt;\n            task.id === taskId ? { ...task, completed: !task.completed } : task\n        );\n        setTasks(updatedTasks);\n    };\n\n    const removeTask = (taskId) =&gt; {\n        const updatedTasks = tasks.filter((task) =&gt; task.id !== taskId);\n        setTasks(updatedTasks);\n    };\n\n    return (\n        &lt;div style={{ padding: '20px' }}&gt;\n            &lt;h1&gt;To-Do List&lt;/h1&gt;\n            &lt;input\n                type=\"text\"\n                value={taskInput}\n                onChange={handleInputChange}\n                placeholder=\"Add a new task\"\n            /&gt;\n            &lt;button onClick={addTask}&gt;Add Task&lt;/button&gt;\n\n            &lt;ul&gt;\n                {tasks.map((task) =&gt; (\n                    &lt;li key={task.id} style={{ textDecoration: task.completed ? 'line-through' : 'none' }}&gt;\n                        &lt;input\n                            type=\"checkbox\"\n                            checked={task.completed}\n                            onChange={() =&gt; toggleTaskCompletion(task.id)}\n                        /&gt;\n                        {task.text}\n                        &lt;button onClick={() =&gt; removeTask(task.id)}&gt;Remove&lt;/button&gt;\n                    &lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default App;\n</code></pre>"},{"location":"frontend/state-management/webstorage/intro/#2-sessionstorage","title":"2. SessionStorage","text":"<ul> <li>Persistence: Data stored in SessionStorage is only available for the duration of the page session. It is cleared when the page session ends, which occurs when the tab or window is closed.</li> <li>Scope: Data is limited to a single tab or window. If you open the same page in another tab or window, a new SessionStorage is created.</li> <li>Capacity: Similar storage limits to LocalStorage (around 5 to 10 MB).</li> <li>Use Cases: Ideal for temporary data that should only last as long as the user is on the page, such as form data or session-specific information.</li> </ul> ExampleReact BasicReact Advanced <pre><code>// Set an item\nsessionStorage.setItem('sessionId', 'abc123');\n\n// Get an item\nconst sessionId = sessionStorage.getItem('sessionId');\n\n// Remove an item\nsessionStorage.removeItem('sessionId');\n</code></pre> <pre><code>// src/App.js\nimport React, { useState, useEffect } from 'react';\n\nconst App = () =&gt; {\n    const [username, setUsername] = useState('');\n\n    // Load username from SessionStorage when the component mounts\n    useEffect(() =&gt; {\n        const savedUsername = sessionStorage.getItem('username');\n        if (savedUsername) {\n            setUsername(savedUsername);\n        }\n    }, []);\n\n    // Update SessionStorage whenever the username changes\n    const handleInputChange = (event) =&gt; {\n        const newUsername = event.target.value;\n        setUsername(newUsername);\n        sessionStorage.setItem('username', newUsername); // Save to SessionStorage\n    };\n\n    const clearUsername = () =&gt; {\n        setUsername('');\n        sessionStorage.removeItem('username'); // Remove from SessionStorage\n    };\n\n    return (\n        &lt;div style={{ padding: '20px' }}&gt;\n            &lt;h1&gt;SessionStorage Example&lt;/h1&gt;\n            &lt;input\n                type=\"text\"\n                value={username}\n                onChange={handleInputChange}\n                placeholder=\"Enter your username\"\n            /&gt;\n            &lt;button onClick={clearUsername}&gt;Clear Username&lt;/button&gt;\n            &lt;p&gt;Current Username: {username || 'No username set'}&lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default App;\n</code></pre> <pre><code>// src/App.js\nimport React, { useState, useEffect } from 'react';\n\nconst App = () =&gt; {\n    const [tasks, setTasks] = useState([]);\n    const [taskInput, setTaskInput] = useState('');\n\n    // Load tasks from SessionStorage when the component mounts\n    useEffect(() =&gt; {\n        const savedTasks = JSON.parse(sessionStorage.getItem('tasks'));\n        if (savedTasks) {\n            setTasks(savedTasks);\n        }\n    }, []);\n\n    // Update SessionStorage whenever tasks change\n    useEffect(() =&gt; {\n        sessionStorage.setItem('tasks', JSON.stringify(tasks));\n    }, [tasks]);\n\n    const handleInputChange = (event) =&gt; {\n        setTaskInput(event.target.value);\n    };\n\n    const addTask = () =&gt; {\n        if (taskInput.trim() !== '') {\n            const newTask = {\n                id: Date.now(),\n                text: taskInput,\n                completed: false,\n            };\n            setTasks([...tasks, newTask]);\n            setTaskInput('');\n        }\n    };\n\n    const toggleTaskCompletion = (taskId) =&gt; {\n        const updatedTasks = tasks.map((task) =&gt;\n            task.id === taskId ? { ...task, completed: !task.completed } : task\n        );\n        setTasks(updatedTasks);\n    };\n\n    const removeTask = (taskId) =&gt; {\n        const updatedTasks = tasks.filter((task) =&gt; task.id !== taskId);\n        setTasks(updatedTasks);\n    };\n\n    return (\n        &lt;div style={{ padding: '20px' }}&gt;\n            &lt;h1&gt;To-Do List with SessionStorage&lt;/h1&gt;\n            &lt;input\n                type=\"text\"\n                value={taskInput}\n                onChange={handleInputChange}\n                placeholder=\"Add a new task\"\n            /&gt;\n            &lt;button onClick={addTask}&gt;Add Task&lt;/button&gt;\n\n            &lt;ul&gt;\n                {tasks.map((task) =&gt; (\n                    &lt;li key={task.id} style={{ textDecoration: task.completed ? 'line-through' : 'none' }}&gt;\n                        &lt;input\n                            type=\"checkbox\"\n                            checked={task.completed}\n                            onChange={() =&gt; toggleTaskCompletion(task.id)}\n                        /&gt;\n                        {task.text}\n                        &lt;button onClick={() =&gt; removeTask(task.id)}&gt;Remove&lt;/button&gt;\n                    &lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default App;\n</code></pre>"},{"location":"frontend/state-management/webstorage/intro/#key-differences","title":"Key Differences","text":"Feature LocalStorage SessionStorage <code>Persistence</code> Data persists indefinitely Data persists for the session <code>Scope</code> Accessible across tabs/windows Limited to the specific tab/window <code>Use Cases</code> Delete resource Temporary data, form state"},{"location":"frontend/state-management/webstorage/intro/#conclusion","title":"Conclusion","text":"<p>Both LocalStorage and SessionStorage are useful for client-side data storage, but they cater to different needs. Choose LocalStorage for long-term data retention and SessionStorage for temporary, session-specific data.</p>"},{"location":"frontend/state-management/webstorage/token/","title":"Token","text":""},{"location":"frontend/state-management/webstorage/token/#overview","title":"Overview","text":"<p>how to save the token from the api response. and where to save in localstorage or in seession storage.</p> Storing Tokens: LocalStorage vs. SessionStorage <ol> <li> <p>LocalStorage:</p> <ul> <li><code>Persistence</code>: Data persists even after the browser is closed.</li> <li><code>Use Case</code>: Suitable for long-lived tokens (e.g., refresh tokens) or when the user is expected to remain logged in across sessions.</li> <li><code>Security Concern</code>: Vulnerable to XSS attacks, so ensure you validate and sanitize inputs.</li> </ul> </li> <li> <p>SessionStorage:</p> <ul> <li><code>Persistence</code>: Data is cleared when the tab or browser window is closed.</li> <li><code>Use Case</code>: Suitable for short-lived tokens (e.g., access tokens) when you don't want the user to remain logged in after closing the tab.</li> <li><code>Security Concern</code>: Also vulnerable to XSS attacks.</li> </ul> </li> </ol>"},{"location":"frontend/state-management/webstorage/token/#storing-a-token-example","title":"Storing a Token Example","text":"<pre><code>// src/App.js\nimport React, { useState } from 'react';\n\nconst App = () =&gt; {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const [error, setError] = useState('');\n\n  const handleLogin = async (event) =&gt; {\n    event.preventDefault();\n    setError('');\n\n    try {\n      const response = await fetch('https://api.example.com/login', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ username, password }),\n      });\n\n      if (!response.ok) {\n        throw new Error('Login failed');\n      }\n\n      const data = await response.json();\n      const token = data.token; // Assuming the token is in the response body\n\n      // Choose one based on your use case:\n      // LocalStorage for long-lived tokens\n      localStorage.setItem('authToken', token);\n\n      // Or SessionStorage for short-lived tokens\n      // sessionStorage.setItem('authToken', token);\n\n      alert('Login successful!');\n    } catch (err) {\n      setError(err.message);\n    }\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Login&lt;/h1&gt;\n      &lt;form onSubmit={handleLogin}&gt;\n        &lt;input\n          type=\"text\"\n          placeholder=\"Username\"\n          value={username}\n          onChange={(e) =&gt; setUsername(e.target.value)}\n          required\n        /&gt;\n        &lt;input\n          type=\"password\"\n          placeholder=\"Password\"\n          value={password}\n          onChange={(e) =&gt; setPassword(e.target.value)}\n          required\n        /&gt;\n        &lt;button type=\"submit\"&gt;Login&lt;/button&gt;\n      &lt;/form&gt;\n      {error &amp;&amp; &lt;p style={{ color: 'red' }}&gt;{error}&lt;/p&gt;}\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n</code></pre> Security Considerations <ul> <li>XSS Attacks: Be cautious about storing sensitive information in LocalStorage or SessionStorage, as both are accessible through JavaScript and vulnerable to XSS attacks.</li> <li>Token Expiration: Consider implementing token expiration and refreshing mechanisms to enhance security.</li> <li>HTTPS: Always use HTTPS to protect data in transit.</li> </ul>"},{"location":"frontend/typescript/core-concept/","title":"core concept","text":""},{"location":"frontend/typescript/core-concept/#overview","title":"Overview","text":"<p>When learning TypeScript, there are several core concepts that you should understand to use it effectively. Below is a breakdown of the most important concepts:</p>"},{"location":"frontend/typescript/core-concept/#1-static-typing","title":"1. Static Typing","text":"<ul> <li> <p>Type Annotations: TypeScript is statically typed, meaning you can specify the type of a variable, function parameter, or return type.</p> <pre><code>let num: number = 42;\nlet name: string = \"Alice\";\nlet isActive: boolean = true;\n</code></pre> </li> <li> <p>Type Inference: TypeScript automatically infers types when you don\u2019t explicitly specify them. For example:</p> <pre><code>let num = 42; // TypeScript infers `num` as type `number`\n</code></pre> </li> <li> <p>Type System: TypeScript provides several built-in types like <code>number</code>, <code>string</code>, <code>boolean</code>, <code>any</code>, <code>void</code>, <code>null</code>, <code>undefined</code>, and more. You can also define custom types.</p> </li> </ul>"},{"location":"frontend/typescript/core-concept/#2-basic-types","title":"2. Basic Types","text":"<ul> <li> <p>Primitive Types: <code>number</code>, <code>string</code>, <code>boolean</code>, <code>null</code>, <code>undefined</code>, <code>symbol</code>, <code>bigint</code>.</p> <pre><code>let isActive: boolean = true;\nlet age: number = 30;\nlet name: string = \"Alice\";\n</code></pre> </li> <li> <p>Arrays and Tuples:</p> <ul> <li> <p>Arrays are collections of a specific type.</p> <pre><code>let numbers: number[] = [1, 2, 3];\n</code></pre> </li> <li> <p>Tuples allow you to define an array with different types of elements at specific positions.</p> <pre><code>let tuple: [string, number] = [\"Alice\", 25];\n</code></pre> </li> </ul> </li> <li> <p>Enums: A way to define a set of named constants.</p> <pre><code>enum Status {\n  Active,\n  Inactive,\n  Pending,\n}\n\nlet userStatus: Status = Status.Active;\n</code></pre> </li> <li> <p><code>any</code> Type: The <code>any</code> type can hold any value and disables type checking for that variable.</p> <pre><code>let data: any = \"Hello\";\ndata = 42; // No error\n</code></pre> </li> </ul>"},{"location":"frontend/typescript/core-concept/#3-functions-with-types","title":"3. Functions with Types","text":"<ul> <li> <p>Function Types: You can annotate the types of parameters and the return type of functions.</p> <pre><code>function greet(name: string): string {\n  return `Hello, ${name}`;\n}\n</code></pre> </li> <li> <p>Optional Parameters: Parameters can be made optional using <code>?</code>.</p> <pre><code>function greet(name: string, age?: number): string {\n  return age ? `${name} is ${age} years old` : `${name} is of unknown age`;\n}\n</code></pre> </li> <li> <p>Default Parameters: You can provide default values for parameters.</p> <pre><code>function greet(name: string, age: number = 30): string {\n  return `${name} is ${age} years old`;\n}\n</code></pre> </li> </ul>"},{"location":"frontend/typescript/core-concept/#4-interfaces","title":"4. Interfaces","text":"<ul> <li> <p>Defining Object Structures: An interface defines the shape of an object (i.e., the names and types of its properties).</p> <pre><code>interface Person {\n  name: string;\n  age: number;\n}\n\nconst person: Person = {\n  name: \"Alice\",\n  age: 25,\n};\n</code></pre> </li> <li> <p>Optional Properties: You can mark properties as optional using <code>?</code>.</p> <pre><code>interface Person {\n  name: string;\n  age?: number; // Optional property\n}\n</code></pre> </li> <li> <p>Readonly Properties: You can make a property immutable using <code>readonly</code>.</p> <pre><code>interface Point {\n  readonly x: number;\n  readonly y: number;\n}\n</code></pre> </li> </ul>"},{"location":"frontend/typescript/core-concept/#5-classes-and-object-oriented-programming","title":"5. Classes and Object-Oriented Programming","text":"<ul> <li> <p>Classes: TypeScript supports object-oriented programming with classes.</p> <pre><code>class Person {\n  name: string;\n  age: number;\n\n  constructor(name: string, age: number) {\n    this.name = name;\n    this.age = age;\n  }\n\n  greet() {\n    console.log(`Hello, ${this.name}`);\n  }\n}\n\nconst person = new Person(\"Alice\", 25);\nperson.greet();\n</code></pre> </li> <li> <p>Inheritance: You can create a subclass that inherits from a parent class.</p> <pre><code>class Animal {\n  name: string;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n\n  speak() {\n    console.log(`${this.name} makes a sound.`);\n  }\n}\n\nclass Dog extends Animal {\n  speak() {\n    console.log(`${this.name} barks.`);\n  }\n}\n\nconst dog = new Dog(\"Buddy\");\ndog.speak(); // \"Buddy barks.\"\n</code></pre> </li> </ul>"},{"location":"frontend/typescript/core-concept/#6-generics","title":"6. Generics","text":"<ul> <li> <p>Reusable Components: Generics allow you to create functions, classes, or interfaces that work with any data type.</p> <pre><code>function identity&lt;T&gt;(arg: T): T {\n  return arg;\n}\n\nlet result1 = identity(5); // result1 is of type `number`\nlet result2 = identity(\"hello\"); // result2 is of type `string`\n</code></pre> </li> <li> <p>Generic Constraints: You can constrain the types that can be used with a generic.</p> <pre><code>function logLength&lt;T extends { length: number }&gt;(item: T): number {\n  return item.length;\n}\n</code></pre> </li> </ul>"},{"location":"frontend/typescript/core-concept/#7-type-aliases","title":"7. Type Aliases","text":"<ul> <li> <p>Type Aliases: You can create new names for types, including complex ones like unions or intersections.</p> <pre><code>type StringOrNumber = string | number; // Union type\n\nlet value: StringOrNumber = \"Hello\"; // OK\nvalue = 42; // OK\n</code></pre> </li> </ul>"},{"location":"frontend/typescript/core-concept/#8-union-and-intersection-types","title":"8. Union and Intersection Types","text":"<ul> <li> <p>Union Types (<code>|</code>): A value can be one of several types.</p> <pre><code>let id: number | string = 123;\nid = \"abc\"; // Valid\n</code></pre> </li> <li> <p>Intersection Types (<code>&amp;</code>): Combines multiple types into one.</p> <pre><code>interface Person {\n  name: string;\n}\n\ninterface Contact {\n  email: string;\n}\n\ntype Employee = Person &amp; Contact;\n\nconst employee: Employee = {\n  name: \"Alice\",\n  email: \"alice@example.com\",\n};\n</code></pre> </li> </ul>"},{"location":"frontend/typescript/core-concept/#9-modules-and-namespaces","title":"9. Modules and Namespaces","text":"<ul> <li> <p>Modules: TypeScript uses <code>import</code> and <code>export</code> to organize code into separate files.</p> <pre><code>// file: person.ts\nexport interface Person {\n  name: string;\n  age: number;\n}\n\n// file: main.ts\nimport { Person } from \"./person\";\nconst person: Person = { name: \"Alice\", age: 25 };\n</code></pre> </li> <li> <p>Namespaces: Group related code together, but modules (via <code>import/export</code>) are generally preferred now.</p> <pre><code>namespace Animal {\n  export class Dog {\n    name: string;\n    constructor(name: string) {\n      this.name = name;\n    }\n  }\n}\n\nlet myDog = new Animal.Dog(\"Buddy\");\n</code></pre> </li> </ul>"},{"location":"frontend/typescript/core-concept/#10-type-assertions","title":"10. Type Assertions","text":"<ul> <li> <p>Type Assertion: You can tell TypeScript to treat a value as a certain type (bypassing the compiler's type checking).</p> <pre><code>let someValue: any = \"Hello\";\nlet strLength: number = (someValue as string).length;\n</code></pre> </li> </ul>"},{"location":"frontend/typescript/core-concept/#11-advanced-types","title":"11. Advanced Types","text":"<ul> <li> <p>Conditional Types: Types that depend on a condition.</p> <pre><code>type IsString&lt;T&gt; = T extends string ? \"Yes\" : \"No\";\ntype A = IsString&lt;string&gt;; // \"Yes\"\ntype B = IsString&lt;number&gt;; // \"No\"\n</code></pre> </li> <li> <p>Mapped Types: Create new types by transforming existing ones.</p> <pre><code>type ReadOnly&lt;T&gt; = {\n  readonly [K in keyof T]: T[K];\n};\n</code></pre> </li> </ul>"},{"location":"frontend/typescript/core-concept/#summary","title":"Summary","text":"<p>These are the main concepts that will help you understand and use TypeScript effectively:</p> <ul> <li>Static typing and type annotations</li> <li>Primitive types, arrays, tuples, and enums</li> <li>Interfaces and type aliases</li> <li>Classes, inheritance, and object-oriented programming</li> <li>Generics for reusable components</li> <li>Union and intersection types</li> <li>Modules, namespaces, and file organization</li> <li>Type assertions and advanced types</li> </ul> <p>Once you're comfortable with these, you'll have a solid foundation in TypeScript!</p>"},{"location":"frontend/typescript/core-concept/#question","title":"Question","text":"<p>Yes, when using TypeScript in a React project, all files that contain TypeScript code should have the <code>.ts</code> or <code>.tsx</code> extensions, depending on whether they contain JSX.</p> <p>Here\u2019s a breakdown of how to handle file extensions in TypeScript:</p> <p>1. For TypeScript files without JSX:</p> <ul> <li>File extension: .ts</li> <li>These files contain only TypeScript code (e.g., utility functions, API services, Redux slices, etc.), but no JSX syntax.</li> </ul> <p>Example:</p> <ul> <li><code>utils/helpers.ts</code>, <code>redux/slices/userSlice.ts</code>, <code>api/services/userApi.ts</code></li> </ul> <p>2. For TypeScript files with JSX:</p> <pre><code>File extension: `.tsx`\nThese files contain both TypeScript and JSX (e.g., React components).\n</code></pre> <p>Example:</p> <ul> <li><code>components/UserList.tsx</code>, <code>views/Home/Home.tsx</code>, <code>App.tsx</code></li> </ul> <p>Why is this important?</p> <ul> <li>TypeScript\u2019s compiler needs to know whether or not it should expect JSX syntax. Files with <code>.tsx</code> extensions indicate that the file contains JSX, and TypeScript will allow JSX syntax in them.</li> <li><code>.ts</code> files are for TypeScript-only code, where JSX is not allowed. If you tried to use JSX syntax in a <code>.ts</code> file, TypeScript would throw an error.</li> </ul> Example Example of React Component: UserList.tsx (a component with JSX)<pre><code>import React from 'react';\n\nconst UserList: React.FC = () =&gt; {\n    return (\n        &lt;div&gt;\n        &lt;h1&gt;User List&lt;/h1&gt;\n        {/* JSX syntax */}\n        &lt;/div&gt;\n    );\n};\n\nexport default UserList;\n</code></pre> userApi.ts (a service file without JSX)<pre><code>import axios from 'axios';\n\nconst userApi = {\n    fetchUsers: async () =&gt; {\n        const response = await axios.get('/users');\n        return response.data;\n    }\n};\n\nexport default userApi;\n</code></pre> <p>Summary:</p> <ul> <li>Use <code>.ts</code> for TypeScript files that don\u2019t include JSX.</li> <li>Use <code>.tsx</code> for TypeScript files that include JSX.</li> </ul> <p>This way, your code will remain consistent, and TypeScript will be able to process the files correctly.</p>"},{"location":"frontend/typescript/one-hour-ts/","title":"1 hour","text":""},{"location":"frontend/typescript/one-hour-ts/#overview","title":"Overview","text":"<p>Learning TypeScript in one hour is definitely a challenge, but it's possible to get a good understanding of the basics and learn how to start using it effectively. I'll focus on key concepts, and by the end, you should be able to write simple TypeScript code and understand how it integrates with JavaScript.</p>"},{"location":"frontend/typescript/one-hour-ts/#outline-for-1-hour-typescript-crash-course","title":"Outline for 1-Hour TypeScript Crash Course","text":"0-10 minutes: Introduction to TypeScript <p>What is TypeScript?</p> <ul> <li>TypeScript is a statically typed superset of JavaScript.</li> <li>It adds types, interfaces, and other features to help catch errors early and improve code quality.</li> <li>Transpilation: TypeScript code is compiled to JavaScript (it doesn't run natively in browsers).</li> </ul> <p>Why Use TypeScript?</p> <ul> <li>Type safety: Helps avoid common runtime errors (e.g., accessing properties of <code>undefined</code>).</li> <li>Autocompletion: Better IDE support.</li> <li>Refactoring: Makes large projects easier to maintain.</li> </ul> <p>Install TypeScript:</p> <ul> <li> <p>You can install TypeScript globally via npm:</p> <pre><code>npm install -g typescript\n</code></pre> </li> <li> <p>To compile TypeScript to JavaScript:</p> <pre><code>tsc myfile.ts\n</code></pre> </li> </ul> 10-25 minutes: Basic Syntax and Types <ul> <li> <p>Basic Types: TypeScript provides static types that help enforce rules about how values are used. Here are the most common ones:</p> <pre><code>let num: number = 42;\nlet isActive: boolean = true;\nlet name: string = \"Alice\";\nlet anyValue: any = \"Can be anything\";\n</code></pre> </li> <li> <p>Arrays and Tuples:</p> <pre><code>let numbers: number[] = [1, 2, 3];\nlet tuple: [string, number] = [\"Hello\", 42]; // Tuple of a string and a number\n</code></pre> </li> <li> <p>Object Types: Define the shape of an object using an interface or inline object types:</p> <pre><code>let person: { name: string, age: number } = { name: \"Alice\", age: 25 };\n</code></pre> </li> <li> <p>Functions with Types: Functions in TypeScript have type annotations for parameters and return types:</p> <pre><code>function greet(name: string): string {\n    return \"Hello, \" + name;\n}\n</code></pre> </li> </ul> 25-40 minutes: Intermediate Concepts <ul> <li> <p>Interfaces: Interfaces define the structure of objects. They help you enforce types across your codebase:</p> <pre><code>interface Person {\n    name: string;\n    age: number;\n}\n\nconst person: Person = { name: \"Alice\", age: 30 };\n</code></pre> </li> <li> <p>Type Aliases: Type aliases can simplify complex types:</p> <pre><code>type StringOrNumber = string | number;\n\nlet value: StringOrNumber = 10;\nvalue = \"Hello\"; // OK\n</code></pre> </li> <li> <p>Union Types: TypeScript allows you to specify a value can be one of several types:</p> <pre><code>function showMessage(message: string | number) {\n    console.log(message);\n}\n\nshowMessage(\"Hello\");\nshowMessage(42);\n</code></pre> </li> <li> <p>Type Assertion (like casting in other languages):</p> <pre><code>let someValue: any = \"This is a string\";\nlet strLength: number = (someValue as string).length;\n</code></pre> </li> </ul> 40-50 minutes: Advanced Concepts (Optional for Speed) <ul> <li> <p>Generics: Generics allow you to create reusable components that work with any data type:</p> <pre><code>function identity&lt;T&gt;(arg: T): T {\n    return arg;\n}\n\nlet result = identity(42); // result is of type number\nlet stringResult = identity(\"hello\"); // result is of type string\n</code></pre> </li> <li> <p>Classes and Inheritance: TypeScript supports classes and object-oriented programming:</p> <pre><code>class Animal {\n    name: string;\n    constructor(name: string) {\n        this.name = name;\n    }\n    speak() {\n        console.log(`${this.name} makes a noise`);\n    }\n}\n\nclass Dog extends Animal {\n    speak() {\n        console.log(`${this.name} barks`);\n    }\n}\n\nconst dog = new Dog(\"Buddy\");\ndog.speak(); // \"Buddy barks\"\n</code></pre> </li> <li> <p>Modules: TypeScript allows you to use import and export to split your code into multiple files:</p> <pre><code>// person.ts\nexport interface Person {\n    name: string;\n    age: number;\n}\n\n// main.ts\nimport { Person } from './person';\nconst person: Person = { name: \"Alice\", age: 25 };\n</code></pre> </li> </ul> 50-60 minutes: Putting It All Together <ul> <li> <p>Write a Small TypeScript Project: Try writing a small TypeScript program that uses the concepts above. For example, create a simple class-based system for a \"Book\" and \"Library\" to practice using classes, interfaces, and types:</p> <pre><code>interface Book {\n    title: string;\n    author: string;\n    year: number;\n}\n\nclass Library {\n    books: Book[] = [];\n\n    addBook(book: Book) {\n        this.books.push(book);\n    }\n\n    listBooks() {\n        this.books.forEach(book =&gt; console.log(`${book.title} by ${book.author}, ${book.year}`));\n    }\n}\n\nconst library = new Library();\nlibrary.addBook({ title: \"1984\", author: \"George Orwell\", year: 1949 });\nlibrary.listBooks();\n</code></pre> </li> </ul> <p>This example uses interfaces, classes, and basic types.</p>"},{"location":"frontend/typescript/one-hour-ts/#wrap-up-next-steps","title":"Wrap-Up &amp; Next Steps","text":"<ul> <li>You now have a basic understanding of TypeScript! You can start using it in small projects and gradually dive deeper into more advanced concepts.</li> <li> <p>Next Steps:</p> </li> <li> <p>Practice by converting existing JavaScript code to TypeScript.</p> </li> <li>Explore the TypeScript documentation: TypeScript Handbook.</li> <li>Try using TypeScript with frameworks like Angular or React to see its benefits in larger applications.</li> </ul>"},{"location":"frontend/typescript/typescript-compiler/","title":"Compiler","text":""},{"location":"frontend/typescript/typescript-compiler/#typescript-compiler","title":"TypeScript Compiler","text":"<p>TypeScript is transpiled into JavaScript using a compiler.</p> <p>TypeScript being converted into JavaScript means it runs anywhere that JavaScript runs!</p>"},{"location":"frontend/typescript/typescript-compiler/#installing-the-compiler","title":"Installing the Compiler","text":"<p>TypeScript has an official compiler which can be installed through npm.</p> <p>Within your npm project, run the following command to install the compiler:</p> <p>npm install typescript --save-dev</p> <p>You can then run the TypeScript compiler using one of the following commands:</p> <p>npx tsc</p> <p>yarn tsc</p> <p>pnpm tsc</p>"},{"location":"frontend/typescript/typescript-compiler/#globally-installing-typescript","title":"Globally Installing TypeScript","text":"<p>npm install -g typescript</p>"},{"location":"frontend/typescript/typescript-compiler/#configuring-the-compiler","title":"Configuring the compiler","text":"<p>You can have TypeScript create <code>tsconfig.json</code> with the recommended settings with:</p> <p>npx tsc --init</p> <p>Here is an example of more things you could add to the <code>tsconfig.json</code> file:</p> <pre><code>{\n  \"include\": [\"src\"],\n  \"compilerOptions\": {\n    \"outDir\": \"./build\"\n  }\n}\n</code></pre>"},{"location":"frontend/typescript/typescript-compiler/#working-with-typescript-compatible-transpilers","title":"Working with TypeScript-compatible transpilers","text":"<p>There are other tools which convert TypeScript files to JavaScript files</p> <ol> <li>Babel: Babel is a very popular JavaScript transpiler which supports TypeScript files via the plugin @babel/plugin-transform-typescript.</li> <li>swc: swc is a fast transpiler created in Rust which supports many of Babel's features including TypeScript.</li> <li>Sucrase: Sucrase is a Babel fork focused on speed for using in development mode. Sucrase supports TypeScript natively.</li> </ol>"},{"location":"frontend/typescript/typescript-compiler/#reference","title":"Reference","text":"<ul> <li>TypeScript Compiler :w3chools.com</li> </ul>"},{"location":"frontend/typescript/typescript-installation/","title":"Installation","text":""},{"location":"frontend/typescript/typescript-installation/#typescript","title":"Typescript","text":""},{"location":"frontend/typescript/typescript-installation/#what-is-typescript","title":"What is TypeScript?","text":"<p>TypeScript is JavaScript with added syntax for types.</p> <p>TypeScript is a syntactic superset of JavaScript which adds static typing.</p> <p>This basically means that TypeScript adds syntax on top of JavaScript, allowing developers to add types.</p> <p>TypeScript being a \"Syntactic Superset\" means that it shares the same base syntax as JavaScript, but adds something to it.</p>"},{"location":"frontend/typescript/typescript-installation/#how-do-i-use-typescript","title":"How do I use TypeScript?","text":"<p>A common way to use TypeScript is to use the official TypeScript compiler, which transpiles TypeScript code into JavaScript.</p> <p>The next section shows how to get the compiler setup for a local project.</p> <p>Some popular code editors, such as Visual Studio Code, have built-in TypeScript support and can show errors as you write code!</p> <p>TypeScript uses compile time type checking. Which means it checks if the specified types match before running the code, not while running the code.</p> <p>TypeScript allows developers to add types to JavaScript.</p>"},{"location":"frontend/typescript/typescript-installation/#overview","title":"Overview","text":"<p>To install React Redux and React Redux Toolkit in a TypeScript project using pnpm, follow these steps:</p> <p>**Step 1: Install the necessary packages ** You need to install the following packages:</p> <ul> <li><code>react-redux</code>: The official Redux bindings for React.</li> <li><code>@reduxjs/toolkit</code>: The official Redux Toolkit, which simplifies working with Redux.</li> <li><code>@types/react-redux</code>: TypeScript types for React Redux.</li> </ul> <p>Install with pnpm</p> <p>In your project directory, run the following command:</p> <pre><code>pnpm add react-redux @reduxjs/toolkit @types/react-redux\n</code></pre> <p>This command will:</p> <ul> <li>Install <code>react-redux</code> for React bindings.</li> <li>Install <code>@reduxjs/toolkit</code> for simplified Redux setup.</li> <li>Install <code>@types/react-redux</code> for TypeScript types to ensure full type safety.</li> </ul>"},{"location":"frontend/typescript/typescript-installation/#reference","title":"Reference","text":"<ul> <li>TypeScript Tutorial: w3schools.com</li> </ul>"},{"location":"frontend/typescript/react-fc/example/","title":"Example","text":""},{"location":"frontend/typescript/react-fc/example/#example","title":"Example","text":"<p>so using React.FC expects the return statements? is it correct</p> <p>Yes, that's correct! When you use <code>React.FC</code>, it expects your component to return <code>valid JSX</code> (or <code>ReactNode</code>), as it infers the return type to be a React element.</p> Example <pre><code>import React from \"react\";\nimport type { FormProps } from \"antd\";\nimport { Button, Checkbox, Form, Input } from \"antd\";\n\ntype FieldType = {\n    username?: string;\n    password?: string;\n    remember?: string;\n};\n\nconst onFinish: FormProps&lt;FieldType&gt;[\"onFinish\"] = (values) =&gt; {\n    console.log(\"Success:\", values);\n};\n\nconst onFinishFailed: FormProps&lt;FieldType&gt;[\"onFinishFailed\"] = (errorInfo) =&gt; {\n    console.log(\"Failed:\", errorInfo);\n};\n\nconst App: React.FC = () =&gt; (\n    &lt;Form\n        name=\"basic\"\n        labelCol={{ span: 8 }}\n        wrapperCol={{ span: 16 }}\n        style={{ maxWidth: 600 }}\n        initialValues={{ remember: true }}\n        onFinish={onFinish}\n        onFinishFailed={onFinishFailed}\n        autoComplete=\"off\"\n    &gt;\n        &lt;Form.Item&lt;FieldType&gt;\n            label=\"Username\"\n            name=\"username\"\n            rules={[{ required: true, message: \"Please input your username!\" }]}\n        &gt;\n            &lt;Input /&gt;\n        &lt;/Form.Item&gt;\n\n        &lt;Form.Item&lt;FieldType&gt;\n            label=\"Password\"\n            name=\"password\"\n            rules={[{ required: true, message: \"Please input your password!\" }]}\n        &gt;\n            &lt;Input.Password /&gt;\n        &lt;/Form.Item&gt;\n\n        &lt;Form.Item&lt;FieldType&gt; name=\"remember\" valuePropName=\"checked\" label={null}&gt;\n            &lt;Checkbox&gt;Remember me&lt;/Checkbox&gt;\n        &lt;/Form.Item&gt;\n\n        &lt;Form.Item label={null}&gt;\n            &lt;Button type=\"primary\" htmlType=\"submit\"&gt;\n                Submit\n            &lt;/Button&gt;\n        &lt;/Form.Item&gt;\n    &lt;/Form&gt;\n);\n\nexport default App;\n</code></pre> <p>Great question! The key thing to understand here is that React.FC (FunctionComponent) is a shortcut for defining a functional component in TypeScript, but it doesn't enforce a <code>return</code> statement in the sense of needing an explicit return like other JavaScript functions. The <code>App</code> component implicitly returns JSX because that's the behavior of functional components in React.</p>"},{"location":"frontend/typescript/react-fc/example/#why-it-doesnt-need-a-return-statement","title":"Why It Doesn't Need a <code>return</code> Statement:","text":"<ol> <li> <p>Implicit Return: In JSX, the return of the JSX element is implicit. When you write JSX directly inside a function body like this:</p> <pre><code>const App: React.FC = () =&gt; &lt;Form&gt;...&lt;/Form&gt;;\n</code></pre> <p>It's equivalent to:</p> <pre><code>const App: React.FC = () =&gt; {\n  return &lt;Form&gt;...&lt;/Form&gt;;\n};\n</code></pre> <p>The parentheses <code>()</code> after the arrow function indicate an implicit return of JSX (the <code>Form</code> component in this case). This shorthand is common in React components.</p> </li> <li> <p>React.FC: Using <code>React.FC</code> does not require a <code>return</code> statement in a conventional way because the implicit return feature of arrow functions is being used. So, in your example, <code>React.FC</code> is just a typing convention, and the actual component implicitly returns the JSX in the form of the <code>Form</code> component.</p> </li> </ol>"},{"location":"frontend/typescript/react-fc/example/#summary","title":"Summary:","text":"<p><code>React.FC</code> does not change the behavior of how JSX is returned. The component still returns JSX implicitly through the arrow function syntax. The parentheses <code>()</code> after the arrow function are what make this return implicit, so you don't need to explicitly write <code>return</code> if you're writing JSX directly.</p>"},{"location":"frontend/typescript/react-fc/intro/","title":"Intro","text":"<p><code>React.FC</code> (or <code>React.FunctionComponent</code>) is a TypeScript type that helps define functional components in React with proper type checking. It's a generic type provided by React to make it easier to work with functional components in TypeScript.</p>"},{"location":"frontend/typescript/react-fc/intro/#what-is-reactfc","title":"What is React.FC?","text":"<p>React.FC is a built-in TypeScript type that is specifically designed for defining functional components. It automatically provides some helpful type inference, such as:</p> <ol> <li>Props type: When you use React.FC, TypeScript infers the shape of props that the component will receive.</li> <li>Children prop: By default, it adds the children prop to your component, so you don't have to explicitly type it unless you want to override it.</li> <li>Return type: It ensures the component returns valid JSX/React elements.</li> </ol> <p>Here's a breakdown of what React.FC provides:</p> <ul> <li>Type for props: <code>React.FC</code> expects a type argument that describes the shape of the props. If no props are used, you can pass {}.</li> <li>Children typing: If your component renders children, <code>React.FC</code> automatically gives you the correct type for children (i.e., ReactNode).</li> <li>Return type inference: It ensures that your component returns a valid React element.</li> </ul>"},{"location":"frontend/typescript/react-fc/intro/#why-do-we-need-reactfc","title":"Why do we need React.FC?","text":"<p>In TypeScript, <code>React.FC</code> provides better type safety and code readability by enforcing rules about props and return types. Here's why you might want to use it:</p> <ol> <li> <p>Automatic typing of props: If you have a component that accepts props, you can define the shape of the props once, and <code>React.FC</code> will enforce this type for you. This reduces the chance of errors where props are used incorrectly.</p> </li> <li> <p>Children support: React components often need to render children. <code>React.FC</code> automatically handles the children prop, so you don't need to explicitly define it if you're using it. This makes your code more concise and easier to read.</p> </li> <li> <p>Consistent return types: <code>React.FC</code> ensures that your component returns valid JSX. It helps prevent mistakes where a function might not return anything or return something that isn't a valid React element.</p> </li> </ol> Example Example with React.FC:Explanation <pre><code>import React from \"react\";\n\ntype ButtonProps = {\n    text: string;\n};\n\nconst Button: React.FC&lt;ButtonProps&gt; = ({ text }) =&gt; {\n    return &lt;button&gt;{text}&lt;/button&gt;;\n};\n\nexport default Button;\n</code></pre> <ul> <li><code>ButtonProps</code> defines the <code>text</code> prop.</li> <li><code>React.FC&lt;ButtonProps&gt;</code> tells TypeScript that this component expects <code>ButtonProps</code> and will return a valid JSX element.</li> </ul>"},{"location":"frontend/typescript/react-fc/intro/#what-happens-if-we-dont-use-reactfc","title":"What happens if we don't use React.FC?","text":"<p>You are not required to use <code>React.FC</code>. In fact, it's perfectly fine to define functional components without it, especially if you don't need <code>children</code> or prefer to define your own types. Here's an example of a component without <code>React.FC</code>:</p> <pre><code>import React from \"react\";\n\ntype ButtonProps = {\n  text: string;\n};\n\nconst Button = ({ text }: ButtonProps) =&gt; {\n  return &lt;button&gt;{text}&lt;/button&gt;;\n};\n\nexport default Button;\n</code></pre> <p>In this case:</p> <ul> <li>You're still explicitly typing the <code>ButtonProps</code> and passing them as arguments.</li> <li>There's no need for <code>React.FC</code> because you're not using the default <code>children</code> prop and you explicitly type the return type (JSX) by just defining the props.</li> </ul>"},{"location":"frontend/typescript/react-fc/intro/#key-differences-and-trade-offs","title":"Key Differences and Trade-offs:","text":"<ol> <li> <p>No <code>children</code> support: If you don't use <code>React.FC</code>, and you want to support children, you will need to type the <code>children</code> prop manually. For example:</p> <pre><code>type ButtonProps = {\n  text: string;\n  children?: React.ReactNode;\n};\n</code></pre> </li> <li> <p>Verbose typing: Without <code>React.FC</code>, you might need to manually type the return type for your component if it's not just JSX:</p> <pre><code>const Button = ({ text }: ButtonProps): JSX.Element =&gt; {\n  return &lt;button&gt;{text}&lt;/button&gt;;\n};\n</code></pre> <p><code>React.FC</code> automatically infers that the return type should be <code>JSX.Element</code>.</p> </li> <li> <p>No enforced <code>children</code> prop: If you use <code>React.FC</code>, you get <code>children</code> as an implicit part of your props. If you don't want it, you can either remove it from your type or override it, but generally, you won't need to define it manually.</p> </li> </ol>"},{"location":"frontend/typescript/react-fc/intro/#conclusion","title":"Conclusion:","text":"<ul> <li>Use <code>React.FC</code> if you want automatic typing for <code>children</code> and prefer the convenience of having <code>React</code> types inferred (for props and return values).</li> <li>Don't use <code>React.FC</code> if you prefer more control and don't need automatic handling of <code>children</code>. You might also avoid it for simpler components that don't require these features.</li> </ul> <p>While <code>React.FC</code> is widely used, it's not a strict requirement. Some developers choose to avoid it for various reasons, such as wanting more explicit typing control or reducing unnecessary complexity.</p>"},{"location":"frontend/typescript/react-fc/react-fc/","title":"React.FC","text":""},{"location":"frontend/typescript/react-fc/react-fc/#when-to-use","title":"When to use","text":"<p>In a TypeScript-based React application, whether to use <code>React.FC</code> (or <code>React.FunctionComponent</code>) or not depends on the specific needs of your components and the style guide you follow. I'll go through both scenarios\u2014when to use and when not to use <code>React.FC</code>\u2014along with real-time examples for each case.</p> Note When to Use <code>React.FC</code>When Not to Use <code>React.FC</code> <ol> <li> <p>When Your Component Accepts Children</p> <p><code>React.FC</code>automatically includes the <code>children</code> prop. If your component is designed to accept children (nested content or components), using <code>React.FC</code> is convenient, as it will automatically infer the type for <code>children</code>.</p> Example <pre><code>import React from 'react';\n\ninterface CardProps {\n    title: string;\n    content: string;\n}\n\nconst Card: React.FC&lt;CardProps&gt; = ({ title, content, children }) =&gt; {\n    return (\n        &lt;div className=\"card\"&gt;\n            &lt;h2&gt;{title}&lt;/h2&gt;\n            &lt;p&gt;{content}&lt;/p&gt;\n            &lt;div&gt;{children}&lt;/div&gt; {/* children are automatically typed */}\n        &lt;/div&gt;\n    );\n};\n</code></pre> <ul> <li> <p>Why use <code>React.FC</code> here?</p> <ul> <li>This component is designed to accept <code>children</code>. By using <code>React.FC</code>, we don't have to explicitly define the <code>children</code> prop in the <code>CardProps</code> interface. It's automatically included and typed as <code>ReactNode</code>.</li> <li>This is useful if you want to make sure that the component works as a wrapper that can accept arbitrary child elements.</li> </ul> </li> </ul> </li> <li> <p>When You Want a Simple and Consistent Type for Functional Components</p> <p>Using <code>React.FC</code> provides a consistent way of defining functional components with type inference for <code>props</code> and <code>children</code>, especially in large codebases where you want to keep things uniform.</p> Example <pre><code>import React from 'react';\n\ninterface ButtonProps {\n    label: string;\n    onClick: () =&gt; void;\n}\n\nconst Button: React.FC&lt;ButtonProps&gt; = ({ label, onClick }) =&gt; {\n    return &lt;button onClick={onClick}&gt;{label}&lt;/button&gt;;\n};\n</code></pre> <ul> <li> <p>Why use <code>React.FC</code> here?</p> </li> <li> <p>The <code>Button</code> component only accepts <code>label</code> and <code>onClick</code> props, but it is simple and clear. <code>React.FC</code> automatically ensures that <code>children</code> can also be passed (though it's not used in this case).</p> </li> <li>It reduces boilerplate if you are using <code>children</code> in other components in your application, and it provides a consistent style.</li> </ul> </li> </ol> <ol> <li> <p>When Your Component Does Not Need <code>children</code></p> <p>If your component does not need to accept <code>children</code>, using <code>React.FC</code> might be unnecessary and might lead to potential confusion, as <code>children</code> will be inferred by TypeScript even though it's not used. In such cases, manually typing the props is simpler and avoids any confusion about unnecessary <code>children</code> support.</p> Example <pre><code>import React from 'react';\n\ninterface AvatarProps {\n    imageUrl: string;\n    altText: string;\n}\n\nconst Avatar = ({ imageUrl, altText }: AvatarProps) =&gt; {\n    return &lt;img src={imageUrl} alt={altText} /&gt;;\n};\n</code></pre> <ul> <li> <p>Why not use <code>React.FC</code> here?</p> <ul> <li><code>Avatar</code> is a simple component that does not need <code>children</code>. Adding <code>React.FC</code> here would unnecessarily add <code>children</code> as part of the type, even though it isn't required. This can make the code slightly more complex or confusing for others.</li> </ul> </li> </ul> </li> <li> <p>When You Want Explicit Typing for props</p> <p>Sometimes, being more explicit about what your component expects and handling the props manually is preferred. This can be helpful in cases where you want to ensure that only the props you explicitly define are passed in.</p> Example <pre><code>import React from 'react';\n\ninterface ProfileProps {\n    username: string;\n    age: number;\n}\n\nconst Profile = ({ username, age }: ProfileProps) =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;{username}&lt;/h1&gt;\n            &lt;p&gt;Age: {age}&lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n</code></pre> <ul> <li> <p>Why not use <code>React.FC</code> here?</p> <ul> <li>By defining <code>ProfileProps</code> and explicitly typing the props in the component signature, you're making the code clear and explicit.</li> <li>This can help avoid unnecessary automatic behaviors that <code>React.FC</code> introduces, like the implicit <code>children</code> prop.</li> <li>If your component doesn't need <code>children</code>, it's clearer and more explicit to not use <code>React.FC</code>.</li> </ul> </li> </ul> </li> <li> <p>When You Want to Avoid Potential Unnecessary Re-renders</p> <p>In some cases, the use of <code>React.FC</code> might lead to unnecessary complexity because it adds some implicit behavior (like <code>children</code>), which could potentially trigger re-renders or create complexity in the props typing.</p> Example <pre><code>import React, { useState } from 'react';\n\ninterface CounterProps {\n    initialCount: number;\n}\n\nconst Counter = ({ initialCount }: CounterProps) =&gt; {\n    const [count, setCount] = useState(initialCount);\n\n    return (\n        &lt;div&gt;\n            &lt;h2&gt;Count: {count}&lt;/h2&gt;\n            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n</code></pre> <ul> <li> <p>Why not use <code>React.FC</code> here?</p> <ul> <li><code>Counter</code> only needs <code>initialCount</code> as a prop, and <code>children</code> aren't required. Using <code>React.FC</code> in this case would introduce unnecessary props (<code>children</code>), making it harder to track what's required and potentially leading to unnecessary re-renders or confusion about which props the component actually accepts.</li> <li>When you manually define <code>props</code>, you have full control over what is passed into your component.</li> </ul> </li> </ul> </li> </ol> <p>Summary of When to Use and When Not to Use <code>React.FC</code></p> Use <code>React.FC</code> Don't Use <code>React.FC</code> When your component needs to accept <code>children</code>. When your component doesn't need <code>children</code>. When you want a consistent, simpler type for functional components. When you prefer more explicit typing for props. When you want automatic type inference for <code>children</code>. When you want to avoid implicit behavior (like <code>children</code>) in the component. When your component is a wrapper or layout component (e.g., cards, panels). When the component is simple and doesn't require extra functionality. <p>Conclusion</p> <ul> <li>Use <code>React.FC</code> when you want to quickly define functional components that accept <code>children</code> or when you prefer having consistent typing for props and <code>children</code>.</li> <li>Avoid <code>React.FC</code> when you don't need <code>children</code> or when you want to keep your components' typings as explicit and simple as possible.</li> </ul> <p>While there's no hard rule, a lot of modern TypeScript React codebases avoid <code>React.FC</code> because it can introduce unnecessary complexity when <code>children</code> are not needed. Ultimately, it boils down to coding style preferences and the needs of your application.</p>"},{"location":"interview/improved-code/","title":"Improved Code","text":""},{"location":"interview/improved-code/#difference-between-single-double-curly-braces","title":"Difference between <code>Single</code> &amp; <code>Double</code> Curly Braces","text":"<p>In JavaScript (and JSX), <code>{}</code> and <code>{{}}</code> are used in different contexts, and here's the distinction:</p> Success <code>{}</code> (Single Curly Braces)<code>{{}}</code> (Double Curly Braces) <ul> <li> <p>In JSX: <code>{}</code> is used to embed JavaScript expressions into JSX.</p> <ul> <li>Example: <code>const name = 'John';</code> and <code>&lt;div&gt;{name}&lt;/div&gt;</code> will render the value of <code>name</code> inside the <code>&lt;div&gt;</code>.</li> </ul> </li> <li> <p>In JavaScript: <code>{}</code> is also used for defining objects, blocks, or destructuring.</p> <ul> <li> <p>In JSX: When you want to embed a variable or a JavaScript expression (like a number, string, function call, etc.) inside JSX, you wrap it with <code>{}</code>. For example:</p> <pre><code>const greeting = 'Hello, World!';\nreturn &lt;h1&gt;{greeting}&lt;/h1&gt;;  // The value of greeting will be displayed inside the &lt;h1&gt;\n</code></pre> </li> </ul> </li> </ul> <ul> <li> <p>In JSX: {{}} is commonly used when you're passing an object as a prop, especially for inline styles or for embedding an object inside JSX.</p> <ul> <li> <p>For inline styles, you need to use a double pair of curly braces:</p> <pre><code>const style = { color: 'blue', fontSize: '16px' };\nreturn &lt;div style={{ color: 'blue', fontSize: '16px' }}&gt;Styled Text&lt;/div&gt;;\n</code></pre> <ul> <li>The first pair <code>{}</code> is for the JSX syntax (since it's in JSX, it expects expressions).</li> <li>The second pair <code>{{}}</code> is the object itself that you want to pass (the inline styles are represented as an object).</li> </ul> </li> <li> <p>Another use case is when you're passing an object to a function or a component prop:</p> <pre><code>&lt;Component prop={{ key: 'value' }} /&gt;\n</code></pre> <p>This means you're passing an object <code>{ key: 'value' }</code> to the <code>prop</code> of the <code>Component</code>.</p> </li> </ul> </li> </ul> <ul> <li><code>{}</code> (Single Curly Braces): Used to embed JavaScript expressions in JSX.</li> <li><code>{{}}</code> (Double Curly Braces): Used when you want to pass an object (like inline styles or any other object) inside JSX.</li> </ul>"},{"location":"interview/improved-code/#improvements","title":"Improvements","text":"MainLayoutHeader <pre><code>import { Layout } from \"antd\";\nimport Header from \"./Header\";\nimport Sidebar from \"./Sidebar\";\nimport { useState } from \"react\";\n\nconst { Content } = Layout;\n\nconst MainLayout = ({ children }) =&gt; {\n    const [collapsed, setCollapsed] = useState(false);\n\n    // Calculate sidebar width based on collapse state\n    const sidebarWidth = collapsed ? 80 : 240;\n\n    // Calculate content width based on sidebar state\n    const contentWidth = `calc(100% - ${sidebarWidth}px)`;\n\n    return (\n        &lt;Layout style={{ minHeight: \"100vh\" }}&gt;\n            &lt;Header collapsed={collapsed} setCollapsed={setCollapsed} /&gt;\n            &lt;Layout style={{ display: \"flex\" }}&gt;\n                &lt;Sidebar collapsed={collapsed} width={sidebarWidth} /&gt;\n                &lt;Content style={{ width: contentWidth }}&gt;{children}&lt;/Content&gt;\n            &lt;/Layout&gt;\n        &lt;/Layout&gt;\n    );\n};\n\nexport default MainLayout;\n</code></pre> <pre><code>import { MenuUnfoldOutlined, MenuFoldOutlined } from \"@ant-design/icons\";\nimport { Layout } from \"antd\";\n\nconst { Header: AntHeader } = Layout;\n\nconst Header = ({ collapsed, setCollapsed }) =&gt; {\n    return (\n        &lt;AntHeader style={{ padding: 0 }}&gt;\n            &lt;div style={{ display: \"flex\", justifyContent: \"space-between\" }}&gt;\n                &lt;div&gt;\n                    &lt;button\n                        onClick={() =&gt; setCollapsed(!collapsed)}\n                        style={{ background: \"none\", border: \"none\" }}\n                    &gt;\n                        {collapsed ? &lt;MenuUnfoldOutlined /&gt; : &lt;MenuFoldOutlined /&gt;}\n                    &lt;/button&gt;\n                &lt;/div&gt;\n                &lt;div&gt; {/* Other header content */} &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/AntHeader&gt;\n    );\n};\n\nexport default Header;\n</code></pre>"},{"location":"interview/improved-code/#final-optimized-code","title":"Final Optimized Code:","text":"MainLayout.jsxHeader.jsx <pre><code>import { useState, useCallback } from \"react\";\nimport { Layout } from \"antd\";\nimport { RightCircleOutlined, LeftCircleOutlined } from \"@ant-design/icons\";\n\nimport Header from \"./Header\";\nimport Sidebar from \"./Sidebar\";\n\nconst { Content } = Layout;\n\nconst MainLayout = ({ children }) =&gt; {\n    const [collapsed, setCollapsed] = useState(false);\n\n    // Using useCallback to memoize the function and prevent unnecessary re-renders\n    const toggleSidebar = useCallback(() =&gt; {\n        setCollapsed((prev) =&gt; !prev);\n    }, []);\n\n    const sidebarWidth = collapsed ? 80 : 240;\n    const contentWidth = `calc(100% - ${sidebarWidth}px)`;\n\n    return (\n        &lt;Layout&gt;\n            &lt;Header toggleSidebar={toggleSidebar} /&gt; {/* Pass toggleSidebar to Header */}\n            &lt;Layout style={{ display: \"flex\" }}&gt;\n                &lt;Sidebar collapsed={collapsed} width={sidebarWidth} /&gt;\n                &lt;Content style={{ width: contentWidth, position: \"relative\" }}&gt;\n                    {collapsed ? (\n                        &lt;RightCircleOutlined\n                            onClick={toggleSidebar}\n                            aria-label=\"Expand Sidebar\"\n                        /&gt;\n                    ) : (\n                        &lt;LeftCircleOutlined\n                            onClick={toggleSidebar}\n                            aria-label=\"Collapse Sidebar\"\n                        /&gt;\n                    )}\n                    {children}\n                &lt;/Content&gt;\n            &lt;/Layout&gt;\n        &lt;/Layout&gt;\n    );\n};\n\nexport default MainLayout;\n</code></pre> <pre><code>import React from 'react';\nimport { Layout, Button } from 'antd';\nimport { MenuFoldOutlined, MenuUnfoldOutlined } from '@ant-design/icons';\n\nconst { Header: AntHeader } = Layout;\n\nconst Header = ({ toggleSidebar }) =&gt; {\n    return (\n        &lt;AntHeader style={{ padding: 0, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}&gt;\n            {/* Button to toggle sidebar */}\n            &lt;Button\n                type=\"primary\"\n                icon={toggleSidebar ? &lt;MenuUnfoldOutlined /&gt; : &lt;MenuFoldOutlined /&gt;}\n                onClick={toggleSidebar}\n                aria-label=\"Toggle Sidebar\"\n                style={{ marginLeft: 16 }}\n            /&gt;\n            {/* You can add other elements like branding, user info, etc. */}\n            &lt;div style={{ fontSize: '18px', color: 'white' }}&gt;My Application&lt;/div&gt;\n        &lt;/AntHeader&gt;\n    );\n};\n\nexport default Header;\n</code></pre>"},{"location":"interview/improved-code/#react-responsive","title":"react-responsive","text":"<pre><code>npm install react-responsive\n</code></pre> Updated Code with Responsiveness <pre><code>import { Layout } from \"antd\";\nimport Header from \"./Header\";\nimport Sidebar from \"./Sidebar\";\nimport { useState } from \"react\";\nimport { useMediaQuery } from \"react-responsive\";\n\nconst { Content } = Layout;\n\nconst MainLayout = ({ children }) =&gt; {\n    // State for sidebar collapse\n    const [collapsed, setCollapsed] = useState(false);\n\n    // Set sidebar width based on collapse state\n    const sidebarWidth = collapsed ? 80 : 240;\n\n    // Use media query to check if the screen is small\n    const isSmallScreen = useMediaQuery({ maxWidth: 768 });\n\n    // Automatically collapse sidebar on small screens\n    if (isSmallScreen &amp;&amp; !collapsed) {\n        setCollapsed(true);\n    }\n\n    // Calculate content width based on sidebar state\n    const contentWidth = `calc(100% - ${sidebarWidth}px)`;\n\n    return (\n        &lt;Layout style={{ minHeight: \"100vh\" }}&gt;\n            &lt;Header collapsed={collapsed} setCollapsed={setCollapsed} /&gt;\n            &lt;Layout style={{ display: \"flex\" }}&gt;\n                &lt;Sidebar collapsed={collapsed} width={sidebarWidth} /&gt;\n                &lt;Content style={{ width: contentWidth }}&gt;{children}&lt;/Content&gt;\n            &lt;/Layout&gt;\n        &lt;/Layout&gt;\n    );\n};\n\nexport default MainLayout;\n</code></pre> <pre><code>// 1. Use effect to update sidebar collapse state based on screen size\nuseEffect(() =&gt; {\n  if (isSmallScreen &amp;&amp; !collapsed) {\n    setCollapsed(true); // Collapse sidebar on small screens\n  } else if (!isSmallScreen &amp;&amp; collapsed) {\n    setCollapsed(false); // Expand sidebar on large screens\n  }\n}, [isSmallScreen, collapsed]); // Trigger effect on screen size change\n\n// 2. Automatically collapse sidebar on small screens, but allow manual toggle on large screens\nuseEffect(() =&gt; {\n  if (isSmallScreen) {\n    setCollapsed(true); // Collapse sidebar on small screens\n  } else {\n    // Don't override user's manual collapse state on large screens\n    setCollapsed((prev) =&gt; prev); // Keep the previous state intact\n  }\n}, [isSmallScreen]); // Trigger this effect only when the screen size changes\n\n// 3. Automatically collapse sidebar on small screens, but allow manual toggle on large screens\nuseEffect(() =&gt; {\n  if (isSmallScreen) {\n    setCollapsed(true); // Collapse sidebar on small screens\n  } else {\n    setCollapsed(false); // Expand sidebar on larger screens\n  }\n}, [isSmallScreen]); // Trigger this effect only when the screen size changes\n</code></pre>"},{"location":"interview/improved-code/#reference","title":"Reference","text":"<ul> <li>Responsive websites with React-Responsive</li> <li>Use React Responsive Libraries</li> <li>RTK Query For Beginners</li> </ul>"},{"location":"interview/intro/","title":"Intro","text":""},{"location":"interview/intro/#dashboard-react-app","title":"Dashboard React App","text":"<ul> <li>Dashboard Templated</li> <li>Free MUI Dashboard</li> </ul>"},{"location":"interview/intro/#website-react-app","title":"Website React App","text":""},{"location":"interview/intro/#react-application","title":"React Application","text":""},{"location":"interview/javascript/","title":"Javascript","text":""},{"location":"interview/javascript/#overview","title":"Overview","text":""},{"location":"interview/javascript/#what-is-a-closure-in-javascript-provide-an-example","title":"What is a \"closure\" in JavaScript? Provide an example.","text":"<p>A closure is a function defined inside another function (called the parent function), and has access to variables that are declared and defined in the parent function scope.</p> <p>The closure has access to variables in three scopes:</p> <ul> <li>Variables declared in their own scope.</li> <li>Variables declared in a parent function scope.</li> <li>Variables declared in the global namespace.</li> </ul> <pre><code>var globalVar = \"abc\";\n\n// Parent self-invoking function\n(function outerFunction(outerArg) {\n  // Begin of scope outerFunction\n\n  // Variable declared in outerFunction function scope\n  var outerFuncVar = \"x\"; // Fixed invalid quotation marks\n\n  // Closure self-invoking function\n  (function innerFunction(innerArg) {\n    // Begin of scope innerFunction\n\n    // Variable declared in innerFunction function scope\n    var innerFuncVar = \"y\";\n    console.log(\n      \"outerArg = \" +\n        outerArg +\n        \"\\n\" +\n        \"outerFuncVar = \" +\n        outerFuncVar +\n        \"\\n\" +\n        \"innerArg = \" +\n        innerArg +\n        \"\\n\" +\n        \"innerFuncVar = \" +\n        innerFuncVar +\n        \"\\n\" +\n        \"globalVar = \" +\n        globalVar\n    );\n  })(\n    // End of scope innerFunction\n    5\n  ); // Pass 5 as parameter\n})(\n  // End of scope outerFunction\n  7\n); // Pass 7 as parameter\n</code></pre> <p><code>innerFunction</code> is closure that is defined inside <code>outerFunction</code> and has access to all variables declared and defined in the <code>outerFunction</code> scope. In addition, the function defined inside another function as a closure will have access to variables declared in the <code>global namespace</code>.</p> <p>Thus, the output of the code above would be:</p> <pre><code>outerArg = 7\nouterFuncVar = x\ninnerArg = 5\ninnerFuncVar = y\nglobalVar = abc\n</code></pre> <p>pg: 21. JavaScript Interview Questions by Fabio Cimo</p>"},{"location":"interview/javascript/#what-are-javascript-data-types","title":"What are JavaScript data types?","text":"<p>In JavaScript, there are <code>three</code> primary data types, <code>two</code> composite data types, and <code>two</code> special data types.</p> <p>Primary Data Types</p> <ul> <li>String</li> <li>Number</li> <li>Boolean</li> </ul> <p>Composite Data Types</p> <ul> <li>Object</li> <li>Array</li> </ul> <p>Special Data Types</p> <ul> <li>Null</li> <li>Undefined</li> </ul> <p>pg: 6. JavaScript Interview Questions by Fabio Cimo</p>"},{"location":"interview/javascript/#define-event-bubbling","title":"Define event bubbling","text":"<p>JavaScript allows DOM elements to be nested inside each other. In such a case, if the handler of the child is clicked, the handler of parent will also work as if it were clicked too.</p> <p>pg: 7. JavaScript Interview Questions by Fabio Cimo</p>"},{"location":"interview/javascript/#what-are-screen-objects","title":"What are Screen objects?","text":"<p>Screen objects are used to read the information from the client\u2019s screen. The properties of screen objects are -</p> <ul> <li><code>AvalHeight</code>: Gives the height of client\u2019s screen.</li> <li><code>AvailWidth</code>: Gives the width of client\u2019s screen.</li> <li><code>ColorDepth</code>: Gives the bit depth of images on the client\u2019s screen</li> <li><code>Height</code>: Gives the total height of the client\u2019s screen, including the taskbar</li> <li><code>Width</code>: Gives the total width of the client\u2019s screen, including the taskbar</li> </ul>"},{"location":"interview/javascript/#books","title":"Books","text":""},{"location":"interview/javascript/#reference","title":"Reference","text":"<ul> <li>jsbin.com</li> </ul>"},{"location":"interview/bff/bff-question/","title":"BFF Question","text":""},{"location":"interview/bff/bff-question/#question","title":"Question","text":"<p>What is required to implement a Backend for Frontend (BFF) architecture in Django with Django REST Framework (DRF)?</p> <p>To implement a BFF architecture in Django and DRF, you generally need to focus on the following key components:</p> <ol> <li> <p>Custom Serializers:</p> <ul> <li>You will need to create different serializers for each frontend application (e.g., web and mobile) to tailor the data structure according to their specific needs.</li> </ul> </li> <li> <p>Viewsets:</p> <ul> <li>Create separate viewsets for each frontend, using the custom serializers to handle requests and responses appropriately.</li> </ul> </li> <li> <p>URLs:</p> <ul> <li>Set up distinct URL routes for each BFF endpoint, ensuring that each frontend can access its corresponding API.</li> </ul> </li> <li> <p>Data Models (if applicable):</p> <ul> <li>Your data models may remain the same, but the way you serve them will differ based on the serializers and viewsets you create.</li> </ul> </li> <li> <p>Authentication and Permissions (if needed):</p> <ul> <li>You may also want to implement different authentication or permission schemes based on the frontend requirements.</li> </ul> </li> </ol> <p>Summary</p> <p>While customizing serializers is a significant part of implementing a BFF, it\u2019s not the only step. You also need to create dedicated viewsets and URL configurations to ensure each frontend receives the data in the format it requires.</p>"},{"location":"interview/bff/bff-question/#step-by-step-example","title":"Step-by-Step Example","text":"Basic Example <ol> <li> <p>Set Up Your Django Project</p> <p>First, create a new Django project and an app:</p> <pre><code>django-admin startproject my_bff\ncd my_bff\ndjango-admin startapp user\n</code></pre> </li> <li> <p>Install Django REST Framework</p> <p>Install DRF:</p> <pre><code>pip install djangorestframework\n</code></pre> <p>Add <code>'rest_framework'</code> and your app (<code>'user'</code>) to <code>INSTALLED_APPS</code> in <code>settings.py</code>:</p> <pre><code># my_bff/settings.py\n\nINSTALLED_APPS = [\n    ...\n    'rest_framework',\n    'user',\n]\n</code></pre> </li> <li> <p>Create the User Model</p> <p>Define a simple User model in <code>models.py</code>:</p> <pre><code># user/models.py\n\nfrom django.db import models\n\nclass User(models.Model):\n    username = models.CharField(max_length=150)\n    email = models.EmailField()\n    phone = models.CharField(max_length=15)\n    street = models.CharField(max_length=255)\n    city = models.CharField(max_length=100)\n    zipcode = models.CharField(max_length=10)\n    newsletter = models.BooleanField(default=False)\n    notifications = models.BooleanField(default=False)\n\n    def __str__(self):\n        return self.username\n</code></pre> <p>Run the migrations to create the User table:</p> <pre><code>python manage.py makemigrations\npython manage.py migrate\n</code></pre> </li> <li> <p>Create Serializers</p> <p>Create serializers for the User model in <code>serializers.py</code>:</p> <pre><code># user/serializers.py\n\nfrom rest_framework import serializers\nfrom .models import User\n\nclass UserProfileWebSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = User\n        fields = ['id', 'username', 'email', 'phone', 'street', 'city', 'zipcode', 'newsletter', 'notifications']\n\nclass UserProfileMobileSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = User\n        fields = ['id', 'username', 'email']\n</code></pre> </li> <li> <p>Create Viewsets</p> <p>Define viewsets for the different BFFs in <code>views.py</code>:</p> <pre><code># user/views.py\n\nfrom rest_framework import viewsets\nfrom .models import User\nfrom .serializers import UserProfileWebSerializer, UserProfileMobileSerializer\n\nclass UserProfileWebViewSet(viewsets.ReadOnlyModelViewSet):\n    queryset = User.objects.all()\n    serializer_class = UserProfileWebSerializer\n\nclass UserProfileMobileViewSet(viewsets.ReadOnlyModelViewSet):\n    queryset = User.objects.all()\n    serializer_class = UserProfileMobileSerializer\n</code></pre> </li> <li> <p>Configure URLs</p> <p>Set up URLs for the two different BFFs in <code>urls.py</code>:</p> <pre><code># user/urls.py\n\nfrom django.urls import path, include\nfrom rest_framework.routers import DefaultRouter\nfrom .views import UserProfileWebViewSet, UserProfileMobileViewSet\n\nrouter = DefaultRouter()\nrouter.register(r'web/user-profile', UserProfileWebViewSet, basename='user-web')\nrouter.register(r'mobile/user-profile', UserProfileMobileViewSet, basename='user-mobile')\n\nurlpatterns = [\n    path('', include(router.urls)),\n]\n</code></pre> <p>Include the user app URLs in the main project <code>urls.py</code>:</p> <pre><code># my_bff/urls.py\n\nfrom django.contrib import admin\nfrom django.urls import path, include\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('api/', include('user.urls')),\n]\n</code></pre> </li> <li> <p>Test the BFF APIs</p> <p>Run your Django server:</p> <pre><code>python manage.py runserver\n</code></pre> </li> </ol>"},{"location":"interview/bff/bff-question/#endpoint","title":"Endpoint","text":"<p>Now, you can test the endpoints using a tool like <code>Postman</code> or <code>curl</code>.</p> 1. Web App Endpoint:2. Mobile App Endpoint: <ul> <li>URL: <code>http://localhost:8000/api/web/user-profile/</code></li> <li> <p>Response Example:</p> <pre><code>{\n    \"id\": 1,\n    \"username\": \"john_doe\",\n    \"email\": \"john@example.com\",\n    \"phone\": \"123-456-7890\",\n    \"street\": \"123 Elm St\",\n    \"city\": \"Somewhere\",\n    \"zipcode\": \"12345\",\n    \"newsletter\": true,\n    \"notifications\": false\n}\n</code></pre> </li> </ul> <ul> <li>URL: <code>http://localhost:8000/api/mobile/user-profile/</code></li> <li> <p>Response Example:</p> <pre><code>{\n    \"id\": 1,\n    \"username\": \"john_doe\",\n    \"email\": \"john@example.com\"\n}\n</code></pre> </li> </ul> Benefits of Using BFF <ol> <li> <p>Tailored Responses:</p> <ul> <li>The web app receives all necessary details, while the mobile app only gets the crucial information it needs.</li> </ul> </li> <li> <p>Reduced Payload:</p> <ul> <li>The mobile app's response is smaller, improving load times and performance.</li> </ul> </li> <li> <p>Decoupled Development:</p> <ul> <li>Frontend teams can make changes to their BFFs independently without affecting the other frontend.</li> </ul> </li> </ol> <p>Conclusion</p> <p>In this example, we implemented a BFF architecture using Django and Django REST Framework. We created two separate APIs tailored for different frontends (web and mobile), showcasing how to customize serializers, viewsets, and URLs to meet the specific needs of each frontend application. This approach optimizes data delivery and enhances performance, making it a great architectural choice.</p>"},{"location":"interview/bff/bff/","title":"BFF","text":""},{"location":"interview/bff/bff/#what-is-backend-for-frontend-bff","title":"What is Backend for Frontend (BFF)?","text":"<p>Backend for Frontend (BFF) is a design pattern that involves creating a dedicated backend service tailored specifically for a particular frontend application (like a web or mobile app). This approach helps in optimizing the communication between the frontend and backend by providing a layer that is specifically designed to serve the needs of the frontend, making it easier to manage and improve performance.</p>"},{"location":"interview/bff/bff/#overview","title":"Overview","text":"<p>Backend for Frontend (BFF) is designed to create a dedicated backend layer tailored specifically for individual frontend applications. It serves to optimize communication, improve performance, and streamline development by providing APIs that are custom-built to meet the specific needs of each frontend.</p>"},{"location":"interview/bff/bff/#key-features-of-bff","title":"Key Features of BFF","text":"<ol> <li>Tailored API: Each frontend (web, mobile, etc.) can have its own backend that serves only the data and functionality it needs.</li> <li>Reduced Over-fetching: By designing the API specifically for the frontend, you can avoid sending unnecessary data, reducing payload sizes.</li> <li>Simplified Logic: It allows for frontend-specific logic to reside in the backend, keeping the frontend code cleaner and more focused on presentation.</li> <li>Easier Adaptation: Changes in the frontend can often be accommodated in the BFF without affecting the overall backend architecture.</li> </ol>"},{"location":"interview/bff/bff/#scenario","title":"Scenario","text":"With BFFWithout BFFSummary <p>Suppose you have two different frontend applications: a web app and a mobile app. Each of these apps requires different data formats and structures from the backend.</p> <ul> <li>Web App: Needs detailed information, including user profiles, order histories, and recommendations.</li> <li>Mobile App: Needs summarized data to save bandwidth, focusing only on essential information like user profiles and recent orders.</li> </ul> <p>BFF Implementation:</p> <p>BFF Layer:</p> <ul> <li> <p>Web BFF:</p> <ul> <li>API Endpoint: <code>/api/web/user-profile</code></li> <li>Returns detailed user information, including nested objects.</li> </ul> </li> <li> <p>Mobile BFF:</p> <ul> <li>API Endpoint: <code>/api/mobile/user-profile</code></li> <li>Returns a simplified version of the user profile with only essential fields.</li> </ul> </li> </ul> Benefits: <ul> <li>Tailored Responses: Each frontend gets exactly what it needs without over-fetching or under-fetching data.</li> <li>Decoupled Development: Frontend teams can work independently from backend teams since the BFF layer abstracts the backend complexities.</li> <li>Optimized Performance: By reducing payload sizes for the mobile app, you improve loading times and user experience.</li> </ul> <p>In a traditional setup, you might have a single backend service that serves both the web and mobile apps.</p> <ul> <li> <p>Single API Endpoint: <code>/api/user-profile</code></p> <ul> <li>Returns all user data regardless of the frontend requesting it, including detailed information that the mobile app doesn't need.</li> </ul> </li> </ul> Drawbacks: <ul> <li>Over-fetching: The mobile app receives more data than it needs, leading to larger payloads and slower response times.</li> <li>Inflexibility: Any changes required for one frontend can inadvertently affect the other, making development less agile.</li> <li>Complexity: Frontend developers may need to implement additional logic to filter and process unnecessary data, adding to their workload.</li> </ul> <p>Using a BFF allows you to tailor backend services specifically for different frontend applications, optimizing data delivery, improving performance, and simplifying development. In contrast, a traditional single-backend approach can lead to inefficiencies and complexities as frontends evolve.</p>"},{"location":"interview/bff/bff/#implementation-in-drf","title":"Implementation in drf","text":""},{"location":"interview/http/api/","title":"API","text":"<p>Understanding the Difference Between Response Object and Parsed Data in API Fetch Requests</p> Quote <pre><code>\"Decoding API Responses: Response Object vs. Parsed Data\"\n\"How to Differentiate Between API Response Metadata and Data\"\n\"Understanding Fetch API: Inspecting Response Objects and JSON Data\"\n\"API Fetch Explained: Distinguishing Between Response and Data\"\n\"From Response Object to JSON Data: A Guide to Handling API Fetch Results\"\n\"Fetching Data from APIs: Parsing Responses and Understanding Output\"\n\"Navigating API Responses: What the Response Object and Data Represent\"\n\"Unpacking API Fetch Responses: Insights into Response Objects and Data Extraction\"\n\"Fetching and Parsing API Data: A Closer Look at Response vs. JSON Content\"\n\"API Fetch Demystified: Differences Between the Response Object and Parsed Data\"\n</code></pre>"},{"location":"interview/http/api/#overview","title":"Overview","text":"<p>Let\u2019s break down what\u2019s happening step-by-step in your code:</p> <ol> <li> <p>Fetching Data:</p> ExampleExplanation <pre><code>const response = await fetch(apiUrl, {\n    method: 'GET', // or 'POST', 'PUT', etc. depending on your API\n    headers: {\n        'Authorization': `Api-Key ${apiKey}`,\n        'Content-Type': 'application/json'\n    }\n});\n</code></pre> <p>This code sends a request to the specified <code>apiUrl</code> with the method 'GET' and the specified headers. <code>await</code> pauses the execution of the function until the fetch operation is complete, and the result is assigned to <code>response</code>.</p> </li> <li> <p>Handling Response:</p> ExampleExplanation <pre><code>if (!response.ok) {\n    throw new Error('Network response was not ok');\n}\nconsole.log(\"RESPONSE: \", response)\n</code></pre> <p><code>response.ok</code> checks if the HTTP status code is in the range 200-299, indicating a successful request. If the response is not ok, an error is thrown. The <code>console.log(\"RESPONSE: \", response)</code> prints the <code>response</code> object to the console.</p> <ul> <li> <p>What is <code>response</code> ?</p> <p>The <code>response</code> object represents the response to the request and contains metadata like status codes and headers. It does not directly contain the response data; rather, it provides methods to retrieve it.</p> </li> </ul> </li> <li> <p>Extracting JSON Data:</p> ExampleExplanation <pre><code>const data = await response.json();\nconsole.log(\"data: \", data)\n</code></pre> <p><code>response.json()</code> reads the response stream to completion and parses it as JSON. This method returns a promise that resolves with the result of parsing the body text as JSON. Using <code>await</code> here, the execution pauses until the JSON is fully parsed and assigned to <code>data</code>.</p> <ul> <li> <p>What is <code>data</code> ? </p> <p><code>data</code> contains the actual data returned from the API in JSON format. This is the useful information you're interested in, such as an object or array of values, depending on what the API returns.</p> </li> </ul> </li> <li> <p>Explanation of Console Logs:</p> <ul> <li> <p><code>console.log(\"RESPONSE: \", response)</code> This logs the <code>response</code> object itself. This object includes various properties like <code>status</code>, <code>statusText</code>, <code>headers</code>, and methods to read the response body (like <code>response.json()</code>, <code>response.text()</code>, etc.). It doesn't show the actual data content from the response directly but rather information about the response.</p> </li> <li> <p><code>console.log(\"data: \", data)</code> This logs the content of the response after it has been parsed from JSON. This is the actual data returned by the API.</p> </li> </ul> </li> </ol> <p>In summary, <code>response</code> is the raw response object from the API call, which contains metadata and methods for extracting the data. <code>data</code> is the parsed JSON content of the response, representing the actual data returned by the API.</p>"},{"location":"interview/http/api/#understanding-the-response-object","title":"Understanding the <code>response</code> Object","text":"<p>When you make a network request using the <code>fetch</code> API, the <code>response</code> object that you receive contains metadata about the request and methods to retrieve the response body. However, the raw response body is not automatically in the format you might expect. Here\u2019s why:</p> <ol> <li> <p>Raw Response Body: The <code>response</code> object contains a stream of data, not the parsed data itself. This means that the body of the response is just a raw stream of bytes, and you need to explicitly extract and interpret this data.</p> </li> <li> <p>Response Methods: The <code>response</code> object provides several methods to read the response body:</p> <ul> <li><code>response.text()</code>: Reads the body as a string.</li> <li><code>response.json()</code>: Parses the body as JSON.</li> <li><code>response.blob()</code>: Reads the body as a <code>Blob</code> (binary large object).</li> <li><code>response.formData()</code>: Reads the body as <code>FormData</code>.</li> </ul> </li> </ol> The Role of <code>response.json()</code> <p>The <code>response.json()</code> method is used specifically to parse the response body as JSON. Here\u2019s a step-by-step explanation of what happens:</p> <ol> <li> <p>Fetching Data: When you make a fetch request, the response body is delivered as a raw stream. This stream contains the data in its original format, which is often JSON, but not necessarily so until it is processed.</p> </li> <li> <p>Parsing JSON: JSON (JavaScript Object Notation) is a text-based format for representing structured data. The response.json() method performs the following tasks:</p> <ul> <li>Reads the Response: It reads the entire body of the response stream.</li> <li>Parses JSON: It then parses the body text as JSON, which converts the JSON text into a JavaScript object or array that you can work with directly.</li> </ul> </li> <li> <p>Return Value: <code>response.json()</code> returns a promise that resolves to the parsed JavaScript object. This means that once you call <code>await response.json()</code>, you get the data in a usable format.</p> </li> </ol> Why Not Use the Raw Response Directly? <ul> <li> <p>Data Interpretation: The raw response body is just a series of bytes. It needs to be interpreted (or decoded) to be usable. For JSON data, this means converting the raw JSON text into a JavaScript object or array.</p> </li> <li> <p>Error Handling: <code>response.json()</code> also helps with error handling. If the response body is not valid JSON, calling <code>response.json()</code> will throw an error, which you can catch and handle.</p> </li> </ul>"},{"location":"interview/http/api/#example","title":"Example","text":"CodeExplanation <pre><code>try {\n    const response = await fetch(apiUrl);\n\n    if (!response.ok) {\n        throw new Error('Network response was not ok');\n    }\n\n    // Attempting to parse the response as JSON\n    const data = await response.json();\n    console.log(\"Parsed Data: \", data);\n} catch (error) {\n    console.error('Error fetching or parsing data:', error);\n}\n</code></pre> <ul> <li><code>await response.json()</code> reads the response body stream, parses it as JSON, and converts it into a JavaScript object or array.</li> <li>Without using <code>response.json()</code>, you would not get the JSON data directly; you would have the raw response body that needs to be explicitly parsed</li> </ul>"},{"location":"interview/http/api/#summary","title":"Summary","text":"<ul> <li>Raw Response: The <code>response</code> object contains the raw response stream, not the parsed data.</li> <li><code>response.json()</code>: This method reads the raw stream, parses it as JSON, and returns a JavaScript object or array.</li> <li>Parsing Necessity: Parsing is necessary to convert the raw JSON text into a format that you can easily manipulate in JavaScript.</li> </ul> <p>Using <code>response.json()</code> ensures you get the JSON data correctly parsed and ready for use, which is essential for working with APIs that return data in JSON format.</p>"},{"location":"interview/http/api/#properties-methods-of-response-object-can-vary","title":"Properties &amp; Methods of <code>response</code> object can vary","text":"<p>The <code>response</code> object is central to handling HTTP responses when using modern web APIs, such as the Fetch API in JavaScript. It provides various properties and methods to access and manipulate the details of an HTTP response. </p> <p>Yes, the properties and methods of the <code>response</code> object can vary depending on the environment, library, or framework you are using.</p> <p>While there are common concepts and functionalities, the exact implementation details might differ. Here\u2019s a comparison of how different environments and libraries handle HTTP responses:</p>"},{"location":"interview/http/api/#1-fetch-api-browser","title":"1. Fetch API (Browser)","text":"<p>In the Fetch API, the <code>Response</code> object includes several standardized properties and methods:</p> PropertiesMethods <ul> <li><code>status</code>: The HTTP status code of the response.</li> <li><code>statusText</code>: The status message corresponding to the status code.</li> <li><code>headers</code>: An instance of the <code>Headers</code> class representing the response headers.</li> <li><code>url</code>: The URL of the response.</li> <li><code>type</code>: The type of the response (e.g., \"basic\", \"cors\", \"default\", \"error\", \"opaque\").</li> </ul> <ul> <li><code>text()</code>: Reads the response body as a string.</li> <li><code>json()</code>: Reads the response body and parses it as JSON.</li> <li><code>blob()</code>: Reads the response body as a <code>Blob</code> (binary data).</li> <li><code>formData()</code>: Reads the response body and parses it as <code>FormData</code>.</li> <li><code>arrayBuffer()</code>: Reads the response body as an <code>ArrayBuffer</code>.</li> </ul>"},{"location":"interview/http/api/#2-axios-javascript-library","title":"2. Axios (JavaScript Library)","text":"<p>Axios handles HTTP responses slightly differently, as it is built on top of <code>XMLHttpRequest</code> or Node.js <code>http</code> module. The <code>response</code> object in Axios includes:</p> PropertiesMethods <ul> <li><code>data</code>: The response body, automatically parsed according to the response content type (e.g., JSON).</li> <li><code>status</code>: The HTTP status code of the response.</li> <li><code>statusText</code>: The status message corresponding to the status code.</li> <li><code>headers</code>: The headers of the response.</li> <li><code>config</code>: The configuration object used for the request.</li> <li><code>request</code>: The request object (in some environments).</li> </ul> <ul> <li>Axios does not provide methods to transform the response body; instead, the <code>data</code> property is already in the parsed format (e.g., JSON).</li> </ul>"},{"location":"interview/http/api/#3-node-fetch-nodejs-library","title":"3. Node-Fetch (Node.js Library)","text":"<p>Node-Fetch closely resembles the Fetch API in browsers, but there are minor differences due to the Node.js environment:</p> PropertiesMethods <ul> <li>Similar to Fetch API with <code>status</code>, <code>statusText</code>, <code>headers</code>, <code>url</code>, and <code>type</code>.</li> </ul> <ul> <li>Similar to Fetch API with <code>text()</code>, <code>json()</code>, <code>blob()</code>, <code>formData()</code>, and <code>arrayBuffer()</code>.</li> </ul>"},{"location":"interview/http/api/#4-python-requests-library","title":"4. Python (Requests Library)","text":"<p>In the requests library for Python, the Response object has:</p> PropertiesMethods <ul> <li><code>status_code</code>: The HTTP status code of the response.</li> <li><code>headers</code>: The headers of the response.</li> <li><code>url</code>: The URL of the response.</li> <li><code>content</code>: The raw content of the response as bytes.</li> <li><code>text</code>: The content of the response decoded as a string.</li> <li><code>json()</code>: Method to parse the response body as JSON.</li> </ul> <ul> <li><code>json()</code>: Parses the response body as JSON.</li> </ul>"},{"location":"interview/http/api/#5-java-httpclient","title":"5. Java (HttpClient)","text":"<p>In Java's HttpClient:</p> PropertiesMethods <ul> <li><code>statusCode()</code>: The HTTP status code of the response.</li> <li><code>headers()</code>: The headers of the response.</li> <li><code>body()</code>: The body of the response (as a <code>BodyHandler</code> type).</li> </ul> <ul> <li>Java's HttpClient does not have direct methods like <code>text()</code> or <code>json()</code>. You handle the response body through the <code>BodyHandler</code> (e.g., <code>BodyHandlers.ofString()</code>, <code>BodyHandlers.ofByteArray()</code>).</li> </ul>"},{"location":"interview/http/api/#6-c-net-httpclient","title":"6. C# (.NET HttpClient)","text":"<p>In .NET's HttpClient:</p> PropertiesMethods <ul> <li><code>StatusCode</code>: The HTTP status code of the response.</li> <li><code>Headers</code>: The headers of the response.</li> <li><code>Content</code>: The content of the response.</li> </ul> <ul> <li>Methods for handling content, such as <code>ReadAsStringAsync()</code> for reading as a string and <code>ReadAsJsonAsync&lt;T&gt;()</code> for JSON parsing (using <code>System.Text.Json</code> or <code>Newtonsoft.Json</code>).</li> </ul>"},{"location":"interview/http/api/#summary_1","title":"Summary","text":"<ul> <li>Consistency: While there are consistent concepts (status code, headers, body content), the exact properties and methods can vary.</li> <li>Library/Environment Specifics: Each environment or library has its own way of representing and interacting with the HTTP response object.</li> <li>Adaptation: Understanding how to work with the response object depends on the specific API or library you are using, and it\u2019s important to refer to the documentation of that environment for detailed information.</li> </ul> <p>By understanding the specific details of how HTTP responses are handled in your environment, you can effectively work with responses, handle data, and manage errors.</p>"},{"location":"interview/http/asynchronous-javaScript/","title":"Asynchronous","text":""},{"location":"interview/http/asynchronous-javaScript/#overview","title":"Overview","text":"<p>To become a \"god tier\" in Asynchronous JavaScript, you need to master the fundamentals and gradually progress to more advanced topics. Here's a structured learning path to help you achieve that:</p>"},{"location":"interview/http/asynchronous-javaScript/#1-basic-understanding","title":"1. Basic Understanding","text":"<p>a.  Synchronous vs. Asynchronous Programming</p> <ul> <li>Synchronous: Code runs line by line. Each operation must complete before the next starts.</li> <li>Asynchronous: Operations can run concurrently, and you don\u2019t have to wait for one to complete before starting another.</li> </ul> <p>b.  Basic Concepts</p> <ul> <li>Callback Functions: Functions passed as arguments to other functions and executed after some operation completes.</li> <li>Event Loop: The mechanism that handles asynchronous operations in JavaScript by executing tasks from the message queue.</li> </ul>"},{"location":"interview/http/asynchronous-javaScript/#2-intermediate-concepts","title":"2. Intermediate Concepts","text":"<p>a.  Promises</p> <ul> <li>What is a Promise: An object representing the eventual completion or failure of an asynchronous operation.</li> <li>States: Pending, Fulfilled, Rejected.</li> <li>Methods: <code>.then()</code>, <code>.catch()</code>, <code>.finally()</code>.</li> </ul> <p>b.  Promise Chaining</p> <ul> <li>How to chain multiple asynchronous operations using promises.</li> </ul> <p>c.  Error Handling</p> <ul> <li>Handling errors in promises using <code>.catch()</code>.</li> </ul>"},{"location":"interview/http/asynchronous-javaScript/#3-advanced-concepts","title":"3. Advanced Concepts","text":"<p>a.  <code>async</code> and <code>await</code></p> <ul> <li>What is <code>async</code>: A keyword that defines an asynchronous function.</li> <li>What is <code>await</code>: A keyword that waits for a promise to resolve or reject.</li> </ul> <p>b.  Error Handling with <code>async</code>/<code>await</code></p> <ul> <li>Use <code>try...catch</code> for handling errors.</li> </ul> <p>c.  Concurrency</p> <ul> <li>Handling multiple asynchronous operations simultaneously using <code>Promise.all</code>, <code>Promise.allSettled</code>, <code>Promise.race</code>.</li> </ul> <p>d.  Performance Considerations</p> <ul> <li>Understanding the impact of asynchronous operations on performance.</li> </ul>"},{"location":"interview/http/asynchronous-javaScript/#4-expert-level","title":"4. Expert Level","text":"<p>a.  Advanced Patterns</p> <ul> <li>Custom Promises: Creating and handling custom promise implementations.</li> <li>Concurrency Patterns: Managing complex concurrency patterns using async generators and <code>Promise.all</code> with dependencies.</li> </ul> <p>b.  Debugging Asynchronous Code</p> <ul> <li>Techniques and tools for debugging asynchronous JavaScript, including browser DevTools.</li> </ul> <p>c.  Integration with APIs</p> <ul> <li>How to effectively integrate and handle asynchronous operations with APIs, including error handling and retries.</li> </ul> <p>d.  Real-World Applications</p> <ul> <li>Building and managing complex asynchronous applications, e.g., handling real-time data with WebSockets.</li> </ul>"},{"location":"interview/http/asynchronous-javaScript/#5-practice-and-projects","title":"5. Practice and Projects","text":"<ul> <li>Small Projects: Build projects like a to-do list or weather app to practice handling asynchronous data.</li> <li>Open Source Contributions: Contribute to open-source projects involving asynchronous JavaScript.</li> <li>Challenges and Coding Platforms: Engage in coding challenges on platforms like LeetCode or HackerRank to test your skills.</li> </ul>"},{"location":"interview/http/asynchronous-javaScript/#6-stay-updated","title":"6. Stay Updated","text":"<p>JavaScript is constantly evolving, so stay current with the latest updates and best practices by following JavaScript blogs, attending webinars, and participating in developer communities.</p> <p>By following this structured path and consistently practicing, you\u2019ll be well on your way to mastering asynchronous JavaScript and becoming a top-tier developer!</p>"},{"location":"interview/http/codesnap/","title":"Code Snap","text":""},{"location":"interview/http/codesnap/#destructuring-props","title":"Destructuring props","text":""},{"location":"interview/http/codesnap/#antd-eclipse-column","title":"antd eclipse column","text":""},{"location":"interview/http/codesnap/#reference","title":"Reference","text":"<ul> <li>uncontrolled-components: official</li> <li>understanding uncontrolled components an essential-guide-for-react-developers</li> </ul>"},{"location":"interview/http/http-request/","title":"HTTP Request","text":"<p>An HTTP request is a message sent from a client (such as a web browser or application) to a server to request data or perform an action. HTTP (Hypertext Transfer Protocol) is the foundation of data communication on the web.</p>"},{"location":"interview/http/http-request/#types-of-http-requests","title":"Types of HTTP Requests","text":"<ol> <li>GET: Requests data from a specified resource.</li> <li>POST: Submits data to be processed to a specified resource.</li> <li>PUT: Updates a specified resource with new data.</li> <li>DELETE: Deletes a specified resource.</li> <li>PATCH: Applies partial modifications to a resource.</li> </ol>"},{"location":"interview/http/http-request/#understanding-http-requests-in-javascript","title":"Understanding HTTP Requests in JavaScript","text":"<p>To master HTTP requests in JavaScript, you'll want to be familiar with the different methods for making requests, handling responses, and dealing with various scenarios like error handling and asynchronous operations. Here's a structured approach to mastering HTTP requests:</p> <ol> <li> <p>Learn the Basics</p> <ul> <li>HTTP Methods: Understand what each HTTP method does and when to use it.</li> <li>Status Codes: Learn common status codes like 200 (OK), 404 (Not Found), and 500 (Internal Server Error).</li> <li>Headers: Understand headers and their role in requests and responses (e.g., Content-Type, Authorization).</li> </ul> </li> <li> <p>Use <code>Built-in</code> APIs</p> <p>Fetch API</p> Basic UsageAdvanced Usage <pre><code>fetch('https://api.example.com/data')\n    .then(response =&gt; {\n        if (!response.ok) {\n            throw new Error('Network response was not ok');\n        }\n        return response.json();\n    })\n    .then(data =&gt; {\n        console.log(data);\n    })\n    .catch(error =&gt; {\n        console.error('Fetch error:', error);\n    });\n</code></pre> <pre><code>fetch('https://api.example.com/data', {\n    method: 'POST',\n    headers: {\n        'Content-Type': 'application/json',\n        'Authorization': 'Bearer token'\n    },\n    body: JSON.stringify({ key: 'value' })\n})\n.then(response =&gt; response.json())\n.then(data =&gt; console.log(data))\n.catch(error =&gt; console.error('Fetch error:', error));\n</code></pre> <p>XMLHttpRequest</p> Basic Usage <pre><code>var xhr = new XMLHttpRequest();\nxhr.open('GET', 'https://api.example.com/data', true);\nxhr.onload = function () {\n    if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) {\n        console.log(JSON.parse(xhr.responseText));\n    } else {\n        console.error('Request failed with status:', xhr.status);\n    }\n};\nxhr.onerror = function () {\n    console.error('Request error');\n};\nxhr.send();\n</code></pre> </li> <li> <p>Use Libraries</p> <p>Axios</p> <ul> <li>Installation: <code>npm install axios</code></li> </ul> Basic UsageAdvanced Usage <pre><code>axios.get('https://api.example.com/data')\n    .then(response =&gt; console.log(response.data))\n    .catch(error =&gt; console.error('Axios error:', error));\n</code></pre> <pre><code>axios.post('https://api.example.com/data', { key: 'value' }, {\n    headers: {\n        'Content-Type': 'application/json',\n        'Authorization': 'Bearer token'\n    }\n})\n.then(response =&gt; console.log(response.data))\n.catch(error =&gt; console.error('Axios error:', error));\n</code></pre> <p>jQuery AJAX</p> <ul> <li>Installation: Include jQuery via CDN or npm install jquery</li> </ul> Basic Usage <pre><code>$.ajax({\n    url: 'https://api.example.com/data',\n    method: 'GET',\n    success: function(data) {\n        console.log(data);\n    },\n    error: function(xhr, status, error) {\n        console.error('AJAX error:', error);\n    }\n});\n</code></pre> </li> <li> <p>Master Error Handling and Asynchronous Operations</p> <ul> <li>Handle Errors: Learn how to handle network errors, server errors, and handle cases when the response is not as expected.</li> <li> <p>Async/Await: Use async/await syntax for better readability and error handling in asynchronous code.</p> <pre><code>async function fetchData() {\n    try {\n        const response = await fetch('https://api.example.com/data');\n        if (!response.ok) {\n            throw new Error('Network response was not ok');\n        }\n        const data = await response.json();\n        console.log(data);\n    } catch (error) {\n        console.error('Fetch error:', error);\n    }\n}\n\nfetchData();\n</code></pre> </li> </ul> </li> <li> <p>Practice and Experiment</p> <ul> <li>Build Projects: Create small projects or features that require making HTTP requests.</li> <li>Explore APIs: Work with different public APIs to understand how to handle various types of data and responses.</li> </ul> </li> </ol> <p>By mastering these concepts and practices, you'll become proficient in making and handling HTTP requests in JavaScript.</p>"},{"location":"interview/http/http-response/","title":"HTTP Reponse","text":""},{"location":"interview/http/http-response/#1-http-response-overview","title":"1. HTTP Response Overview","text":"<p>An HTTP response is essentially a message sent by a server in response to a client request. It contains:</p> <ul> <li>Status Line: Includes the status code and status text.</li> <li>Headers: Metadata about the response.</li> <li>Body: The main content of the response (which could be in various formats such as <code>text</code>, <code>JSON</code>, <code>HTML</code>, <code>XML</code>, etc.).</li> </ul>"},{"location":"interview/http/http-response/#2-representation-across-different-platforms","title":"2. Representation Across Different Platforms","text":"<p>While the structure of an HTTP response is consistent (status line, headers, body), its representation can differ based on the programming language, library, or environment. Here\u2019s how it varies:</p> <p>JavaScript (Fetch API):</p> <ul> <li>Response Object: Represents the HTTP response and includes properties like status, headers, and methods like <code>json()</code>, <code>text()</code>, <code>blob()</code>.</li> <li>Data Types: The body can be read as text, JSON, or other formats depending on the method used (<code>response.json()</code>, <code>response.text()</code>, etc.).</li> </ul> <p>Python (Requests Library):</p> <ul> <li>Response Object: Contains attributes such as <code>status_code</code>, <code>headers</code>, and methods like <code>text</code> and <code>json()</code>.</li> <li>Data Types: The body can be accessed as text or parsed as JSON using <code>response.json()</code>.</li> </ul> <p>Node.js (Node-Fetch):</p> <ul> <li>Response Object: Similar to the Fetch API, with properties like status and methods like <code>json()</code>, <code>text()</code>.</li> <li>Data Types: The body can be read and parsed into various formats depending on the method used.</li> </ul> <p>Java (HttpClient):</p> <ul> <li>HttpResponse Object: Includes methods like <code>statusCode()</code>, <code>headers()</code>, and <code>body()</code>.</li> <li>Data Types: The body is accessed through <code>HttpResponse.BodyHandlers</code> and can be processed as a string or other types.</li> </ul> <p>C# (.NET HttpClient):</p> <ul> <li>HttpResponseMessage Object: Includes properties like <code>StatusCode</code>, <code>Headers</code>, and <code>Content</code>.</li> <li>Data Types: The body is accessed through the <code>Content</code> property and can be read as a string, JSON, or other formats.</li> </ul>"},{"location":"interview/http/http-response/#3-underlying-data-types","title":"3. Underlying Data Types","text":"<p>Body Content: The actual data in the body of the HTTP response can be in various formats:</p> <ul> <li><code>Text</code>: Plain text, HTML.</li> <li><code>JSON</code>: JavaScript Object Notation.</li> <li><code>Binary</code>: Images, files (handled as blobs or array buffers).</li> <li><code>FormData</code>: Key-value pairs from forms.</li> </ul>"},{"location":"interview/http/http-response/#4-summary","title":"4. Summary","text":"<ul> <li> <p>Response Representation: While the HTTP response concept is universal, its representation varies by platform or library. Each platform provides its own way to access and manipulate the response data.</p> </li> <li> <p>Data Type Consistency: The body of the response is not strictly a single data type; it can be text, JSON, binary data, etc. The platform or library you use will determine how you interact with and convert this data.</p> </li> <li> <p>Understanding the Platform: To effectively work with HTTP responses, you need to understand the specifics of the response object in the context of the platform or library you're using. This involves knowing how to access the status, headers, and body of the response, and how to handle the body in the appropriate format.</p> </li> </ul> <p>In summary, while the fundamental concept of an HTTP response is consistent across platforms, the way it is represented and the data types used can vary. The key is to understand how to work with the response object provided by the specific environment you're working in.</p>"},{"location":"interview/http/importing-file/","title":"Importing File","text":""},{"location":"interview/http/importing-file/#best-practices-for-importing-files-in-a-large-react-codebase","title":"Best Practices for Importing Files in a Large React Codebase","text":"<p>When working with a large React codebase, efficient file imports can have a significant impact on maintainability, readability, and performance. Here are some best practices for importing files in a large React project:</p>"},{"location":"interview/http/importing-file/#1-organize-files-and-folders-logically","title":"1. Organize Files and Folders Logically","text":"<ul> <li> <p>Group related components: Keep components, hooks, utilities, and styles organized in a well-structured folder hierarchy. For example:</p> <pre><code>/src\n/components\n    /Button\n    Button.jsx\n    Button.module.css\n    Button.test.jsx\n/hooks\n    useAuth.js\n/utils\n    formatDate.js\n/styles\n    theme.js\n</code></pre> </li> <li> <p>Feature-based organization: In large projects, consider organizing files based on features rather than type. For example, have a folder per feature (e.g., <code>/user</code>, <code>/auth</code>) with all the relevant files (components, hooks, etc.) inside.</p> </li> <li> <p>Use index files: Within each folder, you can create an <code>index.js</code> (or <code>.jsx</code>, <code>.ts</code>, etc.) file that exports all the relevant components and utilities. This makes it easier to import multiple files from a single location.</p> <pre><code>// /components/Button/index.js\nexport { default as Button } from \"./Button\";\nexport { default as ButtonGroup } from \"./ButtonGroup\";\n</code></pre> <p>Then, you can import like this:</p> <pre><code>import { Button, ButtonGroup } from \"components/Button\";\n</code></pre> </li> </ul>"},{"location":"interview/http/importing-file/#2-use-absolute-imports","title":"2. Use Absolute Imports","text":"<ul> <li>Avoid relative path hell: As your project grows, deeply nested folders can make relative imports cumbersome (e.g., <code>../../../</code>), which is hard to maintain and read.</li> <li>Configure absolute imports: Set up your project to use absolute imports based on the root directory, so you can import files without worrying about the relative path depth.</li> <li> <p>For React projects created with Create React App (CRA), this is as simple as adding the following to your <code>jsconfig.json</code> or <code>tsconfig.json</code>:</p> <pre><code>{\n  \"compilerOptions\": {\n      \"baseUrl\": \"src\"\n  }\n}\n</code></pre> <p>Now you can import like this:</p> <pre><code>import { Button } from 'components/Button';\n</code></pre> </li> </ul>"},{"location":"interview/http/importing-file/#3-lazy-load-with-dynamic-imports","title":"3. Lazy Load with Dynamic Imports","text":"<ul> <li> <p>For larger codebases, especially if you have heavy components, use <code>React.lazy()</code> for code splitting. This allows you to load components asynchronously, reducing the initial bundle size.</p> <pre><code>import React, { Suspense } from \"react\";\nconst LazyComponent = React.lazy(() =&gt; import(\"components/LazyComponent\"));\n\nconst App = () =&gt; (\n  &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;\n    &lt;LazyComponent /&gt;\n  &lt;/Suspense&gt;\n);\n</code></pre> </li> <li> <p>This can be particularly useful for components that are only used under certain conditions or on specific routes.</p> </li> </ul>"},{"location":"interview/http/importing-file/#4-group-imports-by-type-and-maintain-consistency","title":"4. Group Imports by Type and Maintain Consistency","text":"<ul> <li> <p>Group imports logically: Follow a consistent order for imports. A common practice is:</p> <ul> <li>React-related imports (like <code>react</code>, <code>react-dom</code>, etc.)</li> <li>Third-party libraries (e.g., <code>lodash</code>, <code>axios</code>)</li> <li>Internal modules (components, hooks, utils)</li> <li>Stylesheets (CSS, SCSS, or styled-components)</li> </ul> </li> <li> <p>Example:</p> <pre><code>// External dependencies\nimport React, { useState } from \"react\";\nimport PropTypes from \"prop-types\";\n\n// Internal modules\nimport { Button } from \"components/Button\";\nimport { useAuth } from \"hooks/useAuth\";\n\n// Styles\nimport \"./App.css\";\n</code></pre> </li> </ul>"},{"location":"interview/http/importing-file/#5-minimize-imports-from-large-libraries","title":"5. Minimize Imports from Large Libraries","text":"<ul> <li> <p>Avoid importing entire libraries if you only need specific utilities or components. For example, instead of:</p> <pre><code>import _ from \"lodash\";\n</code></pre> </li> <li> <p>You can import just the method you need:</p> <pre><code>import debounce from \"lodash/debounce\";\n</code></pre> </li> <li> <p>This reduces the size of the bundle and optimizes performance.</p> </li> </ul>"},{"location":"interview/http/importing-file/#6-avoid-circular-dependencies","title":"6. Avoid Circular Dependencies","text":"<ul> <li>Circular dependencies can introduce hard-to-debug issues and performance problems. When designing the structure of your codebase, ensure that no files rely on each other in a cyclic manner.</li> <li> <p>Use tools like Madge to detect circular dependencies:</p> <pre><code>madge --circular src/\n</code></pre> </li> <li> <p>Best way to resolve circular dependencies in TypeScript</p> </li> </ul>"},{"location":"interview/http/importing-file/#7-use-aliases-for-long-paths","title":"7. Use Aliases for Long Paths","text":"<ul> <li> <p>If your folder structure is deep, consider setting up aliases to simplify long paths. In a Webpack-based project, you can configure aliases in <code>webpack.config.js</code>:</p> <pre><code>resolve: {\n    alias: {\n        components: path.resolve(__dirname, 'src/components/'),\n        utils: path.resolve(__dirname, 'src/utils/'),\n    }\n}\n</code></pre> <p>This allows you to import with shorter, clearer paths:</p> <pre><code>import { Button } from \"components/Button\";\n</code></pre> </li> </ul>"},{"location":"interview/http/importing-file/#8-ensure-file-extensions-are-consistent","title":"8. Ensure File Extensions Are Consistent","text":"<ul> <li> <p>Stick to a convention for file extensions to avoid confusion:</p> <ul> <li><code>.jsx</code> for React components</li> <li><code>.js</code> for non-UI JavaScript files (utils, hooks, etc.)</li> <li><code>.ts</code> or <code>.tsx</code> if using TypeScript</li> <li><code>.css</code> or <code>.module.css</code> for CSS, or <code>.scss</code> if using Sass</li> </ul> </li> <li> <p>Avoid unnecessary extensions in imports. In most modern build setups (like Webpack), you don't need to specify the file extension, e.g., <code>import './styles'</code> instead of <code>import './styles.css'</code>.</p> </li> </ul>"},{"location":"interview/http/importing-file/#9-consider-barrel-files-for-large-modules","title":"9. Consider Barrel Files for Large Modules","text":"<p>A barrel file is a single file that re-exports items from several files in a directory. This is particularly useful when a directory contains many files, such as a component directory. Instead of importing each file individually, you import from the barrel.</p> <ul> <li> <p>Example</p> <pre><code>// src/components/index.js\nexport { default as Button } from \"./Button\";\nexport { default as Input } from \"./Input\";\nexport { default as Modal } from \"./Modal\";\n</code></pre> </li> <li> <p>Now, you can import all components from a single place:</p> <pre><code>import { Button, Input, Modal } from \"components\";\n</code></pre> </li> </ul>"},{"location":"interview/http/importing-file/#10-use-code-linters-for-import-style-consistency","title":"10. Use Code Linters for Import Style Consistency","text":"<ul> <li>Use linters like ESLint with plugins like <code>eslint-plugin-import</code> to enforce import conventions and prevent problems like unused imports, incorrect paths, or missing modules.</li> <li> <p>Example ESLint rule for sorting imports:</p> <pre><code>\"import/order\": [\n\"error\",\n  {\n      \"groups\": [\n          [\"builtin\", \"external\"],\n          [\"internal\"],\n          [\"parent\", \"sibling\", \"index\"]\n      ],\n      \"alphabetize\": {\n          \"order\": \"asc\",\n          \"caseInsensitive\": true\n      }\n  }\n]\n</code></pre> </li> </ul> <p>By following these best practices, you can improve the scalability, readability, and performance of your large React codebase, making it easier to maintain and collaborate on.</p> <p>How to clear the logs file in ubuntu 22.04</p>"},{"location":"interview/http/importing-file/#reference","title":"Reference","text":"<ul> <li> <p>Tyscript: w3schools</p> </li> <li> <p>What is a tsconfig.json</p> </li> <li> <p>Difference between tsconfig.json and tsconfig.app.json files in Angular</p> </li> <li> <p>Why does Vite create multiple TypeScript config files: tsconfig.json, tsconfig.app.json and tsconfig.node.json?</p> </li> </ul>"},{"location":"interview/http/jwt/","title":"jwt package","text":""},{"location":"interview/http/jwt/#overview","title":"Overview","text":"<p>Decoding a JWT token in a React application using TypeScript, Redux Toolkit, and Axios can be done in a few steps. Here is the best approach to decoding JWT tokens in your application:</p> <p></p>"},{"location":"interview/http/jwt/#steps","title":"Steps:","text":"<ol> <li>Install JWT library: To decode the JWT token, you can use a library like jsonwebtoken or jwt-decode. These libraries help decode JWT tokens without needing to manually parse the payload.</li> </ol> <pre><code>npm install jwt-decode\n</code></pre> <p>Or, you can use the jsonwebtoken library (though it's heavier and more feature-rich, including encoding/decoding and verifying tokens).</p> <pre><code>npm install jsonwebtoken\n</code></pre> <p>For simplicity, jwt-decode is the most common choice for decoding, as it\u2019s lightweight and easy to use.</p> <ol> <li>Create a utility function for decoding the JWT:</li> </ol> <p>You can create a utility file where you define your JWT decoding function.</p> utils/jwtDecode.ts<pre><code>import jwtDecode from \"jwt-decode\";\n\nexport interface DecodedToken {\n  exp: number;\n  iat: number;\n  [key: string]: any;\n}\n\nexport const decodeToken = (token: string): DecodedToken | null =&gt; {\n  try {\n    const decoded = jwtDecode&lt;DecodedToken&gt;(token);\n    return decoded;\n  } catch (error) {\n    console.error(\"Invalid token:\", error);\n    return null;\n  }\n};\n</code></pre> <p>This utility will take in a JWT string and return the decoded payload, or <code>null</code> if the token is invalid.</p> <ol> <li>Integrating the decoding into Redux state:</li> </ol> <p>If you need to store the decoded token (or certain parts of it, like user information or expiration) in your Redux store, you can use Redux Toolkit to store and manage the JWT data.</p> redux/slices/authSlice.ts<pre><code>import { createSlice, PayloadAction } from \"@reduxjs/toolkit\";\nimport { decodeToken, DecodedToken } from \"../../utils/jwtDecode\";\n\ninterface AuthState {\n  token: string | null;\n  decodedToken: DecodedToken | null;\n  isAuthenticated: boolean;\n}\n\nconst initialState: AuthState = {\n  token: null,\n  decodedToken: null,\n  isAuthenticated: false,\n};\n\nconst authSlice = createSlice({\n  name: \"auth\",\n  initialState,\n  reducers: {\n    setToken: (state, action: PayloadAction&lt;string&gt;) =&gt; {\n      state.token = action.payload;\n      state.decodedToken = decodeToken(action.payload);\n      state.isAuthenticated = state.decodedToken ? true : false;\n    },\n    logout: (state) =&gt; {\n      state.token = null;\n      state.decodedToken = null;\n      state.isAuthenticated = false;\n    },\n  },\n});\n\nexport const { setToken, logout } = authSlice.actions;\n\nexport default authSlice.reducer;\n</code></pre> <p>Here, the <code>setToken</code> action will update the token in the state and decode it using the decodeToken utility.</p> <ol> <li>Dispatching actions after login or token update:</li> </ol> <p>In your component or wherever you handle authentication (e.g., Axios interceptors or login logic), you will dispatch the action to set the token and store the decoded value in Redux.</p> <p>Example: Axios Interceptor for Token Handling</p> utils/axios.ts<pre><code>import axios from \"axios\";\nimport { store } from \"../store\";\nimport { setToken } from \"../redux/slices/authSlice\";\n\nconst axiosInstance = axios.create({\n  baseURL: \"https://api.example.com\",\n});\n\n// Interceptor to handle token storage and refresh\naxiosInstance.interceptors.response.use(\n  (response) =&gt; response,\n  (error) =&gt; {\n    if (error.response?.status === 401) {\n      // Handle Unauthorized (token expired or invalid)\n      store.dispatch(setToken(\"\")); // Remove token and clear auth state\n    }\n    return Promise.reject(error);\n  }\n);\n\nexport default axiosInstance;\n</code></pre> <p>After a successful login (e.g., from a <code>login</code> function), you will store the token in Redux:</p> <pre><code>// On successful login\nconst handleLogin = async (username: string, password: string) =&gt; {\n  try {\n    const response = await axiosInstance.post(\"/login\", { username, password });\n    const token = response.data.token;\n    store.dispatch(setToken(token)); // Dispatch the token to Redux\n  } catch (error) {\n    console.error(\"Login failed:\", error);\n  }\n};\n</code></pre> <ol> <li>Accessing the decoded token in a component:</li> </ol> <p>You can easily access the decoded token or any other properties from your Redux store using the <code>useSelector</code> hook in React components.</p> components/Profile.tsx<pre><code>import React from \"react\";\nimport { useSelector } from \"react-redux\";\nimport { RootState } from \"../store\";\n\nconst Profile: React.FC = () =&gt; {\n  const { decodedToken, isAuthenticated } = useSelector(\n    (state: RootState) =&gt; state.auth\n  );\n\n  if (!isAuthenticated) {\n    return &lt;div&gt;Please log in&lt;/div&gt;;\n  }\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Profile&lt;/h1&gt;\n      &lt;p&gt;User ID: {decodedToken?.userId}&lt;/p&gt;\n      &lt;p&gt;Expiration: {new Date(decodedToken?.exp * 1000).toLocaleString()}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default Profile;\n</code></pre> <p>Key Points:</p> <ul> <li>Use jwt-decode to decode the JWT payload easily.</li> <li>Store the decoded JWT information in Redux using the Redux Toolkit (<code>setToken</code> action).</li> <li>Use Axios interceptors to handle token expiration or refresh.</li> <li>Access the decoded token in your React components via <code>useSelector</code>.</li> </ul>"},{"location":"interview/http/jwt/#alternative-jwt-decoding-without-redux","title":"Alternative (JWT Decoding without Redux):","text":"<p>If you just need to decode the token once in the component or in specific places, you can directly use the <code>jwt-decode</code> function without storing it in Redux.</p> <p>For example:</p> <pre><code>import jwtDecode from \"jwt-decode\";\n\nconst decodedToken = jwtDecode(token);\nconsole.log(decodedToken);\n</code></pre> <p>But using Redux for managing the JWT state is a good practice when you need to globally manage authentication state and access decoded token data across your application.</p>"},{"location":"interview/http/jwt/#conclusion","title":"Conclusion:","text":"<p>This approach allows you to decode JWT tokens efficiently, store decoded values in Redux, and manage authentication across your application. Using <code>jwt-decode</code> with Redux Toolkit provides a clear and maintainable structure for handling JWTs in a React app.</p>"},{"location":"interview/http/react/","title":"React","text":"<p>Tip</p> <ul> <li>Next.js: React framework</li> <li>styled-components: CSS styling</li> <li>apollographql: Data API</li> <li>authjs: Authentication</li> <li>React Testing Library and Jest: Testing</li> <li>GitHub: Version control</li> <li>Vercel: Serverless online web host</li> </ul>"},{"location":"interview/http/react/#internationalization-and-localization","title":"Internationalization and localization","text":"<p>Internationalization and localization are basic practices in software development that enable you to design and deploy systems that can be tailored to multiple languages and areas. Let\u2019s learn the difference between them.</p>"},{"location":"interview/http/react/#what-is-internationalization","title":"What is internationalization?","text":"<p>Internationalization is the process of creating and preparing your application so that it can potentially be used in several languages. This frequently entails extracting all of your application\u2019s strings into distinct files that can potentially be translated into multiple languages. It also requires structuring your software to ensure that it can correctly manage and show these translations.</p>"},{"location":"interview/http/react/#what-is-localization","title":"What is localization?","text":"<p>This involves translating your locally optimized application into specific native languages. Translating an application\u2019s text is only one aspect of localization. It might also include other regionally unique elements, such as text direction, number forms, and date and time formats, among other things. React Router allows you to build localized routes. To manage language choice, you might, for instance, have several routes for various languages (such as \"<code>/en/about</code>\u201d and \"<code>/fr/about</code>\") or you can utilize a context or state.</p> <p>We have learned so much already and our knowledge has increased a lot. Next, we will move on to the penultimate section of this chapter, where we are going to learn all about adding translations and formatted messages in our React applications. We just learned about internationalization and localization, which is where we prepare our applications for different languages. Now, let\u2019s learn how to implement different languages in the code we write.</p>"},{"location":"interview/mf/micro-frontend/","title":"Micro Frontend","text":""},{"location":"interview/mf/micro-frontend/#micro-frontend","title":"Micro Frontend","text":""},{"location":"interview/mf/micro-frontend/#reference","title":"Reference","text":""},{"location":"interview/pwa/intro/","title":"PWA","text":""},{"location":"interview/pwa/intro/#what-is-a-pwa","title":"What is a PWA?","text":"<p>A Progressive Web App (PWA) is a type of web application that uses modern web technologies to deliver an app-like experience to users. PWAs combine the best of web and mobile apps, offering features such as:</p> <ol> <li>Offline Capability: PWAs can work offline or in low-network conditions thanks to service workers.</li> <li>App-like Experience: They can be added to the home screen and launched in a standalone window, resembling native apps.</li> <li>Responsive Design: PWAs work seamlessly across various devices and screen sizes.</li> <li>Push Notifications: They can send notifications to users even when the app isn't open.</li> <li>Fast Loading: Optimized for speed and performance, enhancing user experience.</li> </ol>"},{"location":"interview/pwa/intro/#can-any-website-be-made-a-pwa","title":"Can Any Website Be Made a PWA?","text":"<p>Yes, most websites can be turned into PWAs, but certain criteria and enhancements are necessary:</p> <ol> <li>HTTPS: Your website must be served over HTTPS for security reasons.</li> <li>Web App Manifest: Include a manifest file that provides metadata about the app.</li> <li>Service Worker: Implement a service worker to handle caching, offline access, and push notifications.</li> <li>Responsive Design: Ensure the website is mobile-friendly and works well on various screen sizes.</li> <li>Performance Optimization: Optimize loading times and responsiveness to provide a smooth user experience.</li> </ol>"},{"location":"interview/pwa/intro/#steps-to-turn-your-website-into-a-pwa","title":"Steps to Turn Your Website into a PWA","text":"<ol> <li>Serve Over HTTPS: Ensure your site is secure.</li> <li>Create a Manifest File: Define your app\u2019s metadata.</li> <li>Implement a Service Worker: This script runs in the background and manages caching and offline capabilities.</li> <li>Make It Responsive: Use responsive design techniques (like CSS media queries) to ensure usability on all devices.</li> <li>Test Your PWA: Use tools like Google Lighthouse to assess your PWA\u2019s performance and compliance.</li> </ol>"},{"location":"interview/pwa/intro/#summary","title":"Summary","text":"<p>While you can convert most websites into PWAs, achieving the best results may require some development effort and optimizations. Once done, users can enjoy a more integrated, app-like experience!</p>"},{"location":"interview/pwa/intro/#reference","title":"Reference","text":"<ul> <li>Adjust Color Temperature of Your Screen Using Terminal in Ubuntu and Fedora</li> <li>Use web apps</li> </ul>"},{"location":"interview/selling-app/app-ideas/","title":"App Ideas","text":""},{"location":"interview/selling-app/app-ideas/#overview","title":"Overview","text":"<p>Choosing between a web app and a mobile app largely depends on your target audience and market needs. Generally, web apps have a broader reach since they can be accessed on any device with a browser, while mobile apps can offer better performance and user experience on smartphones.</p>"},{"location":"interview/selling-app/app-ideas/#sellable-apps-web-app-vs-mobile-app","title":"Sellable Apps: Web App vs. Mobile App","text":"<ul> <li>Web Apps: Often easier to develop and maintain, they can be updated without user intervention. Ideal for productivity tools, SaaS platforms, and content-heavy applications.</li> <li>Mobile Apps: Tend to have higher engagement and user retention. They are better for apps requiring native device features like GPS, camera, or push notifications. Ideal for social networking, gaming, and lifestyle apps.</li> </ul>"},{"location":"interview/selling-app/app-ideas/#sellable-web-app-ideas","title":"Sellable Web App Ideas","text":"<ol> <li> <p>SaaS Tools for Businesses</p> <ul> <li>Ideas: Project management, CRM, invoicing, or HR management tools.</li> </ul> </li> <li> <p>E-commerce Platform</p> <ul> <li>Ideas: Niche marketplaces, subscription box services, or local delivery platforms.</li> </ul> </li> <li> <p>Online Learning Management System</p> <ul> <li>Ideas: Course creation and tracking for schools or corporate training.</li> </ul> </li> <li> <p>Customer Feedback and Survey Tool</p> <ul> <li>Ideas: Tools to create surveys, polls, and analyze feedback.</li> </ul> </li> <li> <p>Digital Marketing Dashboard</p> <ul> <li>Ideas: Analytics and reporting tool for marketing campaigns across channels.</li> </ul> </li> <li> <p>Recipe Management and Meal Planning</p> <ul> <li>Ideas: Meal planners with shopping lists and nutritional information.</li> </ul> </li> <li> <p>Remote Team Collaboration Tool</p> <ul> <li>Ideas: Virtual whiteboards, brainstorming tools, or document collaboration.</li> </ul> </li> <li> <p>Real Estate Listing Platform</p> <ul> <li>Ideas: A portal for property listings, virtual tours, and agent profiles.</li> </ul> </li> <li> <p>Fitness and Nutrition Tracker</p> <ul> <li>Ideas: Tools for tracking workouts, meal plans, and progress.</li> </ul> </li> <li> <p>Personal Finance Management</p> <ul> <li>Ideas: Budgeting tools with expense tracking and financial planning.</li> </ul> </li> </ol>"},{"location":"interview/selling-app/app-ideas/#sellable-mobile-app-ideas","title":"Sellable Mobile App Ideas","text":"<ol> <li> <p>Fitness and Wellness App</p> <ul> <li>Ideas: Workout tracking, guided workouts, and community challenges.</li> </ul> </li> <li> <p>Mental Health and Meditation App</p> <ul> <li>Ideas: Mindfulness exercises, journaling, and mood tracking.</li> </ul> </li> <li> <p>Travel Planning App</p> <ul> <li>Ideas: Itinerary builders, travel journal, and collaboration features.</li> </ul> </li> <li> <p>Social Networking for Specific Interests</p> <ul> <li>Ideas: Platforms for niche communities (e.g., book lovers, pet owners).</li> </ul> </li> <li> <p>Recipe and Meal Planning App</p> <ul> <li>Ideas: Features for saving recipes, meal prepping, and grocery lists.</li> </ul> </li> <li> <p>Event Planning and RSVP App</p> <ul> <li>Ideas: Tools for organizing events, sending invites, and managing RSVPs.</li> </ul> </li> <li> <p>Personal Finance Tracker</p> <ul> <li>Ideas: Expense logging, budget creation, and savings goals.</li> </ul> </li> <li> <p>Language Learning App</p> <ul> <li>Ideas: Interactive lessons, quizzes, and community practice.</li> </ul> </li> <li> <p>Augmented Reality Shopping</p> <ul> <li>Ideas: Virtual try-ons for clothing, furniture, or cosmetics.</li> </ul> </li> <li> <p>Gamified Learning for Kids</p> <ul> <li>Ideas: Interactive games that teach subjects like math, science, or languages.</li> </ul> </li> </ol>"},{"location":"interview/selling-app/app-ideas/#conclusion","title":"Conclusion","text":"<p>Both web apps and mobile apps can be profitable, but the choice should align with user needs and the unique value you can offer. Research your target market to identify gaps and opportunities in either space. Each idea can be further tailored based on specific features, target demographics, or industry needs!</p>"},{"location":"interview/selling-app/finance/","title":"Finance","text":""},{"location":"interview/selling-app/finance/#overview","title":"Overview","text":"<p>This sounds like a financial tracking or budgeting application. A few names could be:</p> <ul> <li>Balance Tracker</li> <li>SpendSmart</li> <li>BudgetEase</li> <li>TrackMyFunds</li> <li>MoneyFlow</li> </ul> <p>Your question could be rephrased as: \"What type of application would this be categorized as, and what would be a suitable architecture for it?\"</p> <p>This type of application is typically categorized as a Personal Finance or Budgeting application. Its goal is to help users track and manage their finances, including income, expenses, and savings.</p>"},{"location":"interview/selling-app/finance/#suggested-navigation-menu-structure","title":"Suggested Navigation Menu Structure","text":"<p>A potential sidebar or top navigation menu could look like this:</p> <ul> <li>Home</li> <li>Balance Management</li> <li>Spending</li> <li>Reports</li> <li>Profile</li> <li>Logout</li> </ul> Dashboard.jsBalanceManagement.jsSpending.jsReports.jsProfile.jsLogin.jsSignup.js <p>The <code>Dashboard</code> page displays the user\u2019s balance using Ant Design\u2019s <code>Card</code> and <code>Statistic</code> components.</p> <pre><code>// src/pages/Dashboard.js\nimport React from 'react';\nimport { useGetUserBalanceQuery } from '../features/apiSlice';\nimport { Card, Statistic, Spin, Alert } from 'antd';\n\nfunction Dashboard() {\n    const { data: balance, error, isLoading } = useGetUserBalanceQuery();\n\n    if (isLoading) return &lt;Spin /&gt;;\n    if (error) return &lt;Alert message=\"Error\" description={error.message} type=\"error\" /&gt;;\n\n    return (\n        &lt;div style={{ padding: 24 }}&gt;\n            &lt;Card title=\"Dashboard\" bordered={false} style={{ marginBottom: 16 }}&gt;\n                &lt;Statistic title=\"Total Balance\" value={`$${balance?.totalBalance}`} precision={2} /&gt;\n                &lt;Statistic title=\"Spending Balance\" value={`$${balance?.spendingBalance}`} precision={2} /&gt;\n            &lt;/Card&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default Dashboard;\n</code></pre> <p>The <code>BalanceManagement</code> page allows users to update their total balance using Ant Design\u2019s Form and <code>InputNumber</code> components.</p> <pre><code>// src/pages/BalanceManagement.js\nimport React, { useState } from 'react';\nimport { useGetUserBalanceQuery, useAddSpendingMutation } from '../features/apiSlice';\nimport { Form, InputNumber, Button, Card, Spin, Alert } from 'antd';\n\nfunction BalanceManagement() {\n    const { data: balance, error, isLoading } = useGetUserBalanceQuery();\n    const [updateBalance] = useAddSpendingMutation();\n    const [totalBalance, setTotalBalance] = useState(balance?.totalBalance || 0);\n\n    const handleSubmit = async () =&gt; {\n        try {\n            await updateBalance({ totalBalance });\n            alert('Balance updated!');\n        } catch (err) {\n            console.error('Update failed:', err);\n        }\n    };\n\n    return (\n        &lt;div style={{ padding: 24 }}&gt;\n            &lt;Card title=\"Balance Management\"&gt;\n                {isLoading &amp;&amp; &lt;Spin /&gt;}\n                {error &amp;&amp; &lt;Alert message=\"Error\" description={error.message} type=\"error\" /&gt;}\n                {!isLoading &amp;&amp; !error &amp;&amp; (\n                &lt;Form onFinish={handleSubmit}&gt;\n                    &lt;Form.Item label=\"Total Balance\"&gt;\n                        &lt;InputNumber\n                            value={totalBalance}\n                            onChange={(value) =&gt; setTotalBalance(value)}\n                            min={0}\n                            style={{ width: '100%' }}\n                        /&gt;\n                    &lt;/Form.Item&gt;\n                    &lt;Form.Item&gt;\n                        &lt;Button type=\"primary\" htmlType=\"submit\"&gt;Update Balance&lt;/Button&gt;\n                    &lt;/Form.Item&gt;\n                &lt;/Form&gt;\n                )}\n            &lt;/Card&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default BalanceManagement;\n</code></pre> <p>The <code>Spending</code> page lists all spending records and includes an option to add a new spending record using <code>Form</code>, <code>InputNumber</code>, and <code>List</code> components from Ant Design.</p> <pre><code>// src/pages/Spending.js\nimport React, { useState } from 'react';\nimport { useGetSpendingRecordsQuery, useAddSpendingMutation } from '../features/apiSlice';\nimport { Form, InputNumber, Button, Card, List, Spin, Alert } from 'antd';\n\nfunction Spending() {\n    const { data: spendingRecords, isLoading, error } = useGetSpendingRecordsQuery();\n    const [addSpending] = useAddSpendingMutation();\n    const [amount, setAmount] = useState(0);\n\n    const handleAddSpending = async () =&gt; {\n        try {\n            await addSpending({ amount });\n            setAmount(0);\n            alert('Spending record added!');\n        } catch (err) {\n            console.error('Add spending failed:', err);\n        }\n    };\n\n    return (\n        &lt;div style={{ padding: 24 }}&gt;\n            &lt;Card title=\"Spending\"&gt;\n                {isLoading &amp;&amp; &lt;Spin /&gt;}\n                {error &amp;&amp; &lt;Alert message=\"Error\" description={error.message} type=\"error\" /&gt;}\n\n                &lt;Form onFinish={handleAddSpending} layout=\"inline\"&gt;\n                    &lt;Form.Item label=\"Amount\"&gt;\n                        &lt;InputNumber\n                            value={amount}\n                            onChange={(value) =&gt; setAmount(value)}\n                            min={0}\n                        /&gt;\n                    &lt;/Form.Item&gt;\n                    &lt;Form.Item&gt;\n                        &lt;Button type=\"primary\" htmlType=\"submit\"&gt;Add Spending&lt;/Button&gt;\n                    &lt;/Form.Item&gt;\n                &lt;/Form&gt;\n\n                &lt;List\n                    header={&lt;strong&gt;Spending Records&lt;/strong&gt;}\n                    bordered\n                    dataSource={spendingRecords || []}\n                    renderItem={(record) =&gt; (\n                        &lt;List.Item&gt;\n                            ${record.amount} - {record.date}\n                        &lt;/List.Item&gt;\n                    )}\n                /&gt;\n            &lt;/Card&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default Spending;\n</code></pre> <p>The <code>Reports</code> page uses <code>Card</code> to provide a placeholder for reports.</p> <pre><code>// src/pages/Reports.js\nimport React from 'react';\nimport { Card } from 'antd';\n\nfunction Reports() {\n    return (\n        &lt;div style={{ padding: 24 }}&gt;\n            &lt;Card title=\"Reports\"&gt;\n                &lt;p&gt;Reports will be displayed here...&lt;/p&gt;\n            &lt;/Card&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default Reports;\n</code></pre> <p>The <code>Profile</code> page is a placeholder for displaying and managing user profile details.</p> <pre><code>// src/pages/Profile.js\nimport React from 'react';\nimport { Card } from 'antd';\n\nfunction Profile() {\n    return (\n        &lt;div style={{ padding: 24 }}&gt;\n            &lt;Card title=\"Profile\"&gt;\n                &lt;p&gt;Manage your profile here...&lt;/p&gt;\n            &lt;/Card&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default Profile;\n</code></pre> <p>The <code>Login</code> page uses Ant Design\u2019s <code>Form</code> and <code>Input</code> components.</p> <pre><code>// src/pages/Login.js\nimport React, { useState } from 'react';\nimport { useLoginMutation } from '../features/apiSlice';\nimport { useNavigate } from 'react-router-dom';\nimport { Form, Input, Button, Card, Alert } from 'antd';\n\nfunction Login() {\n    const [login, { isLoading }] = useLoginMutation();\n    const [error, setError] = useState(null);\n    const navigate = useNavigate();\n\n    const handleSubmit = async ({ email, password }) =&gt; {\n        try {\n            const { data } = await login({ email, password });\n            localStorage.setItem('authToken', data.token);\n            navigate('/dashboard');\n        } catch (err) {\n            setError('Login failed. Please check your credentials.');\n        }\n    };\n\n    return (\n        &lt;div style={{ padding: 24 }}&gt;\n            &lt;Card title=\"Login\"&gt;\n                {error &amp;&amp; &lt;Alert message=\"Error\" description={error} type=\"error\" /&gt;}\n\n                &lt;Form onFinish={handleSubmit}&gt;\n                    &lt;Form.Item name=\"email\" rules={[{ required: true, message: 'Please enter your email!' }]}&gt;\n                        &lt;Input placeholder=\"Email\" /&gt;\n                    &lt;/Form.Item&gt;\n                    &lt;Form.Item name=\"password\" rules={[{ required: true, message: 'Please enter your password!' }]}&gt;\n                        &lt;Input.Password placeholder=\"Password\" /&gt;\n                    &lt;/Form.Item&gt;\n                    &lt;Form.Item&gt;\n                        &lt;Button type=\"primary\" htmlType=\"submit\" loading={isLoading}&gt;Login&lt;/Button&gt;\n                    &lt;/Form.Item&gt;\n                &lt;/Form&gt;\n            &lt;/Card&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default Login;\n</code></pre> <p>The <code>Signup</code> page uses Ant Design\u2019s <code>Form</code> and <code>Input</code> components as well.</p> <pre><code>// src/pages/Signup.js\nimport React from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport { Form, Input, Button, Card } from 'antd';\n\nfunction Signup() {\n    const navigate = useNavigate();\n\n    const handleSubmit = (values) =&gt; {\n        console.log('Signup:', values);\n        navigate('/login');\n    };\n\n    return (\n        &lt;div style={{ padding: 24 }}&gt;\n            &lt;Card title=\"Signup\"&gt;\n                &lt;Form onFinish={handleSubmit}&gt;\n                    &lt;Form.Item name=\"email\" rules={[{ required: true, message: 'Please enter your email!' }]}&gt;\n                        &lt;Input placeholder=\"Email\" /&gt;\n                    &lt;/Form.Item&gt;\n                    &lt;Form.Item name=\"password\" rules={[{ required: true, message: 'Please enter your password!' }]}&gt;\n                        &lt;Input.Password placeholder=\"Password\" /&gt;\n                    &lt;/Form.Item&gt;\n                    &lt;Form.Item&gt;\n                        &lt;Button type=\"primary\" htmlType=\"submit\"&gt;Signup&lt;/Button&gt;\n                    &lt;/Form.Item&gt;\n                &lt;/Form&gt;\n            &lt;/Card&gt;\n        &lt;/div&gt;\n    );\n}\n\nexport default Signup;\n</code></pre>"},{"location":"interview/selling-app/intro/","title":"Intro","text":"<p>Selling APP</p>"},{"location":"interview/selling-app/intro/#live-app","title":"Live App","text":""},{"location":"interview/selling-app/intro/#production-app","title":"Production App","text":""},{"location":"interview/selling-app/intro/#example-real-time-api-sources","title":"Example Real-Time API Sources","text":"<ol> <li> <p>Free APIs:</p> <ul> <li>DummyJSON for users: https://dummyjson.com.</li> </ul> </li> <li> <p>Financial APIs:</p> <ul> <li>Open Exchange Rates: https://openexchangerates.org/</li> <li>Alpha Vantage: https://www.alphavantage.co/</li> </ul> </li> </ol>"},{"location":"interview/storybook/intro/","title":"StoryBook","text":""},{"location":"interview/storybook/intro/#overview","title":"Overview","text":"<p>Astro is a modern static site generator designed for building fast, optimized websites. It allows developers to create websites using their favorite frameworks, like React, Vue, or Svelte, while focusing on performance and reducing client-side JavaScript.</p> Key features include: <ol> <li>Partial Hydration: Astro only sends JavaScript to the client when necessary, improving loading times.</li> <li>Component-based: You can use various UI frameworks alongside each other in a single project.</li> <li>Static Site Generation: It generates static HTML at build time, which can be served quickly.</li> <li>Markdown and MDX Support: Easily write content using Markdown, with the ability to include interactive components via MDX.</li> </ol> <p>Astro is ideal for content-heavy sites, blogs, and portfolios, emphasizing speed and simplicity.</p>"},{"location":"interview/storybook/intro/#what-is-createslice","title":"what is createSlice","text":"<p><code>createSlice</code> is a function provided by Redux Toolkit that simplifies the process of creating Redux slices. A slice is a portion of the Redux state and includes both the reducer logic and the actions that can modify that state. Here's a detailed breakdown of what <code>createSlice</code> does:</p>"},{"location":"interview/storybook/intro/#key-features-of-createslice","title":"Key Features of <code>createSlice</code>","text":"<ol> <li> <p>Combines Reducers and Actions:</p> <ul> <li>With <code>createSlice</code>, you can define the initial state, the reducers, and the actions all in one place, which reduces boilerplate code.</li> </ul> </li> <li> <p>Automatically Generates Action Creators:</p> <ul> <li>For each reducer you define, <code>createSlice</code> automatically generates corresponding action creators. This means you don\u2019t need to create them manually.</li> </ul> </li> <li> <p>Immer Library:</p> <ul> <li><code>createSlice</code> uses the Immer library under the hood, which allows you to write \"mutating\" logic in your reducers. This means you can directly mutate the state, and Immer will take care of producing an immutable state.</li> </ul> </li> <li> <p>Easier to Understand:</p> <ul> <li>The API is designed to be intuitive and easier to work with compared to traditional Redux patterns.</li> </ul> </li> </ol> Basic StructureComponents of <code>createSlice</code> <p>Here\u2019s a basic example of how to use createSlice:</p> <pre><code>import { createSlice } from '@reduxjs/toolkit'\n\nconst counterSlice = createSlice({\n    name: 'counter', // Name of the slice\n    initialState: {\n        value: 0, // Initial state\n    },\n    reducers: {\n        increment: (state) =&gt; {\n            state.value += 1; // Mutate state directly\n        },\n        decrement: (state) =&gt; {\n            state.value -= 1; // Mutate state directly\n        },\n        incrementByAmount: (state, action) =&gt; {\n            state.value += action.payload; // Mutate state directly with payload\n        },\n    },\n});\n\n// Export actions\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions;\n\n// Export reducer\nexport default counterSlice.reducer;\n</code></pre> <ol> <li> <p>name: A string that defines the slice's name. This is used as a prefix for generated action types (e.g., <code>counter/increment</code>).</p> </li> <li> <p>initialState: The initial state of the slice.</p> </li> <li> <p>reducers: An object where each key is a reducer function. The function can directly mutate the state because of Immer's usage.</p> </li> </ol> <p>How to Use</p> <p>You would typically combine the slice's reducer with others in your Redux store setup:</p> <pre><code>import { configureStore } from \"@reduxjs/toolkit\";\nimport counterReducer from \"./counterSlice\";\n\nconst store = configureStore({\n  reducer: {\n    counter: counterReducer, // Adding the counter slice reducer to the store\n  },\n});\n</code></pre> <p>Conclusion</p> <p>In summary, <code>createSlice</code> is a powerful tool in Redux Toolkit that streamlines state management by allowing you to define a slice of state, its actions, and its reducers all in one concise structure. It promotes best practices while reducing boilerplate, making it easier to work with Redux in modern applications.</p>"},{"location":"interview/storybook/intro/#reference","title":"Reference","text":"<ul> <li>Is spending time learning storybook worth it? </li> <li>is it worth maintaining a storybook</li> <li>What is Storybook and Why Developers Should Use It</li> <li>The Benefits and Frustrations of Using Storybook</li> </ul>"},{"location":"interview/topic/best-approach-rtk/","title":"Best Approach RTK","text":""},{"location":"interview/topic/best-approach-rtk/#revolt-1","title":"Revolt 1","text":"<pre><code>src/\n\u2514\u2500\u2500 redux/\n    \u251c\u2500\u2500 store/\n    \u2502   \u2514\u2500\u2500 index.js        // Configure and export the Redux store\n    \u251c\u2500\u2500 middleware/\n    \u2502   \u2514\u2500\u2500 customMiddleware.js // Your custom middleware (if any)\n    \u251c\u2500\u2500 blog/\n    \u2502   \u251c\u2500\u2500 api.js          // API calls using Axios\n    \u2502   \u251c\u2500\u2500 slice.js        // Redux slice for blog state\n    \u2502   \u2514\u2500\u2500 services.js     // Business logic and service functions\n    \u2514\u2500\u2500 index.js            // Optional: combine all slices if needed\n</code></pre> <p>Breakdown of Each File</p> 1. <code>api.js</code>:2. <code>slice.js</code>:3. <code>services.js</code>:Using <ul> <li>Use this file to define your Axios instance and API calls.</li> <li> <p>Example:</p> <pre><code>import axios from 'axios';\n\nconst api = axios.create({\n    baseURL: 'https://your-api-url.com',\n});\n\nexport const fetchBlogs = () =&gt; api.get('/blogs');\nexport const createBlog = (blogData) =&gt; api.post('/blogs', blogData);\n</code></pre> </li> </ul> <ul> <li>This file contains the Redux slice for managing the blog state.</li> <li> <p>Example:</p> <pre><code>import { createSlice } from '@reduxjs/toolkit';\n\nconst blogSlice = createSlice({\n    name: 'blog',\n    initialState: {\n        blogs: [],\n        loading: false,\n        error: null,\n    },\n    reducers: {\n        setBlogs: (state, action) =&gt; {\n            state.blogs = action.payload;\n        },\n        setLoading: (state, action) =&gt; {\n            state.loading = action.payload;\n        },\n        setError: (state, action) =&gt; {\n            state.error = action.payload;\n        },\n    },\n});\n\nexport const { setBlogs, setLoading, setError } = blogSlice.actions;\nexport default blogSlice.reducer;\n</code></pre> </li> </ul> <ul> <li>Handle the business logic and asynchronous operations here, like dispatching actions.</li> <li> <p>Example:</p> <pre><code>import { fetchBlogs } from './api';\nimport { setBlogs, setLoading, setError } from './slice';\n\nexport const loadBlogs = () =&gt; async (dispatch) =&gt; {\n    dispatch(setLoading(true));\n    try {\n        const response = await fetchBlogs();\n        dispatch(setBlogs(response.data));\n    } catch (error) {\n        dispatch(setError(error.message));\n    } finally {\n        dispatch(setLoading(false));\n    }\n};\n</code></pre> </li> </ul> <pre><code>import React, { useEffect } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { loadBlogs } from \"../redux/blog/services\";\n\nconst BlogList = () =&gt; {\n    const dispatch = useDispatch();\n    const blogs = useSelector((state) =&gt; state.blog.blogs);\n    const loading = useSelector((state) =&gt; state.blog.loading);\n    const error = useSelector((state) =&gt; state.blog.error);\n\n    useEffect(() =&gt; {\n        dispatch(loadBlogs());\n    }, [dispatch]);\n\n    if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;\n\n    return (\n        &lt;ul&gt;\n            {blogs.map((blog) =&gt; (\n                &lt;li key={blog.id}&gt;{blog.title}&lt;/li&gt;\n            ))}\n        &lt;/ul&gt;\n    );\n};\n\nexport default BlogList;\n</code></pre>"},{"location":"interview/topic/best-approach-rtk/#revolt-2","title":"Revolt 2","text":"StructureExplanationBenefits of This Structure <pre><code>src/\n\u2514\u2500\u2500 redux/\n    \u251c\u2500\u2500 store/\n    \u2502   \u2514\u2500\u2500 index.js             // Configure and export the Redux store\n    \u251c\u2500\u2500 middleware/\n    \u2502   \u2514\u2500\u2500 customMiddleware.js   // Your custom middleware (if any)\n    \u251c\u2500\u2500 features/\n    \u2502   \u251c\u2500\u2500 blogs/\n    \u2502   \u2502   \u251c\u2500\u2500 api.js            // API calls for blogs\n    \u2502   \u2502   \u251c\u2500\u2500 slice.js          // Redux slice for blogs\n    \u2502   \u2502   \u2514\u2500\u2500 services.js       // Business logic for blogs\n    \u2502   \u251c\u2500\u2500 users/\n    \u2502   \u2502   \u251c\u2500\u2500 api.js            // API calls for users\n    \u2502   \u2502   \u251c\u2500\u2500 slice.js          // Redux slice for users\n    \u2502   \u2502   \u2514\u2500\u2500 services.js       // Business logic for users\n    \u2502   \u251c\u2500\u2500 comments/\n    \u2502   \u2502   \u251c\u2500\u2500 api.js            // API calls for comments\n    \u2502   \u2502   \u251c\u2500\u2500 slice.js          // Redux slice for comments\n    \u2502   \u2502   \u2514\u2500\u2500 services.js       // Business logic for comments\n    \u2502   \u2514\u2500\u2500 ...                   // Other feature folders\n    \u2514\u2500\u2500 index.js                  // Optional: combine all slices if needed\n</code></pre> <ol> <li> <p><code>features/ Folder</code>:</p> <ul> <li>This is a dedicated folder for all your feature slices. Each feature (like blogs, users, comments, etc.) gets its own subfolder.</li> </ul> </li> <li> <p>Feature Structure:</p> <p>Inside each feature folder, you maintain the same structure:</p> <ul> <li><code>api.js</code>: Contains API calls relevant to that feature.</li> <li><code>slice.js</code>: Contains the Redux slice for managing that feature's state.</li> <li><code>services.js</code>: Contains the business logic and any async actions for that feature.</li> </ul> </li> </ol> <ul> <li>Scalability: You can easily add new features without cluttering the Redux folder. Each feature is self-contained.</li> <li>Maintainability: It's easier to find related files for a specific feature. Developers can navigate directly to the feature they are working on.</li> <li>Consistency: Following a consistent structure across all feature folders simplifies understanding the codebase.</li> </ul> <p>Updated <code>api</code> for crud</p> api.jsservices.jsBenefits of This Structure <pre><code>import axios from \"axios\";\n\nconst apiClient = axios.create({\n    baseURL: \"https://jsonplaceholder.typicode.com\",\n});\n\nconst blogsApi = {\n    fetchBlogs: (signal) =&gt; apiClient.get(\"/posts\", { cancelToken: signal }),\n    fetchBlogById: (id, signal) =&gt;\n        apiClient.get(`/posts/${id}`, { cancelToken: signal }),\n    createBlog: (blogData) =&gt; apiClient.post(\"/posts\", blogData),\n    updateBlog: (id, blogData) =&gt; apiClient.put(`/posts/${id}`, blogData),\n    deleteBlog: (id) =&gt; apiClient.delete(`/posts/${id}`),\n};\n\nexport default blogsApi;\n</code></pre> <pre><code>import { createAsyncThunk } from \"@reduxjs/toolkit\";\nimport blogsApi from \"./api\"; // Import the API functions\n\nexport const fetchBlogs = createAsyncThunk(\n    \"blog/fetchBlogs\",\n    async (signal, { rejectWithValue }) =&gt; {\n        try {\n            const response = await blogsApi.fetchBlogs(signal);\n            return response.data;\n        } catch (err) {\n            if (axios.isCancel(err)) {\n                console.log(\"Request canceled:\", err.message);\n                return rejectWithValue(\"Request was canceled\");\n            }\n            return rejectWithValue(err.message);\n        }\n    }\n);\n\n// Additional service functions for other CRUD operations\nexport const createBlog = createAsyncThunk(\n    \"blog/createBlog\",\n    async (blogData, { rejectWithValue }) =&gt; {\n        try {\n            const response = await blogsApi.createBlog(blogData);\n            return response.data;\n        } catch (err) {\n            return rejectWithValue(err.message);\n        }\n    }\n);\n\n// Add similar functions for updateBlog and deleteBlog\n</code></pre> <ul> <li>Modularity: Each function in <code>api.js</code> handles a specific API call, making it clear and easy to manage.</li> <li>Reusability: The <code>blogsApi</code> object can be reused across different service functions or even in different components if necessary.</li> <li>Clarity: It's clear which API calls are available for the <code>blog</code> feature, making it easier for other developers (or future you) to understand the code.</li> </ul>"},{"location":"interview/topic/best-approach-rtk/#decomposition","title":"Decomposition","text":"<pre><code>import { createSlice, createAsyncThunk } from \"@reduxjs/toolkit\";\nimport axios from \"axios\";\n\nexport const fetchBlogs = createAsyncThunk(\n  \"blog/fetchBlogs\",\n  async (signal, { rejectWithValue }) =&gt; {\n    try {\n      const response = await axios.get(\n        \"https://jsonplaceholder.typicode.com/posts\",\n        {\n          cancelToken: signal,\n        }\n      );\n      return response.data;\n    } catch (err) {\n      if (axios.isCancel(err)) {\n        console.log(\"Request canceled:\", err.message);\n        return rejectWithValue(\"Request was canceled\");\n      }\n      return rejectWithValue(err.message);\n    }\n  }\n);\n\nconst blogSlice = createSlice({\n  name: \"blog\",\n  initialState: {\n    blogs: [],\n    status: \"idle\",\n    error: null,\n  },\n  extraReducers: (builder) =&gt; {\n    builder\n      .addCase(fetchBlogs.pending, (state) =&gt; {\n        state.status = \"loading\";\n      })\n      .addCase(fetchBlogs.fulfilled, (state, action) =&gt; {\n        state.status = \"succeeded\";\n        state.blogs = action.payload;\n        state.error = null;\n      })\n      .addCase(fetchBlogs.rejected, (state, action) =&gt; {\n        state.status = \"failed\";\n        state.error = action.payload;\n      });\n  },\n});\n\nexport default blogSlice.reducer;\n</code></pre> <p>To decompose your Redux slice code into multiple files while keeping your project organized, you'll want to separate your concerns into three distinct files: <code>api.js</code>, <code>slice.js</code>, and <code>services.js</code>. Here\u2019s how you can structure each of them:</p> api.jsslice.jsservices.jsFinal Folder StructureSummary <p>This file is responsible for making API requests. It contains functions that handle communication with your backend or external API. You\u2019ll define your Axios calls here.</p> <pre><code>import axios from \"axios\";\n\nconst apiClient = axios.create({\n    baseURL: \"https://jsonplaceholder.typicode.com\",\n});\n\nexport const fetchBlogsApi = (signal) =&gt; {\n    return apiClient.get(\"/posts\", {\n        cancelToken: signal,\n    });\n};\n</code></pre> <p>This file contains your Redux slice. It defines the state structure, reducers, and actions related to the <code>blog</code> feature.</p> <pre><code>import { createSlice } from \"@reduxjs/toolkit\";\nimport { fetchBlogs } from \"./services\"; // Import the async thunk from services\n\nconst blogSlice = createSlice({\n    name: \"blog\",\n    initialState: {\n        blogs: [],\n        status: \"idle\",\n        error: null,\n    },\n    extraReducers: (builder) =&gt; {\n        builder\n            .addCase(fetchBlogs.pending, (state) =&gt; {\n                state.status = \"loading\";\n            })\n            .addCase(fetchBlogs.fulfilled, (state, action) =&gt; {\n                state.status = \"succeeded\";\n                state.blogs = action.payload;\n                state.error = null;\n            })\n            .addCase(fetchBlogs.rejected, (state, action) =&gt; {\n                state.status = \"failed\";\n                state.error = action.payload;\n            });\n    },\n});\n\nexport const { actions, reducer } = blogSlice;\nexport default reducer;\n</code></pre> <p>This file contains your asynchronous logic, such as <code>createAsyncThunk</code> functions. It uses the API functions defined in <code>api.js</code> to make requests.</p> <pre><code>import { createAsyncThunk } from \"@reduxjs/toolkit\";\nimport { fetchBlogsApi } from \"./api\"; // Import the API function\nimport axios from \"axios\";\n\nexport const fetchBlogs = createAsyncThunk(\n    \"blog/fetchBlogs\",\n    async (signal, { rejectWithValue }) =&gt; {\n        try {\n            const response = await fetchBlogsApi(signal);\n            return response.data;\n        } catch (err) {\n            if (axios.isCancel(err)) {\n                console.log(\"Request canceled:\", err.message);\n                return rejectWithValue(\"Request was canceled\");\n            }\n            return rejectWithValue(err.message);\n        }\n    }\n);\n</code></pre> <p>After splitting the functionality, your blogs folder structure will look like this:</p> <pre><code>src/\n\u2514\u2500\u2500 redux/\n    \u251c\u2500\u2500 features/\n    \u2502   \u251c\u2500\u2500 blogs/\n    \u2502   \u2502   \u251c\u2500\u2500 api.js         // API requests\n    \u2502   \u2502   \u251c\u2500\u2500 slice.js       // Redux slice\n    \u2502   \u2502   \u2514\u2500\u2500 services.js     // Async thunks\n    \u2514\u2500\u2500 store/\n        \u2514\u2500\u2500 index.js           // Store configuration\n</code></pre> <ul> <li><code>api.js</code>: Contains API call functions (using Axios).</li> <li><code>slice.js</code>: Contains the Redux slice definition, including initial state and reducers.</li> <li><code>services.js</code>: Contains asynchronous logic, such as thunks that use the API functions to fetch data.</li> </ul>"},{"location":"interview/topic/best-approach-rtk/#advanced","title":"Advanced","text":"Approach 1Approach 2 <p>Approach 1: Multiple Axios Instances</p> <pre><code>import axios from \"axios\";\n\nconst blogApiClient = axios.create({\n    baseURL: \"https://jsonplaceholder.typicode.com\",\n});\n\nconst userApiClient = axios.create({\n    baseURL: \"https://jsonplaceholder.typicode.com/users\", // Example for user-related API\n});\n\n// Blog API functions\nconst blogsApi = {\n    fetchBlogs: (signal) =&gt; blogApiClient.get(\"/posts\", { cancelToken: signal }),\n    fetchBlogById: (id, signal) =&gt;\n        blogApiClient.get(`/posts/${id}`, { cancelToken: signal }),\n    createBlog: (blogData) =&gt; blogApiClient.post(\"/posts\", blogData),\n    updateBlog: (id, blogData) =&gt; blogApiClient.put(`/posts/${id}`, blogData),\n    deleteBlog: (id) =&gt; blogApiClient.delete(`/posts/${id}`),\n};\n\n// User API functions\nconst usersApi = {\n    fetchUsers: () =&gt; userApiClient.get(\"/\"),\n    fetchUserById: (id) =&gt; userApiClient.get(`/${id}`),\n    createUser: (userData) =&gt; userApiClient.post(\"/\", userData),\n    updateUser: (id, userData) =&gt; userApiClient.put(`/${id}`, userData),\n    deleteUser: (id) =&gt; userApiClient.delete(`/${id}`),\n};\n\nexport { blogsApi, usersApi };\n</code></pre> <p>Approach 2: Single API Service with Dynamic Base URL</p> <pre><code>import axios from \"axios\";\n\nconst apiClient = axios.create();\n\nconst setBaseURL = (type) =&gt; {\n    switch (type) {\n        case \"blog\":\n            apiClient.defaults.baseURL = \"https://jsonplaceholder.typicode.com\";\n            break;\n        case \"user\":\n            apiClient.defaults.baseURL = \"https://jsonplaceholder.typicode.com/users\";\n            break;\n        default:\n            throw new Error(\"Unknown API type\");\n    }\n};\n\nconst api = {\n    fetchBlogs: (signal) =&gt; {\n        setBaseURL(\"blog\");\n        return apiClient.get(\"/posts\", { cancelToken: signal });\n    },\n    fetchUsers: () =&gt; {\n        setBaseURL(\"user\");\n        return apiClient.get(\"/\");\n    },\n    // Add other CRUD operations as needed\n};\n\nexport default api;\n</code></pre>"},{"location":"interview/topic/best-approach-rtk/#params","title":"Params","text":"api.jscomponent <pre><code>import axios from \"axios\";\n\nconst apiClient = axios.create({\n    baseURL: \"https://jsonplaceholder.typicode.com\",\n});\n\nconst blogsApi = {\n    fetchBlogs: (signal, params) =&gt;\n        apiClient.get(\"/posts\", { cancelToken: signal, params }), // Include params here\n    fetchBlogById: (id, signal) =&gt;\n        apiClient.get(`/posts/${id}`, { cancelToken: signal }),\n    createBlog: (blogData) =&gt; apiClient.post(\"/posts\", blogData),\n    updateBlog: (id, blogData) =&gt; apiClient.put(`/posts/${id}`, blogData),\n    deleteBlog: (id) =&gt; apiClient.delete(`/posts/${id}`),\n};\n\nexport default blogsApi;\n</code></pre> <pre><code>import React, { useEffect, useState } from \"react\";\nimport blogsApi from \"./api\"; // Adjust the import path as needed\n\nconst BlogList = () =&gt; {\n    const [blogs, setBlogs] = useState([]);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n\n    useEffect(() =&gt; {\n        const fetchBlogs = async () =&gt; {\n        const abortController = new AbortController(); // For cancellation\n        const signal = abortController.signal;\n\n        try {\n            const params = { userId: 1 }; // Example query parameter\n            const response = await blogsApi.fetchBlogs(signal, params);\n            setBlogs(response.data);\n        } catch (err) {\n            if (axios.isCancel(err)) {\n            console.log(\"Request canceled:\", err.message);\n            } else {\n            setError(err.message);\n            }\n        } finally {\n            setLoading(false);\n        }\n\n        // Cleanup function to abort the request on unmount\n        return () =&gt; abortController.abort();\n        };\n\n        fetchBlogs();\n    }, []);\n\n    if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;\n\n    return (\n        &lt;ul&gt;\n        {blogs.map((blog) =&gt; (\n            &lt;li key={blog.id}&gt;{blog.title}&lt;/li&gt;\n        ))}\n        &lt;/ul&gt;\n    );\n};\n\nexport default BlogList;\n</code></pre> <p>Example: Filtering Query Parameters in <code>api.js</code></p> api.jsservice.js <pre><code>import axios from \"axios\";\n\nconst apiClient = axios.create({\n    baseURL: \"https://jsonplaceholder.typicode.com\",\n});\n\n// Helper function to filter and validate query parameters\nconst filterParams = (params) =&gt; {\n    const filtered = {};\n    if (params) {\n        if (params.userId) {\n            filtered.userId = params.userId; // Example filter\n        }\n        // Add more filtering logic as needed\n    }\n    return filtered;\n};\n\nconst blogsApi = {\n    fetchBlogs: (signal, params) =&gt; {\n        const filteredParams = filterParams(params); // Filter params before sending\n        return apiClient.get(\"/posts\", {\n            cancelToken: signal,\n            params: filteredParams,\n        });\n    },\n    fetchBlogById: (id, signal) =&gt;\n        apiClient.get(`/posts/${id}`, { cancelToken: signal }),\n    createBlog: (blogData) =&gt; apiClient.post(\"/posts\", blogData),\n    updateBlog: (id, blogData) =&gt; apiClient.put(`/posts/${id}`, blogData),\n    deleteBlog: (id) =&gt; apiClient.delete(`/posts/${id}`),\n};\n\nexport default blogsApi;\n</code></pre> <pre><code>import React, { useEffect, useState } from \"react\";\nimport blogsApi from \"./api\"; // Adjust the import path as needed\n\nconst BlogList = () =&gt; {\n    const [blogs, setBlogs] = useState([]);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n\n    useEffect(() =&gt; {\n        const fetchBlogs = async () =&gt; {\n        const abortController = new AbortController(); // For cancellation\n        const signal = abortController.signal;\n\n        try {\n            const params = { userId: 1 }; // Example query parameter\n            const response = await blogsApi.fetchBlogs(signal, params);\n            setBlogs(response.data);\n        } catch (err) {\n            if (axios.isCancel(err)) {\n            console.log(\"Request canceled:\", err.message);\n            } else {\n            setError(err.message);\n            }\n        } finally {\n            setLoading(false);\n        }\n\n        // Cleanup function to abort the request on unmount\n        return () =&gt; abortController.abort();\n        };\n\n        fetchBlogs();\n    }, []);\n\n    if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n    if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;\n\n    return (\n        &lt;ul&gt;\n        {blogs.map((blog) =&gt; (\n            &lt;li key={blog.id}&gt;{blog.title}&lt;/li&gt;\n        ))}\n        &lt;/ul&gt;\n    );\n};\n\nexport default BlogList;\n</code></pre>"},{"location":"interview/topic/best-approach-rtk/#query-string","title":"query-string","text":"<p>The query-string package can be very useful when dealing with query parameters in URLs, especially if you need to handle complex scenarios like:</p> <ol> <li>Nested Objects: When you want to serialize nested objects as query parameters.</li> <li>Array Parameters: When you need to handle arrays and want them to be formatted in a specific way in the query string.</li> <li>URL Encoding: Automatically encoding and decoding query parameters can help avoid issues with special characters.</li> </ol> When to Use query-string <p>You might consider using the <code>query-string</code> package in the following scenarios:</p> <ol> <li> <p>Complex Query Parameters: If you need to construct complex query strings, such as nested objects or arrays.</p> <pre><code>import queryString from \"query-string\";\n\nconst params = {\n    userId: 1,\n    tags: [\"react\", \"javascript\"],\n    filters: {\n        sortBy: \"date\",\n        order: \"desc\",\n    },\n};\n\nconst query = queryString.stringify(params);\n// Result: \"userId=1&amp;tags[]=react&amp;tags[]=javascript&amp;filters[sortBy]=date&amp;filters[order]=desc\"\n</code></pre> </li> <li> <p>Parsing Query Strings: If you need to parse incoming query strings from URLs into a usable object format.</p> <pre><code>const parsed = queryString.parse(location.search);\n// Example: location.search is \"?userId=1&amp;tags[]=react\"\n// Result: { userId: '1', tags: ['react'] }\n</code></pre> </li> <li> <p>Avoiding Manual Serialization: If you find yourself frequently needing to manually construct query strings, using <code>query-string</code> can simplify your code.</p> </li> </ol> Example Usage with AxiosSummary <p>Here\u2019s how you might incorporate <code>query-string</code> into your existing <code>blogsApi</code>:</p> <ol> <li> <p>Install the Package</p> <pre><code>npm install query-string\n</code></pre> </li> <li> <p>Update Your API Calls</p> <p>Update the <code>fetchBlogs</code> method to use <code>query-string</code> for parameter serialization:</p> <pre><code>import axios from \"axios\";\nimport queryString from \"query-string\";\n\nconst apiClient = axios.create({\n    baseURL: \"https://jsonplaceholder.typicode.com\",\n});\n\nconst blogsApi = {\n    fetchBlogs: (signal, params) =&gt; {\n        const filteredParams = filterParams(params); // Assume you still filter params here\n        const query = queryString.stringify(filteredParams); // Serialize query params\n        return apiClient.get(`/posts?${query}`, { cancelToken: signal });\n    },\n    fetchBlogById: (id, signal) =&gt;\n        apiClient.get(`/posts/${id}`, { cancelToken: signal }),\n    createBlog: (blogData) =&gt; apiClient.post(\"/posts\", blogData),\n    updateBlog: (id, blogData) =&gt; apiClient.put(`/posts/${id}`, blogData),\n    deleteBlog: (id) =&gt; apiClient.delete(`/posts/${id}`),\n};\n\nexport default blogsApi;\n</code></pre> </li> </ol> <ul> <li>Use <code>query-string</code> when dealing with complex query parameters, such as nested objects or arrays.</li> <li>It simplifies the process of constructing and parsing query strings, especially in more advanced scenarios.</li> <li>If your API calls are simple (e.g., just basic key-value pairs), you might not need it, but it can still be a good addition for clarity and maintainability.</li> </ul>"},{"location":"interview/topic/best-approach-rtk/#packages","title":"Packages","text":"<p>In a large React codebase using RTK and Axios, consider incorporating the following packages:</p> <ol> <li>React Query: For data fetching and caching.</li> <li>Yup and Formik: For form handling and validation.</li> <li>Lodash: For utility functions.</li> <li>Immer: For immutable state updates.</li> <li>date-fns or moment: For date handling.</li> <li>React Router: For routing.</li> <li>react-toastify: For notifications.</li> <li>redux-logger: For Redux action logging.</li> <li>dotenv: For managing environment variables.</li> <li>classnames: For managing CSS class names.</li> <li>styled-components or emotion: For styling components.</li> </ol>"},{"location":"interview/topic/csr-sgr-ssr/","title":"CSR SGR SSR","text":""},{"location":"interview/topic/csr-sgr-ssr/#overview","title":"Overview","text":"<p>SSR (Server-Side Rendering) and SSG (Static Site Generation) are two methods of rendering web pages in a Next.js application. Here\u2019s a breakdown of each:</p>"},{"location":"interview/topic/csr-sgr-ssr/#server-side-rendering-ssr","title":"Server-Side Rendering (SSR)","text":"<ul> <li> <p>Definition: SSR means that the HTML of a page is generated on the server for each request. When a user requests a page, the server processes the request, fetches any necessary data, and renders the page before sending it to the client.</p> </li> <li> <p>When to Use:</p> </li> <li> <p>When you need to show dynamic content that changes frequently (e.g., user-specific data, real-time updates).</p> </li> <li> <p>When SEO is important and you want search engines to see the fully rendered HTML.</p> </li> <li> <p>Example: A blog that displays the latest articles. Each time a user visits the page, the server fetches the latest articles from the database and renders them.</p> </li> </ul>"},{"location":"interview/topic/csr-sgr-ssr/#static-site-generation-ssg","title":"Static Site Generation (SSG)","text":"<ul> <li> <p>Definition: SSG generates HTML pages at build time. This means that when you build your application, Next.js creates static HTML files for each page, which are served to users without needing to fetch data on each request.</p> </li> <li> <p>When to Use:</p> </li> <li> <p>When your content doesn\u2019t change often or can be pre-generated (e.g., documentation sites, blogs with static content).</p> </li> <li> <p>For improved performance, as static files can be served quickly from a CDN.</p> </li> <li> <p>Example: A portfolio site where the content (projects, descriptions) rarely changes. The HTML for each page is generated once during the build process.</p> </li> </ul> Summary <ul> <li>SSR is great for dynamic, user-specific content that needs to be rendered fresh on each request.</li> <li>SSG is ideal for static content that can be pre-rendered and served quickly.</li> </ul> <p><code>Next.js</code> allows you to mix both approaches in a single application, choosing the best method for each page based on its needs.</p>"},{"location":"interview/topic/csr-sgr-ssr/#explanation-for-a-5-year-old","title":"explanation for a 5-year-old","text":"<p>Sure! Here\u2019s an explanation for a 5-year-old:</p>"},{"location":"interview/topic/csr-sgr-ssr/#what-is-ssr-server-side-rendering","title":"What is SSR (Server-Side Rendering)?","text":"<p>Imagine you want a cookie.</p> <ul> <li>You tell your mom, \u201cI want a cookie!\u201d</li> <li>She goes to the kitchen, bakes the cookie for you, and then brings it to you.</li> <li>This happens every time you ask for a cookie.</li> </ul> <p>When to Use SSR:</p> <ul> <li>When you want something that changes all the time, like a fresh cookie. If you want the latest news or your favorite cartoons, it\u2019s best to ask your mom to make it for you each time!</li> </ul> <p>Where It Is Available:</p> <ul> <li>This is done on special computers called servers that can bake the cookie (create the page) every time you ask.</li> </ul>"},{"location":"interview/topic/csr-sgr-ssr/#what-is-ssg-static-site-generation","title":"What is SSG (Static Site Generation)?","text":"<p>Now, think about a cookie jar.</p> <ul> <li>Your mom bakes a bunch of cookies and puts them in a jar.</li> <li>Whenever you want a cookie, you just go to the jar and grab one.</li> <li>It\u2019s super fast because you don\u2019t have to wait for her to bake it every time!</li> </ul> <p>When to Use SSG:</p> <ul> <li>When you want something that doesn\u2019t change much, like your favorite toys or a story that\u2019s always the same. It\u2019s quicker to just grab a cookie from the jar!</li> </ul> <p>Where It Is Available:</p> <ul> <li>The cookies (pages) are stored on the internet, so they\u2019re ready for you anytime you want them!</li> </ul> Summary <ul> <li>SSR is like asking mom for a cookie each time (good for things that change).</li> <li>SSG is like having a cookie jar full of cookies (good for things that stay the same).</li> </ul> <p>Both can be found on the internet, helping people get what they need!</p>"},{"location":"interview/topic/csr-sgr-ssr/#can-we-use-react-only-for-ssg-or-ssr","title":"can we use react only for <code>ssg</code> or <code>ssr</code>","text":"<p>React itself doesn\u2019t directly handle server-side rendering (SSR) or static site generation (SSG); it\u2019s primarily a library for building user interfaces. However, you can implement SSR and SSG with React using frameworks like Next.js, which adds these capabilities on top of React.</p>"},{"location":"interview/topic/csr-sgr-ssr/#using-react-for-ssg-and-ssr","title":"Using React for SSG and SSR","text":"<p>Static Site Generation (SSG):</p> <ul> <li>With frameworks like Next.js, you can use React to build static pages that are pre-rendered at build time. This means the HTML is generated ahead of time, so it loads quickly for users.</li> </ul> <p>Server-Side Rendering (SSR):</p> <ul> <li>Again, with Next.js or similar frameworks, you can use React to create pages that are rendered on the server for each request. This is useful for dynamic content that changes frequently.</li> </ul> Summary <p>While React is the core library you use to build your components, frameworks like Next.js are necessary to implement SSG and SSR effectively. If you\u2019re using just React without a framework, you won't have built-in support for these rendering methods.</p>"},{"location":"interview/topic/csr-sgr-ssr/#reference","title":"Reference","text":"<ul> <li>What is React SSG?</li> <li>React Based Static Site Generators in 2024</li> </ul>"},{"location":"interview/topic/holy-grail/","title":"Holy Grail","text":""},{"location":"interview/topic/holy-grail/#generating-the-worker-script","title":"Generating the worker script","text":"<p>To generate the worker script, run the following command in your project\u2019s root directory:</p> <pre><code>npx msw init &lt;PUBLIC_DIR&gt; --save\n\nnpx msw init ./public --save\n</code></pre> <ul> <li>Version 1</li> <li>Version 2</li> </ul>"},{"location":"interview/topic/holy-grail/#example","title":"Example","text":"<p>To explore the methods available in the MSW package and find their names or functionalities, you can refer to the following:</p>"},{"location":"interview/topic/holy-grail/#1-logging-the-module","title":"1. Logging the Module","text":"<p>As mentioned, you can log the entire MSW module:</p> <pre><code>import * as msw from \"msw\";\n\nconsole.log(msw);\n</code></pre>"},{"location":"interview/topic/holy-grail/#2-documentation","title":"2. Documentation","text":"<p>The best way to understand the available methods is to consult the official MSW documentation. The documentation provides detailed information about all the methods, their usage, and examples.</p>"},{"location":"interview/topic/holy-grail/#3-typescript-definitions","title":"3. TypeScript Definitions","text":"<p>If you are using TypeScript, you can look at the type definitions for MSW. This can give you insights into the available methods and their signatures. You can check the <code>@mswjs/data</code> or <code>msw</code> packages directly in your <code>node_modules</code> or use an IDE that supports TypeScript IntelliSense.</p>"},{"location":"interview/topic/holy-grail/#4-common-methods-and-properties","title":"4. Common Methods and Properties","text":"<p>Here are some of the main methods and properties provided by MSW:</p> <ul> <li><code>rest</code>: For defining REST API request handlers.</li> <li><code>graphql</code>: For defining GraphQL API request handlers.</li> <li><code>setupWorker</code>: Initializes the worker for browser environments.</li> <li><code>setupServer</code>: Initializes a server for Node.js environments.</li> <li><code>start()</code>: Starts the service worker or server.</li> <li><code>stop()</code>: Stops the service worker or server.</li> <li><code>listen()</code>: Starts intercepting requests (Node.js).</li> <li><code>close()</code>: Stops intercepting requests (Node.js).</li> <li><code>ctx</code>: A context object that contains utility functions to build responses (e.g., <code>ctx.json()</code>, <code>ctx.status()</code>, etc.).</li> </ul>"},{"location":"interview/topic/holy-grail/#5-using-objectkeys","title":"5. Using <code>Object.keys()</code>","text":"<p>If you want to list all the method names programmatically, you can use <code>Object.keys()</code>:</p> <pre><code>import * as msw from \"msw\";\n\nconsole.log(Object.keys(msw));\n</code></pre> <p>This will give you an array of the top-level properties, which typically include methods and objects within MSW.</p>"},{"location":"interview/topic/holy-grail/#6-exploring-in-a-repl","title":"6. Exploring in a REPL","text":"<p>If you have a JavaScript or TypeScript environment set up, you can also use a REPL (like Node.js or browser console) to require/import MSW and explore its properties interactively.</p> Example of Commands in REPL<pre><code>$ node\n&gt; const msw = require('msw');\n&gt; console.log(msw); // Logs the entire module\n&gt; console.log(Object.keys(msw)); // Lists all top-level keys\n&gt; console.log(msw.rest); // Logs the REST methods\n&gt; console.log(msw.setupWorker); // Logs the setupWorker function\n</code></pre> <p>Using these methods, you should be able to get a comprehensive view of what MSW offers!</p>"},{"location":"interview/topic/holy-grail/#list-properties-and-methods","title":"List Properties and Methods:","text":"<pre><code>// Log the entire MSW object\nconsole.log(msw); // View all properties and methods\n\n// List all top-level keys\nconsole.log(Object.keys(msw));\n\n// If you want to check specific sections:\nconsole.log(Object.keys(msw.rest)); // REST methods\nconsole.log(Object.keys(msw.graphql)); // GraphQL methods\n</code></pre>"},{"location":"interview/topic/performance-optimization/","title":"Performance Optimization","text":"<p>Performance optimization is crucial in various domains, including software development, system design, and data processing. Techniques can vary depending on the context, but here are some general strategies for optimizing performance:</p>"},{"location":"interview/topic/performance-optimization/#1-code-optimization","title":"1. Code Optimization:","text":"<ul> <li>Profiling: Use profiling tools to identify bottlenecks in your code.</li> <li>Efficient Algorithms: Choose algorithms with lower time and space complexity.</li> <li>Code Refactoring: Clean up and optimize code to reduce unnecessary operations.</li> <li>Inlining: Inline small functions to reduce overhead.</li> </ul>"},{"location":"interview/topic/performance-optimization/#2-data-structure-optimization","title":"2. Data Structure Optimization:","text":"<ul> <li>Choose the Right Data Structures: Use appropriate data structures (e.g., hash tables, trees) based on access patterns.</li> <li>Memory Layout: Optimize memory layout to enhance cache locality.</li> </ul>"},{"location":"interview/topic/performance-optimization/#3-database-optimization","title":"3. Database Optimization:","text":"<ul> <li>Indexing: Create indexes on frequently queried columns.</li> <li>Query Optimization: Write efficient SQL queries and avoid complex joins or subqueries.</li> <li>Caching: Implement caching mechanisms to reduce database load.</li> </ul>"},{"location":"interview/topic/performance-optimization/#4-system-level-optimization","title":"4. System-Level Optimization:","text":"<ul> <li>Concurrency: Use multi-threading or asynchronous processing to make better use of system resources.</li> <li>Resource Management: Optimize the use of CPU, memory, and I/O resources.</li> <li>Load Balancing: Distribute workloads evenly across servers or resources.</li> </ul>"},{"location":"interview/topic/performance-optimization/#5-network-optimization","title":"5. Network Optimization:","text":"<ul> <li>Reduce Latency: Minimize the time it takes for data to travel between systems.</li> <li>Compression: Compress data to reduce bandwidth usage.</li> <li>Caching: Cache frequently accessed data to reduce network load.</li> </ul>"},{"location":"interview/topic/performance-optimization/#6-compilation-and-build-optimization","title":"6. Compilation and Build Optimization:","text":"<ul> <li>Optimization Flags: Use compiler optimization flags to improve execution speed.</li> <li>Minification: Minify code (especially JavaScript and CSS) to reduce file size.</li> </ul>"},{"location":"interview/topic/performance-optimization/#7-memory-optimization","title":"7. Memory Optimization:","text":"<ul> <li>Garbage Collection: Optimize garbage collection strategies to manage memory more efficiently.</li> <li>Memory Pools: Use memory pools to reduce allocation and deallocation overhead.</li> </ul>"},{"location":"interview/topic/performance-optimization/#8-load-testing-and-benchmarking","title":"8. Load Testing and Benchmarking:","text":"<ul> <li>Stress Testing: Test how your system behaves under extreme conditions.</li> <li>Benchmarking: Measure performance and identify areas for improvement.</li> </ul>"},{"location":"interview/topic/performance-optimization/#9-code-review-and-best-practices","title":"9. Code Review and Best Practices:","text":"<ul> <li>Peer Reviews: Have others review your code for potential optimizations.</li> <li>Best Practices: Follow industry best practices and design patterns that promote performance.</li> </ul>"},{"location":"interview/topic/performance-optimization/#10-hardware-optimization","title":"10. Hardware Optimization:","text":"<ul> <li>Upgrade Hardware: Sometimes upgrading hardware can provide a significant performance boost.</li> <li>Tune Hardware Settings: Configure hardware settings (like CPU frequency, disk caching) for optimal performance.</li> </ul> <p>Each context will have its specific techniques and tools, so it\u2019s important to tailor these strategies to the specific requirements and constraints of your project or system.</p>"},{"location":"interview/topic/postgress/","title":"Postgress","text":""},{"location":"interview/topic/postgress/#solution","title":"Solution","text":"Danger <pre><code>pip install psycopg2\n\nCollecting psycopg2\nDownloading psycopg2-2.9.9.tar.gz (384 kB)\nPreparing metadata (setup.py) ... error\nerror: subprocess-exited-with-error\n\n\u00d7 python setup.py egg_info did not run successfully.\n\u2502 exit code: 1\n\u2570\u2500&gt; [23 lines of output]\n    running egg_info\n</code></pre> <p>It looks like you're having trouble installing <code>psycopg2</code>. This can happen for several reasons. Here are some steps to help you troubleshoot and resolve the issue:</p> <ol> <li> <p>Install Dependencies: <code>psycopg2</code> requires some development packages. Make sure you have the necessary dependencies installed. On Debian-based systems (like Ubuntu), you can run:</p> <pre><code>sudo apt-get install libpq-dev python3-dev\n</code></pre> <p>On Red Hat-based systems (like CentOS), you might need:</p> <pre><code>sudo yum install postgresql-devel python3-devel\n</code></pre> </li> <li> <p>Use the Binary Package: Instead of installing from source, you can try installing the binary version, which doesn't require compilation:</p> <pre><code>pip install psycopg2-binary\n</code></pre> </li> <li> <p>Upgrade <code>pip</code> and <code>setuptools</code>: Sometimes older versions of <code>pip</code> or <code>setuptools</code> can cause installation issues. Upgrade them using:</p> <pre><code>pip install --upgrade pip setuptools\n</code></pre> </li> <li> <p>Check Python Version: Ensure you're using a supported version of Python for the version of <code>psycopg2</code> you're trying to install. Compatibility issues can arise with certain Python versions</p> </li> </ol>"},{"location":"interview/topic/postgress/#solution-2","title":"Solution 2","text":"Danger <pre><code>python3 manage.py migrate\nOperations to perform:\nApply all migrations: admin, auth, contenttypes, sessions\nRunning migrations:\nTraceback (most recent call last):\nFile \"/home/ninja/.local/share/virtualenvs/api-auth-VbVYN-9u/lib/python3.8/site-packages/django/db/backends/utils.py\", line 87, in _execute\n    return self.cursor.execute(sql)\npsycopg2.errors.InsufficientPrivilege: permission denied for schema public\nLINE 1: CREATE TABLE \"django_migrations\" (\"id\" bigint NOT NULL PRIMA.\n</code></pre> <p>The error you're encountering indicates that the user configured to access your PostgreSQL database does not have sufficient privileges to create tables in the <code>public</code> schema. Here's how you can address this issue:</p> <ol> <li> <p>Check Database User Permissions: Ensure the user specified in your Django settings has the necessary permissions. You can do this by logging into PostgreSQL and checking the user's privileges.</p> <pre><code>\\c your_database_name;  -- Connect to your database\n\\dn+ public;            -- Check the public schema permissions\n</code></pre> </li> <li> <p>Grant Permissions: If the user lacks the required permissions, you can grant them by executing the following SQL commands in your PostgreSQL command line or through a database management tool like pgAdmin:</p> <pre><code>GRANT ALL PRIVILEGES ON SCHEMA public TO your_username;\nGRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO your_username;\n</code></pre> </li> <li> <p>Update <code>settings.py</code>: Ensure your Django <code>settings.py</code> file has the correct user and database settings. It should look something like this:</p> <pre><code>DATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.postgresql',\n        'NAME': 'your_database_name',\n        'USER': 'your_username',\n        'PASSWORD': 'your_password',\n        'HOST': 'localhost',  # or your database host\n        'PORT': '5432',       # default PostgreSQL port\n    }\n}\n</code></pre> </li> <li> <p>Retry Migrations: After adjusting permissions, try running the migrations again:</p> <pre><code>python3 manage.py migrate\n</code></pre> </li> </ol> <p>If you still encounter issues, double-check that you\u2019re connected to the correct database with the correct user, and ensure that the user has not been restricted in other ways (such as connection limits).</p>"},{"location":"interview/topic/postgress/#postgress-commands","title":"Postgress Commands","text":""},{"location":"interview/topic/postgress/#what-is-psql","title":"What is psql?","text":"<p><code>psql</code> is the interactive terminal for working with PostgreSQL databases. It allows you to execute SQL commands, manage your databases, and perform administrative tasks. You can run queries, create and modify databases and users, and more.</p> Success <pre><code>CREATE USER ninja_user WITH PASSWORD 'ninja12345';\n\nALTER ROLE ninja_user SET client_encoding TO 'utf8';\n\nALTER ROLE ninja_user SET default_transaction_isolation TO 'read committed';\n\nALTER ROLE ninja_user SET timezone TO 'UTC';\n\nGRANT ALL PRIVILEGES ON DATABASE apiauthdatabase TO ninja_user;\n</code></pre>"},{"location":"interview/topic/postgress/#method-1using-the-postgresql-shell","title":"Method 1:Using the PostgreSQL Shell","text":"<ol> <li> <p>Open the PostgreSQL Shell: Open your terminal and run:</p> <pre><code>psql -U postgres\n</code></pre> <p>Replace <code>postgres</code> with your username if it's different.</p> </li> <li> <p>List Users: Once in the PostgreSQL shell, execute the following command:</p> <pre><code>\\du\n</code></pre> <p>This command will display a list of all roles (users) along with their attributes.</p> </li> <li> <p>Exit the PostgreSQL Shell: Type <code>\\q</code> to exit.</p> </li> </ol>"},{"location":"interview/topic/postgress/#method-2-using-sql-query","title":"Method 2: Using SQL Query","text":"<p>You can also retrieve a list of users by executing an SQL query:</p> <pre><code>SELECT usename FROM pg_catalog.pg_user;\n</code></pre> <p>This query will return the names of all users in the PostgreSQL instance.</p>"},{"location":"interview/topic/postgress/#method-3-using-command-line","title":"Method 3: Using Command Line","text":"<p>If you prefer to list users directly from the command line, you can run:</p> <pre><code>psql -U postgres -c \"\\du\"\n</code></pre> <p>This command will connect to PostgreSQL as the <code>postgres</code> user and execute the <code>\\du</code> command.</p>"},{"location":"interview/topic/postgress/#commands","title":"Commands","text":"Basic CommandsDatabase <pre><code>-- Open psql shell\npsql -U postgres\nsudo -u postgres psql\n\n-- Create a new database\nCREATE DATABASE mydatabase;\n\n-- List all databases\n\\l\n\n-- Enable Extended Display\n\\x\n\n-- Permissions Check\n\\du\n\n\n-- Exit psql shell\n\\q\n</code></pre> <pre><code>-- Connect to psql\npsql -U postgres\nsudo -u postgres psql\n\n-- Create a new database\nCREATE DATABASE mydatabase;\n\n-- List databases to verify creation\n\\l\n\n-- Delete the database\nDROP DATABASE mydatabase;\n\n-- List databases to verify deletion\n\\l\n\n-- Exit psql\n\\q\n</code></pre> Important Notes <ul> <li>Permissions: Make sure you have the necessary privileges to create and delete databases.</li> <li>Active Connections: You cannot drop a database that has active connections. You may need to disconnect from it first.</li> </ul>"},{"location":"interview/topic/postgress/#reference","title":"Reference","text":"<ul> <li>How To Use PostgreSQL with your Django Application on Ubuntu 22.04</li> </ul>"},{"location":"interview/topic/private-vs-protected/","title":"Privated vs Protected","text":""},{"location":"interview/topic/private-vs-protected/#overview","title":"Overview","text":"<p>In React Router, \"ProtectedRoute\" and \"PrivateRoute\" are not built-in components but commonly used names for similar concepts. Both terms generally refer to a route that restricts access based on some authentication condition.</p>"},{"location":"interview/topic/private-vs-protected/#heres-a-quick-breakdown","title":"Here's a quick breakdown:","text":"<ul> <li> <p>PrivateRoute: This term is often used to describe a route that is only accessible to authenticated users. If a user is not authenticated, they are typically redirected to a login page.</p> </li> <li> <p>ProtectedRoute: This term is also used similarly and often implies that certain conditions (like user roles or permissions) must be met for access, not just authentication.</p> </li> </ul> <p>In practice, you might find libraries or examples using either term, but they usually serve the same purpose. You can implement them with custom logic to check user authentication and redirect as needed.</p>"},{"location":"interview/topic/private-vs-protected/#in-depth","title":"IN DEPTH","text":"<p>In React, particularly when using React Router, \"ProtectedRoute\" and \"PrivateRoute\" are commonly used terms to describe components that restrict access to certain routes based on user authentication status. While they serve a similar purpose, the terminology can vary depending on the implementation or library used.</p>"},{"location":"interview/topic/private-vs-protected/#privateroute","title":"PrivateRoute","text":"<ul> <li>Purpose: Typically restricts access to a route unless the user is authenticated.</li> <li>Usage: If a user tries to access a route and they are not logged in, they are redirected to a login page or another specified route.</li> <li>Implementation: Often involves checking a user authentication state (like a token or user object in context or Redux).</li> </ul> PrivateRoute.js<pre><code>const PrivateRoute = ({ component: Component, ...rest }) =&gt; {\n  const isAuthenticated = // logic to check if user is authenticated\n  return (\n    &lt;Route\n      {...rest}\n      render={props =&gt;\n        isAuthenticated ? (\n          &lt;Component {...props} /&gt;\n        ) : (\n          &lt;Redirect to=\"/login\" /&gt;\n        )\n      }\n    /&gt;\n  );\n};\n</code></pre>"},{"location":"interview/topic/private-vs-protected/#protectedroute","title":"ProtectedRoute","text":"<ul> <li>Purpose: Similar to PrivateRoute, it generally protects routes from being accessed by unauthorized users. The terminology might imply a broader use case, like protecting routes that are only accessible to certain user roles or permissions.</li> <li>Usage: Can also include additional checks, such as user roles or specific conditions beyond just being logged in.</li> <li>Implementation: May involve more complex logic depending on application needs.</li> </ul> ProtectedRoute.js<pre><code>const ProtectedRoute = ({ component: Component, requiredRole, ...rest }) =&gt; {\n  const { isAuthenticated, userRole } = // logic to get auth and role\n  return (\n    &lt;Route\n      {...rest}\n      render={props =&gt;\n        isAuthenticated &amp;&amp; userRole === requiredRole ? (\n          &lt;Component {...props} /&gt;\n        ) : (\n          &lt;Redirect to=\"/unauthorized\" /&gt;\n        )\n      }\n    /&gt;\n  );\n};\n</code></pre> Summary <ul> <li><code>PrivateRoute.js</code> for the authentication check.</li> <li><code>ProtectedRoute.js</code> for role-based or permission checks.</li> </ul>"},{"location":"interview/topic/private-vs-protected/#major-differences","title":"Major Differences","text":"<ol> <li> <p>Scope of Protection:</p> <ul> <li>PrivateRoute: Typically focuses solely on authentication (whether the user is logged in).</li> <li>ProtectedRoute: May include role-based access control or other conditions beyond just authentication.</li> </ul> </li> <li> <p>Terminology and Usage:</p> <ul> <li>The naming and specific implementation can vary by project or team conventions. \"ProtectedRoute\" might be used in some projects to indicate more complex restrictions.</li> </ul> </li> </ol> <p>In essence, while both concepts are about controlling access to routes based on authentication, \"ProtectedRoute\" often implies additional layers of security or role checks compared to a more straightforward \"PrivateRoute.\"</p>"},{"location":"interview/topic/private-vs-protected/#full-example-using-both","title":"Full Example Using Both","text":"<p>Create the Route Components</p> PrivateRoute.jsProtectedRoute.js <pre><code>// PrivateRoute.js\nimport React from 'react';\nimport { Route, Navigate } from 'react-router-dom';\n\nconst PrivateRoute = ({ component: Component, isAuthenticated, ...rest }) =&gt; (\n    &lt;Route\n        {...rest}\n        element={isAuthenticated ? &lt;Component /&gt; : &lt;Navigate to=\"/login\" /&gt;}\n    /&gt;\n);\n\nexport default PrivateRoute;\n</code></pre> <pre><code>// ProtectedRoute.js\nimport React from 'react';\nimport { Route, Navigate } from 'react-router-dom';\n\nconst ProtectedRoute = ({ component: Component, isAuthenticated, userRole, requiredRole, ...rest }) =&gt; (\n    &lt;Route\n        {...rest}\n        element={\n            isAuthenticated &amp;&amp; userRole === requiredRole ? (\n                &lt;Component /&gt;\n            ) : (\n                &lt;Navigate to=\"/unauthorized\" /&gt;\n            )\n        }\n    /&gt;\n);\n\nexport default ProtectedRoute;\n</code></pre> <p>Set Up Your Main Application</p> <pre><code>// App.js\nimport React, { useState } from \"react\";\nimport { BrowserRouter as Router, Routes, Route } from \"react-router-dom\";\nimport PrivateRoute from \"./PrivateRoute\";\nimport ProtectedRoute from \"./ProtectedRoute\";\nimport Home from \"./Home\";\nimport Login from \"./Login\";\nimport Admin from \"./Admin\";\nimport Unauthorized from \"./Unauthorized\";\n\nconst App = () =&gt; {\n  const [isAuthenticated, setIsAuthenticated] = useState(false);\n  const [userRole, setUserRole] = useState(null); // e.g., 'admin', 'user'\n\n  return (\n    &lt;Router&gt;\n      &lt;Routes&gt;\n        &lt;Route path=\"/login\" element={&lt;Login /&gt;} /&gt;\n        &lt;PrivateRoute\n          path=\"/home\"\n          element={Home}\n          isAuthenticated={isAuthenticated}\n        /&gt;\n        &lt;ProtectedRoute\n          path=\"/admin\"\n          element={Admin}\n          isAuthenticated={isAuthenticated}\n          userRole={userRole}\n          requiredRole=\"admin\"\n        /&gt;\n        &lt;Route path=\"/unauthorized\" element={&lt;Unauthorized /&gt;} /&gt;\n      &lt;/Routes&gt;\n    &lt;/Router&gt;\n  );\n};\n\nexport default App;\n</code></pre> <p>Example Components</p> Home.jsLogin.jsAdmin.jsUnauthorized.js <pre><code>// Home.js\nimport React from 'react';\n\nconst Home = () =&gt; &lt;h1&gt;Welcome to the Home Page!&lt;/h1&gt;;\n\nexport default Home;\n</code></pre> <pre><code>// Login.js\nimport React from 'react';\n\nconst Login = () =&gt; {\nreturn &lt;h1&gt;Please log in&lt;/h1&gt;;\n};\n\nexport default Login;\n</code></pre> <pre><code>// Admin.js\nimport React from 'react';\n\nconst Admin = () =&gt; &lt;h1&gt;Welcome to the Admin Page!&lt;/h1&gt;;\n\nexport default Admin;\n</code></pre> <pre><code>// Unauthorized.js\nimport React from 'react';\n\nconst Unauthorized = () =&gt; &lt;h1&gt;You do not have permission to view this page.&lt;/h1&gt;;\n\nexport default Unauthorized;\n</code></pre> <p>Conclusion</p> <p>With this setup:</p> <ul> <li>Users can navigate to the <code>/home</code> route if they are authenticated.</li> <li>The <code>/admin</code> route is protected and requires the user to be authenticated and have the role of \"admin.\"</li> <li>If access is denied, users are redirected to the <code>/unauthorized</code> page.</li> </ul> <p>You can enhance the logic for authentication and role management based on your specific needs!</p>"},{"location":"interview/topic/private-vs-protected/#alternative-methods","title":"Alternative Methods","text":"<p>These methods offer different approaches to structuring your routes, each with its own benefits. You can choose the one that best fits your application\u2019s needs and complexity:</p> <ul> <li>Separate Route Component: Keeps the main routing file clean.</li> <li>Dynamic Route Rendering: Makes it easy to add/remove routes from a configuration.</li> <li>Nested Routes: Organizes routes hierarchically, improving readability.</li> <li>Higher-Order Component: Streamlines route protection logic.</li> </ul>"},{"location":"interview/topic/private-vs-protected/#best-methods","title":"Best Methods","text":"<p>The Route Composition method is the best choice for managing private and protected routes in your application, especially given your needs for role-based and authentication-based access control. Here\u2019s why it stands out:</p> BenefitsExample Use Case <p>Benefits of Route Composition for Private and Protected Routes</p> <ol> <li> <p>Modularity and Reusability:</p> <ul> <li>By encapsulating access logic in separate <code>PrivateRoute</code> and <code>ProtectedRoute</code> components, you create reusable, isolated pieces of code. This modularity allows each route type to have its own logic, which you can consistently apply across your app.</li> </ul> </li> <li> <p>Separation of Concerns:</p> <ul> <li>Each route component (<code>PrivateRoute</code>, <code>ProtectedRoute</code>) handles specific concerns: <code>PrivateRoute</code> focuses on authentication, while <code>ProtectedRoute</code> can add role-based or conditional access. This separation makes it easy to understand and modify each route\u2019s behavior independently without affecting other routes.</li> </ul> </li> <li> <p>Flexibility with Access Rules:</p> <ul> <li>Route Composition is highly adaptable. For example, you can easily add role-based access control by extending <code>ProtectedRoute</code> without altering other routes. This approach supports more complex access logic (e.g., requiring certain permissions) while keeping your routing logic clean.</li> </ul> </li> <li> <p>Easier Maintenance and Scalability:</p> <ul> <li>As your app grows and you add more protected routes, maintaining a single access check within <code>ProtectedRoute</code> and <code>PrivateRoute</code> becomes far simpler than updating access checks across scattered route definitions or HOCs. If authentication logic changes, you only need to update these components rather than every individual route.</li> </ul> </li> <li> <p>Enhanced Readability:</p> <ul> <li>By using <code>PrivateRoute</code> and <code>ProtectedRoute</code>, you can easily see which routes are protected and the type of access required without digging into nested logic. This readability makes onboarding new developers or reviewing route logic straightforward.</li> </ul> </li> </ol> <p>Example Use Case for Route Composition</p> <p>Suppose your application requires:</p> <ul> <li>Basic authentication for access to certain areas (e.g., a user dashboard).</li> <li>Role-based access to restricted routes (e.g., a \u201cFinancial\u201d route only accessible to premium users).</li> </ul> <p>The Route Composition approach lets you define <code>PrivateRoute</code> for general authenticated access and <code>ProtectedRoute</code> for role-based access. This setup will be flexible and scalable for other future roles or access requirements without significant restructuring.</p> Example Code Implementation for Route Composition<pre><code>// PrivateRoute.js - For routes that only need authentication\nimport React from 'react';\nimport { Navigate } from 'react-router-dom';\n\nconst PrivateRoute = ({ element, isAuthenticated }) =&gt; {\n  return isAuthenticated ? element : &lt;Navigate to=\"/\" /&gt;;\n};\n\nexport default PrivateRoute;\n\n// ProtectedRoute.js - For routes that need both authentication and role-checks\nconst ProtectedRoute = ({ element, isAuthenticated, requiredRole, userRole }) =&gt; {\n  if (!isAuthenticated) {\n    return &lt;Navigate to=\"/\" /&gt;;\n  } else if (userRole !== requiredRole) {\n    return &lt;Navigate to=\"/not-authorized\" /&gt;;\n  }\n  return element;\n};\n\nexport default ProtectedRoute;\n\n// AppRoutes.js - Main route configuration with route composition\nimport PrivateRoute from './PrivateRoute';\nimport ProtectedRoute from './ProtectedRoute';\n\nfunction AppRoutes() {\n  const isAuthenticated = // your authentication logic\n  const userRole = // your role logic (e.g., \"standard\" or \"premium\")\n\n  return (\n    &lt;Router&gt;\n      &lt;Routes&gt;\n        &lt;Route path=\"/\" element={&lt;Login /&gt;} /&gt;\n        &lt;Route path=\"/dashboard\" element={&lt;PrivateRoute isAuthenticated={isAuthenticated} element={&lt;Dashboard /&gt;} /&gt;} /&gt;\n        &lt;Route path=\"/financial\" element={&lt;ProtectedRoute isAuthenticated={isAuthenticated} userRole={userRole} requiredRole=\"premium\" element={&lt;Financial /&gt;} /&gt;} /&gt;\n      &lt;/Routes&gt;\n    &lt;/Router&gt;\n  );\n}\n</code></pre> <p>Why Route Composition is the Best Choice</p> <p>This method balances flexibility, scalability, and simplicity, making it ideal for any application with evolving access requirements. With Route Composition, you get clear, maintainable code that keeps both security and readability in mind\u2014key factors for developing robust, scalable applications.</p>"},{"location":"interview/topic/react-image-gallery/","title":"React Image Gallery","text":""},{"location":"interview/topic/react-image-gallery/#overview","title":"Overview","text":"<p>Yes, there are several popular packages for handling images in React, each with different features and capabilities. Here are a few you might find useful:</p>"},{"location":"interview/topic/react-image-gallery/#1-react-image","title":"1. React Image:","text":"<ul> <li>Package: react-image</li> <li>Features: This package provides a simple way to load images with a fallback for loading and error states.</li> <li>Installation:</li> </ul> <pre><code>npm install react-image\n</code></pre> <ul> <li>Usage:</li> </ul> <pre><code>import { Img } from \"react-image\";\n\n&lt;Img\n  src={item.url}\n  style={{ height: \"200px\", width: \"200px\" }}\n  alt=\"Gallery\"\n  loader={&lt;span&gt;Loading...&lt;/span&gt;}\n  error={&lt;span&gt;Error loading image&lt;/span&gt;}\n/&gt;;\n</code></pre>"},{"location":"interview/topic/react-image-gallery/#2-react-lazy-load-image-component","title":"2. React Lazy Load Image Component:","text":"<ul> <li>Package: react-lazy-load-image-component</li> <li>Features: This package allows you to lazy load images, which can improve performance for pages with many images.</li> <li>Installation:</li> </ul> <pre><code>npm install react-lazy-load-image-component\n</code></pre> <ul> <li>Usage:</li> </ul> <pre><code>import { LazyLoadImage } from \"react-lazy-load-image-component\";\n\n&lt;LazyLoadImage\n  alt=\"Gallery\"\n  height={200}\n  src={item.url} // use normal src\n  width={200}\n  effect=\"opacity\"\n/&gt;;\n</code></pre>"},{"location":"interview/topic/react-image-gallery/#3-react-image-gallery","title":"3. React Image Gallery:","text":"<ul> <li>Package: react-image-gallery</li> <li>Features: A flexible image gallery component with features like thumbnails, fullscreen mode, and more.</li> <li>Installation:</li> </ul> <pre><code>npm install react-image-gallery\n</code></pre> <ul> <li>Usage:</li> </ul> <pre><code>import ImageGallery from \"react-image-gallery\";\n\nconst images = gallery.map((item) =&gt; ({\n  original: item.url,\n  thumbnail: item.url,\n}));\n\n&lt;ImageGallery items={images} /&gt;;\n</code></pre>"},{"location":"interview/topic/react-image-gallery/#4-cloudinary","title":"4. Cloudinary:","text":"<ul> <li>Package: cloudinary-react</li> <li>Features: If you're using Cloudinary for image storage and transformation, this package helps integrate with React.</li> <li>Installation:</li> </ul> <pre><code>npm install cloudinary-react\n</code></pre> <ul> <li>Usage:</li> </ul> <pre><code>import { CloudinaryContext, Image } from \"cloudinary-react\";\n\n&lt;CloudinaryContext cloudName=\"your-cloud-name\"&gt;\n  &lt;Image publicId={item.publicId} height=\"200\" width=\"200\" /&gt;\n&lt;/CloudinaryContext&gt;;\n</code></pre>"},{"location":"interview/topic/react-image-gallery/#summary","title":"Summary","text":"<p>Choose the package that best fits your use case based on your needs for loading, displaying, or managing images in your application. If you're just displaying images, <code>react-image</code> or <code>react-lazy-load-image-component</code> are great choices. For a gallery, <code>react-image-gallery</code> is excellent.</p>"},{"location":"interview/topic/react-image-gallery/#additional","title":"Additional","text":"<p>LazyLoadImage</p> ExampleKey ChangesSummary <pre><code>import React, { useEffect } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { getPhotosService } from \"../../../redux/features/gallery/services\";\nimport axios from \"axios\";\nimport { LazyLoadImage } from \"react-lazy-load-image-component\";\n\nconst Picture = () =&gt; {\n    const dispatch = useDispatch();\n    const { gallery, status, error } = useSelector((state) =&gt; state.gallery);\n\n    useEffect(() =&gt; {\n        const source = axios.CancelToken.source();\n\n        dispatch(getPhotosService(source.token));\n\n        return () =&gt; {\n            source.cancel();\n        };\n    }, [dispatch]);\n\n    console.log(\"gallery\", gallery);\n\n    return (\n        &lt;&gt;\n        &lt;h1&gt;Picture&lt;/h1&gt;\n\n        {gallery &amp;&amp;\n            gallery.map((item) =&gt; (\n            &lt;LazyLoadImage\n                key={item.id}\n                alt=\"Gallery\"\n                height={200}\n                src={item.url} // use the item.url for the image source\n                width={200}\n                effect=\"opacity\" // this applies the fade-in effect\n            /&gt;\n            ))}\n        &lt;/&gt;\n    );\n};\n\nexport default Picture;\n</code></pre> <ol> <li>Use <code>LazyLoadImage</code>: Replace <code>LazyLoadComponent</code> with <code>LazyLoadImage</code>. The <code>LazyLoadImage</code> component is specifically designed for loading images lazily.</li> <li>Props on <code>LazyLoadImage</code>: The props such as key, <code>alt</code>, <code>height</code>, <code>src</code>, <code>width</code>, and effect should be passed directly to <code>LazyLoadImage</code>.</li> <li>Removed Unnecessary Code: Cleaned up the code for better readability.</li> </ol> <p>With these changes, your images should now load lazily, displaying them with a fade-in effect as they come into view. This approach helps improve the performance of your application, especially if you have many images to display.</p> <p>LazyLoadComponent</p> <p>The <code>LazyLoadComponent</code> is a wrapper component that should be used to wrap the actual image component, not directly used as an image itself.</p> <p>The <code>LazyLoadComponent</code> from the react-lazy-load-image-component package is used to lazily load components, not just images. It's ideal for wrapping any component that you want to load only when it enters the viewport. Here's how to properly use <code>LazyLoadComponent</code> in your code:</p> ExampleUsing <code>LazyLoadComponent</code>Key PointsAdditional Props <pre><code>import React, { useEffect } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { getPhotosService } from \"../../../redux/features/gallery/services\";\nimport axios from \"axios\";\nimport { LazyLoadComponent } from \"react-lazy-load-image-component\";\n\nconst Picture = () =&gt; {\n    const dispatch = useDispatch();\n    const { gallery, status, error } = useSelector((state) =&gt; state.gallery);\n\n    useEffect(() =&gt; {\n        const source = axios.CancelToken.source();\n\n        dispatch(getPhotosService(source.token));\n\n        return () =&gt; {\n            source.cancel();\n        };\n    }, [dispatch]);\n\n    console.log(\"gallery\", gallery);\n\n    return (\n        &lt;&gt;\n        &lt;h1&gt;Picture&lt;/h1&gt;\n\n        {gallery &amp;&amp;\n            gallery.map((item) =&gt; (\n            &lt;LazyLoadComponent key={item.id} effect=\"opacity\"&gt;\n                &lt;img\n                    src={item.url}\n                    alt=\"Gallery\"\n                    height=\"200\"\n                    width=\"200\"\n                /&gt;\n            &lt;/LazyLoadComponent&gt;\n            ))}\n        &lt;/&gt;\n    );\n};\n\nexport default Picture;\n</code></pre> <ol> <li>Wrap Your Component: Use <code>LazyLoadComponent</code> to wrap the components you want to load lazily.</li> <li>Children Prop: The <code>LazyLoadComponent</code> can have any children, so you can wrap images, text, or other components.</li> </ol> <ol> <li>Wrapping with <code>LazyLoadComponent</code>: Each image is wrapped with <code>LazyLoadComponent</code>. This component will handle lazy loading for the image inside it.</li> <li>Effect Prop: The effect <code>prop</code> is set to <code>\"opacity\"</code> to apply a fade-in effect when the image is loaded. You can change this to other effects like \"blur\" or use a custom CSS class.</li> <li>Usage of <code>img</code> Tag: Inside the <code>LazyLoadComponent</code>, you use a standard <code>img</code> tag to render the image.</li> </ol> <ul> <li>height and width: If you want to prevent layout shifts, you can specify <code>height</code> and <code>width</code> on the <code>LazyLoadComponent</code>.</li> <li>placeholder: You can also use a placeholder by adding a <code>placeholderSrc</code> prop, which can help maintain layout while the actual image is loading.</li> </ul> Conclusion <p>By using <code>LazyLoadComponent</code>, you can effectively reduce the initial loading time of your application and improve performance by loading images and other components only when they enter the viewport.</p>"},{"location":"interview/topic/react-image-gallery/#when-to-use","title":"When to use","text":"<ul> <li>Use <code>LazyLoadComponent</code>: When you want to lazily load any React component (not just images), such as text, lists, or custom components.</li> <li>Use <code>LazyLoadImage</code>: When you specifically want to lazily load images with built-in optimizations and effects designed for images.</li> </ul> In summary <ul> <li><code>LazyLoadComponent</code> = for any component.</li> <li><code>LazyLoadImage</code> = specifically for images.</li> </ul>"},{"location":"interview/topic/react-image-gallery/#lightbox","title":"Lightbox","text":"<p>To create a modal that displays an image with Next and Previous navigation options, you can use react-image-lightbox. This package makes it easy to implement a lightbox with image navigation.</p> InstallationExampleKey Features of the CodeConclusion <pre><code>npm install react-image-lightbox\n</code></pre> <pre><code>import React, { useState } from \"react\";\nimport \"react-image-lightbox/style.css\";\nimport Lightbox from \"react-image-lightbox\";\n\nconst PictureWithLightbox = ({ gallery }) =&gt; {\n    const [isOpen, setIsOpen] = useState(false);\n    const [currentImageIndex, setCurrentImageIndex] = useState(0);\n\n    const openLightbox = (index) =&gt; {\n        setCurrentImageIndex(index);\n        setIsOpen(true);\n    };\n\n    const goToPrevious = () =&gt; {\n        setCurrentImageIndex((prevIndex) =&gt;\n            prevIndex === 0 ? gallery.length - 1 : prevIndex - 1\n        );\n    };\n\n    const goToNext = () =&gt; {\n        setCurrentImageIndex((prevIndex) =&gt;\n            prevIndex === gallery.length - 1 ? 0 : prevIndex + 1\n        );\n    };\n\n    return (\n        &lt;&gt;\n        &lt;h1&gt;Gallery&lt;/h1&gt;\n        &lt;div style={{ display: \"flex\", flexWrap: \"wrap\" }}&gt;\n            {gallery.map((item, index) =&gt; (\n                &lt;img\n                    key={item.id}\n                    src={item.url}\n                    alt=\"Gallery\"\n                    onClick={() =&gt; openLightbox(index)}\n                    style={{\n                    cursor: \"pointer\",\n                    height: \"200px\",\n                    width: \"200px\",\n                    margin: \"10px\",\n                    }}\n                /&gt;\n            ))}\n        &lt;/div&gt;\n\n        {isOpen &amp;&amp; (\n            &lt;Lightbox\n                mainSrc={gallery[currentImageIndex].url}\n                nextSrc={gallery[(currentImageIndex + 1) % gallery.length].url}\n                prevSrc={\n                    gallery[(currentImageIndex + gallery.length - 1) % gallery.length]\n                    .url\n                }\n                onCloseRequest={() =&gt; setIsOpen(false)}\n                onMovePrevRequest={goToPrevious}\n                onMoveNextRequest={goToNext}\n            /&gt;\n        )}\n        &lt;/&gt;\n    );\n};\n\nexport default PictureWithLightbox;\n</code></pre> <ol> <li> <p>State Management:</p> <ul> <li><code>isOpen</code>: Tracks whether the lightbox is open.</li> <li><code>currentImageIndex</code>: Stores the index of the currently displayed image.</li> </ul> </li> <li> <p>Open Lightbox:</p> <ul> <li>openLightbox(index): Sets the current image index and opens the lightbox.</li> </ul> </li> <li> <p>Navigation Functions:</p> <ul> <li><code>goToPrevious()</code>: Updates the index to show the previous image, wrapping around if at the beginning.</li> <li><code>goToNext()</code>: Updates the index to show the next image, wrapping around if at the end.</li> </ul> </li> <li> <p>Lightbox Component:</p> <ul> <li>Displays the current image and provides Next and Previous functionality with appropriate callbacks.</li> </ul> </li> </ol> <p>With this setup, you can click on any image in the gallery to open a modal with navigation options, allowing users to cycle through images seamlessly. This approach is user-friendly and provides a smooth viewing experience.</p>"},{"location":"interview/topic/react-image-gallery/#reference","title":"Reference","text":"<ul> <li>react-lazy-load-image-component</li> <li>React Image Gallery</li> </ul>"},{"location":"blog/archive/2024/","title":"2024","text":""},{"location":"blog/page/2/","title":"Index","text":""},{"location":"blog/page/3/","title":"Index","text":""},{"location":"blog/page/4/","title":"Index","text":""},{"location":"blog/page/5/","title":"Index","text":""},{"location":"blog/page/6/","title":"Index","text":""},{"location":"blog/archive/2024/page/2/","title":"2024","text":""},{"location":"blog/archive/2024/page/3/","title":"2024","text":""},{"location":"blog/archive/2024/page/4/","title":"2024","text":""},{"location":"blog/archive/2024/page/5/","title":"2024","text":""},{"location":"blog/archive/2024/page/6/","title":"2024","text":""},{"location":"tags/","title":"Tags","text":""},{"location":"tags/#personal","title":"Personal","text":"<ul> <li>Deep Dive into .map()</li> <li>Optimizing JavaScript Object Manipulation with Destructuring</li> <li>Efficiently Removing a Property from an Object While Retaining Its Value</li> </ul>"},{"location":"tags/#porgramming","title":"Porgramming","text":"<ul> <li>API Call in Parent or Child</li> <li>Application Structure for React.js</li> <li>Best folder structure in Redux Toolkit</li> <li>How to Check the React Version in Your Project</li> <li>Combine Slices in a Feature Folder</li> <li>Conditinally Mounting Component</li> <li>What are the main differences between Redux Thunk and Redux Saga, and which one should I use and why?</li> <li>Do we need to install redux-thunk separately when using Redux Toolkit</li> <li>A Comparative Guide to Lodash and JavaScript</li> <li>Libraries for Immutable Data Structure in React</li> <li>Loglist</li> <li>Difference between mutable and immutable data in react</li> <li>Predefined Functions in Redux Toolkit</li> <li>The Role of Reducers in Async Logic</li> <li>Simplifying Error Management in React: A Deep Dive into Component Decomposition</li> <li>Understanding the Importance of rowKey in React Tables</li> <li>Empty array or null</li> <li>Using Immer with Standard Redux</li> <li>Where to store API calls in Redux Toolkit</li> <li>Write Cleaner Reducers with Immer</li> </ul>"},{"location":"tags/#programming","title":"Programming","text":"<ul> <li>Understanding JavaScript Array Methods: Mutating vs. Non-Mutating</li> <li>Principle of Least Privilege (PoLP)</li> <li>React Router v6 Guide</li> </ul>"},{"location":"tags/#react","title":"React","text":"<ul> <li>API Call in Parent or Child</li> <li>Application Structure for React.js</li> <li>How to Check the React Version in Your Project</li> <li>Conditinally Mounting Component</li> <li>A Comparative Guide to Lodash and JavaScript</li> <li>Libraries for Immutable Data Structure in React</li> <li>Loglist</li> <li>Difference between mutable and immutable data in react</li> <li>Principle of Least Privilege (PoLP)</li> <li>Predefined Functions in Redux Toolkit</li> <li>Simplifying Error Management in React: A Deep Dive into Component Decomposition</li> <li>Understanding the Importance of rowKey in React Tables</li> <li>Empty array or null</li> <li>Using Immer with Standard Redux</li> <li>Write Cleaner Reducers with Immer</li> </ul>"},{"location":"tags/#redux","title":"Redux","text":"<ul> <li>Best folder structure in Redux Toolkit</li> <li>Combine Slices in a Feature Folder</li> <li>What are the main differences between Redux Thunk and Redux Saga, and which one should I use and why?</li> <li>Do we need to install redux-thunk separately when using Redux Toolkit</li> <li>The Role of Reducers in Async Logic</li> <li>Where to store API calls in Redux Toolkit</li> </ul>"},{"location":"tags/#saga","title":"Saga","text":"<ul> <li>Best folder structure in Redux Toolkit</li> <li>Combine Slices in a Feature Folder</li> <li>What are the main differences between Redux Thunk and Redux Saga, and which one should I use and why?</li> <li>Do we need to install redux-thunk separately when using Redux Toolkit</li> <li>The Role of Reducers in Async Logic</li> <li>Where to store API calls in Redux Toolkit</li> </ul>"},{"location":"tags/#thunk","title":"Thunk","text":"<ul> <li>Best folder structure in Redux Toolkit</li> <li>Combine Slices in a Feature Folder</li> <li>What are the main differences between Redux Thunk and Redux Saga, and which one should I use and why?</li> <li>Do we need to install redux-thunk separately when using Redux Toolkit</li> <li>The Role of Reducers in Async Logic</li> <li>Where to store API calls in Redux Toolkit</li> </ul>"},{"location":"tags/#antd","title":"antd","text":"<ul> <li>Advanced tips tricks antd design table</li> <li>Choosing Between Function Declarations and Arrow Functions for React Components</li> <li>How Many Concurrent Requests Can a Web Browser Handle?</li> </ul>"},{"location":"tags/#arrow","title":"arrow","text":"<ul> <li>JavaScript Arrow Functions</li> </ul>"},{"location":"tags/#base64","title":"base64","text":"<ul> <li>Saving base64 data into an Excel file in a React application</li> </ul>"},{"location":"tags/#databse","title":"databse","text":"<ul> <li>Conditional Rendering in React</li> <li>Handling Multiple API Calls with Search Input in React using Debouncing and Axios</li> <li>Order of Operations in Ant Design Forms: Ensuring Proper Form Resetting</li> <li>Role-Based vs Permission-Based Access Control in React</li> </ul>"},{"location":"tags/#django","title":"django","text":"<ul> <li>Conditional Rendering in React</li> <li>Handling Multiple API Calls with Search Input in React using Debouncing and Axios</li> <li>Order of Operations in Ant Design Forms: Ensuring Proper Form Resetting</li> <li>Role-Based vs Permission-Based Access Control in React</li> </ul>"},{"location":"tags/#formatting","title":"formatting","text":"<ul> <li>Prettier Formatter for Visual Studio Code</li> </ul>"},{"location":"tags/#http","title":"http","text":"<ul> <li>Useful React Libraries for Projects</li> </ul>"},{"location":"tags/#js","title":"js","text":"<ul> <li>Checking Node.js Versions in React Projects</li> <li>Understanding e.item.props in React and Ant Design's Menu Component</li> <li>Exploring Object.prototype in JavaScript</li> <li>Understanding Functional State Updates in React: A Deep Dive into setSelectedGroupData</li> <li>Handling Circular References in JavaScript: Avoiding 'TypeError: cyclic object value' in JSON.stringify</li> <li>Handling JSON Parsing Errors in JavaScript: A Practical Approach</li> <li>History API</li> <li>JavaScript Arrow Functions</li> <li>JS objects</li> <li>Understanding the Difference Between Response Object and Parsed Data Object</li> <li>Unveiling Static and Prototype Methods in JavaScript Built-in Objects</li> </ul>"},{"location":"tags/#postgresql","title":"postgresql","text":"<ul> <li>Conditional Rendering in React</li> <li>Handling Multiple API Calls with Search Input in React using Debouncing and Axios</li> <li>Order of Operations in Ant Design Forms: Ensuring Proper Form Resetting</li> <li>Role-Based vs Permission-Based Access Control in React</li> </ul>"},{"location":"tags/#postman","title":"postman","text":"<ul> <li>Useful React Libraries for Projects</li> </ul>"},{"location":"tags/#react_1","title":"react","text":"<ul> <li>Advanced tips tricks antd design table</li> <li>Checking Node.js Versions in React Projects</li> <li>Choosing Between Function Declarations and Arrow Functions for React Components</li> <li>Understanding e.item.props in React and Ant Design's Menu Component</li> <li>Understanding Functional State Updates in React: A Deep Dive into setSelectedGroupData</li> <li>Handling JSON Parsing Errors in JavaScript: A Practical Approach</li> <li>History API</li> <li>How Many Concurrent Requests Can a Web Browser Handle?</li> <li>Mastering Object Destructuring, Rest, and Spread Operators in JavaScript</li> <li>Saving base64 data into an Excel file in a React application</li> <li>Understanding async/await</li> <li>Where does redux shines?</li> </ul>"},{"location":"tags/#redux_1","title":"redux","text":"<ul> <li>Where does redux shines?</li> </ul>"},{"location":"tags/#vscode","title":"vscode","text":"<ul> <li>Prettier Formatter for Visual Studio Code</li> </ul>"}]}