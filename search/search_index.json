{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to JSExpert","text":""},{"location":"#welcome-to-jsexpert","title":"Welcome to JSExpert","text":""},{"location":"#react","title":"React","text":""},{"location":"tags/","title":"Tags","text":""},{"location":"tags/#tags","title":"Tags","text":"<ul> <li>Programming</li> <li>Web Development</li> <li>Design</li> <li>Testing</li> <li>Database</li> </ul>"},{"location":"tags/#frameworks","title":"Frameworks","text":"<ul> <li>Django</li> <li>Drf</li> <li>React</li> <li>Jest</li> </ul>"},{"location":"tags/#language","title":"Language","text":"<ul> <li>Python</li> <li>JavaScript</li> </ul>"},{"location":"tags/#tools","title":"Tools","text":"<ul> <li>Vim</li> <li>Git</li> <li>Github</li> <li>SSH</li> </ul>"},{"location":"tags/#misc","title":"Misc","text":"<ul> <li>Personal</li> <li>Postman</li> <li>Redis</li> <li>RabbitMQ</li> <li>SimpleJWT</li> </ul>"},{"location":"tags/#porgramming","title":"Porgramming","text":"<ul> <li>Application Structure for React.js</li> <li>How to Check the React Version in Your Project</li> </ul>"},{"location":"tags/#programming","title":"Programming","text":"<ul> <li>Understanding JavaScript Array Methods: Mutating vs. Non-Mutating</li> <li>React Router v6 Guide</li> </ul>"},{"location":"tags/#react","title":"React","text":"<ul> <li>Application Structure for React.js</li> <li>How to Check the React Version in Your Project</li> </ul>"},{"location":"tags/#arrow","title":"arrow","text":"<ul> <li>JavaScript Arrow Functions</li> </ul>"},{"location":"tags/#base64","title":"base64","text":"<ul> <li>Saving base64 data into an Excel file in a React application</li> </ul>"},{"location":"tags/#databse","title":"databse","text":"<ul> <li>Conditional Rendering in React</li> <li>Handling Multiple API Calls with Search Input in React using Debouncing and Axios</li> <li>Order of Operations in Ant Design Forms: Ensuring Proper Form Resetting</li> <li>Role-Based vs Permission-Based Access Control in React</li> </ul>"},{"location":"tags/#django","title":"django","text":"<ul> <li>Conditional Rendering in React</li> <li>Handling Multiple API Calls with Search Input in React using Debouncing and Axios</li> <li>Order of Operations in Ant Design Forms: Ensuring Proper Form Resetting</li> <li>Role-Based vs Permission-Based Access Control in React</li> </ul>"},{"location":"tags/#formatting","title":"formatting","text":"<ul> <li>Prettier Formatter for Visual Studio Code</li> </ul>"},{"location":"tags/#http","title":"http","text":"<ul> <li>Useful React Libraries for Projects</li> </ul>"},{"location":"tags/#js","title":"js","text":"<ul> <li>Checking Node.js Versions in React Projects</li> <li>Understanding e.item.props in React and Ant Design's Menu Component</li> <li>Exploring Object.prototype in JavaScript</li> <li>Understanding Functional State Updates in React: A Deep Dive into setSelectedGroupData</li> <li>Handling Circular References in JavaScript: Avoiding 'TypeError: cyclic object value' in JSON.stringify</li> <li>Handling JSON Parsing Errors in JavaScript: A Practical Approach</li> <li>History API</li> <li>JavaScript Arrow Functions</li> <li>JS objects</li> <li>Understanding the Difference Between Response Object and Parsed Data Object</li> <li>Unveiling Static and Prototype Methods in JavaScript Built-in Objects</li> </ul>"},{"location":"tags/#postgresql","title":"postgresql","text":"<ul> <li>Conditional Rendering in React</li> <li>Handling Multiple API Calls with Search Input in React using Debouncing and Axios</li> <li>Order of Operations in Ant Design Forms: Ensuring Proper Form Resetting</li> <li>Role-Based vs Permission-Based Access Control in React</li> </ul>"},{"location":"tags/#postman","title":"postman","text":"<ul> <li>Useful React Libraries for Projects</li> </ul>"},{"location":"tags/#react_1","title":"react","text":"<ul> <li>Checking Node.js Versions in React Projects</li> <li>Understanding e.item.props in React and Ant Design's Menu Component</li> <li>Understanding Functional State Updates in React: A Deep Dive into setSelectedGroupData</li> <li>Handling JSON Parsing Errors in JavaScript: A Practical Approach</li> <li>History API</li> <li>Saving base64 data into an Excel file in a React application</li> </ul>"},{"location":"tags/#vscode","title":"vscode","text":"<ul> <li>Prettier Formatter for Visual Studio Code</li> </ul>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2024/05/16/application-structure-for-reactjs/","title":"Application Structure for React.js","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#application-structure-for-reactjs","title":"Application Structure for React.js","text":"<p>React.js itself does not provide a guideline on structuring projects but does suggest a few commonly used approaches.</p> <p>At the high level, you can group files in a React application in two ways:</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#1-group-by-feature","title":"1. Group by feature","text":"<ul> <li>Create folders for every application module, feature, or route.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#2-group-by-file-type","title":"2.  Group by file type","text":"<ul> <li>Create folders for different types of files.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#group-by-module-feature-or-route","title":"Group by Module, Feature, or Route","text":"<p>In this case, the file structure would mirror the business model or the application flow. For example, if you have an ecommerce application, you will have folders for product, productlist, checkout, etc. The CSS, JSX components, tests, subcomponents, or helper libraries explicitly required for the product module reside in the product folder:</p> <pre><code>common/\n    Avatar.js\n    Avatar.css\n    ErrorUtils.js\n    ErrorUtils.test.js\n\nproduct/\n    index.js\n    product.css\n    price.js\n    product.test.js\n\ncheckout/\n    index.js\n    checkout.css\n    checkout.test.js\n</code></pre> <p>The advantage of grouping files by feature is that if there is a change to the module, all the affected files are colocated in the same folder, and the change gets localized to a specific part of the code.</p> <p>The disadvantage is common components, logic, or styles used across modules should be identified periodically to avoid repetition and promote consistency and reuse.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#group-by-file-type","title":"Group by File Type","text":"<p>In this type of grouping, you would create different folders for CSS, components, test files, images, libraries, etc. Thus, logically related files would reside in different folders based on the file type:</p> <pre><code>css/\n    global.css\n    checkout.css\n    product.css\n\nlib/\n    date.js\n    currency.js\n    gtm.js\n\npages/\n    product.js\n    productlist.js\n    checkout.js\n</code></pre> <p>The advantages of this approach are:</p> <ul> <li>You have a standard structure that you can reuse across projects.</li> <li>Newer team members with little knowledge of the application-specific logic can still find files for something like styles or tests.</li> <li>Common components (such as date pickers) and styles imported in different routes or modules can be changed once to ensure that the effect is seen across the application.</li> </ul> <p>The disadvantages are:</p> <ul> <li>A change in logic for a specific module would likely require changes in files across different folders.</li> <li>As the number of features in the application grows, the number of files in different folders would increase, making it difficult to find a specific file.</li> </ul> <p>Either of these approaches could be easy to set up for small- to mid-sized applications with a small number of files (50 to 100) per folder. For larger projects, however, you may want to go for a hybrid approach based on the logical structure of your application. Let us look at some of the possibilities.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#hybrid-grouping-based-on-domain-and-common-components","title":"Hybrid Grouping Based on Domain and Common Components","text":"<p>Here you would group all common components required across the application in a Components folder and all application flow-specific routes or features in a domain folder (the name could be domain, pages, or routes). Every folder can have subfolders for specific components and related files:</p> <pre><code>css/\n    global.css\ncomponents/\n    User/\n        profile.js\n        profile.test.js\n        avatar.js\n    date.js\n    currency.js\n    gtm.js\n    errorUtils.js\ndomain/\n    product/\n        product.js\n        product.css\n        product.test.js\n    checkout/\n        checkout.js\n        checkout.css\n        checkout.test.js\n</code></pre> <p>Thus, you can combine the advantages of both \u201cGroup by file type\u201d and \u201cGroup by feature\u201d by colocating related files, which change together frequently and common reusable components and styles used across the application. Depending on the complexity of the application, you can modify this to a flatter structure without subfolders or a more nested structure:</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#flatter-structure","title":"Flatter structure","text":"<p>The following example illustrates a flatter structure:</p> <pre><code>domain/\n    product.js\n    product.css\n    product.test.js\n    checkout.js\n    checkout.css\n    checkout.test.js\n</code></pre>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#nested-structure","title":"Nested structure","text":"<p>The following example shows a more nested structure:</p> <pre><code>domain/\n    product/\n        productType/\n            features.js\n            features.css\n            size.js\n        price/\n            listprice.js\n            discount.js\n</code></pre> <p>A variation to this approach is to create folders based on views or routes, in addition to those based on domain, as discussed here. A routing component can then coordinate the view to be displayed based on the current route. Next.js uses a similar structure.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#application-structure-for-modern-react-features","title":"Application Structure for Modern React Features","text":"<p>Modern React apps use different features such as Redux, stateful containers, Hooks, and Styled Components. Let\u2019s see where the code related to these would fit in the application structure proposed in the previous section.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#redux","title":"Redux","text":"<p>Redux documentation strongly recommends colocating logic for a given feature in one place. Within a given feature folder, the Redux logic for that feature should be written as a single \u201cslice\u201d file, preferably using the Redux Toolkit createSlice API.</p> <p>The file bundles <code>{actionTypes, actions, reducer}</code> to a self-contained, isolated module. This is also known as the \u201cducks\u201d pattern (from Redux). </p> <p>For example, as given here:</p> <pre><code>/src\n    index.tsx: Entry point file that renders the React component tree\n\n/app\n    store.ts: store setup\n    rootReducer.ts: root reducer (optional)\n    App.tsx: root React component\n\n/common: hooks, generic components, utils, etc\n\n/features: contains all \"feature folders\"\n\n/todos: a single feature folder\n    todosSlice.ts: Redux reducer logic and associated actions\n    Todos.tsx: a React component\n</code></pre> <p>Another comprehensive example that uses Redux without creating containers or Hooks is available here.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#containers","title":"Containers","text":"<p>If you have structured your code to categorize components into presentational components and stateful container components, you can create a separate folder for the container components. Containers let you separate complex stateful logic from other aspects of the component:</p> <pre><code>/src\n    /components\n        /component1\n            index.js\n            styled.js\n    /containers\n        /container1\n</code></pre> <p>You can find a complete structure for an app with containers in the same article.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#hooks","title":"Hooks","text":"<p>Hooks can fit into the hybrid structure just like any other type of code. You can have a folder at the app level for common Hooks that can be consumed by all React components. React Hooks used by only one component should remain in the component\u2019s file or a separate hooks.js file in the component\u2019s folder. You can find a sample structure here:</p> <pre><code>/components\n    /productList\n        index.js\n        test.js\n        style.css\n        hooks.js\n\n/hooks\n    /useClickOutside\n        index.js\n    /useData\n        index.js\n</code></pre>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#styled-components","title":"Styled Components","text":"<p>If you are using Styled Components instead of CSS, you can have style.js files instead of the component-level CSS files mentioned earlier. For example, if you have a titlebar component, the structure would be something like this:</p> <pre><code>/src/components/button/\n    index.js\n    style.js\n</code></pre> <p>An application-level theme.js file would contain the values for colors to be used for background and text. A globals component could include definitions for common style elements that other components can use.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#reference","title":"Reference","text":"<ul> <li>Learning JavaScript Design Patterns: 2nd edition by Addy Osmani</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/01/22/how-to-check-the-react-version-in-your-project/","title":"How to Check the React Version in Your Project","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/01/22/how-to-check-the-react-version-in-your-project/#how-to-check-the-react-version-in-your-project","title":"How to Check the React Version in Your Project","text":"<p>React, a popular JavaScript library for building user interfaces, undergoes regular updates to introduce new features, improvements, and bug fixes. As a React developer, it's essential to know the version of React used in your project. In this short blog post, we'll explore how you can easily check the React version of your project.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/01/22/how-to-check-the-react-version-in-your-project/#methods-to-check-react-version","title":"Methods to Check React Version:","text":"<ol> <li> <p>Examine <code>package.json</code>:</p> <p>The <code>package.json</code> file is a central configuration file for Node.js projects, including React applications. Open the <code>package.json</code> file in your project's root directory using a text editor. Look for the \"dependencies\" section, where React is listed with its version.</p> <pre><code>\"dependencies\": {\n    \"react\": \"^17.0.1\",\n    \"react-dom\": \"^17.0.1\",\n\n    // other dependencies...\n}\n</code></pre> <p>In this example, the version of React is specified as \"<code>^17.0.1</code>\".</p> </li> <li> <p>Use Command Line:</p> <p>You can also use the command line to check the installed version of React. Open your terminal or command prompt, navigate to your project's root directory, and run the following command:</p> <pre><code>npm list react\n</code></pre> <p>If you're using Yarn, run:</p> <pre><code>yarn list react\n</code></pre> <p>This command will display the version of React installed in your project.</p> </li> <li> <p>Inspect the Browser Console:</p> <p>During development, you can view the React version in your browser's developer tools console. Open your application in a web browser, right-click on the page, select \"Inspect\" to open the developer tools, and navigate to the \"Console\" tab. Type the following command and press Enter:</p> <pre><code>console.log(React.version);\n</code></pre> <p>This will log the React version to the console.</p> </li> </ol>","tags":["Porgramming","React"]},{"location":"blog/2024/01/22/how-to-check-the-react-version-in-your-project/#conclusion","title":"Conclusion:","text":"<p>Knowing the React version in your project is crucial for various reasons, including understanding the available features, compatibility, and potential need for updates. By examining your <code>package.json</code> file, using command-line tools, or inspecting the browser console, you can easily check the React version and ensure your project stays up-to-date with the latest advancements in React development.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/11/checking-nodejs-versions-in-react-projects/","title":"Checking Node.js Versions in React Projects","text":"","tags":["react","js"]},{"location":"blog/2024/05/11/checking-nodejs-versions-in-react-projects/#checking-nodejs-versions-in-react-projects","title":"Checking <code>Node.js</code> Versions in React Projects","text":"<p>React itself doesn't directly depend on Node.js version. However, when you're developing a React application, you typically use Node.js and npm (Node Package Manager) to manage your project's dependencies, run development servers, and build your application for production.</p> <p>React projects typically come with a package.json file which specifies the project's dependencies, including the version of Node.js it's compatible with. You can find the required version of Node.js specified in the engines field of the package.json file.</p> package.json<pre><code>\"engines\": {\n  \"node\": \"&gt;=12.0.0\"\n}\n</code></pre> <p>This indicates that the project requires Node.js version <code>12.0.0</code> or later to run properly. You should install the specified version of Node.js on your development machine to ensure compatibility with the React project.</p> <p>You can check the <code>package.json</code> file in your React project's root directory to see which version of Node.js it requires. If you don't have a <code>package.json</code> file, it's likely that your React project hasn't been initialized properly, and you might need to set it up with npm init or yarn init to generate the file.</p>","tags":["react","js"]},{"location":"blog/2024/05/27/conditional-rendering-in-react/","title":"Conditional Rendering in React","text":"","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/27/conditional-rendering-in-react/#conditional-rendering-in-react","title":"Conditional Rendering in React","text":"Conditional Rendering in React: Using Ternary Operators vs. Logical AND <p>Both code snippets are functionally equivalent, but there are differences in style and readability. Here\u2019s a comparison of the two approaches:</p>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/27/conditional-rendering-in-react/#1-using-a-ternary-operator","title":"1.  Using a Ternary Operator","text":"<pre><code>{isCircular ? (\n&lt;&gt;\n    &lt;div style={{ display: \"flex\" }}&gt;\n        &lt;Button type=\"primary\" onClick={() =&gt; {\n            setIsTemplateModalOpen(true);\n            dispatch(actionForGetAllCircularPlanningTemplate());\n        }} style={{ marginRight: \"8px\" }}&gt;\n            Template\n        &lt;/Button&gt;\n        &lt;Button type=\"primary\" onClick={() =&gt; setIsCircularModalOpen(true)}&gt;\n            Send for Approval\n        &lt;/Button&gt;\n    &lt;/div&gt;\n&lt;/&gt;\n) : null}\n</code></pre>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/27/conditional-rendering-in-react/#2-using-logical-and-operator","title":"2.  Using Logical AND Operator","text":"<pre><code>{isCircular &amp;&amp; (\n  &lt;&gt;\n    &lt;div style={{ display: \"flex\" }}&gt;\n      &lt;Button type=\"primary\" onClick={() =&gt; {\n        setIsTemplateModalOpen(true);\n        dispatch(actionForGetAllCircularPlanningTemplate());\n      }} style={{ marginRight: \"8px\" }}&gt;\n        Template\n      &lt;/Button&gt;\n      &lt;Button type=\"primary\" onClick={() =&gt; setIsCircularModalOpen(true)}&gt;\n        Send for Approval\n      &lt;/Button&gt;\n    &lt;/div&gt;\n  &lt;/&gt;\n)}\n</code></pre>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/27/conditional-rendering-in-react/#comparison-and-recommendations","title":"Comparison and Recommendations","text":"Readability and Simplicity: <ul> <li>Logical AND (<code>&amp;&amp;</code>): This method is more concise and commonly used in React for conditional rendering. It directly expresses that the content should only render if the condition is true, making the code cleaner and easier to read.</li> <li>Ternary Operator (<code>? :</code>): This method is more explicit, showing both the <code>true</code> and <code>false</code> branches. It\u2019s useful when you need to render something when the condition is <code>false</code>, but in cases where you only care about rendering when true, it can be more verbose.</li> </ul> Use Case: <ul> <li>If you only need to render something based on a condition and don\u2019t need to handle the <code>false</code> case, the logical AND (<code>&amp;&amp;</code>) operator is typically preferred for its brevity.</li> <li>If you need to explicitly handle both <code>true</code> and <code>false</code> cases (e.g., rendering a fallback or alternative UI), the ternary operator is more appropriate.</li> </ul> Code Consistency: <ul> <li>Choose a style that is consistent with the rest of your codebase. Consistency helps maintain readability and makes it easier for others to understand and maintain the code.</li> </ul>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/27/conditional-rendering-in-react/#conclusion","title":"Conclusion","text":"<p>In most cases, using the logical AND (<code>&amp;&amp;</code>) operator is preferred for its simplicity and readability when you only need to render content conditionally:</p> <pre><code>{isCircular &amp;&amp; (\n  &lt;&gt;\n    &lt;div style={{ display: \"flex\" }}&gt;\n      &lt;Button type=\"primary\" onClick={() =&gt; {\n        setIsTemplateModalOpen(true);\n        dispatch(actionForGetAllCircularPlanningTemplate());\n      }} style={{ marginRight: \"8px\" }}&gt;\n        Template\n      &lt;/Button&gt;\n      &lt;Button type=\"primary\" onClick={() =&gt; setIsCircularModalOpen(true)}&gt;\n        Send for Approval\n      &lt;/Button&gt;\n    &lt;/div&gt;\n  &lt;/&gt;\n)}\n</code></pre> <p>This method clearly shows that the content is rendered only if <code>isCircular</code> is true, and it avoids the need to explicitly render <code>null</code> for the <code>false</code> case.</p>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/27/conditional-rendering-in-react/#question","title":"Question","text":"","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/27/conditional-rendering-in-react/#what-is-conditional-rendering","title":"What is Conditional rendering","text":"<p>Conditional rendering in React is a technique used to render different components or elements based on certain conditions. It allows you to control what is displayed to the user based on the state or props of your component. This is essential for creating dynamic and interactive user interfaces.</p>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/27/conditional-rendering-in-react/#types-of-conditional-rendering","title":"Types of Conditional Rendering","text":"<ol> <li> <p>Using if Statements:</p> <ul> <li>You can use <code>if</code> statements inside your component to conditionally render different JSX elements.</li> </ul> <pre><code>const MyComponent = ({ isLoggedIn }) =&gt; {\n  if (isLoggedIn) {\n    return &lt;h1&gt;Welcome Back!&lt;/h1&gt;;\n  } else {\n    return &lt;h1&gt;Please Log In&lt;/h1&gt;;\n  }\n};\n</code></pre> </li> <li> <p>Using Ternary Operators:</p> <ul> <li>The ternary operator is often used for inline conditional rendering within JSX.</li> </ul> <pre><code>const MyComponent = ({ isLoggedIn }) =&gt; (\n  &lt;div&gt;\n    {isLoggedIn ? &lt;h1&gt;Welcome Back!&lt;/h1&gt; : &lt;h1&gt;Please Log In&lt;/h1&gt;}\n  &lt;/div&gt;\n);\n</code></pre> </li> <li> <p>Using Logical AND (<code>&amp;&amp;</code>) Operator:</p> <ul> <li>The logical AND operator is used to render content only if a condition is true.</li> </ul> <pre><code>const MyComponent = ({ showWelcome }) =&gt; (\n  &lt;div&gt;\n    {showWelcome &amp;&amp; &lt;h1&gt;Welcome to Our Website!&lt;/h1&gt;}\n  &lt;/div&gt;\n);\n</code></pre> </li> <li> <p>Using <code>switch</code> Statements:</p> <ul> <li>For more complex scenarios, a <code>switch</code> statement can be used to render different components based on multiple conditions.</li> </ul> <pre><code>const MyComponent = ({ status }) =&gt; {\n  switch (status) {\n    case 'loading':\n      return &lt;h1&gt;Loading...&lt;/h1&gt;;\n    case 'success':\n      return &lt;h1&gt;Data Loaded Successfully!&lt;/h1&gt;;\n    case 'error':\n      return &lt;h1&gt;Error Loading Data&lt;/h1&gt;;\n    default:\n      return &lt;h1&gt;Unknown Status&lt;/h1&gt;;\n  }\n};\n</code></pre> </li> <li> <p>Using Inline Functions:</p> <ul> <li>Sometimes, especially in more complex conditions, you might use inline functions or methods.</li> </ul> <pre><code>const MyComponent = ({ user }) =&gt; {\n  const renderUserGreeting = () =&gt; {\n    if (user) {\n      return &lt;h1&gt;Hello, {user.name}!&lt;/h1&gt;;\n    }\n    return &lt;h1&gt;Hello, Guest!&lt;/h1&gt;;\n  };\n\n  return &lt;div&gt;{renderUserGreeting()}&lt;/div&gt;;\n};\n</code></pre> </li> </ol>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/27/conditional-rendering-in-react/#conclusion_1","title":"Conclusion","text":"<p>Conditional rendering is a powerful feature in React that helps you create dynamic and interactive user interfaces. Choose the method that best fits the complexity of your conditions and maintain readability and maintainability of your code.</p>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/27/conditional-rendering-in-react/#advanced-topic","title":"Advanced Topic","text":"<p>While conditional rendering is essential in React, it is not the most advanced or the sole important topic. It is a foundational concept, but mastering React involves understanding multiple advanced concepts and patterns. Here\u2019s a breakdown of where conditional rendering fits and what other advanced topics exist in React:</p> <ol> <li> <p>Conditional Rendering (Basic to Intermediate)</p> <ul> <li>Conditional rendering is important because it allows you to dynamically show or hide components based on application state, props, or user interactions.</li> <li>It\u2019s essential but relatively straightforward once you understand basic JavaScript control structures.</li> </ul> </li> <li> <p>More Advanced and Important Topics in React</p> </li> </ol> <p>2.1 State Management (Advanced)</p> <ul> <li>Managing component state with hooks (<code>useState</code>, <code>useReducer</code>).</li> <li>Using libraries like <code>Redux</code> or <code>Context API</code> for global state management.</li> <li>Understanding how to handle complex state logic, side effects (<code>useEffect</code>), and async operations (e.g., API calls).</li> </ul> <p>2.2 React Hooks (Intermediate to Advanced)</p> <ul> <li>Hooks like <code>useEffect</code>, <code>useContext</code>, <code>useMemo</code>, <code>useCallback</code>, <code>useRef</code>, etc., bring reusability and optimization.</li> <li>Custom hooks are essential for abstracting complex logic into reusable pieces.</li> </ul> <p>2.3 Component Lifecycle and Side Effects (Advanced)</p> <ul> <li>Understanding how React\u2019s rendering lifecycle works and using hooks like <code>useEffect</code> to handle side effects (data fetching, subscriptions, cleanup).</li> <li>How React optimizes rendering with virtual DOM and reconciliation processes.</li> </ul> <p>2.4 Performance Optimization (Advanced)</p> <ul> <li>Techniques like memoization (<code>React.memo</code>, <code>useMemo</code>, <code>useCallback</code>) to prevent unnecessary re-renders.</li> <li>Code splitting and lazy loading for better performance using React.lazy and Suspense.</li> <li>Dealing with large lists efficiently using react-window or react-virtualized.</li> </ul> <p>2.5 Routing and Navigation</p> <ul> <li>Handling routing with libraries like React Router.</li> <li>Dynamic route matching, route guards, and lazy-loading routes.</li> </ul> <p>2.6 Context API (Intermediate to Advanced)</p> <ul> <li>The Context API allows for state sharing between components without prop drilling.</li> <li>It's useful for handling global state or themes, but managing complex state often requires Redux or other state libraries.</li> </ul> <p>2.7 Higher-Order Components (HOCs) &amp; Render Props</p> <ul> <li>HOCs and render props are patterns used for code reuse, which is essential for maintaining clean, reusable components in large codebases.</li> </ul> <p>2.8 Custom Hooks and Reusability Patterns</p> <ul> <li>Creating custom hooks allows for reusing logic across components.</li> <li>Exploring patterns like Compound Components and Provider Pattern for scalable and reusable UI libraries.</li> </ul> <p>2.9 React Context vs Redux (Global State Management)</p> <ul> <li>Understanding when to use React Context vs. more advanced state management libraries like Redux for global app state.</li> </ul> <p>2.10 Testing (Advanced)</p> <ul> <li>Testing React components using libraries like Jest and React Testing Library for unit testing and integration testing.</li> <li>Snapshot testing, mocking APIs, and ensuring UI behaves as expected are critical in scalable applications.</li> </ul> <p>2.11 TypeScript with React</p> <ul> <li>Adding TypeScript to React for better type checking, autocompletion, and code robustness in large applications.</li> <li>Advanced types and generics in components and hooks.</li> </ul> <p>2.12 Server-Side Rendering (SSR) and Static Site Generation (SSG)</p> <ul> <li>Understanding Next.js or Gatsby for building applications with SSR or SSG, improving SEO and performance.</li> <li>Managing data fetching and page pre-rendering in SSR.</li> </ul> <p>2.13 React Native (Mobile Development)</p> <ul> <li>Transitioning from React to React Native for mobile app development using similar paradigms.</li> <li>Handling platform-specific behaviors while sharing logic across mobile and web.</li> </ul> Conclusion <p>Conditional rendering is important but is only one of the core concepts of React. More advanced topics, such as state management, hooks, performance optimization, and patterns like HOCs or custom hooks, are vital for mastering React and handling real-world, scalable applications.</p> <p>Becoming proficient in React involves learning and mastering several areas, not just conditional rendering.</p>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/18/understanding-eitemprops-in-react-and-ant-designs-menu-component/","title":"Understanding e.item.props in React and Ant Design's Menu Component","text":"","tags":["react","js"]},{"location":"blog/2024/05/18/understanding-eitemprops-in-react-and-ant-designs-menu-component/#understanding-eitemprops-in-react-and-ant-designs-menu-component","title":"Understanding <code>e.item.props</code> in React and Ant Design's Menu Component","text":"<p>In the context of Ant Design's Menu component, <code>e.item.props</code> refers to the properties of the Menu.Item component that triggered the click event. When a menu item is clicked, Ant Design provides an event object e that contains various details about the event. One of these details is <code>e.item</code>, which represents the <code>Menu.Item</code> that was clicked.</p>","tags":["react","js"]},{"location":"blog/2024/05/18/understanding-eitemprops-in-react-and-ant-designs-menu-component/#how-eitemprops-works","title":"How <code>e.item.props</code> Works?","text":"<p>When you create a Menu in Ant Design, each Menu.Item can have its own properties. These properties are similar to the props you would pass to any React component. For instance, you might pass a <code>key</code>, <code>title</code>, or <code>custom data-*</code> attributes to a Menu.Item.</p> <p>Example</p> React<pre><code>import React, { useState } from 'react';\nimport { Menu } from 'antd';\n\nconst MyMenuComponent = ({ menuData, handleMenuClick }) =&gt; {\n    const [selectedTitle, setSelectedTitle] = useState('');\n\n    const handleClick = (e) =&gt; {\n        const clickedTitle = e.item.props['data-title'];\n        setSelectedTitle(clickedTitle);\n        handleMenuClick(clickedTitle);\n    };\n\n    return (\n        &lt;Menu onClick={handleClick} style={{ width: 256 }} mode=\"inline\"&gt;\n            {menuData.map((item, index) =&gt; (\n                &lt;Menu.Item\n                key={item.id}\n                data-title={item.title}\n                &gt;\n                &lt;span&gt;{index + 1}. {item.title}&lt;/span&gt;\n                &lt;/Menu.Item&gt;\n            ))}\n        &lt;/Menu&gt;\n    );\n};\n\nexport default MyMenuComponent;\n</code></pre>","tags":["react","js"]},{"location":"blog/2024/05/18/understanding-eitemprops-in-react-and-ant-designs-menu-component/#why-use-eitemprops","title":"Why Use e.item.props?","text":"<p>Using <code>e.item.props</code> is beneficial for several reasons:</p> <ol> <li> <p>Dynamic Data Access:</p> <p>It allows you to dynamically access data associated with a menu item, such as titles, IDs, or custom attributes.</p> </li> <li> <p>Simplified Event Handling:</p> <p>Instead of setting up additional state or context to manage menu item data, you can directly access the properties within the event handler.</p> </li> <li> <p>Enhanced Flexibility:</p> <p>You can pass any data you need via custom attributes, making your components more flexible and easier to manage.</p> </li> </ol>","tags":["react","js"]},{"location":"blog/2024/05/18/understanding-eitemprops-in-react-and-ant-designs-menu-component/#conclusion","title":"Conclusion","text":"<p>Whether you're building a sidebar menu or any other interactive component, understanding how to use <code>e.item.props</code> effectively will enhance your React development experience.</p>","tags":["react","js"]},{"location":"blog/2024/05/21/exploring-objectprototype-in-javascript/","title":"Exploring Object.prototype in JavaScript","text":"","tags":["js"]},{"location":"blog/2024/05/21/exploring-objectprototype-in-javascript/#exploring-objectprototype-in-javascript","title":"Exploring <code>Object.prototype</code> in JavaScript","text":"<p>You can inspect the Object.prototype in various ways depending on the environment you are working in. Here are a few methods to do this:</p>","tags":["js"]},{"location":"blog/2024/05/21/exploring-objectprototype-in-javascript/#in-a-browser-console","title":"In a Browser Console","text":"<ul> <li>Open Developer Tools: You can usually open this by pressing <code>F12</code>, <code>Ctrl+Shift+I</code>, or <code>Cmd+Option+I</code>.</li> <li>Go to the Console Tab: Here you can execute JavaScript code.</li> <li> <p>Inspect <code>Object.prototype</code>: Type the following code and press Enter:</p> <pre><code>console.dir(Object.prototype);\n</code></pre> </li> </ul>","tags":["js"]},{"location":"blog/2024/05/21/exploring-objectprototype-in-javascript/#using-nodejs","title":"Using Node.js","text":"<ul> <li>Open a Terminal: Ensure you have Node.js installed.</li> <li>Run the Node.js REPL: Type node and press Enter.</li> <li> <p>Inspect <code>Object.prototype</code>: Type the following code and press Enter:</p> <pre><code>console.dir(Object.prototype);\n</code></pre> </li> </ul>","tags":["js"]},{"location":"blog/2024/05/21/exploring-objectprototype-in-javascript/#example-output","title":"Example Output","text":"<p>When you inspect <code>Object.prototype</code>, you should see an object with various methods and properties like <code>hasOwnProperty</code>, <code>toString</code>, <code>valueOf</code>, etc. Here is a partial example of what you might see:</p> <pre><code>{\n  constructor: \u0192 Object(),\n  hasOwnProperty: \u0192 hasOwnProperty(),\n  isPrototypeOf: \u0192 isPrototypeOf(),\n  propertyIsEnumerable: \u0192 propertyIsEnumerable(),\n  toLocaleString: \u0192 toLocaleString(),\n  toString: \u0192 toString(),\n  valueOf: \u0192 valueOf()\n}\n</code></pre>","tags":["js"]},{"location":"blog/2024/05/21/exploring-objectprototype-in-javascript/#exploring-in-detail","title":"Exploring in Detail","text":"<p>You can also explore the prototype chain by accessing properties and methods directly in the console. For example:</p> <pre><code>console.log(Object.prototype.hasOwnProperty);\nconsole.log(Object.prototype.toString);\n</code></pre> <p>These methods belong to the <code>Object.prototype</code> and are inherited by all objects created in JavaScript unless explicitly overridden.</p>","tags":["js"]},{"location":"blog/2024/05/17/understanding-functional-state-updates-in-react-a-deep-dive-into-setselectedgroupdata/","title":"Understanding Functional State Updates in React: A Deep Dive into setSelectedGroupData","text":"","tags":["react","js"]},{"location":"blog/2024/05/17/understanding-functional-state-updates-in-react-a-deep-dive-into-setselectedgroupdata/#understanding-functional-state-updates-in-react-a-deep-dive-into-setselectedgroupdata","title":"Understanding Functional State Updates in React: A Deep Dive into <code>setSelectedGroupData</code>","text":"<p>When managing state in React, especially with complex objects, you often need to update just one part of the state without affecting the rest. A common pattern for this is the functional state update, which ensures your state changes are safe, predictable, and efficient.</p> <p>Let\u2019s break down the line of code:</p> <pre><code>setSelectedGroupData((prevData) =&gt; ({\n    ...prevData,\n    isReadUnread: updatedIsRead,\n}));\n</code></pre> What\u2019s Happening Here? <ol> <li> <p>Functional Update:</p> <p>The function passed to <code>setSelectedGroupData</code> receives the previous state (<code>prevData</code>) as an argument. This approach is particularly useful when your new state depends on the previous one, preventing potential bugs caused by asynchronous state updates.</p> </li> <li> <p>Immutability with the Spread Operator:</p> <p>The spread operator (<code>...prevData</code>) is used to create a shallow copy of the current state. In React, state is immutable\u2014meaning you shouldn't modify it directly. By copying the existing state into a new object, you preserve immutability, which is crucial for React to efficiently detect changes and trigger re-renders.</p> </li> <li> <p>Merging State:</p> <p>After copying the old state, the <code>isReadUnread</code> property is updated with a new value (<code>updatedIsRead</code>). This process ensures that only this specific property is changed, while all other properties remain intact.</p> </li> </ol> Why Use This Pattern? <ul> <li>Avoiding Bugs: Functional updates ensure that your state is always based on the most current data, avoiding potential race conditions.</li> <li>Performance: By only changing the necessary parts of the state, React can optimize re-renders, leading to better performance.</li> <li>Readability: This pattern makes it clear which parts of the state are being updated, making your code easier to understand and maintain.</li> </ul>","tags":["react","js"]},{"location":"blog/2024/05/17/understanding-functional-state-updates-in-react-a-deep-dive-into-setselectedgroupdata/#conclusion","title":"Conclusion","text":"<p>Understanding and utilizing functional state updates in React is essential for building reliable and performant applications. By leveraging patterns like the one we've explored, you can ensure that your state management is both efficient and robust, paving the way for a smoother development process.</p>","tags":["react","js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/","title":"Handling Circular References in JavaScript: Avoiding 'TypeError: cyclic object value' in JSON.stringify","text":"","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify","title":"Handling Circular References in JavaScript: Avoiding 'TypeError: cyclic object value' in JSON.stringify","text":"<p>The TypeError: cyclic object value error typically occurs when trying to convert a JavaScript object that contains circular references into a JSON string. Circular references happen when an object references itself either directly or indirectly, creating an infinite loop that <code>JSON.stringify</code> cannot handle.</p> <p>Here's an example of a circular reference:</p> <pre><code>let obj = {};\nobj.self = obj;\nJSON.stringify(obj); // TypeError: cyclic object value\n</code></pre>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#how-to-solve-it","title":"How to Solve It","text":"<p>To solve this issue, you have a few options:</p> <ol> <li> <p>Remove Circular References:</p> <p>Manually ensure that your object does not have any circular references before calling <code>JSON.stringify</code>.</p> </li> <li> <p>Use a Custom Replacer Function:</p> <p>Use a replacer function with <code>JSON.stringify</code> to filter out circular references.</p> </li> <li> <p>Use a Library:</p> <p>Utilize a library designed to handle circular references, such as <code>circular-json</code>(deprecated) or <code>flatted</code>.</p> <pre><code>function getCircularReplacer() {\n    const seen = new WeakSet();\n    return (key, value) =&gt; {\n        if (typeof value === \"object\" &amp;&amp; value !== null) {\n            if (seen.has(value)) {\n                return;\n            }\n            seen.add(value);\n        }\n        return value;\n    };\n}\n\nJSON.stringify(obj, getCircularReplacer());\n</code></pre> Danger <pre><code>npm install circular-json\n</code></pre> <pre><code>const CircularJSON = require('circular-json');\nconst jsonString = CircularJSON.stringify(obj);\n</code></pre> <p>Or using flatted:</p> Success <pre><code>npm install flatted\n</code></pre> <pre><code>const { stringify, parse } = require('flatted');\nconst jsonString = stringify(obj);\n</code></pre> </li> </ol>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#example-solution","title":"Example Solution","text":"<p>Here is an example of using a custom replacer function to handle circular references:</p> <pre><code>const obj1 = {};\nconst obj2 = { obj1 };\nobj1.obj2 = obj2;\n\nfunction getCircularReplacer() {\n    const seen = new WeakSet();\n    return (key, value) =&gt; {\n        if (typeof value === \"object\" &amp;&amp; value !== null) {\n            if (seen.has(value)) {\n                return;\n            }\n            seen.add(value);\n        }\n        return value;\n    };\n}\n\nconst jsonString = JSON.stringify(obj1, getCircularReplacer());\nconsole.log(jsonString);\n</code></pre> <p>By using these methods, you can avoid the TypeError: cyclic object value error and successfully convert your object to a JSON string.</p>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#improvement","title":"Improvement","text":"Example1 Bug <pre><code>style={{\n    display: \"flex\",\n    justifyContent:\n    JSON.stringify(item?.userId)?.toUpperCase() === appUserIdUC\n        ? \"flex-end\"\n        : \"flex-start\",\n}}\n</code></pre> <p>is this correct way to stringify data</p> <p>Using <code>JSON.stringify</code> in this context is unnecessary and not the correct approach for comparing strings. Instead, you should directly compare the values after ensuring they are strings. Here's the corrected version:</p> Success <pre><code>style={{\n    display: \"flex\",\n    justifyContent: item?.userId?.toString().toUpperCase() === appUserIdUC\n        ? \"flex-end\"\n        : \"flex-start\",\n}}\n</code></pre> <p>Explanation:</p> <ul> <li>item?.userId?.toString().toUpperCase(): This ensures that <code>item?.userId</code> is converted to a string and transformed to uppercase for comparison.</li> <li>appUserIdUC: This is assumed to be already in uppercase format for comparison.</li> </ul> <p>This approach avoids unnecessary stringification and makes the code cleaner and more efficient.</p>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#when-to-use-jsonstringify","title":"When to use JSON,stringify","text":"<p>In this context, JSON.stringify might be necessary if selectedAttendees is an array or an object that needs to be sent as a string in the bodyPayload. However, if selectedAttendees is already a string or a primitive value, JSON.stringify is not needed.</p> <pre><code> const bodyPayload = {\n            companyId: selectedCompanyId,\n            circularPlanningTemplateId: selectedMenuItem,\n            remarks: values?.remarks,\n            ModeofCommunication: remarksData?.remarks,\n            attentionTo: JSON.stringify(selectedAttendees),\n            isactive: true,\n        }; \n</code></pre> <p>Here\u2019s how you can adjust it based on different scenarios:</p>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#if-selectedattendees-is-an-array-or-object","title":"If selectedAttendees is an Array or Object:","text":"<p>If <code>selectedAttendees</code> is an array or object and you need to send it as a JSON string, your current approach is correct.</p> <pre><code>const bodyPayload = {\n    companyId: selectedCompanyId,\n    circularPlanningTemplateId: selectedMenuItem,\n    remarks: values?.remarks,\n    ModeofCommunication: remarksData?.remarks,\n    attentionTo: JSON.stringify(selectedAttendees), // Correct if selectedAttendees is an array or object\n    isactive: true,\n};\n</code></pre>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#summary","title":"Summary","text":"<ul> <li>Use <code>JSON.stringify</code> if selectedAttendees is an array or object.</li> <li>Do not use <code>JSON.stringify</code> if selectedAttendees is already a string.</li> </ul> <p>This ensures that the bodyPayload is constructed correctly based on the type of selectedAttendees.</p>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#scenario-circular-references-in-nested-objects","title":"Scenario: Circular References in Nested Objects","text":"<p>Imagine you have a complex data structure representing a company with departments, and each department has a reference to the company, creating a circular reference.</p> <pre><code>// Define a company object\nconst company = {\n    name: \"TechCorp\",\n    departments: []\n};\n\n// Define a department object\nconst department = {\n    name: \"Engineering\",\n    company: company // Circular reference\n};\n\n// Add the department to the company's departments array\ncompany.departments.push(department);\n\n// Attempt to stringify the company object\ntry {\n    const jsonString = JSON.stringify(company);\n    console.log(jsonString);\n} catch (error) {\n    console.error(\"Error stringifying object:\", error);\n}\n</code></pre>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#explanation","title":"Explanation:","text":"<ul> <li> <p>Circular Reference: The <code>company</code> object contains a reference to the <code>department</code> object, which in turn has a reference back to the company object. This creates a circular reference.</p> </li> <li> <p>JSON.stringify: When you try to convert the <code>company</code> object to a JSON string using <code>JSON.stringify</code>, the process fails because <code>JSON.stringify</code> cannot handle circular references.</p> </li> </ul>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#handling-the-circular-reference","title":"Handling the Circular Reference","text":"<p>To avoid the TypeError: cyclic object value error, you can use a custom replacer function or a library like <code>circular-json</code> or <code>flatted</code>.</p>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#avoiding-circular-references","title":"Avoiding Circular References","text":"<p>To avoid circular references, you can use a custom serializer or a library like flatted to handle circular references:</p> <p>First, install <code>flatted</code>:</p> <pre><code>npm install flatted\n</code></pre> <p>Then update the component to use <code>flatted</code>:</p> <pre><code>import React, { useState, useEffect } from 'react';\nimport { stringify } from 'flatted';\n\nconst ExampleComponent = () =&gt; {\n  const [employee, setEmployee] = useState({\n    name: \"Eve\",\n    position: \"Software Engineer\",\n    department: {}\n  });\n\n  useEffect(() =&gt; {\n    // Creating a circular reference\n    const department = {\n        name: \"Engineering\",\n        employees: [employee]\n    };\n\n    setEmployee(prevEmployee =&gt; {\n        const updatedEmployee = { ...prevEmployee, department };\n        department.manager = updatedEmployee; // Adding circular reference\n        return updatedEmployee;\n    });\n\n    try {\n        // console.log(JSON.stringify(employee));\n        console.log(stringify(employee)); // Using flatted.stringify\n    } catch (error) {\n        console.error(\"Error: \", error.message);\n    }\n  }, [employee]);\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Employee Details&lt;/h1&gt;\n      &lt;p&gt;Name: {employee.name}&lt;/p&gt;\n      &lt;p&gt;Position: {employee.position}&lt;/p&gt;\n      &lt;p&gt;Department: {employee.department.name}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default ExampleComponent;\n</code></pre> <p>By using the flatted library, you can handle circular references safely and serialize your objects without encountering the <code>TypeError: cyclic object value</code>.</p>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#real-time-office-error","title":"Real-Time Office Error","text":"Danger circularTemplate.js<pre><code>const handleMenuClick = (e) =&gt; {\n    setSelectedMenuItem(e.key);\n    // error on dispatch e.key\n    dispatch(actionForGetCircularPlanningCompanyDtos(e.key))\n    setSelectedMenuItemTitle(e.item.props['value'])\n};\n\n\nconst columns = [\n    {\n        title: \"Attention to\",\n        key: \"attentionTo\",\n        render: (record) =&gt; {\n            //   try {\n            //     return JSON.parse(record?.attentionTo &amp;&amp; record?.attentionTo)\n            //       ?.map((x) =&gt; x.AttentionTo)\n            //       ?.join(\", \");\n            //   } catch (error) {\n            //     console.error(\"Error parsing JSON:\", error);\n            //   }\n\n            try {\n                const rawAttentionTo = record?.attentionTo;\n\n                if (typeof rawAttentionTo === 'string' &amp;&amp;\n                    rawAttentionTo.trim().startsWith('[') &amp;&amp;\n                    rawAttentionTo.trim().endsWith(']')) {\n\n                    const attentionToArray = JSON.parse(rawAttentionTo);\n\n                    if (Array.isArray(attentionToArray) &amp;&amp; attentionToArray.length &gt; 0) {\n                        return attentionToArray.map((x) =&gt; x.AttentionTo).join(\", \");\n                    }\n                }\n\n                return \"\";\n            } catch (error) {\n                console.error(\"Error parsing JSON:\", error);\n                return \"\";\n            }\n        }\n    }\n]\n\n&lt;Table dataSource={companyDtosData} columns={columns} loading={getCircularPlanningCompanyDtosLoading} /&gt;\n</code></pre> Success <pre><code>// UPDATED\nconst handleMenuClick = (id, title) =&gt; {\n    setSelectedMenuItem(id);\n    setSelectedMenuItemTitle(title)\n    if(!isEmpty(id))\n        dispatch(actionForGetCircularPlanningCompanyDtos(id))\n};\n\n// added\nconst utilFunc = (data) =&gt; {\n    if (!data) return [];\n\n    return data.map((item, index) =&gt; {\n        let parsedAttentionTo = [];\n        try {\n            if (typeof item.attentionTo === 'string') {\n                parsedAttentionTo = JSON.parse(item.attentionTo);\n            }\n        } catch (error) {\n            console.error(`Error parsing attentionTo for item at index ${index}:`, error);\n        }\n\n        return {\n            ...item,\n            attentionTo: parsedAttentionTo // Ensure the key matches your data structure\n        };\n    });\n};\n\n// updated\nuseEffect(() =&gt; {\n    if (getCircularPlanningCompanyDtosResp) {\n        console.log('Original Response: ', getCircularPlanningCompanyDtosResp);\n\n        // Call utilFunc to parse attentionTo and update state\n        const parsedData = utilFunc(getCircularPlanningCompanyDtosResp);\n        console.log('Parsed Data: ', parsedData);\n        setCompanyDtosData(parsedData);\n    }\n}, [getCircularPlanningCompanyDtosResp]);\n\n\n...\n&lt;Menu\n    // REMOVED\n    // onClick={handleMenuClick}\n    style={{ width: 256 }}\n    defaultSelectedKeys={['0']}\n    defaultOpenKeys={['sub1']}\n    mode=\"inline\"\n&gt;\n    {allCircularPlanningTemplateLoading ? &lt;Skeleton active /&gt; : templateData.map((item, index) =&gt; (\n        &lt;Menu.Item\n            key={item?.id}\n            value={item?.title}\n            // className=\"sidebars__menu--item\"\n            // ADDED\n            onClick={() =&gt; handleMenuClick(item?.id, item?.title)}\n            className={`sidebars__menu--item ${index % 2 === 0 ? 'even-row' : 'odd-row'}`}\n        &gt;\n            &lt;span&gt;{index + 1}. {item.title}&lt;/span&gt;\n        &lt;/Menu.Item&gt;\n    ))}\n&lt;/Menu&gt;\n</code></pre>","tags":["js"]},{"location":"blog/2024/05/23/handling-circular-references-in-javascript-avoiding-typeerror-cyclic-object-value-in-jsonstringify/#reference","title":"Reference","text":"<ul> <li>circular-json: deprecated</li> <li>flatted: sucessor of circular-json</li> </ul>","tags":["js"]},{"location":"blog/2024/05/12/handling-json-parsing-errors-in-javascript-a-practical-approach/","title":"Handling JSON Parsing Errors in JavaScript: A Practical Approach","text":"","tags":["react","js"]},{"location":"blog/2024/05/12/handling-json-parsing-errors-in-javascript-a-practical-approach/#handling-json-parsing-errors-in-javascript-a-practical-approach","title":"Handling JSON Parsing Errors in JavaScript: A Practical Approach","text":"<p>Parsing JSON strings in JavaScript can sometimes lead to unexpected errors, especially when dealing with data from various sources. One common error encountered is \"Unexpected token 's', 'string' is not valid JSON,\" indicating an issue with the input string. In this blog, we'll explore a practical approach to handle such errors effectively.</p>","tags":["react","js"]},{"location":"blog/2024/05/12/handling-json-parsing-errors-in-javascript-a-practical-approach/#understanding-the-problem","title":"Understanding the Problem","text":"<p>The error typically occurs when the input string is not a valid JSON format. For instance, when the input string is plain text or improperly formatted JSON, attempting to parse it will result in a syntax error. To address this, we need to ensure the input is a valid JSON string before parsing it.</p> <p>Bug</p> TypeError: cyclic object value in ReactTypeError: o is undefined <p>Error parsing JSON: SyntaxError: Unexpected token 's', \"string\" is not valid JSON</p> <ul> <li>Error \"Uncaught SyntaxError: Unexpected token with JSON.parse\"</li> <li>How to Fix SyntaxError: Unexpected token &lt; in JSON at position 0</li> <li>JavaScript TypeError \u2013 Cyclic object value</li> <li>TypeError: cyclic object value in React</li> </ul> <ul> <li>TypeError: Cannot read property '0' of undefined in react</li> </ul>","tags":["react","js"]},{"location":"blog/2024/05/12/handling-json-parsing-errors-in-javascript-a-practical-approach/#the-solution","title":"The Solution","text":"<p>To handle this issue, we can follow a structured approach:</p> <ol> <li> <p>Log the Raw Input:</p> <p>Inspect the raw input to understand its content.</p> </li> <li> <p>Check for Valid JSON:</p> <p>Ensure the input is a valid JSON string.</p> </li> <li> <p>Parse Safely:</p> <p>Parse the JSON string and handle any errors gracefully.</p> </li> </ol> <p>Example</p> explainclean code <pre><code>render: (record) =&gt; {\n    console.log(\"Record: \", record);\n\n    try {\n        const rawAttentionTo = record?.attentionTo;\n        console.log(\"Raw attentionTo: \", rawAttentionTo);\n\n        // Check if rawAttentionTo is a valid JSON string\n        if (typeof rawAttentionTo === 'string' &amp;&amp; \n            rawAttentionTo.trim().startsWith('[') &amp;&amp; \n            rawAttentionTo.trim().endsWith(']')) {\n\n            const attentionToArray = JSON.parse(rawAttentionTo);\n            console.log(\"Parsed Array: \", attentionToArray);\n\n            // Ensure the parsed value is an array and contains data\n            if (Array.isArray(attentionToArray) &amp;&amp; attentionToArray.length &gt; 0) {\n                return attentionToArray.map((x) =&gt; x.AttentionTo).join(\", \");\n            }\n        }\n\n        // Return a fallback value if attentionToArray is empty or not an array\n        return \"\";\n    } catch (error) {\n        console.error(\"Error parsing JSON:\", error);\n        return \"\"; // Return an empty string or a fallback value in case of error\n    }\n}\n</code></pre> <pre><code>render: (record) =&gt; {\n    try {\n        const rawAttentionTo = record?.attentionTo;\n\n        if (typeof rawAttentionTo === 'string' &amp;&amp; \n            rawAttentionTo.trim().startsWith('[') &amp;&amp; \n            rawAttentionTo.trim().endsWith(']')) {\n\n            const attentionToArray = JSON.parse(rawAttentionTo);\n\n            if (Array.isArray(attentionToArray) &amp;&amp; attentionToArray.length &gt; 0) {\n                return attentionToArray.map((x) =&gt; x.AttentionTo).join(\", \");\n            }\n        }\n\n        return \"\";\n    } catch (error) {\n        console.error(\"Error parsing JSON:\", error);\n        return \"\";\n    }\n}\n</code></pre>","tags":["react","js"]},{"location":"blog/2024/05/12/handling-json-parsing-errors-in-javascript-a-practical-approach/#why-this-approach-works","title":"Why This Approach Works","text":"<p>This approach works by ensuring that only valid JSON strings are parsed, preventing unexpected errors. By validating the input and handling errors gracefully, we ensure the application remains robust and user-friendly.</p>","tags":["react","js"]},{"location":"blog/2024/05/12/handling-json-parsing-errors-in-javascript-a-practical-approach/#conclusion","title":"Conclusion","text":"<p>Handling JSON parsing errors in JavaScript requires careful validation and error handling. By following the steps outlined above, you can effectively manage and debug JSON parsing issues, ensuring a smoother user experience. Whether you're dealing with data from APIs or other sources, this approach helps maintain the integrity and reliability of your application.</p>","tags":["react","js"]},{"location":"blog/2024/05/26/handling-multiple-api-calls-with-search-input-in-react-using-debouncing-and-axios/","title":"Handling Multiple API Calls with Search Input in React using Debouncing and Axios","text":"","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/26/handling-multiple-api-calls-with-search-input-in-react-using-debouncing-and-axios/#handling-multiple-api-calls-with-search-input-in-react-using-debouncing-and-axios","title":"Handling Multiple API Calls with Search Input in React using Debouncing and Axios","text":"<p>Handling multiple API calls in React when interacting with a search input requires careful management to ensure that the results are fetched in an efficient and user-friendly way. Several techniques and tools are available to manage multiple simultaneous API calls and handle issues like race conditions, debouncing, and performance optimization.</p> <p>Here are the techniques and tools you can use:</p>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/26/handling-multiple-api-calls-with-search-input-in-react-using-debouncing-and-axios/#1-debouncing","title":"1.  Debouncing","text":"<p>Debouncing is crucial to avoid making an API request on every keystroke in the search input. Instead, wait until the user has stopped typing for a short period (e.g., 300ms).</p> <p>Example:</p> <pre><code>import { useState, useEffect } from 'react';\nimport debounce from 'lodash.debounce';\n\nconst SearchComponent = () =&gt; {\n  const [query, setQuery] = useState('');\n  const [results, setResults] = useState([]);\n\n  const handleSearch = debounce(async (searchTerm) =&gt; {\n    if (searchTerm) {\n      const response1 = fetch(`https://api.example.com/search1?q=${searchTerm}`);\n      const response2 = fetch(`https://api.example.com/search2?q=${searchTerm}`);\n\n      const [result1, result2] = await Promise.all([response1, response2]);\n      const data1 = await result1.json();\n      const data2 = await result2.json();\n\n      // Combine results or handle them separately\n      setResults([...data1, ...data2]);\n    }\n  }, 300);\n\n  useEffect(() =&gt; {\n    handleSearch(query);\n  }, [query]);\n\n  return (\n    &lt;input \n      type=\"text\" \n      value={query} \n      onChange={(e) =&gt; setQuery(e.target.value)} \n      placeholder=\"Search...\"\n    /&gt;\n  );\n};\n</code></pre> <ul> <li>Tools: You can use libraries like <code>lodash.debounce</code> to debounce the search function.</li> <li>Why: This reduces unnecessary API calls and improves performance.</li> </ul>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/26/handling-multiple-api-calls-with-search-input-in-react-using-debouncing-and-axios/#2-cancelling-previous-requests-using-abortcontroller","title":"2.  Cancelling Previous Requests (Using AbortController)","text":"<p>When making multiple API calls, you should cancel the previous request if a new one is initiated, especially in scenarios like search inputs. This avoids race conditions where a slower previous call might overwrite a more recent one.</p> <pre><code>import { useState, useEffect } from 'react';\n\nconst SearchComponent = () =&gt; {\n  const [query, setQuery] = useState('');\n  const [results, setResults] = useState([]);\n\n  useEffect(() =&gt; {\n    const controller = new AbortController();\n    const signal = controller.signal;\n\n    const fetchData = async () =&gt; {\n      try {\n        const response1 = fetch(`https://api.example.com/search1?q=${query}`, { signal });\n        const response2 = fetch(`https://api.example.com/search2?q=${query}`, { signal });\n      }\n    }\n  })\n}\n</code></pre>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/26/handling-multiple-api-calls-with-search-input-in-react-using-debouncing-and-axios/#key-tools-and-techniques","title":"Key Tools and Techniques:","text":"<ul> <li>AbortController: For canceling ongoing API requests when a new request is made.</li> <li>Axios: To handle the HTTP requests with cancellation support.</li> <li>Lodash Debounce: To optimize API calls during search input.</li> <li>Promise.all: To handle multiple concurrent API calls.</li> </ul>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/13/history-api/","title":"History API","text":"","tags":["react","js"]},{"location":"blog/2024/05/13/history-api/#history-api","title":"History API","text":"<p>The History API in JavaScript provides methods to manipulate the browser's history stack programmatically. This allows developers to navigate back and forth between different states of the application without reloading the page. This API is particularly useful in single-page applications (SPAs) and web applications that dynamically load content without full page refreshes.</p> <p>The History interface of the History API allows manipulation of the browser session history, that is the pages visited in the tab or frame that the current page is loaded in.</p>","tags":["react","js"]},{"location":"blog/2024/05/13/history-api/#importance-of-history-api","title":"Importance of History API:","text":"<ul> <li> <p>Enhanced User Experience: Allows smoother navigation within an application without reloading the entire page, which can improve perceived performance and user experience.</p> </li> <li> <p>State Management: Enables saving and managing application state in the browser history, making it possible to bookmark or share specific states of the application.</p> </li> <li> <p>SEO Benefits: Helps in building SPAs that can still have SEO-friendly URLs and states, as the application can update the URL without reloading the page.</p> </li> </ul>","tags":["react","js"]},{"location":"blog/2024/05/13/history-api/#when-to-use-the-history-api","title":"When to Use the History API:","text":"<ul> <li> <p>Single-Page Applications (SPAs): When building applications where page transitions and state changes occur without full page reloads.</p> </li> <li> <p>Enhancing Navigation: When you want to enable back and forward navigation within your application's states or pages.</p> </li> <li> <p>Managing Application State: When you need to manage and update the browser URL to reflect different states or sections of your application.</p> </li> </ul> <p>Tip</p> Instance propertiesInstance methods <ul> <li>length</li> <li>scrollRestoration</li> <li>state</li> </ul> <ul> <li>back()</li> <li>forward()</li> <li>go()</li> <li>pushState()</li> <li>replaceState()</li> </ul> <p>Example</p> <pre><code>// Adding a new state to the history\nhistory.pushState({ page: 'home' }, \"Home\", \"/\");\n\n// Handling popstate event to detect back/forward navigation\nwindow.onpopstate = function(event) {\nconsole.log('Navigated to state:', event.state);\n// Code to update UI based on the state object\n};\n</code></pre> <p>In this simple example:</p> <ul> <li>history.pushState() adds a new state to the history stack with the specified state object <code>({ page: 'home' })</code>, a title (\"Home\"), and URL (\"/\").</li> <li>window.onpopstate listens for back/forward navigation events (popstate), allowing you to handle these events and update your UI accordingly.</li> </ul>","tags":["react","js"]},{"location":"blog/2024/05/13/history-api/#reference","title":"Reference","text":"<ul> <li>History: mozilla</li> <li>Working_with_the_History_API: mozzila</li> <li>api-reference history :github</li> </ul>","tags":["react","js"]},{"location":"blog/2024/04/01/understanding-javascript-array-methods-mutating-vs-non-mutating/","title":"Understanding JavaScript Array Methods: Mutating vs. Non-Mutating","text":"","tags":["Programming"]},{"location":"blog/2024/04/01/understanding-javascript-array-methods-mutating-vs-non-mutating/#understanding-javascript-array-methods-mutating-vs-non-mutating","title":"Understanding JavaScript Array Methods: Mutating vs. Non-Mutating","text":"<p>When working with arrays in JavaScript, it's crucial to understand the distinction between mutating and non-mutating array methods. This differentiation plays a significant role in how arrays are manipulated and can greatly impact the behavior of your code.</p>","tags":["Programming"]},{"location":"blog/2024/04/01/understanding-javascript-array-methods-mutating-vs-non-mutating/#mutating-array-methods","title":"Mutating Array Methods:","text":"<p>Mutating array methods are those that modify the original array directly. They alter the array's contents in place, without creating a new array.</p> <p>Some commonly used mutating array methods include:</p> <ol> <li> <p><code>push()</code> and <code>pop()</code>: These methods add and remove elements from the end of the array, respectively.</p> </li> <li> <p><code>shift()</code> and <code>unshift()</code>: They add and remove elements from the beginning of the array, respectively.</p> </li> <li> <p><code>splice()</code>: This method can add, remove, or replace elements at any position within the array.</p> </li> <li> <p><code>sort()</code> and <code>reverse()</code>: These methods reorder the elements of the array.</p> </li> <li> <p><code>fill()</code> and <code>copyWithin()</code>: They modify elements within the array based on specified criteria.</p> </li> <li> <p><code>forEach()</code>: It iterates over each element of the array and allows you to perform actions on them.</p> </li> </ol>","tags":["Programming"]},{"location":"blog/2024/04/01/understanding-javascript-array-methods-mutating-vs-non-mutating/#non-mutating-array-methods","title":"Non-Mutating Array Methods:","text":"<p>Non-mutating array methods, on the other hand, do not modify the original array. Instead, they return a new array with the desired modifications, leaving the original array unchanged.</p> <p>Some common non-mutating array methods include:</p> <ol> <li> <p><code>concat()</code>:     This method combines two or more arrays and returns a new array.</p> </li> <li> <p><code>slice()</code>:     It returns a portion of the array without modifying the original array (returns a new array).</p> </li> <li> <p><code>filter()</code> and <code>map()</code>:     These methods create new arrays based on specific criteria or transformations applied to the original array's elements.</p> </li> <li> <p><code>reduce()</code> and <code>reduceRight()</code>:     They reduce the array to a single value based on a provided function.</p> </li> <li> <p><code>some()</code> and <code>every()</code>:     These methods check if certain conditions are met by at least one or all elements in the array, respectively.</p> </li> <li> <p><code>indexOf()</code> and <code>lastIndexOf()</code>:     They find the index of a specified element within the array.</p> </li> </ol> <p>Understanding the difference between <code>mutating</code> and <code>non-mutating</code> array methods is crucial for writing efficient and bug-free JavaScript code. Choosing the appropriate method based on your requirements can lead to cleaner, more maintainable code and prevent unintended side effects.</p>","tags":["Programming"]},{"location":"blog/2024/04/01/understanding-javascript-array-methods-mutating-vs-non-mutating/#conclusion","title":"Conclusion","text":"<p>In summary, mutating array methods directly modify the original array, while non-mutating array methods return a new array without altering the original one. By leveraging these methods effectively, you can harness the full power of JavaScript arrays in your projects.</p>","tags":["Programming"]},{"location":"blog/2024/05/15/javascript-arrow-functions/","title":"JavaScript Arrow Functions","text":"","tags":["js","arrow"]},{"location":"blog/2024/05/15/javascript-arrow-functions/#javascript-arrow-functions","title":"JavaScript Arrow Functions","text":"<p>Modern JavaScript introduced arrow functions as alternatives to regular functions. \u00adThere are two concepts you need to know about arrow functions.</p> <p>First, they use a dif\u00adfer\u00adent syntax than regular functions. Defining an arrow function is much quicker, requiring just a few characters and one line of code. The second impor\u00adt ant, but not so obvious, change is that they use something called a lexical scope, making them more intuitive and less error prone.</p>","tags":["js","arrow"]},{"location":"blog/2024/05/15/javascript-arrow-functions/#writing-arrow-functions","title":"Writing Arrow Functions","text":"<p>Instead of using the function keyword to declare an arrow function, we use the equal-to and greater-\u00adthan signs to form an arrow (=&gt;). This syntax, also called the fat arrow, reduces noise and results in more compact code.</p> <p>Therefore, modern JavaScript prefers this syntax when passing functions as arguments.</p> <p>In addition, if an arrow function has only one \u00adparameter and one statement, we can omit the curly brackets and the return keyword. In this compact form, we call the function a concise body function. Listing 2-10 shows the definition of a traditional function followed by an arrow function.</p> <pre><code>const traditional = function (x) {\n    return x * x;\n}\nconst conciseBody = x =&gt; x * x;\n</code></pre> <p>Listing 2-10: A traditional function and an arrow function with the concise body syntax </p> <p>We first define a standard function with the function keyword and familiar return statement. Then we write the same functionality as an arrow function with the concise body syntax. Here we omit the curly brackets and use an implied return statement, without the return keyword.</p>","tags":["js","arrow"]},{"location":"blog/2024/05/15/javascript-arrow-functions/#reference","title":"Reference","text":"<ul> <li>The complete developer by Martin Krause : pg-20</li> </ul>","tags":["js","arrow"]},{"location":"blog/2024/05/20/js-objects/","title":"JS objects","text":"","tags":["js"]},{"location":"blog/2024/05/20/js-objects/#js-objects","title":"JS objects","text":"<p>In JavaScript, every object inherits properties and methods from its prototype. The base object from which all other objects derive, Object.prototype, includes several built-in methods and properties that are fundamental to working with objects. Here are some of the most commonly used ones:</p> Built-ins PropertiesMethodsPrototypal Methods <ul> <li> <p>constructor</p> <ul> <li>Refers to the function that created the instance's prototype.</li> <li>Example: <code>obj.constructor</code></li> </ul> </li> <li> <p>proto</p> <ul> <li>Refers to the prototype of the object.</li> <li>Example: <code>obj.__proto__</code></li> </ul> </li> </ul> <ol> <li> <p>hasOwnProperty()</p> <ul> <li>Determines if an object has a property as its own (not inherited).</li> <li>Example: <code>obj.hasOwnProperty('propertyName')</code></li> </ul> </li> <li> <p>isPrototypeOf()</p> <ul> <li>Checks if an object exists in another object's prototype chain.</li> <li>Example: <code>prototypeObject.isPrototypeOf(obj)</code></li> </ul> </li> <li> <p>propertyIsEnumerable()</p> <ul> <li>Checks if a property is enumerable.</li> <li>Example: <code>obj.propertyIsEnumerable('propertyName')</code></li> </ul> </li> <li> <p>toString()</p> <ul> <li>Returns a string representation of the object.</li> <li>Example: <code>obj.toString()</code></li> </ul> </li> <li> <p>valueOf()</p> <ul> <li>Returns the primitive value of the specified object.</li> <li>Example: <code>obj.valueOf()</code></li> </ul> </li> <li> <p>toLocaleString()</p> <ul> <li>Returns a string representation of the object, localized according to the locale settings.</li> <li>Example: <code>obj.toLocaleString()</code></li> </ul> </li> </ol> <p>Static Methods</p> <ol> <li> <p>defineProperty() (added in ES5)</p> <ul> <li>Defines a new property directly on an object, or modifies an existing property on an object, and returns the object.</li> <li>Example: <code>Object.defineProperty(obj, 'newProp', { value: 42 })</code></li> </ul> </li> <li> <p>defineProperties() (added in ES5)</p> <ul> <li>Defines new or modifies existing properties directly on an object, returning the object.</li> <li>Example: <code>Object.defineProperties(obj, { 'prop1': { value: 42 }, 'prop2': { value: 43 } })</code></li> </ul> </li> <li> <p>getOwnPropertyDescriptor() (added in ES5)</p> <ul> <li>Returns a property descriptor for a named property on an object.</li> <li>Example: <code>Object.getOwnPropertyDescriptor(obj, 'propertyName')</code></li> </ul> </li> <li> <p>getOwnPropertyNames() (added in ES5)</p> <ul> <li>Returns an array of all properties (enumerable or not) found directly upon a given object.</li> <li>Example: <code>Object.getOwnPropertyNames(obj)</code></li> </ul> </li> <li> <p>keys() (added in ES5)</p> <ul> <li>Returns an array of a given object's own enumerable property names.</li> <li>Example: <code>Object.keys(obj)</code></li> </ul> </li> <li> <p>entries() (added in ES8)</p> <ul> <li>Returns an array of a given object's own enumerable string-keyed property [key, value] pairs.</li> <li>Example: <code>Object.entries(obj)</code></li> </ul> </li> <li> <p>values() (added in ES8)</p> <ul> <li>Returns an array of a given object's own enumerable property values.</li> <li>Example: <code>Object.values(obj)</code></li> </ul> </li> <li> <p>fromEntries() (added in ES10)</p> <ul> <li>Transforms a list of key-value pairs into an object.</li> <li>Example: <code>Object.fromEntries([['key1', 'value1'], ['key2', 'value2']])</code></li> </ul> </li> </ol> <p>JavaScript objects can also inherit methods from their prototypes. For example, arrays inherit methods from Array.prototype, strings from String.prototype, etc.</p> <p>Here's an example with arrays:</p> <ol> <li> <p>push()</p> <ul> <li>Adds one or more elements to the end of an array and returns the new length of the array.</li> <li>Example: <code>arr.push(element)</code></li> </ul> </li> <li> <p>pop()</p> <ul> <li>Removes the last element from an array and returns that element.</li> <li>Example: <code>arr.pop()</code></li> </ul> </li> <li> <p>map()</p> <ul> <li>Creates a new array populated with the results of calling a provided function on every element in the calling array.</li> <li>Example: <code>arr.map(function(element) { return element * 2; })</code></li> </ul> </li> </ol> <p>These are some of the core <code>methods</code> and <code>properties</code> that are built into JavaScript objects. The language also provides a robust set of methods and properties for specialized objects like <code>arrays</code>, <code>strings</code>, and <code>functions</code>.</p>","tags":["js"]},{"location":"blog/2024/05/20/js-objects/#prototype-constructor-methods","title":"Prototype &amp; Constructor Methods","text":"","tags":["js"]},{"location":"blog/2024/05/20/js-objects/#prototype-methods","title":"Prototype Methods","text":"<p>Prototype methods are defined on the constructor's prototype. All instances of the object share the same method.</p> <pre><code>function Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\n// Shared method (prototype method)\nPerson.prototype.sayHello = function() {\n  console.log('Hello, my name is ' + this.name);\n};\n\nlet person1 = new Person('Alice', 25);\nlet person2 = new Person('Bob', 30);\n\nperson1.sayHello(); // \"Hello, my name is Alice\"\nperson2.sayHello(); // \"Hello, my name is Bob\"\n\n// Both instances share the same sayHello method\nconsole.log(person1.sayHello === person2.sayHello); // true\n</code></pre> <p>In this example, <code>sayHello</code> is a prototype method, meaning <code>person1</code> and <code>person2</code> share the same <code>sayHello</code> method.</p>","tags":["js"]},{"location":"blog/2024/05/20/js-objects/#instance-specific-constructor-methods","title":"Instance-Specific (Constructor) Methods","text":"<p>Instance-specific methods are defined inside the constructor function. Each instance of the object will have its own copy of these methods.</p> <pre><code>function Person(name, age) {\n  this.name = name;\n  this.age = age;\n\n  // Instance-specific method (constructor method)\n  this.describe = function() {\n    console.log(this.name + ' is ' + this.age + ' years old.');\n  };\n}\n\nlet person1 = new Person('Alice', 25);\nlet person2 = new Person('Bob', 30);\n\nperson1.describe(); // \"Alice is 25 years old.\"\nperson2.describe(); // \"Bob is 30 years old.\"\n\n// Each instance has its own copy of describe\nconsole.log(person1.describe === person2.describe); // false\n</code></pre> <p>In this example, <code>describe</code> is a constructor method, meaning <code>person1</code> and <code>person2</code> each have their own copy of the describe method.</p>","tags":["js"]},{"location":"blog/2024/05/20/js-objects/#key-differences","title":"Key Differences","text":"<ul> <li> <p>Memory Efficiency:</p> <ul> <li>Constructor Methods: Each instance gets its own copy of the method, which can consume more memory.</li> <li>Prototype Methods: All instances share the same method, which is more memory-efficient.</li> </ul> </li> <li> <p>Usage:</p> <ul> <li>Constructor Methods: Use when each instance needs its own unique version of the method, often because the method relies on instance-specific data or state.</li> <li>Prototype Methods: Use when the method's behavior should be the same across all instances, to save memory and maintain consistency.</li> </ul> </li> </ul> Example <pre><code>function Person(name, age) {\n    this.name = name;\n    this.age = age;\n\n    // Instance-specific method (constructor method)\n    this.describe = function() {\n        console.log(this.name + ' is ' + this.age + ' years old.');\n    };\n}\n\n// Shared method (prototype method)\nPerson.prototype.sayHello = function() {\n    console.log('Hello, my name is ' + this.name);\n};\n\nlet person1 = new Person('Alice', 25);\nlet person2 = new Person('Bob', 30);\n\nperson1.describe(); // \"Alice is 25 years old.\"\nperson2.describe(); // \"Bob is 30 years old.\"\n\nperson1.sayHello(); // \"Hello, my name is Alice\"\nperson2.sayHello(); // \"Hello, my name is Bob\"\n\n// Each instance has its own copy of describe\nconsole.log(person1.describe === person2.describe); // false\n\n// Both instances share the same sayHello method\nconsole.log(person1.sayHello === person2.sayHello); // true\n</code></pre> <p>In this example:</p> <ul> <li><code>describe</code> is a constructor method, so each instance (<code>person1</code> and <code>person2</code>) has its own copy.</li> <li><code>sayHello</code> is a prototype method, so <code>person1</code> and <code>person2</code> share the same method.</li> </ul>","tags":["js"]},{"location":"blog/2024/05/20/js-objects/#terminology","title":"Terminology","text":"<p>Static methods and constructor methods are not the same in JavaScript. Let's delve into their differences with clear examples.</p>","tags":["js"]},{"location":"blog/2024/05/20/js-objects/#static-methods","title":"Static Methods","text":"<p>Static methods are methods defined on the constructor function itself. They are not available on instances of the constructor. Static methods are called directly on the constructor.</p> <pre><code>class Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n\n  // Static method\n  static compareAge(person1, person2) {\n    return person1.age - person2.age;\n  }\n}\n\nconst alice = new Person('Alice', 25);\nconst bob = new Person('Bob', 30);\n\n// Calling the static method on the constructor\nconsole.log(Person.compareAge(alice, bob)); // -5\n\n// Static method is not available on instances\nconsole.log(alice.compareAge); // undefined\n</code></pre> <p>In this example, <code>compareAge</code> is a static method defined on the <code>Person</code> constructor. It is called directly on <code>Person</code> and not on the instances (<code>alice</code> and <code>bob</code>).</p>","tags":["js"]},{"location":"blog/2024/05/20/js-objects/#constructor-methods-instance-methods","title":"Constructor Methods (Instance Methods)","text":"<p>Constructor methods are methods defined inside the constructor function. Each instance of the object will have its own copy of these methods.</p> <p>Constructor methods are defined inside the constructor function using this. They are specific to each instance of the object and are accessed through instances of the constructor.</p> <pre><code>class Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n\n    // Constructor method (instance method)\n    this.describe = function() {\n      console.log(`${this.name} is ${this.age} years old.`);\n    };\n  }\n}\n\nconst alice = new Person('Alice', 25);\nconst bob = new Person('Bob', 30);\n\n// Calling the constructor method on instances\nalice.describe(); // \"Alice is 25 years old.\"\nbob.describe(); // \"Bob is 30 years old.\"\n\n// Each instance has its own copy of describe\nconsole.log(alice.describe === bob.describe); // false\n</code></pre> <p>In this example, <code>describe</code> is a constructor method. Each instance (<code>alice</code> and <code>bob</code>) has its own copy of the <code>describe</code> method.</p>","tags":["js"]},{"location":"blog/2024/05/20/js-objects/#summary-of-differences","title":"Summary of Differences","text":"<ol> <li> <p>Definition and Availability:</p> <ul> <li>Static Methods: Defined on the constructor function itself. Available on the constructor, not on instances.</li> <li>Constructor Methods: Defined inside the constructor function. Each instance gets its own copy of the method.</li> </ul> </li> <li> <p>Calling:</p> <ul> <li>Static Methods: Called on the constructor itself.</li> <li>Constructor Methods: Called on instances of the constructor.</li> </ul> </li> </ol> Example Combining Both <pre><code>class Person {\n    constructor(name, age) {\n        this.name = name;\n        this.age = age;\n\n        // Constructor method\n        this.describe = function() {\n        console.log(`${this.name} is ${this.age} years old.`);\n        };\n    }\n\n    // Static method\n    static compareAge(person1, person2) {\n        return person1.age - person2.age;\n    }\n}\n\nconst alice = new Person('Alice', 25);\nconst bob = new Person('Bob', 30);\n\n// Calling the constructor method on instances\nalice.describe(); // \"Alice is 25 years old.\"\nbob.describe(); // \"Bob is 30 years old.\"\n\n// Calling the static method on the constructor\nconsole.log(Person.compareAge(alice, bob)); // -5\n\n// Static method is not available on instances\nconsole.log(alice.compareAge); // undefined\n\n// Each instance has its own copy of describe\nconsole.log(alice.describe === bob.describe); // false\n</code></pre> <p>In this example:</p> <ul> <li><code>compareAge</code> is a static method and is called on the Person constructor.</li> <li><code>describe</code> is a constructor method and is called on instances of Person.</li> </ul> how to know or check if it is contructor methods or static methods in javascript? <p>In JavaScript, whether a method is a constructor method (instance method) or a static method depends on where it is defined and how it is accessed. Here\u2019s how you can identify and distinguish between them:</p> Constructor Methods (Instance Methods)Static Methods <p>Constructor methods are defined inside the constructor function using this. They are specific to each instance of the object and are accessed through instances of the constructor.</p> <pre><code>class Person {\n    constructor(name, age) {\n        this.name = name;\n        this.age = age;\n\n        // Constructor method (instance method)\n        this.describe = function() {\n        console.log(`${this.name} is ${this.age} years old.`);\n        };\n    }\n}\n\nconst alice = new Person('Alice', 25);\n\n// Check if describe is a constructor method\nconsole.log(alice.describe); // function\n\n// Verify it's not available on the constructor itself\nconsole.log(Person.describe); // undefined\n</code></pre> <p>Static methods are defined on the constructor function directly using the static keyword. They are called on the constructor function itself, not on instances of the constructor.</p> <pre><code>class Person {\n    constructor(name, age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    // Static method\n    static compareAge(person1, person2) {\n        return person1.age - person2.age;\n    }\n}\n\nconst alice = new Person('Alice', 25);\n\n// Check if compareAge is a static method\nconsole.log(Person.compareAge); // function\n\n// Verify it's not available on instances of the constructor\nconsole.log(alice.compareAge); // undefined\n</code></pre> How to Identify Them <ul> <li> <p>Location of Definition:</p> <ul> <li>Constructor Methods: Defined inside the constructor function using this.</li> <li>Static Methods: Defined outside the constructor, prefixed with the static keyword within the class.</li> </ul> </li> <li> <p>Access Method:</p> <ul> <li>Constructor Methods: Accessed through instances of the constructor (<code>instance.method()</code>).</li> <li>Static Methods: Accessed directly on the constructor function itself (<code>Constructor.method()</code>).</li> </ul> </li> <li> <p>Usage:</p> <ul> <li>Constructor Methods: Typically used when each instance needs its own copy of the method, often to operate on instance-specific data.</li> <li>Static Methods: Used when the method does not depend on instance-specific data and is more utility-like, applying broadly to the constructor itself or its class.</li> </ul> </li> </ul> Checking in Practice <p>To check if a method is a constructor method or a static method in JavaScript:</p> <ol> <li> <p>Look at where the method is defined:</p> <ul> <li>Inside the constructor function (<code>this.method = function() {...}</code>): It\u2019s a constructor method.</li> <li>Using static keyword (<code>static methodName() {...}</code>): It\u2019s a static method.</li> </ul> </li> <li> <p>Verify how the method is accessed:</p> <ul> <li>Through instances (<code>instance.method()</code>): It\u2019s likely a constructor method.</li> <li>On the constructor itself (<code>Constructor.method()</code>): It\u2019s likely a static method.</li> </ul> </li> </ol> <p>By understanding these distinctions, you can effectively identify and differentiate between constructor methods and static methods in JavaScript classes.</p>","tags":["js"]},{"location":"blog/2024/05/20/js-objects/#reference","title":"Reference","text":"<ul> <li>multipart requests</li> <li>What does enctype='multipart/form-data' mean?</li> <li></li> </ul>","tags":["js"]},{"location":"blog/2024/05/28/order-of-operations-in-ant-design-forms-ensuring-proper-form-resetting/","title":"Order of Operations in Ant Design Forms: Ensuring Proper Form Resetting","text":"","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/28/order-of-operations-in-ant-design-forms-ensuring-proper-form-resetting/#order-of-operations-in-ant-design-forms-ensuring-proper-form-resetting","title":"Order of Operations in Ant Design Forms: Ensuring Proper Form Resetting","text":"<p>When working with forms in Ant Design, managing the state and interactions effectively is crucial for a smooth user experience. One common scenario involves resetting the form fields when a modal is closed. To achieve this successfully, understanding and applying the correct order of operations is essential.</p>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/28/order-of-operations-in-ant-design-forms-ensuring-proper-form-resetting/#why-order-of-operations-matters","title":"Why Order of Operations Matters","text":"<p>The order in which you execute operations can impact the behavior of your form. Specifically, if you're resetting the form fields when a modal closes, the sequence of operations matters because:</p> <ol> <li> <p>Reset Fields Before Closing Modal:</p> <p>To ensure that the form fields are cleared properly, you should call the <code>resetFields()</code> method before changing the modal visibility state. If you change the state first, the modal might close before the form has a chance to reset, leading to unexpected results.</p> </li> <li> <p>Avoid State Mismatch:</p> <p>Changing the modal state (e.g., setting <code>visible</code> to <code>false</code>) before resetting the form could lead to inconsistencies or race conditions where the form reset does not happen as expected.</p> </li> </ol>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/28/order-of-operations-in-ant-design-forms-ensuring-proper-form-resetting/#best-practices","title":"Best Practices","text":"<p>Here\u2019s a simple example illustrating the correct order of operations:</p> <pre><code>import React, { useState } from 'react';\nimport { Modal, Form, Input, Button } from 'antd';\n\nconst ExampleModal = () =&gt; {\n    const [form] = Form.useForm();\n    const [isModalVisible, setIsModalVisible] = useState(false);\n\n    const handleCloseModal = () =&gt; {\n        // Ensure fields are reset before hiding the modal\n        form.resetFields();\n        setIsModalVisible(false);\n    };\n\n    const handleOpenModal = () =&gt; {\n        setIsModalVisible(true);\n    };\n\n    const onFinish = (values) =&gt; {\n        console.log('Form values:', values);\n    };\n\n    return (\n        &lt;&gt;\n            &lt;Button type=\"primary\" onClick={handleOpenModal}&gt;\n                Open Modal\n            &lt;/Button&gt;\n            &lt;Modal\n                title=\"Example Modal\"\n                visible={isModalVisible}\n                onCancel={handleCloseModal}\n                footer={null}\n            &gt;\n                &lt;Form\n                    form={form}\n                    onFinish={onFinish}\n                &gt;\n                    &lt;Form.Item\n                        name=\"exampleField\"\n                        label=\"Example Field\"\n                        rules={[{ required: true, message: 'Please input a value!' }]}\n                    &gt;\n                        &lt;Input /&gt;\n                    &lt;/Form.Item&gt;\n                    &lt;Form.Item&gt;\n                        &lt;Button type=\"primary\" htmlType=\"submit\"&gt;\n                            Submit\n                        &lt;/Button&gt;\n                    &lt;/Form.Item&gt;\n                &lt;/Form&gt;\n            &lt;/Modal&gt;\n        &lt;/&gt;\n    );\n};\n\nexport default ExampleModal;\n</code></pre> Key Takeaways <ol> <li> <p>Reset Form Fields First: Always reset the form fields before updating the state that controls the modal\u2019s visibility. This ensures that the form is cleared properly before the modal closes.</p> </li> <li> <p>Consistent State Management: Keep the state management for form visibility and form data handling consistent to avoid unexpected behaviors.</p> </li> </ol> <p>By adhering to this order of operations, you can ensure a seamless user experience, with forms resetting as expected when modals are closed. This approach minimizes bugs and provides a predictable behavior for users interacting with your forms.</p>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/14/prettier-formatter-for-visual-studio-code/","title":"Prettier Formatter for Visual Studio Code","text":"","tags":["vscode","formatting"]},{"location":"blog/2024/05/14/prettier-formatter-for-visual-studio-code/#prettier-formatter-for-visual-studio-code","title":"Prettier Formatter for Visual Studio Code","text":"<p>Prettier is an opinionated code formatter. It enforces a consistent style by parsing your code and re-printing it with its own rules that take the maximum line length into account, wrapping code when necessary.</p> <p></p> <p></p>","tags":["vscode","formatting"]},{"location":"blog/2024/01/18/react-router-v6-guide/","title":"React Router v6 Guide","text":"","tags":["Programming"]},{"location":"blog/2024/01/18/react-router-v6-guide/#react-router-v6-guide","title":"React Router v6 Guide","text":"<p>React Router is a popular library for handling navigation and routing in React applications. It enables the creation of single-page applications (SPAs) by allowing developers to define the navigation structure of their applications, rendering different components based on the URL, and managing browser history.</p> <ol> <li> <p>Installation:</p> <p>Make sure you have React and React DOM installed, and then install React Router:</p> bash<pre><code>npm install react-router-dom\n</code></pre> </li> <li> <p>Basic Usage:</p> <p>Import necessary components:</p> jsx<pre><code>import { BrowserRouter as Router, Routes, Route, Link } from 'react-router-dom';\n</code></pre> <p>Wrap your application with the <code>Router</code> component:</p> jsx<pre><code>function App() {\n    return (\n        &lt;Router&gt;\n        &lt;Routes&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n        &lt;/Routes&gt;\n        &lt;/Router&gt;\n    );\n}\n</code></pre> </li> <li> <p>Nested Routes:</p> <p>You can nest Route components to create nested routes:</p> jsx<pre><code>function App() {\n    return (\n        &lt;Router&gt;\n        &lt;Routes&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/dashboard\" element={&lt;Dashboard /&gt;}&gt;\n            &lt;Route path=\"profile\" element={&lt;Profile /&gt;} /&gt;\n            &lt;Route path=\"settings\" element={&lt;Settings /&gt;} /&gt;\n            &lt;/Route&gt;\n        &lt;/Routes&gt;\n        &lt;/Router&gt;\n    );\n}\n</code></pre> </li> <li> <p>Route Parameters:</p> <p>You can capture parameters from the URL using <code>`:param</code> syntax:</p> jsx<pre><code>&lt;Route path=\"/user/:id\" element={&lt;UserProfile /&gt;} /&gt;\n</code></pre> <p>Access the parameter in the component:</p> jsx<pre><code>import { useParams } from 'react-router-dom';\n\nfunction UserProfile() {\nconst { id } = useParams();\n\n// Use the id parameter\n// ...\n}\n</code></pre> </li> <li> <p>Navigating Between Routes:</p> <p>Use the <code>Link</code> component for navigation:</p> jsx<pre><code>&lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n</code></pre> </li> <li> <p>Navigation Lifecycle Events:</p> <p>React Router v6 introduces the <code>useNavigate</code> hook for programmatic navigation:</p> jsx<pre><code>import { useNavigate } from 'react-router-dom';\n\nfunction MyComponent() {\nconst navigate = useNavigate();\n\nconst handleClick = () =&gt; {\n    // Navigate to a specific route\n    navigate('/new-route');\n};\n\n// ...\n}\n</code></pre> </li> <li> <p>Route Guards:</p> <p>Use the <code>useEffect</code> hook to guard against unauthorized access:</p> jsx<pre><code>import { useEffect } from 'react';\nimport { useNavigate } from 'react-router-dom';\n\nfunction PrivateRoute() {\nconst navigate = useNavigate();\n\nuseEffect(() =&gt; {\n    // Check if the user is authenticated\n    const isAuthenticated = // Your authentication logic here\n\n    if (!isAuthenticated) {\n    // Redirect to the login page\n    navigate('/login');\n    }\n}, [navigate]);\n\n// Render your private route content\nreturn &lt;div&gt;Private Route Content&lt;/div&gt;;\n}\n</code></pre> </li> <li> <p>Query Parameters:</p> <p>Access and manipulate query parameters using the <code>useSearchParams</code> hook:</p> jsx<pre><code>import { useSearchParams } from 'react-router-dom';\n\nfunction MyComponent() {\nconst [searchParams, setSearchParams] = useSearchParams();\n\n// Access and manipulate search parameters\nconst paramValue = searchParams.get('paramName');\nsetSearchParams({ paramName: 'newValue' });\n\n// ...\n}\n</code></pre> </li> <li> <p>Custom Route Matching:</p> <p>You can define custom route matching logic using the <code>path</code> prop and the <code>element</code> prop of the <code>Route</code> component:</p> jsx<pre><code>&lt;Route\n    path=\"/custom-route\"\n    element={&lt;CustomComponent /&gt;}\n    caseSensitive={true}\n/&gt;\n</code></pre> </li> <li> <p>Error Boundary for Routes:</p> <p>Wrap your route components with an error boundary:</p> jsx<pre><code>function ErrorBoundary() {\n    // Your error handling logic\n\n    return (\n        &lt;div&gt;\n        &lt;h1&gt;Something went wrong!&lt;/h1&gt;\n        &lt;/div&gt;\n    );\n}\n\n&lt;Route\n    path=\"/error-boundary\"\n    element={&lt;ErrorBoundary&gt;&lt;ErrorProneComponent /&gt;&lt;/ErrorBoundary&gt;}\n/&gt;\n</code></pre> </li> </ol> <p>This advanced guide covers some key concepts of React Router v6. Remember to refer to the official documentation for the most accurate and up-to-date information.</p>","tags":["Programming"]},{"location":"blog/2024/01/18/react-router-v6-guide/#reference","title":"Reference","text":"","tags":["Programming"]},{"location":"blog/2024/05/10/understanding-the-difference-between-response-object-and-parsed-data-object/","title":"Understanding the Difference Between Response Object and Parsed Data Object","text":"","tags":["js"]},{"location":"blog/2024/05/10/understanding-the-difference-between-response-object-and-parsed-data-object/#understanding-the-difference-between-response-object-and-parsed-data-object","title":"Understanding the Difference Between Response Object and Parsed Data Object","text":"<p>When working with APIs in JavaScript, particularly with the Fetch API, it's crucial to distinguish between the Response object and the parsed data object obtained from API responses. </p> <p>Here\u2019s a concise breakdown to clarify these concepts:</p>","tags":["js"]},{"location":"blog/2024/05/10/understanding-the-difference-between-response-object-and-parsed-data-object/#response-object","title":"Response Object","text":"<ul> <li>Definition: The Response object is provided by the Fetch API to represent the entire HTTP response received from an API endpoint.</li> <li>Contents: It includes metadata such as headers, status codes, and methods to access the response body (e.g., <code>.json()</code>, <code>.text()</code>).</li> <li>Type: When checking its type with <code>typeof</code>, it returns \"object\".</li> <li>Usage: You use the Response object to check the status of the request, access headers, and initiate methods to read and parse the response body content.</li> </ul>","tags":["js"]},{"location":"blog/2024/05/10/understanding-the-difference-between-response-object-and-parsed-data-object/#parsed-data-object","title":"Parsed Data Object","text":"<ul> <li>Definition: After parsing the response body using methods like <code>.json()</code> or <code>.text()</code> on the Response object, you obtain a parsed JavaScript object or string.</li> <li>Contents: This object represents the actual data content received from the API in a usable format within JavaScript.</li> <li>Type: When checking its type with <code>typeof</code>, it typically returns \"object\" (for JSON data) or \"string\" (for text data).</li> <li>Usage: It allows you to directly manipulate and use the data obtained from the API response within your application logic, such as rendering UI components or processing further.</li> </ul> <p>Example Scenario</p> javascript<pre><code>fetch('https://api.example.com/data')\n.then(response =&gt; {\n    if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    return response.json(); // Parse JSON response body\n})\n.then(data =&gt; {\n    // Response object\n    console.log(typeof response); // Outputs: \"object\"\n\n    // Parsed data object\n    console.log(typeof data); // Outputs: \"object\" (if parsed as JSON)\n\n    // Further process 'data' as needed\n    console.log(data); // Parsed JSON data object\n})\n.catch(error =&gt; {\n    console.error('Fetch error:', error);\n});\n</code></pre>","tags":["js"]},{"location":"blog/2024/05/10/understanding-the-difference-between-response-object-and-parsed-data-object/#conclusion","title":"Conclusion","text":"<p>Understanding the distinction between the Response object and the parsed data object is fundamental for effective API integration in JavaScript. The Response object encapsulates the entire HTTP response, while the parsed data object represents the meaningful content of that response in a format suitable for application logic. This clarity enables developers to handle API responses efficiently and leverage data seamlessly in their web applications.</p>","tags":["js"]},{"location":"blog/2024/01/29/understanding-the-impact-of-the-return-statement-in-javascripts-map-function/","title":"Understanding the Impact of the Return Statement in JavaScript's Map Function","text":""},{"location":"blog/2024/01/29/understanding-the-impact-of-the-return-statement-in-javascripts-map-function/#understanding-the-impact-of-the-return-statement-in-javascripts-map-function","title":"Understanding the Impact of the Return Statement in JavaScript's Map Function","text":"<p>In JavaScript, the <code>map</code> function is a powerful tool for transforming arrays by applying a function to each element. However, the presence or absence of the <code>return</code> statement within this function can significantly affect its behavior and the resulting output.</p> <p>Consider the following code snippet:</p> javascript<pre><code>const participantIds = test?.applicationTypeDetails?.tos?.map((item) =&gt; {\n  console.log(\"Ttos: \", item?.participantId);\n  return item?.participantId;\n});\n</code></pre> <p>In this snippet, <code>participantIds</code> is generated by mapping over the tos array, and for each item, we log \"Ttos: \" along with the participantId value. But crucially, we also use the <code>return</code> statement to explicitly specify that the <code>participantId</code> value should be included in the resulting array.</p> <p>Using the <code>return</code> statement ensures that each element processed by the <code>map</code> function contributes a specific value to the resulting array. This clarity is especially important when dealing with potentially <code>undefined</code> values, as it allows for consistent handling.</p> <p>However, if we were to omit the return statement, JavaScript would implicitly add <code>undefined</code> values to the resulting array for each item processed. While this may not always be desirable, it illustrates how the absence of the <code>return</code> statement impacts the function's behavior.</p>"},{"location":"blog/2024/01/29/understanding-the-impact-of-the-return-statement-in-javascripts-map-function/#conclusion","title":"Conclusion","text":"<p>In conclusion, the choice of using or not using the <code>return</code> statement within the <code>map</code> function depends on the desired outcome. Explicitly using return offers clarity and control over the resulting array, especially when dealing with potentially undefined values, while omitting it may lead to implicit <code>undefined</code> values being included in the output. Understanding this distinction empowers JavaScript developers to wield the <code>map</code> function effectively in their code.</p>"},{"location":"blog/2024/05/25/role-based-vs-permission-based-access-control-in-react/","title":"Role-Based vs Permission-Based Access Control in React","text":"","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/25/role-based-vs-permission-based-access-control-in-react/#role-based-vs-permission-based-access-control-in-react","title":"Role-Based vs Permission-Based Access Control in React","text":"Role-Based vs Permission-Based Access Control in React: Which is Better for Displaying Elements? <p>When deciding between permission-based or role-based access control (RBAC) for showing certain elements in a React application, both approaches have their pros and cons, depending on the complexity of your system. Here's a comparison to help decide which approach suits your needs:</p>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/25/role-based-vs-permission-based-access-control-in-react/#1-role-based-access-control-rbac","title":"1.  Role-Based Access Control (RBAC)","text":"<p>In RBAC, users are assigned roles, and each role has permissions to access certain features. For example, an \"Admin\" role might have access to more elements than a \"User\" role.</p> Pros: <ul> <li>Simpler to manage: Assign roles once, and permissions are derived from the role.</li> <li>Less configuration: You only need to define roles and check them, reducing complexity.</li> <li>Scalability: Easier to scale for smaller apps where roles are clearly defined (e.g., Admin, User, Guest).</li> </ul> Cons: <ul> <li>Limited granularity: You can't easily fine-tune permissions within roles (e.g., two Admins with different permissions).</li> </ul> <pre><code>const userRole = 'Admin'; // This would come from your state or API\n\nconst AdminElement = () =&gt; &lt;div&gt;Admin Content&lt;/div&gt;;\nconst UserElement = () =&gt; &lt;div&gt;User Content&lt;/div&gt;;\n\nreturn (\n  &lt;&gt;\n    {userRole === 'Admin' &amp;&amp; &lt;AdminElement /&gt;}\n    {userRole === 'User' &amp;&amp; &lt;UserElement /&gt;}\n  &lt;/&gt;\n);\n</code></pre>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/25/role-based-vs-permission-based-access-control-in-react/#2-permission-based-access-control","title":"2. Permission-Based Access Control","text":"<p>In permission-based control, users are granted individual permissions directly (e.g., \"canViewDashboard\", \"canEditProfile\"). Permissions are more granular and allow for fine-tuning access control.</p> Pros: <ul> <li>More flexibility: Permissions can be applied to specific features regardless of roles, allowing fine-grained control.</li> <li>Complex scenarios: Suitable for larger apps with multiple permission needs across various features.</li> </ul> Cons: <ul> <li>Harder to manage: Managing individual permissions for every feature can become complex, especially as the app grows.</li> <li>Overhead: More API calls and logic to check each specific permission.</li> </ul> <pre><code>const userPermissions = ['canViewDashboard', 'canEditProfile']; // Fetched from API or state\n\nconst DashboardElement = () =&gt; &lt;div&gt;Dashboard&lt;/div&gt;;\nconst EditProfileElement = () =&gt; &lt;div&gt;Edit Profile&lt;/div&gt;;\n\nreturn (\n  &lt;&gt;\n    {userPermissions.includes('canViewDashboard') &amp;&amp; &lt;DashboardElement /&gt;}\n    {userPermissions.includes('canEditProfile') &amp;&amp; &lt;EditProfileElement /&gt;}\n  &lt;/&gt;\n);\n</code></pre>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/25/role-based-vs-permission-based-access-control-in-react/#3-hybrid-approach","title":"3. Hybrid Approach:","text":"<p>Many systems use a hybrid of both methods, where roles define broad access and permissions are used for finer control.</p> <pre><code>const userRole = 'Admin';\nconst userPermissions = ['canViewSettings'];\n\nconst SettingsElement = () =&gt; &lt;div&gt;Settings&lt;/div&gt;;\n\nreturn (\n  &lt;&gt;\n    {userRole === 'Admin' &amp;&amp; userPermissions.includes('canViewSettings') &amp;&amp; &lt;SettingsElement /&gt;}\n  &lt;/&gt;\n);\n</code></pre> <p>This allows roles to handle major access control while permissions handle finer details.</p>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/25/role-based-vs-permission-based-access-control-in-react/#choosing-the-right-approach","title":"Choosing the Right Approach:","text":"<ul> <li>Small apps: If your app has a clear set of predefined roles (e.g., Admin, Editor, Viewer), role-based access control is simpler and faster to implement.</li> <li>Large apps or complex permission needs: For larger applications where users need fine-grained control over different features (e.g., granular permissions across multiple areas), permission-based control will be more flexible.</li> </ul>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/25/role-based-vs-permission-based-access-control-in-react/#in-summary","title":"In summary:","text":"<ul> <li>Role-based control is good for simplicity and clear boundaries.</li> <li>Permission-based control is good for complex systems with more granular needs.</li> </ul>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/25/role-based-vs-permission-based-access-control-in-react/#question","title":"Question","text":"<p>Access control is a critical aspect of web application security, ensuring that users only have access to the data and features they are authorized to use. There are several different types of access control mechanisms commonly used in web applications:</p> <ol> <li> <p>Role-Based Access Control (RBAC)</p> <p>In RBAC, access to resources and features is granted based on roles assigned to users. Each role has predefined permissions, and users are assigned roles depending on their responsibilities.</p> Characteristics: <ul> <li>Roles like \"Admin,\" \"Editor,\" and \"Viewer\" are created.</li> <li>Users are assigned one or more roles.</li> <li>Permissions are attached to roles, not individual users.</li> </ul> Example: <ul> <li>Admin can access all pages.</li> <li>Editor can modify content but not user settings.</li> <li>Viewer can only view content.</li> </ul> Common Use Cases: <ul> <li>Content Management Systems (CMS)</li> <li>Enterprise Resource Planning (ERP) systems</li> </ul> </li> <li> <p>Permission-Based Access Control</p> <p>In Permission-Based control, permissions are granted to individual users or groups based on specific actions, rather than roles. Permissions allow more fine-grained control, often granting access to individual resources or features.</p> Characteristics: <ul> <li>Users have explicit permissions like \"canViewDashboard\" or \"canEditProfile.\"</li> <li>Permissions are more granular and provide better flexibility.</li> </ul> Example: <ul> <li>A user might have permission to view the dashboard but not edit their profile.</li> </ul> Common Use Cases: <ul> <li>SaaS platforms with flexible access controls.</li> <li>Applications with complex permissions across features.</li> </ul> </li> <li> <p>Discretionary Access Control (DAC)</p> <p>In DAC, the owner of the data or resource decides who can access it. The access control decision is made based on user identity and group membership. The resource owner can modify permissions, granting or restricting access to other users.</p> Characteristics: <p>The owner (user or admin) has full control over the access rights of others. Flexible but potentially less secure than mandatory access control.</p> Example: <p>A file owner can choose who can read or edit their file.</p> Common Use Cases: <p>File-sharing systems. Personal data control in collaborative platforms.</p> </li> <li> <p>Mandatory Access Control (MAC)</p> <p>In MAC, access control policies are enforced by the system and are not controlled by individual users. The system assigns security labels to users and data, and access decisions are made based on these labels.</p> Characteristics: <ul> <li>Access is granted based on clearance levels.</li> <li>The system administrator defines the rules; users have no control over who can access the data.</li> </ul> <p>???+ example \"Example:</p> <pre><code>-   Classified government systems where access is based on security clearances (e.g., Confidential, Secret, Top Secret).\n</code></pre> Common Use Cases: <ul> <li>Military or governmental systems.</li> <li>High-security environments requiring strict controls.</li> </ul> </li> <li> <p>Attribute-Based Access Control (ABAC)</p> <p>In ABAC, access decisions are made based on user attributes (e.g., department, job title, location), resource attributes, and environmental conditions (e.g., time of day). It allows for highly dynamic and context-aware access control.</p> Characteristics: <ul> <li>Rules are based on attributes rather than predefined roles or permissions.</li> <li>Policies can specify who has access under certain conditions.</li> </ul> Example: <ul> <li>Only employees in the \"HR\" department can access employee records during office hours.</li> </ul> Common Use Cases: <ul> <li>Dynamic systems like cloud services or IoT systems.</li> <li>Systems requiring granular and context-aware access control.</li> </ul> </li> <li> <p>Identity-Based Access Control (IBAC)</p> <p>In IBAC, access is determined by the individual identity of the user. Each user has specific access to certain resources based on their personal identification.</p> Characteristics: <ul> <li>Personalized access control for each user.</li> <li>Access control decisions are made based on the user's identity.</li> </ul> Example: <ul> <li>A specific user has access to their own documents but not others'.</li> </ul> Common Use Cases: <ul> <li>Personalized dashboards.</li> <li>Applications where each user manages their own data.</li> </ul> </li> <li> <p>Token-Based Access Control (e.g., OAuth, JWT)</p> <p>Token-Based Access Control is widely used in modern web applications where users are authenticated via tokens (like JWT). The token carries information about the user\u2019s permissions and is used to verify access.</p> Characteristics: <ul> <li>Stateless authentication where tokens are passed with each request.</li> <li>Can be used for Single Sign-On (SSO) and third-party API access.</li> </ul> Example: <ul> <li>OAuth tokens grant access to resources on behalf of users.</li> <li>JWT tokens are used to authenticate and authorize users in a web app.</li> </ul> Common Use Cases: <ul> <li>RESTful APIs.</li> <li>Single Sign-On (SSO) systems.</li> </ul> </li> <li> <p>Context-Based Access Control (CBAC)</p> <p>In CBAC, access control is based on the context of the request, including factors like the user's location, device, and time of access.</p> Characteristics: <ul> <li>Highly dynamic access control, taking into account external factors.</li> <li>Context can change access permissions in real time.</li> </ul> Example: <ul> <li>A user can access a system only during working hours and from an approved device.</li> </ul> Common Use Cases: <ul> <li>Enterprise systems with location and time-based access controls.</li> <li>IoT systems with real-time environmental conditions.</li> </ul> </li> <li> <p>Rule-Based Access Control</p> <p>Rule-Based Access Control defines access rules that the system follows. These rules determine who has access to which resources and under what conditions.</p> Characteristics: <ul> <li>Rules are predefined based on specific conditions.</li> <li>Offers flexibility, as rules can be customized for various situations.</li> </ul> Example: <ul> <li>A user can access a report if they have completed a mandatory training course.</li> </ul> Common Use Cases: <ul> <li>Automated systems requiring complex rules.</li> <li>Security systems with specific conditional access requirements.</li> </ul> </li> </ol> Conclusion: <ul> <li>RBAC is simple and widely used for role-based access across different user types.</li> <li>Permission-Based control offers more flexibility with finer control over resources.</li> <li>ABAC is best for dynamic, attribute-driven environments like cloud or IoT.</li> <li>Token-Based control is essential for stateless systems and API access.</li> </ul> <p>Choose the model based on the complexity and security needs of your application!</p> <pre><code>Summary\n\nRBAC: Based on roles.\nPermission-Based: Based on specific permissions.\nDAC: Resource owners define access.\nMAC: System-enforced access policies.\nABAC: Based on attributes like department or time.\nIBAC: Based on user identity.\nToken-Based: Uses tokens (e.g., JWT) for stateless authentication.\nCBAC: Access based on context like location or time.\nRule-Based: Rules define access criteria.\n</code></pre>","tags":["databse","django","postgresql"]},{"location":"blog/2024/05/19/saving-base64-data-into-an-excel-file-in-a-react-application/","title":"Saving base64 data into an Excel file in a React application","text":"","tags":["react","base64"]},{"location":"blog/2024/05/19/saving-base64-data-into-an-excel-file-in-a-react-application/#saving-base64-data-into-an-excel-file-in-a-react-application","title":"Saving base64 data into an Excel file in a React application","text":"<p>To save base64 data into an Excel file in a React application, you can use the FileSaver library to handle the file download and the xlsx library to convert the base64 data into a format that can be saved as an Excel file.</p> <p>Here's a step-by-step guide on how to do this:</p> <ol> <li> <p>Install the necessary libraries:</p> <pre><code>npm install file-saver xlsx\n</code></pre> </li> <li> <p>Create a function to handle the download:</p> <pre><code>import { saveAs } from 'file-saver';\nimport * as XLSX from 'xlsx';\n\nconst saveBase64AsExcel = (base64Data, fileName) =&gt; {\n    // Convert base64 string to ArrayBuffer\n    const binaryString = window.atob(base64Data);\n    const len = binaryString.length;\n    const bytes = new Uint8Array(len);\n    for (let i = 0; i &lt; len; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n    }\n    const blob = new Blob([bytes], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });\n\n    // Use FileSaver to save the file\n    saveAs(blob, fileName);\n    };\n\n    // Example usage\n    const handleDownload = () =&gt; {\n    if (isDownloadStatus) {\n        let data = 'your_base64_data_here'; // Replace with your actual base64 data\n        saveBase64AsExcel(data, 'example.xlsx');\n    }\n};\n</code></pre> </li> <li> <p>Call the <code>handleDownload</code> function when you need to trigger the download:</p> <pre><code>import React from 'react';\n\nconst YourComponent = () =&gt; {\n    return (\n        &lt;div&gt;\n        &lt;button onClick={handleDownload}&gt;Download Excel&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default YourComponent;\n</code></pre> <p>This code snippet shows how to convert base64-encoded data into an <code>ArrayBuffer</code>, create a Blob from it, and use the <code>FileSaver</code> library to download it as an Excel file. You can replace 'your_base64_data_here' with your actual base64 data variable.</p> <p>Remember to import and use handleDownload in your component as shown in the example. This should allow you to download the base64 data as an Excel file when <code>isDownloadStatus</code> is true.</p> </li> </ol>","tags":["react","base64"]},{"location":"blog/2024/04/23/formsetfieldsvalue-vs-defaultvalue-in-react/","title":"form.setFieldsValue vs defaultValue in react","text":""},{"location":"blog/2024/04/23/formsetfieldsvalue-vs-defaultvalue-in-react/#formsetfieldsvalue-vs-defaultvalue-in-react","title":"form.setFieldsValue <code>vs</code> defaultValue in react","text":"<p>Whether to set the default value using form.setFieldsValue or by using the defaultValue prop in <code>&lt;Select&gt;</code> depends on your specific use case and preference.</p> <p>Here's a breakdown of each approach:</p> <ol> <li> <p>Setting Default Value with <code>form.setFieldsValue</code>:</p> <p>Tip</p> jsx<pre><code>import { useEffect } from 'react';\nimport { Form, Select } from 'antd';\n\nconst YourComponent = ({ form, details, remainingLeaveApplicationTypesListing }) =&gt; {\n    useEffect(() =&gt; {\n        form.setFieldsValue({\n            leaveApplicationTypeId: details?.leaveApplicationTypeDto?.id\n        });\n    }, [form, details]);\n\n    return (\n        &lt;Form form={form}&gt;\n            &lt;Form.Item name=\"leaveApplicationTypeId\"&gt;\n                &lt;Select\n                    placeholder=\"Please select\"\n                    autoComplete=\"off\"\n                    // Define a function to handle selection changes\n                    onChange={(value) =&gt; handleSelect(value)}\n                &gt;\n                    {!isEmpty(remainingLeaveApplicationTypesListing) &amp;&amp;\n                    remainingLeaveApplicationTypesListing.map((leaveType, i) =&gt; (\n                        &lt;Select.Option\n                            value={leaveType.leaveApplicationTypeId}\n                            title={leaveType?.leaveApplicationTypeDto?.leaveTypeName}\n                            key={i}\n                        &gt;\n                            {leaveType?.leaveApplicationTypeDto?.leaveTypeName}\n                        &lt;/Select.Option&gt;\n                    ))}\n                &lt;/Select&gt;\n            &lt;/Form.Item&gt;\n        &lt;/Form&gt;\n    );\n};\n</code></pre> <p>With this approach, the default value is set programmatically using form.setFieldsValue inside a useEffect hook. This allows you to set the default value dynamically based on the details object. </p> <p>This approach is suitable when you need to calculate the default value or when the default value depends on asynchronous data fetching.</p> </li> <li> <p>Setting Default Value with <code>defaultValue</code> prop:</p> <p>Tip</p> jsx<pre><code>&lt;Select\n    placeholder=\"Please select\"\n    autoComplete=\"off\"\n    // Set the default value\n    defaultValue={details?.leaveApplicationTypeDto?.id}\n    // Define a function to handle selection changes\n    onChange={(value) =&gt; handleSelect(value)}\n&gt;\n    {!isEmpty(remainingLeaveApplicationTypesListing) &amp;&amp;\n        remainingLeaveApplicationTypesListing.map((leaveType, i) =&gt; (\n            &lt;Select.Option\n                value={leaveType.leaveApplicationTypeId}\n                title={leaveType?.leaveApplicationTypeDto?.leaveTypeName}\n                key={i}\n            &gt;\n                {leaveType?.leaveApplicationTypeDto?.leaveTypeName}\n            &lt;/Select.Option&gt;\n        ))}\n&lt;/Select&gt;\n</code></pre> <p>With this approach, you directly set the default value using the defaultValue prop of the <code>&lt;Select&gt;</code> component. </p> <p>This approach is simpler and more straightforward when you have a static default value or when the default value doesn't depend on other factors.</p> </li> </ol>"},{"location":"blog/2024/04/23/formsetfieldsvalue-vs-defaultvalue-in-react/#which-approach-to-choose","title":"Which Approach to Choose:","text":"<ul> <li>If the default value depends on dynamic data or needs to be calculated based on other state/props, using <code>form.setFieldsValue</code> inside a <code>useEffect</code> hook is more appropriate.</li> <li>If the default value is static or doesn't depend on other factors, using the <code>defaultValue</code> prop directly in the <code>&lt;Select&gt;</code> component is simpler and cleaner.</li> </ul>"},{"location":"blog/2024/05/22/unveiling-static-and-prototype-methods-in-javascript-built-in-objects/","title":"Unveiling Static and Prototype Methods in JavaScript Built-in Objects","text":"","tags":["js"]},{"location":"blog/2024/05/22/unveiling-static-and-prototype-methods-in-javascript-built-in-objects/#unveiling-static-and-prototype-methods-in-javascript-built-in-objects","title":"Unveiling Static and Prototype Methods in JavaScript Built-in Objects","text":"<p>To thoroughly understand and see the static methods and constructor methods in JavaScript built-in objects, you can use a combination of developer tools, documentation, and JavaScript code. Here\u2019s a detailed guide:</p>","tags":["js"]},{"location":"blog/2024/05/22/unveiling-static-and-prototype-methods-in-javascript-built-in-objects/#1-using-developer-tools","title":"1. Using Developer Tools","text":"<p>In a Browser Console</p> <ol> <li>Open Developer Tools: You can usually open this by pressing <code>F12</code>, <code>Ctrl+Shift+I</code>, or <code>Cmd+Option+I</code>.</li> <li>Go to the Console Tab: Here you can execute JavaScript code.</li> </ol>","tags":["js"]},{"location":"blog/2024/05/22/unveiling-static-and-prototype-methods-in-javascript-built-in-objects/#viewing-static-methods","title":"Viewing Static Methods","text":"<p>Static methods are functions that are called on the class itself, not on instances of the class. For example, <code>Array.from()</code> is a static method on the <code>Array</code> constructor.</p> <pre><code>console.dir(Array);\nconsole.dir(Object);\nconsole.dir(Math);\n</code></pre>","tags":["js"]},{"location":"blog/2024/05/22/unveiling-static-and-prototype-methods-in-javascript-built-in-objects/#viewing-constructor-methods","title":"Viewing Constructor Methods","text":"<p>Constructor methods (or prototype methods) are functions that are available on the instances of the objects. For example, <code>Array.prototype.push()</code> is a constructor method.</p> <pre><code>console.dir(Array.prototype);\nconsole.dir(Object.prototype);\n</code></pre>","tags":["js"]},{"location":"blog/2024/05/22/unveiling-static-and-prototype-methods-in-javascript-built-in-objects/#2-using-javascript-code","title":"2. Using JavaScript Code","text":"","tags":["js"]},{"location":"blog/2024/05/22/unveiling-static-and-prototype-methods-in-javascript-built-in-objects/#list-all-static-methods-and-properties","title":"List All Static Methods and Properties","text":"<p>To list all static methods and properties of a built-in object, you can use the following code snippet:</p> <pre><code>function listStaticMethods(obj) {\n  return Object.getOwnPropertyNames(obj).filter(prop =&gt; typeof obj[prop] === 'function');\n}\n\nconsole.log(listStaticMethods(Array)); // List static methods of Array\nconsole.log(listStaticMethods(Object)); // List static methods of Object\nconsole.log(listStaticMethods(Math));   // List static methods of Math\n</code></pre>","tags":["js"]},{"location":"blog/2024/05/22/unveiling-static-and-prototype-methods-in-javascript-built-in-objects/#list-all-prototype-methods","title":"List All Prototype Methods","text":"<p>To list all prototype methods of a built-in object, you can use the following code snippet:</p> <pre><code>function listPrototypeMethods(obj) {\n  return Object.getOwnPropertyNames(obj.prototype).filter(prop =&gt; typeof obj.prototype[prop] === 'function');\n}\n\nconsole.log(listPrototypeMethods(Array)); // List prototype methods of Array\nconsole.log(listPrototypeMethods(Object)); // List prototype methods of Object\n</code></pre>","tags":["js"]},{"location":"blog/2024/05/22/unveiling-static-and-prototype-methods-in-javascript-built-in-objects/#3-consulting-documentation","title":"3. Consulting Documentation","text":"<p>Refer to the official JavaScript documentation for comprehensive details on built-in objects, their static methods, and prototype methods:</p> <ul> <li> <p>MDN Web Docs: This is a highly recommended resource for in-depth information on JavaScript built-in objects. For example:</p> </li> <li> <p>Array</p> </li> <li>Object</li> <li>Math</li> </ul> Example Output <p>When you run the provided code snippets, you will get lists of methods:</p> <p>Static Methods of Array:</p> <pre><code>[\"from\", \"isArray\", \"of\"]\n</code></pre> <p>Prototype Methods of Array:</p> <pre><code>[\"constructor\", \"copyWithin\", \"fill\", \"find\", \"findIndex\", \"keys\", \"entries\", \"values\", \"pop\", \"push\", \"concat\", \"join\", \"reverse\", \"shift\", \"unshift\", \"slice\", \"splice\", \"sort\", \"indexOf\", \"lastIndexOf\", \"every\", \"some\", \"forEach\", \"map\", \"filter\", \"reduce\", \"reduceRight\", \"includes\", \"flat\", \"flatMap\", \"at\", \"toLocaleString\", \"toString\", \"length\"]\n</code></pre> <p>By using these methods, you can thoroughly explore and understand the static and prototype methods available in JavaScript <code>built-in</code> objects.</p>","tags":["js"]},{"location":"blog/2024/05/24/useful-react-libraries-for-projects/","title":"Useful React Libraries for Projects","text":"","tags":["postman","http"]},{"location":"blog/2024/05/24/useful-react-libraries-for-projects/#useful-react-libraries-for-projects","title":"Useful React Libraries for Projects","text":"<p>Pdf</p>","tags":["postman","http"]},{"location":"blog/2024/05/24/useful-react-libraries-for-projects/#loadash","title":"loadash","text":"<pre><code>import { uniqBy } from 'lodash';\n\nconst recentlyUsedTags = [\n  { code: \"AFL-asdasdasaggdfgdfg\", id: \"45f3d5c0-6e3e-4d24-b9e6-f960845c9c0d\" },\n  { code: \"AFL-asdasdasaggdfgdfg\", id: \"45f3d5c0-6e3e-4d24-b9e6-f960845c9c0d\" }\n];\n\nconst otherReferenceDtos = [\n  { code: \"BFL-sdfdsfsdfsdffsd\", id: \"23d4c5a0-7e2f-5d25-b7a6-f234512d4b4d\" },\n  { code: \"AFL-asdasdasaggdfgdfg\", id: \"45f3d5c0-6e3e-4d24-b9e6-f960845c9c0d\" }\n];\n\nconst combinedArray = [...recentlyUsedTags, ...otherReferenceDtos];\n\nconst uniqueArray = uniqBy(combinedArray, 'id');\n\nsetFilterReference(uniqueArray);\n</code></pre> <ul> <li>Top 10 JavaScript Libraries To Use in 2024 </li> <li>js-utility-libraries</li> </ul> <ul> <li>pip install mkdocs-pdf</li> <li>mkdocs-pdf: pypi</li> <li>How to link a pdf</li> <li></li> <li>How to Import SVGs in a React and Vite app</li> <li>How to display svg icons(.svg files) in UI using React Component?: slackoverflow</li> <li>How to use SVGs in React</li> </ul>","tags":["postman","http"]},{"location":"frontend/js/intro/","title":"Intro","text":"<p>What\u2019s in a name?</p> <p>The name JavaScript was chosen to take advantage of the popularity of Java \u2013 just as a marketing ploy! Its first name was Mocha, then, LiveScript, and only then JavaScript.</p>"},{"location":"frontend/js/intro/#fp-and-other-programming-paradigms","title":"FP and other programming paradigms","text":"<p>Programming paradigms classify programming languages according to their features. </p> <p>However, some languages may be classified into multiple paradigms \u2013 as is the case of JavaScript itself!</p> <p>A primary division is imperative versus declarative languages. In the former, developers must instruct the machine on how to do its work, step by step. </p> <p>Programming may be procedural (if instructions are grouped into procedures) or object-oriented (if instructions are grouped with a related state).</p> <p>In declarative languages, in opposition, developers just declare properties that the sought result must satisfy, but not how to calculate it. Declarative languages may be logic-based (based on logic rules and constraints), reactive (based on data and event streams), or functional (based on the application and combination of functions). </p> <p>In a sense, we could say that imperative languages focus on how, while declarative languages focus on what.</p> <p>JavaScript is multi-paradigm: it\u2019s imperative (both procedural and object-oriented) but also allows declarative programming, both functional (like almost everything in this book! In particular, we will devote Chapter 5, Programming Declaratively, to this topic) and reactive (we\u2019ll see reactive FP in Chapter 11, Implementing Design Patterns).</p>"},{"location":"frontend/js/intro/#reference","title":"Reference","text":"<ul> <li>Mastering JavaScript Functional Programming Third Edition by Federico Kereki</li> </ul>"},{"location":"frontend/js/core/api-response-object/","title":"Response Object","text":"when we fetch the api endpoint, the reponse data is in which format do we get? object or string <p>When you fetch data from an API endpoint, the response data is typically received as a <code>string</code>. This string needs to be parsed into an object to be usable within your application.</p> Is the json response format is <code>object</code> or <code>string</code> ? <p>When you receive a JSON response from an API, the data is initially received as a string. This string represents the JSON data. To work with this data as a JavaScript object, you need to parse the JSON string into an object.</p> <p>Here's a detailed explanation:</p> so what is the difference between <code>.json()</code> method and <code>JSON.parse</code> when to use. is it the same <p>The <code>.json()</code> method and <code>JSON.parse()</code> serve similar purposes but are used in different contexts. Here's a breakdown of the differences and when to use each:</p> <code>.json()</code> MethodJSON.parse()Key Differences <ul> <li>Context: Used with the <code>fetch</code> API to read and parse the response body as JSON.</li> <li>Functionality: The <code>.json()</code> method is called on a Response object. It reads the response stream to completion and parses it as JSON.</li> <li>Return Value: Returns a promise that resolves with the result of parsing the response body text as JSON.</li> <li>Usage: Use <code>.json()</code> when dealing with the response from a fetch request.</li> </ul>"},{"location":"frontend/js/core/api-response-object/#fetching-api-data-in-javascript","title":"Fetching API Data in JavaScript","text":"<p>When using the <code>fetch</code> API in JavaScript, the response is received as a raw stream of data, which is then processed into a string and parsed as needed. Here's the process:</p> <ol> <li>Fetching the Data:</li> </ol> javascript<pre><code>fetch('https://api.example.com/data')\n.then(response =&gt; response.json())  // Parses the response as JSON\n.then(data =&gt; {\n    console.log(data);  // The data is now a JavaScript object\n})\n.catch(error =&gt; console.error('Error:', error));\n</code></pre> <p>In this example, the <code>response.json()</code> method is called on the response object. This method reads the response stream to completion and parses it as JSON. The result is a JavaScript object.</p> Response Data Formats <ol> <li> <p>JSON (Most Common)</p> <ul> <li>Received as: String</li> <li>Parsed to: JavaScript object</li> <li>Example:</li> </ul> <pre><code>fetch('https://api.example.com/data')\n.then(response =&gt; response.json())  // Converts JSON string to JavaScript object\n.then(data =&gt; {\n    console.log(data);\n});\n</code></pre> </li> <li> <p>Text</p> <ul> <li>Received as: String</li> <li>Example:</li> </ul> <pre><code>fetch('https://api.example.com/text')\n.then(response =&gt; response.text())  // Reads response as plain text\n.then(data =&gt; {\n    console.log(data);\n});\n</code></pre> </li> <li> <p>Blob (Binary Large Object)</p> <ul> <li>Received as: Binary data</li> <li>Example:</li> </ul> <pre><code>fetch('https://api.example.com/image')\n.then(response =&gt; response.blob())  // Reads response as binary data (Blob)\n.then(blob =&gt; {\n    console.log(blob);\n});\n</code></pre> </li> <li> <p>FormData</p> <ul> <li>Received as: Form data</li> <li>Example:</li> </ul> <pre><code>fetch('https://api.example.com/formdata')\n.then(response =&gt; response.formData())  // Reads response as FormData\n.then(formData =&gt; {\n    console.log(formData);\n});\n</code></pre> </li> <li> <p>ArrayBuffer</p> <ul> <li>Received as: Binary data</li> <li>Example:</li> </ul> <pre><code>fetch('https://api.example.com/binary')\n.then(response =&gt; response.arrayBuffer())  // Reads response as ArrayBuffer\n.then(buffer =&gt; {\n    console.log(buffer);\n});\n</code></pre> </li> </ol>"},{"location":"frontend/js/core/api-response-object/#summary","title":"Summary","text":"<p>When fetching data from an API endpoint, the response is initially received as a string or binary data. For JSON responses, which are most common, the string is parsed into a JavaScript object using the <code>response.json()</code> method. Other methods like <code>response.text()</code>, <code>response.blob()</code>, <code>response.formData()</code>, and <code>response.arrayBuffer()</code> are used to handle different types of response data. The parsed data can then be used within your application as needed.</p>"},{"location":"frontend/js/core/api-response-object/#process-of-fetching-and-parsing-json-data","title":"Process of Fetching and Parsing JSON Data","text":"<ol> <li> <p>Fetching the Data:</p> <p>When you use the fetch API to make a request, the response body is a readable stream. This stream needs to be read to obtain the actual data.</p> </li> <li> <p>Response as JSON:</p> <p>The <code>response.json()</code> method reads the response stream to completion and parses the text as JSON. This method returns a promise that resolves with the result of parsing the body text as JSON.</p> </li> </ol>"},{"location":"frontend/js/core/api-response-object/#example-in-javascript","title":"Example in JavaScript","text":"<ol> <li> <p>Fetching and Parsing JSON Data:</p> javascript<pre><code>fetch('https://api.example.com/data')\n.then(response =&gt; response.json())  // Parses the response text as JSON\n.then(data =&gt; {\n    console.log(data);  // 'data' is now a JavaScript object\n})\n.catch(error =&gt; console.error('Error:', error));\n</code></pre> </li> </ol> <p>In this example:</p> <ul> <li><code>fetch('https://api.example.com/data')</code> sends a request to the API.</li> <li><code>response.json()</code> reads the response stream and parses it as JSON, converting it from a string to a JavaScript object.</li> <li>The resulting data is a JavaScript object that can be used in your code.</li> </ul>"},{"location":"frontend/js/core/api-response-object/#clarification-on-json-response","title":"Clarification on JSON Response","text":"<ul> <li>Initial Format: When the JSON response is received from the API, it is in string format.</li> <li>After Parsing: The JSON string is parsed into a JavaScript object using response.json().</li> </ul>"},{"location":"frontend/js/core/api-response-object/#example-of-json-response","title":"Example of JSON Response","text":"<ol> <li> <p>Raw JSON Response (String):</p> json<pre><code>{\n    \"name\": \"Alice\",\n    \"age\": 30,\n    \"isMember\": true\n}\n</code></pre> </li> <li> <p>Parsed JavaScript Object:</p> javascript<pre><code>{\n    name: \"Alice\",\n    age: 30,\n    isMember: true\n}\n</code></pre> </li> </ol> <ul> <li>Context: Used to parse a JSON string into a JavaScript object.</li> <li>Functionality: <code>JSON.parse()</code> takes a JSON string and parses it to produce a JavaScript object.</li> <li>Return Value: Returns a JavaScript object.</li> <li>Usage: Use <code>JSON.parse()</code> when you have a JSON string (e.g., stored in a variable) and need to convert it to a JavaScript object.</li> </ul> javascript<pre><code>let jsonString = '{\"name\": \"Alice\", \"age\": 30, \"isMember\": true}';\nlet data = JSON.parse(jsonString);  // Parses JSON string into JavaScript object\nconsole.log(data.name);  // Output: Alice\n</code></pre> <ol> <li> <p>Source of Data:</p> <ul> <li><code>.json()</code>: Used directly on the Response object returned by the fetch API to handle the response stream.</li> <li><code>JSON.parse()</code>: Used on a JSON string that you already have (e.g., from a variable, local storage, etc.).</li> </ul> </li> <li> <p>Return Type:</p> <ul> <li><code>.json()</code>: Returns a promise that resolves with the parsed JavaScript object.</li> <li><code>JSON.parse()</code>: Directly returns the parsed JavaScript object.</li> </ul> </li> <li> <p>Common Usage:</p> <ul> <li><code>.json()</code>: Commonly used in asynchronous operations involving fetching data from APIs.</li> <li><code>JSON.parse()</code>: Used whenever you have a JSON string and need to convert it to a JavaScript object, irrespective of how you obtained the string.</li> </ul> </li> </ol>"},{"location":"frontend/js/core/api-response-object/#summary_1","title":"Summary","text":"<p>While JSON responses from an API are initially received as strings, they are typically parsed into JavaScript objects using methods like <code>response.json()</code>. This parsing process is necessary to convert the string representation of the JSON data into a format (JavaScript object) that can be easily manipulated in your code.</p>"},{"location":"frontend/js/core/api-response-object/#example","title":"Example","text":"JavaScript<pre><code>fetch('https://api.example.com/data')\n.then(response =&gt; response.json())  // Reads and parses response body as JSON\n.then(data =&gt; {\n    console.log(data);  // 'data' is now a JavaScript object\n})\n.catch(error =&gt; console.error('Error:', error));\n</code></pre>"},{"location":"frontend/js/core/api-response-object/#summary_2","title":"Summary","text":"<ul> <li>Use <code>.json()</code>: When handling responses from fetch API requests to read and parse the JSON response.</li> <li>Use <code>JSON.parse()</code>: When you have a JSON string and need to convert it to a JavaScript object in other contexts.</li> </ul> <p>Both methods are essential for working with JSON data, but they are applied in different scenarios to achieve similar results: converting JSON-formatted data into JavaScript objects.</p>"},{"location":"frontend/js/core/api-response-object/#what-is-reponse-api-object","title":"what is reponse API object","text":"<p>The Response object in the Fetch API represents the response to a request. It contains information about the response, including the status code, status text, headers, and the body of the response. This object is returned as a promise when a fetch request is made.</p> <p>Key Properties and Methods of the Response Object</p> PropertiesMethodsExampleExplanation <ul> <li>type: Indicates the type of the response (e.g., \"basic\", \"cors\", \"error\", \"opaque\").</li> <li>url: The URL of the response.</li> <li>redirected: Indicates whether the response is the result of a redirect.</li> <li>status: The status code of the response (e.g., 200 for a successful request).</li> <li>statusText: The status message corresponding to the status code (e.g., \"OK\" for status 200).</li> <li>ok: A boolean indicating whether the response was successful (status in the range 200-299).</li> <li>headers: The <code>Headers</code> object associated with the response.</li> <li>body: A <code>ReadableStream</code> of the body contents.</li> <li>bodyUsed: A boolean indicating whether the body has been read.</li> </ul> <ul> <li>arrayBuffer(): Reads the response body and returns it as a promise that resolves with an ArrayBuffer.</li> <li>blob(): Reads the response body and returns it as a promise that resolves with a Blob.</li> <li>formData(): Reads the response body and returns it as a promise that resolves with FormData.</li> <li>json(): Reads the response body and parses it as JSON, returning a promise that resolves with a JavaScript object.</li> <li>text(): Reads the response body and returns it as a promise that resolves with a string.</li> </ul> javascript<pre><code>fetch('https://api.example.com/data')\n.then(response =&gt; {\n    // Check if the request was successful\n    if (!response.ok) {\n    throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    // Access response properties\n    console.log(response.status);      // e.g., 200\n    console.log(response.statusText);  // e.g., \"OK\"\n    console.log(response.headers.get('Content-Type'));  // e.g., \"application/json\"\n\n    // Read and parse the response body\n    return response.json();  // Returns a promise that resolves with the JSON-parsed body\n})\n.then(data =&gt; {\n    // 'data' is now a JavaScript object\n    console.log(data);\n})\n.catch(error =&gt; {\n    console.error('Fetch error:', error);\n});\n</code></pre> <ol> <li><code>fetch('https://api.example.com/data')</code>: Initiates a request to the specified URL and returns a promise that resolves to a Response object.</li> <li><code>response.ok</code>: Checks if the response status code indicates a successful request.</li> <li><code>response.status</code>: Accesses the status code of the response.</li> <li><code>response.statusText</code>: Accesses the status text of the response.</li> <li><code>response.headers.get('Content-Type')</code>: Accesses the Content-Type header of the response.</li> <li><code>response.json()</code>: Reads and parses the response body as JSON, returning a promise that resolves to a JavaScript object.</li> <li>Handling the parsed data: The parsed JSON data is logged to the console.</li> <li>Error handling: Catches and logs any errors that occur during the fetch or parsing process.</li> </ol>"},{"location":"frontend/js/core/api-response-object/#summary_3","title":"Summary","text":"<p>The Response object in the Fetch API encapsulates the response to a request, providing access to the status, headers, and body of the response. You use various methods like <code>.json()</code>, <code>.text()</code>, and others to read and parse the response body, converting it into a usable format such as a JavaScript object or string. This process is essential for working with API responses in web development.</p>"},{"location":"frontend/js/core/array-prototype/","title":"Array Prototype","text":""},{"location":"frontend/js/core/array-prototype/#array-prototype","title":"Array Prototype","text":"<p>In JavaScript, the Array prototype is an object that contains methods and properties available to all arrays. When you create a new array, it inherits these methods and properties through its prototype chain.</p> <p>Here's how the prototype chain works for arrays:</p> <ul> <li>When you create an array like <code>let myArray = [1, 2, 3];</code>, myArray inherits from <code>Array.prototype</code>.</li> <li>Array.prototype is itself an object that inherits from Object.prototype.</li> </ul>"},{"location":"frontend/js/core/array-prototype/#why-is-the-array-prototype-important","title":"Why is the Array Prototype Important?","text":"<ul> <li> <p>Inheritance:</p> <p>All arrays have access to the methods defined on Array.prototype. This means you can call methods like push, pop, map, filter, etc., on any array.</p> <pre><code>let myArray = [1, 2, 3];\nmyArray.push(4);\nconsole.log(myArray); // [1, 2, 3, 4]\n</code></pre> </li> <li> <p>Extensibility:</p> <p>You can add custom methods to all arrays by modifying <code>Array.prototype</code>. However, this is generally discouraged in practice because it can lead to conflicts and unexpected behavior, especially in shared environments or libraries.</p> <pre><code>Array.prototype.first = function() {\n    return this[0];\n};\n\nlet myArray = [1, 2, 3];\nconsole.log(myArray.first()); // 1\n</code></pre> </li> <li> <p>Efficiency:</p> <p>By defining methods on the prototype, JavaScript ensures that only one copy of each method exists in memory, regardless of the number of arrays you create. This is more efficient than defining the same method individually for each array instance.</p> </li> </ul>"},{"location":"frontend/js/core/array-prototype/#example-of-adding-a-custom-method-to-array-prototype","title":"Example of Adding a Custom Method to Array Prototype","text":"<pre><code>Array.prototype.last = function() {\n  return this[this.length - 1];\n};\n\nlet myArray = [1, 2, 3, 4];\nconsole.log(myArray.last()); // 4\n</code></pre> <p>In this example:</p> <ul> <li>We add a last method to <code>Array.prototype</code>, which returns the last element of the array.</li> <li>All arrays now have access to this <code>last</code> method.</li> </ul>"},{"location":"frontend/js/core/array-prototype/#summary","title":"Summary","text":"<ul> <li> <p>Higher-order functions are functions that operate on other functions, either by taking them as arguments or by returning them. Many array methods in JavaScript are higher-order functions.</p> </li> <li> <p>The Array prototype is an object from which all arrays inherit their methods and properties. It allows for method sharing and efficient memory use, as well as extensibility by adding custom methods.</p> </li> </ul>"},{"location":"frontend/js/core/array-prototype/#most-important-about-array","title":"Most Important about Array","text":"<p>One of the most important things to learn about arrays in JavaScript to master advanced programming is understanding and effectively utilizing higher-order functions provided by the Array prototype. These functions include methods like <code>map()</code>, <code>filter()</code>, <code>reduce()</code>, <code>forEach()</code>, <code>find()</code>, <code>some()</code>, and <code>every()</code>. Mastering these functions allows you to write concise, expressive, and efficient code for manipulating and processing arrays</p> Example and Explanation of Key Higher-Order Functions: <ol> <li> <p>map():</p> <p>Creates a new array populated with the results of calling a provided function on every element in the calling array.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst doubled = numbers.map(num =&gt; num * 2);\nconsole.log(doubled); // [2, 4, 6, 8]\n</code></pre> </li> <li> <p>filter():</p> <p>Creates a new array with all elements that pass the test implemented by the provided function.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst evens = numbers.filter(num =&gt; num % 2 === 0);\nconsole.log(evens); // [2, 4]\n</code></pre> </li> <li> <p>reduce():</p> <p>Executes a reducer function on each element of the array, resulting in a single output value.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst sum = numbers.reduce((accumulator, currentValue) =&gt; accumulator + currentValue, 0);\nconsole.log(sum); // 10\n</code></pre> </li> <li> <p>forEach():</p> <p>Executes a provided function once for each array element.</p> <pre><code>const numbers = [1, 2, 3, 4];\nnumbers.forEach(num =&gt; console.log(num));\n// Outputs: 1, 2, 3, 4\n</code></pre> </li> <li> <p>find():</p> <p>Returns the value of the first element in the provided array that satisfies the provided testing function.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst firstEven = numbers.find(num =&gt; num % 2 === 0);\nconsole.log(firstEven); // 2\n</code></pre> </li> <li> <p>some():</p> <p>Tests whether at least one element in the array passes the test implemented by the provided function. It returns a Boolean value.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst hasEven = numbers.some(num =&gt; num % 2 === 0);\nconsole.log(hasEven); // true\n</code></pre> </li> <li> <p>every():</p> <p>Tests whether all elements in the array pass the test implemented by the provided function. It returns a Boolean value.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst allEven = numbers.every(num =&gt; num % 2 === 0);\nconsole.log(allEven); // false\n</code></pre> </li> </ol>"},{"location":"frontend/js/core/array-prototype/#why-mastering-these-functions-is-important","title":"Why Mastering These Functions is Important:","text":"<ul> <li>Expressiveness: They allow you to express complex operations on arrays concisely and declaratively.</li> <li>Readability: Code written with these methods is often more readable and easier to understand, as it closely matches the high-level description of the logic.</li> <li>Functional Programming: These methods are fundamental to functional programming techniques, which are powerful for writing clean, maintainable, and bug-resistant code.</li> <li>Efficiency: They are optimized for performance in most JavaScript engines, making them efficient for large datasets.</li> </ul> <p>Understanding and mastering these higher-order functions will significantly enhance your ability to write advanced and efficient JavaScript code.</p>"},{"location":"frontend/js/core/array/","title":"Array","text":""},{"location":"frontend/js/core/array/#array","title":"Array","text":""},{"location":"frontend/js/core/array/#why-is-an-array-an-object-in-javascript","title":"Why is an Array an Object in JavaScript?","text":"<p>In JavaScript, arrays are a type of object because the language is designed around the concept of objects as the fundamental building blocks. Here are a few reasons why arrays are implemented as objects in JavaScript:</p> <ul> <li> <p>Unified Data Structure: JavaScript is a language designed to be flexible and dynamic. By treating arrays as objects, JavaScript can leverage the existing object infrastructure, providing a unified way to handle collections of data.</p> </li> <li> <p>Dynamic Properties and Methods: As objects, arrays can have properties and methods. This allows for powerful features like dynamic resizing, and built-in methods (e.g., <code>push</code>, <code>pop</code>, <code>map</code>, <code>filter</code>) that make working with arrays convenient.</p> </li> <li> <p>Flexibility: Arrays being objects allow them to be extended and manipulated in ways that more rigid, statically-typed arrays in other languages might not support. This fits well with JavaScript's dynamic and loosely-typed nature.</p> </li> </ul>"},{"location":"frontend/js/core/array/#are-arrays-objects-in-other-programming-languages","title":"Are Arrays Objects in Other Programming Languages?","text":"<p>The treatment of arrays varies across different programming languages:</p> <ul> <li> <p>C/C++: In languages like <code>C</code> and <code>C++</code>, arrays are not objects. They are contiguous blocks of memory with a fixed size. Arrays in these languages are more primitive and have limited functionality compared to JavaScript arrays.</p> </li> <li> <p>Java: In Java, arrays are objects. They are instances of a class and have a fixed size once created. They also have properties (like <code>length</code>) and methods.</p> </li> <li> <p>Python: In Python, the closest equivalent to JavaScript arrays is the list. Lists are objects in Python, with dynamic sizing and many built-in methods, similar to JavaScript arrays.</p> </li> <li> <p>Ruby: In Ruby, arrays are also objects. They are instances of the Array class and come with a rich set of methods for manipulation.</p> </li> </ul>"},{"location":"frontend/js/core/array/#reason-behind-the-design-choice","title":"Reason Behind the Design Choice","text":"<p>The decision to make arrays objects in JavaScript (and other high-level languages) often comes down to the following reasons:</p> <ul> <li> <p>Consistency: By making arrays objects, the language maintains a consistent approach to data structures. Everything is an object, which simplifies the language model and makes it easier to learn and use.</p> </li> <li> <p>Extensibility: Arrays as objects can be easily extended with new properties and methods. This allows for more powerful and flexible programming paradigms.</p> </li> <li> <p>Ease of Use: Built-in methods and properties provided by the array object simplify many common tasks, reducing the need for boilerplate code and making the language more expressive and productive for developers.</p> </li> </ul>"},{"location":"frontend/js/core/array/#summary","title":"Summary","text":"<ul> <li>In JavaScript: Arrays are objects to provide a consistent, flexible, and powerful way to handle collections of data.</li> <li>In Other Languages: The treatment of arrays varies, with some languages treating them as primitive types and others as objects.</li> <li>Design Reasons: Making arrays objects allows for extensibility, ease of use, and a unified data structure model.</li> </ul> <p>This design choice reflects JavaScript's overall philosophy of being a flexible and dynamic language, aiming to simplify and enhance the developer experience.</p> what is exactly an array in javascript. <p>Yes, in JavaScript, an array is indeed a type of object. Here's a more detailed explanation:</p> is array an object in javascript <p>In JavaScript, arrays are a type of object. Specifically, they are a specialized type of object designed to store indexed collections of data. Arrays in JavaScript can hold various types of data (such as <code>numbers</code>, <code>strings</code>, <code>objects</code>, or even other <code>arrays</code>) and provide methods for manipulating those data elements.</p> <pre><code>let myArray = [1, 2, 3, 4, 5]; // An array of numbers\n\nconsole.log(typeof myArray); // Outputs: object\nconsole.log(Array.isArray(myArray)); // Outputs: true\n</code></pre> <p>Even though <code>typeof myArray</code> returns \"object\", you can use Array.isArray() to specifically check if a variable is an array. Arrays have additional properties and methods compared to regular objects, such as length for the number of elements and methods like <code>push</code>, <code>pop</code>, <code>forEach</code>, etc., for array manipulation.</p> what do you mean by type of object. is it exactly object? what is it? if it is an object then why do we need isArray <p>In JavaScript, the <code>typeof</code> operator can return several values, including \"object\" for objects and arrays. However, arrays are a specialized type of object with additional features and behaviors tailored specifically for handling ordered collections of data.</p> <p>Here's why <code>Array.isArray()</code> is useful:</p> <ul> <li> <p>Clarity: Arrays and objects are both considered \"object\" types by <code>typeof</code>, so Array.isArray() provides a clear and specific way to determine if a variable is an array.</p> </li> <li> <p>Behavior: Arrays in JavaScript have specialized methods and properties (length, push, pop, etc.) that make them distinct from regular objects. Using Array.isArray() ensures that you are working with an array and can safely use array-specific methods without encountering unexpected behavior.</p> </li> <li> <p>Compatibility: In older versions of JavaScript, before Array.isArray() was introduced in ECMAScript 5 (2009), checking if an object was an array was less straightforward. Array.isArray() provides a reliable cross-browser way to perform this check.</p> </li> </ul> <p>Here\u2019s an example of how you might use Array.isArray():</p> <pre><code>let myArray = [1, 2, 3];\nlet myObject = { key: 'value' };\n\nconsole.log(Array.isArray(myArray)); // true\nconsole.log(Array.isArray(myObject)); // false\n\n// Using typeof\nconsole.log(typeof myArray); // \"object\"\nconsole.log(typeof myObject); // \"object\"\n</code></pre> <p>So, while arrays are objects in JavaScript, Array.isArray() is necessary to distinguish arrays from other types of objects and ensure correct behavior when working with arrays.</p> so why do we need array object type and Array.isArray() <p>The distinction between arrays and regular objects in JavaScript, as well as the use of Array.isArray(), serves several important purposes:</p> <ol> <li> <p>Specialized Functionality:</p> <p>Arrays are specialized objects designed specifically for storing ordered collections of data. They come with built-in methods (push, pop, forEach, etc.) that make it easy to manipulate and iterate over their elements. This specialization allows for efficient handling of sequential data, which is common in programming tasks.</p> </li> <li> <p>Type Checking:</p> <p>JavaScript's typeof operator returns \"object\" for both arrays and regular objects. However, arrays have distinct behavior and capabilities compared to generic objects. Array.isArray() provides a reliable way to specifically check if a variable is an array, ensuring that you can safely use array-specific methods without encountering errors or unexpected behavior.</p> </li> <li> <p>Compatibility:</p> <p>Prior to the introduction of Array.isArray() in ECMAScript 5 (2009), developers often used less reliable methods to check if an object was an array (such as checking for the presence of array-specific methods like push). Array.isArray() provides a standardized and cross-browser-compatible approach to this check.</p> </li> <li> <p>Code Readability:</p> <p>Explicitly using Array.isArray() improves the readability and maintainability of your code. It clearly communicates your intention to check whether a variable is an array, making the code easier to understand for other developers who may work with or maintain it in the future.</p> </li> </ol> <p>In essence, while arrays are objects in JavaScript, they have specialized features that distinguish them from regular objects. Array.isArray() is a utility function that ensures clarity, reliability, and compatibility when working with arrays, helping developers write more robust and understandable code.</p>"},{"location":"frontend/js/core/array/#what-is-an-array","title":"What is an Array?","text":"<p>An array in JavaScript is a special type of object used to store multiple values in a single variable. Unlike regular objects, which use named keys to store values, arrays use numeric indices.</p>"},{"location":"frontend/js/core/array/#characteristics-of-arrays","title":"Characteristics of Arrays","text":"<ol> <li>Indexed Collection: Arrays are indexed, meaning each element in the array has a numbered position (starting from 0).</li> <li>Dynamic Size: Arrays can grow and shrink in size dynamically as elements are added or removed.</li> <li>Zero-based Index: The index of the first element is 0, the second element is 1, and so on.</li> <li>Heterogeneous Elements: Arrays can store elements of different types (numbers, strings, objects, other arrays, etc.).</li> </ol> Example of an Array<pre><code>let fruits = ['Apple', 'Banana', 'Cherry'];\n</code></pre> <p>In this example, <code>fruits</code> is an array containing three string elements.</p>"},{"location":"frontend/js/core/array/#arrays-are-objects","title":"Arrays are Objects","text":"<p>Internally, arrays are a specialized type of object. You can verify this by using the typeof operator:</p> javascript<pre><code>console.log(typeof fruits); // \"object\"\n</code></pre> <p>Despite being objects, arrays have special properties and methods that make them particularly useful for working with ordered collections of data. For example:</p> <ul> <li>length property: Returns the number of elements in the array.</li> <li>push method: Adds one or more elements to the end of the array.</li> <li>pop method: Removes the last element from the array.</li> <li>map method: Creates a new array with the results of calling a provided function on every element in the array.</li> </ul>"},{"location":"frontend/js/core/array/#key-differences-between-arrays-and-objects","title":"Key Differences Between <code>Arrays</code> and <code>Objects</code>","text":"<ul> <li>Indexing: Arrays are indexed using numeric indices, while objects use named keys.</li> <li>Length Property: Arrays have a <code>length</code> property that keeps track of the number of elements. Objects do not have a built-in <code>length</code> property.</li> <li>Iteration: Arrays can be easily iterated using loops (like <code>for</code>, <code>for...of</code>, <code>forEach</code>). Iterating over an object typically requires using a <code>for...in</code> loop or <code>Object.keys()</code>.</li> </ul>"},{"location":"frontend/js/core/array/#summary_1","title":"Summary","text":"<ul> <li>Arrays are objects with additional functionality suited for storing ordered collections of data.</li> <li>They provide methods and properties that make it easier to manipulate sequences of values.</li> </ul> Example: some common array operations<pre><code>let numbers = [1, 2, 3, 4, 5];\n\nconsole.log(numbers.length); // 5\nnumbers.push(6);\nconsole.log(numbers); // [1, 2, 3, 4, 5, 6]\nnumbers.pop();\nconsole.log(numbers); // [1, 2, 3, 4, 5]\n\nnumbers.forEach(num =&gt; console.log(num * 2)); // 2, 4, 6, 8, 10\n</code></pre>"},{"location":"frontend/js/core/array/#example","title":"Example","text":"<p>Tip</p> <p>Certainly! Here are basic and advanced examples demonstrating the usage of <code>Array.isArray()</code> in JavaScript:</p> Basic ExampleAdvanced Example javascript<pre><code>// Basic example\nlet arr = [1, 2, 3];\n\nconsole.log(Array.isArray(arr)); // true\n\nlet obj = { name: 'John', age: 30 };\n\nconsole.log(Array.isArray(obj)); // false\n</code></pre> <p>In this basic example:</p> <ul> <li>Array.isArray(arr) returns true because arr is an array.</li> <li>Array.isArray(obj) returns false because obj is a plain object, not an array.</li> </ul> javascript<pre><code>function processArray(input) {\n    if (Array.isArray(input)) {\n        input.forEach(item =&gt; console.log(item));\n    } else {\n        console.log(\"Input is not an array.\");\n    }\n}\n\nlet arr = [1, 2, 3];\nlet obj = { name: 'Jane', age: 25 };\n\nprocessArray(arr); // Outputs: 1, 2, 3\nprocessArray(obj); // Outputs: \"Input is not an array.\"\n</code></pre> <p>In this advanced example:</p> <ul> <li>The <code>processArray</code> function takes <code>input</code> as a parameter.</li> <li>Inside the function, <code>Array.isArray(input)</code> checks if <code>input</code> is an array.</li> <li>If <code>input</code> is an array, it iterates over its elements using <code>forEach</code>.</li> <li>If <code>input</code> is not an array, it outputs a message indicating that it's not an array.</li> </ul> <p>These examples illustrate how <code>Array.isArray()</code> can be used to safely and reliably determine whether a variable is an array before performing operations specific to arrays. This helps prevent errors and ensures that your code behaves as expected in different scenarios.</p>"},{"location":"frontend/js/core/control-statement/","title":"Control Statement","text":"<p>Control statements in JavaScript allow you to control the flow of execution within your programs. They enable you to make decisions, iterate over collections, and manage complex logical operations. Here are the main control statements in JavaScript:</p> <p>Tip</p> <ul> <li>Conditional Statements: <code>if</code>, <code>if...else</code>, <code>if...else if...else</code>, <code>switch</code>.</li> <li>Looping Statements: <code>for</code>, <code>while</code>, <code>do...while</code>.</li> <li>Jump Statements: <code>break</code>, <code>continue</code>, <code>return</code>.</li> <li>Exception Handling Statements: <code>try...catch</code>, <code>try...catch...finally</code>, <code>throw</code>.</li> </ul> Looping an Array &amp; Object Looping an ArrayLooping through an Object <ol> <li> <p><code>for</code> loop:</p> <ul> <li>Does not return a new array.</li> <li> <p>It is simply a control flow statement.</p> <pre><code>const array = [1, 2, 3, 4, 5];\n\nfor (let i = 0; i &lt; array.length; i++) {\n    console.log(array[i]);\n}\n</code></pre> </li> </ul> </li> <li> <p><code>for...of</code> loop:</p> <ul> <li>Does not return a new array.</li> <li> <p>It is used to iterate over iterable objects.</p> <pre><code>const array = [1, 2, 3, 4, 5];\n\nfor (const item of array) {\n    console.log(item);\n}\n</code></pre> </li> </ul> </li> <li> <p><code>forEach</code> method:</p> <ul> <li>Does not return a new array.</li> <li> <p>It executes a provided function once for each array element.</p> <pre><code>const array = [1, 2, 3, 4, 5];\n\narray.forEach(item =&gt; {\n    console.log(item);\n});\n</code></pre> </li> </ul> </li> <li> <p><code>map</code> method:</p> <ul> <li>Returns a new array.</li> <li> <p>It creates a new array with the results of calling a provided function on every element in the calling array.</p> <pre><code>const array = [1, 2, 3, 4, 5];\n\narray.map(item =&gt; {\n    console.log(item);\n    return item;\n});\n\n// Example\nconst array = [1, 2, 3, 4, 5];\nconst newArray = array.map(item =&gt; item * 2);\nconsole.log(newArray); // [2, 4, 6, 8, 10]\n</code></pre> </li> </ul> </li> </ol> <ol> <li> <p><code>for...in</code> loop:</p> <ul> <li>Does not return a new object.</li> <li> <p>It is used to iterate over the enumerable properties of an object.</p> <pre><code>const obj = {a: 1, b: 2, c: 3};\n\nfor (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n        console.log(key, obj[key]);\n    }\n}\n</code></pre> </li> </ul> </li> <li> <p><code>Object.keys</code> method:</p> <ul> <li> <p>Returns a new array of the object\u2019s own enumerable property names (keys).</p> <pre><code>const obj = {a: 1, b: 2, c: 3};\n\nObject.keys(obj).forEach(key =&gt; {\n    console.log(key, obj[key]);\n});\n\n// Example\nconst obj = {a: 1, b: 2, c: 3};\nconst keys = Object.keys(obj);\nconsole.log(keys); // ['a', 'b', 'c']\n</code></pre> </li> </ul> </li> <li> <p><code>Object.entries</code> method:</p> <ul> <li> <p>Returns a new array of the object\u2019s own enumerable string-keyed property [key, value] pairs.</p> <pre><code>const obj = {a: 1, b: 2, c: 3};\n\nObject.entries(obj).forEach(([key, value]) =&gt; {\n    console.log(key, value);\n});\n\n// Example\nconst obj = {a: 1, b: 2, c: 3};\nconst entries = Object.entries(obj);\nconsole.log(entries); // [['a', 1], ['b', 2], ['c', 3]]\n</code></pre> </li> </ul> </li> <li> <p><code>Object.values</code> method:</p> <ul> <li> <p>Returns a new array of the object\u2019s own enumerable property values.</p> <pre><code>const obj = {a: 1, b: 2, c: 3};\n\nObject.values(obj).forEach(value =&gt; {\n    console.log(value);\n});\n\n// Example\nconst obj = {a: 1, b: 2, c: 3};\nconst values = Object.values(obj);\nconsole.log(values); // [1, 2, 3]\n</code></pre> </li> </ul> </li> </ol> <p>These methods provide flexibility depending on the specific requirements of your task. For example, <code>for...in</code> is generally used for objects, while <code>for...of</code> is typically used for arrays and iterable objects.</p> <p>In summary, among the array methods, only map returns a new array. For objects, Object.keys, Object.entries, and Object.values return new arrays. Methods like for, for...of, forEach, and for...in are used for iteration and do not inherently create new arrays or objects.</p>"},{"location":"frontend/js/core/control-statement/#for-in-vs-for-of-loop","title":"for in <code>vs</code> for of Loop","text":"<p>The <code>for...in</code> and <code>for...of</code> loops are both used for iterating over collections in JavaScript, but they serve different purposes and work with different types of collections.</p>"},{"location":"frontend/js/core/control-statement/#forin-loop","title":"<code>for...in</code> Loop","text":"<ul> <li>Purpose: Iterates over the enumerable properties of an object.</li> <li>Usage: Typically used for iterating over the keys of an object.</li> <li>Works with: Objects (though it can also be used with <code>arrays</code>, it is generally not recommended).</li> </ul> <pre><code>const obj = {a: 1, b: 2, c: 3};\n\nfor (const key in obj) {\n    console.log(key, obj[key]);\n}\n\n// Output:\n// a 1\n// b 2\n// c 3\n</code></pre> <p>When used with <code>arrays</code>, it iterates over the array indices (which are the enumerable properties of the array object).</p> <pre><code>const array = [1, 2, 3, 4, 5];\n\nfor (const index in array) {\n    console.log(index, array[index]);\n}\n\n// Output:\n// 0 1\n// 1 2\n// 2 3\n// 3 4\n// 4 5\n</code></pre>"},{"location":"frontend/js/core/control-statement/#forof-loop","title":"for...of Loop","text":"<ul> <li>Purpose: Iterates over the values of an iterable object.</li> <li>Usage: Typically used for iterating over the values of arrays, strings, maps, sets, and other iterable objects.</li> <li>Works with: Arrays, strings, maps, sets, and other iterable objects.</li> </ul> <pre><code>const array = [1, 2, 3, 4, 5];\n\nfor (const value of array) {\n    console.log(value);\n}\n\n// Output:\n// 1\n// 2\n// 3\n// 4\n// 5\n</code></pre> <p>It can also be used with other iterable objects like strings:</p> <pre><code>const string = \"hello\";\n\nfor (const char of string) {\n    console.log(char);\n}\n\n// Output:\n// h\n// e\n// l\n// l\n// o\n</code></pre>"},{"location":"frontend/js/core/control-statement/#key-differences","title":"Key Differences","text":"<ol> <li> <p>Iteration Target:</p> <ul> <li><code>for...in</code> iterates over the enumerable properties (keys) of an object.</li> <li><code>for...of</code> iterates over the values of an iterable object.</li> </ul> </li> <li> <p>Common Use Cases:</p> <ul> <li><code>for...in</code> is commonly used with objects to get the keys.</li> <li><code>for...of</code> is commonly used with <code>arrays</code>, <code>strings</code>, <code>maps</code>, <code>sets</code>, and other iterable objects to get the values.</li> </ul> </li> <li> <p>Arrays:</p> <ul> <li><code>for...in</code> should generally be avoided for arrays because it iterates over keys (indices) and can include properties from the prototype chain.</li> <li><code>for...of</code> is ideal for arrays as it directly iterates over the values.</li> </ul> </li> <li> <p>Prototype Chain:</p> <ul> <li><code>for...in</code> iterates over all enumerable properties, including those inherited from the prototype chain.</li> <li><code>for...of</code> only iterates over the values of the iterable object and does not consider properties from the prototype chain.</li> </ul> </li> </ol> <p>In summary, use <code>for...in</code> when you need to iterate over the properties of an object and use <code>for...of</code> when you need to iterate over the values of an iterable collection like an array or string.</p>"},{"location":"frontend/js/core/data-types/","title":"Data Type","text":""},{"location":"frontend/js/core/data-types/#data-types-in-js","title":"Data Types in JS","text":"<p>In JavaScript, while many things are objects, not everything is an object. JavaScript has a variety of data types, and understanding which are objects and which are not is important for grasping the language's structure.</p>"},{"location":"frontend/js/core/data-types/#javascript-data-types","title":"JavaScript Data Types","text":"<p>JavaScript has both primitive data types and objects.</p> <p>primitive</p> <p>Object</p>"},{"location":"frontend/js/core/data-types/#primitive-data-types","title":"Primitive Data Types","text":"<p>Primitive data types are not objects and do not have properties or methods. They are immutable and are directly assigned and manipulated.</p> <ol> <li> <p>Number: Represents both integer and floating-point numbers.</p> <pre><code>let num = 42;\n</code></pre> </li> <li> <p>String: Represents a sequence of characters.</p> <pre><code>let str = \"Hello, world!\";\n</code></pre> </li> <li> <p>Boolean: Represents a logical entity with two values: <code>true</code> and <code>false</code>.</p> <pre><code>let bool = true;\n</code></pre> </li> <li> <p>Null: Represents the intentional absence of any object value.</p> <pre><code>let nullValue = null;\n</code></pre> </li> <li> <p>Undefined:: Represents a variable that has been declared but not assigned a value.</p> <pre><code>let undefinedValue;\n</code></pre> </li> <li> <p>Symbol: Represents a unique and immutable identifier.</p> <pre><code>let sym = Symbol('description');\n</code></pre> </li> <li> <p>BigInt: Represents integers with arbitrary precision.</p> <pre><code>let bigInt = 1234567890123456789012345678901234567890n;\n</code></pre> </li> </ol>"},{"location":"frontend/js/core/data-types/#objects","title":"Objects","text":"<p>Objects are collections of properties and are more complex. <code>Arrays</code>, <code>functions</code>, and <code>objects</code> created using the Object constructor or object literals are examples of objects.</p> <ol> <li> <p>Object: General-purpose containers for named properties.</p> <pre><code>let obj = { key: 'value' };\n</code></pre> </li> <li> <p>Array: Ordered lists of values.</p> <pre><code>let arr = [1, 2, 3];\n</code></pre> </li> <li> <p>Function: Callable objects.</p> <pre><code>function func() { return 'Hello!'; }\n</code></pre> </li> <li> <p>Date: Represents dates and times.</p> <pre><code>let date = new Date();\n</code></pre> </li> <li> <p>RegExp: Represents regular expressions.</p> <pre><code>let regex = /abc/;\n</code></pre> </li> <li> <p>Map: Key-value pairs where keys can be of any type.</p> <pre><code>let map = new Map();\n</code></pre> </li> <li> <p>Set: Collections of unique values.</p> <pre><code>let set = new Set();\n</code></pre> </li> </ol>"},{"location":"frontend/js/core/data-types/#why-not-everything-is-an-object","title":"Why Not Everything is an Object","text":"<p>Primitive types are not objects because they are meant to be simple and efficient. They are stored directly in memory rather than by reference, which allows for faster access and manipulation. For example, mathematical operations on numbers or string manipulations are faster because these operations do not involve object overhead. Wrappers for Primitives</p> <p>JavaScript automatically provides temporary objects, known as wrapper objects, when methods or properties are accessed on primitive values. These objects allow primitives to behave like objects in certain contexts.</p> <pre><code>let str = \"hello\";\nconsole.log(str.toUpperCase()); // \"HELLO\"\n</code></pre> <p>In this example, <code>str</code> is a primitive string, but JavaScript temporarily wraps it in a <code>String</code> object to call the <code>toUpperCase</code> method.</p>"},{"location":"frontend/js/core/data-types/#summary","title":"Summary","text":"<ul> <li>Primitive Types: <code>Number</code>, <code>String</code>, <code>Boolean</code>, <code>Null</code>, <code>Undefined</code>, <code>Symbol</code>, <code>BigInt</code>. Not objects, immutable, and have no properties or methods directly.</li> <li>Objects: More complex structures including plain <code>objects</code>, <code>arrays</code>, <code>functions</code>, etc. Have properties and methods and are stored by reference.</li> </ul> <p>While JavaScript provides a unified and flexible approach to handling various data types, understanding the distinction between primitives and objects is crucial for effective programming in JavaScript.</p> autoboxing in javascript"},{"location":"frontend/js/core/data-types/#autoboxing","title":"autoboxing","text":"<p>In JavaScript, when you attempt to access a property or method on a primitive value, the language automatically wraps the primitive in a temporary object so that you can use the properties and methods that are typically available on objects. This process is known as autoboxing. Here\u2019s a detailed explanation of how this works:</p>"},{"location":"frontend/js/core/data-types/#how-javascript-wraps-primitives","title":"How JavaScript Wraps Primitives","text":"<ol> <li> <p>Autoboxing: When you try to access a method or property on a primitive value, JavaScript temporarily converts (or \"boxes\") the primitive value into an object.</p> <pre><code>let str = \"hello\";\nconsole.log(str.toUpperCase()); // \"HELLO\"\n</code></pre> </li> </ol> <p>Here's what happens behind the scenes:</p> <ul> <li>JavaScript sees that you're calling <code>toUpperCase()</code> on the str variable, which is a string primitive.</li> <li>It creates a temporary <code>String</code> object from the primitive value \"hello\".</li> <li>It calls the toUpperCase method on this temporary <code>String</code> object.</li> <li>The method returns the result (\"HELLO\").</li> <li>The temporary <code>String</code> object is discarded.</li> </ul>"},{"location":"frontend/js/core/data-types/#steps-involved","title":"Steps Involved","text":"<ol> <li> <p>Primitive Detection: When you try to access a property or method on a primitive value, the JavaScript engine checks the type of the value.</p> <ul> <li>If the value is a primitive type (<code>string</code>, <code>number</code>, <code>boolean</code>, <code>symbol</code>, <code>bigint</code>), the engine understands that it needs to provide access to the methods and properties that are defined on the corresponding wrapper objects (<code>String</code>, <code>Number</code>, <code>Boolean</code>, <code>Symbol</code>, <code>BigInt</code>).</li> </ul> </li> <li> <p>Temporary Object Creation: The JavaScript engine creates a temporary object of the corresponding wrapper type.</p> <ul> <li>For a string, it creates a <code>String</code> object.</li> <li>For a number, it creates a <code>Number</code> object.</li> <li>For a boolean, it creates a <code>Boolean</code> object.</li> <li>For a symbol, it creates a <code>Symbol</code> object.</li> <li>For a bigint, it creates a <code>BigInt</code> object.</li> </ul> </li> <li> <p>Method/Property Access: The engine uses this temporary object to access the desired method or property.</p> <ul> <li>In the case of \"hello\".toUpperCase(), it creates a <code>String</code> object and calls the <code>toUpperCase</code> method on it.</li> </ul> </li> <li> <p>Result Return and Discarding Temporary Object: The result of the method or property access is returned, and the temporary object is discarded.</p> <ul> <li>The temporary <code>String</code> object is no longer needed after the <code>toUpperCase</code> method is called, so it is discarded.</li> </ul> </li> </ol>"},{"location":"frontend/js/core/data-types/#example-in-detail","title":"Example in Detail","text":"<p>Here\u2019s a more detailed breakdown of the example:</p> <pre><code>let str = \"hello\";\nconsole.log(str.toUpperCase()); // \"HELLO\"\n</code></pre> <ol> <li>Primitive Detection: The JavaScript engine sees that str is a primitive string.</li> <li> <p>Temporary Object Creation: The engine creates a temporary String object that represents the value \"hello\".</p> <pre><code>let tempStrObj = new String(\"hello\");\n</code></pre> </li> <li> <p>Method/Property Access: The engine calls the <code>toUpperCase</code> method on the <code>tempStrObj</code> object.</p> <pre><code>let result = tempStrObj.toUpperCase(); // \"HELLO\"\n</code></pre> </li> <li> <p>Result Return and Discarding Temporary Object: The engine returns the result (\"HELLO\") and discards the temporary <code>String</code> object.</p> </li> </ol>"},{"location":"frontend/js/core/data-types/#summary_1","title":"Summary","text":"<ul> <li>JavaScript uses autoboxing to wrap primitive values in temporary objects when you try to access properties or methods on them.</li> <li>The engine checks the type of the value and creates a corresponding wrapper object (<code>String</code>, <code>Number</code>, <code>Boolean</code>, <code>Symbol</code>, <code>BigInt</code>).</li> <li>After accessing the property or method, the result is returned, and the temporary object is discarded.</li> </ul> <p>This mechanism allows primitive values to behave like objects when needed, providing a seamless and flexible programming experience.</p>"},{"location":"frontend/js/core/data-types/#reference","title":"Reference","text":"<ul> <li>Autoboxing in JavaScript</li> </ul>"},{"location":"frontend/js/core/high-order-function/","title":"High Order Function (Hof)","text":""},{"location":"frontend/js/core/high-order-function/#higher-order-functions","title":"Higher-Order Functions","text":"<p>A higher-order function is a function that does at least one of the following:</p> <ul> <li>Takes one or more functions as arguments.</li> <li>Returns a function as its result.</li> </ul> <p>In JavaScript, many of the methods provided by the Array object are higher-order functions because they accept a function as an argument to process each element in the array. Here are a couple of examples:</p> Example map()filter()reduce()forEach()some()every()find()findIndex()sort()concat() <p>Takes a function as an argument to apply to each element and returns a new array.</p> <pre><code>const numbers = [1, 2, 3];\nconst doubled = numbers.map(num =&gt; num * 2);\nconsole.log(doubled); // [2, 4, 6]\n</code></pre> <p>Takes a function as an argument to determine which elements to include in the new array.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst evens = numbers.filter(num =&gt; num % 2 === 0);\nconsole.log(evens); // [2, 4]\n</code></pre> <p>Executes a reducer function (that you provide) on each element of the array, resulting in a single output value.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst sum = numbers.reduce((accumulator, currentValue) =&gt; accumulator + currentValue, 0);\nconsole.log(sum); // 10\n</code></pre> <p>Executes a provided function once for each array element.</p> <pre><code>const numbers = [1, 2, 3, 4];\nnumbers.forEach(num =&gt; console.log(num)); // 1 2 3 4\n</code></pre> <p>Tests whether at least one element in the array passes the test implemented by the provided function. Returns a Boolean value.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst hasEven = numbers.some(num =&gt; num % 2 === 0);\nconsole.log(hasEven); // true\n</code></pre> <p>Tests whether all elements in the array pass the test implemented by the provided function. Returns a Boolean value.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst allEven = numbers.every(num =&gt; num % 2 === 0);\nconsole.log(allEven); // false\n</code></pre> <p>Returns the value of the first element in the array that satisfies the provided testing function. Otherwise undefined is returned.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst firstEven = numbers.find(num =&gt; num % 2 === 0);\nconsole.log(firstEven); // 2\n</code></pre> <p>Returns the index of the first element in the array that satisfies the provided testing function. Otherwise, -1 is returned.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst firstEvenIndex = numbers.findIndex(num =&gt; num % 2 === 0);\nconsole.log(firstEvenIndex); // 1\n</code></pre> <p>Sorts the elements of an array in place and returns the sorted array.</p> <pre><code>const numbers = [4, 2, 3, 1];\nnumbers.sort((a, b) =&gt; a - b);\nconsole.log(numbers); // [1, 2, 3, 4]\n</code></pre> <p>Merges two or more arrays. This method does not change the existing arrays, but instead returns a new array.</p> <pre><code>const array1 = [1, 2];\nconst array2 = [3, 4];\nconst combined = array1.concat(array2);\nconsole.log(combined); // [1, 2, 3, 4]\n</code></pre> <p>These functions are \"higher-order\" because they operate on other functions, either by receiving them as arguments or by returning them.</p> what is high order function in javascript? why it is called hof? why do we need them. when does the hof comes in javascript? explain me in depth <p>A higher-order function (HOF) in JavaScript is a function that either takes one or more functions as arguments, returns a function as its result, or both. Higher-order functions are a key feature in functional programming, allowing for more flexible and reusable code.</p> <p>Why It's Called HOF</p> <p>The term \"higher-order\" comes from mathematics, where functions that operate on other functions are called higher-order functions. This terminology has been adopted in programming to describe functions that can take other functions as parameters or return functions as results.</p> <p>Why We Need Higher-Order Functions</p> <ul> <li> <p>Abstraction: Higher-order functions allow for abstraction of actions, not just values. They enable you to create more generic and reusable code by encapsulating behavior that can be varied.</p> </li> <li> <p>Code Reusability: By using HOFs, you can write more generic functions that can be reused with different behaviors, leading to less code duplication.</p> </li> <li> <p>Functional Programming: They are a cornerstone of functional programming, promoting a declarative coding style. This can make code more readable and maintainable.</p> </li> <li> <p>Composability: HOFs enable function composition, which is a way to build complex functions by combining simpler ones.</p> </li> </ul> <p>Examples of Higher-Order Functions</p> Functions as Arguments:Functions as Return Values:Both: <pre><code>function filter(array, test) {\n    let passed = [];\n    for (let element of array) {\n        if (test(element)) {\n            passed.push(element);\n        }\n    }\n    return passed;\n}\n\nconst isEven = n =&gt; n % 2 === 0;\nconst numbers = [1, 2, 3, 4, 5, 6];\nconsole.log(filter(numbers, isEven)); // [2, 4, 6]\n</code></pre> <pre><code>function createMultiplier(multiplier) {\n    return function(x) {\n        return x * multiplier;\n    };\n}\n\nconst double = createMultiplier(2);\nconsole.log(double(5)); // 10\n</code></pre> <pre><code>function repeat(n, action) {\n    for (let i = 0; i &lt; n; i++) {\n        action(i);\n    }\n}\n\nrepeat(3, console.log);\n// Output:\n// 0\n// 1\n// 2\n</code></pre> <p>Common JavaScript Higher-Order Functions</p> <ol> <li> <p>Array.prototype.map():</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst doubled = numbers.map(n =&gt; n * 2);\nconsole.log(doubled); // [2, 4, 6, 8]\n</code></pre> </li> <li> <p>Array.prototype.filter():</p> <pre><code>const numbers = [1, 2, 3, 4, 5];\nconst evens = numbers.filter(n =&gt; n % 2 === 0);\nconsole.log(evens); // [2, 4]\n</code></pre> </li> <li> <p>Array.prototype.reduce():</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst sum = numbers.reduce((acc, n) =&gt; acc + n, 0);\nconsole.log(sum); // 10\n</code></pre> </li> </ol> <p>When Do HOFs Come in JavaScript?</p> <p>HOFs come into play in various scenarios:</p> <ul> <li>Array Operations: Functions like <code>map</code>, <code>filter</code>, <code>reduce</code>, and <code>forEach</code> are higher-order functions that operate on arrays.</li> <li>Event Handling: Functions like <code>addEventListener</code> in the browser API take a callback function to be executed when an event occurs.</li> <li>Asynchronous Programming: Functions like <code>setTimeout</code>, <code>setInterval</code>, and <code>promises</code> use callbacks to handle asynchronous operations.</li> </ul> <p>Conclusion</p> <p>Higher-order functions are a powerful feature in JavaScript that allows for more flexible, reusable, and composable code. They enable a functional programming approach, promoting a declarative coding style and making complex operations more manageable. Understanding and using HOFs can greatly enhance your ability to write clean and efficient JavaScript code.</p> higher-order functions can be applied in various contexts beyond array operations? <ol> <li> <p>Event Handling</p> <p>Higher-order functions are widely used in event handling in web development.</p> <pre><code>document.getElementById(\"myButton\").addEventListener(\"click\", function() {\n    alert(\"Button was clicked!\");\n});\n</code></pre> <p>In this example, <code>addEventListener</code> is a higher-order function that takes another function (the event handler) as an argument.</p> </li> <li> <p>Asynchronous Programming</p> <p>Higher-order functions are crucial in asynchronous programming with <code>callbacks</code>, <code>promises</code>, and <code>async/await</code>.</p> Callbacks<pre><code>function fetchData(callback) {\n    setTimeout(() =&gt; {\n        const data = { name: \"John\", age: 30 };\n        callback(data);\n    }, 1000);\n}\n\nfetchData(function(data) {\n    console.log(data);\n});\n</code></pre> Promises<pre><code>function fetchData() {\n    return new Promise((resolve, reject) =&gt; {\n        setTimeout(() =&gt; {\n        const data = { name: \"John\", age: 30 };\n        resolve(data);\n        }, 1000);\n    });\n}\n\nfetchData().then(data =&gt; {\n    console.log(data);\n});\n</code></pre> </li> <li> <p>Function Composition</p> <p>Higher-order functions are used to compose functions.</p> <pre><code>const add = x =&gt; x + 1;\nconst multiply = x =&gt; x * 2;\n\nconst compose = (f, g) =&gt; x =&gt; f(g(x));\n\nconst addThenMultiply = compose(multiply, add);\n\nconsole.log(addThenMultiply(5)); // 12\n</code></pre> </li> <li> <p>Middleware</p> <p>In frameworks like <code>Express.js</code>, middleware functions are higher-order functions that process HTTP requests and responses.</p> <pre><code>const express = require(\"express\");\nconst app = express();\n\napp.use((req, res, next) =&gt; {\n    console.log(\"Middleware function\");\n    next();\n});\n\napp.get(\"/\", (req, res) =&gt; {\n    res.send(\"Hello World\");\n});\n\napp.listen(3000);\n</code></pre> </li> <li> <p>Currying</p> <p>Currying transforms a function with multiple arguments into a sequence of functions each with a single argument.</p> <pre><code>const multiply = a =&gt; b =&gt; a * b;\nconst double = multiply(2);\nconsole.log(double(5)); // 10\n</code></pre> </li> </ol> <p>Conclusion</p> <p>Higher-order functions in JavaScript are versatile and can be applied in various contexts, including but not limited to array operations. They play a significant role in event handling, asynchronous programming, function composition, middleware, and more. Understanding how to use higher-order functions effectively can greatly enhance your programming skills and enable you to write more flexible and reusable code.</p> does high order function used in object? <p>Yes, higher-order functions can be used with objects in JavaScript. While they are often associated with arrays due to methods like <code>map</code>, <code>filter</code>, and <code>reduce</code>, higher-order functions can operate on objects and be used in various object-oriented programming scenarios. Here are some examples to illustrate how higher-order functions can be used with objects:</p> <p>1. Iterating Over Object Properties</p> <p>You can create higher-order functions to iterate over an object's properties.</p> Mapping Over Object Properties<pre><code>const mapObject = (obj, fn) =&gt; {\n    const result = {};\n    for (const [key, value] of Object.entries(obj)) {\n        result[key] = fn(value);\n    }\n    return result;\n};\n\nconst user = { name: \"Alice\", age: 25, country: \"USA\" };\nconst upperCasedUser = mapObject(user, val =&gt; val.toString().toUpperCase());\nconsole.log(upperCasedUser); \n// { name: \"ALICE\", age: \"25\", country: \"USA\" }\n</code></pre> <p>2. Object Methods as Higher-Order Functions</p> <p>Objects can have methods that accept functions as arguments or return functions.</p> Configurable Logger<pre><code>const logger = {\n    log: (message) =&gt; console.log(`LOG: ${message}`),\n    error: (message) =&gt; console.error(`ERROR: ${message}`),\n    withPrefix: function(prefix) {\n        return (message) =&gt; this.log(`${prefix} ${message}`);\n    }\n};\n\nconst prefixedLogger = logger.withPrefix(\"Prefix\");\nprefixedLogger(\"This is a message.\"); \n// LOG: Prefix This is a message.\n</code></pre> <p>3. Functional Programming with Objects</p> <p>You can use higher-order functions to manipulate objects in a functional programming style.</p> Object Transformation<pre><code>const transformObject = (obj, transformFn) =&gt; {\n    return Object.keys(obj).reduce((acc, key) =&gt; {\n        acc[key] = transformFn(obj[key]);\n        return acc;\n    }, {});\n};\n\nconst user = { name: \"Alice\", age: 25, country: \"USA\" };\nconst doubledAgesUser = transformObject(user, val =&gt; typeof val === 'number' ? val * 2 : val);\nconsole.log(doubledAgesUser); \n// { name: \"Alice\", age: 50, country: \"USA\" }\n</code></pre> <p>4. Creating Fluent APIs</p> <p>Higher-order functions can help create fluent APIs, where methods can be chained together.</p> Fluent API for Object Manipulation<pre><code>const user = {\n    name: \"Alice\",\n    age: 25,\n    setName: function(newName) {\n        this.name = newName;\n        return this;\n    },\n    setAge: function(newAge) {\n        this.age = newAge;\n        return this;\n    }\n};\n\nconst updatedUser = user.setName(\"Bob\").setAge(30);\nconsole.log(updatedUser); \n// { name: \"Bob\", age: 30, setName: [Function], setAge: [Function] }\n</code></pre> <p>Conclusion</p> <p>Higher-order functions are not limited to arrays and can be effectively used with objects in JavaScript. They enable powerful patterns for iterating over object properties, transforming objects, creating methods that accept or return functions, and building fluent APIs. Understanding how to apply higher-order functions to objects can help you write more flexible, reusable, and expressive code.</p> Example <p>In JavaScript, a higher-order function is a function that either takes one or more functions as arguments or returns a function as a result. This allows for more abstract and flexible code.</p> <p>Here's a simple mathematical example using higher-order functions in JavaScript:</p> <p>Example 1: Function that multiplies numbers by a given factor</p> <p>We'll create a higher-order function called <code>createMultiplier</code> that takes a number as an argument and returns a new function. This returned function will multiply its input by the given number.</p> <pre><code>// Higher-order function\nfunction createMultiplier(factor) {\n    // Returning a new function\n    return function(number) {\n        return number * factor;\n    };\n}\n\n// Using the higher-order function to create multiplier functions\nconst double = createMultiplier(2);\nconst triple = createMultiplier(3);\n\n// Testing the created functions\nconsole.log(double(5)); // Output: 10\nconsole.log(triple(5)); // Output: 15\n</code></pre> <p>Explanation</p> <ul> <li>Higher-Order Function: <code>createMultiplier</code> is a higher-order function because it takes a number (<code>factor</code>) as an argument and returns a new function.</li> <li>Returned Function: The returned function takes another number (<code>number</code>) as an argument and multiplies it by the <code>factor</code>.</li> <li>Usage: We use <code>createMultiplier</code> to create two new functions: <code>double</code> (which multiplies by 2) and <code>triple</code> (which multiplies by 3).</li> <li>Testing: When we call <code>double(5)</code>, it returns <code>10</code> (because 5\u00d72=10). When we call <code>triple(5)</code>, it returns <code>15</code> (because 5\u00d73=15).</li> </ul> <p>Another Example: Function Composition</p> <p>Here's another mathematical example using higher-order functions for function composition:</p> <pre><code>// Higher-order function for function composition\nfunction compose(f, g) {\n    // Returning a new function\n    return function(x) {\n        return f(g(x));\n    };\n}\n\n// Simple mathematical functions\nfunction add2(x) {\n    return x + 2;\n}\n\nfunction square(x) {\n    return x * x;\n}\n\n// Using the compose function\nconst add2AndSquare = compose(square, add2);\n\n// Testing the composed function\nconsole.log(add2AndSquare(3)); // Output: 25\n</code></pre> <p>Explanation</p> <ul> <li>Higher-Order Function: <code>compose</code> is a higher-order function because it takes two functions (<code>f</code> and <code>g</code>) as arguments and returns a new function.</li> <li>Returned Function: The returned function takes a number (<code>x</code>) as an argument and applies <code>g</code> to <code>x</code>, then applies <code>f</code> to the result of <code>g(x)</code>.</li> <li>Simple Functions: <code>add2</code> adds 2 to its input, and <code>square</code> squares its input.</li> <li>Usage: We use <code>compose</code> to create a new function <code>add2AndSquare</code> which first adds 2 to the input and then squares the result.</li> <li>Testing: When we call <code>add2AndSquare(3)</code>, it returns <code>25</code> (because (3+2)\u00d7(3+2)=5\u00d75=25).</li> </ul> <p>Higher-order functions are powerful tools in functional programming, allowing you to create more flexible and reusable code by abstracting common patterns.</p> Warning <p>The two functions you've provided are quite different in both their structure and their behavior. Let's break down the differences:</p> <p>First Function: Higher-Order Function</p> <pre><code>function createMultiplier(factor) {\n    // Returning a new function\n    return function(number) {\n        return number * factor;\n    };\n}\n</code></pre> <p>Explanation:</p> <ul> <li>Higher-Order Function: This function is a higher-order function because it returns a new function.</li> <li>Returned Function: The returned function takes an argument <code>number</code> and multiplies it by factor.</li> <li>Usage: You can use this function to create specific multiplier functions that can be used multiple times with different inputs.</li> </ul> Example Usage<pre><code>const double = createMultiplier(2);\nconst triple = createMultiplier(3);\n\nconsole.log(double(5)); // Output: 10\nconsole.log(triple(5)); // Output: 15\n</code></pre> <p>Second Function: Simple Multiplication</p> <pre><code>function createMultiplier(factor) {\n    return factor * factor;\n}\n</code></pre> <p>Explanation:</p> <ul> <li>Simple Function: This function is not a higher-order function. It simply multiplies the <code>factor</code> by itself and returns the result.</li> <li>Immediate Result: The function returns the result of <code>factor * factor</code> immediately without returning another function.</li> <li>Usage: You use this function to get the square of a number.</li> </ul> Example Usage<pre><code>console.log(createMultiplier(2)); // Output: 4\nconsole.log(createMultiplier(3)); // Output: 9\n</code></pre> Differences: <ol> <li> <p>Function Type:</p> <ul> <li>First Function: A higher-order function that returns a new function.</li> <li>Second Function: A simple function that performs a calculation and returns the result immediately.</li> </ul> </li> <li> <p>Purpose:</p> <ul> <li>First Function: Designed to create and return a multiplier function that can be used to multiply different numbers by a specific factor.</li> <li>Second Function: Designed to return the square of the given factor.</li> </ul> </li> <li> <p>Usage:</p> <ul> <li>First Function: Can be used to create specific multiplier functions (e.g., doubling, tripling).</li> <li>Second Function: Can only be used to calculate the square of the given factor.</li> </ul> </li> </ol> <p>Summary:</p> <ul> <li>The first function (<code>createMultiplier(factor) { return function(number) { return number * factor; }; }</code>) is a higher-order function that returns a new function capable of multiplying a number by the specified factor.</li> <li>The second function (<code>createMultiplier(factor) { return factor * factor; }</code>) is a simple function that returns the square of the given factor.</li> </ul> <p>Each function serves a different purpose and is used in different contexts. The higher-order function is more flexible and can create various multiplier functions, while the simple function is limited to calculating the square of the input factor.</p>"},{"location":"frontend/js/core/high-order-function/#finale-example","title":"FINALE EXAMPLE","text":"javascript<pre><code>function createMultiplier(factor) {\n    // Returning a new function\n    return function(number) {\n        return number * factor;\n    };\n}\nconst double = createMultiplier(2);\nconsole.log(double(5));\n</code></pre>"},{"location":"frontend/js/core/high-order-function/#lets-clarify-where-5-and-2-fit-in","title":"Let's clarify where 5 and 2 fit in:","text":"<ul> <li> <p>Factor (<code>factor</code>): When you call <code>createMultiplier(2)</code>, <code>2</code> is passed as an argument to <code>createMultiplier</code>, which assigns it to the parameter <code>factor</code>. So, <code>factor</code> becomes <code>2</code> within the scope of the returned function.</p> </li> <li> <p>Number (<code>number</code>): When you call <code>double(5)</code>, <code>5</code> is passed as an argument to double, which is actually the function returned by <code>createMultiplier(2)</code>. Inside this function, <code>number</code> refers to <code>5</code> in this particular call.</p> </li> </ul>"},{"location":"frontend/js/core/js-exception-handling/","title":"Exception Handling","text":"<p>In JavaScript, the throw new Error(errorMessage); statement does not display the error on the web by itself. Instead, it creates an Error object with the provided errorMessage and then throws that error. This error will be caught by the nearest catch block in a try...catch structure.</p> Here\u2019s a breakdown of how it works: <ol> <li> <p>Error Creation and Throwing:</p> <ul> <li><code>throw new Error(errorMessage)</code>; creates a new <code>Error</code> object with the specified errorMessage.</li> <li>The <code>throw</code> statement then throws this Error object, which immediately exits the current function and passes the error to the nearest <code>catch</code> block.</li> </ul> </li> <li> <p>Error Handling in <code>catch</code>:</p> <ul> <li>If there is a <code>catch</code> block that matches this <code>Error</code>, the error is caught and can be handled appropriately (e.g., logging the error, dispatching an error action, displaying an error message to the user).</li> </ul> </li> <li> <p>Error Display on the Web:</p> <ul> <li>To show an error message to the user, you must explicitly handle and display it. This usually involves:<ul> <li>Catching the error and then displaying a message in the UI.</li> <li>Using a library or UI component to show user-friendly error messages (e.g., alert, modal, or notification).</li> </ul> </li> </ul> </li> </ol> <pre><code>// Action creator with error handling\nexport const actionForUpdateDailyDairy = (id, body) =&gt; {\n    return async(dispatch) =&gt; {\n        dispatch(init(DAILY_DAIRY.UPDATE_DAILY_DIARY));\n\n        try {\n            const response = await dailyDairyService.apiForDailyDiaryUpdate(id, body);\n            if(response.isSuccess) {\n                dispatch(success(DAILY_DAIRY.UPDATE_DAILY_DIARY, response.data));\n                return response.data;\n            } else {\n                const errorMessage = response.errorMessage || 'Unknown error occurred during the update';\n                dispatch(error(errorMessage));\n                throw new Error(errorMessage); // Throwing error to be caught by catch block\n            }\n        } catch (err) {\n            // Handling the error\n            const errorMessage = err.message || 'Unknown error occurred';\n            dispatch(error(errorMessage));\n            // Optionally show the error message in the UI\n            // e.g., displayNotification(errorMessage);\n        } finally {\n            dispatch(finish(DAILY_DAIRY.UPDATE_DAILY_DIARY));\n        }\n    }\n}\n</code></pre> Points to Note: <ol> <li> <p>Error Propagation:</p> <ul> <li>The error thrown is caught by the <code>catch</code> block, where you can handle it (e.g., dispatch an error action to update the UI).</li> </ul> </li> <li> <p>UI Error Display:</p> <ul> <li>To display an error message on the web, ensure that your <code>catch</code> block (or the part of the application handling errors) updates the UI or shows a message to the user.</li> </ul> </li> <li> <p>No Automatic Display:</p> <ul> <li>JavaScript does not automatically display error messages. You need to implement a mechanism to display errors if needed.</li> </ul> </li> </ol> <p>By correctly handling errors in the <code>catch</code> block, you can manage how errors are propagated and displayed in your application.</p> <p>Mastering JavaScript exception handling involves understanding how errors work, effectively using error-handling mechanisms, and implementing best practices to ensure robust and user-friendly applications. Here\u2019s a comprehensive guide to help you master JavaScript exception handling:</p> <ol> <li> <p>Understanding JavaScript Errors</p> <p>JavaScript errors are instances of the Error class and its subclasses:</p> <ul> <li>Error: Base class for all errors.</li> <li>TypeError: Indicates an operation was performed on a value of the wrong type.</li> <li>ReferenceError: Indicates a reference to an undefined variable.</li> <li>SyntaxError: Indicates a syntax mistake in code.</li> <li>RangeError: Indicates a value is out of range.</li> <li>EvalError: Indicates an error with the <code>eval()</code> function (rarely used).</li> </ul> </li> <li> <p>Basic Exception Handling</p> <p>Use <code>try...catch</code> blocks to handle exceptions:</p> <pre><code>try {\n    // Code that may throw an error\n    let result = riskyOperation();\n} catch (error) {\n    // Handle the error\n    console.error('Error occurred:', error.message);\n} finally {\n    // Code that always executes\n    console.log('Cleanup code');\n}\n</code></pre> <ul> <li>try: Contains code that might throw an error.</li> <li>catch: Handles the error if one occurs.</li> <li>finally: Executes code regardless of whether an error occurred.</li> </ul> </li> <li> <p>Throwing Errors</p> <p>You can throw your own errors using <code>throw</code>:</p> <pre><code>function validate(value) {\n    if (value &lt; 0) {\n        throw new RangeError('Value must be non-negative');\n    }\n    return value;\n}\n</code></pre> </li> <li> <p>Custom Error Classes</p> <p>Create custom error classes to represent specific error conditions:</p> <pre><code>class CustomError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = 'CustomError';\n    }\n}\n\nfunction doSomething() {\n    throw new CustomError('Something went wrong');\n}\n</code></pre> </li> </ol> Best Practices <ul> <li>Avoid Silent Failures: Always handle errors to avoid silent failures that can lead to unexpected behavior.</li> <li>Use Specific Errors: Throw specific error types where applicable to make debugging easier.</li> <li>Avoid Overuse of <code>try...catch</code>: Only use <code>try...catch</code> where necessary, as overuse can obscure issues.</li> </ul>"},{"location":"frontend/js/core/js-exception-handling/#reducer","title":"REDUCER","text":""},{"location":"frontend/js/core/js-exception-handling/#function","title":"FUNCTION","text":""},{"location":"frontend/js/core/js-exception-handling/#question-1","title":"Question 1:","text":"Question <pre><code>const handleTodaySaveDiary = () =&gt; {\n    console.log(\"data.items\", data.items);\n}\n\n&lt;Content\n    style={{\n        display: \"flex\",\n        justifyContent: \"end\",\n        paddingTop: \"8px\",\n    }}\n&gt;\n{!loading &amp;&amp; data != null &amp;&amp; !isEmpty(data.items) &amp;&amp; (\n    &lt;Button\n        type=\"primary\"\n        // disabled\n        // loading={loading}\n        onClick={handleTodaySaveDiary}\n        style={{\n            padding: \"0px 10px\"\n        }}\n    &gt;\n        Save\n    &lt;/Button&gt;\n)}\n&lt;/Content&gt;\n\n&lt;Modal\n    title=\"Basic Modal\"\n    visible={isModalOpen}\n    onOk={handleOk}\n    onCancel={handleCancel}\n    fotter={null}\n&gt;\n    &lt;Form\n        form={formToday}\n    &gt;\n        Today Form\n    &lt;/Form&gt;\n&lt;/Modal&gt;\n\n\n// data.items value\n\n{\n    \"totalCount\": 2,\n    \"items\": [\n    {\n        \"id\": \"5a618cd6-53d8-4d49-b0b9-23f1ef72a395\",\n        \"todoEventId\": \"cafba611-b13b-4881-8639-b7715257a430\",\n        \"dailyDairyDate\": \"2024-08-15T12:07:48.1704016\",\n        \"stutusId\": \"4de2c2e9-aed1-4b28-bec0-6e52ab148f87\",\n        \"statusName\": \"Start\",\n        \"userId\": \"73fc9457-6b63-6a4a-64de-39f960722731\",\n        \"userName\": \"admin_bbask\",\n        \"title\": \"OS\",\n        \"remarks\": \"KHALAS xcccpp\",\n        \"isActive\": true,\n        \"statusDto\": {\n        \"id\": \"4de2c2e9-aed1-4b28-bec0-6e52ab148f87\",\n        \"name\": \"Start\",\n        \"colorHexValue\": \"#6a71ad\",\n        \"colorFontHexValue\": \"#ffffff\"\n        }\n    },\n    {\n        \"id\": \"84970e8e-2d55-4703-b4a8-ce118cd2a363\",\n        \"todoEventId\": \"f83a16b1-3931-4b0f-b2ea-59a123e4b2af\",\n        \"dailyDairyDate\": \"2024-08-15T09:34:31.976906\",\n        \"stutusId\": \"6a4a2e83-c05a-4134-999b-fd211a546e86\",\n        \"statusName\": \"Completed\",\n        \"userId\": \"73fc9457-6b63-6a4a-64de-39f960722731\",\n        \"userName\": \"admin_bbask\",\n        \"title\": \"NEW TASK TODAY\",\n        \"remarks\": \"fsfafsdfdsfasdf  jkhjk sadfjasdfb sadasdf\\ndsds\",\n        \"isActive\": true,\n        \"statusDto\": {\n        \"id\": \"6a4a2e83-c05a-4134-999b-fd211a546e86\",\n        \"name\": \"Completed\",\n        \"colorHexValue\": \"#cbce91\",\n        \"colorFontHexValue\": \"#ffffff\"\n        }\n    }\n    ]\n}\n</code></pre> <p>Scenario: after click the handleTodaySaveDiary button if the data.items contains object which statusName is not Completed then open the modal and list the title and remarks description box to submit. if all the statusName is completed then donot open the modal.</p>"},{"location":"frontend/js/core/js-exception-handling/#solution-1","title":"SOLUTION 1:","text":"Question <p>To ensure that <code>handleAddUpdateDairy()</code> is only called if <code>actionForUpdateDailyDairy</code> completes successfully, you need to adjust your <code>handleOnFinish</code> function to properly handle errors from the asynchronous action. Currently, <code>handleAddUpdateDairy()</code> is called unconditionally after dispatching <code>actionForUpdateDailyDairy</code>, so you should modify the function to wait for <code>actionForUpdateDailyDairy</code> to complete and handle errors properly.</p> <p>Here's how you can adjust the handleOnFinish function:</p> <ol> <li> <p>Use <code>await</code> for asynchronous operations: Since <code>dispatch</code> is returning a promise, you should await the result of <code>dispatch(actionForUpdateDailyDairy(selectedRecordData?.id, body))</code> to handle errors effectively.</p> </li> <li> <p>Check the result of dispatch before calling <code>handleAddUpdateDairy()</code>: Only call <code>handleAddUpdateDairy()</code> if the update action was successful.</p> </li> </ol> <p>Here's the updated handleOnFinish function:</p> <pre><code>const handleOnFinish = async (values) =&gt; {\n    let body = {\n        statusId: values?.todoEventStatusId,\n        remarks: values?.remarks\n    };\n\n    try {\n        // Ensure dispatch returns a promise to await it\n        const result = await dispatch(actionForUpdateDailyDairy(selectedRecordData?.id, body));\n\n        // If the result was successful, proceed with handleAddUpdateDairy\n        if (result) {\n            handleAddUpdateDairy();\n        }\n    } catch (err) {\n        console.log(\"Error: \", err);\n    }\n}\n</code></pre> Explanation <ol> <li> <p>Await Dispatch: The <code>await dispatch(actionForUpdateDailyDairy(selectedRecordData?.id, body))</code> will pause execution until <code>actionForUpdateDailyDairy</code> has finished, allowing you to catch any errors that might be thrown during the dispatch.</p> </li> <li> <p>Conditional Call: <code>handleAddUpdateDairy()</code> is only called if the result from <code>actionForUpdateDailyDairy</code> indicates success. You may need to adjust the <code>actionForUpdateDailyDairy</code> action to ensure it returns a result that you can check, such as a boolean indicating success.</p> </li> <li> <p>Error Handling: The catch block will handle any errors thrown during the dispatch or the async operation itself.</p> </li> </ol> Important Note <p>Make sure that <code>actionForUpdateDailyDairy</code>'s promise resolves with a value you can check. If the action creator does not currently return a meaningful result, you might need to adjust it so that it does. For example, you could modify <code>actionForUpdateDailyDairy</code> to return <code>response.data</code> only when the operation is successful, and ensure that the error handling logic is correctly implemented.</p>"},{"location":"frontend/js/core/js-exception-handling/#solution-2","title":"SOLUTION 2:","text":"<p>To update your <code>handleOnFinish</code> function so that <code>handleAddUpdateDairy</code> is only called if there is no error in <code>actionForUpdateDailyDairy</code>, you'll need to handle the asynchronous nature of <code>dispatch</code>. You should await the result of <code>dispatch</code> and check for errors before proceeding. Here\u2019s how you can modify your code:</p> Updated handleOnFinish Function<pre><code>const handleOnFinish = async (values) =&gt; {\n    let body = {\n        statusId: values?.todoEventStatusId,\n        remarks: values?.remarks\n    };\n\n    try {\n        if (values?.todoEventStatusId) {\n            // Await the dispatch to ensure completion\n            await dispatch(actionForUpdateDailyDairy(selectedRecordData?.id, body));\n        }\n\n        // Only call handleAddUpdateDairy if dispatch was successful\n        handleAddUpdateDairy();\n    } catch (err) {\n        // Log error and handle it appropriately\n        console.log(\"Error: \", err);\n        // Optionally handle or display the error to the user\n    }\n};\n</code></pre> Explanation: <ol> <li> <p>Await Dispatch: The <code>await dispatch(actionForUpdateDailyDairy(selectedRecordData?.id, body))</code>; line ensures that you wait for the asynchronous action to complete. This means <code>handleAddUpdateDairy()</code> will only be called after <code>actionForUpdateDailyDairy</code> has finished.</p> </li> <li> <p>Conditional Call: <code>handleAddUpdateDairy()</code> is called after the <code>dispatch</code> promise resolves successfully. If <code>dispatch</code> throws an error or fails, the catch block will handle it, and <code>handleAddUpdateDairy()</code> will not be executed.</p> </li> <li> <p>Error Handling: The <code>catch</code> block catches any errors thrown during the dispatch process. You can log or handle these errors as needed.</p> </li> </ol> Additional Considerations: <ul> <li> <p>Action Return Values: Ensure that <code>actionForUpdateDailyDairy</code> is set up to correctly handle and throw errors if necessary. The action creator should be designed to handle success and failure cases.</p> </li> <li> <p>User Feedback: Depending on your UI needs, you might want to provide feedback to the user if an error occurs. This can be done using a UI library or custom error messaging.</p> </li> </ul> <p>With this approach, your code will properly handle the asynchronous operation and ensure that subsequent actions are only taken if the update is successful.</p>"},{"location":"frontend/js/core/js-exception-handling/#example","title":"Example","text":""},{"location":"frontend/js/core/js-exception-handling/#question-2","title":"Question 2:","text":"<ul> <li><code>onClick={handleTodaySaveDiary}</code>: Directly assigns the function to the <code>onClick</code> event, so it will be called when the button is clicked.</li> <li><code>onClick={() =&gt; handleTodaySaveDiary()}</code>: Uses an arrow function to call <code>handleTodaySaveDiary()</code> when the button is clicked. This is useful if you need to perform additional logic in the future.</li> </ul>"},{"location":"frontend/js/core/js-exception-handling/#button-code-snippit-example","title":"Button Code Snippit Example","text":"Example <pre><code>{!loading &amp;&amp; data != null &amp;&amp; !isEmpty(data.items) &amp;&amp; (\n    &lt;Button\n        type=\"primary\"\n        loading={loading}\n        onClick={() =&gt; console.log(\"hello world\", data?.items)}\n        style={{\n            padding: \"0px 10px\"\n        }}\n    &gt;\n        Save\n    &lt;/Button&gt;\n)}\n\n// or\n\n&lt;Button\n    // disabled\n    type=\"primary\"\n    loading={loading}\n    onClick={() =&gt; console.log(\"hello world\", data?.items)}\n    style={{\n        padding: \"0px 10px\"\n    }}\n&gt;\n    Save\n&lt;/Button&gt;\n</code></pre>"},{"location":"frontend/js/core/js-exception-handling/#use-content-for-layout","title":"use <code>Content</code> for Layout","text":"Note <pre><code>import { Layout } from \"antd\";\n\nconst { Content } = Layout;\n\n&lt;Content\n    style={{\n        display: \"flex\",\n        justifyContent: \"end\",\n        paddingTop: \"8px\",\n    }}\n&gt;\n    &lt;Button\n        // disabled\n        type=\"primary\"\n        loading={loading}\n        onClick={() =&gt; console.log(\"hello world\", data?.items)}\n        style={{\n            padding: \"0px 10px\"\n        }}\n    &gt;\n        Save\n    &lt;/Button&gt;\n&lt;/Content&gt;\n</code></pre>"},{"location":"frontend/js/core/js-exception-handling/#office-solve","title":"Office Solve","text":""},{"location":"frontend/js/core/js-exception-handling/#question-1_1","title":"Question 1","text":"Example CodeExplanationModified <p>To implement this scenario, you can filter data.items based on the statusName. If there are any items with statusName not equal to \"Completed\", the modal will open; otherwise, it will remain closed.</p> <p>Here's how you can achieve this:</p> Updated Code:<pre><code>const handleTodaySaveDiary = () =&gt; {\n    const incompleteItems = data.items.filter(item =&gt; item.statusName !== \"Completed\");\n\n    // Log items that are not completed\n    console.log(\"Incomplete Items:\", incompleteItems);\n\n    if (incompleteItems.length &gt; 0) {\n        // Open the modal\n        setIsModalOpen(true);\n    } else {\n        // All items are completed, do not open the modal\n        console.log(\"All items are completed, no modal needed\");\n    }\n};\n\n&lt;Content\n    style={{\n        display: \"flex\",\n        justifyContent: \"end\",\n        paddingTop: \"8px\",\n    }}\n&gt;\n{!loading &amp;&amp; data != null &amp;&amp; !isEmpty(data.items) &amp;&amp; (\n    &lt;Button\n        type=\"primary\"\n        onClick={handleTodaySaveDiary}\n        style={{\n            padding: \"0px 10px\"\n        }}\n    &gt;\n        Save\n    &lt;/Button&gt;\n)}\n&lt;/Content&gt;\n\n&lt;Modal\n    title=\"Incomplete Tasks\"\n    visible={isModalOpen}\n    onOk={handleOk}\n    onCancel={handleCancel}\n    footer={null}\n&gt;\n    &lt;Form form={formToday}&gt;\n        {data.items.filter(item =&gt; item.statusName !== \"Completed\").map(item =&gt; (\n            &lt;div key={item.id}&gt;\n                &lt;h3&gt;{item.title}&lt;/h3&gt;\n                &lt;p&gt;{item.remarks}&lt;/p&gt;\n                &lt;Form.Item\n                    name={`remarks_${item.id}`}\n                    label=\"Remarks\"\n                    rules={[{ required: true, message: 'Please enter remarks' }]}\n                &gt;\n                    &lt;Input.TextArea rows={4} defaultValue={item.remarks} /&gt;\n                &lt;/Form.Item&gt;\n            &lt;/div&gt;\n        ))}\n    &lt;/Form&gt;\n&lt;/Modal&gt;\n</code></pre> <ol> <li> <p><code>handleTodaySaveDiary</code> Function:</p> <ul> <li>Filters <code>data.items</code> to find objects where <code>statusName</code> is not \"Completed\".</li> <li>If there are any such objects, it opens the modal by setting <code>setIsModalOpen(true)</code>.</li> <li>Otherwise, it logs that all items are completed and the modal doesn't open.</li> </ul> </li> <li> <p>Modal Rendering:</p> <ul> <li>Inside the modal, we map over the filtered items (those that are not completed) and display the <code>title</code> and a <code>TextArea</code> input field pre-filled with the current <code>remarks</code>.</li> </ul> </li> </ol> <p>This way, you ensure that the modal only opens when there are incomplete tasks, and it provides an interface for the user to edit the <code>remarks</code> for those tasks.</p> <pre><code>const handleOk = () =&gt; {\n    // Submit the form when Ok is clicked\n    formToday.submit();\n};\n\nconst handleCancel = () =&gt; {\n    formToday.resetFields();\n    setIsModalOpen(false);\n};\n\nconst handleOnFinishFormModal = (values) =&gt; {\n    // Log the form values on form submission\n    console.log(\"Form Values Submitted: \", values);\n\n    // Close the modal after successful submission\n    setIsModalOpen(false);\n};\n</code></pre> Explanation: <ol> <li> <p>onFinish: This function (<code>handleOnFinishFormModal</code>) will be triggered when the form is successfully submitted. The submitted form values are captured in the <code>values</code> parameter.</p> </li> <li> <p>formToday.submit(): Inside <code>handleOk()</code>, calling <code>formToday.submit()</code> ensures that the form submission is triggered when the \"Ok\" button is clicked in the modal.</p> </li> <li> <p>footer={null}: Removed the default footer of the modal to prevent the default \"Ok\" and \"Cancel\" buttons, ensuring you have full control over when the form is submitted.</p> </li> </ol> <p>With this setup, when the modal is open, and the user fills in the remarks and clicks \"Ok,\" the form values will be logged to the console, and you can handle them as needed.</p> <pre><code>if (InomplteStatusItems.length &gt; 0) {\n    // Open the modal\n    setIsModalOpen(true);\n\n    //\n    const initialFormValues = {};\n    InomplteStatusItems.forEach(item =&gt; {\n        initialFormValues[`remarks_${item.id}`] = item.remarks || '';  // Set initial remarks or empty if not available\n    });\n    formToday.setFieldsValue(initialFormValues);\n} else {\n    // All items are completed, do not open the modal\n    console.log(\"All items are completed, no modal needed\");\n}\n</code></pre>"},{"location":"frontend/js/core/js-exception-handling/#reference","title":"Reference","text":"<ul> <li>Control flow and error handling: developer.mozilla</li> <li>JavaScript Errors: w3schools</li> </ul>"},{"location":"frontend/js/core/maps-and-sets/","title":"Maps and Sets","text":""},{"location":"frontend/js/core/maps-and-sets/#maps-and-sets-the-new-data-structures-on-the-block","title":"Maps and Sets <code>\u2014 The New Data-structures on the Block</code>","text":""},{"location":"frontend/js/core/maps-and-sets/#reference","title":"Reference","text":"<ul> <li>JavaScript Next by Raju Gandhi, pg: 81</li> </ul>"},{"location":"frontend/js/core/object-prototype/","title":"Object Prototype","text":""},{"location":"frontend/js/core/object-prototype/#objectprototype","title":"Object.prototype","text":"<p>In JavaScript, Object.prototype is the prototype object from which all other objects inherit their properties and methods, unless explicitly specified otherwise. It is the top of the prototype chain, meaning that any object created using a constructor function or an object literal will have Object.prototype in its prototype chain.</p>"},{"location":"frontend/js/core/object-prototype/#what-is-objectprototype","title":"What is Object.prototype?","text":"<ul> <li> <p>Prototype Chain:</p> <p>In JavaScript, objects can have a prototype, which is another object from which they inherit properties. The prototype of an object is accessible through the <code>__proto__</code> property (or <code>[[Prototype]]</code> in more formal terms).</p> </li> <li> <p>Inheritance:</p> <p><code>Object.prototype</code> is the final object in the prototype chain. It means that all properties and methods defined on <code>Object.prototype</code> are available to all other objects, unless those properties and methods are overridden further down the prototype chain.</p> </li> </ul>"},{"location":"frontend/js/core/object-prototype/#common-properties-and-methods-from-objectprototype","title":"Common Properties and Methods from <code>Object.prototype</code>","text":"<p>Object.prototype includes several methods and properties that are useful and commonly used:</p> <ol> <li> <p>hasOwnProperty:</p> <p>Checks if a property is a direct property of the object (not inherited).</p> <pre><code>const obj = { a: 1 };\nconsole.log(obj.hasOwnProperty('a')); // true\nconsole.log(obj.hasOwnProperty('toString')); // false\n</code></pre> </li> <li> <p>isPrototypeOf:</p> <p>Checks if an object exists in another object's prototype chain.</p> <pre><code>function Person() {}\nconst person = new Person();\nconsole.log(Person.prototype.isPrototypeOf(person)); // true\n</code></pre> </li> <li> <p>toString:</p> <p>Returns a string representation of the object.</p> <pre><code>const obj = { a: 1 };\nconsole.log(obj.toString()); // \"[object Object]\"\n</code></pre> </li> <li> <p>valueOf:</p> <p>Returns the primitive value of the specified object.</p> <pre><code>const obj = { a: 1 };\nconsole.log(obj.valueOf()); // { a: 1 }\n</code></pre> </li> </ol> <p>Prototype Chain Example</p>"},{"location":"frontend/js/core/object-prototype/#prototype-chain-example","title":"Prototype Chain Example","text":"<p>To better understand Object.prototype and the prototype chain, consider the following example:</p> <pre><code>const person = {\n    name: 'John',\n    greet: function() {\n        console.log('Hello, ' + this.name);\n    }\n};\n\n// Create a new object that inherits from person\nconst anotherPerson = Object.create(person);\nanotherPerson.name = 'Jane';\n\nanotherPerson.greet(); // Hello, Jane\n\n// Check the prototype chain\nconsole.log(Object.getPrototypeOf(anotherPerson) === person); // true\nconsole.log(Object.getPrototypeOf(person) === Object.prototype); // true\n</code></pre> <p>In this example:</p> <ol> <li>We define an object <code>person</code> with a property <code>name</code> and a method <code>greet</code>.</li> <li>We create a new object <code>anotherPerson</code> that inherits from person using Object.create.</li> <li>The <code>anotherPerson</code> object can access properties and methods from <code>person</code> because <code>person</code> is in its prototype chain.</li> <li>We verify the prototype chain using Object.getPrototypeOf.</li> </ol>"},{"location":"frontend/js/core/object-prototype/#customizing-objectprototype","title":"Customizing Object.prototype","text":"<p>While it is possible to add properties or methods to Object.prototypeit is generally discouraged== because it can lead to unexpected behavior and conflicts in your code, especially when working with third-party libraries. Modifying Object.prototype affects all objects, which can have unintended side effects.</p> <pre><code>Object.prototype.customMethod = function() {\n  console.log('This is a custom method.');\n};\n\nconst obj = {};\nobj.customMethod(); // This is a custom method.\n</code></pre> <p>In this example, the <code>customMethod</code> is added to Object.prototype, making it available to all objects. However, this practice should be used with caution.</p>"},{"location":"frontend/js/core/object-prototype/#summary","title":"Summary","text":"<ul> <li>Object.prototype is the top-level prototype object from which all other objects inherit properties and methods.</li> <li>It provides several built-in methods like <code>hasOwnProperty</code>, <code>isPrototypeOf</code>, <code>toString</code>, and <code>valueOf</code>.</li> <li>All objects in JavaScript have Object.prototype in their prototype chain unless explicitly specified otherwise.</li> <li>Modifying Object.prototype is possible but generally discouraged due to the potential for unintended side effects.</li> </ul>"},{"location":"frontend/js/core/object/","title":"Object","text":""},{"location":"frontend/js/core/object/#object","title":"Object","text":""},{"location":"frontend/js/core/object/#question","title":"Question","text":"<p>what is exactly object in programming language. why it is called the king in programming language. where does it exist. where does not it exist. how does it transfer in http protocal.\"</p> <p>An object in programming is an instance of a class that encapsulates both data and methods that operate on that data. Objects are fundamental building blocks in object-oriented programming (OOP) and represent real-world entities and concepts within the code.</p> <p>Tip</p> <p>Success</p> <p>Danger</p> <p>Example</p>"},{"location":"frontend/js/core/object/#why-is-an-object-called-the-king-in-programming","title":"Why is an Object Called the \"King\" in Programming?","text":"<ul> <li>Encapsulation: Objects bundle data and methods that operate on the data, ensuring a modular and organized code structure.</li> <li>Abstraction: Objects provide a simplified interface to interact with complex systems, hiding unnecessary details.</li> <li>Inheritance: Objects can inherit properties and methods from other objects, promoting code reuse and efficiency.</li> <li>Polymorphism**: Objects can take many forms, allowing methods to be used interchangeably across different classes.</li> </ul> <p>These principles make objects central to OOP, hence they are often referred to as the \"king\" in programming.</p>"},{"location":"frontend/js/core/object/#where-do-objects-exist","title":"Where Do Objects Exist?","text":"<ul> <li>Object-Oriented Programming Languages: Objects are fundamental in languages like <code>Java</code>, <code>C++</code>, <code>Python</code>, <code>Ruby</code>, and <code>JavaScript</code>.</li> <li>In Memory: At runtime, objects exist in a computer's memory, where they are instantiated, manipulated, and used by the program.</li> </ul>"},{"location":"frontend/js/core/object/#where-do-objects-not-exist","title":"Where Do Objects Not Exist?","text":"<ul> <li>Non-OOP Languages: In procedural programming languages like <code>C</code> (not C++), there is no concept of objects. Code is organized around procedures or functions.</li> <li>Static Resources: Objects do not exist in static resources like <code>plain text files</code>, simple scripts, or configuration files, which do not use OOP principles.</li> </ul>"},{"location":"frontend/js/core/object/#how-do-objects-transfer-in-http-protocol","title":"How Do Objects Transfer in HTTP Protocol?","text":"<p>Objects transfer in HTTP protocol typically <code>through serialization</code>, where the object's state is converted into a format that can be transmitted over the network. Common serialization formats include:</p> <ol> <li> <p>JSON (<code>JavaScript Object Notation</code>): Widely used due to its simplicity and readability.</p> json<pre><code>{\n    \"name\": \"Alice\",\n    \"age\": 30,\n    \"isMember\": true\n}\n</code></pre> </li> <li> <p>XML (<code>Extensible Markup Language</code>): More verbose than JSON but still commonly used.</p> xml<pre><code>&lt;person&gt;\n    &lt;name&gt;Alice&lt;/name&gt;\n    &lt;age&gt;30&lt;/age&gt;\n    &lt;isMember&gt;true&lt;/isMember&gt;\n&lt;/person&gt;\n</code></pre> </li> <li> <p>Binary Formats: <code>Protocol Buffers</code>, <code>Apache Avro</code>, or <code>MessagePack</code>, which are more efficient for data transfer but less human-readable.</p> </li> </ol> <p>The serialized object is included in the HTTP request or response body and transferred between the client and server.</p> HTTP Request Example:<pre><code>POST /api/users HTTP/1.1\nHost: example.com\nContent-Type: application/json\n\n{\n    \"name\": \"Alice\",\n    \"age\": 30,\n    \"isMember\": true\n}\n</code></pre> HTTP Response Example:<pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n    \"status\": \"success\",\n    \"data\": {\n        \"id\": 123,\n        \"name\": \"Alice\"\n    }\n}\n</code></pre>"},{"location":"frontend/js/core/object/#summary","title":"Summary","text":"<p>Objects are essential in OOP, providing a structured way to represent and manipulate data. They exist in memory and within OOP languages but not in non-OOP contexts. They transfer over HTTP through serialization into formats like JSON, XML, or binary.</p>"},{"location":"frontend/js/core/prototype/","title":"Prototype","text":""},{"location":"frontend/js/core/prototype/#prototype","title":"Prototype","text":""},{"location":"frontend/js/core/prototype/#objectprototype","title":"Object.prototype","text":"<ul> <li> <p>Base Prototype:</p> <p>Object.prototype is the prototype object from which all other objects inherit, unless explicitly specified otherwise. It is the root of the prototype chain for most objects.</p> </li> <li> <p>Properties and Methods:</p> <p>It includes methods and properties that are common to all objects, such as <code>toString()</code>, <code>valueOf()</code>, <code>hasOwnProperty()</code>, <code>isPrototypeOf()</code>, and <code>propertyIsEnumerable()</code>.</p> </li> <li> <p>Role:</p> <p>Any object created using an object literal or the Object constructor will have Object.prototype in its prototype chain.</p> </li> </ul> <p>Example</p> Function.prototypeString.prototypeNumber.prototypeBoolean.prototypeDate.prototypeRegExp.prototype <p>The prototype for all function objects. It includes methods like <code>apply()</code>, <code>call()</code>, and <code>bind()</code>.</p> <pre><code>function sayHello() {\n    console.log('Hello');\n}\n\nsayHello.call(); // Hello\n</code></pre> <p>The prototype for all string objects. It includes methods like <code>charAt()</code>, <code>indexOf()</code>, <code>toUpperCase()</code>, <code>toLowerCase()</code>, <code>substring()</code>, <code>slice()</code>, and <code>replace()</code>.</p> <pre><code>const str = 'hello';\nconsole.log(str.toUpperCase()); // HELLO\n</code></pre> <p>The prototype for all number objects. It includes methods like <code>toFixed()</code>, <code>toExponential()</code>, and <code>toPrecision()</code>.</p> <pre><code>const num = 123.456;\nconsole.log(num.toFixed(2)); // 123.46\n</code></pre> <p>The prototype for all boolean objects. It has methods like <code>toString()</code> and <code>valueOf()</code>.</p> <pre><code>const bool = true;\nconsole.log(bool.toString()); // true\n</code></pre> <p>The prototype for all date objects. It includes methods like <code>getDate()</code>, <code>getDay()</code>, <code>getFullYear()</code>, <code>getHours()</code>, and <code>toISOString()</code>.</p> <pre><code>const date = new Date();\nconsole.log(date.toISOString()); // Current date in ISO format\n</code></pre> <p>The prototype for all regular expression objects. It includes methods like <code>exec()</code>, <code>test()</code>, and properties like source.</p> <pre><code>const regex = /hello/;\nconsole.log(regex.test('hello world')); // true\n</code></pre>"},{"location":"frontend/js/core/prototype/#key-differences-and-summary","title":"Key Differences and Summary","text":"<ul> <li> <p>Purpose:</p> <p><code>Object.prototype</code> provides generic methods and properties for all objects, while Array.prototype provides specific methods and properties for array instances.</p> </li> <li> <p>Inheritance:</p> <p>All objects inherit from <code>Object.prototype</code>, but array instances additionally inherit from <code>Array.prototype</code>.</p> </li> <li> <p>Methods and Properties:</p> <p>The methods and properties on <code>Object.prototype</code>are applicable to all objects, whereas those on Array.prototype are specifically for arrays.</p> </li> </ul> <p>Understanding the prototype chain and how different prototypes provide different methods and properties is crucial for effective JavaScript programming. It helps in leveraging the full power of built-in objects and creating custom objects with shared behaviors.</p>"},{"location":"frontend/js/core/prototype/#prototype-chain-illustration","title":"Prototype Chain Illustration","text":"<p>Here\u2019s a simplified illustration of the prototype chain for these <code>built-in</code> objects:</p> <ol> <li> <p>Function:</p> <ul> <li><code>example.__proto__ === Function.prototype</code></li> <li><code>Function.prototype.__proto__ === Object.prototype</code></li> </ul> </li> <li> <p>String:</p> <ul> <li><code>str.__proto__ === String.prototype</code></li> <li><code>String.prototype.__proto__ === Object.prototype</code></li> </ul> </li> <li> <p>Array:</p> <ul> <li><code>arr.__proto__ === Array.prototype</code></li> <li><code>Array.prototype.__proto__ === Object.prototype</code></li> </ul> </li> <li> <p>Boolean:</p> <ul> <li><code>bool.__proto__ === Boolean.prototype</code></li> <li><code>Boolean.prototype.__proto__ === Object.prototype</code></li> </ul> </li> </ol> <p>Example of Prototype Chain</p> <pre><code>function example() {}\nconst str = 'hello';\nconst arr = [1, 2, 3];\nconst bool = true;\n\n// Checking the prototype chain\nconsole.log(Object.getPrototypeOf(example) === Function.prototype); // true\nconsole.log(Object.getPrototypeOf(Function.prototype) === Object.prototype); // true\n\nconsole.log(Object.getPrototypeOf(str) === String.prototype); // true\nconsole.log(Object.getPrototypeOf(String.prototype) === Object.prototype); // true\n\nconsole.log(Object.getPrototypeOf(arr) === Array.prototype); // true\nconsole.log(Object.getPrototypeOf(Array.prototype) === Object.prototype); // true\n\nconsole.log(Object.getPrototypeOf(bool) === Boolean.prototype); // true\nconsole.log(Object.getPrototypeOf(Boolean.prototype) === Object.prototype); // true\n</code></pre>"},{"location":"frontend/js/core/prototype/#__proto__","title":"<code>__proto__</code>","text":"<p>A hidden link that lets an object inherit properties and methods from another object.</p>"},{"location":"frontend/js/core/serialization/","title":"Serialization","text":""},{"location":"frontend/js/core/serialization/#serialization","title":"Serialization","text":""},{"location":"frontend/js/core/serialization/#question","title":"Question","text":"<p>why do we need to serailize to tranfer in http protocal? why does we can't transfers the direct object. what is the reason?\"</p> <p>Serialization is necessary to transfer objects over the HTTP protocol because HTTP is a text-based protocol that only understands text or binary data formats. Directly transferring an object as it exists in memory is not feasible due to several reasons:</p> Reasons for Serialization <ol> <li> <p>Incompatibility with HTTP Protocol: HTTP is designed to transfer data in text (ASCII or UTF-8) or binary format, not in the complex memory structures that objects are represented as within a running program.</p> </li> <li> <p>Language and Platform Independence: Serialization transforms objects into a standardized format that can be understood across different programming languages and platforms. Without serialization, the internal memory representation of an object in one language (e.g., Python) might not be understandable by another language (e.g., JavaScript).</p> </li> <li> <p>Security: Directly transferring raw memory data could expose sensitive information and increase the risk of security vulnerabilities. Serialization allows control over what data is included and how it is represented, enhancing security.</p> </li> <li> <p>Data Integrity and Structure: Serialization ensures that the data structure is preserved and can be accurately reconstructed. It converts complex objects into a structured format (like JSON or XML) that maintains the relationships between data fields.</p> </li> <li> <p>Efficiency and Performance: Serialized data can be optimized for transmission. Formats like JSON and Protocol Buffers are designed to be lightweight and efficient, reducing the amount of data transferred and improving performance.</p> </li> </ol> Why Direct Transfer of Objects is Not Feasible <ol> <li> <p>Memory Representation: Objects in memory contain pointers, memory addresses, and other metadata that are specific to the runtime environment. This low-level information is not meaningful outside the context of that environment.</p> </li> <li> <p>Endianness and Architecture Differences: Computers may have different endianness (byte order) and architecture (<code>32-bit</code> vs. <code>64-bit</code>), leading to differences in how data is stored in memory. Serialization abstracts these differences.</p> </li> <li> <p>Complex Object Graphs: Objects often reference other objects, creating complex graphs of interconnected data. Direct transfer would require duplicating the entire memory structure, which is impractical and error-prone.</p> </li> </ol> <p>Example</p>"},{"location":"frontend/js/core/serialization/#serialization-process","title":"Serialization Process","text":"<ol> <li> <p>Conversion to Text or Binary Format: The object is converted into a format like <code>JSON</code>, <code>XML</code>, or <code>Protocol Buffers</code>. This format represents the object's data in a standardized way.</p> </li> <li> <p>Transmission Over HTTP: The serialized data is included in the HTTP request or response body, allowing it to be transmitted over the network.</p> </li> <li> <p>Deserialization: On the receiving end, the data is converted back into an object, reconstructing the original data structure.</p> </li> </ol>"},{"location":"frontend/js/core/serialization/#example-of-serialization-and-transmission","title":"Example of Serialization and Transmission","text":""},{"location":"frontend/js/core/serialization/#json-serialization","title":"JSON Serialization","text":"Original Object (Python):<pre><code>user = {\"name\": \"Alice\", \"age\": 30, \"isMember\": True}\n</code></pre>"},{"location":"frontend/js/core/serialization/#serialized-json","title":"Serialized JSON:","text":"json<pre><code>{\n    \"name\": \"Alice\",\n    \"age\": 30,\n    \"isMember\": true\n}\n</code></pre>"},{"location":"frontend/js/core/serialization/#http-request","title":"HTTP Request:","text":"http<pre><code>POST /api/users HTTP/1.1\nHost: example.com\nContent-Type: application/json\n\n{\n    \"name\": \"Alice\",\n    \"age\": 30,\n    \"isMember\": true\n}\n</code></pre>"},{"location":"frontend/js/core/serialization/#deserialization-javascript","title":"Deserialization (JavaScript):","text":"javascript<pre><code>let user = JSON.parse('{\"name\": \"Alice\", \"age\": 30, \"isMember\": true}');\n</code></pre>"},{"location":"frontend/js/core/serialization/#conclusion","title":"Conclusion","text":"<p>Serialization is essential for transferring objects over the HTTP protocol because it converts objects into a text or binary format that is compatible with HTTP, ensures language and platform independence, and maintains data integrity and security. Direct transfer of objects is not feasible due to the complexity of memory representations and the need for standardized data formats.</p>"},{"location":"frontend/js/core/spread-vs-rest-operator/","title":"Spread vs Rest Operator","text":""},{"location":"frontend/js/core/spread-vs-rest-operator/#spread-vs-rest-polar-opposite-twins","title":"Spread vs. Rest <code>\u2014 Polar Opposite Twins</code>","text":"<p>One will have observed that the syntax for the rest parameter and the spread operator is identical, but their behavior is the exact opposite of one another. The rest parameter \u201ccollects\u201d all the unaccounted arguments supplied to a function into an array, while the spread operator extracts all the elements out of an array. What differentiates what the ... syntax does depends on the invocation context. ... only acts as the rest parameter when an assignment happens, and if not, then it acts as a spread operator. This contradiction can be both interesting and disconcerting at the same time:</p> <p>Differences Between Spread and Rest</p> <ol> <li> <p>Spread Operator: Expands an array or object into individual elements.</p> <ul> <li>Example: <code>...array</code></li> </ul> </li> <li> <p>Rest Operator: Collects multiple elements into a single array.</p> <ul> <li>Example: <code>...args</code></li> </ul> </li> </ol> <p>Tip</p>"},{"location":"frontend/js/core/spread-vs-rest-operator/#destructuring","title":"Destructuring","text":"Array DestructuringObject DestructuringCombination"},{"location":"frontend/js/core/spread-vs-rest-operator/#reference","title":"Reference","text":"<ul> <li>JavaScript Next by Raju Gandhi, pg: 48</li> </ul>"},{"location":"frontend/js/core/topic/","title":"Topic","text":"<p>Mastering JavaScript requires a deep understanding of both its fundamental concepts and advanced topics. Here are some key areas to focus on, along with some hidden depths you should explore:</p>"},{"location":"frontend/js/core/topic/#core-concepts","title":"Core Concepts","text":"<ol> <li> <p>Data Types and Structures</p> <ul> <li>Primitive types and their behavior.</li> <li>Objects, arrays, and their methods.</li> <li>Map and Set objects.</li> </ul> </li> <li> <p>Functions</p> <ul> <li>Function declarations, expressions, and arrow functions.</li> <li>Scope, closures, and lexical scoping.</li> <li>Higher-order functions and callbacks.</li> <li>The <code>this</code> keyword and context binding.</li> </ul> </li> <li> <p>Asynchronous Programming</p> <ul> <li>Callbacks, promises, and async/await.</li> <li>Event loop and concurrency model.</li> <li>Error handling in asynchronous code.</li> </ul> </li> </ol>"},{"location":"frontend/js/core/topic/#advanced-topics","title":"Advanced Topics","text":"<ol> <li> <p>Prototypes and Inheritance</p> <ul> <li>Prototypal inheritance and the prototype chain.</li> <li>ES6 class syntax and how it relates to prototypes.</li> <li><code>Object.create</code> and inheritance patterns.</li> </ul> </li> <li> <p>Execution Context and Hoisting</p> <ul> <li>Execution context and the call stack.</li> <li>Variable and function hoisting.</li> <li>Temporal dead zone (TDZ) with <code>let</code> and <code>const</code>.</li> </ul> </li> <li> <p>Closures and Lexical Scope</p> <ul> <li>Understanding closures and their applications.</li> <li>Practical uses of closures in module patterns and function factories.</li> </ul> </li> <li> <p>Modules and Module Bundlers</p> <ul> <li>ES6 modules: import and export.</li> <li>Module patterns in older JavaScript (CommonJS, AMD).</li> <li>Using module bundlers like Webpack, Parcel, and Rollup.</li> </ul> </li> <li> <p>Event Handling and DOM Manipulation</p> <ul> <li>Event delegation and propagation (bubbling and capturing).</li> <li>Modern DOM APIs and manipulation techniques.</li> <li>Understanding and handling browser events.</li> </ul> </li> </ol>"},{"location":"frontend/js/core/topic/#deep-dive-topics","title":"Deep Dive Topics","text":"<ol> <li> <p>Memory Management and Performance</p> <ul> <li>Garbage collection and memory leaks.</li> <li>Optimizing performance: profiling and benchmarking.</li> <li>Understanding V8 engine optimizations.</li> </ul> </li> <li> <p>Design Patterns</p> <ul> <li>Common JavaScript design patterns (e.g., Singleton, Factory, Observer).</li> <li>Applying design patterns to real-world problems.</li> </ul> </li> <li> <p>Type Systems and Type Checking</p> <ul> <li>Dynamic vs. static typing.</li> <li>Using TypeScript for type safety.</li> <li>Flow and other type checkers.</li> </ul> </li> <li> <p>Testing</p> <ul> <li>Unit testing, integration testing, and end-to-end testing.</li> <li>Popular testing frameworks (<code>Jest</code>, <code>Mocha</code>, <code>Chai</code>, <code>Cypress</code>).</li> <li>Test-driven development (TDD) practices.</li> </ul> </li> <li> <p>Tooling and Build Processes</p> <ul> <li>Modern JavaScript tooling: ESLint, Prettier, Babel.</li> <li>Setting up and configuring build processes with tools like Webpack.</li> <li>Continuous integration and deployment (CI/CD) for JavaScript projects.</li> </ul> </li> </ol>"},{"location":"frontend/js/core/topic/#hidden-depths","title":"Hidden Depths","text":"<ol> <li> <p>Symbol and Meta-programming</p> <ul> <li>Using symbols to create unique property keys.</li> <li>Understanding well-known symbols and their uses.</li> <li>Proxy objects and the Reflect API for metaprogramming.</li> </ul> </li> <li> <p>Iterators and Generators</p> <ul> <li>Custom iterators and the iterable protocol.</li> <li>Generator functions and the yield keyword.</li> <li>Using generators for asynchronous control flow.</li> </ul> </li> <li> <p>Concurrency and Parallelism</p> <ul> <li>Web Workers for parallel processing.</li> <li>Understanding and using SharedArrayBuffer and Atomics.</li> <li>Concurrency models in JavaScript.</li> </ul> </li> <li> <p>Advanced Asynchronous Patterns</p> <ul> <li>Async iterators and generators.</li> <li>Using <code>Promise.all</code>, <code>Promise.race</code>, and <code>Promise.allSettled</code>.</li> <li>Managing complex async workflows with libraries like RxJS.</li> </ul> </li> <li> <p>Understanding the Event Loop and Microtasks</p> <ul> <li>Detailed workings of the event loop.</li> <li>Difference between macro-tasks and micro-tasks.</li> <li>Practical implications for writing efficient asynchronous code.</li> </ul> </li> </ol>"},{"location":"frontend/js/core/topic/#practical-application","title":"Practical Application","text":"<ul> <li>Building Projects: Apply what you learn by building real-world projects.</li> <li>Contributing to Open Source: Contribute to JavaScript libraries and frameworks.</li> <li>Reading and Understanding Source Code: Study the source code of popular libraries and frameworks.</li> </ul> <p>Mastering JavaScript is a journey that involves both understanding the theory and applying it in practical scenarios. By delving into these topics, you will gain a comprehensive and deep understanding of JavaScript, enabling you to write efficient, maintainable, and robust code.</p> Abstract <p>To gain a deep understanding of JavaScript, the main approach is to focus on mastering its core concepts and advanced features. Here's a structured plan to achieve that:</p> <ol> <li> <p>Fundamentals:</p> <ul> <li>Variables and Data Types: Understand var, let, const, and data types (number, string, boolean, object, undefined, null).</li> <li>Functions: Learn about function declarations, expressions, arrow functions, and IIFE (Immediately Invoked Function Expressions).</li> <li>Control Structures: Master if statements, loops (for, while, do-while), and switch statements.</li> </ul> </li> <li> <p>Advanced Concepts:</p> <ul> <li>Closures: Understand how closures work and how they enable functions to have private variables.</li> <li>Prototypes and Inheritance: Learn about prototype chains, inheritance models, and how to create objects using constructor functions and class syntax.</li> <li>Asynchronous Programming: Master callbacks, promises, async/await, and event loop mechanisms.</li> <li>Scope and Hoisting: Understand the scope (global, local, block) and hoisting behaviors in JavaScript.</li> </ul> </li> <li> <p>JavaScript in the Browser:</p> <ul> <li>DOM Manipulation: Learn how to select, traverse, and manipulate DOM elements.</li> <li>Event Handling: Understand how to handle user interactions and events.</li> <li>Browser APIs: Explore key browser APIs like fetch, localStorage, and sessionStorage.</li> </ul> </li> <li> <p>Modern JavaScript (ES6+):</p> <ul> <li>Learn new syntax and features introduced in ES6 and later versions, including template literals, destructuring, spread/rest operators, modules, and enhanced object literals.</li> </ul> </li> <li> <p>Tooling and Ecosystem:</p> <ul> <li>Node.js: Understand server-side JavaScript and how to build backend applications with Node.js.</li> <li>Build Tools: Learn about build tools like Webpack, Babel, and task runners like Gulp or Grunt.</li> <li>Testing: Master JavaScript testing frameworks like Jest, Mocha, or Jasmine.</li> </ul> </li> <li> <p>Best Practices:</p> <ul> <li>Code Organization: Learn how to write modular, maintainable, and reusable code.</li> <li>Performance Optimization: Understand techniques for optimizing JavaScript performance.</li> <li>Security: Learn common security practices to prevent vulnerabilities like XSS and CSRF.</li> </ul> </li> <li> <p>Projects and Real-world Applications:</p> <ul> <li>Build projects that challenge you to apply what you've learned.</li> <li>Contribute to open-source projects or collaborate on team projects to gain practical experience.</li> </ul> </li> </ol> <p>By systematically studying these areas, practicing through projects, and keeping up with the latest advancements in JavaScript, you'll be able to develop a deep and comprehensive understanding of the language.</p>"},{"location":"frontend/js/ecmascript/es6/","title":"es6","text":""},{"location":"frontend/js/ecmascript/es6/#javascript-es6","title":"JavaScript ES6","text":"<p>ES6 is a significant update. It contains a whole host of new features for JavaScript, almost two dozen in total. JavaScript written in ES6 is tangibly different than JavaScript written in ES5.</p> <p>The most important ECMAScript version is generally considered to be <code>ECMAScript 2015 (ES6)</code>. Here are the reasons why ES6 is so significant:</p>"},{"location":"frontend/js/ecmascript/es6/#impact-of-es6","title":"Impact of ES6:","text":"<ul> <li>Modern JavaScript: ES6 transformed JavaScript into a more modern, powerful, and developer-friendly language.</li> <li>Tooling and Frameworks: Many modern JavaScript frameworks and libraries (e.g., React, Angular, Vue.js) heavily utilize ES6 features.</li> <li>Backward Compatibility: Tools like Babel allow developers to write ES6+ code while maintaining compatibility with older browsers.</li> <li>Standardization: Set the foundation for annual updates to the ECMAScript specification, ensuring continuous improvement of the language.</li> </ul> <p>Due to these significant enhancements and its foundational role in modern JavaScript development, ECMAScript 2015 (ES6) is often regarded as the most important ECMAScript version.</p>"},{"location":"frontend/js/ecmascript/es6/#key-features-of-es6","title":"Key Features of ES6:","text":"React <p>There are two ways to declare React components:</p> <ol> <li>ES6 classes</li> <li>Function components</li> </ol> <p>An example of using an ES6 class:</p> <pre><code>class HelloWorld extends React.Component {\n    render() { return &lt;p&gt;Hello, world!&lt;/p&gt;; }\n}\n</code></pre> <p>The same component written in a \u201cfunctional component\u201d style:</p> <pre><code>function HelloWorld() {\n    return &lt;p&gt;Hello, world!&lt;/p&gt;;\n}\n</code></pre> <p>At the time of writing, both types of declarations are in widespread use. </p> <p>While they both do essentially the same thing, there are some important differences that we\u2019ll get to later in the book.</p> <p>We\u2019ll be using ES6 class components through much of the book, but we\u2019ll be using function components from time-to-time as well. While it might seem cleaner to just pick one, you\u2019ll encounter (and use) both in your real-world work. So we\u2019ll cover both.</p> <ul> <li>Fullstack React The Complete Guide to ReactJS and Friends by Anthony Accomazzo :21</li> </ul>"},{"location":"frontend/js/function/advanced-concept/","title":"Advanced","text":"Key Concept to Remember <p>Arrow functions lexically bind <code>this</code> from their surrounding scope. This means they do not have their own <code>this</code> context, making them ideal for preserving this in callbacks and asynchronous code without additional binding.</p> <p>In traditional (general) functions, the binding of <code>this</code> depends on the context in which the function is invoked. </p>"},{"location":"frontend/js/function/advanced-concept/#advanced-concepts","title":"Advanced Concepts","text":"<p>Here are some advanced function-related topics in JavaScript:</p> <ol> <li> <p>Anonymous Functions and Function Expressions</p> <p>Functions don\u2019t always need names. An anonymous function can be used in situations where a function doesn\u2019t need to be reused.</p> <pre><code>const greet = function(name) {\n    return `Hello, ${name}!`;\n};\nconsole.log(greet('Alice')); // Outputs: Hello, Alice!\n</code></pre> </li> <li> <p>Arrow Functions</p> <p>Arrow functions offer a shorter syntax and do not bind their own this. They are especially useful for simple functions.</p> <pre><code>const multiply = (x, y) =&gt; x * y;\nconsole.log(multiply(4, 5)); // Outputs: 20\n</code></pre> <p>Note: Arrow functions do not have their own this context.</p> </li> <li> <p>Higher-Order Functions</p> <p>A higher-order function is a function that takes another function as an argument or returns a function.</p> <pre><code>function higherOrderFunction(callback) {\n    return function(value) {\n        return callback(value);\n    };\n}\n\nconst square = higherOrderFunction(x =&gt; x * x);\nconsole.log(square(5)); // Outputs: 25\n</code></pre> </li> <li> <p>Closures</p> <p>Closures are functions that capture the lexical environment in which they are defined, allowing them to access variables from an outer scope even after that outer function has finished executing.</p> <pre><code>function createCounter() {\n    let count = 0;\n    return function() {\n        count += 1;\n        return count;\n    };\n}\n\nconst counter = createCounter();\nconsole.log(counter()); // Outputs: 1\nconsole.log(counter()); // Outputs: 2\n</code></pre> </li> <li> <p>Currying and Partial Application</p> <p><code>Currying</code> transforms a function that takes multiple arguments into a sequence of functions each taking a single argument. <code>Partial</code> application involves fixing some arguments of a function and generating a new function.</p> Currying<pre><code>function multiply(a) {\n    return function(b) {\n        return a * b;\n    };\n}\n\nconst multiplyBy2 = multiply(2);\nconsole.log(multiplyBy2(5)); // Outputs: 10\n</code></pre> Partial Application<pre><code>function add(a, b, c) {\n    return a + b + c;\n}\n\nfunction partialAdd(a) {\n    return function(b, c) {\n        return add(a, b, c);\n    };\n}\n\nconst add5 = partialAdd(5);\nconsole.log(add5(3, 2)); // Outputs: 10\n</code></pre> </li> <li> <p>Generators</p> <p>Generators are functions that can be paused and resumed, allowing for more complex iteration patterns.</p> <pre><code>function* countUpTo(max) {\n    let count = 1;\n    while (count &lt;= max) {\n        yield count++;\n    }\n}\n\nconst counter = countUpTo(3);\nconsole.log(counter.next().value); // Outputs: 1\nconsole.log(counter.next().value); // Outputs: 2\nconsole.log(counter.next().value); // Outputs: 3\nconsole.log(counter.next().value); // Outputs: undefined\n</code></pre> </li> <li> <p>Async Functions and Promises</p> <p>Async functions simplify working with asynchronous code by allowing you to use <code>await</code> to pause execution until a promise is resolved.</p> <pre><code>async function fetchData() {\n    const response = await fetch('https://api.example.com/data');\n    const data = await response.json();\n    return data;\n}\n\nfetchData().then(data =&gt; console.log(data));\n</code></pre> </li> </ol>"},{"location":"frontend/js/function/advanced-concept/#hidden-facts","title":"Hidden Facts","text":"<ul> <li>Functions Are Objects: Functions in JavaScript are first-class objects, meaning they can have properties and methods.</li> <li>Function Hoisting: Function declarations are hoisted to the top of their scope, meaning they can be used before they are defined.</li> <li><code>arguments</code> Object: Regular functions have access to an <code>arguments</code> object that contains all the passed arguments.</li> <li>Function Constructor: Functions can also be created using the <code>Function</code> constructor, though it's less common and can be less secure.</li> </ul> <pre><code>const sum = new Function('a', 'b', 'return a + b;');\nconsole.log(sum(1, 2)); // Outputs: 3\n</code></pre> <p>Mastering these concepts will greatly enhance your JavaScript skills and help you write more efficient, elegant code.</p> Implement in Real Projects <p>Apply your knowledge in real-world projects:</p> <ol> <li>Refactor Code: Use advanced functions to improve existing codebases. For instance, refactor callback-heavy code to use Promises and async/await.</li> <li>Build Libraries: Create libraries or utilities that leverage these advanced concepts. For example, build a custom function library using higher-order functions and currying.</li> <li>Contribute to Open Source: Work on open-source projects where these concepts are used. This will expose you to practical use cases and diverse coding styles.</li> </ol>"},{"location":"frontend/js/function/advanced-concept/#why-these-concepts-are-important","title":"Why These Concepts Are Important","text":"<p>Performance Optimization: Advanced functions like currying and partial application can optimize performance by reducing redundant computations. Enhanced Code Readability: Functions like arrow functions and higher-order functions can make code more concise and easier to understand. Maintainability: Closures and generators help manage state and handle complex logic in a manageable way, making the codebase easier to maintain. Improved Asynchronous Handling: Async/await provides a more straightforward way to handle asynchronous operations compared to traditional callback methods. Functional Programming Paradigms: Embracing functional programming techniques can lead to more predictable, reliable, and testable code.</p>"},{"location":"frontend/js/function/arrow-example/","title":"Arrow Example","text":"<p>In React, whether you use direct function references or arrow functions for event handlers can impact performance and behavior in different ways. </p> <p>Here\u2019s a breakdown of why you might choose one approach over the other:</p> Direct Reference<pre><code>const handleClickButton1 = () =&gt; console.log('Button 1 clicked');\nconst handleClickButton2 = () =&gt; console.log('Button 2 clicked');\n\nreturn (\n  &lt;div&gt;\n    &lt;button onClick={handleClickButton1}&gt;Button 1&lt;/button&gt;\n    &lt;button onClick={handleClickButton2}&gt;Button 2&lt;/button&gt;\n  &lt;/div&gt;\n);\n</code></pre> Arrow Function for Argument Passing<pre><code>const handleClickButtonWithData = (data) =&gt; console.log('Button clicked with data:', data);\n\nreturn (\n  &lt;div&gt;\n    &lt;button \n        onClick={() =&gt; handleClickButtonWithData(recordData)}\n    &gt;Button with Data&lt;/button&gt;\n  &lt;/div&gt;\n);\n</code></pre>"},{"location":"frontend/js/function/arrow-example/#summary","title":"Summary","text":"<ul> <li>Use direct function references for simplicity and better performance if no arguments are needed.</li> <li>Use arrow functions when you need to pass arguments or need more dynamic behavior for the handler. This approach ensures that your code remains efficient and maintainable while accommodating different use cases for event handling.</li> </ul> <pre><code>import React from 'react';\n\nconst MyComponent = () =&gt; {\n  // General function that takes data as a parameter\n  const handleClickButtonWithData = (data) =&gt; {\n    console.log('Button clicked with data:', data);\n  };\n\n  // Example data\n  const recordData = { id: 1, name: 'Sample Record' };\n\n  return (\n    &lt;div&gt;\n      {/* Using an arrow function to pass data to the general function */}\n      &lt;button onClick={() =&gt; handleClickButtonWithData(recordData)}&gt;Button with Data&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default MyComponent;\n</code></pre>"},{"location":"frontend/js/function/arrow-function/","title":"Arrow Functions","text":""},{"location":"frontend/js/function/arrow-function/#arrow-functions-and-this-a-comprehensive-guide-to-context-in-modern-javascript","title":"Arrow Functions and <code>this</code>: A Comprehensive Guide to Context in Modern JavaScript","text":"<p>Understanding how arrow functions affect the this context in JavaScript is crucial for writing accurate and effective code. </p> <p>Here\u2019s a deep dive into the topic:</p> Key Concept to Remember <p>Arrow functions lexically bind <code>this</code> from their surrounding scope. This means they do not have their own <code>this</code> context, making them ideal for preserving this in callbacks and asynchronous code without additional binding.</p> <p>In traditional (general) functions, the binding of <code>this</code> depends on the context in which the function is invoked. </p>"},{"location":"frontend/js/function/arrow-function/#what-is-this","title":"What is this?","text":"<p>In JavaScript, this is a special keyword that refers to the context in which a function is executed. Its value depends on how the function is called.</p>"},{"location":"frontend/js/function/arrow-function/#in-different-contexts","title":"In Different Contexts:","text":"<ul> <li>Global Context: In the global context, <code>this</code> refers to the global object (<code>window</code> in browsers, <code>global</code> in Node.js).</li> <li>Object Method: When a function is a method of an object, <code>this</code> refers to the object the method is called on.</li> <li>Constructor Function: When a function is used as a constructor (with the <code>new</code> keyword), <code>this</code> refers to the newly created instance.</li> <li>Event Handlers: In event handlers, <code>this</code> refers to the element that triggered the event.</li> <li>Arrow Functions: Arrow functions have a unique behavior regarding <code>this</code>.</li> </ul>"},{"location":"frontend/js/function/arrow-function/#arrow-functions-and-this","title":"Arrow Functions and this","text":"<p>Arrow functions were introduced in ECMAScript 6 (ES6) and have a distinct behavior compared to regular functions:</p> <ol> <li> <p>Lexical <code>this</code> Binding: Arrow functions do not have their own <code>this</code> context. Instead, they inherit <code>this</code> from the surrounding (lexical) scope at the time they are defined.</p> <pre><code>function Timer() {\n    this.seconds = 0;\n    setInterval(() =&gt; {\n        this.seconds += 1;\n        console.log(this.seconds);\n    }, 1000);\n}\n\nconst timer = new Timer();\n// Logs: 1, 2, 3, ...\n</code></pre> <p>In this example, the arrow function inside <code>setInterval</code> uses <code>this</code> from the <code>Timer</code> function scope. If we used a regular function instead, <code>this</code> would refer to the global object or be undefined in strict mode, not the <code>Timer</code> instance.</p> </li> <li> <p>No <code>this</code> Binding Override: Unlike regular functions, arrow functions cannot have their <code>this</code> value overridden with methods like call, apply, or bind.</p> <pre><code>const obj = {\n    value: 10,\n    regularFunction: function() {\n        console.log(this.value);\n    },\n    arrowFunction: () =&gt; {\n        console.log(this.value);\n    }\n};\n\nobj.regularFunction(); // Logs: 10\nobj.arrowFunction();  // Logs: undefined (or the value of `this.value` in the global scope, which is likely `undefined`)\n</code></pre> <p>Here, <code>regularFunction</code> has <code>this</code> bound to <code>obj</code>, whereas <code>arrowFunction</code> has <code>this</code> bound to the <code>surrounding context</code> (which is the global scope in this case).</p> </li> </ol>"},{"location":"frontend/js/function/arrow-function/#why-do-we-need-arrow-functions","title":"Why Do We Need Arrow Functions?","text":"<ol> <li> <p>Simplify Code: Arrow functions provide a more concise syntax, especially useful for small functions.</p> <pre><code>const add = (a, b) =&gt; a + b;\n</code></pre> </li> <li> <p>Preserve <code>this</code> Context: In scenarios where <code>this</code> needs to be consistent across nested functions (like callbacks or event handlers), arrow functions are helpful.</p> <pre><code>class MyClass {\n    constructor() {\n        this.value = 5;\n    }\n\n    increment() {\n        setTimeout(() =&gt; {\n            this.value += 1;\n            console.log(this.value); // Correctly logs updated value\n        }, 1000);\n    }\n}\n\nconst instance = new MyClass();\ninstance.increment();\n</code></pre> </li> <li> <p>Avoid Common Pitfalls: Traditional functions can cause confusion when used as methods or callbacks due to <code>this</code> binding issues. Arrow functions mitigate these issues by keeping the <code>this</code> context consistent with the lexical scope.</p> </li> <li> <p>Functional Programming: Arrow functions align with functional programming practices by allowing cleaner and more predictable function behavior.</p> </li> </ol> Key Points to Remember <ul> <li>No Own <code>this</code>: Arrow functions do not create their own <code>this</code>. They inherit <code>this</code> from the surrounding context at the time they are defined.</li> <li>Use Cases: Use arrow functions when you need a short function with no special <code>this</code> context or when you want to preserve the <code>this</code> value from the outer scope.</li> <li>Limitations: Avoid using arrow functions as methods in objects or constructors where you need <code>this</code> to refer to the object or the instance.</li> </ul>"},{"location":"frontend/js/function/arrow-function/#summary","title":"Summary","text":"<p>Arrow functions provide a more predictable and concise way to handle <code>this</code> in JavaScript, making them especially useful in scenarios involving callbacks and asynchronous code. They simplify function syntax while preserving the lexical scope of <code>this</code>, avoiding common pitfalls associated with traditional function behavior. Understanding and leveraging these characteristics can help you write more maintainable and bug-free code.</p>"},{"location":"frontend/js/function/arrow-function/#hidden-facts-of-arrow-function","title":"Hidden Facts of Arrow Function","text":"<ol> <li> <p>No <code>prototype</code> Property</p> <p>Arrow functions do not have a <code>prototype</code> property. This means you cannot use them to create prototype-based inheritance.</p> <pre><code>const MyFunction = () =&gt; {};\nconsole.log(MyFunction.prototype); // Logs: undefined\n</code></pre> </li> </ol> Hidden Facts About Arrow Functions <ol> <li> <p>Lexical <code>this</code> Binding**: Arrow functions inherit <code>this</code> from their surrounding context, meaning they don\u2019t have their own <code>this</code>. Useful for preserving <code>this</code> in callbacks.</p> </li> <li> <p>No <code>arguments</code> Object: Arrow functions don\u2019t have their own <code>arguments</code> object. They inherit <code>arguments</code> from their outer function.</p> </li> <li> <p>Not Constructors: Arrow functions cannot be used as constructors and cannot be called with <code>new</code>.</p> </li> <li> <p>No <code>super</code> Keyword: Arrow functions do not have a <code>super</code> keyword, so they can\u2019t be used to call methods from a superclass.</p> </li> <li> <p>No <code>prototype</code> Property: Arrow functions do not have a prototype property, so they can\u2019t be used for prototypal inheritance.</p> </li> <li> <p>Not Suitable for Object Methods: Arrow functions are not ideal for defining methods on objects where <code>this</code> needs to refer to the object itself.</p> </li> <li> <p>Syntax Simplicity: They offer a concise syntax but lack flexibility in some complex scenarios, such as method chaining.</p> </li> <li> <p><code>this</code> Context in Classes: Arrow functions can be used in class constructors to preserve the <code>this</code> context, but not for all class-specific operations.</p> </li> </ol> <p>These points highlight the unique behavior and limitations of arrow functions, helping you use them effectively in JavaScript.</p>"},{"location":"frontend/js/function/intro/","title":"Intro","text":"<p>In JavaScript, a function is a fundamental building block of the language. It is a reusable piece of code that performs a specific task. Functions help in organizing code, improving reusability, and making programs easier to understand and maintain.</p>"},{"location":"frontend/js/function/intro/#what-is-a-function","title":"What is a Function?","text":"<p>A function in JavaScript is a block of code designed to perform a particular task. It can take inputs, called parameters, and return an output. Functions help you encapsulate code into a single, manageable unit.</p> Syntax<pre><code>function functionName(parameters) {\n  // Code to execute\n  return value; // Optional\n}\n</code></pre> Why Do We Need Functions? <ol> <li>Code Reusability: Write once, use multiple times. Functions help avoid code duplication.</li> <li>Modularity: Break down complex problems into smaller, manageable parts.</li> <li>Maintainability: Changes to functionality can be made in one place rather than throughout your codebase.</li> <li>Abstraction: Hide implementation details and expose only what\u2019s necessary.</li> <li>Testing: Functions can be tested independently for better reliability.</li> </ol> What Does a Function Do? <p>A function performs a specific action based on the logic defined within it. When you call a function, it executes the code inside its body, using any parameters you pass to it and potentially returning a result.</p>"},{"location":"frontend/js/function/intro/#how-do-you-create-a-function","title":"How Do You Create a Function?","text":"<p>In JavaScript, you can create a function using the function keyword or using an arrow function syntax. Here are both methods:</p>"},{"location":"frontend/js/function/intro/#using-the-function-keyword","title":"Using the <code>function</code> Keyword","text":"<pre><code>function greet(name) {\n  return `Hello, ${name}!`;\n}\n</code></pre>"},{"location":"frontend/js/function/intro/#using-arrow-function-syntax","title":"Using Arrow Function Syntax","text":"<pre><code>const greet = (name) =&gt; `Hello, ${name}!`;\n</code></pre>"},{"location":"frontend/js/function/intro/#components-of-a-function","title":"Components of a Function","text":"<ol> <li>Function Name: The identifier you use to call the function (e.g., <code>greet</code>).</li> <li>Parameters: The inputs to the function (e.g., <code>name</code> in the example above). Parameters are optional.</li> <li>Function Body: The block of code that runs when the function is called, enclosed in curly braces <code>{}</code>.</li> <li>Return Statement: The value the function produces as output. Functions can return a value using the <code>return</code> keyword.</li> </ol>"},{"location":"frontend/js/function/intro/#example","title":"Example","text":"<p>Here\u2019s a complete example of a function that calculates the sum of two numbers:</p> <pre><code>function add(a, b) {\n  return a + b;\n}\n\nconst result = add(3, 5);\nconsole.log(result); // Outputs: 8\n</code></pre> <p>In this example:</p> <ul> <li><code>add</code> is the function name.</li> <li><code>a</code> and <code>b</code> are parameters.</li> <li>The function body contains the logic to return the sum of <code>a</code> and <code>b</code>.</li> <li>The <code>result</code> variable captures the return value of the function when called with arguments <code>3</code> and <code>5</code>.</li> </ul> <p>Functions are a cornerstone of programming in JavaScript, enabling you to create flexible, modular, and reusable code.</p>"},{"location":"frontend/js/function/intro/#question","title":"Question","text":"<p>In JavaScript, not every function has to return a value. If a function doesn't explicitly use the <code>return</code> statement, it will return <code>undefined</code> by default.</p>"},{"location":"frontend/js/function/intro/#what-happens-when-return-is-not-used","title":"What Happens When <code>return</code> Is Not Used?","text":"<p>When a function does not have a <code>return</code> statement, or if the <code>return</code> statement is used without an explicit value, JavaScript automatically returns <code>undefined</code>. This is useful for cases where a function performs an action but does not need to produce a result.</p> Examples <p>Function with No <code>return</code> Statement</p> <pre><code>function sayHello() {\n    console.log(\"Hello!\");\n}\n\nconst result = sayHello(); // Logs \"Hello!\" to the console\nconsole.log(result); // Outputs: undefined\n</code></pre> <p>In this example:</p> <ul> <li><code>sayHello</code> logs a message to the console but does not return a value.</li> <li>When <code>sayHello</code> is called, it returns <code>undefined</code> because there is no <code>return</code> statement.</li> </ul> <p>Function with <code>return</code> Statement But No Value</p> <pre><code>function logAndReturn() {\n    console.log(\"Logging something.\");\n    return; // Explicitly returns undefined\n}\n\nconst result = logAndReturn(); // Logs \"Logging something.\" to the console\nconsole.log(result); // Outputs: undefined\n</code></pre> <p>In this example:</p> <ul> <li><code>logAndReturn</code> includes a <code>return</code> statement but does not specify a value.</li> <li>The function still returns <code>undefined</code> because that is the default behavior when no value is provided in the <code>return</code> statement.</li> </ul> Key Points <ol> <li> <p>Explicit Return: If you want your function to return a specific value, you need to include a return statement with that value.</p> </li> <li> <p>Implicit Return: If the <code>return</code> statement is omitted or if it is used without a value, the function will return <code>undefined</code>.</p> </li> <li> <p>Useful for Side Effects: Functions that perform actions (like logging, modifying global state, or interacting with the DOM) without returning a value are often referred to as procedures or actions. They focus on side effects rather than producing a value.</p> </li> </ol> Example with Return Value<pre><code>function add(a, b) {\n  return a + b;\n}\n\nconst sum = add(3, 4); // sum will be 7\nconsole.log(sum); // Outputs: 7\n</code></pre> <p>Here, the function <code>add</code> returns the result of adding <code>a</code> and <code>b</code>, and this value is captured in the <code>sum</code> variable.</p> <p>In summary, a function in JavaScript that does not use a <code>return</code> statement will return <code>undefined</code> by default. This behavior is often useful for functions that are intended to perform actions rather than calculate and return a value.</p>"},{"location":"frontend/js/function/intro/#related-blogs","title":"Related Blogs","text":"<ul> <li>Why Mastering These Functions is Important</li> <li>High Order Function</li> <li>Javascript Arrow Functions</li> <li>Control Statement</li> <li>Understanding JavaScript Array Methods: Mutating vs. Non-Mutating</li> <li>Languages That Return Default Values</li> <li>Mastering JavaScript Array</li> <li>Why React is Both Declarative and Functional</li> </ul>"},{"location":"frontend/js/json/intro/","title":"Intro","text":"<p>JSON or JavaScript Object Notation is a very popular data interchange format. It was developed by Douglas Crockford. JSON is text-based, lightweight, and a human-readable format for data exchange between clients and servers. JSON is derived from JavaScript and bears a close resemblance to JavaScript objects, but it is not dependent on JavaScript. JSON is language-independent, and support for the JSON data format is available in all the popular languages, some of which are C#, PHP, Java, C++, Python, and Ruby.</p> <p>JSON is a format and not a language.</p> <p>JSON can be used in web applications for data transfer. Prior to JSON, XML was considered to be the chosen data interchange format. </p>"},{"location":"frontend/js/json/intro/#datatypes-in-json","title":"Datatypes in JSON","text":"<p>Tip</p> <p>JSON supports six datatypes: </p> <ol> <li>strings, </li> <li>numbers, </li> <li>Booleans, </li> <li>arrays, </li> <li>objects, &amp; </li> <li>null.</li> </ol> <ul> <li>JavaScript and JSON Essentials by Sai Srinivas Sriparasa: 2013 Packt Publishing</li> </ul>"},{"location":"frontend/js/json/json5/","title":"Json and .Json5","text":"<p>The main difference between <code>.json</code> and <code>.json5</code> lies in their syntax and flexibility:</p> <ol> <li> <p>JSON (<code>.json</code>):</p> <ul> <li>Stands for JavaScript Object Notation.</li> <li>It is a strict, lightweight data-interchange format.</li> <li>Syntax rules are rigid, requiring:<ul> <li>Double quotes around property names.</li> <li>No trailing commas.</li> <li>No comments allowed.</li> <li>Only strings, numbers, arrays, booleans, null, and objects are valid.</li> </ul> </li> </ul> <pre><code>{\n    \"name\": \"John\",\n    \"age\": 30,\n    \"isStudent\": false\n}\n</code></pre> </li> <li> <p>JSON5 (<code>.json5</code>):</p> <ul> <li>Stands for JSON for Humans, an extension of JSON.</li> <li>It is more flexible and user-friendly, allowing:<ul> <li>Single quotes for strings.</li> <li>Trailing commas.</li> <li>Unquoted property names if valid identifiers.</li> <li>Comments (both single-line <code>//</code> and multi-line <code>/* */</code>).</li> <li>Support for additional data types like <code>Infinity</code>, <code>NaN</code>, and hexadecimal numbers.</li> </ul> </li> </ul> <pre><code>{\n    name: 'John',  // Unquoted property names, single quotes\n    age: 30,       // Trailing commas allowed\n    isStudent: false,  // Comments allowed\n}\n</code></pre> </li> </ol> <p>In summary, JSON5 relaxes some of the strict rules of JSON, making it more human-friendly for editing, while <code>.json</code> is more standardized and widely supported.</p>"},{"location":"frontend/js/json/json5/#json-interesting-topic","title":"JSON interesting topic","text":"<p>Here are some interesting aspects of JSON and how you can maximize its usage:</p> <ol> <li> <p>JSON Schema Validation</p> <ul> <li>What it is: JSON Schema is a powerful tool for validating the structure of JSON data.</li> <li>Why it's interesting: It ensures that your JSON data conforms to a specific format, making it easier to validate inputs and outputs in APIs.</li> <li>How to use it: You can define a schema and use libraries like <code>Ajv</code> (in JavaScript) to validate your data.</li> </ul> <pre><code>{\n    \"type\": \"object\",\n    \"properties\": {\n        \"name\": { \"type\": \"string\" },\n        \"age\": { \"type\": \"integer\" }\n    },\n    \"required\": [\"name\", \"age\"]\n}\n</code></pre> </li> <li> <p>JSON Web Tokens (JWT)</p> <ul> <li>What it is: JWT is a compact, URL-safe means of representing claims to be transferred between two parties.</li> <li>Why it's interesting: JWTs are widely used for authentication and authorization in web applications.</li> <li>How to use it: You can encode and decode JWTs using libraries like <code>jsonwebtoken</code> in Node.js, sending tokens in HTTP headers to secure APIs.</li> </ul> <pre><code>{\n    \"alg\": \"HS256\",\n    \"typ\": \"JWT\"\n}\n{\n    \"sub\": \"1234567890\",\n    \"name\": \"John Doe\",\n    \"iat\": 1516239022\n}\n</code></pre> </li> <li> <p>JSON with Local Storage</p> <ul> <li>What it is: Storing data in a browser's localStorage or sessionStorage.</li> <li>Why it's interesting: You can persist JSON data locally, making it useful for offline applications or user preferences.</li> <li> <p>How to use it:</p> <pre><code>// Storing\nconst user = { name: \"John\", age: 30 };\nlocalStorage.setItem('user', JSON.stringify(user));\n\n// Retrieving\nconst storedUser = JSON.parse(localStorage.getItem('user'));\n</code></pre> </li> </ul> </li> <li> <p>JSON with IndexedDB</p> <ul> <li>What it is: A client-side database that stores complex data (like JSON objects).</li> <li>Why it's interesting: IndexedDB allows you to store and retrieve large amounts of structured data, which is more powerful than localStorage.</li> <li>How to use it: You can store complex data like objects and arrays natively.</li> </ul> <pre><code>const dbRequest = indexedDB.open(\"MyDatabase\");\ndbRequest.onsuccess = function(event) {\n    const db = event.target.result;\n    const transaction = db.transaction(\"myStore\", \"readwrite\");\n    const store = transaction.objectStore(\"myStore\");\n    store.add({ id: 1, name: \"John\", age: 30 });\n};\n</code></pre> </li> <li> <p>JSON Patch (RFC 6902)</p> <ul> <li>What it is: JSON Patch is a format for expressing a list of operations to apply to a JSON document.</li> <li>Why it's interesting: It\u2019s used for efficient partial updates, especially in scenarios where you only want to update specific fields.</li> <li>How to use it: Using libraries like <code>fast-json-patch</code> in JavaScript to apply patches.</li> </ul> <pre><code>[\n    { \"op\": \"replace\", \"path\": \"/name\", \"value\": \"Jane\" },\n    { \"op\": \"remove\", \"path\": \"/age\" }\n]\n</code></pre> </li> <li> <p>JSON Streaming</p> <ul> <li>What it is: JSON Streaming allows large JSON datasets to be processed in chunks rather than loading the entire document at once.</li> <li>Why it's interesting: It's useful for handling big data without crashing the browser or server due to memory overload.</li> <li>How to use it: Tools like <code>stream-json</code> in Node.js can parse large JSON datasets in chunks.</li> </ul> <pre><code>const { parser } = require('stream-json');\nconst fs = require('fs');\nfs.createReadStream('large-file.json').pipe(parser()).on('data', (chunk) =&gt; {\n    console.log(chunk);\n});\n</code></pre> </li> <li> <p>JSON with GraphQL</p> <ul> <li>What it is: JSON is the default format for sending and receiving data in GraphQL APIs.</li> <li>Why it's interesting: GraphQL APIs allow clients to request specific data in JSON format, reducing over-fetching common in REST APIs.</li> <li>How to use it: You define queries in GraphQL, and responses are returned as JSON.</li> </ul> <pre><code>query {\n    user(id: 1) {\n        name\n        age\n    }\n}\n</code></pre> JSON Response:<pre><code>{\n    \"data\": {\n        \"user\": {\n        \"name\": \"John\",\n        \"age\": 30\n        }\n    }\n}\n</code></pre> </li> <li> <p>JSONPath for Querying JSON</p> <ul> <li>What it is: JSONPath is a query language for extracting values from JSON documents (similar to XPath for XML).</li> <li>Why it's interesting: JSONPath allows for complex querying of deeply nested JSON objects.</li> <li>How to use it: Using libraries like <code>jsonpath</code> in JavaScript.</li> </ul> <pre><code>{\n    \"store\": {\n        \"book\": [\n            { \"category\": \"fiction\", \"title\": \"The Great Gatsby\" },\n            { \"category\": \"drama\", \"title\": \"Hamlet\" }\n        ]\n    }\n}\n</code></pre> Query:<pre><code>jsonpath.query(data, '$.store.book[?(@.category==\"fiction\")]');\n</code></pre> </li> <li> <p>JSON Serialization and Deserialization</p> <ul> <li>What it is: Converting objects to JSON format (serialization) and parsing JSON back into objects (deserialization).</li> <li>Why it's interesting: Most web APIs rely on this mechanism for data interchange.</li> <li> <p>How to use it:</p> <pre><code>const obj = { name: \"John\", age: 30 };\nconst jsonStr = JSON.stringify(obj);  // Serialize\nconst parsedObj = JSON.parse(jsonStr);  // Deserialize\n</code></pre> </li> </ul> </li> <li> <p>JSON Transformations with Lodash</p> <ul> <li>What it is: Using utility libraries like Lodash to manipulate JSON objects efficiently.</li> <li>Why it's interesting: Lodash offers powerful tools for querying, filtering, and transforming JSON data.</li> <li> <p>How to use it:</p> <pre><code>const data = [{ name: 'John', age: 30 }, { name: 'Jane', age: 25 }];\nconst adults = _.filter(data, user =&gt; user.age &gt;= 18);\n</code></pre> </li> </ul> </li> <li> <p>JSON for Configuration Files</p> <ul> <li>What it is: JSON is often used as a format for configuration files, especially in web development (<code>package.json</code>, <code>.babelrc</code>).</li> <li>Why it's interesting: Storing settings and configurations in JSON is easy to read, write, and manipulate programmatically.</li> <li>How to use it: You can use JSON in Node.js or other backends to dynamically load and parse configuration settings.</li> </ul> </li> <li> <p>JSON with REST APIs</p> <ul> <li>What it is: JSON is the most common data format used for sending and receiving data via REST APIs.</li> <li>Why it's interesting: Knowing how to effectively work with JSON in REST APIs ensures you build scalable, maintainable systems.</li> <li> <p>How to use it:  </p> <pre><code>fetch('https://api.example.com/data')\n.then(response =&gt; response.json())\n.then(data =&gt; console.log(data));\n</code></pre> </li> </ul> </li> </ol> <p>By learning these techniques, you can leverage the full potential of JSON in various real-world applications, from API development to efficient data management and beyond.</p>"},{"location":"frontend/js/json/json5/#js-topic","title":"JS Topic","text":"<p>Here are some interesting topics you might want to explore as you continue deepening your knowledge, especially considering your focus on becoming a top-tier developer:</p> <ol> <li> <p>Advanced JavaScript Concepts</p> <ul> <li>Closures and Currying: Understanding these will help you write more efficient and readable code.</li> <li>Event Loop and Async/Await: Mastering how JavaScript handles asynchronous operations can enhance performance in complex applications.</li> <li>Prototypes and Inheritance: Dig deeper into object-oriented principles in JavaScript.</li> <li>Functional Programming: Concepts like immutability, pure functions, and higher-order functions can transform how you approach problems.</li> </ul> </li> <li> <p>React Ecosystem</p> <ul> <li>React Performance Optimization: Learn techniques such as memoization (useMemo, useCallback), lazy loading, and code splitting.</li> <li>React Hooks: Mastering custom hooks and using built-in hooks like useReducer for complex state management.</li> <li>React Suspense and Concurrent Mode: These will shape the future of React apps, enabling better UX with async data fetching.</li> <li>Server-Side Rendering (SSR) with Next.js: Explore Next.js for building SEO-friendly React apps.</li> </ul> </li> <li> <p>State Management (Advanced Redux)</p> <ul> <li>Redux Toolkit: Learn the modern way to manage state with Redux's streamlined syntax and enhanced development experience.</li> <li>Context API: It\u2019s lightweight compared to Redux but excellent for certain types of global state management.</li> <li>Middleware in Redux: Thunk, Saga, and custom middleware for managing side effects.</li> </ul> </li> <li> <p>TypeScript</p> <ul> <li>Type Inference &amp; Generics: Learn how to leverage TypeScript's static typing for cleaner, more maintainable code.</li> <li>TypeScript in React and Node.js: Understanding how to use TypeScript in both frontend and backend can be a game changer.</li> </ul> </li> <li> <p>Advanced APIs &amp; Web Technologies</p> <ul> <li>GraphQL: A flexible, efficient alternative to REST APIs. Learn about querying and mutations with GraphQL.</li> <li>WebSockets: Real-time communication for applications like chats, notifications, or live updates.</li> <li>Service Workers: Understanding how to implement Progressive Web Apps (PWAs) with offline capabilities.</li> </ul> </li> <li> <p>Full-Stack Development</p> <ul> <li>Django with React/Next.js: Explore integrating frontend frameworks with powerful backends like Django.</li> <li>Microservices Architecture: Learn how to split large applications into smaller, independent services for scalability and maintainability.</li> <li>API Design Principles: RESTful APIs, versioning, and security considerations like JWT (JSON Web Token).</li> </ul> </li> <li> <p>Databases and Data Management</p> <ul> <li>NoSQL vs. SQL: Learn the differences and when to use MongoDB vs PostgreSQL/MySQL.</li> <li>Database Indexing and Optimization: Mastering these techniques will enhance database performance.</li> <li>Graph Databases: Explore databases like Neo4j for relationship-heavy data (e.g., for your dating app).</li> </ul> </li> <li> <p>Advanced DevOps and CI/CD</p> <ul> <li>Containerization with Docker: Packaging applications into containers for easier deployment.</li> <li>Kubernetes: Managing containerized applications at scale using Kubernetes clusters.</li> <li>CI/CD Pipelines: Automate testing, integration, and deployment with tools like GitLab CI, Jenkins, or GitHub Actions.</li> </ul> </li> <li> <p>Cloud and Serverless Computing</p> <ul> <li>AWS, Google Cloud, or Azure: Master cloud platforms to deploy, manage, and scale applications.</li> <li>Serverless Functions (AWS Lambda, Firebase Functions): Writing and deploying code without managing servers.</li> <li>Cloud Databases and Storage: Using cloud services for data persistence and management.</li> </ul> </li> <li> <p>Software Architecture &amp; Design Patterns</p> <ul> <li>SOLID Principles: These principles will help in writing scalable and maintainable code.</li> <li>Design Patterns: Explore patterns like Singleton, Factory, Observer, etc.</li> <li>Monolithic vs Microservices: Understand when to use each approach.</li> </ul> </li> <li> <p>Security Best Practices</p> <ul> <li>OWASP Top 10: Understanding the most common security vulnerabilities in web applications.</li> <li>Encryption and Authentication: JWT, OAuth2, and bcrypt for hashing passwords.</li> <li>Security in APIs: Preventing XSS, CSRF, and implementing secure HTTP headers.</li> </ul> </li> <li> <p>Mobile App Development</p> <ul> <li>React Native: Since you are already working on a dating app, mastering React Native will help build cross-platform mobile applications.</li> <li>Mobile Optimization: Techniques for performance and UX improvements on mobile devices.</li> <li>Firebase or Traditional Database for Mobile: Integrating real-time databases and authentication in mobile apps.</li> </ul> </li> <li> <p>Machine Learning Basics for Web Developers</p> <ul> <li>TensorFlow.js: Learn how to run machine learning models in the browser.</li> <li>Basic Data Science Concepts: Learn about linear regression, decision trees, and clustering algorithms.</li> <li>Recommendation Systems: Especially useful for personalized applications like a dating app.</li> </ul> </li> <li> <p>GraphQL with Apollo Client</p> <ul> <li>Advanced Querying: Learn about fragments, inline arguments, and directives.</li> <li>Cache Management: Understanding Apollo Client's caching strategies.</li> </ul> </li> <li> <p>Testing and Quality Assurance</p> <ul> <li>Unit, Integration, and E2E Testing: Master tools like Jest, Mocha, Cypress, and React Testing Library.</li> <li>TDD and BDD: Learn Test-Driven Development and Behavior-Driven Development to write better, bug-free code.</li> </ul> </li> <li> <p>Code Management and Collaboration</p> <ul> <li>Git Workflows: Learn about different Git workflows like GitFlow, feature branching, and rebasing.</li> <li>Monorepos: How large companies use tools like Lerna and Nx to manage multiple projects in a single repository.</li> </ul> </li> </ol> <p>These topics can significantly boost your understanding and skillset across modern development paradigms. You can explore them based on your interests and project needs!</p> what is difference between conntecting mysql and postgress. in ubuntu in need to install to connect django with mysql what i need to do in postgress <p>When setting up Django with MySQL versus PostgreSQL on Ubuntu, the installation and configuration processes differ slightly due to the differences in the database systems.</p> <p>Here\u2019s a breakdown of what you need to do for each:</p>"},{"location":"frontend/js/json/json5/#connecting-django-to-mysql","title":"Connecting Django to MySQL","text":"<ol> <li> <p>Install MySQL Server:</p> <ul> <li> <p>Open a terminal and install MySQL server with the following command:</p> <pre><code>sudo apt update\nsudo apt install mysql-server\n</code></pre> </li> </ul> </li> <li> <p>Install MySQL Client Libraries:</p> <ul> <li> <p>You need the MySQL client libraries to interface with MySQL from Python. Install them with:</p> <pre><code>sudo apt install libmysqlclient-dev\n</code></pre> </li> </ul> </li> <li> <p>Install Django MySQL Adapter:</p> <ul> <li> <p>You need the <code>mysqlclient</code> package for Django to connect to MySQL. Install it using pip:</p> <pre><code>pip install mysqlclient\n</code></pre> </li> </ul> </li> <li> <p>Configure Django Settings:</p> <ul> <li> <p>In your <code>settings.py</code>, configure the database settings for <code>MySQL</code>:</p> <pre><code>    DATABASES = {\n        'default': {\n            'ENGINE': 'django.db.backends.mysql',\n            'NAME': 'your_database_name',\n            'USER': 'your_username',\n            'PASSWORD': 'your_password',\n            'HOST': 'localhost',\n            'PORT': '3306',\n        }\n    }\n</code></pre> </li> </ul> </li> </ol> <p>Summary</p> <ul> <li>MySQL: You need to install <code>mysql-server</code>, <code>libmysqlclient-dev</code>, and <code>mysqlclient</code>.</li> </ul> <p>In both cases, after setting up the database server and installing the required Python packages, you'll configure your <code>settings.py</code> file in Django to connect to the database you have chosen.</p>"},{"location":"frontend/js/tools/ESLint/","title":"ESLint","text":""},{"location":"frontend/js/tools/ESLint/#theory","title":"Theory","text":""},{"location":"frontend/js/tools/ESLint/#what-is-eslint","title":"What is ESLint?","text":"<p>ESLint is an open-source JavaScript linting tool that helps developers find and fix problems in their JavaScript code. Linting is the process of analyzing code for potential errors, bugs, stylistic errors, and suspicious constructs.</p>"},{"location":"frontend/js/tools/ESLint/#where-does-eslint-come-from","title":"Where Does ESLint Come From?","text":"<p>ESLint was created by Nicholas C. Zakas in June 2013. It was developed to address some of the limitations of other JavaScript linting tools like <code>JSLint</code> and <code>JSHint</code>. ESLint is highly configurable and extensible, which has made it the preferred choice for many developers.</p>"},{"location":"frontend/js/tools/ESLint/#how-to-use-eslint","title":"How to Use ESLint","text":"Installation: <ol> <li> <p>Install ESLint:     Use npm (Node Package Manager) or yarn to install ESLint in your project.</p> <pre><code>npm install eslint --save-dev\n# or\nyarn add eslint --dev\n</code></pre> </li> <li> <p>Initialize ESLint:</p> <p>Run the ESLint initialization command to create a configuration file (<code>.eslintrc.json</code>).</p> <pre><code>npx eslint --init\n</code></pre> </li> </ol>"},{"location":"frontend/js/tools/ESLint/#configuration","title":"Configuration:","text":"<ol> <li> <p>Config File:</p> <p>The initialization command will prompt you to answer a series of questions to set up your configuration file. Here is an example <code>.eslintrc.json</code>:</p> <pre><code>{\n    \"env\": {\n        \"browser\": true,\n        \"es2021\": true\n    },\n    \"extends\": \"eslint:recommended\",\n    \"parserOptions\": {\n        \"ecmaVersion\": 12,\n        \"sourceType\": \"module\"\n    },\n    \"rules\": {\n        \"indent\": [\"error\", 2],\n        \"linebreak-style\": [\"error\", \"unix\"],\n        \"quotes\": [\"error\", \"single\"],\n        \"semi\": [\"error\", \"always\"]\n    }\n}\n</code></pre> <ol> <li>Custom Rules:</li> </ol> <p>You can customize ESLint rules according to your project's needs by modifying the <code>rules</code> section in the configuration file.</p> </li> </ol>"},{"location":"frontend/js/tools/ESLint/#running-eslint","title":"Running ESLint:","text":"<ol> <li> <p>Command Line:</p> <p>You can run ESLint from the command line to lint your code:</p> <pre><code>npx eslint yourfile.js\n</code></pre> </li> <li> <p>Automatic Fixes:</p> <p>ESLint can automatically fix certain issues:</p> <pre><code>npx eslint yourfile.js --fix\n</code></pre> </li> </ol>"},{"location":"frontend/js/tools/ESLint/#integration-with-code-editors","title":"Integration with Code Editors:","text":"<ol> <li> <p>VSCode:</p> <p>Install the ESLint extension from the Visual Studio Code Marketplace to get real-time linting feedback.</p> </li> <li> <p>Other Editors:</p> <p>Most popular editors like Atom, Sublime Text, and WebStorm have plugins or built-in support for ESLint.</p> </li> </ol>"},{"location":"frontend/js/tools/ESLint/#do-we-need-to-use-eslint-in-react","title":"Do We Need to Use ESLint in React?","text":"<p>Using ESLint in React projects is highly recommended for several reasons:</p> <ol> <li> <p>Code Quality: ESLint helps ensure that your React code follows best practices and avoids common pitfalls.</p> </li> <li> <p>Consistency: Enforces a consistent coding style across your React codebase, making it easier to read and maintain.</p> </li> <li> <p>Error Prevention: Helps catch potential errors early in the development process, reducing the likelihood of bugs in production.</p> </li> <li> <p>Integration: ESLint can be easily integrated with React projects, especially with popular configurations like Airbnb's style guide, which includes rules for React and JSX.</p> </li> </ol>"},{"location":"frontend/js/tools/ESLint/#example-configuration-for-react","title":"Example Configuration for React:","text":"<p>To use ESLint with React, you can extend a popular style guide like Airbnb\u2019s that includes React-specific linting rules. Here is an example <code>.eslintrc.json</code> for a React project:</p> <pre><code>{\n  \"env\": {\n    \"browser\": true,\n    \"es2021\": true,\n    \"node\": true\n  },\n  \"extends\": [\n    \"eslint:recommended\",\n    \"plugin:react/recommended\",\n    \"airbnb\"\n  ],\n  \"parserOptions\": {\n    \"ecmaFeatures\": {\n      \"jsx\": true\n    },\n    \"ecmaVersion\": 12,\n    \"sourceType\": \"module\"\n  },\n  \"plugins\": [\n    \"react\"\n  ],\n  \"rules\": {\n    \"react/react-in-jsx-scope\": \"off\",\n    \"indent\": [\"error\", 2],\n    \"linebreak-style\": [\"error\", \"unix\"],\n    \"quotes\": [\"error\", \"single\"],\n    \"semi\": [\"error\", \"always\"]\n  }\n}\n</code></pre> <p>Using ESLint in your React projects will help you maintain high code quality, consistent style, and catch errors early, ultimately leading to more robust and maintainable code.</p>"},{"location":"frontend/js/tools/ESLint/#add-eslint-scripts-to-packagejson","title":"Add ESLint Scripts to <code>package.json</code>","text":"<pre><code>{\n  \"scripts\": {\n    \"lint\": \"eslint 'src/**/*.{js,jsx}'\",\n    \"lint:fix\": \"eslint 'src/**/*.{js,jsx}' --fix\"\n  }\n}\n</code></pre>"},{"location":"frontend/js/tools/node-package-manager/","title":"npm","text":"<p>npm is a powerful package manager for JavaScript and Node.js, serving as the default package manager for the <code>Node.js</code> runtime environment. It includes a command-line client (npm) and an online repository (<code>npm registry</code>) for hosting and sharing JavaScript packages.</p> Example"},{"location":"frontend/js/tools/node-package-manager/#using-npm-flags-effectively-when-to-use-d-s-and-more","title":"Using npm Flags Effectively: When to Use <code>-D</code>, <code>-S</code>, and More","text":"<ol> <li> <p>-D or --save-dev:</p> <ul> <li>Purpose: Install packages needed only for development, such as build tools, testing libraries, and linters. This means the package will be listed under the devDependencies section in the <code>package.json</code> file.</li> <li>Usage: Use this flag when adding development tools that aren\u2019t needed in production.</li> <li>Example: <code>npm install -D jest eslint webpack</code></li> </ul> </li> <li> <p>No Flag or --save or -S:</p> <ul> <li>Purpose: Install packages needed for both <code>development</code> and <code>production</code>, such as frameworks and libraries. This is the default behavior when you run <code>npm install</code> without any flags. It installs the package as a dependency and adds it to the dependencies section in <code>package.json</code>.</li> <li>Usage: Use this default behavior for core dependencies required to run your application.</li> <li>Example: <code>npm install react express axios</code></li> </ul> </li> <li> <p>-g or --global:</p> <ul> <li>Purpose: Install packages globally for system-wide access, useful for CLI tools and utilities.</li> <li>Usage: Use this flag for tools you want to use from the command line across projects.</li> <li>Example: <code>npm install -g nodemon</code></li> </ul> </li> <li> <p>--exact or -E:</p> <ul> <li>Purpose: Install packages with an exact version, avoiding automatic updates.</li> <li>Usage: Use this for version consistency in your project.</li> <li>Example: <code>npm install lodash@4.17.21 -E</code></li> </ul> </li> <li> <p>--no-save:</p> <ul> <li>Purpose: Install a package temporarily without adding it to package.json.</li> <li>Usage: Use this for testing or one-time installs.</li> <li>Example: <code>npm install some-temporary-package --no-save</code></li> </ul> </li> <li> <p>--save-optional or -O:</p> <ul> <li>Purpose: Install packages that are not essential but provide additional functionality if available.</li> <li>Usage: Use this for optional dependencies that enhance your project but aren't critical.</li> <li>Example: <code>npm install fsevents -O</code></li> </ul> </li> <li> <p>--save-peer:</p> <ul> <li>Purpose: Install packages as peer dependencies, which are meant to work alongside a specific version of another package.</li> <li>Usage: Use this for packages that should be compatible with a specific version of a core dependency.</li> <li>Example: <code>npm install react@^17.0.0 -P</code></li> </ul> </li> </ol> <p>Choosing the right flag ensures that your dependencies are managed effectively, keeping your project organized and efficient.</p> <p>Summary</p> <ul> <li>Use -D for development dependencies.</li> <li>Use without any flag for production dependencies.</li> <li>Use -g for globally installed tools.</li> <li>Use -E for exact version installations.</li> <li>Use --no-save for temporary installations.</li> <li>Use -O for optional dependencies.</li> <li>Use -P for peer dependencies.</li> </ul>"},{"location":"frontend/js/tools/node-package-manager/#deep-dive-into-packagejson","title":"Deep Dive into <code>package.json</code>","text":"<p>The <code>package.json</code> file is central to any <code>Node.js</code> project, serving as the manifest for your project. It defines project metadata, dependencies, scripts, and configurations. Here\u2019s an in-depth look at the key sections and features of package.json:</p>"},{"location":"frontend/js/tools/node-package-manager/#scripts","title":"Scripts","text":"<ul> <li>Purpose: Defines custom commands that can be run using <code>npm run &lt;script-name&gt;</code>.</li> <li> <p>Examples:</p> <pre><code>\"scripts\": {\n    \"start\": \"node index.js\",\n    \"test\": \"jest\",\n    \"build\": \"webpack --config webpack.config.js\"\n}\n</code></pre> </li> <li> <p>Custom Scripts: You can create scripts for various tasks like testing, building, linting, and more. Scripts can be executed with <code>npm run &lt;script-name&gt;</code>.</p> </li> </ul>"},{"location":"frontend/js/tools/node-package-manager/#dependencies","title":"Dependencies","text":"<ul> <li> <p>dependencies: Packages required for the application to run in production.</p> <pre><code>\"dependencies\": {\n    \"express\": \"^4.17.1\",\n    \"axios\": \"^0.21.1\"\n}\n</code></pre> </li> <li> <p>devDependencies: Packages needed only during development (e.g., testing frameworks, build tools).</p> <pre><code>\"devDependencies\": {\n    \"jest\": \"^26.6.3\",\n    \"webpack\": \"^5.24.4\"\n}\n</code></pre> </li> <li> <p>optionalDependencies: Packages that are not essential but provide additional features if available.</p> <pre><code>\"optionalDependencies\": {\n    \"fsevents\": \"^1.2.13\"\n}\n</code></pre> </li> <li> <p>peerDependencies: Packages that your project needs to work alongside a specific version of another package.</p> <pre><code>\"peerDependencies\": {\n    \"react\": \"^17.0.2\"\n}\n</code></pre> </li> </ul>"},{"location":"frontend/js/tools/node-package-manager/#configurations","title":"Configurations","text":"<ul> <li> <p>engines: Specifies which versions of Node.js and other engines your project is compatible with.</p> <pre><code>\"engines\": {\n    \"node\": \"&gt;=12.0.0\"\n}\n</code></pre> </li> <li> <p>browserslist: Defines the list of browsers that your project should support, used by tools like Babel and Autoprefixer.</p> <pre><code>\"browserslist\": [\n    \"&gt; 1%\",\n    \"last 2 versions\",\n    \"not dead\"\n]\n</code></pre> </li> </ul>"},{"location":"frontend/js/tools/node-package-manager/#scripts-configuration-hooks","title":"Scripts Configuration <code>Hooks</code>","text":"<ul> <li> <p>pre and post Hooks: Special scripts that run before or after a specific script. For example, <code>pretest</code> runs before test, and <code>postbuild</code> runs after build.</p> <pre><code>\"scripts\": {\n    \"pretest\": \"echo Preparing for tests...\",\n    \"test\": \"jest\",\n    \"posttest\": \"echo Tests completed!\"\n}\n</code></pre> </li> </ul>"},{"location":"frontend/js/tools/node-package-manager/#package-metadata","title":"Package Metadata","text":"<ul> <li> <p>main: The entry point of your project or package, usually the main file.</p> <pre><code>\"main\": \"index.js\"\n</code></pre> </li> </ul>"},{"location":"frontend/js/tools/node-package-manager/#workspaces","title":"Workspaces","text":"<ul> <li> <p>Purpose: Manage multiple packages within a single repository. Useful for monorepos.</p> </li> <li> <p>Configuration:</p> </li> </ul> <pre><code>\"workspaces\": [\n  \"packages/*\"\n]\n</code></pre>"},{"location":"frontend/js/tools/node-package-manager/#summary","title":"Summary","text":"<ul> <li><code>package.json</code> is crucial for defining project metadata, managing dependencies, configuring scripts, and setting up project settings.</li> <li>Scripts help automate development workflows.</li> <li>Dependencies are categorized into <code>dependencies</code>, <code>devDependencies</code>, <code>optionalDependencies</code>, and <code>peerDependencies</code> based on their role.</li> <li>Configurations and metadata fields help define how your project behaves and integrates with other tools.</li> </ul> <p>Mastering <code>package.json</code> allows you to effectively manage your <code>Node.js</code> projects and streamline development processes.</p>"},{"location":"frontend/js/tools/node-version-manager/","title":"Node Version Manager","text":""},{"location":"frontend/js/tools/node-version-manager/#install-nvm","title":"Install NVM","text":"<ol> <li> <p>Install NVM using either <code>curl</code> or <code>wget</code>:</p> cURLwget <p>To install NVM using <code>curl</code>, run the following command:</p> <pre><code>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.2/install.sh | bash\n</code></pre> <p>To install NVM using <code>wget</code>, run the following command:</p> <pre><code>wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.2/install.sh | bash\n</code></pre> </li> <li> <p>Source the new instructions NVM added to <code>.bashrc</code> during the installation process. You can either exit and re-enter the shell console, or manually source your <code>.bashrc</code> file. This file is almost always located at the root of your home directory:</p> <pre><code>source ~/.bashrc\n</code></pre> </li> <li> <p>Confirm the version of NVM that is running with the following command:</p> <pre><code>nvm --version\n</code></pre> </li> </ol>"},{"location":"frontend/js/tools/node-version-manager/#reference","title":"Reference","text":"<ul> <li>node version manager nvm</li> </ul>"},{"location":"frontend/js/tools/nodejs-package-manager/","title":"nodejs package manager","text":"<ul> <li> <p> npm (Node Package Manager)</p> <p>Comes pre-installed with Node.js, no additional setup required.</p> <p> Reference</p> </li> <li> <p> Yarn</p> <p>Excellent support for monorepos and managing multiple packages within a single repository.</p> <p> Reference</p> </li> <li> <p> pnpm (Performant npm)</p> <p>Uses a unique approach of symlinking packages which saves space and speeds up installations.</p> <p> Reference</p> </li> </ul>"},{"location":"frontend/js/tools/nodejs-package-manager/#decision-factors","title":"Decision Factors","text":"<ol> <li>Performance Needs: If speed and efficiency are crucial, consider Yarn or pnpm.</li> <li>Monorepo Management: For projects with multiple packages, Yarn or pnpm\u2019s workspace features are beneficial.</li> <li>Team Familiarity: Choose the package manager that your team is most comfortable with to minimize the learning curve.</li> <li>Ecosystem and Tooling: Consider the compatibility of the package manager with other tools and services you use.</li> </ol>"},{"location":"frontend/js/tools/nodejs-package-manager/#summary","title":"Summary","text":"<ul> <li>Use npm if you prefer the default, out-of-the-box solution with Node.js.</li> <li>Use Yarn if you need faster installs, stability, and good monorepo support.</li> <li>Use pnpm if you want the best performance and disk space efficiency, and are open to adopting newer tools.</li> </ul>"},{"location":"frontend/js/tools/pnpm/","title":"pnpm","text":"<p>pnpm (Performant npm):</p> <ul> <li>Focuses on efficient disk space usage and speed.</li> <li>Shares dependencies across projects without duplicating them.</li> <li>Uses a <code>pnpm-lock.yaml</code> file to lock dependencies.</li> <li>Command examples: <code>pnpm install</code>, <code>pnpm update</code>, <code>pnpm remove</code>.</li> </ul>"},{"location":"frontend/js/tools/vite/","title":"Vite","text":"<p>Vite is primarily needed during the development phase of a project, not in production. Here\u2019s why:</p> Abstract Development:Production: <ul> <li>Fast Build and HMR: Vite provides a fast and efficient development server with Hot Module Replacement (HMR), allowing you to see changes in real-time without a full page reload.</li> <li>Modern JavaScript Support: Vite leverages native ES modules in the browser for faster builds and efficient module loading during development.</li> <li>Optimized for Development: Vite is optimized to improve the development experience with features like fast refresh, instant feedback, and efficient bundling.</li> </ul> <ul> <li>Build Process: Vite is used to build the final optimized bundle of your application. It handles tasks like minification, code splitting, and other optimizations to prepare your code for production deployment.</li> <li>Static Assets Handling: Vite can process and optimize static assets such as images, stylesheets, and other resources during the build process.</li> </ul> Conclusion: <ul> <li>In Development: You need Vite to run your development server, utilize HMR, and benefit from its fast build times and modern JavaScript support.</li> <li>In Production: Vite is used to build and optimize your application, but it is not required to run the application in a production environment. The built and optimized output from Vite is what gets deployed, not Vite itself.</li> </ul> <p>Therefore, you should install Vite as a <code>development dependency</code> using the -D flag:</p> <pre><code>npm install -D vite\n</code></pre> <p>This ensures that Vite is only used during the development phase and build process, not in the production environment.</p>"},{"location":"frontend/js/tools/vite/#scaffolding-your-first-vite-project","title":"Scaffolding Your First Vite Project","text":"Compatibility Note <p>Vite requires <code>Node.js</code> version 18+ or 20+. However, some templates require a higher Node.js version to work, please upgrade if your package manager warns about it.</p> NPMYarnPNPMBun <pre><code>$ npm create vite@latest\n</code></pre> <pre><code>$ yarn create vite\n</code></pre> <pre><code>$ pnpm create vite\n</code></pre> <pre><code>$ bun create vite\n</code></pre> <p>Then follow the prompts!</p> <p>You can also directly specify the project name and the template you want to use via additional command line options. For example, to scaffold a Vite + Vue project, run:</p> <pre><code># npm 7+, extra double-dash is needed:\nnpm create vite@latest my-vue-app -- --template vue\n\n# yarn\nyarn create vite my-vue-app --template vue\n\n# pnpm\npnpm create vite my-vue-app --template vue\n\n# bun\nbun create vite my-vue-app --template vue\n</code></pre> <p>You can use <code>.</code> for the project name to scaffold in the current directory.</p>"},{"location":"frontend/js/tools/vite/#supported-template","title":"Supported Template","text":"<p>The supported template presets are:</p> JavaScript TypeScript vanilla vanilla-ts vue vue-ts react react-ts preact preact-ts lit lit-ts svelte svelte-ts solid solid-ts qwik qwik-ts"},{"location":"frontend/js/tools/vite/#viteconfigjs","title":"vite.config.js","text":"Example ViteVite <pre><code>import { defineConfig } from 'vite';\nimport vue from '@vitejs/plugin-vue'; // Example plugin for Vue\nimport path from 'path';\n\nexport default defineConfig({\n    // Basic server configuration\n    server: {\n        port: 3000, // Specify the port number\n        open: true, // Automatically open the app in the default browser\n    },\n\n    // Aliases\n    resolve: {\n        alias: {\n        '@': path.resolve(__dirname, 'src'), // Simplify import paths\n        },\n    },\n\n    // Plugins\n    plugins: [\n        vue(), // Add plugins here\n    ],\n\n    // CSS Preprocessing\n    css: {\n        preprocessorOptions: {\n        scss: {\n            additionalData: `@import \"@/styles/global.scss\";`, // Example for SCSS\n        },\n        },\n    },\n\n    // Build options\n    build: {\n        outDir: 'dist', // Output directory for the build\n        sourcemap: true, // Enable source maps for debugging\n        rollupOptions: {\n        output: {\n            // Customize the output settings\n            chunkFileNames: 'js/[name]-[hash].js',\n            entryFileNames: 'js/[name]-[hash].js',\n            assetFileNames: 'assets/[name]-[hash].[ext]',\n        },\n        },\n    },\n\n    // Environment Variables\n    define: {\n        'process.env': process.env, // Use environment variables\n    },\n});\n</code></pre> <pre><code>// vite.config.js\nimport { defineConfig } from 'vite';\n\nexport default defineConfig({\n    // Basic server configuration\n    server: {\n        port: 3000, // set the port to 3000\n        host: 'localhost', // set the host\n        https: false, // enable HTTPS\n        open: true, // automatically open the app in the browser\n        cors: true, // enable CORS\n        proxy: {\n            // configure proxy rules\n            '/api': {\n                target: 'http://localhost:5000',\n                changeOrigin: true,\n                rewrite: (path) =&gt; path.replace(/^\\/api/, '')\n            }\n        }\n    }\n});\n</code></pre>"},{"location":"frontend/js/tools/vite/#to-automatically-open-your-app-in-the-browser","title":"To automatically open your app in the browser","text":"<p>To automatically open your app in the browser when running npm run dev, you need to configure your <code>vite.config.js</code> file appropriately and ensure your <code>package.json</code> has the correct script.</p> <pre><code>// vite.config.js\nimport { defineConfig } from 'vite';\n\nexport default defineConfig({\n    // Basic server configuration\n    server: {\n        open: true, // automatically open the app in the default browser\n        port: 3000, // you can also set the port if needed\n    }\n});\n</code></pre> <p>Updating <code>package.json</code></p> <p>In your package.json, make sure you have a script defined to start the Vite development server. It typically looks like this:</p> <pre><code>// package.json\n{\n  \"scripts\": {\n    \"dev\": \"vite\"\n  }\n}\n</code></pre> <p>Running the Development Server</p> <p>With the above configurations in place, running npm run dev will start the Vite development server and automatically open your app in the default web browser.</p> <pre><code>npm run dev\n</code></pre>"},{"location":"frontend/js/tools/vite/#handling-jsxtsx-in-vite","title":"Handling JSX/TSX in Vite","text":"<p>Vite needs plugins to handle frameworks like React, Vue, etc. For React, you would typically use the <code>@vitejs/plugin-react plugin</code>.</p> <p>Install Necessary Plugins</p> <pre><code>npm install @vitejs/plugin-react\n</code></pre> <p>Update <code>vite.config.js</code> with Plugins</p> <p>Here is a complete example of <code>vite.config.js</code> for a React project:</p> <pre><code>import { defineConfig } from 'vite';\nimport react from '@vitejs/plugin-react';\n\nexport default defineConfig({\n    plugins: [react()],\n    resolve: {\n        alias: {\n        '@': path.resolve(__dirname, 'src'), // Optional alias\n        },\n        extensions: ['.js', '.jsx', '.ts', '.tsx'], // Ensure Vite resolves these extensions\n    },\n    server: {\n        port: 3000,\n        open: true,\n    },\n    build: {\n        outDir: 'dist',\n        sourcemap: true,\n    },\n});\n</code></pre> <p>Summary</p> <ol> <li>Rename your files to have the appropriate extensions (<code>.jsx</code> for JavaScript with JSX, <code>.tsx</code> for TypeScript with JSX).</li> <li>Install necessary plugins and configure Vite to recognize these extensions.</li> <li>Update your <code>vite.config.js</code> to include plugins and resolve the appropriate extensions.</li> </ol> <p>By following these steps, you should resolve the internal server error related to invalid JS syntax in Vite.</p>"},{"location":"frontend/js/tools/vite/#reference","title":"Reference","text":"<ul> <li>vitejs.dev</li> </ul>"},{"location":"frontend/js/tools/yarn/","title":"yarn","text":"<ul> <li>Developed by Facebook as an alternative to npm.</li> <li>Focuses on speed, reliability, and deterministic dependency resolution.</li> <li>Uses a <code>yarn.lock</code> file to lock dependencies.</li> <li>Command examples: <code>yarn add</code>, <code>yarn upgrade</code>, <code>yarn remove</code>.</li> </ul>"},{"location":"frontend/react/code-for-change/","title":"Code For Change","text":""},{"location":"frontend/react/code-for-change/#question","title":"Question","text":"How to: api, reducer, action <pre><code>src\n    services\n        redux\n            groupchat\n                action.js\n                reducer.js\n                api.js\n            contact\n                action.js\n                reducer.js\n                api.js\n        store\n            middlewares\n                app.js\n            index.js\n            StoreProvider.js\n    common.js\n    commonService.js\n    remanentCalls.js\n    types.js\n</code></pre> APIAction api<pre><code>import queryString from \"query-string\";\nimport { appBaseUrl } from \"utils/config\";\nimport { getService, postService, putService } from \"../../commonServices\";\n\nexport class FingerPrintService {\n    addFingerPrint(q) {\n        let query = queryString.stringify(q);\n        let url = `${appBaseUrl}/attendance/allFingerPrintDataByDateRangeAdd?${query}`;\n        // local\n        // let url = `http://localhost:7143/FingerPrintData/GetRevisedFingerPrintDataByDateRange?${query}`;\n        let data = postService(url);\n        return data;\n    }\n}\n</code></pre> action.js<pre><code>import  { FINGER_PRINT_TYPES } from '../../types';\nimport { init, success, finish, error } from 'services/common';\nimport { message } from 'antd';\nimport { FingerPrintService } from \"./api\"\n\nconst fingerPrintService = new FingerPrintService();\n\nexport const fingerPrintAdd = (body) =&gt; {\n    return async(dispatch) =&gt; {\n        dispatch(init(FINGER_PRINT_TYPES.CREATE_FINGER_PRINT));\n        const resp = await fingerPrintService.addFingerPrint(body);\n        dispatch(finish(FINGER_PRINT_TYPES.CREATE_FINGER_PRINT));\n        if(resp.isSuccess) {\n            dispatch(success(FINGER_PRINT_TYPES.CREATE_FINGER_PRINT, resp.data))\n            message.success(\"Data pull successfully\")\n        } else if(!resp.isSuccess) {\n            dispatch(error(resp.errorMessage))\n        }\n\n    }\n} \n</code></pre> Redux Folder Structure Example 1. Basic Structure2. Intermediate Structure3. Advanced Structure <p>For a small to medium-sized application, you might keep things straightforward:</p> <pre><code>src/\n|-- components/\n|-- pages/\n|-- redux/\n|   |-- actions/\n|   |   |-- exampleActions.js\n|   |-- reducers/\n|   |   |-- exampleReducer.js\n|   |-- store.js\n|-- App.js\n|-- index.js\n</code></pre> <p>Description:</p> <ul> <li>actions/: Contains action creators.</li> <li>reducers/: Contains reducer functions.</li> <li>store.js: Configures and exports the Redux store.</li> </ul> store.js<pre><code>import { createStore, combineReducers } from 'redux';\nimport exampleReducer from './reducers/exampleReducer';\n\nconst rootReducer = combineReducers({\n    example: exampleReducer,\n});\n\nconst store = createStore(rootReducer);\n\nexport default store;\n</code></pre> <p>As your application grows, you might want to organize things a bit more and introduce concepts like feature modules:</p> <pre><code>src/\n|-- components/\n|-- pages/\n|-- redux/\n|   |-- feature1/\n|   |   |-- actions.js\n|   |   |-- reducer.js\n|   |   |-- types.js\n|   |-- feature2/\n|   |   |-- actions.js\n|   |   |-- reducer.js\n|   |   |-- types.js\n|   |-- store.js\n|-- App.js\n|-- index.js\n</code></pre> <p>Description:</p> <ul> <li>feature1/ and feature2/: Feature-specific folders that include actions, reducers, and types (action type constants).</li> <li>types.js: Contains action type constants to avoid typos and make actions easier to manage.</li> </ul> feature1/actions.jsfeature1/reducer.jsstore.js actions.js<pre><code>import { FEATURE1_ACTION } from './types';\n\nexport const feature1Action = (payload) =&gt; ({\n    type: FEATURE1_ACTION,\n    payload,\n});\n</code></pre> reducer.js<pre><code>import { FEATURE1_ACTION } from './types';\nconst initialState = {};\n\nconst feature1Reducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case FEATURE1_ACTION:\n        return { ...state, ...action.payload };\n        default:\n        return state;\n    }\n};\n\nexport default feature1Reducer;\n</code></pre> <pre><code>import { createStore, combineReducers } from 'redux';\nimport feature1Reducer from './feature1/reducer';\nimport feature2Reducer from './feature2/reducer';\n\nconst rootReducer = combineReducers({\n    feature1: feature1Reducer,\n    feature2: feature2Reducer,\n});\n\nconst store = createStore(rootReducer);\n\nexport default store;\n</code></pre> <p>For larger applications, a more scalable and maintainable structure is often needed. This includes organizing by feature and separating concerns:</p> <pre><code>src/\n|-- components/\n|-- pages/\n|-- redux/\n|   |-- features/\n|   |   |-- feature1/\n|   |   |   |-- actions.js\n|   |   |   |-- reducer.js\n|   |   |   |-- selectors.js\n|   |   |   |-- types.js\n|   |   |-- feature2/\n|   |   |   |-- actions.js\n|   |   |   |-- reducer.js\n|   |   |   |-- selectors.js\n|   |   |   |-- types.js\n|   |-- rootReducer.js\n|   |-- store.js\n|   |-- thunks/\n|   |   |-- feature1Thunks.js\n|   |   |-- feature2Thunks.js\n|-- App.js\n|-- index.js\n</code></pre> <p>Description:</p> <ul> <li>features/: Organizes Redux code by feature or domain.</li> <li>selectors.js: Contains selector functions to derive data from the state.</li> <li>rootReducer.js: Combines all reducers into a single root reducer.</li> <li>thunks/: Contains asynchronous action creators (thunks) if using Redux Thunk for async operations.</li> </ul> selectors.jsactions.jsreducer.js javascript<pre><code>// features/feature1/selectors.js\n\nexport const getFeature1Data = (state) =&gt; state.feature1.data;\n</code></pre> javascript<pre><code>// features/feature1/actions.js\n\nimport { FEATURE1_ACTION } from './types';\n\nexport const feature1Action = (payload) =&gt; ({\n    type: FEATURE1_ACTION,\n    payload,\n});\n</code></pre> javascript<pre><code>// features/feature1/reducer.js\n\nimport { FEATURE1_ACTION } from './types';\n\nconst initialState = { data: [] };\n\nconst feature1Reducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case FEATURE1_ACTION:\n            return { ...state, data: action.payload };\n        default:\n            return state;\n    }\n};\n\nexport default feature1Reducer;\n</code></pre> <p>Types</p> <pre><code>// feature1/types.js\nexport const FEATURE1_ACTION = 'FEATURE1_ACTION';\nexport const FEATURE1_LOAD_REQUEST = 'FEATURE1_LOAD_REQUEST';\nexport const FEATURE1_LOAD_SUCCESS = 'FEATURE1_LOAD_SUCCESS';\nexport const FEATURE1_LOAD_FAILURE = 'FEATURE1_LOAD_FAILURE';\n</code></pre> <p>Reducer</p> rootReducer.jsstore.js <pre><code>import { combineReducers } from 'redux';\nimport feature1Reducer from './features/feature1/reducer';\nimport feature2Reducer from './features/feature2/reducer';\n\nconst rootReducer = combineReducers({\n    feature1: feature1Reducer,\n    feature2: feature2Reducer,\n});\n\nexport default rootReducer;\n</code></pre> <pre><code>import { createStore, applyMiddleware } from 'redux';\nimport rootReducer from './rootReducer';\nimport thunk from 'redux-thunk';\n\nconst store = createStore(rootReducer, applyMiddleware(thunk));\n\nexport default store;\n</code></pre> <p>This advanced structure helps in managing larger codebases by organizing Redux logic more effectively and separating concerns for better maintainability and scalability.</p> To determine if a React application is using Redux Thunk or Redux Saga middleware <p>To determine if a React application is using Redux Thunk or Redux Saga middleware, you can follow these steps:</p> <p>1. Check the Redux Store Configuration</p> <p>The most direct way to find out which middleware is being used is to examine the store configuration. The store is usually set up in a file like <code>store.js</code> or <code>configureStore.js</code>. For Redux Thunk:</p> <p>In the store configuration, look for <code>applyMiddleware</code> and see if <code>thunk</code> is being used:</p> <p>For Redux Thunk:</p> <p>In the store configuration, look for applyMiddleware and see if thunk is being used:</p> javascript<pre><code>// store.js or configureStore.js\nimport { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk'; // Import thunk middleware\nimport rootReducer from './rootReducer';\n\nconst store = createStore(\n    rootReducer,\n    applyMiddleware(thunk) // Apply thunk middleware\n);\n\nexport default store;\n</code></pre> <p>If you see <code>thunk</code> being imported and used with <code>applyMiddleware</code>, then Redux Thunk is being used.</p> <p>For Redux Saga:</p> <p>If Redux Saga is being used, the store configuration will include <code>redux-saga</code> and <code>sagaMiddleware</code>:</p> javascript<pre><code>// store.js or configureStore.js\nimport { createStore, applyMiddleware } from 'redux';\nimport createSagaMiddleware from 'redux-saga'; // Import saga middleware\nimport rootReducer from './rootReducer';\nimport rootSaga from './sagas'; // Import root saga\n\nconst sagaMiddleware = createSagaMiddleware(); // Create saga middleware\n\nconst store = createStore(\n    rootReducer,\n    applyMiddleware(sagaMiddleware) // Apply saga middleware\n);\n\nsagaMiddleware.run(rootSaga); // Run the root saga\n\nexport default store;\n</code></pre> <p>In this case, you\u2019ll find <code>createSagaMiddleware</code> and <code>sagaMiddleware.run(rootSaga)</code> in the store configuration.</p> <p>2. Check Dependencies in package.json</p> <p>Look at the <code>dependencies</code> or <code>devDependencies</code> in your <code>package.json</code> file.</p> <p>For Redux Thunk:</p> <p>You will see <code>redux-thunk</code> listed:</p> json<pre><code>\"dependencies\": {\n    \"redux-thunk\": \"^2.3.0\"\n}\n</code></pre> <p>For Redux Saga:</p> <p>You will see redux-saga listed:</p> json<pre><code>\"dependencies\": {\n    \"redux-saga\": \"^1.1.3\"\n}\n</code></pre> <p>3. Search the Codebase</p> <p>You can perform a search in your codebase to see if any <code>thunk</code> or <code>saga</code> related code is present:</p> <ul> <li>Search for <code>thunk</code>: Look for <code>import thunk from 'redux-thunk' or applyMiddleware(thunk)</code>.</li> <li>Search for <code>saga</code>: Look for <code>import createSagaMiddleware from 'redux-saga', sagaMiddleware.run</code>, or <code>import { call, put } from 'redux-saga/effects'</code>.</li> </ul> <p>4. Inspect Middleware in DevTools</p> <p>If you are using Redux DevTools, you can inspect the middleware in your application:</p> <ol> <li>Open Redux DevTools in your browser.</li> <li>Look at the middleware section or check the logs to see which middleware is being applied.</li> </ol> <p>Summary</p> <ol> <li>Check Store Configuration: Look at the <code>applyMiddleware</code> in the store setup.</li> <li>Check package.json: See which middleware libraries are listed in dependencies.</li> <li>Search Codebase: Look for imports and usage related to <code>redux-thunk</code> or <code>redux-saga</code>.</li> <li>Inspect DevTools: Use Redux DevTools to examine applied middleware.</li> </ol> <p>By using these methods, you can determine whether your React application is utilizing Redux Thunk or Redux Saga middleware.</p>"},{"location":"frontend/react/code-for-change/#code-for-change-cfc","title":"Code For Change (CFC)","text":""},{"location":"frontend/react/code-for-change/#redux","title":"REDUX","text":"Improved Error Handling and Asynchronous Code Management in Redux-Thunk with React Component Integration Old CodeNew CodeKey Differences Explained Action Creator:<pre><code>export const actionForGroupChatTitleAdd = (body) =&gt; {\n    return async(dispatch) =&gt; {\n        dispatch(init(GROUPCHAT_TYPES.CREATE_GROUPCHAT_TITLE));\n        const resp = await groupChatService.apiForGroupChatTitleAdd(body);\n        if(resp.isSuccess) {\n            dispatch(success(GROUPCHAT_TYPES.CREATE_GROUPCHAT_TITLE, resp.data))\n            message.success(\"Newly added Group Chat\")\n        } else if(!resp.isSuccess) {\n            dispatch(error(resp.errorMessage))\n        }\n        dispatch(finish(GROUPCHAT_TYPES.CREATE_GROUPCHAT_TITLE));\n    }\n}\n</code></pre> Component:<pre><code>const onFinish = (values) =&gt; {\n    let errorReq = {\n        \"chatGroupName\": \"ICTC \",\n        \"referenceId\": \"f9f8bf40-067e-42aa-8538-e9d4dbd8e2fe\"\n    };\n\n    // dispatch(actionForGroupChatTitleAdd(values));\n    dispatch(actionForGroupChatTitleAdd(errorReq))\n        .then(() =&gt; {\n            console.log(\"Successfully added group chat title\");\n            onClose();\n        })\n        .catch((error) =&gt; {\n            console.log(\"error: \", error);\n            // Do not close the drawer in case of an error\n        });\n};\n</code></pre> <p>Updated Action Creator</p> <p>Your current action creator looks good, but for better error handling, we can ensure it throws an error when the response is not successful:</p> Action Creator:<pre><code>export const actionForGroupChatTitleAdd = (body) =&gt; {\n    return async(dispatch) =&gt; {\n        dispatch(init(GROUPCHAT_TYPES.CREATE_GROUPCHAT_TITLE));\n        try {\n            const resp = await groupChatService.apiForGroupChatTitleAdd(body);\n            if(resp.isSuccess) {\n                dispatch(success(GROUPCHAT_TYPES.CREATE_GROUPCHAT_TITLE, resp.data));\n                message.success(\"Newly added Group Chat\");\n                return resp.data; // Return data for success\n            } else {\n                dispatch(error(resp.errorMessage));\n                throw new Error(resp.errorMessage); // Throw error to be caught in the component\n            }\n        } catch (err) {\n            dispatch(error(err.message || 'Unknown error occurred'));\n            throw err; // Re-throw error to be caught in the component\n        } finally {\n            dispatch(finish(GROUPCHAT_TYPES.CREATE_GROUPCHAT_TITLE));\n        }\n    }\n};\n</code></pre> <p>Component Handling the API Call</p> <p>In your component, handle the promise returned by the dispatch function to conditionally call <code>onClose</code>:</p> Component:<pre><code>const onFinish = async (values) =&gt; {\n    let errorReq = {\n        \"chatGroupName\": \"ICTC \",\n        \"referenceId\": \"f9f8bf40-067e-42aa-8538-e9d4dbd8e2fe\"\n    };\n\n    try {\n        await dispatch(actionForGroupChatTitleAdd(errorReq));\n        console.log(\"Successfully added group chat title\");\n        onClose();\n    } catch (error) {\n        console.log(\"error: \", error);\n        message.error(\"Failed to add group chat title\");\n        // Drawer remains open\n    }\n};\n</code></pre> Explanation <p>Action Creator:</p> <ul> <li>If the API response is successful, it dispatches the <code>success</code> action and returns the response data.</li> <li>If the API response is not successful, it dispatches the <code>error</code> action and throws an error to be caught by the calling component.</li> <li>Errors caught within the <code>try</code> block are dispatched as errors and re-thrown to be handled by the component.</li> </ul> <p>Component:</p> <ul> <li>The <code>onFinish</code> function is modified to use <code>async/await</code> for handling the dispatch.</li> <li>On success (<code>await dispatch(actionForGroupChatTitleAdd(errorReq));</code>), it logs the success message and calls onClose() to close the drawer.</li> <li>On error (<code>catch</code> block), it logs the error and displays an error message using <code>message.error</code>. The drawer remains open.</li> </ul> <ol> <li> <p>Error Handling in Action Creator:</p> <p>Original Code:</p> <ul> <li>The action creator does not throw an error when the response is unsuccessful. It only dispatches the error message.</li> <li>This means the component cannot directly catch errors thrown by the action creator.</li> </ul> <p>Updated Code:</p> <ul> <li>The action creator explicitly throws an error when the response is unsuccessful. This allows the component to catch and handle the error.</li> <li>It uses a try-catch block to handle both the API call and any unexpected errors, re-throwing them to be caught in the component.</li> </ul> </li> <li> <p>Promise Handling in Component:</p> <p>Original Code:</p> <ul> <li>Uses <code>.then()</code> and <code>.catch()</code> to handle the promise returned by the action creator.</li> <li>If an error occurs, it is logged, but the drawer remains open because <code>onClose()</code> is not called in the <code>catch</code> block.</li> </ul> <p>Updated Code:</p> <ul> <li>Uses <code>async/await</code> syntax for better readability and error handling.</li> <li>The <code>try-catch</code> block allows for more straightforward handling of success and error cases.</li> <li>On success, it logs a message and calls <code>onClose()</code> to close the drawer.</li> <li>On error, it logs the error, displays an error message using <code>message.error</code>, and ensures the drawer remains open.</li> </ul> </li> </ol> <p>Summary</p> <p>The updated code improves error handling and readability:</p> <p>Action Creator:</p> <ul> <li>Handles both success and error cases explicitly.</li> <li>Throws errors to be caught by the component, ensuring better error propagation.</li> </ul> <p>Component:</p> <ul> <li>Uses <code>async/await</code> for cleaner, more readable asynchronous code.</li> <li>Handles success and error cases more clearly with a <code>try-catch</code> block.</li> <li>Ensures the drawer only closes on a successful API call, keeping it open on error.</li> </ul> <p>By documenting these changes, you can ensure a clear understanding of the improvements made and the rationale behind them.</p>"},{"location":"frontend/react/code-for-change/#redux-middleware","title":"Redux Middleware","text":"which redux middleware is more advance thunk or saga? <p>Both Redux Thunk and Redux Saga are popular middleware options for managing side effects in a Redux application, but they have different approaches and capabilities. Here\u2019s a comparison to help you determine which might be more advanced or suitable for your needs:</p> Redux ThunkRedux Saga <p>Advantages:</p> <ul> <li>Simplicity: Thunks are functions that can be dispatched like normal actions, making them simple to understand and implement.</li> <li>Familiarity: It feels similar to regular JavaScript, especially for handling asynchronous logic using promises or async/await.</li> <li>Learning Curve: It has a lower learning curve compared to Redux Saga.</li> </ul> <p>Disadvantages:</p> <ul> <li>Readability: As applications grow, complex async flows can become harder to manage and read.</li> <li>Error Handling: Handling complex error scenarios can be cumbersome.</li> </ul> <p>Advantages:</p> <ul> <li>Advanced Control: Provides more powerful control over complex async flows using generators, making it easier to manage and test.</li> <li>Concurrency: Better at handling concurrent actions and coordinating complex async processes.</li> <li>Testability: Sagas are more straightforward to test due to their generator-based nature.</li> <li>Composability: Easier to compose multiple sagas to work together and handle more advanced patterns like race conditions or parallel execution.</li> </ul> <p>Disadvantages:</p> <ul> <li>Complexity: Has a steeper learning curve due to the use of ES6 generators and more advanced patterns.</li> <li>Boilerplate: Can introduce more boilerplate code compared to Thunk.</li> </ul> <p>Conclusion</p> <p>When to Use Redux Thunk:</p> <ul> <li>For simpler applications or those just starting with Redux.</li> <li>When you need straightforward async logic handling.</li> <li>If you want a lower learning curve and less boilerplate.</li> </ul> <p>When to Use Redux Saga:</p> <ul> <li>For larger applications with complex async needs.</li> <li>When you need advanced control over side effects and better testability.</li> <li>If you are comfortable with generators and more complex patterns.</li> </ul> <p>Overall, Redux Saga is generally considered more advanced due to its powerful capabilities and fine-grained control over side effects. However, it also comes with more complexity, so the choice between Thunk and Saga should be based on your specific application needs and your team's familiarity with these tools.</p>"},{"location":"frontend/react/code-for-change/#which-one-to-use","title":"Which one to use","text":"Which One to Master First: Thunk or Saga? <p>Start with Redux Thunk:</p> <ul> <li>Simplicity: Thunk is simpler and easier to grasp, making it a good starting point for understanding how to manage side effects in Redux.</li> <li>Foundational Knowledge: Learning Thunk first provides a solid foundation in handling asynchronous actions, which is beneficial before tackling the more advanced concepts in Redux Saga.</li> </ul> How to Master Redux ThunkHow to Master Redux Saga <ol> <li> <p>Understand the Basics:</p> <ul> <li>Learn how to create and dispatch actions in Redux.</li> <li>Understand synchronous vs. asynchronous actions.</li> </ul> </li> <li> <p>Set Up Redux Thunk:</p> <ul> <li>Integrate Redux Thunk into your Redux store configuration.</li> </ul> </li> <li> <p>Create Thunk Actions:</p> <ul> <li>Write action creators that return functions instead of plain objects.</li> <li>Use <code>dispatch</code> and <code>getState</code> inside these functions to manage async operations.</li> </ul> </li> <li> <p>Handle Asynchronous Logic:</p> <ul> <li>Use promises or async/await within Thunk actions to perform API calls or other async tasks.</li> <li>Manage loading states and error handling within Thunk actions.</li> </ul> </li> <li> <p>Read Documentation and Tutorials:</p> <ul> <li>Follow the Redux Thunk documentation.</li> <li>Explore tutorials and examples on managing async actions with Thunk.</li> </ul> </li> <li> <p>Build Projects:</p> <ul> <li>Apply your knowledge in real projects to gain practical experience.</li> <li>Refactor existing Redux code to use Thunk for async actions.</li> </ul> </li> </ol> <ol> <li> <p>Understand ES6 Generators:</p> <ul> <li>Familiarize yourself with ES6 generator functions, as they are fundamental to Redux Saga.</li> <li>Practice using <code>yield</code>, <code>next()</code>, and generator control flow.</li> </ul> </li> <li> <p>Learn Redux Saga Basics:</p> <ul> <li>Understand the core concepts of Redux Saga, including sagas, effects, watchers, and workers.</li> </ul> </li> <li> <p>Set Up Redux Saga:</p> <ul> <li>Integrate Redux Saga into your Redux store configuration.</li> </ul> </li> <li> <p>Create Simple Sagas:</p> <ul> <li>Write sagas to handle asynchronous actions using <code>takeEvery</code>, <code>takeLatest</code>, and <code>call</code>.</li> <li>Learn to manage side effects like API calls, delays, and parallel execution.</li> </ul> </li> <li> <p>Handle Complex Scenarios:</p> <ul> <li>Use advanced patterns like <code>race</code>, <code>all</code>, and <code>cancellation</code> to manage complex async flows.</li> <li>Handle concurrency and manage multiple sagas.</li> </ul> </li> <li> <p>Read Documentation and Tutorials:</p> <ul> <li>Follow the Redux Saga documentation.</li> <li>Explore tutorials and examples to understand advanced use cases.</li> </ul> </li> <li> <p>Build Projects:</p> <ul> <li>Apply Redux Saga in real projects to tackle more complex async logic.</li> <li>Refactor existing Thunk code to use Redux Saga for better control and testability.</li> </ul> </li> </ol> <p>Additional Tips for Mastery</p> <ul> <li>Practice Regularly: Consistent practice and application in real projects are key to mastering both Thunk and Saga.</li> <li>Join Communities: Participate in online forums, communities, and discussions to learn from others and share your experiences.</li> <li>Keep Updated: Both Thunk and Saga are actively maintained, so keep an eye on updates and best practices by following their repositories and release notes.</li> <li>Experiment: Don't be afraid to experiment with different patterns and techniques to find what works best for your use case.</li> </ul> <p>Starting with Redux Thunk provides a solid foundation, and mastering Redux Saga will give you advanced tools for handling complex asynchronous logic in your Redux applications.</p>"},{"location":"frontend/react/code-for-change/#jest","title":"Jest","text":"<p>In the context of package management, like with <code>npm</code> (Node Package Manager) for JavaScript projects, <code>--save</code> and <code>--save-dev</code> are options used during the installation of packages. Here's a simple explanation of the difference:</p> <ul> <li> <p>--save: When you install a package using --save, it means the package will be listed as a dependency in your project's <code>package.json</code> file. This indicates that your project needs this package to run properly. These dependencies are typically packages required for the application to function correctly in production.</p> </li> <li> <p>--save-dev: On the other hand, when you install a package using --save-dev, it means the package will be listed as a development dependency in your project's <code>package.json</code> file. This indicates that your project only needs this package during development, such as for testing, building, or other development-related tasks. These dependencies are typically tools or libraries used during the development process, but not necessary for the application to run in production.</p> </li> </ul> <p>So, in summary:</p> <ul> <li>Use --save for packages your project needs to run.</li> <li>Use --save-dev for packages your project needs during development but not for running the final application.</li> </ul> <ul> <li>--save <code>vs</code> --save-dev</li> <li>jest testing</li> <li>How To Structure React Projects From Beginner To Advanced</li> <li>useEffect by Example</li> </ul>"},{"location":"frontend/react/code-for-change/#easy-thumbnail","title":"Easy Thumbnail","text":"<ul> <li>easy-thumbnails 2.8.5: pypi</li> <li>easy thumbnail: readthedocs</li> <li>easy thumbnail: github</li> </ul> <pre><code>from easy_thumbnails.fields import ThumbnailerImageField\n\nclass Profile(models.Model):\n    user = models.OneToOneField('auth.User')\n    photo = ThumbnailerImageField(upload_to='photos', blank=True)\n</code></pre>"},{"location":"frontend/react/code-for-change/#step-1","title":"Step 1:","text":"<pre><code>Run pip install easy-thumbnails.\n</code></pre>"},{"location":"frontend/react/code-for-change/#step-2","title":"Step 2:","text":"<pre><code>Add `easy_thumbnails` to your INSTALLED_APPS setting:\n\n```python\nINSTALLED_APPS = (\n    ...\n    'easy_thumbnails',\n)\n```\n</code></pre>"},{"location":"frontend/react/code-for-change/#step-3","title":"Step 3:","text":"<pre><code>Run `manage.py` migrate `easy_thumbnails`\n</code></pre>"},{"location":"frontend/react/slides/","title":"Slides","text":""},{"location":"frontend/react/slides/#presentation","title":"Presentation","text":""},{"location":"frontend/react/core/intro/","title":"Intro","text":""},{"location":"frontend/react/core/intro/#programming-paradigm","title":"Programming Paradigm","text":"<ul> <li>imperative (how to do)</li> <li>declarative (what to do)</li> </ul>"},{"location":"frontend/react/core/intro/#react-is-declarative","title":"React is declarative","text":"<p>In declarative programming, you concentrate on the \"<code>what</code>\". Not the \"<code>how</code>\". For instance, the following snippet tells your app to serve certain pages at the given route-paths.</p> <p>Libraries:</p> <ul> <li>React</li> <li>React-Router</li> <li>React-Apollo (GraphQL)</li> <li>Styled-Components</li> <li>Express</li> <li>Infrastructure-Components</li> </ul> <p>Notes</p> <ul> <li> <p><code>React.js</code> removed the boundaries between HTML and JavaScript. It uses the Javascript   Syntax Extension (JSX) that complements basic Javascript source code with HTML.</p> </li> <li> <p><code>Styled-Components</code> added a convenient way of styling your React-components. There\u2019s no   need for global style sheets anymore.</p> </li> <li> <p>With <code>Infrastructure-Components</code>, you can integrate REST-services into your React app. As   well as database schemes and queries. You can even configure your serverless infrastructure.</p> </li> </ul> <p>life is an experiment. The more experiments you make the better. - Ralph Waldo Emerson</p>"},{"location":"frontend/react/core/intro/#different-ways-to-scaffold-a-react-application","title":"Different Ways to Scaffold a React Application","text":"<p>There are several ways to create and scaffold a React application. Here are some of the most popular methods:</p>"},{"location":"frontend/react/core/intro/#1-create-react-app-cra","title":"1. Create React App (CRA)","text":"<p>Create React App is an officially supported way to create single-page React applications. It offers a modern build setup with no configuration.</p> Installation:<pre><code>npx create-react-app my-app\ncd my-app\nnpm start\n</code></pre>"},{"location":"frontend/react/core/intro/#2-vite","title":"2. Vite","text":"<p>Vite is a fast build tool that offers an alternative to Create React App with a focus on speed and performance.</p> Installation:<pre><code>npm create vite@latest my-app --template react\ncd my-app\nnpm install\nnpm run dev\n</code></pre>"},{"location":"frontend/react/core/intro/#3-nextjs","title":"3. Next.js","text":"<p>Next.js is a powerful framework built on top of React for building server-side rendered (SSR) and statically generated (SSG) websites.</p> Installation:<pre><code>npx create-next-app@latest my-app\ncd my-app\nnpm run dev\n</code></pre>"},{"location":"frontend/react/core/intro/#4-gatsby","title":"4. Gatsby","text":"<p>Gatsby is a React-based framework for building fast static websites and apps.</p> Installation:<pre><code>npm install -g gatsby-cli\ngatsby new my-app\ncd my-app\ngatsby develop\n</code></pre>"},{"location":"frontend/react/core/intro/#5-parcel","title":"5. Parcel","text":"<p>Parcel is a web application bundler that can also be used to scaffold a React project with zero configuration.</p> Installation:<pre><code>mkdir my-app\ncd my-app\nnpm init -y\nnpm install react react-dom parcel\n</code></pre> Project Structure: <ol> <li> <p>Create an <code>index.html</code> file:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;My App&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"app\"&gt;&lt;/div&gt;\n    &lt;script src=\"index.js\"&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> </li> <li> <p>Create an <code>index.js</code> file:</p> <pre><code>import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nconst App = () =&gt; &lt;div&gt;Hello, world!&lt;/div&gt;;\n\nReactDOM.render(&lt;App /&gt;, document.getElementById(\"app\"));\n</code></pre> </li> </ol> <p>Start the development server:</p> <pre><code>npx parcel index.html\n</code></pre>"},{"location":"frontend/react/core/intro/#6-manual-setup-with-webpack-and-babel","title":"6. Manual Setup with Webpack and Babel","text":"<p>For more control over the configuration, you can set up a React project manually using Webpack and Babel.</p> Installation:<pre><code>mkdir my-app\ncd my-app\nnpm init -y\nnpm install react react-dom webpack webpack-cli webpack-dev-server babel-loader @babel/core @babel/preset-env @babel/preset-react html-webpack-plugin\n</code></pre> Configuration <ol> <li> <p>Create a <code>webpack.config.js</code> file:</p> <pre><code>const path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: ['@babel/preset-env', '@babel/preset-react']\n          }\n        }\n      }\n    ]\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html'\n    })\n  ],\n  devServer: {\n    contentBase: './dist'\n  }\n};\n</code></pre> </li> <li> <p>Create a <code>.babelrc</code> file:</p> <pre><code>{\n  \"presets\": [\"@babel/preset-env\", \"@babel/preset-react\"]\n}\n</code></pre> </li> <li> <p>Create an <code>index.html</code> file in src:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;My App&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"app\"&gt;&lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> </li> <li> <p>Create a <code>.babelrc</code> file:</p> <pre><code>import React from 'react';\nimport ReactDOM from 'react-dom';\n\nconst App = () =&gt; &lt;div&gt;Hello, world!&lt;/div&gt;;\n\nReactDOM.render(&lt;App /&gt;, document.getElementById('app'));\n</code></pre> </li> </ol> <p>Start the development server:</p> <pre><code>npx webpack serve\n</code></pre> <p>These methods cover a range of scenarios from quick setups with Create React App to more complex configurations with Next.js and manual setups using Webpack. Choose the one that best fits your project's needs.</p>"},{"location":"frontend/react/core/intro/#recommendation","title":"Recommendation","text":"<p>For most modern React projects, Next.js is a highly recommended choice due to its flexibility, performance benefits, and future-proof features. It supports a wide range of use cases, from simple SPAs to complex, SEO-friendly applications.</p> <p>Create React App is also a solid choice for simpler projects or for those who prefer minimal configuration and an easy setup process. However, as projects scale, you might find the need to switch to a more flexible solution like Next.js.</p> <p>Vite is gaining traction and can be an excellent choice for developers who prioritize build speed and modern tooling.</p> <p>Gatsby remains a strong option for static site generation and content-driven projects.</p> <p>Ultimately, the choice depends on your project requirements, team familiarity, and long-term goals. All of these tools have strong communities and regular updates, ensuring they remain relevant and useful for years to come.</p>"},{"location":"frontend/react/core/intro/#reference","title":"Reference","text":"<ul> <li> <p>React-Architect by Dr.Frank Zickert</p> </li> <li> <p>What is Programming Paradigm?</p> </li> </ul>"},{"location":"frontend/react/core/auth-example/login/react-login/","title":"Login","text":"<p>To implement login authentication in a React application, you typically need to handle user input, send authentication requests to a backend server, manage authentication tokens, and conditionally render components based on the authentication state. Here's a step-by-step guide to achieve this:</p>"},{"location":"frontend/react/core/auth-example/login/react-login/#install-necessary-packages","title":"Install Necessary Packages","text":"<p>You may need some additional packages for handling HTTP requests and managing authentication state:</p> <pre><code>npm install axios react-router-dom\n</code></pre>"},{"location":"frontend/react/core/auth-example/login/react-login/#folder-structure","title":"Folder Structure","text":"<p>React authentication</p> <pre><code>my-auth-app/\n\u251c\u2500\u2500 node_modules/\n\u251c\u2500\u2500 public/\n\u2502   \u251c\u2500\u2500 index.html\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 components/\n\u2502   \u2502   \u251c\u2500\u2500 Home.js\n\u2502   \u2502   \u251c\u2500\u2500 Login.js\n\u2502   \u2502   \u2514\u2500\u2500 ProtectedRoute.js\n\u2502   \u251c\u2500\u2500 context/\n\u2502   \u2502   \u2514\u2500\u2500 AuthContext.js\n\u2502   \u251c\u2500\u2500 services/\n\u2502   \u2502   \u2514\u2500\u2500 authService.js\n\u2502   \u251c\u2500\u2500 App.js\n\u2502   \u251c\u2500\u2500 index.css\n\u2502   \u251c\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 package-lock.json\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 ...\n</code></pre> Abstract <ul> <li> <p>components/: Contains the React components used in your application.</p> <ul> <li>Home.js: The protected home component.</li> <li>Login.js: The login form component.</li> <li>ProtectedRoute.js: The component that protects routes requiring authentication.</li> </ul> </li> <li> <p>context/: Contains the context for managing authentication state.</p> <ul> <li>AuthContext.js: The authentication context provider and hooks.</li> </ul> </li> <li> <p>services/: Contains service files for handling API calls and other business logic.</p> <ul> <li>authService.js: Service for handling authentication-related API calls.</li> </ul> </li> <li> <p>App.js: The main application component that sets up routing and provides context.</p> </li> <li> <p>index.js: The entry point for the React application.    </p> </li> <li> <p>index.css: Global styles for the application.</p> </li> </ul>"},{"location":"frontend/react/core/auth-example/login/react-login/#code","title":"Code","text":"Success src/components/src/context/src/services/src/ Home.jsLogin.jsProtectedRoute.js <pre><code>import React, { useContext } from 'react';\nimport { AuthContext } from '../context/AuthContext';\n\nconst Home = () =&gt; {\n    const { currentUser, logout } = useContext(AuthContext);\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Welcome, {currentUser?.username}&lt;/h1&gt;\n            &lt;button onClick={logout}&gt;Logout&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Home;\n</code></pre> <pre><code>import React, { useState, useContext } from 'react';\nimport { AuthContext } from '../context/AuthContext';\n\nconst Login = () =&gt; {\n    const [username, setUsername] = useState('');\n    const [password, setPassword] = useState('');\n    const { login } = useContext(AuthContext);\n\n    const handleSubmit = async (e) =&gt; {\n        e.preventDefault();\n        try {\n            await login(username, password);\n            // Redirect or perform any action on successful login\n        } catch (error) {\n            console.error('Login failed', error);\n        }\n    };\n\n    return (\n        &lt;form onSubmit={handleSubmit}&gt;\n            &lt;div&gt;\n                &lt;label&gt;Username&lt;/label&gt;\n                &lt;input type=\"text\" value={username} onChange={(e) =&gt; setUsername(e.target.value)} /&gt;\n            &lt;/div&gt;\n            &lt;div&gt;\n                &lt;label&gt;Password&lt;/label&gt;\n                &lt;input type=\"password\" value={password} onChange={(e) =&gt; setPassword(e.target.value)} /&gt;\n            &lt;/div&gt;\n            &lt;button type=\"submit\"&gt;Login&lt;/button&gt;\n        &lt;/form&gt;\n    );\n};\n\nexport default Login;\n</code></pre> <pre><code>import React, { useContext } from 'react';\nimport { Route, Redirect } from 'react-router-dom';\nimport { AuthContext } from '../context/AuthContext';\n\nconst ProtectedRoute = ({ component: Component, ...rest }) =&gt; {\n    const { currentUser } = useContext(AuthContext);\n\n    return (\n        &lt;Route\n            {...rest}\n            render={(props) =&gt;\n                currentUser ? &lt;Component {...props} /&gt; : &lt;Redirect to=\"/login\" /&gt;\n            }\n        /&gt;\n    );\n};\n\nexport default ProtectedRoute;\n</code></pre> AuthContext.js<pre><code>import React, { createContext, useState, useEffect } from 'react';\nimport { getCurrentUser, login, logout } from '../services/authService';\n\nexport const AuthContext = createContext();\n\nexport const AuthProvider = ({ children }) =&gt; {\n    const [currentUser, setCurrentUser] = useState(null);\n\n    useEffect(() =&gt; {\n        const user = getCurrentUser();\n        if (user) {\n            setCurrentUser(user);\n        }\n    }, []);\n\n    const loginHandler = async (username, password) =&gt; {\n        const user = await login(username, password);\n        setCurrentUser(user);\n    };\n\n    const logoutHandler = () =&gt; {\n        logout();\n        setCurrentUser(null);\n    };\n\n    return (\n        &lt;AuthContext.Provider value={{ currentUser, login: loginHandler, logout: logoutHandler }}&gt;\n            {children}\n        &lt;/AuthContext.Provider&gt;\n    );\n};\n</code></pre> authService.js<pre><code>import axios from 'axios';\n\nconst API_URL = 'https://your-api-url.com'; // Replace with your API URL\n\nexport const login = async (username, password) =&gt; {\n    const response = await axios.post(`${API_URL}/auth/login`, { username, password });\n    if (response.data.token) {\n        localStorage.setItem('user', JSON.stringify(response.data));\n    }\n    return response.data;\n};\n\nexport const logout = () =&gt; {\n    localStorage.removeItem('user');\n};\n\nexport const getCurrentUser = () =&gt; {\n    return JSON.parse(localStorage.getItem('user'));\n};\n</code></pre> App.jsindex.js <pre><code>import React from 'react';\nimport { BrowserRouter as Router, Route, Switch } from 'react-router-dom';\nimport { AuthProvider } from './context/AuthContext';\nimport Login from './components/Login';\nimport ProtectedRoute from './components/ProtectedRoute';\nimport Home from './components/Home'; // Your protected home component\n\nconst App = () =&gt; {\n    return (\n        &lt;AuthProvider&gt;\n        &lt;Router&gt;\n            &lt;Switch&gt;\n            &lt;Route path=\"/login\" component={Login} /&gt;\n            &lt;ProtectedRoute path=\"/\" component={Home} /&gt;\n            &lt;/Switch&gt;\n        &lt;/Router&gt;\n        &lt;/AuthProvider&gt;\n    );\n};\n\nexport default App;\n</code></pre> <pre><code>import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n    &lt;React.StrictMode&gt;\n        &lt;App /&gt;\n    &lt;/React.StrictMode&gt;,\n    document.getElementById('root')\n);\n</code></pre> <p>This structure provides a clean and organized way to handle authentication in your React application. You can further expand it with additional features and components as needed.</p>"},{"location":"frontend/react/core/auth-example/react-without-redux/intro/","title":"Login","text":""},{"location":"frontend/react/core/auth-example/react-without-redux/intro/#without-state-management","title":"Without State Management","text":"<p>Certainly! Using React with APIs without state management libraries like Redux can be done by leveraging React's built-in state and effect hooks (<code>useState</code> and <code>useEffect</code>). Here's an example of how to structure your folders and code to achieve this.</p>"},{"location":"frontend/react/core/auth-example/react-without-redux/intro/#folder-structure","title":"Folder Structure","text":"<pre><code>my-app/\n\u251c\u2500\u2500 public/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 api/\n\u2502   \u2502   \u2514\u2500\u2500 fetchData.js\n\u2502   \u251c\u2500\u2500 components/\n\u2502   \u2502   \u251c\u2500\u2500 DataDisplay.jsx\n\u2502   \u2502   \u2514\u2500\u2500 DataItem.jsx\n\u2502   \u251c\u2500\u2500 App.jsx\n\u2502   \u251c\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 styles/\n\u2502       \u2514\u2500\u2500 App.css\n\u2514\u2500\u2500 package.json\n</code></pre> Example fetchData.jscomponentssrc/App.jssrc/index.jssrc/styles/App.css <p>This file contains the API call logic.</p> <pre><code>// src/api/fetchData.js\n\nexport const fetchData = async () =&gt; {\n    try {\n        const response = await fetch('https://api.example.com/data');\n        if (!response.ok) {\n            throw new Error('Network response was not ok');\n        }\n        const data = await response.json();\n        return data;\n    } catch (error) {\n        console.error('Error fetching data:', error);\n        return null;\n    }\n};\n</code></pre> DataItem.jsDataDisplay.js <p>A simple component to display individual data items.</p> <pre><code>// src/components/DataItem.js\n\nimport React from 'react';\n\nconst DataItem = ({ item }) =&gt; {\n    return (\n        &lt;div className=\"data-item\"&gt;\n            &lt;h3&gt;{item.title}&lt;/h3&gt;\n            &lt;p&gt;{item.description}&lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default DataItem;\n</code></pre> <p>A component to fetch and display the data.</p> <pre><code>// src/components/DataDisplay.js\n\nimport React, { useState, useEffect } from 'react';\nimport { fetchData } from '../api/fetchData';\nimport DataItem from './DataItem';\n\nconst DataDisplay = () =&gt; {\n    const [data, setData] = useState([]);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n\n    useEffect(() =&gt; {\n        const getData = async () =&gt; {\n            setLoading(true);\n            const result = await fetchData();\n            if (result) {\n                setData(result);\n            } else {\n                setError('Failed to fetch data');\n            }\n            setLoading(false);\n        };\n\n        getData();\n    }, []);\n\n    if (loading) return &lt;p&gt;Loading...&lt;/p&gt;;\n    if (error) return &lt;p&gt;{error}&lt;/p&gt;;\n\n    return (\n        &lt;div className=\"data-display\"&gt;\n            {data.map(item =&gt; (\n                &lt;DataItem key={item.id} item={item} /&gt;\n            ))}\n        &lt;/div&gt;\n    );\n};\n\nexport default DataDisplay;\n</code></pre> <p>The main app component where DataDisplay is used.</p> <pre><code>import React from 'react';\nimport DataDisplay from './components/DataDisplay';\nimport './styles/App.css';\n\nconst App = () =&gt; {\n    return (\n        &lt;div className=\"app\"&gt;\n            &lt;h1&gt;My Data App&lt;/h1&gt;\n            &lt;DataDisplay /&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default App;\n</code></pre> <p>The entry point of the React application.</p> <pre><code>import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport './styles/App.css';\n\nReactDOM.render(\n    &lt;React.StrictMode&gt;\n        &lt;App /&gt;\n    &lt;/React.StrictMode&gt;,\n    document.getElementById('root')\n);\n</code></pre> <p>Basic styles for the application.</p> <pre><code>.app {\n    text-align: center;\n}\n\n.data-display {\n    display: flex;\n    flex-wrap: wrap;\n    justify-content: center;\n}\n\n.data-item {\n    border: 1px solid #ccc;\n    padding: 16px;\n    margin: 8px;\n    width: 200px;\n    text-align: left;\n}\n</code></pre> <p>Summary</p> <p>This example shows a simple way to structure a React application that fetches data from an API and displays it without using any state management libraries. The <code>fetchData</code> function in the <code>api</code> folder handles the API request. The <code>DataDisplay</code> component uses <code>useState</code> and <code>useEffect</code> hooks to manage and display the data. This approach is sufficient for smaller applications or components with limited state management needs.</p>"},{"location":"frontend/react/core/basic/guides/","title":"Guide","text":"<p>React Design Patterns and Best Practices page number: 82</p> <p>Props are the way a parent component can pass its data down the tree to every component that needs it (or part of it).</p> <p>When a component passes some props to another component, it is called the Owner, irrespective of the parent-child relation between them.</p>"},{"location":"frontend/react/core/basic/guides/#children","title":"Children","text":"<p>There is a special prop that can be passed from the owners to the components defined inside their render method; it is called children.</p> <p>In the React documentation, it is described as <code>opaque</code> because it is a property that does not tell anything about the value it contains.</p>"},{"location":"frontend/react/core/basic/guides/#react-hooks-reference","title":"React Hooks Reference","text":"<ul> <li>Learn core Redux \u2014 The easiest way you can imagine</li> <li> <p>Redux Toolkit \u2014 The cheat sheet for Redux development</p> </li> <li> <p>React Hooks cheat sheet: Best practices with examples</p> </li> <li> <p>React Hooks Cheat Sheet</p> </li> <li> <p>React Hooks Cheatsheet \u2014 Most commonly used hooks in ReactJS</p> </li> <li> <p>The React Cheatsheet for 2021 (+ Real-World Examples)</p> </li> </ul>"},{"location":"frontend/react/core/basic/guides/#reference","title":"Reference","text":"<p>LinkedIn React Post</p>"},{"location":"frontend/react/core/basic/migrating-cra-vite/","title":"Migrating Cra to vite","text":""},{"location":"frontend/react/core/basic/migrating-cra-vite/#migrating-create-react-app-to-vite","title":"Migrating create-react-app to Vite","text":"<pre><code>for x in src/**/*.js; do mv \"$x\" \"${x%.js}.jsx\"; done\n</code></pre>"},{"location":"frontend/react/core/basic/migrating-cra-vite/#heres-a-modified-version","title":"Here's a modified version","text":"<p>You can use the find command along with exec to achieve this more efficiently.</p> bash<pre><code>find src -type f -name '*.js' -exec sh -c 'mv \"$1\" \"${1%.js}.jsx\"' _ {} \\;\n</code></pre> <p>Explanation of the command:</p> <ul> <li> <p><code>find src -type f -name '*.js'</code>:</p> <p>This part finds all files (<code>-type f</code>) with a .js extension in the <code>src</code> directory.</p> </li> <li> <p><code>-exec sh -c 'mv \"$1\" \"${1%.js}.jsx\"' _ {} \\;</code>:</p> <p>For each file found, it executes the given shell command to rename the file. The <code>{}</code> is a placeholder for the file name, and the <code>_</code> is a placeholder for <code>$0</code> in the shell command.</p> <p>So, when you run this command, it will find all <code>.js</code> files in the src directory and rename them to <code>.jsx</code>. Make sure to run this command from the parent directory containing the src directory.</p> </li> </ul>"},{"location":"frontend/react/core/basic/migrating-cra-vite/#editor-in-react","title":"Editor in React","text":"<ul> <li>TinyMCE React</li> <li>ckeditor5-react</li> </ul>"},{"location":"frontend/react/core/basic/migrating-cra-vite/#outdated-library","title":"Outdated Library","text":"<ul> <li>react-kanban: archived</li> </ul>"},{"location":"frontend/react/core/basic/migrating-cra-vite/#reference","title":"Reference","text":"<ul> <li>Upgrade React: w3schools</li> <li>create-react-app to vite: youtube</li> <li>Bash Scripting to changes all file name</li> </ul>"},{"location":"frontend/react/core/basic/react-context-api/","title":"react context api","text":""},{"location":"frontend/react/core/basic/react-context-api/#react-context-api","title":"React Context API","text":"<pre><code># Context API Folder Structure\n\nsrc/\n|-- components/\n|-- context/\n|   |-- MyContext.js\n|   |-- MyContextProvider.js\n|-- pages/\n|-- App.js\n|-- index.js\n</code></pre> <p>The React Context API allows you to share state or behavior across your React components without having to pass props manually through each level of the component tree. Here's a simple guide on how to use the React Context API:</p>"},{"location":"frontend/react/core/basic/react-context-api/#step-1-create-a-context","title":"Step 1: Create a Context","text":"<p>You can create a new context using the <code>createContext</code> function from React.</p> MyContext.js<pre><code>import { createContext } from \"react\";\n\nconst MyContext = createContext();\n\nexport default MyContext;\n</code></pre>"},{"location":"frontend/react/core/basic/react-context-api/#step-2-create-a-provider-component","title":"Step 2: Create a Provider Component","text":"<p>Create a provider component that will wrap the part of your component tree where you want to make the context available. This provider component will be responsible for managing the state that you want to share.</p> MyContextProvider.js<pre><code>import React, { useState } from \"react\";\nimport MyContext from \"./MyContext\";\n\nconst MyContextProvider = ({ children }) =&gt; {\n  const [myState, setMyState] = useState(\"Initial value\");\n\n  const updateState = (newValue) =&gt; {\n    setMyState(newValue);\n  };\n\n  return (\n    &lt;MyContext.Provider value={{ myState, updateState }}&gt;\n      {children}\n    &lt;/MyContext.Provider&gt;\n  );\n};\n\nexport default MyContextProvider;\n</code></pre>"},{"location":"frontend/react/core/basic/react-context-api/#step-3-wrap-your-app-with-the-provider","title":"Step 3: Wrap Your App with the Provider","text":"<p>Wrap your main App component (or any parent component) with the provider component you created. This will make the context and its state available to all the components within that part of the component tree.</p> App.js<pre><code>import React from \"react\";\nimport MyContextProvider from \"./MyContextProvider\";\nimport MyComponent from \"./MyComponent\";\n\nconst App = () =&gt; {\n  return (\n    &lt;MyContextProvider&gt;\n      &lt;MyComponent /&gt;\n    &lt;/MyContextProvider&gt;\n  );\n};\n\nexport default App;\n</code></pre>"},{"location":"frontend/react/core/basic/react-context-api/#step-4-consume-the-context-in-a-component","title":"Step 4: Consume the Context in a Component","text":"<p>Now, any component within the wrapped part of the tree can consume the context using the useContext hook.</p> MyComponent.js<pre><code>import React, { useContext } from \"react\";\nimport MyContext from \"./MyContext\";\n\nconst MyComponent = () =&gt; {\n  const { myState, updateState } = useContext(MyContext);\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Value from context: {myState}&lt;/p&gt;\n      &lt;button onClick={() =&gt; updateState(\"New value\")}&gt;Update Context&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default MyComponent;\n</code></pre> <p>Notes</p> <p>The key idea is that the state or functions you provide through the context provider become accessible to all the components that consume that context within the wrapped part of the component tree.</p>"},{"location":"frontend/react/core/basic/react-context-api/#reference","title":"Reference","text":"<ul> <li>How to Use the React Context API in Your Projects: good</li> <li>React Context API: What is it and How it works?</li> </ul>"},{"location":"frontend/react/core/basic/react-router/","title":"react router","text":""},{"location":"frontend/react/core/basic/react-router/#router","title":"Router","text":"<pre><code>// Installation\n\n$ pnpm install react-router-dom\n</code></pre>"},{"location":"frontend/react/core/basic/react-router/#how-to-install-react-router","title":"How to Install React Router?","text":"<p>React router contains 3 different packages for routing.</p> <ul> <li><code>react-router</code>: contains most of the core functionality of React Router including the route matching algorithm and most of the core components and react hooks</li> <li><code>react-router-native</code>: It is designed for mobile applications.</li> <li><code>react-router-dom</code>: It is designed for web applications.</li> </ul>"},{"location":"frontend/react/core/basic/react-router/#components-in-react-router","title":"Components in React Router","text":"<p>React router components are divided into 3 main categories -</p> <ul> <li><code>Routers</code> - for instance, <code>&lt;BrowserRouter&gt;</code> and <code>&lt;HashRouter&gt;</code> components</li> <li><code>Route matchers</code> - for instance, <code>&lt;Routes&gt;</code> and <code>&lt;Route&gt;</code> components</li> <li><code>Navigation</code> \u2013 for instance, <code>&lt;Link&gt;</code> and <code>&lt;NavLink&gt;</code> components</li> </ul> <p></p>"},{"location":"frontend/react/core/basic/react-router/#code","title":"Code","text":"<pre><code>import { BrowserRouter as Router, Switch, Route } from \"react-router-dom\";\n\nexport default function App() {\n  return (\n    &lt;Router&gt;\n      &lt;Navbar /&gt;\n      &lt;Switch&gt;\n        &lt;Route exact path=\"/\" component={Home} /&gt;\n        &lt;Route path=\"/about\" component={About} /&gt;\n      &lt;/Switch&gt;\n    &lt;/Router&gt;\n  );\n}\n</code></pre>"},{"location":"frontend/react/core/basic/react-router/#redirect-component","title":"Redirect Component","text":"<pre><code>import {\n  BrowserRouter as Router,\n  Switch,\n  Route,\n  Redirect\n} from \"react-router-dom\";\n\nexport default function App() {\n  return (\n    &lt;Router&gt;\n      &lt;Switch&gt;\n        &lt;Route exact path=\"/\" component={Home} /&gt;\n        &lt;PrivateRoute path=\"/hidden\" component={Hidden} /&gt;\n      &lt;/Switch&gt;\n    &lt;/Router&gt;\n  );\n}\n\nfunction PrivateRoute({ component: Component, ...rest }) {\n  // useAuth is some custom hook to get the current user's auth state\n  const isAuth = useAuth();\n\n  return (\n    &lt;Route\n      {...rest}\n      render={(props) =&gt;\n        isAuth ? &lt;Component {...props} /&gt; : &lt;Redirect to=\"/\" /&gt;\n      }\n    /&gt;\n  );\n}\n\nfunction Home() {\n  return &lt;&gt;home&lt;/&gt;;\n}\n\nfunction Hidden() {\n  return &lt;&gt;hidden&lt;/&gt;;\n}\n</code></pre> <p>The redirect component is very simple to use, very declarative, and allows us to see the great benefit of React Router DOM being component-based, just like everything in React.</p>"},{"location":"frontend/react/core/basic/react-router/#react-router-hooks","title":"React Router Hooks","text":"<ul> <li>useHistory Hook</li> <li>useLocation Hook</li> <li>useParams Hook + Dynamic Routes</li> <li>useRouteMatch Hook</li> </ul> <pre><code>import { useHistory } from \"react-router-dom\";\n\n\nfunction About() {\n  const history = useHistory();\n\n  console.log(history.location.pathname); // '/about'\n\n  return (\n    &lt;&gt;\n     &lt;h1&gt;The about page is on: {history.location.pathname}&lt;/h1&gt;\n     &lt;button onClick={() =&gt; history.push('/')}&gt;Go to home page&lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre>"},{"location":"frontend/react/core/basic/react-router/#upgrading-fro-v5-to-v6","title":"Upgrading fro <code>v5</code> to <code>v6</code>","text":"<ul> <li>Upgrade all <code>&lt;Switch&gt;</code> elements to <code>&lt;Routes&gt;</code></li> <li>Use <code>useNavigate</code> instead of <code>useHistory</code></li> <li>Replace <code>useRouteMatch</code> with <code>useMatch</code></li> </ul> <p>Replacing Switch component with Routes</p> <pre><code>// old with Switch\n\nexport function App() {\n  return (\n    &lt;div&gt;\n      &lt;Switch&gt;\n        &lt;Route path=\"/about\"&gt;\n          &lt;AboutPage /&gt;\n        &lt;/Route&gt;\n        &lt;Route exact path=\"/profile\"&gt;\n          &lt;ProfilePage /&gt;\n        &lt;/Route&gt;\n        &lt;Route path=\"/profile/:id\"&gt;\n          &lt;ProfileUserPage /&gt;\n        &lt;/Route&gt;\n      &lt;/Switch&gt;\n    &lt;/div&gt;\n  )\n}\n\n// new with Routes\n\nexport function App() {\n  return (\n    &lt;div&gt;\n      &lt;Routes&gt;\n        &lt;Route path=\"/about\" element={&lt;AboutPage /&gt;} /&gt;\n        &lt;Route exact path=\"/profile\" element={&lt;ProfilePage /&gt;} /&gt;\n        &lt;Route path=\"/profile/:id\" element={&lt;ProfileUserPage /&gt;} /&gt;\n      &lt;/Routes&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre> <p>Internal changes &amp; path evaluation (no more needed exact prop) For V5 we needed to put the exact prop on the component to go for that specific route we want</p> <pre><code>// old\n\nexport function App() {\n  return (\n    &lt;div&gt;\n      &lt;Routes&gt;\n        &lt;Route path=\"/about\" element={&lt;AboutPage /&gt;} /&gt;\n        &lt;Route exact path=\"/profile\" element={&lt;ProfilePage /&gt;} /&gt;\n        &lt;Route path=\"/profile/:id\" element={&lt;ProfileUserPage /&gt;} /&gt;\n      &lt;/Routes&gt;\n    &lt;/div&gt;\n  )\n}\n\n// new\nexport function App() {\n  return (\n    &lt;div&gt;\n      &lt;Routes&gt;\n        &lt;Route path=\"/about\" element={&lt;AboutPage /&gt;} /&gt;\n        &lt;Route path=\"/profile\" element={&lt;ProfilePage /&gt;} /&gt;\n        &lt;Route path=\"/profile/:id\" element={&lt;ProfileUserPage /&gt;} /&gt;\n      &lt;/Routes&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre>"},{"location":"frontend/react/core/basic/react-router/#history","title":"History","text":"<pre><code>$ npm i history\n</code></pre> <p>There are three types of history</p> <ul> <li>browser</li> <li>hash</li> <li>memory</li> </ul> <pre><code>import {\n  createBrowserHistory,\n  createHashHistory,\n  createMemoryHistory\n} from 'history'\n</code></pre> <p>If you are using React Router, it can automatically create history objects for you, so you may never have to actually interact with history directly. Still, it is important to understand the differences between each type of history so that you can determine which one is right for your project.</p>"},{"location":"frontend/react/core/basic/react-router/#reference","title":"Reference","text":"<ul> <li>React router overview</li> <li>React Router - Types, Mechanism, Installation And Examples</li> <li>The React Router Cheatsheet \u2013 Everything You Need to Know - (BEST)</li> <li>Using Hashrouter With React - Definitive Guide</li> <li>What is Hash Routing?</li> <li>upgrading v5 - v6: oficial doc</li> <li>React router V6: Some of the new changes </li> <li>A little bit of history - npm</li> <li>history - npm</li> </ul>"},{"location":"frontend/react/core/basic/useCallback/","title":"useCallback","text":""},{"location":"frontend/react/core/basic/useCallback/#usecallback-hook","title":"useCallback Hook","text":"<p><code>useCallback</code> is a React hook that is used to memoize functions so that they do not get recreated on each render, which can be useful to optimize performance in certain scenarios. Here's a simple real example to illustrate the use of <code>useCallback</code>.</p> <p></p> <pre><code>import React, { useState, useCallback } from \"react\";\n\nconst ExampleComponent = () =&gt; {\n  const [count, setCount] = useState(0);\n\n  // Without useCallback\n  const handleClickWithoutCallback = () =&gt; {\n    console.log(\"Button clicked!\");\n    setCount(count + 1);\n  };\n\n  // With useCallback\n  const handleClickWithCallback = useCallback(() =&gt; {\n    console.log(\"Button clicked!\");\n    setCount(count + 1);\n  }, [count]);\n  // Dependency array: specify dependencies that should trigger function re-creation\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Count: {count}&lt;/p&gt;\n\n      &lt;button onClick={handleClickWithoutCallback}&gt;\n        Click Without useCallback\n      &lt;/button&gt;\n\n      &lt;button onClick={handleClickWithCallback}&gt;Click With useCallback&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default ExampleComponent;\n</code></pre> <p>In this example:</p> <ul> <li>The component renders a count state variable.</li> <li>There are two buttons: one <code>without useCallback</code> and one <code>with useCallback</code>.</li> <li>The <code>handleClickWithoutCallback</code> function is created inside the component body, so it is recreated on every render. This can lead to unnecessary re-renders of child components if passed down as props.</li> <li>The <code>handleClickWithCallback</code> function is memoized using useCallback, and the dependency array <code>[count]</code> specifies that the function should be recreated only when the <code>count</code> variable changes. This can be useful to prevent unnecessary function recreation and optimize performance.</li> </ul> <p>In this simple example, the difference might not be significant, but in larger applications, especially when passing functions down to child components, using <code>useCallback</code> can help optimize performance by avoiding unnecessary re-renders triggered by new function instances.</p> <p>Scenario: When to use useCallback &amp; when not to use</p> <p>Here are some scenarios where using useCallback in React can be beneficial, and situations where it may not be necessary:</p> <p>Use useCallback:</p> <ol> <li> <p>Optimizing Child Components:</p> <ul> <li>When passing callback functions as props to child components.</li> <li>It prevents unnecessary re-renders of child components if the callback function reference changes.</li> </ul> <pre><code>const ParentComponent = () =&gt; {\n  const handleClick = useCallback(() =&gt; {\n    console.log(\"Button clicked!\");\n  }, []);\n\n  return &lt;ChildComponent onClick={handleClick} /&gt;;\n};\n</code></pre> </li> <li> <p>Event Handlers in Dependencies:</p> <ul> <li>When using callback functions in the dependency array of <code>useEffect</code> to avoid unnecessary re-execution of the effect.   <pre><code>useEffect(() =&gt; {\n  // Effect logic\n}, [callbackFunction]);\n</code></pre></li> </ul> </li> <li> <p>Preventing Unnecessary Function Recreation:</p> <ul> <li>When you want to avoid recreating functions on each render, especially if those functions are passed as dependencies to other hooks or functions.   <pre><code>const memoizedFunction = useCallback(() =&gt; {\n  // Function logic\n}, [dependency1, dependency2]);\n</code></pre></li> </ul> </li> </ol> <p>Might Not Need useCallback:</p> <ol> <li> <p>Local Functions:</p> <ul> <li>If a function is defined inside a component and doesn't need to be referenced outside that component or passed down to child components, it may not need <code>useCallback</code></li> </ul> <pre><code>const MyComponent = () =&gt; {\n  const localFunction = () =&gt; {\n    // Local function logic\n  };\n\n  // No need for useCallback if localFunction is not passed as a prop or used in dependencies.\n  // ...\n};\n</code></pre> </li> <li> <p>Static Dependencies:</p> <ul> <li>If the function doesn't depend on any external variables or props, and its behavior is consistent across renders, <code>useCallback</code> might not be necessary.</li> </ul> <pre><code>const simpleFunction = () =&gt; {\n  // Function logic without dependencies\n};\n\n// No need for useCallback if simpleFunction doesn't depend on external variables.\n</code></pre> </li> <li> <p>Performance Impact is Negligible:</p> <ul> <li>In some cases, the performance impact of not using useCallback might be negligible, especially for smaller components or when function recreation does not affect the overall performance.</li> </ul> </li> </ol> <p>It's important to use <code>useCallback</code> judiciously and consider the specific use case and performance requirements of your application. If in doubt, you can start without <code>useCallback</code> and optimize later if performance becomes an issue.</p>"},{"location":"frontend/react/core/basic/useCallback/#reference","title":"Reference","text":"<ul> <li>Your Guide to React.useCallback()</li> <li>Demystifying React Hooks: useCallback and useMemo </li> </ul>"},{"location":"frontend/react/core/basic/useEffect-cleanup/","title":"useEffect cleanup","text":"<p>A cleanup function in React is typically used to perform necessary cleanup or resource disposal when a component unmounts. Here are some scenarios in which you should consider writing a cleanup function using the <code>useEffect</code> hook:</p>"},{"location":"frontend/react/core/basic/useEffect-cleanup/#1-clearing-subscriptions-or-timers","title":"1. Clearing Subscriptions or Timers:","text":"<p>If your component sets up subscriptions (e.g., using <code>addEventListener</code>) or timers (e.g., using <code>setTimeout</code> or <code>setInterval</code>), it's crucial to clean them up when the component is unmounted to avoid memory leaks and unexpected behavior.</p> jsx<pre><code>useEffect(() =&gt; {\n  const timerId = setInterval(() =&gt; {\n    // Your logic here\n  }, 1000);\n\n  return () =&gt; {\n    // Cleanup: Clear the timer when the component unmounts\n    clearInterval(timerId);\n  };\n}, []);\n</code></pre>"},{"location":"frontend/react/core/basic/useEffect-cleanup/#2-canceling-network-requests","title":"2. Canceling Network Requests:","text":"<p>If your component makes asynchronous requests (e.g., using <code>fetch</code>), you might want to cancel or abort the request if the component is unmounted to prevent setting state on an unmounted component.</p> jsx<pre><code>useEffect(() =&gt; {\n  const abortController = new AbortController();\n\n  const fetchData = async () =&gt; {\n    try {\n      const response = await fetch(\"https://api.example.com/data\", {\n        signal: abortController.signal,\n      });\n      const data = await response.json();\n      setData(data);\n    } catch (error) {\n      if (error.name === \"AbortError\") {\n        // Request was canceled (component unmounted)\n      } else {\n        console.error(\"Error fetching data:\", error);\n      }\n    }\n  };\n\n  fetchData();\n\n  return () =&gt; {\n    // Cleanup: Cancel the request if the component unmounts\n    abortController.abort();\n  };\n}, []);\n</code></pre>"},{"location":"frontend/react/core/basic/useEffect-cleanup/#3-cleaning-up-external-resources","title":"3. Cleaning Up External Resources:","text":"<p>If your component interacts with external resources or libraries (e.g., closing a WebSocket connection, cleaning up a third-party library instance), the cleanup function is the right place to perform these actions.</p> jsx<pre><code>useEffect(() =&gt; {\n  const socket = new WebSocket(\"wss://example.com\");\n\n  socket.addEventListener(\"open\", () =&gt; {\n    // Your logic here\n  });\n\n  return () =&gt; {\n    // Cleanup: Close the WebSocket connection when the component unmounts\n    socket.close();\n  };\n}, []);\n</code></pre>"},{"location":"frontend/react/core/basic/useEffect-cleanup/#4-resetting-state-or-side-effects","title":"4. Resetting State or Side Effects:","text":"<p>If your component needs to reset certain state variables or undo side effects when it unmounts, the cleanup function can be used for such purposes.</p> jsx<pre><code>useEffect(() =&gt; {\n  // Your effect logic here\n\n  return () =&gt; {\n    // Cleanup: Reset state or undo side effects when the component unmounts\n    resetState();\n  };\n}, [dependency]);\n</code></pre> <p>Remember that the cleanup function is an essential part of the useEffect lifecycle. It ensures that resources are properly released, preventing potential memory leaks or unintended behavior when a component is no longer in use. Always use the cleanup function to perform any necessary cleanup actions specific to the effects you've set up in your component.</p>"},{"location":"frontend/react/core/basic/useEffect-technique-used/","title":"useEffect mostly used","text":"<p>The choice of <code>useEffect</code> technique often depends on the specific requirements of your application. However, one commonly used and versatile pattern is using <code>useEffect</code> for data fetching. This is especially relevant in applications that interact with APIs or external data sources. The pattern typically involves:</p> <ol> <li>Fetching data when the component mounts.</li> <li>Optionally fetching data based on changes in certain dependencies.</li> </ol> <p>Here's a breakdown of this pattern:</p>"},{"location":"frontend/react/core/basic/useEffect-technique-used/#1-fetching-data-on-mount","title":"1. Fetching Data on Mount:","text":"<p>Use <code>useEffect</code> with an empty dependency array to fetch data when the component mounts. This ensures that the effect runs only once after the initial render.</p> jsx<pre><code>useEffect(() =&gt; {\n  const fetchData = async () =&gt; {\n    try {\n      const response = await fetch(\"https://api.example.com/data\");\n      const data = await response.json();\n      setData(data);\n    } catch (error) {\n      console.error(\"Error fetching data:\", error);\n    }\n  };\n\n  fetchData();\n}, []); // Empty dependency array means this effect runs once on mount\n</code></pre>"},{"location":"frontend/react/core/basic/useEffect-technique-used/#2-fetching-data-based-on-dependencies","title":"2. Fetching Data Based on Dependencies:","text":"<p>Use <code>useEffect</code> with specific dependencies to refetch data when those dependencies change. This is useful for scenarios where you need to update data in response to user interactions or changes in the application state.</p> jsx<pre><code>useEffect(() =&gt; {\n  const fetchData = async () =&gt; {\n    try {\n      const response = await fetch(`https://api.example.com/data/${userId}`);\n      const data = await response.json();\n      setData(data);\n    } catch (error) {\n      console.error(\"Error fetching data:\", error);\n    }\n  };\n\n  fetchData();\n}, [userId]); // Refetch data when 'userId' changes\n</code></pre>"},{"location":"frontend/react/core/basic/useEffect-technique-used/#3-cleanup-and-cancellation","title":"3. Cleanup and Cancellation:","text":"<p>Consider incorporating cleanup functions to handle scenarios like canceling pending requests or unsubscribing from external subscriptions when the component unmounts.</p> jsx<pre><code>useEffect(() =&gt; {\n  const abortController = new AbortController();\n\n  const fetchData = async () =&gt; {\n    try {\n      const response = await fetch(\"https://api.example.com/data\", {\n        signal: abortController.signal,\n      });\n      const data = await response.json();\n      setData(data);\n    } catch (error) {\n      if (error.name === \"AbortError\") {\n        // Request was canceled (component unmounted)\n      } else {\n        console.error(\"Error fetching data:\", error);\n      }\n    }\n  };\n\n  fetchData();\n\n  return () =&gt; {\n    // Cleanup: Cancel the request if the component unmounts\n    abortController.abort();\n  };\n}, []);\n</code></pre>"},{"location":"frontend/react/core/basic/useEffect-technique-used/#4-combining-multiple-useeffect-hooks","title":"4. Combining Multiple useEffect Hooks:","text":"<p>Break down complex logic into multiple <code>useEffect</code> hooks for better readability and maintainability. For example, separate data fetching from UI-related side effects.</p> jsx<pre><code>useEffect(() =&gt; {\n  // Fetch initial data\n  const fetchData = async () =&gt; {\n    // ...\n  };\n  fetchData();\n}, []);\n\nuseEffect(() =&gt; {\n  // Handle UI-related side effects\n  // ...\n}, [data, userId]);\n</code></pre>"},{"location":"frontend/react/core/basic/useEffect-technique-used/#5-asyncawait-pattern","title":"5. Async/Await Pattern:","text":"<p>Use the <code>async</code> keyword and <code>await</code> syntax for cleaner asynchronous code within the <code>useEffect</code>.</p> jsx<pre><code>useEffect(() =&gt; {\n  const fetchData = async () =&gt; {\n    try {\n      const response = await fetch(\"https://api.example.com/data\");\n      const data = await response.json();\n      setData(data);\n    } catch (error) {\n      console.error(\"Error fetching data:\", error);\n    }\n  };\n\n  fetchData();\n}, []);\n</code></pre> <p>This data-fetching pattern is commonly used because it covers a wide range of scenarios, from initial data loading to updating data based on changes in specific dependencies. It provides a clean and organized way to manage asynchronous operations in React components.</p>"},{"location":"frontend/react/core/basic/useEffect-technique/","title":"useEffect Technique","text":""},{"location":"frontend/react/core/basic/useEffect-technique/#_1","title":"useEffect Technique","text":"<p>The <code>useEffect</code> hook in React is used for handling side effects in functional components. It is a powerful tool that allows you to perform operations such as data fetching, subscriptions, or manually changing the DOM in response to component lifecycle events. Here are some advanced techniques and use cases for the <code>useEffect</code> hook:</p>"},{"location":"frontend/react/core/basic/useEffect-technique/#1-conditional-execution","title":"1. Conditional Execution:","text":"<p>Use <code>useEffect</code> with dependencies to conditionally execute code when certain dependencies change. This is useful for optimizing performance and avoiding unnecessary computations.</p> jsx<pre><code>useEffect(() =&gt; {\n  // Effect will run when 'dependency' changes\n  fetchData(dependency);\n}, [dependency]);\n</code></pre>"},{"location":"frontend/react/core/basic/useEffect-technique/#2-cleanup-function","title":"2. Cleanup Function:","text":"<p>Use the cleanup function returned by <code>useEffect</code> for cleanup operations, such as canceling subscriptions or clearing intervals.</p> jsx<pre><code>useEffect(() =&gt; {\n  const subscription = subscribe();\n  return () =&gt; {\n    // Cleanup function: unsubscribe when the component unmounts\n    subscription.unsubscribe();\n  };\n}, []); // Empty dependency array means this effect runs once on mount\n</code></pre>"},{"location":"frontend/react/core/basic/useEffect-technique/#3-debouncing-and-throttling","title":"3. Debouncing and Throttling:","text":"<p>Use <code>useEffect</code> in combination with debouncing or throttling techniques to limit the rate at which a function is called.</p> jsx<pre><code>useEffect(() =&gt; {\n  const debouncedFunction = debounce(() =&gt; {\n    // Code to run after debounce\n  }, 300);\n\n  // Attach the debounced function to an event listener, for example\n  window.addEventListener(\"scroll\", debouncedFunction);\n\n  return () =&gt; {\n    // Cleanup: remove the event listener when the component unmounts\n    window.removeEventListener(\"scroll\", debouncedFunction);\n  };\n}, []);\n</code></pre>"},{"location":"frontend/react/core/basic/useEffect-technique/#4-global-state-synchronization","title":"4. Global State Synchronization:","text":"<p>Use <code>useEffect</code> to synchronize the component's state with a global state management solution, like Redux.</p> jsx<pre><code>useEffect(() =&gt; {\n  // Update local state when global state changes\n  setLocalState(globalState);\n}, [globalState]);\n</code></pre>"},{"location":"frontend/react/core/basic/useEffect-technique/#5-dependency-arrays-and-stale-closures","title":"5. Dependency Arrays and Stale Closures:","text":"<p>Be careful with dependencies and closures to avoid stale values. Use the functional form of <code>setState</code> to capture the latest state or props.</p> jsx<pre><code>useEffect(() =&gt; {\n  // Avoid stale closures\n  const fetchData = async () =&gt; {\n    const result = await fetch(url);\n    // Use result and capture the latest 'mounted' value\n    if (mounted.current) {\n      setData(result);\n    }\n  };\n\n  fetchData();\n\n  return () =&gt; {\n    // Cleanup: Set 'mounted' to false when the component unmounts\n    mounted.current = false;\n  };\n}, [url]);\n</code></pre>"},{"location":"frontend/react/core/basic/useEffect-technique/#6-multiple-useeffect-for-separation-of-concerns","title":"6. Multiple useEffect for Separation of Concerns:","text":"<p>Use multiple <code>useEffect</code> blocks to separate different concerns, making your code more readable and maintainable.</p> jsx<pre><code>useEffect(() =&gt; {\n  // Code for fetching data\n  fetchData();\n}, [dependencyForDataFetching]);\n\nuseEffect(() =&gt; {\n  // Code for handling UI updates\n  updateUI();\n}, [dependencyForUIUpdate]);\n</code></pre>"},{"location":"frontend/react/core/basic/useEffect-technique/#7-promise-in-useeffect","title":"7. Promise in useEffect:","text":"<p>If you want to work with asynchronous code in <code>useEffect</code>, you can use the async keyword and await syntax.</p> jsx<pre><code>useEffect(() =&gt; {\n  const fetchData = async () =&gt; {\n    try {\n      const result = await fetchDataFromAPI();\n      setData(result);\n    } catch (error) {\n      console.error(\"Error fetching data:\", error);\n    }\n  };\n\n  fetchData();\n}, [dependency]);\n</code></pre>"},{"location":"frontend/react/core/basic/useEffect-technique/#8-combining-useeffect-with-other-hooks","title":"8. Combining useEffect with Other Hooks:","text":"<p>Combine useEffect with other hooks like useMemo or useCallback for more fine-grained control over the memoization of values and functions.</p> jsx<pre><code>const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);\n\nuseEffect(() =&gt; {\n  // Effect using memoizedValue\n  performEffectWithMemoizedValue(memoizedValue);\n}, [memoizedValue]);\n</code></pre> <p>Notes</p> <p>By mastering these advanced techniques, you can make the most of the useEffect hook in your React applications and handle complex scenarios with ease. Always consider the specific requirements of your application and choose the approach that best fits your use case.</p>"},{"location":"frontend/react/core/basic/useRef/","title":"useRef","text":""},{"location":"frontend/react/core/basic/useRef/#useref-hooks","title":"useRef hooks","text":"<p><code>useRef</code> is a React hook that provides a way to create a mutable object that persists across renders. It's commonly used to access and interact with a DOM element or to persist values across renders without causing re-renders.</p> <p>Here's a beginner's guide on how to use useRef in React:</p>"},{"location":"frontend/react/core/basic/useRef/#basic-usage","title":"Basic Usage:","text":"<ol> <li> <p>Import <code>useRef</code>:</p> <p>Import the useRef hook from React.</p> <pre><code>import React, { useRef } from \"react\";\n</code></pre> </li> <li> <p>Create a Ref:</p> <p>Use useRef() to create a ref object.</p> <pre><code>const myRef = useRef();\n</code></pre> </li> <li> <p>Attach Ref to a JSX Element:</p> <p>Attach the ref to a JSX element using the <code>ref</code> attribute.</p> <pre><code>return &lt;div ref={myRef}&gt;Hello, useRef!&lt;/div&gt;;\n</code></pre> </li> <li> <p>Accessing the DOM Element:</p> <p>Use the <code>.current</code> property of the ref object to access the DOM element.</p> <pre><code>console.log(myRef.current); // Outputs the DOM element\n</code></pre> </li> </ol>"},{"location":"frontend/react/core/basic/useRef/#example-with-a-functional-component","title":"Example with a Functional Component:","text":"<pre><code>import React, { useRef, useEffect } from \"react\";\n\nconst MyComponent = () =&gt; {\n  const myRef = useRef();\n\n  useEffect(() =&gt; {\n    // Access the DOM element after the component is mounted\n    console.log(myRef.current);\n  }, []); // Empty dependency array ensures the effect runs only once after mount\n\n  return &lt;div ref={myRef}&gt;Hello, useRef!&lt;/div&gt;;\n};\n\nexport default MyComponent;\n</code></pre>"},{"location":"frontend/react/core/basic/useRef/#use-cases-and-when-to-use-useref","title":"Use Cases and When to Use useRef:","text":"<ol> <li> <p>Accessing or Modifying DOM Elements:</p> <ul> <li>Use <code>useRef</code> when you need to access or modify a DOM element directly. For example, focusing an input field, measuring an element, or triggering imperative animations.</li> </ul> <pre><code>const inputRef = useRef();\n\nuseEffect(() =&gt; {\n  inputRef.current.focus();\n}, []);\n</code></pre> </li> <li> <p>Holding Mutable Values Without Causing Rerenders:</p> <ul> <li><code>useRef</code> can hold mutable values that persist across renders without causing re-renders. This is useful for storing values that shouldn't trigger component updates.</li> </ul> <pre><code>const countRef = useRef(0);\n\nuseEffect(() =&gt; {\n  countRef.current += 1;\n  console.log(\"Render count:\", countRef.current);\n});\n</code></pre> </li> <li> <p>Storing Previous Values:</p> <ul> <li>Use <code>useRef</code> to store and compare previous values, useful for certain scenarios like tracking changes in dependencies.</li> </ul> <pre><code>const prevValueRef = useRef();\nuseEffect(() =&gt; {\n  if (value !== prevValueRef.current) {\n    console.log(\"Value changed!\");\n  }\n  prevValueRef.current = value;\n}, [value]);\n</code></pre> <p>Remember that the ref value persists between renders, so changes to <code>.current</code> do not trigger a re-render. This makes <code>useRef</code> suitable for scenarios where you need to hold mutable values across renders without causing unnecessary updates.</p> </li> </ol>"},{"location":"frontend/react/core/fake-api/intro/","title":"Intro","text":"<p>Faking an API in a React application is useful for testing and development purposes. Here are a few common methods:</p>"},{"location":"frontend/react/core/fake-api/intro/#1-using-mock-service-workers-msw","title":"1. Using Mock Service Workers (MSW)","text":"<p>MSW is a powerful library for mocking API requests. It intercepts requests at the network level and returns mock responses. This is especially useful for integration testing and development.</p> Setup MSW: <ol> <li> <p>Install the library:</p> <pre><code>npm install msw --save-dev\n</code></pre> </li> <li> <p>Create a mock handler file (<code>mocks/handlers.js</code>):</p> <pre><code>import { rest } from 'msw';\n\nexport const handlers = [\n    rest.get('/api/your-endpoint', (req, res, ctx) =&gt; {\n        return res(ctx.json({ message: 'This is a mock response' }));\n    }),\n    // Add more handlers for different endpoints and methods\n];\n</code></pre> </li> <li> <p>Setup the mock server in your application (<code>mocks/browser.js</code>):</p> <pre><code>import { setupWorker } from 'msw';\nimport { handlers } from './handlers';\n\nconst worker = setupWorker(...handlers);\n\nworker.start();\n</code></pre> </li> <li> <p>Include the mock server setup in your application entry point (<code>index.js</code> or <code>App.js</code>):</p> <pre><code>import './mocks/browser';\n</code></pre> </li> </ol>"},{"location":"frontend/react/core/fake-api/intro/#2-using-json-server","title":"2. Using json-server","text":"<p>json-server is a simple tool to create a fake REST API using a JSON file.</p> <pre><code>your-project/\n\u251c\u2500\u2500 public/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 layouts/\n\u2502   \u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 utils/\n\u2502   \u251c\u2500\u2500 views/\n\u2502   \u251c\u2500\u2500 App.js\n\u2502   \u251c\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 ... (other source files)\n\u251c\u2500\u2500 db/\n\u2502   \u251c\u2500\u2500 db.json\n\u2502   \u2514\u2500\u2500 start-mock-api.js\n\u251c\u2500\u2500 node_modules/\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 webpack.config.js\n\u2514\u2500\u2500 ... (other configuration files)\n</code></pre> db.jsonstart-mock-api.jspackage.json <pre><code>{\n    \"posts\": [\n        { \"id\": 1, \"title\": \"Hello World\" },\n        { \"id\": 2, \"title\": \"json-server is awesome\" }\n    ],\n    \"comments\": [\n        { \"id\": 1, \"body\": \"some comment\", \"postId\": 1 }\n    ],\n    \"profile\": { \"name\": \"typicode\" }\n}\n</code></pre> <pre><code>const jsonServer = require('json-server');\nconst path = require('path');\nconst server = jsonServer.create();\nconst router = jsonServer.router(path.join(__dirname, 'db.json'));\nconst middlewares = jsonServer.defaults();\n\nserver.use(middlewares);\nserver.use(router);\n\nconst PORT = 5000;\nserver.listen(PORT, () =&gt; {\n    console.log(`JSON Server is running on port ${PORT}`);\n});\n</code></pre> <pre><code>\"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"dockerbuild\": \"react-scripts --openssl-legacy-provider build\",\n    \"mac-start-run\": \"react-scripts --openssl-legacy-provider start\",\n    \"test\": \"react-scripts test\",\n    \"eject\": \"react-scripts eject\",\n    \"product\": \"set PORT=4200 &amp;&amp; react-scripts start\",\n    \"start:mock-api\": \"node db/start-mock-api.js\",\n    \"start:all\": \"concurrently \\\"npm run product\\\" \\\"npm run start:mock-api\\\"\"\n}\n</code></pre> Setup json-server: <ol> <li> <p>Install <code>json-server</code>:</p> <pre><code>npm install json-server --save-dev\n\n//or\n\nnpm install json-server@0.16.3 --save-dev\n</code></pre> </li> <li> <p>Create a <code>db.json</code> file with your mock data:</p> <pre><code>{\n    \"posts\": [\n        { \"id\": 1, \"title\": \"Hello World\" }\n    ]\n}\n</code></pre> </li> <li> <p>Add a script to your <code>package.json</code> to start the server:</p> <pre><code>\"scripts\": {\n    \"start:mock-api\": \"json-server --watch db.json --port 5000\"\n}\n</code></pre> </li> <li> <p>Run the mock API server:</p> <pre><code>npm run start:mock-api\n</code></pre> </li> </ol> <p>You can now make requests to <code>http://localhost:5000/posts</code>.</p> <p>Start Both Servers:</p> <p>Use <code>concurrently</code> to start both the React app and the mock API server.</p> <pre><code>npm run start:all\n</code></pre>"},{"location":"frontend/react/core/fake-api/intro/#3-using-a-simple-mock-with-axios-or-fetch","title":"3. Using a Simple Mock with Axios or Fetch","text":"<p>You can create a simple mock directly in your React application by intercepting API calls with Axios or Fetch.</p> Example using Axios: <ol> <li> <p>Install Axios:</p> <pre><code>npm install axios\n</code></pre> </li> <li> <p>Create a mock API file (<code>apiMock.js</code>):</p> <pre><code>import axios from 'axios';\n\nconst mockResponse = {\n    data: { message: 'This is a mock response' },\n};\n\naxios.interceptors.request.use(request =&gt; {\n    if (request.url === '/api/your-endpoint') {\n        return Promise.resolve(mockResponse);\n    }\n    return request;\n});\n</code></pre> </li> <li> <p>Import and use the mock API file in your application (<code>App.js</code>):</p> <pre><code>import './apiMock';\n</code></pre> </li> </ol> <p>Now, when your app makes requests to <code>/api/your-endpoint</code>, it will receive the mock response.</p> <p>These methods allow you to simulate API responses and test how your React application handles different scenarios without needing a real backend.</p>"},{"location":"frontend/react/core/fake-api/intro/#among-the-methods-mentioned","title":"Among the methods mentioned:","text":"<ol> <li> <p>Mock Service Workers (MSW) is the most popular and widely used method for mocking APIs in modern React applications. It provides a comprehensive and flexible solution for intercepting network requests and mocking responses. MSW is especially popular in testing environments due to its ability to handle various HTTP methods and work with both REST and GraphQL APIs. It integrates well with testing libraries like Jest and React Testing Library.</p> </li> <li> <p>json-server is also popular, particularly for creating a quick and simple REST API with a JSON file. It is commonly used for local development and prototyping. While it\u2019s less flexible compared to MSW in terms of handling different types of requests and responses, it's still a useful tool for generating mock data and endpoints quickly.</p> </li> <li> <p>Using a Simple Mock with Axios or Fetch is less common compared to the other methods but can be useful for very basic scenarios or when you need a quick solution without setting up additional libraries. It\u2019s typically used for simpler use cases or when integrating mocks directly into the application code is sufficient.</p> </li> </ol> <p>For most React applications, MSW is the go-to choice due to its robust features and flexibility in handling various mocking scenarios.</p>"},{"location":"frontend/react/core/fake-api/json-server/","title":"Use Mocking Libraries","text":""},{"location":"frontend/react/core/fake-api/json-server/#2-use-mocking-libraries-eg-json-server-miragejs","title":"2. Use Mocking Libraries (e.g., <code>json-server</code>, <code>MirageJS</code>):","text":"<ul> <li><code>json-server</code>: A full fake REST API server that you can run locally.</li> </ul> <pre><code>npm install json-server\n</code></pre> Steps: <ol> <li> <p>Install json-server:</p> <pre><code>npm install -g json-server\n</code></pre> </li> <li> <p>Create a <code>db.json</code> file with some mock data:</p> json<pre><code>{\n    \"users\": [\n        { \"id\": 1, \"name\": \"John Doe\" },\n        { \"id\": 2, \"name\": \"Jane Smith\" }\n    ]\n}\n</code></pre> </li> <li> <p>Run the server:</p> <pre><code>json-server --watch db.json --port 5000\n</code></pre> </li> <li> <p>Now, you can access your API at <code>http://localhost:5000/users</code>.</p> </li> </ol> Example in Vue/React/Angular: <pre><code>fetch(\"http://localhost:5000/users\")\n.then((response) =&gt; response.json())\n.then((data) =&gt; console.log(data));\n</code></pre>"},{"location":"frontend/react/core/fake-api/json-server/#example","title":"Example","text":"Abstract 1. Basic Example2. Intermediate Example3. Advanced Example <p>This example will create a simple REST API using json-server to serve basic user data.</p> Steps: <ol> <li> <p>Install <code>json-server</code> globally (if not already installed):</p> <pre><code>npm install -g json-server\n</code></pre> </li> <li> <p>Create a <code>db.json</code> file:</p> <pre><code>{\n    \"users\": [\n        { \"id\": 1, \"name\": \"John Doe\", \"email\": \"john@example.com\" },\n        { \"id\": 2, \"name\": \"Jane Smith\", \"email\": \"jane@example.com\" }\n    ]\n}\n</code></pre> </li> <li> <p>Run <code>json-server</code>:</p> <pre><code>json-server --watch db.json --port 5000\n</code></pre> </li> <li> <p>Access the API:</p> <ul> <li><code>GET http://localhost:5000/users</code> will return the list of users.</li> <li><code>GET http://localhost:5000/users/1</code> will return the user with id <code>1</code>.</li> <li><code>POST</code>, <code>PUT</code>, <code>DELETE</code> operations will work automatically for <code>users</code>.</li> </ul> </li> </ol> <p>Result:</p> <ul> <li>Simple API with RESTful routes for basic CRUD operations.</li> </ul> <p>In this example, we\u2019ll add:</p> <ul> <li>Custom Routes for more control over the API.</li> <li>Pagination and Filtering using query parameters.</li> </ul> Steps: <ol> <li> <p>Create an extended <code>db.json</code> file with multiple resources:</p> <pre><code>{\n    \"users\": [\n        { \"id\": 1, \"name\": \"John Doe\", \"email\": \"john@example.com\" },\n        { \"id\": 2, \"name\": \"Jane Smith\", \"email\": \"jane@example.com\" },\n        { \"id\": 3, \"name\": \"Bill Gates\", \"email\": \"bill@microsoft.com\" },\n        { \"id\": 4, \"name\": \"Elon Musk\", \"email\": \"elon@spacex.com\" }\n    ],\n    \"posts\": [\n        { \"id\": 1, \"title\": \"Post 1\", \"content\": \"Lorem Ipsum\", \"userId\": 1 },\n        { \"id\": 2, \"title\": \"Post 2\", \"content\": \"Dolor Sit\", \"userId\": 2 },\n        { \"id\": 3, \"title\": \"Post 3\", \"content\": \"Amet Consectetur\", \"userId\": 1 }\n    ]\n}\n</code></pre> </li> <li> <p>Add a <code>routes.json</code> file to define custom routes:</p> <pre><code>{\n    \"/api/users\": \"/users\",\n    \"/api/posts\": \"/posts\"\n}\n</code></pre> </li> <li> <p>Run <code>json-server</code> with the custom routes:</p> <pre><code>json-server --watch db.json --routes routes.json --port 5000\n</code></pre> </li> <li> <p>API Features:</p> <ul> <li>Pagination: <code>GET http://localhost:5000/users?_page=1&amp;_limit=2</code> will return 2 users per page.</li> <li>Filtering: <code>GET http://localhost:5000/posts?userId=1</code> will return all posts for user with <code>userId=1</code>.</li> <li>Custom Routes: Access users via <code>GET http://localhost:5000/api/users</code>.</li> </ul> </li> </ol> <p>Result:</p> <ul> <li>More control over API routes.</li> <li>Added pagination and filtering for more realistic data operations.</li> </ul> <p>In this example, we\u2019ll demonstrate:</p> <ul> <li>Custom Middlewares for request logging.</li> <li>Delayed Responses to simulate network delays.</li> <li>Advanced Relationships between resources (users and posts).</li> </ul> Steps: <ol> <li> <p>Create a <code>db.json</code> file with more complex relationships:</p> <pre><code>{\n    \"users\": [\n        { \"id\": 1, \"name\": \"John Doe\", \"email\": \"john@example.com\" },\n        { \"id\": 2, \"name\": \"Jane Smith\", \"email\": \"jane@example.com\" }\n    ],\n    \"posts\": [\n        { \"id\": 1, \"title\": \"Post 1\", \"userId\": 1 },\n        { \"id\": 2, \"title\": \"Post 2\", \"userId\": 1 },\n        { \"id\": 3, \"title\": \"Post 3\", \"userId\": 2 }\n    ],\n    \"comments\": [\n        { \"id\": 1, \"body\": \"Nice post!\", \"postId\": 1 },\n        { \"id\": 2, \"body\": \"Thanks for sharing!\", \"postId\": 1 },\n        { \"id\": 3, \"body\": \"Great article\", \"postId\": 2 }\n    ]\n}\n</code></pre> </li> <li> <p>Create a <code>server.js</code> file to customize the server:</p> <pre><code>const jsonServer = require('json-server');\nconst server = jsonServer.create();\nconst router = jsonServer.router('db.json');\nconst middlewares = jsonServer.defaults();\nconst port = 5000;\n\n// Custom middleware to log requests\nserver.use(middlewares);\nserver.use((req, res, next) =&gt; {\n    console.log(`[LOG] Request: ${req.method} ${req.url}`);\n    next();\n});\n\n// Custom route for delayed response\nserver.get('/api/delayed-response', (req, res) =&gt; {\n    setTimeout(() =&gt; {\n        res.status(200).jsonp({ message: \"This response is delayed!\" });\n    }, 3000); // 3-second delay\n});\n\n// Use default router with pagination, filters, etc.\nserver.use(router);\n\n// Start server\nserver.listen(port, () =&gt; {\n    console.log(`JSON Server is running on http://localhost:${port}`);\n});\n</code></pre> </li> <li> <p>Run the custom server:</p> <pre><code>node server.js\n</code></pre> </li> <li> <p>API Features:</p> <ul> <li>Logging Middleware: Logs all incoming requests with their method and URL.</li> <li>Delayed Response: <code>GET http://localhost:5000/api/delayed-response</code> simulates a 3-second delay before responding.</li> <li>Relationships: <code>GET http://localhost:5000/posts?userId=1</code> will fetch posts for a specific user, and you can fetch comments for a post with <code>GET http://localhost:5000/comments?postId=1</code>.</li> </ul> </li> </ol> <p>Result:</p> <ul> <li>Advanced API with custom middlewares, delayed responses, and relationships between entities.</li> <li>You can simulate real-world scenarios with complex data structures.</li> </ul> <p>Summary:</p> <ul> <li>Basic Example: Simple CRUD operations using <code>json-server</code>.</li> <li>Intermediate Example: Added custom routes, pagination, and filtering.</li> <li>Advanced Example: Custom middlewares, delayed responses, and more complex relationships between entities.</li> </ul> <p>These progressively advanced examples help you mock an API for frontend development, simulate realistic scenarios, and add more flexibility to your workflow.</p>"},{"location":"frontend/react/core/fake-api/json-server/#my-json-server","title":"My JSON Server","text":"How to <ol> <li>Create a repository on GitHub (<code>&lt;your-username&gt;/&lt;your-repo&gt;</code>)</li> <li>Create a <code>db.json</code> file</li> <li>Visit https://my-json-server.typicode.com// to access your server</li> </ol> <p>No registration. Nothing to install.</p> <ul> <li>my-json-server: github</li> </ul>"},{"location":"frontend/react/core/fake-api/json-server/#reference","title":"Reference","text":"<ul> <li>json server: github</li> <li>my-json-server.typicode.com</li> </ul>"},{"location":"frontend/react/core/fake-api/msw/","title":"Mock Services with Browser APIs","text":"<p>To fake an API for consumption in your frontend (React, Vue, Angular), you can use different tools and techniques, such as setting up a mock server or using third-party libraries. Here are a few common approaches:</p> 1. Use Mock Services in JavaScript: <p>You can define mock data directly in your frontend project for development and testing.</p> <pre><code>// Sample mock data\nconst mockData = [\n{ id: 1, name: \"John Doe\", age: 30 },\n{ id: 2, name: \"Jane Smith\", age: 25 },\n];\n\n// Mock API call\nexport const fetchMockData = () =&gt; {\nreturn new Promise((resolve) =&gt; {\n    setTimeout(() =&gt; {\n    resolve(mockData);\n    }, 1000); // Simulating network delay\n});\n};\n\n// In your React component\nuseEffect(() =&gt; {\nfetchMockData().then((data) =&gt; {\n    console.log(data); // Handle the data\n});\n}, []);\n</code></pre> 3. Use Axios Interceptors (or Fetch Mocking): <p>You can intercept network requests in your frontend using Axios or Fetch to return fake responses.</p> Axios Example:<pre><code>import axios from 'axios';\n\n// Create a mock Axios instance\nconst mockAxios = axios.create();\n\n// Intercept requests and return mock data\nmockAxios.interceptors.request.use((config) =&gt; {\n    if (config.url === '/api/users') {\n        return Promise.resolve({\n            data: [{ id: 1, name: 'John Doe' }, { id: 2, name: 'Jane Smith' }],\n        });\n    }\n    return config;\n});\n\n// In your component\nuseEffect(() =&gt; {\n    mockAxios.get('/api/users').then((response) =&gt; {\n        console.log(response.data); // Fake data\n    });\n}, []);\n</code></pre>"},{"location":"frontend/react/core/fake-api/msw/#4-mock-services-with-browser-apis-eg-fetch-mock-msw","title":"4. Mock Services with Browser APIs (e.g., <code>fetch-mock</code>, <code>msw</code>):","text":"<ul> <li><code>fetch-mock</code>: Mock fetch requests.</li> <li>MSW (Mock Service Worker): An API mocking library that works by intercepting requests via Service Workers.</li> </ul> MSW Example: <ol> <li> <p>Install <code>msw</code>:</p> <pre><code>npm install msw --save-dev\n</code></pre> </li> <li> <p>Setup <code>msw</code>:</p> <pre><code>import { setupWorker, rest } from \"msw\";\n\n// Define request handlers\nconst worker = setupWorker(\n    rest.get(\"/api/users\", (req, res, ctx) =&gt; {\n        return res(\n            ctx.json([\n                { id: 1, name: \"John Doe\" },\n                { id: 2, name: \"Jane Smith\" },\n            ])\n        );\n    })\n);\n\n// Start the worker\nworker.start();\n</code></pre> <p>These methods let you easily fake APIs to speed up frontend development without depending on a backend. You can choose the best approach depending on your stack and workflow!</p> </li> </ol>"},{"location":"frontend/react/core/pattern/antipattern/","title":"Anti Pattern","text":"<ol> <li> <p>Using <code>indexes</code> as a key</p> <p>Bug</p> <pre><code>return (\n&lt;div&gt;\n    &lt;ul&gt;\n    {items.map((item, index) =&gt; (\n        &lt;li key={index}&gt;\n            {item}\n            &lt;input type=\"text\" /&gt;\n        &lt;/li&gt;\n    ))}\n    &lt;/ul&gt;\n\n    &lt;button onClick={handleClick}&gt;+&lt;/button&gt;\n&lt;/div&gt;\n)\n</code></pre> <p>To solve this problem, we can, for example, use the value of the item if we expect it not to be repeated within the list, or create a unique identifier, for example:</p> <p>Success</p> <pre><code>{items.map((item, index) =&gt; (\n    &lt;li key={`${item}-${index}`}&gt;\n        {item}\n        &lt;input type=\"text\" /&gt;\n    &lt;/li&gt;\n))}\n</code></pre> </li> <li> <p>Spreading properties on DOM elements</p> </li> </ol>"},{"location":"frontend/react/core/pattern/compound-pattern/","title":"Compound Pattern","text":"<p>Let's create a compound component for a <code>Modal</code> that can be used to display various types of content. The compound components will include <code>Modal</code>, <code>ModalHeader</code>, <code>ModalBody</code>, and <code>ModalFooter</code>.</p> Modal.jsModalHeader.jsModalBody.jsModalFooter.js <pre><code>import React, { useState } from 'react';\n\nconst Modal = ({ children, isOpen, onClose }) =&gt; {\n    return isOpen ? (\n        &lt;div className=\"modal-overlay\" onClick={onClose}&gt;\n            &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n                {children}\n            &lt;/div&gt;\n        &lt;/div&gt;\n    ) : null;\n};\n\nexport default Modal;\n</code></pre> <pre><code>import React from 'react';\n\nconst ModalHeader = ({ children }) =&gt; {\n    return &lt;div className=\"modal-header\"&gt;{children}&lt;/div&gt;;\n};\n\nexport default ModalHeader;\n</code></pre> <pre><code>import React from 'react';\n\nconst ModalBody = ({ children }) =&gt; {\n    return &lt;div className=\"modal-body\"&gt;{children}&lt;/div&gt;;\n};\n\nexport default ModalBody;\n</code></pre> <pre><code>import React from 'react';\n\nconst ModalFooter = ({ children }) =&gt; {\n    return &lt;div className=\"modal-footer\"&gt;{children}&lt;/div&gt;;\n};\n\nexport default ModalFooter;\n</code></pre> <p>Now, let's use these components in an example application:</p> App.js<pre><code>// App.js\nimport React, { useState } from \"react\";\nimport Modal from \"./Modal\";\nimport ModalHeader from \"./ModalHeader\";\nimport ModalBody from \"./ModalBody\";\nimport ModalFooter from \"./ModalFooter\";\n\nconst App = () =&gt; {\n  const [isModalOpen, setIsModalOpen] = useState(false);\n\n  const openModal = () =&gt; {\n    setIsModalOpen(true);\n  };\n\n  const closeModal = () =&gt; {\n    setIsModalOpen(false);\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Compound Pattern in React - Modal Example&lt;/h1&gt;\n      &lt;button onClick={openModal}&gt;Open Modal&lt;/button&gt;\n\n      &lt;Modal isOpen={isModalOpen} onClose={closeModal}&gt;\n        &lt;ModalHeader&gt;\n          &lt;h2&gt;Modal Title&lt;/h2&gt;\n        &lt;/ModalHeader&gt;\n        &lt;ModalBody&gt;\n          &lt;p&gt;This is the content of the modal.&lt;/p&gt;\n        &lt;/ModalBody&gt;\n        &lt;ModalFooter&gt;\n          &lt;button onClick={closeModal}&gt;Close&lt;/button&gt;\n        &lt;/ModalFooter&gt;\n      &lt;/Modal&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n</code></pre> <p>In this example, the <code>Modal</code> component serves as the container for the modal content. The <code>ModalHeader</code>, <code>ModalBody</code>, and <code>ModalFooter</code> components are used within the <code>Modal</code> component to structure and style the different parts of the modal.</p> <p>This compound pattern allows you to create a reusable and flexible modal component by composing smaller components together. Each smaller component focuses on a specific part of the modal, making the code more modular and maintainable.</p>"},{"location":"frontend/react/core/pattern/container-presentational-patterns/","title":"container presentational patterns","text":"<p>React components typically contain a mix of logic and presentation. By logic, we refer to anything that is unrelated to the UI, such as API calls, data manipulation, and event handlers. The presentation is the part of the render where we create the elements to be displayed on the UI.</p> <p>In React, there are simple and powerful patterns, known as container and presentational, which we can apply when creating components that help us to separate those two concerns.</p>"},{"location":"frontend/react/core/pattern/function-as-child/","title":"FaC Pattern","text":""},{"location":"frontend/react/core/pattern/function-as-child/#function-as-child-fac-pattern","title":"Function as Child (FaC) pattern","text":"<p>In React, the \"<code>Function as Child</code>\" (FaC) pattern involves passing a function as a child of a component. This pattern is also known as \"Render Props.\" The basic idea is to pass a function as a child to a component, allowing the component to render content or behavior based on the result of that function.</p> <p>Here's a simple example to illustrate the Function as Child pattern:</p> ParentComponent.js<pre><code>import React from \"react\";\n\nconst ParentComponent = ({ children }) =&gt; {\n  // Execute the function (child) and pass data to it\n  return &lt;div&gt;{children(\"Data from Parent\")}&lt;/div&gt;;\n};\n\nexport default ParentComponent;\n</code></pre> <p>Now, you can use <code>ParentComponent</code> in another component and pass a function as its child:</p> App.js<pre><code>import React from \"react\";\nimport ParentComponent from \"./ParentComponent\";\n\nconst App = () =&gt; {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Function as Child Pattern&lt;/h1&gt;\n\n      {/* Using ParentComponent and passing a function as its child */}\n      &lt;ParentComponent&gt;\n        {(dataFromParent) =&gt; (\n          &lt;p&gt;{`Received data in child component: ${dataFromParent}`}&lt;/p&gt;\n        )}\n      &lt;/ParentComponent&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n</code></pre> <p>In this example, the <code>ParentComponent</code> takes a <code>children</code> prop, which is a function. Inside <code>ParentComponent</code>, it calls the <code>children</code> function and passes some data (\"<code>Data from Parent</code>\" in this case). The child component (the function passed as a child) then receives this data and can use it to render content.</p> <p>The main benefit of the Function as Child pattern is that it allows you to inject dynamic behavior or data into a component from its parent without the need for complex props or state management. It provides a way to share functionality between components in a more flexible and composable manner.</p> <p>This pattern is commonly used in React, especially in cases where you want to abstract away some logic or behavior into a component but allow customization in its usage by passing functions as children.</p> <p>Real Example</p> <p>Lets create <code>Toggle</code> component that can be used to toggle the visibility of content.</p> Toggle.js<pre><code>import React, { useState } from \"react\";\n\nconst Toggle = ({ children }) =&gt; {\n  const [isVisible, setIsVisible] = useState(false);\n\n  const toggleVisibility = () =&gt; {\n    setIsVisible(!isVisible);\n  };\n\n  // Render the child function and pass the toggleVisibility function and the current visibility state\n  return children({ isVisible, toggleVisibility });\n};\n\nexport default Toggle;\n</code></pre> <p>Now, let's use the <code>Toggle</code> component in another component:</p> App.js<pre><code>import React from \"react\";\nimport Toggle from \"./Toggle\";\n\nconst App = () =&gt; {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Function as Child Pattern - Toggle Example&lt;/h1&gt;\n\n      {/* Using Toggle and passing a function as its child */}\n      &lt;Toggle&gt;\n        {({ isVisible, toggleVisibility }) =&gt; (\n          &lt;div&gt;\n            &lt;button onClick={toggleVisibility}&gt;Toggle Visibility&lt;/button&gt;\n\n            {isVisible &amp;&amp; &lt;p&gt;This content is now visible!&lt;/p&gt;}\n          &lt;/div&gt;\n        )}\n      &lt;/Toggle&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n</code></pre> <p>In this example, the <code>Toggle</code> component encapsulates the state and logic for toggling visibility. It takes a function as a child, and that function receives an object with two properties: <code>isVisible</code> (a boolean indicating whether the content is visible) and <code>toggleVisibility</code> (a function to toggle the visibility).</p> <p>The <code>App</code> component uses the <code>Toggle</code> component, passing a function as its child. Inside the function, it receives the <code>isVisible</code> state and the <code>toggleVisibility</code> function, and it uses these to conditionally render content.</p> <p>This pattern is powerful because it allows you to encapsulate state and behavior within a component while giving the consumer of that component full control over the rendering and customization of the UI based on the component's state.</p>"},{"location":"frontend/react/core/pattern/hoc-pattern/","title":"HoC Pattern","text":"<p>Higher-Order Components (HOCs) are a design pattern in React that allows the reuse of component logic.</p> <p>A Higher-Order Component is a function that takes a component and returns a new component with additional props or behavior. HOCs are commonly used for cross-cutting concerns such as authentication, logging, and data fetching.</p> <p>Here's an example of a Higher-Order Component using a functional component:</p> withLogging.js (HOC file):MyComponent.jsApp.js jsx<pre><code>import React, { useEffect } from 'react';\n\nconst withLogging = (WrappedComponent) =&gt; {\n    const WithLogging = (props) =&gt; {\n        useEffect(() =&gt; {\n            console.log(`Component ${WrappedComponent.name || 'Anonymous'} is mounted`);\n            return () =&gt; {\n                console.log(`Component ${WrappedComponent.name || 'Anonymous'} is unmounted`);\n            };\n        }, []);\n\n        return &lt;WrappedComponent {...props} /&gt;;\n    };\n\n    return WithLogging;\n};\n\nexport default withLogging;\n</code></pre> jsx<pre><code>import React from 'react';\n\nconst MyComponent = () =&gt; {\n    return &lt;div&gt;Hello, I'm a functional component!&lt;/div&gt;;\n};\n\nexport default MyComponent;\n</code></pre> jsx<pre><code>import React from 'react';\nimport withLogging from './withLogging';\nimport MyComponent from './MyComponent';\n\nconst MyComponentWithLogging = withLogging(MyComponent);\n\nconst App = () =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;MyComponentWithLogging /&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default App;\n</code></pre> <p>In this structure:</p> <ul> <li><code>withLogging.js</code> contains the HOC (withLogging).</li> <li><code>MyComponent.js</code> contains the functional component (MyComponent).</li> <li><code>App.js</code> uses the HOC by importing it and applying it to MyComponent.</li> </ul> <p>This modular approach allows you to organize your code better and promotes reusability. You can easily apply the withLogging HOC to other components in different files without duplicating the logic.</p>"},{"location":"frontend/react/core/pattern/hoc-pattern/#when-naming-higher-order-component-hoc-files-in-a-react-application","title":"When naming Higher-Order Component (HOC) files in a React application","text":"<ul> <li> <p>Prefix with \"with\":</p> <p>It's a common convention to prefix the HOC file name with \"with\" to indicate that it is a Higher-Order Component.</p> <pre><code>withExampleHOC.js\nwithAuthentication.js\nwithTheme.js\n</code></pre> </li> <li> <p>Suffix with \"HOC\":</p> <p>Optionally, you can suffix the file name with \"HOC\" to make it explicit that it is a Higher-Order Component.</p> <pre><code>ExampleComponentHOC.js\nAuthenticationHOC.js\n</code></pre> </li> </ul>"},{"location":"frontend/react/core/pattern/hoc-pattern/#real-example","title":"Real Example","text":"<p>You can organize your code in a way that makes sense for your project structure. Here's an example of how you might structure the file:</p> withConditionalFormItem.js<pre><code>import React from \"react\";\nimport { Form } from \"antd\";\n\nconst withConditionalFormItem = (WrappedComponent, condition) =&gt; {\n  return (props) =&gt; {\n    if (condition) {\n      return &lt;WrappedComponent {...props} /&gt;;\n    } else {\n      return null; // or you can render an alternative component/message\n    }\n  };\n};\n\nexport default withConditionalFormItem;\n</code></pre> <p>Then, in your main component file:</p> YourFormComponent.js<pre><code>//\nimport React from \"react\";\nimport { Form, Input } from \"antd\";\nimport withConditionalFormItem from \"./withConditionalFormItem\";\n\n// Usage\nconst ConditionalRemarksFormItem = withConditionalFormItem(\n  Form.Item,\n  !isCircular // Condition based on your boolean value\n);\n\nconst YourFormComponent = () =&gt; {\n  return (\n    &lt;Form&gt;\n      {/* Other Form items */}\n      &lt;ConditionalRemarksFormItem label=\"Remarks\" name=\"remarks\"&gt;\n        &lt;Input.TextArea rows={4} placeholder=\"Remarks\" /&gt;\n      &lt;/ConditionalRemarksFormItem&gt;\n      {/* Other Form items */}\n    &lt;/Form&gt;\n  );\n};\n\nexport default YourFormComponent;\n</code></pre> <p>This way, you have a separate file for the higher-order component, making it easy to reuse across different components in your project.</p>"},{"location":"frontend/react/core/pattern/misc/","title":"Misc","text":""},{"location":"frontend/react/core/pattern/misc/#conditional-rendering-pattern","title":"<code>Conditional Rendering</code> pattern","text":"<pre><code>import React from \"react\";\n\nconst YourComponent = ({ singleCircularReferenceTemplateResponse }) =&gt; {\n  // Check if the response is still loading\n  const isLoading = !singleCircularReferenceTemplateResponse;\n\n  // Check if the response has content\n  const hasContent = !!singleCircularReferenceTemplateResponse?.content;\n\n  return (\n    &lt;div&gt;\n      {isLoading &amp;&amp; &lt;p&gt;Loading...&lt;/p&gt;}\n      {!isLoading &amp;&amp; !hasContent &amp;&amp; &lt;p&gt;No Content available.&lt;/p&gt;}\n      {!isLoading &amp;&amp; hasContent &amp;&amp; (\n        &lt;div\n          dangerouslySetInnerHTML={{\n            __html: singleCircularReferenceTemplateResponse.content,\n          }}\n        &gt;&lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default YourComponent;\n</code></pre>"},{"location":"frontend/react/core/pattern/react-pattern-intro/","title":"Introduction","text":""},{"location":"frontend/react/core/pattern/react-pattern-intro/#react-design-patterns","title":"React Design Patterns","text":"<ul> <li><code>Compound</code> Pattern</li> <li><code>HOC</code> Pattern</li> <li><code>Hooks</code> Pattern</li> <li><code>Container/Presentational</code> Pattern</li> <li><code>Render Props</code> Pattern</li> </ul>"},{"location":"frontend/react/core/pattern/react-pattern-intro/#reference","title":"Reference","text":"<ul> <li>reactpatterns.js.org</li> <li>patterns.dev</li> <li> <p>reactpatterns.com</p> </li> <li> <p>React Design Patterns</p> </li> </ul>"},{"location":"frontend/react/core/router/intro/","title":"Introduction","text":""},{"location":"frontend/react/core/router/intro/#react-router","title":"React Router","text":"<ul> <li>React Router v6 Update: Updated PrivateRoute to use Navigate instead of Redirect.</li> <li>Component Validation: Ensured PrivateRoute validates its props with PropTypes.</li> <li>Router Configuration: Updated App component to use Routes and Route components from react-router-dom v6.</li> </ul> <p>By making these changes, your code will be compatible with react-router-dom version 6, and you should no longer encounter the issue with the Redirect component.</p> <p>React Router is a popular library used for routing in React applications. It allows you to handle navigation and rendering of different components based on the URL, enabling single-page application (SPA) behavior.</p>"},{"location":"frontend/react/core/router/intro/#versions-of-react-router","title":"Versions of React Router","text":"<p>React Router has undergone several major versions, each introducing significant changes and improvements:</p> <ol> <li>React Router v1 and v2: Early versions focused on basic routing capabilities.</li> <li>React Router v3: Provided a more stable API but started showing limitations in terms of flexibility and ease of use.</li> <li>React Router v4: Introduced a major overhaul with a declarative approach to routing, enabling more powerful and flexible routing capabilities.</li> <li>React Router v5: Built on v4's foundation, providing incremental improvements and more features while maintaining backward compatibility.</li> <li>React Router v6: Another major update with significant changes to the API, simplifying and modernizing routing in React applications.</li> </ol>"},{"location":"frontend/react/core/router/intro/#major-updates-and-changes","title":"Major Updates and Changes","text":""},{"location":"frontend/react/core/router/intro/#react-router-v4","title":"React Router v4","text":"<ul> <li>Declarative Routing: Introduced a new approach where routes are declared as components, making the routing logic more intuitive and easier to manage.</li> <li>Dynamic Routing: Allowed routes to be dynamic, enabling more flexibility.</li> <li>Nested Routes: Improved support for nested routes, making it easier to build complex routing structures.</li> <li>Removal of Route Configuration: Moved away from centralized route configuration to a component-based approach.</li> </ul>"},{"location":"frontend/react/core/router/intro/#react-router-v5","title":"React Router v5","text":"<ul> <li>Incremental Improvements: Built on v4, adding minor enhancements and optimizations while maintaining the same declarative approach.</li> <li>Hooks Support: Introduced hooks like <code>useHistory</code>, <code>useLocation</code>, <code>useParams</code>, and <code>useRouteMatch</code> for more flexible and powerful routing.</li> <li>Suspense Integration: Improved integration with React's Suspense for data fetching and code splitting.</li> </ul>"},{"location":"frontend/react/core/router/intro/#react-router-v6","title":"React Router v6","text":"<ul> <li>Simplified API: Major overhaul with a more straightforward and simplified API.</li> <li>Routes and Route Elements: Introduced the Routes and Route elements, replacing Switch and Route from previous versions.</li> <li>Nested Routes: Enhanced nested routing with a more intuitive approach.</li> <li>Data Loading: Integrated better support for data loading and fetching, aligning with modern React patterns.</li> <li>Improved TypeScript Support: Enhanced TypeScript support for better type checking and developer experience.</li> <li>URL-based State: Improved handling of state through URLs, making it easier to manage state with routing.</li> <li>Route Definitions: Allowed defining routes as objects or elements, providing more flexibility.</li> </ul>"},{"location":"frontend/react/core/router/intro/#example-comparison","title":"Example Comparison","text":"React Router v5 <pre><code>import { BrowserRouter as Router, Switch, Route, Redirect } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Switch&gt;\n            &lt;Route path=\"/login\" component={Login} /&gt;\n            &lt;PrivateRoute path=\"/dashboard\" component={Dashboard} /&gt;\n            &lt;Redirect from=\"/\" to=\"/dashboard\" /&gt;\n        &lt;/Switch&gt;\n    &lt;/Router&gt;\n);\n</code></pre> React Router v6 <pre><code>import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Routes&gt;\n            &lt;Route path=\"/login\" element={&lt;Login /&gt;} /&gt;\n            &lt;Route path=\"/dashboard\" element={&lt;PrivateRoute component={Dashboard} /&gt;} /&gt;\n            &lt;Route path=\"*\" element={&lt;Navigate to=\"/dashboard\" /&gt;} /&gt;\n        &lt;/Routes&gt;\n    &lt;/Router&gt;\n);\n</code></pre>"},{"location":"frontend/react/core/router/intro/#summary-of-major-changes-in-v6","title":"Summary of Major Changes in v6","text":"<ol> <li><code>Switch</code> replaced by <code>Routes</code>: <code>Switch</code> component is replaced by <code>Routes</code>.</li> <li><code>component</code> and <code>render</code> replaced by <code>element</code>: The <code>component</code> and <code>render</code> props are replaced by <code>element</code>.</li> <li><code>Redirect</code> replaced by <code>Navigate</code>: <code>Redirect</code> component is replaced by <code>Navigate</code>.</li> <li>Route Definitions: Routes can now be defined using nested <code>Route</code> elements.</li> <li>Hooks and Context API: Improved hooks and context for routing logic.</li> <li>Improved TypeScript Support: Better TypeScript support for static type checking.</li> </ol> <p>By understanding these changes, you can effectively use React Router in your projects and take advantage of the latest features and improvements.</p>"},{"location":"frontend/react/example/breaking-react-component-pattern/","title":"How to break react components","text":"<pre><code>Component Decomposition\nContainer and Presentational Components\nHigher-Order Components (HOCs)\nRender Props\nCustom Hooks\nContext API\nComposition Over Inheritance\n</code></pre> <p>Breaking components into smaller, manageable pieces is essential for maintaining a clean and scalable React application. Here are some of the most useful React patterns for breaking components effectively:</p>"},{"location":"frontend/react/example/breaking-react-component-pattern/#1-component-decomposition","title":"1. Component Decomposition","text":"<p>Break down large components into smaller, reusable ones based on their functionality or UI elements. This makes each component simpler and easier to maintain.</p> Example jsx<pre><code>// Large Component\nconst UserProfile = () =&gt; (\n    &lt;div&gt;\n        &lt;Avatar /&gt;\n        &lt;UserInfo /&gt;\n        &lt;UserPosts /&gt;\n    &lt;/div&gt;\n);\n\n// Smaller Components\nconst Avatar = () =&gt; &lt;img src=\"avatar.jpg\" alt=\"User Avatar\" /&gt;;\n    const UserInfo = () =&gt; (\n    &lt;div&gt;\n        &lt;h2&gt;John Doe&lt;/h2&gt;\n        &lt;p&gt;john.doe@example.com&lt;/p&gt;\n    &lt;/div&gt;\n    );\n    const UserPosts = () =&gt; (\n    &lt;ul&gt;\n        &lt;li&gt;First Post&lt;/li&gt;\n        &lt;li&gt;Second Post&lt;/li&gt;\n    &lt;/ul&gt;\n);\n</code></pre>"},{"location":"frontend/react/example/breaking-react-component-pattern/#2-container-and-presentational-components","title":"2. Container and Presentational Components","text":"<p>Separate components into container (stateful) and presentational (stateless) components. Containers handle logic and state, while presentational components handle rendering.</p> Example jsx<pre><code>// Container Component\nconst UserProfileContainer = () =&gt; {\n    const [user, setUser] = useState({ name: 'John Doe', email: 'john.doe@example.com' });\n    return &lt;UserProfile user={user} /&gt;;\n};\n\n// Presentational Component\nconst UserProfile = ({ user }) =&gt; (\n    &lt;div&gt;\n        &lt;h2&gt;{user.name}&lt;/h2&gt;\n        &lt;p&gt;{user.email}&lt;/p&gt;\n    &lt;/div&gt;\n);\n</code></pre>"},{"location":"frontend/react/example/breaking-react-component-pattern/#3-higher-order-components-hocs","title":"3. Higher-Order Components (HOCs)","text":"<p>Use HOCs to enhance components with additional functionality, such as adding authentication or fetching data.</p> Example jsx<pre><code>// Higher-Order Component\nconst withUserData = (WrappedComponent) =&gt; {\n    return (props) =&gt; {\n        const [user, setUser] = useState(null);\n\n        useEffect(() =&gt; {\n        // Fetch user data\n        setUser({ name: 'John Doe', email: 'john.doe@example.com' });\n        }, []);\n\n        return &lt;WrappedComponent user={user} {...props} /&gt;;\n    };\n};\n\n// Wrapped Component\nconst UserProfile = ({ user }) =&gt; (\n    &lt;div&gt;\n        &lt;h2&gt;{user ? user.name : 'Loading...'}&lt;/h2&gt;\n        &lt;p&gt;{user ? user.email : ''}&lt;/p&gt;\n    &lt;/div&gt;\n);\n\nconst EnhancedUserProfile = withUserData(UserProfile);\n</code></pre>"},{"location":"frontend/react/example/breaking-react-component-pattern/#4-render-props","title":"4. Render Props","text":"<p>Use render props to share code between components by passing a function as a prop that returns React elements.</p> Example jsx<pre><code>// Component with Render Props\nconst DataProvider = ({ render }) =&gt; {\n    const [data, setData] = useState('Hello World');\n\n    return render(data);\n};\n\n// Usage\nconst App = () =&gt; (\n    &lt;DataProvider render={(data) =&gt; &lt;div&gt;{data}&lt;/div&gt;} /&gt;\n);\n</code></pre>"},{"location":"frontend/react/example/breaking-react-component-pattern/#5-custom-hooks","title":"5. Custom Hooks","text":"<p>Create custom hooks to encapsulate reusable logic and state management, which can then be used across multiple components.</p> Example jsx<pre><code>// Custom Hook\nconst useCounter = () =&gt; {\n    const [count, setCount] = useState(0);\n\n    const increment = () =&gt; setCount(count + 1);\n    const decrement = () =&gt; setCount(count - 1);\n\n    return { count, increment, decrement };\n};\n\n// Component using Custom Hook\nconst Counter = () =&gt; {\n    const { count, increment, decrement } = useCounter();\n\n    return (\n        &lt;div&gt;\n        &lt;p&gt;Count: {count}&lt;/p&gt;\n        &lt;button onClick={increment}&gt;Increment&lt;/button&gt;\n        &lt;button onClick={decrement}&gt;Decrement&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n</code></pre>"},{"location":"frontend/react/example/breaking-react-component-pattern/#6-context-api","title":"6. Context API","text":"<p>Use the Context API to manage global state and avoid prop drilling by providing data to all components within a provider.</p> Example jsx<pre><code>// Context\nconst ThemeContext = createContext();\n\n// Provider Component\nconst ThemeProvider = ({ children }) =&gt; {\n    const [theme, setTheme] = useState('light');\n\n    return (\n        &lt;ThemeContext.Provider value={{ theme, setTheme }}&gt;\n        {children}\n        &lt;/ThemeContext.Provider&gt;\n    );\n};\n\n// Consuming Context\nconst ThemedComponent = () =&gt; {\n    const { theme } = useContext(ThemeContext);\n\n    return &lt;div className={theme}&gt;Current Theme: {theme}&lt;/div&gt;;\n};\n</code></pre>"},{"location":"frontend/react/example/breaking-react-component-pattern/#7-composition-over-inheritance","title":"7. Composition Over Inheritance","text":"<p>Leverage composition to build components with flexible and reusable parts, rather than relying on inheritance or deeply nested components.</p> Example jsx<pre><code>// Composition\nconst Panel = ({ header, children }) =&gt; (\n    &lt;div className=\"panel\"&gt;\n        &lt;div className=\"panel-header\"&gt;{header}&lt;/div&gt;\n        &lt;div className=\"panel-body\"&gt;{children}&lt;/div&gt;\n    &lt;/div&gt;\n);\n\n// Usage\nconst App = () =&gt; (\n    &lt;Panel header=\"Panel Header\"&gt;\n        &lt;p&gt;Panel Body Content&lt;/p&gt;\n    &lt;/Panel&gt;\n);\n</code></pre>"},{"location":"frontend/react/example/breaking-react-component-pattern/#summary","title":"Summary","text":"<p>By using these patterns, you can create more maintainable, reusable, and modular React components. Each pattern has its own use cases and benefits, and often, a combination of these patterns will be used to achieve the desired structure and behavior in a React application.</p>"},{"location":"frontend/react/example/children-prop/","title":"Children Prop","text":"<p>In React, children is a special prop that allows you to pass components or elements to a component as its children. This enables the creation of more flexible and reusable components by allowing them to render nested content. What is children?</p> <p>The children prop is a special prop in React that represents the content between the opening and closing tags of a component. This content can be other React components, elements, or plain text.</p>"},{"location":"frontend/react/example/children-prop/#how-children-relates-to-react","title":"How <code>children</code> Relates to React","text":"<p>The <code>children</code> prop is a core feature of React's composition model. It enables components to:</p> <ul> <li>Encapsulate and Render Nested Content: Components can render nested elements or components within their own output.</li> <li>Create Reusable Layouts: Layout components like modals, dialogs, or containers can use children to render dynamic content.</li> </ul>"},{"location":"frontend/react/example/children-prop/#how-to-use-children","title":"How to Use children","text":"<ol> <li> <p>Basic Usage:</p> <p>You can use <code>children</code> to render any content that is passed between the opening and closing tags of a component.</p> Example<pre><code>const Wrapper = ({ children }) =&gt; (\n    &lt;div className=\"wrapper\"&gt;\n        {children}\n    &lt;/div&gt;\n);\n\nconst App = () =&gt; (\n    &lt;Wrapper&gt;\n        &lt;h1&gt;Hello, World!&lt;/h1&gt;\n        &lt;p&gt;This is some content inside the Wrapper component.&lt;/p&gt;\n    &lt;/Wrapper&gt;\n);\n\nexport default App;\n</code></pre> <p>In this example, the Wrapper component uses the children prop to render whatever is passed inside its tags.</p> </li> <li> <p>Rendering Multiple Children:</p> <p>children can be a single element, a list of elements, or even a mix of both.</p> jsx<pre><code>const List = ({ children }) =&gt; (\n    &lt;ul&gt;\n        {React.Children.map(children, (child) =&gt; (\n        &lt;li&gt;{child}&lt;/li&gt;\n        ))}\n    &lt;/ul&gt;\n);\n\nconst App = () =&gt; (\n    &lt;List&gt;\n        &lt;span&gt;Item 1&lt;/span&gt;\n        &lt;span&gt;Item 2&lt;/span&gt;\n        &lt;span&gt;Item 3&lt;/span&gt;\n    &lt;/List&gt;\n);\n\nexport default App;\n</code></pre> <p>In this example, the <code>List</code> component takes multiple <code>children</code> elements and renders them as list items.</p> </li> <li> <p>Using <code>React.Children</code> Utilities:</p> <p>React provides utility methods for working with <code>children</code>, such as <code>React.Children.map</code>, <code>React.Children.forEach</code>, and <code>React.Children.toArray</code>.</p> jsx<pre><code>const Parent = ({ children }) =&gt; (\n    &lt;div&gt;\n        {React.Children.map(children, (child, index) =&gt; (\n        &lt;div key={index}&gt;{child}&lt;/div&gt;\n        ))}\n    &lt;/div&gt;\n);\n\nconst App = () =&gt; (\n    &lt;Parent&gt;\n        &lt;p&gt;First Child&lt;/p&gt;\n        &lt;p&gt;Second Child&lt;/p&gt;\n    &lt;/Parent&gt;\n);\n\nexport default App;\n</code></pre> <p>In this example, <code>React.Children.map</code> is used to iterate over and render each child within a <code>div</code>.</p> </li> <li> <p>Conditional Rendering of <code>children</code>:</p> <p>You can conditionally render <code>children</code> based on some logic.</p> <pre><code>const ConditionalWrapper = ({ condition, children }) =&gt; (\n    &lt;div&gt;\n        {condition ? children : &lt;p&gt;No content available&lt;/p&gt;}\n    &lt;/div&gt;\n);\n\nconst App = () =&gt; (\n    &lt;ConditionalWrapper condition={true}&gt;\n        &lt;p&gt;This content will be displayed.&lt;/p&gt;\n    &lt;/ConditionalWrapper&gt;\n);\n\nexport default App;\n</code></pre> </li> </ol>"},{"location":"frontend/react/example/children-prop/#summary","title":"Summary","text":"<p>The <code>children</code> prop in React is a powerful feature that allows components to render nested content dynamically. It helps in creating flexible and reusable components by enabling them to accept and render various types of content. By understanding and utilizing <code>children</code>, you can build more modular and maintainable React applications.</p>"},{"location":"frontend/react/example/component-composition/","title":"Component Composition","text":"<p>Component composition is a fundamental concept in React that involves building complex UIs by combining smaller, reusable components. It allows developers to create more manageable, modular, and maintainable code. Instead of creating large monolithic components, you can break them down into smaller, self-contained components that can be composed together to form the final UI.</p> <p>Practice creating small, reusable components and composing them into larger components.</p>"},{"location":"frontend/react/example/component-composition/#react-patterns-for-breaking-down-components","title":"React Patterns for Breaking Down Components","text":"<ul> <li> <p> 1. Presentational and Container Components:</p> <p>how things look &amp; how things work</p> <p> Getting started</p> </li> <li> <p> 2. Higher-Order Components (HOCs)</p> <p>Use HOCs to add common functionality to components. For example, you might have an HOC to handle form submission logic.</p> <p> Getting started</p> </li> <li> <p> 3. Render Props</p> <p>Render props is a pattern for sharing code between React components using a prop whose value is a function.</p> <p> Getting started</p> </li> </ul>"},{"location":"frontend/react/example/component-composition/#key-principles-of-component-composition","title":"Key Principles of Component Composition","text":"<ol> <li>Reusability: Create components that can be reused across different parts of your application.</li> <li>Single Responsibility: Each component should have a single responsibility, making it easier to understand and maintain.</li> <li>Separation of Concerns: Separate the concerns of different parts of your application into different components.</li> <li>Declarative Syntax: Use a declarative syntax to define how components should be composed together.</li> </ol>"},{"location":"frontend/react/example/component-composition/#example","title":"Example","text":"<p>Let's look at an example where we compose a user profile page using smaller components.</p> <ol> <li> <p>Basic Components:</p> jsx<pre><code>// Avatar.js\nconst Avatar = ({ url }) =&gt; &lt;img src={url} alt=\"User Avatar\" /&gt;;\n\n// UserInfo.js\nconst UserInfo = ({ name, email }) =&gt; (\n&lt;div&gt;\n    &lt;h2&gt;{name}&lt;/h2&gt;\n    &lt;p&gt;{email}&lt;/p&gt;\n&lt;/div&gt;\n);\n\n// UserPosts.js\nconst UserPosts = ({ posts }) =&gt; (\n&lt;ul&gt;\n    {posts.map(post =&gt; (\n    &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;\n    ))}\n&lt;/ul&gt;\n);\n</code></pre> </li> <li> <p>Composing the Components:</p> jsx<pre><code>// UserProfile.js\nimport Avatar from './Avatar';\nimport UserInfo from './UserInfo';\nimport UserPosts from './UserPosts';\n\nconst UserProfile = ({ user, posts }) =&gt; (\n&lt;div&gt;\n    &lt;Avatar url={user.avatarUrl} /&gt;\n    &lt;UserInfo name={user.name} email={user.email} /&gt;\n    &lt;UserPosts posts={posts} /&gt;\n&lt;/div&gt;\n);\n\nexport default UserProfile;\n</code></pre> </li> <li> <p>Using the Composed Component:</p> jsx<pre><code>// App.js\nimport UserProfile from './UserProfile';\n\nconst user = {\nname: 'John Doe',\nemail: 'john.doe@example.com',\navatarUrl: 'https://example.com/avatar.jpg',\n};\n\nconst posts = [\n{ id: 1, title: 'First Post' },\n{ id: 2, title: 'Second Post' },\n];\n\nconst App = () =&gt; (\n&lt;div&gt;\n    &lt;UserProfile user={user} posts={posts} /&gt;\n&lt;/div&gt;\n);\n\nexport default App;\n</code></pre> </li> </ol>"},{"location":"frontend/react/example/component-composition/#benefits-of-component-composition","title":"Benefits of Component Composition","text":"<ul> <li>Maintainability: Smaller components are easier to understand and maintain.</li> <li>Reusability: Reusable components can be used in different parts of the application.</li> <li>Testability: Smaller components are easier to test individually.</li> <li>Scalability: Composing components makes it easier to scale the application as it grows.</li> </ul>"},{"location":"frontend/react/example/component-composition/#tips-for-effective-component-composition","title":"Tips for Effective Component Composition","text":"<ul> <li>Identify Common Patterns: Look for patterns in your UI that can be abstracted into reusable components.</li> <li>Use Prop Drilling and Context: Pass data and callbacks down the component tree via props or use React Context for deeper hierarchies.</li> <li>Follow Naming Conventions: Use clear and consistent naming conventions for your components to improve readability.</li> <li>Modularity: Keep components focused and modular, avoiding unnecessary dependencies between them.</li> </ul> <p>By mastering component composition, you can create a flexible and maintainable React application, leveraging the power of reusable components to build complex UIs efficiently.</p>"},{"location":"frontend/react/example/component-composition/#handling-missing-prop-values-in-react-components","title":"Handling Missing Prop Values in React Components","text":"<p>To handle cases where the props might not contain values, you can use default values, conditional rendering, and prop type validation. Here's how you can address these scenarios:</p> 1. Using Default Props <p>You can set default props to provide default values for your component's props. This way, if a prop is not provided, the component will use the default value.</p> jsx<pre><code>// UserInfo.js\nimport PropTypes from 'prop-types';\n\nconst UserInfo = ({ name, email }) =&gt; (\n    &lt;div&gt;\n        &lt;h2&gt;{name}&lt;/h2&gt;\n        &lt;p&gt;{email}&lt;/p&gt;\n    &lt;/div&gt;\n);\n\nUserInfo.defaultProps = {\n    name: 'Unknown User',\n    email: 'No email provided',\n};\n\nUserInfo.propTypes = {\n    name: PropTypes.string,\n    email: PropTypes.string,\n};\n\nexport default UserInfo;\n</code></pre> 2. Conditional Rendering <p>You can also use conditional rendering to handle cases where the props might not contain values.</p> <pre><code>// UserInfo.js\nimport PropTypes from 'prop-types';\n\nconst UserInfo = ({ name, email }) =&gt; (\n    &lt;div&gt;\n        &lt;h2&gt;{name ? name : 'Unknown User'}&lt;/h2&gt;\n        &lt;p&gt;{email ? email : 'No email provided'}&lt;/p&gt;\n    &lt;/div&gt;\n);\n\nUserInfo.propTypes = {\n    name: PropTypes.string,\n    email: PropTypes.string,\n};\n\nexport default UserInfo;\n</code></pre> 3. Combining Default Props and Conditional Rendering <p>Combining both approaches can provide a robust solution for handling missing prop values.</p> <pre><code>// UserInfo.js\nimport PropTypes from 'prop-types';\n\nconst UserInfo = ({ name, email }) =&gt; (\n    &lt;div&gt;\n        &lt;h2&gt;{name}&lt;/h2&gt;\n        &lt;p&gt;{email}&lt;/p&gt;\n    &lt;/div&gt;\n);\n\nUserInfo.defaultProps = {\n    name: 'Unknown User',\n    email: 'No email provided',\n};\n\nUserInfo.propTypes = {\n    name: PropTypes.string,\n    email: PropTypes.string,\n};\n\nexport default UserInfo;\n</code></pre> 4. Using Nullish Coalescing Operator (Optional) <p>For modern JavaScript, you can use the nullish coalescing operator (??) to provide fallback values.</p> <pre><code>// UserInfo.js\nimport PropTypes from 'prop-types';\n\nconst UserInfo = ({ name, email }) =&gt; (\n    &lt;div&gt;\n        &lt;h2&gt;{name ?? 'Unknown User'}&lt;/h2&gt;\n        &lt;p&gt;{email ?? 'No email provided'}&lt;/p&gt;\n    &lt;/div&gt;\n);\n\nUserInfo.propTypes = {\n    name: PropTypes.string,\n    email: PropTypes.string,\n};\n\nexport default UserInfo;\n</code></pre>"},{"location":"frontend/react/example/component-composition/#example-usage-in-userprofile-component","title":"Example Usage in UserProfile Component","text":"<p>Here's how you might use the <code>UserInfo</code> component in the UserProfile component with potential missing values.</p> <pre><code>// UserProfile.js\nimport Avatar from './Avatar';\nimport UserInfo from './UserInfo';\nimport UserPosts from './UserPosts';\n\nconst UserProfile = ({ user, posts }) =&gt; (\n  &lt;div&gt;\n    &lt;Avatar url={user?.avatarUrl ?? 'default-avatar.jpg'} /&gt;\n    &lt;UserInfo name={user?.name} email={user?.email} /&gt;\n    &lt;UserPosts posts={posts} /&gt;\n  &lt;/div&gt;\n);\n\nexport default UserProfile;\n</code></pre>"},{"location":"frontend/react/example/component-composition/#example-usage-in-app-component","title":"Example Usage in App Component","text":"<pre><code>// App.js\nimport UserProfile from './UserProfile';\n\nconst user = {\n  name: 'John Doe',\n  email: 'john.doe@example.com',\n  avatarUrl: 'https://example.com/avatar.jpg',\n};\n\nconst posts = [\n  { id: 1, title: 'First Post' },\n  { id: 2, title: 'Second Post' },\n];\n\nconst App = () =&gt; (\n  &lt;div&gt;\n    &lt;UserProfile user={user} posts={posts} /&gt;\n    {/* UserProfile with missing values */}\n    &lt;UserProfile user={{}} posts={posts} /&gt;\n  &lt;/div&gt;\n);\n\nexport default App;\n</code></pre> <p>By using these techniques, you can ensure that your components handle missing prop values gracefully, improving the robustness and user experience of your application.</p>"},{"location":"frontend/react/example/hoc/","title":"High Order Component","text":"<p>High-order components (HOCs) in React are a pattern where a function takes a component and returns a new component with enhanced functionality. Here are examples categorized into basic, intermediate, and advanced HOCs:</p> <p>Use HOCs to add common functionality to components.</p> simple example <p>Use HOCs to add common functionality to components.</p> <p>For example, you might have an HOC to handle form submission logic.</p> jsx<pre><code>// withFormSubmission.js\nconst withFormSubmission = (WrappedComponent) =&gt; {\nreturn (props) =&gt; {\n    const handleSubmit = (values) =&gt; {\n    // handle form submission logic here\n    console.log('Form submitted:', values);\n    };\n\n    return &lt;WrappedComponent {...props} onSubmit={handleSubmit} /&gt;;\n};\n};\n\nexport default withFormSubmission;\n\n// EnhancedUserForm.js\nimport withFormSubmission from './withFormSubmission';\nimport UserForm from './UserForm';\n\nconst EnhancedUserForm = withFormSubmission(UserForm);\n\nexport default EnhancedUserForm;\n</code></pre> Abstract <p>Why High-Order Component Naming Starts with \"with\"</p> <p>The convention of naming higher-order components (HOCs) with a prefix \"with\" comes from the idea of enhancing or augmenting the base component with additional functionality. This naming convention makes it clear that the HOC is wrapping and modifying the behavior or appearance of the original component.</p> <p>For example:</p> <ul> <li>withLogging indicates that the wrapped component will have logging functionality added.</li> <li>withAuthentication indicates that the wrapped component will have authentication checking added.</li> <li>withDataFetching indicates that the wrapped component will have data fetching capabilities added.</li> </ul> <p>Using \"with\" helps developers quickly understand that the function is not just a regular function but an HOC that will provide additional capabilities to the component it wraps.</p> <p>When to Use HOCs</p> <p>HOCs are useful in a variety of scenarios where you want to reuse component logic or behavior across multiple components without repeating code. Here are some common use cases for HOCs:</p> <ol> <li> <p>Cross-Cutting Concerns:</p> <ul> <li>Logging: Adding logging functionality to monitor the props being passed to the component.</li> <li>Error Handling: Wrapping a component in an error boundary to catch JavaScript errors anywhere in their child component tree.</li> </ul> </li> <li> <p>Code Reuse:</p> <ul> <li>Data Fetching: Encapsulating data fetching logic and reusing it across multiple components.</li> <li>Form Handling: Managing form state and submission logic that can be reused in different forms.</li> </ul> </li> <li> <p>Conditional Rendering:</p> <ul> <li>Authorization: Restricting access to certain components based on user roles or permissions.</li> <li>Feature Flags: Conditionally rendering components based on feature flags or configuration.</li> </ul> </li> <li> <p>Enhancing Components:</p> <ul> <li>Styling: Adding or modifying styles dynamically based on props or state.</li> <li>Animation: Adding animation logic to components.</li> </ul> </li> <li> <p>State Management:</p> <ul> <li>Global State: Connecting components to a global state management system (e.g., Redux).</li> </ul> </li> </ol>"},{"location":"frontend/react/example/hoc/#basic-hocs","title":"Basic HOCs","text":""},{"location":"frontend/react/example/hoc/#1-logging-props","title":"1. Logging Props","text":"Asbtract ExampleUsage javascript<pre><code>const withLogging = (WrappedComponent) =&gt; {\n    return (props) =&gt; {\n        console.log(props);\n        return &lt;WrappedComponent {...props} /&gt;;\n    };\n};\n\n// or\n\nconst withLogging = (WrappedComponent) =&gt; (props) =&gt; {\n    console.log(props);\n    return &lt;WrappedComponent {...props} /&gt;;\n};\n</code></pre> javascript<pre><code>const withLogging = (WrappedComponent) =&gt; (props) =&gt; {\n    console.log(props);\n    return &lt;WrappedComponent {...props} /&gt;;\n};\n\nconst SimpleComponent = (props) =&gt; &lt;div&gt;{props.message}&lt;/div&gt;;\n\nconst LoggedSimpleComponent = withLogging(SimpleComponent);\n\n// Usage\n&lt;LoggedSimpleComponent message=\"Hello, World!\" /&gt;;\n</code></pre>"},{"location":"frontend/react/example/hoc/#2-default-props","title":"2. Default Props","text":"Asbtract ExampleUsage javascript<pre><code>const withDefaultProps = (defaultProps) =&gt; (WrappedComponent) =&gt; {\n    return (props) =&gt; {\n        return &lt;WrappedComponent {...defaultProps} {...props} /&gt;;\n    };\n};\n\n// or\n\nconst withDefaultProps = (defaultProps) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    return &lt;WrappedComponent {...defaultProps} {...props} /&gt;;\n};\n</code></pre> javascript<pre><code>const withDefaultProps = (defaultProps) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    return &lt;WrappedComponent {...defaultProps} {...props} /&gt;;\n};\n\nconst SimpleComponent = (props) =&gt; &lt;div&gt;{props.message}&lt;/div&gt;;\n\nconst DefaultPropsComponent = withDefaultProps({ message: \"Default Message\" })(SimpleComponent);\n\n// Usage\n&lt;DefaultPropsComponent /&gt;; // Renders \"Default Message\"\n&lt;DefaultPropsComponent message=\"Custom Message\" /&gt;; // Renders \"Custom Message\"\n</code></pre>"},{"location":"frontend/react/example/hoc/#3-conditional-rendering","title":"3. Conditional Rendering","text":"Asbtract ExampleUsage javascript<pre><code>const withConditionalRendering = (conditionFn) =&gt; (WrappedComponent) =&gt; {\n    return (props) =&gt; {\n        if (conditionFn(props)) {\n            return &lt;WrappedComponent {...props} /&gt;;\n        } else {\n            return null;\n        }\n    };\n};\n\n// or\n\nconst withConditionalRendering = (conditionFn) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    return conditionFn(props) ? &lt;WrappedComponent {...props} /&gt; : null;\n};\n</code></pre> javascript<pre><code>const withConditionalRendering = (conditionFn) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    return conditionFn(props) ? &lt;WrappedComponent {...props} /&gt; : null;\n};\n\nconst SimpleComponent = (props) =&gt; &lt;div&gt;{props.message}&lt;/div&gt;;\n\nconst ConditionalComponent = withConditionalRendering((props) =&gt; props.show)(SimpleComponent);\n\n// Usage\n&lt;ConditionalComponent show={true} message=\"Visible Message\" /&gt;; // Renders \"Visible Message\"\n&lt;ConditionalComponent show={false} message=\"Invisible Message\" /&gt;; // Renders null\n</code></pre>"},{"location":"frontend/react/example/hoc/#4-adding-class-name","title":"4. Adding Class Name","text":"Asbtract ExampleUsage javascript<pre><code>const withClassName = (className) =&gt; (WrappedComponent) =&gt; {\n    return (props) =&gt; {\n        return &lt;WrappedComponent {...props} className={className} /&gt;;\n    };\n};\n\n// or\n\nconst withClassName = (className) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    return &lt;WrappedComponent {...props} className={className} /&gt;;\n};\n</code></pre> javascript<pre><code>const withClassName = (className) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    return &lt;WrappedComponent {...props} className={className} /&gt;;\n};\n\nconst SimpleComponent = (props) =&gt; &lt;div className={props.className}&gt;{props.message}&lt;/div&gt;;\n\nconst ClassNameComponent = withClassName(\"custom-class\")(SimpleComponent);\n\n// Usage\n&lt;ClassNameComponent message=\"Styled Message\" /&gt;;\n</code></pre>"},{"location":"frontend/react/example/hoc/#5-simple-error-boundary","title":"5. Simple Error Boundary","text":"Note Functional ComponentClass ComponentUsage javascript<pre><code>const withErrorBoundary = (WrappedComponent) =&gt; (props) =&gt; {\n    const [hasError, setHasError] = React.useState(false);\n\n    try {\n        return &lt;WrappedComponent {...props} /&gt;;\n    } catch (error) {\n        setHasError(true);\n        console.error(error);\n        return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;\n    }\n};\n</code></pre> javascript<pre><code>const withErrorBoundary = (WrappedComponent) =&gt; {\n    return class extends React.Component {\n        state = { hasError: false };\n\n        static getDerivedStateFromError() {\n            return { hasError: true };\n        }\n\n        componentDidCatch(error, errorInfo) {\n        console.error(error, errorInfo);\n        }\n\n        render() {\n            if (this.state.hasError) {\n                return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;\n            }\n            return &lt;WrappedComponent {...this.props} /&gt;;\n        }\n    };\n};\n</code></pre> <pre><code>const withErrorBoundary = (WrappedComponent) =&gt; (props) =&gt; {\nconst [hasError, setHasError] = React.useState(false);\n\n    try {\n        return &lt;WrappedComponent {...props} /&gt;;\n    } catch (error) {\n        setHasError(true);\n        console.error(error);\n        return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;\n    }\n};\n\nconst SimpleComponent = (props) =&gt; {\n    if (props.throwError) {\n        throw new Error(\"Error triggered\");\n    }\n    return &lt;div&gt;{props.message}&lt;/div&gt;;\n};\n\nconst ErrorBoundaryComponent = withErrorBoundary(SimpleComponent);\n\n// Usage\n&lt;ErrorBoundaryComponent throwError={true} message=\"This will throw an error\" /&gt;; // Renders error message\n&lt;ErrorBoundaryComponent throwError={false} message=\"No error\" /&gt;; // Renders \"No error\"\n</code></pre>"},{"location":"frontend/react/example/hoc/#intermediate-hocs","title":"Intermediate HOCs","text":""},{"location":"frontend/react/example/hoc/#1-data-fetching","title":"1. Data Fetching","text":"Success Functional ComponentClass ComponentUsage javascript<pre><code>const withDataFetching = (url) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    const [data, setData] = React.useState(null);\n    const [loading, setLoading] = React.useState(true);\n\n    React.useEffect(() =&gt; {\n        fetch(url)\n        .then((response) =&gt; response.json())\n        .then((data) =&gt; {\n            setData(data);\n            setLoading(false);\n        });\n    }, [url]);\n\n    return &lt;WrappedComponent {...props} data={data} loading={loading} /&gt;;\n};\n</code></pre> javascript<pre><code>const withDataFetching = (url) =&gt; (WrappedComponent) =&gt; {\n    return class extends React.Component {\n        state = { data: null, loading: true };\n\n        componentDidMount() {\n        fetch(url)\n            .then((response) =&gt; response.json())\n            .then((data) =&gt; this.setState({ data, loading: false }));\n        }\n\n        render() {\n        return &lt;WrappedComponent {...this.props} {...this.state} /&gt;;\n        }\n    };\n};\n</code></pre> <pre><code>const withDataFetching = (url) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    const [data, setData] = React.useState(null);\n    const [loading, setLoading] = React.useState(true);\n\n    React.useEffect(() =&gt; {\n        fetch(url)\n        .then((response) =&gt; response.json())\n        .then((data) =&gt; {\n            setData(data);\n            setLoading(false);\n        });\n    }, [url]);\n\n    return &lt;WrappedComponent {...props} data={data} loading={loading} /&gt;;\n};\n\nconst DataComponent = ({ data, loading }) =&gt; {\n    if (loading) {\n        return &lt;div&gt;Loading...&lt;/div&gt;;\n    }\n    return &lt;div&gt;Data: {JSON.stringify(data)}&lt;/div&gt;;\n};\n\nconst FetchedDataComponent = withDataFetching(\"https://api.example.com/data\")(DataComponent);\n\n// Usage\n&lt;FetchedDataComponent /&gt;;\n</code></pre>"},{"location":"frontend/react/example/hoc/#2-authentication-check","title":"2. Authentication Check","text":"Success Functional ComponentClass ComponentUsage javascript<pre><code>const withAuthentication = (WrappedComponent) =&gt; (props) =&gt; {\n    if (!props.isAuthenticated) {\n        return &lt;div&gt;Please log in&lt;/div&gt;;\n    }\n    return &lt;WrappedComponent {...props} /&gt;;\n};\n</code></pre> javascript<pre><code>const withAuthentication = (WrappedComponent) =&gt; {\n    return class extends React.Component {\n        render() {\n        if (!this.props.isAuthenticated) {\n            return &lt;div&gt;Please log in&lt;/div&gt;;\n        }\n        return &lt;WrappedComponent {...this.props} /&gt;;\n        }\n    };\n};\n</code></pre> <pre><code>const withAuthentication = (WrappedComponent) =&gt; (props) =&gt; {\n    if (!props.isAuthenticated) {\n        return &lt;div&gt;Please log in&lt;/div&gt;;\n    }\n    return &lt;WrappedComponent {...props} /&gt;;\n};\n\nconst AuthenticatedComponent = (props) =&gt; &lt;div&gt;Authenticated Content&lt;/div&gt;;\n\nconst AuthCheckComponent = withAuthentication(AuthenticatedComponent);\n\n// Usage\n&lt;AuthCheckComponent isAuthenticated={true} /&gt;; // Renders \"Authenticated Content\"\n&lt;AuthCheckComponent isAuthenticated={false} /&gt;; // Renders \"Please log in\"\n</code></pre>"},{"location":"frontend/react/example/hoc/#3-form-handling","title":"3. Form Handling","text":"Success Functional ComponentClass ComponentUsage javascript<pre><code>const withFormHandling = (WrappedComponent) =&gt; (props) =&gt; {\n    const [formData, setFormData] = React.useState({});\n\n    const handleChange = (event) =&gt; {\n        const { name, value } = event.target;\n        setFormData({ ...formData, [name]: value });\n    };\n\n    const handleSubmit = (event) =&gt; {\n        event.preventDefault();\n        // handle form submission\n    };\n\n    return (\n        &lt;WrappedComponent\n        {...props}\n        formData={formData}\n        handleChange={handleChange}\n        handleSubmit={handleSubmit}\n        /&gt;\n    );\n};\n</code></pre> javascript<pre><code>const withFormHandling = (WrappedComponent) =&gt; {\n    return class extends React.Component {\n        state = { formData: {} };\n\n        handleChange = (event) =&gt; {\n        const { name, value } = event.target;\n        this.setState({ formData: { ...this.state.formData, [name]: value } });\n        };\n\n        handleSubmit = (event) =&gt; {\n        event.preventDefault();\n        // handle form submission\n        };\n\n        render() {\n        return (\n            &lt;WrappedComponent\n            {...this.props}\n            formData={this.state.formData}\n            handleChange={this.handleChange}\n            handleSubmit={this.handleSubmit}\n            /&gt;\n        );\n        }\n    };\n};\n</code></pre> <pre><code>const withFormHandling = (WrappedComponent) =&gt; (props) =&gt; {\nconst [formData, setFormData] = React.useState({});\n\nconst handleChange = (event) =&gt; {\n    const { name, value } = event.target;\n    setFormData({ ...formData, [name]: value });\n};\n\nconst handleSubmit = (event) =&gt; {\n    event.preventDefault();\n    console.log(\"Form submitted with data:\", formData);\n};\n\nreturn (\n    &lt;WrappedComponent\n    {...props}\n    formData={formData}\n    handleChange={handleChange}\n    handleSubmit={handleSubmit}\n    /&gt;\n);\n};\n\nconst FormComponent = ({ formData, handleChange, handleSubmit }) =&gt; (\n&lt;form onSubmit={handleSubmit}&gt;\n    &lt;input name=\"name\" value={formData.name || ''} onChange={handleChange} /&gt;\n    &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n&lt;/form&gt;\n);\n\nconst HandledFormComponent = withFormHandling(FormComponent);\n\n// Usage\n&lt;HandledFormComponent /&gt;;\n</code></pre>"},{"location":"frontend/react/example/hoc/#4-authorization-check","title":"4. Authorization Check","text":"Success Functional ComponentClass ComponentUsage javascript<pre><code>const withAuthorization = (allowedRoles) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    if (!allowedRoles.includes(props.role)) {\n        return &lt;div&gt;Access Denied&lt;/div&gt;;\n    }\n    return &lt;WrappedComponent {...props} /&gt;;\n};\n</code></pre> javascript<pre><code>const withAuthorization = (allowedRoles) =&gt; (WrappedComponent) =&gt; {\n    return class extends React.Component {\n        render() {\n        if (!allowedRoles.includes(this.props.role)) {\n            return &lt;div&gt;Access Denied&lt;/div&gt;;\n        }\n        return &lt;WrappedComponent {...this.props} /&gt;;\n        }\n    };\n};\n</code></pre> <pre><code>const withAuthorization = (allowedRoles) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    if (!allowedRoles.includes(props.role)) {\n        return &lt;div&gt;Access Denied&lt;/div&gt;;\n    }\n    return &lt;WrappedComponent {...props} /&gt;;\n};\n\nconst AuthorizedComponent = (props) =&gt; &lt;div&gt;Authorized Content&lt;/div&gt;;\n\nconst RoleCheckComponent = withAuthorization(['admin'])(AuthorizedComponent);\n\n// Usage\n&lt;RoleCheckComponent role=\"admin\" /&gt;; // Renders \"Authorized Content\"\n&lt;RoleCheckComponent role=\"user\" /&gt;; // Renders \"Access Denied\"\n</code></pre>"},{"location":"frontend/react/example/hoc/#5-redux-connect-hoc","title":"5. Redux Connect HOC","text":"Success ExampleUsage javascript<pre><code>import { connect } from 'react-redux';\n\nconst withReduxConnect = (mapStateToProps, mapDispatchToProps) =&gt; (WrappedComponent) =&gt; {\n    return connect(mapStateToProps, mapDispatchToProps)(WrappedComponent);\n};\n</code></pre> <pre><code>import { connect } from 'react-redux';\n\nconst withReduxConnect = (mapStateToProps, mapDispatchToProps) =&gt; (WrappedComponent) =&gt; {\n    return connect(mapStateToProps, mapDispatchToProps)(WrappedComponent);\n};\n\nconst SimpleComponent = ({ message }) =&gt; &lt;div&gt;{message}&lt;/div&gt;;\n\nconst mapStateToProps = (state) =&gt; ({\n    message: state.message,\n});\n\nconst mapDispatchToProps = (dispatch) =&gt; ({\n    updateMessage: (msg) =&gt; dispatch({ type: 'UPDATE_MESSAGE', payload: msg }),\n});\n\nconst ReduxConnectedComponent = withReduxConnect(mapStateToProps, mapDispatchToProps)(SimpleComponent);\n\n// Usage\n&lt;ReduxConnectedComponent /&gt;;\n</code></pre>"},{"location":"frontend/react/example/hoc/#advanced-hocs","title":"Advanced HOCs","text":""},{"location":"frontend/react/example/hoc/#1-dynamic-module-loader","title":"1. Dynamic Module Loader","text":"Example Functional ComponentClass ComponentUsage javascript<pre><code>const withDynamicModule = (importModule) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    const [Module, setModule] = React.useState(null);\n\n    React.useEffect(() =&gt; {\n        importModule().then((mod) =&gt; setModule(mod.default));\n    }, [importModule]);\n\n    return Module ? &lt;Module {...props} /&gt; : &lt;div&gt;Loading...&lt;/div&gt;;\n};\n</code></pre> javascript<pre><code>const withDynamicModule = (importModule) =&gt; (WrappedComponent) =&gt; {\n    return class extends React.Component {\n        state = { Module: null };\n\n        componentDidMount() {\n        importModule().then((mod) =&gt; this.setState({ Module: mod.default }));\n        }\n\n        render() {\n        const { Module } = this.state;\n        return Module ? &lt;Module {...this.props} /&gt; : &lt;div&gt;Loading...&lt;/div&gt;;\n        }\n    };\n};\n</code></pre> javascript<pre><code>const withDynamicModule = (importModule) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    const [Module, setModule] = React.useState(null);\n\n    React.useEffect(() =&gt; {\n        importModule().then((mod) =&gt; setModule(mod.default));\n    }, [importModule]);\n\n    return Module ? &lt;Module {...props} /&gt; : &lt;div&gt;Loading...&lt;/div&gt;;\n};\n\nconst DynamicComponent = (props) =&gt; &lt;div&gt;{props.dynamicContent}&lt;/div&gt;;\n\nconst DynamicLoadedComponent = withDynamicModule(() =&gt; import('./DynamicComponent'))(DynamicComponent);\n\n// Usage\n&lt;DynamicLoadedComponent dynamicContent=\"This is dynamically loaded\" /&gt;;\n</code></pre>"},{"location":"frontend/react/example/hoc/#2-performance-optimization-with-memoization","title":"2. Performance Optimization with Memoization","text":"Example Functional ComponentClass ComponentUsage javascript<pre><code>const withMemoization = (WrappedComponent) =&gt; React.memo(WrappedComponent, (prevProps, nextProps) =&gt; {\n    // Add custom comparison logic here\n    return prevProps === nextProps;\n});\n</code></pre> javascript<pre><code>const withMemoization = (WrappedComponent) =&gt; {\n    return React.memo(WrappedComponent, (prevProps, nextProps) =&gt; {\n        // Add custom comparison logic here\n        return prevProps === nextProps;\n    });\n};\n</code></pre> javascript<pre><code>const withMemoization = (WrappedComponent) =&gt; React.memo(WrappedComponent, (prevProps, nextProps) =&gt; {\n    return prevProps === nextProps;\n});\n\nconst MemoizedComponent = ({ message }) =&gt; &lt;div&gt;{message}&lt;/div&gt;;\n\nconst OptimizedComponent = withMemoization(MemoizedComponent);\n\n// Usage\n&lt;OptimizedComponent message=\"Memoized Content\" /&gt;;\n</code></pre>"},{"location":"frontend/react/example/hoc/#3-internationalization-i18n","title":"3. Internationalization (i18n)","text":"Example Functional ComponentClass ComponentUsage javascript<pre><code>import { useTranslation } from 'react-i18next';\n\nconst withI18n = (WrappedComponent) =&gt; (props) =&gt; {\n    const { t, i18n } = useTranslation();\n    return &lt;WrappedComponent {...props} t={t} i18n={i18n} /&gt;;\n};\n</code></pre> javascript<pre><code>import { withTranslation } from 'react-i18next';\n\nconst withI18n = (WrappedComponent) =&gt; {\n    return withTranslation()(WrappedComponent);\n};\n</code></pre> javascript<pre><code>import { useTranslation } from 'react-i18next';\n\nconst withI18n = (WrappedComponent) =&gt; (props) =&gt; {\n    const { t, i18n } = useTranslation();\n    return &lt;WrappedComponent {...props} t={t} i18n={i18n} /&gt;;\n};\n\nconst TranslatedComponent = ({ t }) =&gt; &lt;div&gt;{t('welcome_message')}&lt;/div&gt;;\n\nconst I18nComponent = withI18n(TranslatedComponent);\n\n// Usage\n&lt;I18nComponent /&gt;;\n</code></pre>"},{"location":"frontend/react/example/hoc/#4-analytics-tracking","title":"4. Analytics Tracking","text":"Example Functional ComponentClass ComponentUsage javascript<pre><code>const withAnalytics = (eventName) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    React.useEffect(() =&gt; {\n        // Simulate sending event to analytics service\n        console.log(`Event: ${eventName}`);\n    }, [eventName]);\n\n    return &lt;WrappedComponent {...props} /&gt;;\n};\n</code></pre> javascript<pre><code>const withAnalytics = (eventName) =&gt; (WrappedComponent) =&gt; {\n    return class extends React.Component {\n        componentDidMount() {\n            // Simulate sending event to analytics service\n            console.log(`Event: ${eventName}`);\n        }\n\n        render() {\n            return &lt;WrappedComponent {...this.props} /&gt;;\n        }\n    };\n};\n</code></pre> javascript<pre><code>const withAnalytics = (eventName) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    React.useEffect(() =&gt; {\n        console.log(`Event: ${eventName}`);\n    }, [eventName]);\n\n    return &lt;WrappedComponent {...props} /&gt;;\n};\n\nconst AnalyticsComponent = (props) =&gt; &lt;div&gt;{props.content}&lt;/div&gt;;\n\nconst TrackedComponent = withAnalytics('ComponentLoaded')(AnalyticsComponent);\n\n// Usage\n&lt;TrackedComponent content=\"Analytics Tracked Content\" /&gt;;\n</code></pre>"},{"location":"frontend/react/example/hoc/#5-drag-and-drop","title":"5. Drag and Drop","text":"Example Functional ComponentClass ComponentUsage javascript<pre><code>import { useDrag, useDrop } from 'react-dnd';\n\nconst withDragAndDrop = (WrappedComponent) =&gt; (props) =&gt; {\n    const [, drag] = useDrag({\n        type: 'ITEM',\n        item: { id: props.id },\n    });\n\n    const [, drop] = useDrop({\n        accept: 'ITEM',\n        drop: (item) =&gt; props.onDrop(item.id, props.id),\n    });\n\n    return (\n        &lt;div ref={(node) =&gt; drag(drop(node))}&gt;\n            &lt;WrappedComponent {...props} /&gt;\n        &lt;/div&gt;\n    );\n};\n</code></pre> javascript<pre><code>import { DragSource, DropTarget } from 'react-dnd';\n\nconst withDragAndDrop = (WrappedComponent) =&gt; {\n    const dragSpec = {\n        beginDrag: (props) =&gt; ({ id: props.id })\n    };\n\n    const dropSpec = {\n        drop: (props, monitor) =&gt; {\n            const item = monitor.getItem();\n            props.onDrop(item.id, props.id);\n        }\n    };\n\n    const collectDrag = (connect) =&gt; ({\n        connectDragSource: connect.dragSource()\n    });\n\n    const collectDrop = (connect) =&gt; ({\n        connectDropTarget: connect.dropTarget()\n    });\n\n    const DraggableComponent = DragSource('ITEM', dragSpec, collectDrag)(WrappedComponent);\n    return DropTarget('ITEM', dropSpec, collectDrop)(DraggableComponent);\n};\n</code></pre> javascript<pre><code>import { useDrag, useDrop } from 'react-dnd';\n\nconst withDragAndDrop = (WrappedComponent) =&gt; (props) =&gt; {\n    const [, drag] = useDrag({\n        type: 'ITEM',\n        item: { id: props.id },\n    });\n\n    const [, drop] = useDrop({\n        accept: 'ITEM',\n        drop: (item) =&gt; props.onDrop(item.id, props.id),\n    });\n\n    return (\n        &lt;div ref={(node) =&gt; drag(drop(node))}&gt;\n        &lt;WrappedComponent {...props} /&gt;\n        &lt;/div&gt;\n    );\n};\n\nconst DraggableComponent = ({ content }) =&gt; &lt;div&gt;{content}&lt;/div&gt;;\n\nconst DragDropComponent = withDragAndDrop(DraggableComponent);\n\n// Usage\n&lt;DragDropComponent id=\"1\" content=\"Drag me\" onDrop={(sourceId, targetId) =&gt; console.log(`Dropped ${sourceId} on ${targetId}`)} /&gt;;\n</code></pre> <p>These examples should cover a wide range of scenarios and illustrate how HOCs can be used to enhance and reuse component functionality at different levels of complexity.</p>"},{"location":"frontend/react/example/hoc/#folder-structure-of-hocs","title":"Folder Structure of HOCs","text":"<p>The folder structure for Higher-Order Components (HOCs) in a React project can vary depending on the complexity and size of your project. However, a common and organized way to structure your folders and files can look like this:</p>"},{"location":"frontend/react/example/hoc/#1-basic-folder-structure","title":"1. Basic Folder Structure","text":"<p>A simple structure for a small to medium-sized project might look like this:</p> <pre><code>src/\n\u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 SomeComponent/\n\u2502   \u2502   \u251c\u2500\u2500 SomeComponent.js\n\u2502   \u2502   \u251c\u2500\u2500 SomeComponent.css\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 hocs/\n\u2502   \u251c\u2500\u2500 withAuth.js\n\u2502   \u2514\u2500\u2500 withLogging.js\n\u251c\u2500\u2500 App.js\n\u251c\u2500\u2500 index.js\n\u2514\u2500\u2500 ...\n</code></pre>"},{"location":"frontend/react/example/hoc/#2-advanced-folder-structure","title":"2. Advanced Folder Structure","text":"<p>For larger projects, it might make sense to have a more detailed structure:</p> <pre><code>src/\n\u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 SomeComponent/\n\u2502   \u2502   \u251c\u2500\u2500 SomeComponent.js\n\u2502   \u2502   \u251c\u2500\u2500 SomeComponent.css\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 AnotherComponent/\n\u2502       \u251c\u2500\u2500 AnotherComponent.js\n\u2502       \u251c\u2500\u2500 AnotherComponent.css\n\u2502       \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 hocs/\n\u2502   \u251c\u2500\u2500 withAuth/\n\u2502   \u2502   \u251c\u2500\u2500 withAuth.js\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u251c\u2500\u2500 withLogging/\n\u2502   \u2502   \u251c\u2500\u2500 withLogging.js\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 withAnotherFeature/\n\u2502       \u251c\u2500\u2500 withAnotherFeature.js\n\u2502       \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 utils/\n\u2502   \u251c\u2500\u2500 helper1.js\n\u2502   \u2514\u2500\u2500 helper2.js\n\u251c\u2500\u2500 hooks/\n\u2502   \u251c\u2500\u2500 useCustomHook.js\n\u2502   \u2514\u2500\u2500 useAnotherHook.js\n\u251c\u2500\u2500 App.js\n\u251c\u2500\u2500 index.js\n\u2514\u2500\u2500 ...\n</code></pre>"},{"location":"frontend/react/example/hoc/#explanation-of-each-folder","title":"Explanation of Each Folder:","text":"<ol> <li> <p>components/:</p> <ul> <li>Contains all your React components.</li> <li>Each component has its own folder which may contain its JavaScript file, CSS file, and an <code>index.js</code> for easier imports.</li> </ul> </li> <li> <p>hocs/:</p> <ul> <li>Contains all your Higher-Order Components.</li> <li>Each HOC can have its own folder if it consists of multiple files or just a single file if it's simple.</li> <li>Each HOC folder typically has an <code>index.js</code> file for easier imports.</li> </ul> </li> <li> <p>utils/:</p> <ul> <li>Contains utility functions that can be reused throughout your project.</li> </ul> </li> <li> <p>hooks/:</p> <ul> <li>Contains custom React hooks.</li> </ul> </li> </ol>"},{"location":"frontend/react/example/hoc/#hocs","title":"HOCs","text":"<p>Higher-Order Components (HOCs) are a pattern in React for reusing component logic. They are functions that take a component and return a new component with added functionality. HOCs are particularly useful in various scenarios, and they are commonly used for the following purposes:</p>"},{"location":"frontend/react/example/hoc/#scenarios-for-using-hocs","title":"Scenarios for Using HOCs","text":"<ol> <li> <p>Code Reuse, Logic, and Bootstrap Abstraction:</p> <ul> <li>HOCs allow you to reuse code across multiple components. This is particularly useful for logic that needs to be shared, such as fetching data, managing state, or subscribing to events.</li> </ul> </li> <li> <p>Manipulating Props:</p> <ul> <li>HOCs can manipulate the props passed to a component. This can include adding new props, modifying existing ones, or filtering out unnecessary props.</li> </ul> </li> <li> <p>Conditional Rendering:</p> <ul> <li>HOCs can be used to conditionally render components based on certain criteria, such as user authentication, feature flags, or permission levels.</li> </ul> </li> <li> <p>State Management:</p> <ul> <li>They can manage state and pass it down as props to the wrapped component. This is useful for scenarios where state management logic needs to be shared across multiple components.</li> </ul> </li> <li> <p>Handling Side Effects:</p> <ul> <li>HOCs can handle side effects like data fetching, subscriptions, or logging. This is useful for abstracting side effects out of the component, keeping them clean and focused on rendering UI.</li> </ul> </li> </ol>"},{"location":"frontend/react/example/hoc/#common-uses-of-hocs","title":"Common Uses of HOCs","text":"<ol> <li> <p>Authentication:</p> <ul> <li>Wrapping components to ensure that only authenticated users can access certain parts of an application.</li> <li>Example: <code>withAuth(Component)</code></li> </ul> </li> <li> <p>Logging:</p> <ul> <li>Adding logging functionality to components for debugging or analytics.</li> <li>Example: <code>withLogging(Component)</code></li> </ul> </li> <li> <p>Data Fetching:</p> <ul> <li>Fetching data from an API and passing it as props to the wrapped component.</li> <li>Example: <code>withDataFetching(Component, apiEndpoint)</code></li> </ul> </li> <li> <p>Theming:</p> <ul> <li>Providing theme-related props to components.</li> <li>Example: <code>withTheme(Component)</code></li> </ul> </li> <li> <p>Error Handling:</p> <ul> <li>Wrapping components with error boundaries to catch and handle errors in a standardized way.</li> <li>Example: <code>withErrorBoundary(Component)</code></li> </ul> </li> <li> <p>Access Control:</p> <ul> <li>Enforcing role-based access control by conditionally rendering components based on user roles.</li> <li>Example: <code>withRole(Component, allowedRoles)</code></li> </ul> </li> <li> <p>Form Handling:</p> <ul> <li>Managing form state and validation logic.</li> <li>Example: <code>withFormHandling(Component)</code></li> </ul> </li> </ol>"},{"location":"frontend/react/example/lifting-state-up/","title":"Lifting State Up","text":""},{"location":"frontend/react/example/lifting-state-up/#theory-of-lifting-state-up-in-react","title":"Theory of Lifting State Up in React","text":"<p>Lifting state up is a pattern in React where you move state from <code>child components</code> to a common <code>parent component</code>. This pattern is necessary for managing state that needs to be shared among multiple child components. By lifting the state up to a common ancestor, you create a single source of truth, ensuring that all child components that need the state have access to the same data.</p>"},{"location":"frontend/react/example/lifting-state-up/#why-is-it-necessary","title":"Why Is It Necessary?","text":"<p>When multiple components need to share and synchronize state, managing the state within each component individually can lead to inconsistencies and complexity. Lifting the state up solves these issues by:</p> <ul> <li>Ensuring Consistency: By having a single source of truth for the state, you avoid the risk of components having out-of-sync data.</li> <li>Simplifying State Management: It becomes easier to manage and update the state from one place, reducing the complexity of your application.</li> <li>Avoiding Prop Drilling: While lifting state up does require passing state down as props, it helps avoid deeper and more convoluted prop drilling in larger component trees.</li> </ul>"},{"location":"frontend/react/example/lifting-state-up/#how-does-it-solve-the-problem","title":"How Does It Solve the Problem?","text":"<p>Problem: </p> <p>Imagine two sibling components need to share and synchronize some state. If each component maintains its own state, it becomes challenging to keep them in sync.</p> <p>Solution: </p> <p>Lift the state up to their common parent, and pass the state and state-updating functions down to the child components via props. This way, the parent component manages the state, and the child components simply use the state and functions passed to them.</p>"},{"location":"frontend/react/example/lifting-state-up/#example","title":"Example","text":"<p>Let's consider a more detailed example:</p> Tip Without Lifting State UpWith Lifting State Up <p>We have two sibling components: TemperatureInput for Celsius and Fahrenheit. Each component maintains its own state.</p> <pre><code>function TemperatureInputCelsius() {\n    const [celsius, setCelsius] = useState('');\n\n    const handleChange = (e) =&gt; {\n        setCelsius(e.target.value);\n    };\n\n    return &lt;input type=\"text\" value={celsius} onChange={handleChange} /&gt;;\n}\n\nfunction TemperatureInputFahrenheit() {\n    const [fahrenheit, setFahrenheit] = useState('');\n\n    const handleChange = (e) =&gt; {\n        setFahrenheit(e.target.value);\n    };\n\n    return &lt;input type=\"text\" value={fahrenheit} onChange={handleChange} /&gt;;\n}\n\nfunction App() {\n    return (\n        &lt;div&gt;\n        &lt;TemperatureInputCelsius /&gt;\n        &lt;TemperatureInputFahrenheit /&gt;\n        &lt;/div&gt;\n    );\n}\n</code></pre> <p>In this setup, the components have their own state and do not share data. Converting between Celsius and Fahrenheit requires extra logic in each component and makes it hard to keep them in sync.</p> <p>Lift the state up to the App component and pass the necessary state and handlers down to the child components.</p> <pre><code>function TemperatureInput({ scale, temperature, handleChange }) {\n    return (\n        &lt;fieldset&gt;\n        &lt;legend&gt;Enter temperature in {scale}:&lt;/legend&gt;\n        &lt;input value={temperature} onChange={handleChange} /&gt;\n        &lt;/fieldset&gt;\n    );\n}\n\n// main function\nfunction App() {\n    const [temperature, setTemperature] = useState('');\n    const [scale, setScale] = useState('c');\n\n    const handleCelsiusChange = (e) =&gt; {\n        setScale('c');\n        setTemperature(e.target.value);\n    };\n\n    const handleFahrenheitChange = (e) =&gt; {\n        setScale('f');\n        setTemperature(e.target.value);\n    };\n\n    const celsius = scale === 'f' ? tryConvert(temperature, toCelsius) : temperature;\n    const fahrenheit = scale === 'c' ? tryConvert(temperature, toFahrenheit) : temperature;\n\n    return (\n        &lt;div&gt;\n        &lt;TemperatureInput\n            scale=\"Celsius\"\n            temperature={celsius}\n            handleChange={handleCelsiusChange}\n        /&gt;\n        &lt;TemperatureInput\n            scale=\"Fahrenheit\"\n            temperature={fahrenheit}\n            handleChange={handleFahrenheitChange}\n        /&gt;\n        &lt;/div&gt;\n    );\n}\n\nfunction toCelsius(fahrenheit) {\n    return ((fahrenheit - 32) * 5) / 9;\n}\n\nfunction toFahrenheit(celsius) {\n    return (celsius * 9) / 5 + 32;\n}\n\nfunction tryConvert(temperature, convert) {\n    const input = parseFloat(temperature);\n    if (Number.isNaN(input)) {\n        return '';\n    }\n    const output = convert(input);\n    const rounded = Math.round(output * 1000) / 1000;\n    return rounded.toString();\n}\n</code></pre> <p>In this example, the <code>App</code> component maintains the state for the temperature and the scale. The <code>TemperatureInput</code> components are now stateless and receive the necessary state and handlers as props. The conversion functions ensure that both input fields stay in sync.</p>"},{"location":"frontend/react/example/lifting-state-up/#summary","title":"Summary","text":"<ul> <li>Lifting state up means moving the state to the closest common ancestor of components that need to share the state.</li> <li>It ensures consistency, simplifies state management, and avoids deep prop drilling.</li> <li>By lifting state up, you centralize the state management, making your application more predictable and easier to maintain.</li> </ul> <p>This approach is essential for managing shared state in React applications, particularly as they grow in complexity.</p>"},{"location":"frontend/react/example/passing-props/","title":"Passing Props","text":""},{"location":"frontend/react/example/passing-props/#passing-props","title":"passing props","text":"<p>Yes, you can pass state and functions to other components in React, and this is a common practice. The standard approach typically involves the following methods:</p>"},{"location":"frontend/react/example/passing-props/#1-props","title":"1. Props","text":"<p>Passing state and functions through props is the most straightforward method. This is done by passing them from a parent component to its child components.</p> <pre><code>function ParentComponent() {\n  const [state, setState] = useState(initialState);\n\n  const handleAction = () =&gt; {\n    // function logic\n  };\n\n  return (\n    &lt;ChildComponent state={state} handleAction={handleAction} /&gt;\n  );\n}\n\nfunction ChildComponent({ state, handleAction }) {\n  return (\n    &lt;div&gt;\n      &lt;p&gt;{state}&lt;/p&gt;\n      &lt;button onClick={handleAction}&gt;Do Something&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"frontend/react/example/passing-props/#2-context","title":"2. Context","text":"<p>For passing state and functions down the component tree without prop drilling (passing through many intermediary components), React's Context API can be used.</p> <pre><code>const MyContext = React.createContext();\n\nfunction ParentComponent() {\n  const [state, setState] = useState(initialState);\n\n  const handleAction = () =&gt; {\n    // function logic\n  };\n\n  return (\n    &lt;MyContext.Provider value={{ state, handleAction }}&gt;\n      &lt;ChildComponent /&gt;\n    &lt;/MyContext.Provider&gt;\n  );\n}\n\nfunction ChildComponent() {\n  const { state, handleAction } = React.useContext(MyContext);\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;{state}&lt;/p&gt;\n      &lt;button onClick={handleAction}&gt;Do Something&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"frontend/react/example/passing-props/#3-custom-hooks","title":"3. Custom Hooks","text":"<p>For reusable logic that involves state and functions, you can create custom hooks.</p> <pre><code>function useCustomHook() {\n  const [state, setState] = useState(initialState);\n\n  const handleAction = () =&gt; {\n    // function logic\n  };\n\n  return { state, handleAction };\n}\n\nfunction Component() {\n  const { state, handleAction } = useCustomHook();\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;{state}&lt;/p&gt;\n      &lt;button onClick={handleAction}&gt;Do Something&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"frontend/react/example/passing-props/#standard-practices","title":"Standard Practices:","text":""},{"location":"frontend/react/example/passing-props/#lift-state-up","title":"Lift State Up:","text":"<p>Keep the state in the closest common ancestor of the components that need access to the state. This helps in avoiding unnecessary re-renders and makes the state management simpler.</p>"},{"location":"frontend/react/example/passing-props/#prop-drilling","title":"Prop Drilling:","text":"<p>If prop drilling (passing props through multiple levels of components) becomes cumbersome, consider using Context API or state management libraries like Redux.</p>"},{"location":"frontend/react/example/passing-props/#descriptive-props","title":"Descriptive Props:","text":"<p>When passing functions and state as props, use descriptive names to make the code more readable and maintainable.</p>"},{"location":"frontend/react/example/passing-props/#minimize-context-use","title":"Minimize Context Use:","text":"<p>Use context sparingly to avoid performance issues related to unnecessary re-renders. For global state management, consider state management libraries.</p> <p>By following these methods and practices, you can effectively manage and pass state and functions between components in your React application.</p>"},{"location":"frontend/react/example/passing-props/#naming-conventions-for-passing-props","title":"Naming Conventions for Passing Props","text":"Tip <ol> <li> <p>Descriptive Names:</p> <ul> <li>Use clear, descriptive names that convey the purpose of the prop.</li> <li>For state values, use the noun form.</li> <li>For functions (handlers), use the verb form, often prefixed with on or handle.</li> </ul> </li> <li> <p>State Props:</p> <ul> <li>Use the exact name of the state variable.</li> <li>Example: If the state variable is <code>user</code>, pass it as <code>user</code>.</li> </ul> </li> <li> <p>Function Props:</p> <ul> <li>Prefix functions with on if they are event handlers.</li> <li>Prefix with handle if they are general purpose functions.</li> <li>Example: onClick, onChange, handleSubmit.</li> </ul> </li> <li> <p>Boolean Props:</p> <ul> <li>Use prefixes like is, has, should, etc., to indicate boolean nature.</li> <li>Example: isOpen, hasError.</li> </ul> </li> </ol>"},{"location":"frontend/react/example/passing-props/#examples","title":"Examples","text":"<p>Here are examples demonstrating these conventions:</p> Basic Example Parent Component:Child Component: jsx<pre><code>function ParentComponent() {\n    const [count, setCount] = useState(0);\n\n    const incrementCount = () =&gt; {\n        setCount(count + 1);\n    };\n\n    return (\n        &lt;ChildComponent count={count} onIncrement={incrementCount} /&gt;\n    );\n}\n</code></pre> jsx<pre><code>function ChildComponent({ count, onIncrement }) {\n    return (\n        &lt;div&gt;\n            &lt;p&gt;Count: {count}&lt;/p&gt;\n            &lt;button onClick={onIncrement}&gt;Increment&lt;/button&gt;\n        &lt;/div&gt;\n    );\n}\n</code></pre> Advanced Example with Multiple Props Parent Component:Child Component: jsx<pre><code>function ParentComponent() {\n    const [username, setUsername] = useState('');\n    const [email, setEmail] = useState('');\n\n    const handleUsernameChange = (e) =&gt; {\n        setUsername(e.target.value);\n    };\n\n    const handleEmailChange = (e) =&gt; {\n        setEmail(e.target.value);\n    };\n\n    return (\n        &lt;FormComponent\n            username={username}\n            email={email}\n            onUsernameChange={handleUsernameChange}\n            onEmailChange={handleEmailChange}\n        /&gt;\n    );\n}\n</code></pre> jsx<pre><code>function FormComponent({ username, email, onUsernameChange, onEmailChange }) {\n    return (\n        &lt;form&gt;\n            &lt;div&gt;\n                &lt;label&gt;Username:&lt;/label&gt;\n                &lt;input type=\"text\" value={username} onChange={onUsernameChange} /&gt;\n            &lt;/div&gt;\n            &lt;div&gt;\n                &lt;label&gt;Email:&lt;/label&gt;\n                &lt;input type=\"email\" value={email} onChange={onEmailChange} /&gt;\n            &lt;/div&gt;\n        &lt;/form&gt;\n    );\n}\n</code></pre>"},{"location":"frontend/react/example/passing-props/#summary-of-naming-conventions","title":"Summary of Naming Conventions","text":"<ul> <li>State Values: Use the exact name of the state variable (e.g., <code>count</code>, <code>username</code>).</li> <li>Function Props: Prefix with on for <code>event handlers</code> and handle for <code>general functions</code> (e.g., <code>onClick</code>, <code>handleSubmit</code>).</li> <li>Boolean Props: Use prefixes like is, has, should to indicate their nature (e.g., <code>isOpen</code>, <code>hasError</code>).</li> </ul> <p>Following these conventions makes your code more predictable, readable, and easier to maintain, especially when working in teams or on large projects.</p>"},{"location":"frontend/react/example/presentational-and-container/","title":"Presentation & Container","text":""},{"location":"frontend/react/example/presentational-and-container/#presentational-components","title":"Presentational Components:","text":"<p>These components focus on how things look. They receive data and callbacks exclusively via props and rarely have their own state.</p>"},{"location":"frontend/react/example/presentational-and-container/#container-components","title":"Container Components:","text":"<p>These components focus on how things work. They manage state and handle logic, passing data and callbacks down to presentational components.</p>"},{"location":"frontend/react/example/presentational-and-container/#example","title":"Example","text":"jsx<pre><code>// UserForm.js (Presentational Component)\nimport { Form, Input, Button } from 'antd';\n\nconst UserForm = ({ form, onSubmit }) =&gt; (\n  &lt;Form form={form} layout=\"vertical\" onFinish={onSubmit}&gt;\n    &lt;Form.Item name=\"name\" label=\"Name\" rules={[{ required: true }]}&gt;\n      &lt;Input /&gt;\n    &lt;/Form.Item&gt;\n    &lt;Form.Item name=\"email\" label=\"Email\" rules={[{ required: true, type: 'email' }]}&gt;\n      &lt;Input /&gt;\n    &lt;/Form.Item&gt;\n    &lt;Button type=\"primary\" htmlType=\"submit\"&gt;Submit&lt;/Button&gt;\n  &lt;/Form&gt;\n);\n\nexport default UserForm;\n\n// UserFormContainer.js (Container Component)\nimport React from 'react';\nimport { Form, message } from 'antd';\nimport UserForm from './UserForm';\n\nconst UserFormContainer = () =&gt; {\n  const [form] = Form.useForm();\n\n  const handleSubmit = (values) =&gt; {\n    message.success('Form submitted: ' + JSON.stringify(values));\n    // handle form submission logic here\n  };\n\n  return &lt;UserForm form={form} onSubmit={handleSubmit} /&gt;;\n};\n\nexport default UserFormContainer;\n</code></pre>"},{"location":"frontend/react/example/prop-drilling/","title":"Props Drilling","text":"<p>Prop drilling is a pattern in React where you pass data and functions from a parent component through multiple levels of intermediate components down to a deeply nested child component. This can become cumbersome and make the component tree harder to manage, especially as the application grows.</p>"},{"location":"frontend/react/example/prop-drilling/#what-is-prop-drilling","title":"What is Prop Drilling?","text":"<p>Prop drilling occurs when you need to pass data or callbacks through many layers of components, even if those intermediate components don\u2019t need to use the data themselves. It can lead to:</p> <ul> <li>Complex Component Trees: Passing props through many layers can make components less reusable and harder to maintain.</li> <li>Unnecessary Re-renders: Intermediate components may re-render unnecessarily if the props change.</li> <li>Increased Boilerplate: You may need to add boilerplate code for passing props through each component layer.</li> </ul>"},{"location":"frontend/react/example/prop-drilling/#example","title":"Example","text":"Parent Component: <pre><code>const Parent = () =&gt; {\n    const [data, setData] = useState('Hello');\n\n    return &lt;Intermediate data={data} /&gt;;\n};\n</code></pre> Intermediate Component: <pre><code>const Intermediate = ({ data }) =&gt; {\n    return &lt;DeepChild data={data} /&gt;;\n};\n</code></pre> Deep Child Component: <pre><code>const DeepChild = ({ data }) =&gt; {\n    return &lt;div&gt;{data}&lt;/div&gt;;\n};\n</code></pre> <p>In this example, <code>data</code> is drilled down from <code>Parent</code> through <code>Intermediate</code> to <code>DeepChild</code>.</p>"},{"location":"frontend/react/example/prop-drilling/#how-to-avoid-prop-drilling","title":"How to Avoid Prop Drilling","text":"<p>There are several strategies to avoid prop drilling, making your component tree cleaner and more maintainable:</p>"},{"location":"frontend/react/example/prop-drilling/#1-react-context-api","title":"1. React Context API:","text":"<p>React Context allows you to share values and functions across the component tree without passing props explicitly through every level.</p> jsx<pre><code>// Create a Context\nconst DataContext = createContext();\n\n// Provider Component\nconst DataProvider = ({ children }) =&gt; {\n  const [data, setData] = useState('Hello');\n\n  return (\n    &lt;DataContext.Provider value={{ data, setData }}&gt;\n      {children}\n    &lt;/DataContext.Provider&gt;\n  );\n};\n\n// Deep Component\nconst DeepChild = () =&gt; {\n  const { data } = useContext(DataContext);\n  return &lt;div&gt;{data}&lt;/div&gt;;\n};\n\n// Usage\nconst App = () =&gt; (\n  &lt;DataProvider&gt;\n    &lt;DeepChild /&gt;\n  &lt;/DataProvider&gt;\n);\n\nexport default App;\n</code></pre>"},{"location":"frontend/react/example/prop-drilling/#2-custom-hooks","title":"2. Custom Hooks:","text":"<p>Use custom hooks to encapsulate and share logic across components.</p> <pre><code>// useData.js\nimport { useState } from 'react';\n\nexport const useData = () =&gt; {\n  const [data, setData] = useState('Hello');\n  return { data, setData };\n};\n\n// Deep Component\nconst DeepChild = () =&gt; {\n  const { data } = useData();\n  return &lt;div&gt;{data}&lt;/div&gt;;\n};\n\n// Usage\nconst App = () =&gt; (\n  &lt;div&gt;\n    &lt;DeepChild /&gt;\n  &lt;/div&gt;\n);\n\nexport default App;\n</code></pre>"},{"location":"frontend/react/example/prop-drilling/#3-state-management-libraries","title":"3. State Management Libraries:","text":"<p>Use state management libraries like Redux, Zustand, or Recoil to manage and access state globally.</p> Redux<pre><code>// actions.js\nexport const setData = (data) =&gt; ({\n  type: 'SET_DATA',\n  payload: data,\n});\n\n// reducer.js\nconst initialState = { data: 'Hello' };\n\nexport const dataReducer = (state = initialState, action) =&gt; {\n  switch (action.type) {\n    case 'SET_DATA':\n      return { ...state, data: action.payload };\n    default:\n      return state;\n  }\n};\n\n// Deep Component\nimport { useSelector } from 'react-redux';\n\nconst DeepChild = () =&gt; {\n  const data = useSelector((state) =&gt; state.data);\n  return &lt;div&gt;{data}&lt;/div&gt;;\n};\n\n// Usage\nimport { Provider } from 'react-redux';\nimport { createStore } from 'redux';\nimport { dataReducer } from './reducer';\n\nconst store = createStore(dataReducer);\n\nconst App = () =&gt; (\n  &lt;Provider store={store}&gt;\n    &lt;DeepChild /&gt;\n  &lt;/Provider&gt;\n);\n\nexport default App;\n</code></pre>"},{"location":"frontend/react/example/prop-drilling/#4-composition","title":"4. Composition:","text":"<p>Sometimes, restructuring components to use composition rather than hierarchical prop drilling can simplify the design.</p> <pre><code>// DataProvider Component\nconst DataProvider = ({ children }) =&gt; {\n  const [data, setData] = useState('Hello');\n  return React.cloneElement(children, { data, setData });\n};\n\n// Deep Component\nconst DeepChild = ({ data }) =&gt; {\n  return &lt;div&gt;{data}&lt;/div&gt;;\n};\n\n// Usage\nconst App = () =&gt; (\n  &lt;DataProvider&gt;\n    &lt;DeepChild /&gt;\n  &lt;/DataProvider&gt;\n);\n\nexport default App;\n</code></pre>"},{"location":"frontend/react/example/prop-drilling/#summary","title":"Summary","text":"<p>While prop drilling is a common pattern in React, it can be managed more effectively by leveraging Context API, custom hooks, state management libraries, and component composition. These strategies help maintain a clean and manageable component tree, avoiding the pitfalls of deep prop drilling.</p>"},{"location":"frontend/react/example/render-props/","title":"Render Props","text":"<p>Render props is a pattern for sharing code between React components using a prop whose value is a function.</p> Example jsx<pre><code>// FormContainer.js\nconst FormContainer = ({ children }) =&gt; {\n    const [form] = Form.useForm();\n\n    const handleSubmit = (values) =&gt; {\n        console.log('Form submitted:', values);\n    };\n\n    return children({ form, handleSubmit });\n};\n\n// UserForm.js\nconst UserForm = ({ form, handleSubmit }) =&gt; (\n    &lt;Form form={form} layout=\"vertical\" onFinish={handleSubmit}&gt;\n        &lt;Form.Item name=\"name\" label=\"Name\" rules={[{ required: true }]}&gt;\n            &lt;Input /&gt;\n        &lt;/Form.Item&gt;\n        &lt;Form.Item name=\"email\" label=\"Email\" rules={[{ required: true, type: 'email' }]}&gt;\n            &lt;Input /&gt;\n        &lt;/Form.Item&gt;\n        &lt;Button type=\"primary\" htmlType=\"submit\"&gt;Submit&lt;/Button&gt;\n    &lt;/Form&gt;\n);\n\n// Usage in a component\n&lt;FormContainer&gt;\n    {({ form, handleSubmit }) =&gt; (\n        &lt;UserForm form={form} handleSubmit={handleSubmit} /&gt;\n    )}\n&lt;/FormContainer&gt;\n</code></pre> <p>Render props is a pattern in React that allows sharing code between components using a prop whose value is a function. It\u2019s commonly used to provide data and behavior to a component in a way that is flexible and reusable. While \"render props\" is the most widely recognized term, there are a few other names and related concepts that describe similar patterns:</p>"},{"location":"frontend/react/example/render-props/#other-names-and-related-concepts","title":"Other Names and Related Concepts","text":""},{"location":"frontend/react/example/render-props/#1-function-as-child-component-facc","title":"1. Function as Child Component (FaCC):","text":"<p>This term describes a pattern where a function is used as a child of a component. It\u2019s conceptually similar to render props, but with the function passed as a child rather than a prop.</p> Example<pre><code>const UserProfile = ({ children }) =&gt; {\nconst user = { name: 'John Doe', email: 'john.doe@example.com' };\nreturn children(user);\n};\n\nconst App = () =&gt; (\n&lt;UserProfile&gt;\n    {user =&gt; (\n    &lt;div&gt;\n        &lt;h1&gt;{user.name}&lt;/h1&gt;\n        &lt;p&gt;{user.email}&lt;/p&gt;\n    &lt;/div&gt;\n    )}\n&lt;/UserProfile&gt;\n);\n</code></pre>"},{"location":"frontend/react/example/render-props/#2-controlled-components","title":"2. Controlled Components:","text":"<p>Controlled components use props to control their behavior and render output. While this term is often associated with form elements, it can also apply to the render props pattern where a component is controlled via functions.</p>"},{"location":"frontend/react/example/render-props/#3-function-render-pattern","title":"3. Function Render Pattern:","text":"<p>This term is used interchangeably with render props to describe the pattern of using a function to determine what should be rendered.</p>"},{"location":"frontend/react/example/render-props/#4-function-as-children-pattern","title":"4. Function-as-Children Pattern:","text":"<p>Similar to function as child components, this pattern involves passing a function as a child to render UI based on some state or logic.</p> <pre><code>const DataProvider = ({ children }) =&gt; {\n  const data = ['Item 1', 'Item 2', 'Item 3'];\n  return children(data);\n};\n\nconst App = () =&gt; (\n  &lt;DataProvider&gt;\n    {data =&gt; (\n      &lt;ul&gt;\n        {data.map((item, index) =&gt; (\n          &lt;li key={index}&gt;{item}&lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n    )}\n  &lt;/DataProvider&gt;\n);\n</code></pre>"},{"location":"frontend/react/example/render-props/#5-render-function-pattern","title":"5. Render Function Pattern:","text":"<p>This term emphasizes the use of a function to handle the rendering logic within a component. It is another way to refer to the render props pattern.</p>"},{"location":"frontend/react/example/render-props/#summary","title":"Summary","text":"<p>The render props pattern is known by various names and is conceptually related to several other patterns that involve passing functions to control rendering and behavior. These patterns provide flexibility and reusability in React component design.</p>"},{"location":"frontend/react/package/intro/","title":"Introduction","text":"<p>JavaScript utility libraries commonly used in React development.</p> <ul> <li> <p><code>lodash</code>:</p> <p><code>Lodash</code> is a widely used utility library in the JavaScript ecosystem, and it provides a comprehensive set of functions for working with arrays, objects, strings, and more.</p> <pre><code> // 1. Installation\n npm install lodash\n\n // 2. Importing\n import _ from 'lodash'; // Import the entire library\n // or\n import { map, filter, debounce } from 'lodash'; // Import specific functions\n\n // Example Debounce\n import _ from 'lodash';\n\n const debouncedFunction = _.debounce((value) =&gt; {\n     console.log('Debounced:', value);\n }, 300);\n</code></pre> </li> <li> <p>Underscore.js:</p> <p><code>Underscore.js</code> is similar to Lodash and provides a set of utility functions for working with arrays, objects, functions, and more. It predates Lodash and served as an inspiration for it.</p> </li> <li> <p>axios:</p> <p><code>axios</code> is a promise-based HTTP client that simplifies making HTTP requests. It is commonly used for handling API requests in React applications.</p> </li> <li> <p>React Query:</p> <p><code>React Query</code> is a library for managing, caching, and synchronizing data in React applications. It provides hooks for fetching and updating data with a focus on simplicity and performance.</p> </li> <li> <p>Ramda:</p> <p><code>Ramda</code> is a functional programming library that focuses on immutability and functional composition. It provides functions for functional programming paradigms and is suitable for projects that adopt a more functional style.</p> </li> <li> <p>Immer:</p> <p><code>Immer</code> is a library that simplifies state management by enabling a more convenient way to work with immutable data structures. It is often used in combination with React's state to make state updates more concise.</p> </li> </ul> Useful"},{"location":"frontend/react/package/intro/#useful-react-libraries","title":"Useful React Libraries","text":""},{"location":"frontend/react/package/intro/#1-react-konva","title":"1. React-Konva","text":""},{"location":"frontend/react/package/intro/#2-react-gesture-handler","title":"2. React-Gesture-Handler","text":""},{"location":"frontend/react/package/intro/#3-react-flip-move","title":"3. React-Flip-Move","text":""},{"location":"frontend/react/package/intro/#4-react-virtualized","title":"4. React-Virtualized","text":""},{"location":"frontend/react/package/intro/#5-react-toastify","title":"5. React-Toastify","text":""},{"location":"frontend/react/package/intro/#6-react-page-transition","title":"6. React-Page-Transition","text":""},{"location":"frontend/react/package/intro/#7-react-360","title":"7. React 360","text":"<ul> <li>Javascript Mastery</li> </ul>"},{"location":"frontend/react/package/antd/","title":"Intro","text":""},{"location":"frontend/react/package/antd/#and","title":"and","text":"<pre><code>$ pnpm add antd\n$ pnpm add @ant-design/icons\n</code></pre>"},{"location":"frontend/react/package/antd/antd-form-validator/","title":"Antd Form Validation","text":""},{"location":"frontend/react/package/antd/antd-form-validator/#antd-form-validation","title":"Antd Form Validation","text":"<p><code>Components/modals/quickAddPerson.js</code></p> BasicAdvanced <pre><code>const validateEmail = (_, value) =&gt; {\n    // Basic email validation using a regular expression\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n\n    if (!value || emailRegex.test(value)) {\n        return Promise.resolve();\n    }\n\n    return Promise.reject(\"Invalid email address\");\n};\n\n&lt;Form.Item\n    name=\"email\"\n    label=\"Email\"\n    rules={[\n        {\n            required: true,\n            message: \"Please enter your email\",\n        },\n        {\n            validator: validateEmail,\n        },\n    ]}\n&gt;\n    &lt;Input placeholder=\"Email\" /&gt;\n&lt;/Form.Item&gt;\n</code></pre>"},{"location":"frontend/react/package/antd/antd-form/","title":"Antd Form","text":"<p>Ant Design provides the <code>form.getFieldValue</code> and <code>form.setFieldsValue</code> methods to get and set form field values, respectively</p> jsx<pre><code>const [form] = Form.useForm();\n\nconst otherFieldValue = form.getFieldValue(\"otherField\");\n\nform.setFieldsValue({\n    currentField: /* New value based on custom logic */,\n});\n\nuseEffect(() =&gt; {\n    // Set default values based on external data\n    form.setFieldsValue({\n      username: externalData.username,\n      email: externalData.email,\n    });\n}, [externalData, form]);\n</code></pre>"},{"location":"frontend/react/package/antd/controlled-components/","title":"Controlled Component","text":""},{"location":"frontend/react/package/antd/controlled-components/#controlled-components-with-form-component","title":"Controlled Components with Form Component:","text":"<p>Ant Design provides a <code>Form</code> component that simplifies form handling. You can use controlled components and the <code>Form</code> component together to manage form state and validation easily.</p> jsx<pre><code>import { Form, Input, Button } from \"antd\";\nimport { useState } from \"react\";\n\nfunction MyForm() {\n  const [form] = Form.useForm();\n  const [formData, setFormData] = useState({});\n\n  const onFinish = (values) =&gt; {\n    console.log(\"Form submitted:\", values);\n    // Perform further actions with form data\n  };\n\n  return (\n    &lt;Form form={form} onFinish={onFinish}&gt;\n      &lt;Form.Item name=\"username\" label=\"Username\"&gt;\n        &lt;Input /&gt;\n      &lt;/Form.Item&gt;\n      &lt;Form.Item name=\"password\" label=\"Password\"&gt;\n        &lt;Input.Password /&gt;\n      &lt;/Form.Item&gt;\n      &lt;Form.Item&gt;\n        &lt;Button type=\"primary\" htmlType=\"submit\"&gt;\n          Submit\n        &lt;/Button&gt;\n      &lt;/Form.Item&gt;\n    &lt;/Form&gt;\n  );\n}\n</code></pre>"},{"location":"frontend/react/package/antd/topic/","title":"Topic","text":"<p>Mastering Ant Design (antd) and reaching a \"god tier\" level involves a combination of understanding the core concepts, practicing extensively, and keeping up with best practices. Here\u2019s a structured approach to get you there:</p> <ol> <li> <p>Understand the Basics</p> <ul> <li>Documentation: Start with the official Ant Design documentation. Familiarize yourself with the core components, layout system, and design principles.</li> <li>Components: Learn how to use basic components like Buttons, Forms, Tables, and Modals. Practice integrating these into a simple project.</li> </ul> </li> <li> <p>Dive Deeper</p> <ul> <li>Advanced Components: Explore more advanced components like DatePicker, Tree, and Cascader. Understand their props, events, and how they interact with other components.</li> <li>Customization: Learn how to customize Ant Design components. Understand theming and how to override default styles using Less or CSS-in-JS.</li> <li>Form Handling: Master the use of Form components for creating and validating forms, handling dynamic fields, and managing complex form layouts.</li> </ul> </li> <li> <p>Build Projects</p> <ul> <li>Small Projects: Start with small projects or components to practice what you\u2019ve learned. For example, build a dashboard using Ant Design\u2019s layout and table components.</li> <li>Complex Applications: Gradually work on more complex applications. Incorporate routing, state management (using libraries like <code>Redux</code> or <code>Zustand</code>), and API interactions.</li> </ul> </li> <li> <p>Optimize Performance</p> <ul> <li>Lazy Loading: Implement code splitting and lazy loading to optimize the performance of your application.</li> <li>Virtualization: Use techniques like windowing for rendering large lists efficiently. Libraries like <code>react-window</code> or <code>react-virtualized</code> can help.</li> </ul> </li> <li> <p>Keep Up with Updates</p> <ul> <li>Changelog: Regularly check Ant Design\u2019s changelog for updates and new features.</li> <li>Community: Engage with the community on forums, GitHub discussions, and social media to learn about best practices and emerging trends.</li> </ul> </li> <li> <p>Contribute and Collaborate</p> <ul> <li>Open Source Contribution: Contribute to the Ant Design library or its ecosystem. It\u2019s a great way to understand the internals and get feedback from other developers.</li> <li>Collaborate: Work on collaborative projects or contribute to open-source projects that use Ant Design.</li> </ul> </li> <li> <p>Best Practices</p> <ul> <li>Consistency: Maintain consistency in your UI design by following Ant Design\u2019s guidelines and patterns.</li> <li>Accessibility: Ensure your applications are accessible. Use tools and practices to make sure your UI is usable by everyone.</li> </ul> </li> <li> <p>Deepen Your Knowledge</p> <ul> <li>Source Code: Explore the source code of Ant Design to understand its inner workings.</li> <li>Performance Tuning: Learn advanced techniques for optimizing React applications, such as memoization, shouldComponentUpdate, and PureComponent.</li> </ul> </li> <li> <p>Teach and Share</p> <ul> <li>Write Articles: Share your knowledge by writing blog posts or creating tutorials.</li> <li>Talks and Workshops: Host talks or workshops to teach others and refine your understanding through teaching.</li> </ul> </li> <li> <p>Stay Curious and Experiment</p> <ul> <li>Experiment: Don\u2019t be afraid to experiment with new features or create custom components.</li> <li>Feedback Loop: Continuously seek feedback on your work and strive for improvement.</li> </ul> </li> </ol> <p>By following these steps, you\u2019ll not only master Ant Design but also become adept at creating high-quality, scalable, and maintainable user interfaces.</p>"},{"location":"frontend/react/package/fetching/axios/","title":"Axios","text":""},{"location":"frontend/react/package/fetching/axios/#axios","title":"axios","text":""},{"location":"frontend/react/package/fetching/intro/","title":"Intro","text":""},{"location":"frontend/react/package/fetching/intro/#intro","title":"Intro","text":"<p>Here's a list of popular React fetching libraries along with brief descriptions and example usage for each:</p>"},{"location":"frontend/react/package/fetching/intro/#1-fetch-api","title":"1. Fetch API","text":"<p>The native way to make HTTP requests in JavaScript.</p> <pre><code>useEffect(() =&gt; {\n  fetch('https://api.example.com/data')\n    .then(response =&gt; response.json())\n    .then(data =&gt; console.log(data))\n    .catch(error =&gt; console.error('Error:', error));\n}, []);\n</code></pre>"},{"location":"frontend/react/package/fetching/intro/#2-axios","title":"2. Axios","text":"<p>A promise-based HTTP client for the browser and Node.js.</p> <pre><code>import axios from 'axios';\n\nuseEffect(() =&gt; {\n  axios.get('https://api.example.com/data')\n    .then(response =&gt; console.log(response.data))\n    .catch(error =&gt; console.error('Error:', error));\n}, []);\n</code></pre>"},{"location":"frontend/react/package/fetching/intro/#3-superagent","title":"3. SuperAgent","text":"<p>A small, progressive HTTP request library.</p> <pre><code>import superagent from 'superagent';\n\nuseEffect(() =&gt; {\n  superagent.get('https://api.example.com/data')\n    .then(response =&gt; console.log(response.body))\n    .catch(error =&gt; console.error('Error:', error));\n}, []);\n</code></pre>"},{"location":"frontend/react/package/fetching/intro/#4-swr","title":"4. SWR","text":"<p>A React Hooks library for remote data fetching developed by Vercel.</p> <pre><code>import useSWR from 'swr';\n\nconst fetcher = url =&gt; fetch(url).then(res =&gt; res.json());\n\nfunction Component() {\n  const { data, error } = useSWR('https://api.example.com/data', fetcher);\n\n  if (error) return &lt;div&gt;Error loading data&lt;/div&gt;;\n  if (!data) return &lt;div&gt;Loading...&lt;/div&gt;;\n\n  return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n</code></pre>"},{"location":"frontend/react/package/fetching/intro/#5-react-query","title":"5. React Query","text":"<p>A powerful data-fetching and state management library for React.</p> <pre><code>import { useQuery } from 'react-query';\n\nconst fetcher = async () =&gt; {\n  const response = await fetch('https://api.example.com/data');\n  return response.json();\n};\n\nfunction Component() {\n  const { data, error, isLoading } = useQuery('dataKey', fetcher);\n\n  if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;\n  if (error) return &lt;div&gt;Error loading data&lt;/div&gt;;\n\n  return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n</code></pre>"},{"location":"frontend/react/package/fetching/intro/#6-apollo-client","title":"6. Apollo Client","text":"<p>A comprehensive solution for managing GraphQL data.</p> <pre><code>import { useQuery, gql } from '@apollo/client';\n\nconst GET_DATA = gql`\n  query GetData {\n    data {\n      id\n      name\n    }\n  }\n`;\n\nfunction Component() {\n  const { data, loading, error } = useQuery(GET_DATA);\n\n  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n  if (error) return &lt;div&gt;Error loading data&lt;/div&gt;;\n\n  return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n</code></pre>"},{"location":"frontend/react/package/fetching/intro/#7-relay","title":"7. Relay","text":"<p>A JavaScript framework for building data-driven React applications using GraphQL.</p> <pre><code>import {\n  RelayEnvironmentProvider,\n  loadQuery,\n  usePreloadedQuery,\n  graphql,\n} from 'react-relay/hooks';\nimport RelayEnvironment from './RelayEnvironment';\n\nconst { PreloadedQuery, PreloadableQuery } = loadQuery(\n  RelayEnvironment,\n  graphql`\n    query AppQuery {\n      viewer {\n        name\n      }\n    }\n  `\n);\n\nfunction Component(props) {\n  const data = usePreloadedQuery(PreloadableQuery, props.preloadedQuery);\n  return &lt;div&gt;{data.viewer.name}&lt;/div&gt;;\n}\n\nfunction App() {\n  return (\n    &lt;RelayEnvironmentProvider environment={RelayEnvironment}&gt;\n      &lt;Component preloadedQuery={PreloadedQuery} /&gt;\n    &lt;/RelayEnvironmentProvider&gt;\n  );\n}\n</code></pre>"},{"location":"frontend/react/package/fetching/intro/#8-urql","title":"8. Urql","text":"<p>A highly customizable and versatile GraphQL client for React.</p> <pre><code>import { createClient, Provider, useQuery } from 'urql';\n\nconst client = createClient({\n  url: 'https://api.example.com/graphql',\n});\n\nconst GET_DATA = `\n  query {\n    data {\n      id\n      name\n    }\n  }\n`;\n\nfunction Component() {\n  const [result] = useQuery({ query: GET_DATA });\n  const { data, fetching, error } = result;\n\n  if (fetching) return &lt;div&gt;Loading...&lt;/div&gt;;\n  if (error) return &lt;div&gt;Error loading data&lt;/div&gt;;\n\n  return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n\nfunction App() {\n  return (\n    &lt;Provider value={client}&gt;\n      &lt;Component /&gt;\n    &lt;/Provider&gt;\n  );\n}\n</code></pre> <p>These libraries cover a range of use cases from basic HTTP requests to advanced GraphQL queries, allowing you to choose the one that best fits your project's needs.</p> Tips <ol> <li> <p>JavaScript Fundamentals</p> <ul> <li>Promises and Async/Await: Understanding how promises work and how to use async/await syntax for handling asynchronous code is crucial.</li> <li>Error Handling: Knowing how to handle errors properly in asynchronous code.</li> </ul> </li> <li> <p>Data Fetching</p> <ul> <li>Fetch API: Basic understanding of the native Fetch API as a starting point.</li> <li>Axios: Learning how to use Axios for more advanced use cases.</li> </ul> </li> <li> <p>Error Handling</p> <ul> <li>Properly handle errors in data fetching.</li> <li>Display appropriate error messages to users.</li> </ul> </li> </ol>"},{"location":"frontend/react/package/fetching/intro/#setup-and-installation","title":"Setup and Installation:","text":"<ol> <li> <p>Practical Steps to Get Started</p> <ul> <li>Install the chosen library using npm or yarn.</li> </ul> <pre><code>npm install axios\nnpm install swr\nnpm install @apollo/client graphql\nnpm install react-query\n</code></pre> </li> <li> <p>Basic Fetching:</p> <ul> <li>Write a simple data-fetching component.</li> </ul> <pre><code>import axios from 'axios';\nimport { useEffect, useState } from 'react';\n\nfunction DataFetchingComponent() {\nconst [data, setData] = useState(null);\n\nuseEffect(() =&gt; {\n    axios.get('https://api.example.com/data')\n    .then(response =&gt; setData(response.data))\n    .catch(error =&gt; console.error(error));\n}, []);\n\nif (!data) return &lt;div&gt;Loading...&lt;/div&gt;;\n\nreturn &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n</code></pre> </li> <li> <p>Error Handling:</p> <ul> <li>Implement proper error handling.</li> </ul> <pre><code>useEffect(() =&gt; {\naxios.get('https://api.example.com/data')\n    .then(response =&gt; setData(response.data))\n    .catch(error =&gt; {\n    console.error(error);\n    setError('Failed to fetch data');\n    });\n}, []);\n</code></pre> </li> <li> <p>Using Hooks:</p> <ul> <li>For libraries like SWR or React Query, understand and use their custom hooks.</li> </ul> <pre><code>import useSWR from 'swr';\nconst fetcher = url =&gt; fetch(url).then(res =&gt; res.json());\n\nfunction DataFetchingComponent() {\nconst { data, error } = useSWR('https://api.example.com/data', fetcher);\n\nif (error) return &lt;div&gt;Error loading data&lt;/div&gt;;\nif (!data) return &lt;div&gt;Loading...&lt;/div&gt;;\n\nreturn &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n</code></pre> </li> <li> <p>Advanced Usage:</p> <ul> <li>Explore more advanced features such as pagination, caching, and optimistic updates provided by libraries like React Query and SWR.</li> </ul> </li> </ol> <p>By understanding these core concepts and gradually building upon them, you will be well-prepared to effectively use any data-fetching library in React.</p> <p>In JavaScript, there are several traditional ways to fetch API data, including:</p>"},{"location":"frontend/react/package/fetching/intro/#traditional-methods-in-javascript","title":"Traditional Methods in JavaScript:","text":"<ol> <li> <p>XMLHttpRequest:</p> <pre><code>var xhr = new XMLHttpRequest();\nxhr.open('GET', 'https://api.example.com/data', true);\nxhr.onload = function () {\n    if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) {\n        console.log(JSON.parse(xhr.responseText));\n    } else {\n        console.error('Request failed');\n    }\n};\nxhr.send();\n</code></pre> </li> <li> <p>Fetch API:</p> <pre><code>fetch('https://api.example.com/data')\n.then(response =&gt; response.json())\n.then(data =&gt; console.log(data))\n.catch(error =&gt; console.error('Error:', error));\n</code></pre> </li> <li> <p>Async/Await with Fetch API:</p> <pre><code>async function fetchData() {\n    try {\n        const response = await fetch('https://api.example.com/data');\n        const data = await response.json();\n        console.log(data);\n    } catch (error) {\n        console.error('Error:', error);\n    }\n}\nfetchData();\n</code></pre> </li> </ol>"},{"location":"frontend/react/package/fetching/intro/#packages-in-react-to-fetch-api-data","title":"Packages in React to Fetch API Data:","text":"<ol> <li> <p>Axios:</p> <pre><code>import axios from 'axios';\n\naxios.get('https://api.example.com/data')\n    .then(response =&gt; console.log(response.data))\n    .catch(error =&gt; console.error('Error:', error));\n</code></pre> <p>Using Axios with async/await:</p> <pre><code>import axios from 'axios';\n\nasync function fetchData() {\n    try {\n        const response = await axios.get('https://api.example.com/data');\n        console.log(response.data);\n    } catch (error) {\n        console.error('Error:', error);\n    }\n}\nfetchData();\n</code></pre> </li> <li> <p>React Query:</p> <pre><code>import { useQuery } from 'react-query';\n\nfunction MyComponent() {\n    const { isLoading, error, data } = useQuery('fetchData', () =&gt;\n        fetch('https://api.example.com/data').then(res =&gt; res.json())\n    );\n\n    if (isLoading) return 'Loading...';\n    if (error) return 'An error has occurred: ' + error.message;\n\n    return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n</code></pre> </li> <li> <p>SWR (stale-while-revalidate):</p> <pre><code>import useSWR from 'swr';\n\nconst fetcher = url =&gt; fetch(url).then(res =&gt; res.json());\n\nfunction MyComponent() {\n    const { data, error } = useSWR('https://api.example.com/data', fetcher);\n\n    if (error) return &lt;div&gt;Failed to load&lt;/div&gt;;\n    if (!data) return &lt;div&gt;Loading...&lt;/div&gt;;\n\n    return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n</code></pre> </li> <li> <p>useEffect with Fetch API:</p> <pre><code>import { useEffect, useState } from 'react';\n\nfunction MyComponent() {\n    const [data, setData] = useState(null);\n    const [isLoading, setIsLoading] = useState(true);\n    const [error, setError] = useState(null);\n\n    useEffect(() =&gt; {\n        fetch('https://api.example.com/data')\n            .then(response =&gt; response.json())\n            .then(data =&gt; {\n                setData(data);\n                setIsLoading(false);\n            })\n            .catch(error =&gt; {\n                setError(error);\n                setIsLoading(false);\n            });\n    }, []);\n\n    if (isLoading) return 'Loading...';\n    if (error) return 'An error has occurred: ' + error.message;\n\n    return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n</code></pre> </li> </ol> <p>These methods and packages cover a range of use cases and preferences for fetching API data in JavaScript and React applications.</p>"},{"location":"frontend/react/package/lodash/debounce/","title":"debounce","text":"<p><code>npm install lodash</code></p> jsx<pre><code>import React, { useState, useEffect } from \"react\";\nimport { Select } from \"antd\";\nimport debounce from \"lodash/debounce\";\n\nconst { Option } = Select;\n\nconst DebouncedSelect = () =&gt; {\n  const [searchTerm, setSearchTerm] = useState(\"\");\n\n  const debouncedSearch = debounce((value) =&gt; {\n    // Your search logic here, e.g., making an API call\n    console.log(\"Searching for:\", value);\n  }, 300); // 300ms debounce delay\n\n  useEffect(() =&gt; {\n    debouncedSearch(searchTerm);\n  }, [searchTerm, debouncedSearch]);\n\n  const handleSearch = (value) =&gt; {\n    setSearchTerm(value);\n  };\n\n  return (\n    &lt;Select\n      showSearch\n      onSearch={handleSearch}\n      style={{ width: 200 }}\n      placeholder=\"Search...\"\n    &gt;\n      &lt;Option value=\"1\"&gt;Option 1&lt;/Option&gt;\n      &lt;Option value=\"2\"&gt;Option 2&lt;/Option&gt;\n      &lt;Option value=\"3\"&gt;Option 3&lt;/Option&gt;\n    &lt;/Select&gt;\n  );\n};\n\nexport default DebouncedSelect;\n</code></pre>"},{"location":"frontend/react/package/lodash/debounce/#debounce-with-hoc","title":"Debounce with Hoc","text":"<p>separate the debounce logic and the HOC into separate files for better organization</p> 1. Debounce utility file2. HOC file3. Component file debounce.js<pre><code>// debounce.js\nconst debounce = (func, delay) =&gt; {\n    let timeoutId;\n    return function (...args) {\n        clearTimeout(timeoutId);\n        timeoutId = setTimeout(() =&gt; func.apply(this, args), delay);\n    };\n};\n\nexport default debounce;\n</code></pre> withDebounce.js<pre><code>import React from 'react';\nimport debounce from './debounce';\n\nconst withDebounce = (WrappedComponent) =&gt; {\n    return class WithDebounce extends React.Component {\n        debouncedFunction = debounce((...args) =&gt; {\n            console.log('Debounced function called with args:', args);\n        }, 500); // 500ms debounce delay\n\n        render() {\n            return (\n                &lt;WrappedComponent\n                    {...this.props}\n                    onDebouncedAction={this.debouncedFunction}\n                /&gt;\n            );\n        }\n    };\n};\n\nexport default withDebounce;\n</code></pre> MyComponent.js<pre><code>import React from 'react';\nimport withDebounce from './withDebounce';\n\nconst MyComponent = ({ onDebouncedAction }) =&gt; {\n    const handleClick = () =&gt; {\n        onDebouncedAction('Click event');\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;button onClick={handleClick}&gt;Click me&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default withDebounce(MyComponent);\n</code></pre> <p>Now you can import and use the <code>MyComponent</code> in your main application file:</p> App.js<pre><code>import React from \"react\";\nimport MyComponent from \"./MyComponent\";\n\nconst App = () =&gt; {\n  return (\n    &lt;div&gt;\n      &lt;MyComponent /&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n</code></pre> <p>This structure helps maintain a clean separation of concerns, making each file focused on its specific responsibility. The debounce utility is isolated in its own file, and the HOC is defined separately, promoting code modularity and reusability.</p>"},{"location":"frontend/react/package/tinymce/tinymce/","title":"Intro","text":"<p>TinyMCE is a popular WYSIWYG editor that can be integrated into React applications. To add a template inside the TinyMCE editor in a React project, you can follow these general steps:</p> <ol> <li> <p>Install TinyMCE:     If you haven't already, install the TinyMCE editor in your React project using a package manager like npm or yarn. Here's an example using npm:</p> <pre><code>npm install tinymce\n</code></pre> </li> <li> <p>Import TinyMCE in your React component:     Import TinyMCE in the React component where you want to use the editor.</p> <pre><code>import { Editor } from \"@tinymce/tinymce-react\";\n</code></pre> </li> <li> <p>Configure TinyMCE:     Set up the TinyMCE configuration in your component. This is where you can define the template and other settings.</p> <pre><code>const TinyMCEEditor = () =&gt; {\n  const handleEditorChange = (content, editor) =&gt; {\n    // Handle content changes here\n    console.log(\"Content:\", content);\n  };\n\n  const templateContent = `\n    &lt;p&gt;This is a template content&lt;/p&gt;\n`;\n\n  return (\n    &lt;Editor\n      apiKey=\"YOUR_API_KEY\" // You can obtain an API key by creating a TinyMCE account\n      initialValue={templateContent}\n      init={{\n        height: 500,\n        menubar: false,\n        plugins: [\n          \"advlist autolink lists link image charmap print preview anchor\",\n          \"searchreplace visualblocks code fullscreen\",\n          \"insertdatetime media table paste code help wordcount\",\n        ],\n        toolbar:\n          \"undo redo | formatselect | bold italic backcolor | \\\n        alignleft aligncenter alignright alignjustify | \\\n        bullist numlist outdent indent | removeformat | help\",\n        content_style:\n          \"body { font-family:Helvetica,Arial,sans-serif; font-size:14px }\",\n      }}\n      onChange={handleEditorChange}\n    /&gt;\n  );\n};\n\nexport default TinyMCEEditor;\n</code></pre> <p>In the above example, templateContent is the initial content of the editor, and you can customize the init object to include the desired plugins, toolbar buttons, and other configurations.</p> </li> <li> <p>Handle Template Insertion:</p> <p>You can provide a button or some other user interaction to insert the template content into the editor. For example, you can add a button that, when clicked, inserts the template content at the current cursor position.</p> <pre><code>const insertTemplate = () =&gt; {\n  const editor = tinymce.activeEditor;\n  if (editor) {\n    editor.insertContent(templateContent);\n  }\n};\n\n// ...\n\n&lt;button onClick={insertTemplate}&gt;Insert Template&lt;/button&gt;;\n</code></pre> <p>Make sure to adapt the code according to your specific requirements and integrate it seamlessly into your React application. Adjust the TinyMCE configuration and event handlers based on your needs.</p> </li> </ol>"},{"location":"frontend/react/report/bugs/cleanup-function/","title":"Cleanup Function","text":"<p>Cleanup functions in React are essential for managing resources and avoiding memory leaks, especially when dealing with asynchronous operations, side effects, or subscriptions. Here\u2019s a breakdown of when and how to use cleanup functions, including patterns and common practices:</p>"},{"location":"frontend/react/report/bugs/cleanup-function/#when-to-use-cleanup-functions","title":"When to Use Cleanup Functions","text":"<ol> <li> <p>Asynchronous Operations:</p> <ul> <li>Scenario: You make API calls or other asynchronous tasks in <code>useEffect</code> that might still be running when the component unmounts.</li> <li>Solution: Use a flag or an <code>AbortController</code> to cancel the request if the component unmounts.</li> </ul> </li> <li> <p>Subscriptions:</p> <ul> <li>Scenario: You subscribe to external data sources, like WebSocket connections, event listeners, or other subscriptions.</li> <li>Solution: Unsubscribe or clean up listeners when the component unmounts to prevent memory leaks.</li> </ul> </li> <li> <p>Timers:</p> <ul> <li>Scenario: You set up timers or intervals using <code>setTimeout</code> or <code>setInterval</code>.</li> <li>Solution: Clear the timers when the component unmounts to prevent unexpected behavior.</li> </ul> </li> <li> <p>Event Listeners:</p> <ul> <li>Scenario: You add event listeners to the <code>window</code>, <code>document</code>, or other elements.</li> <li>Solution: Remove these event listeners when the component unmounts to avoid memory leaks.</li> </ul> </li> </ol>"},{"location":"frontend/react/report/bugs/cleanup-function/#popular-cleanup-patterns","title":"Popular Cleanup Patterns","text":"<ol> <li> <p>Using a Mounted Flag:</p> <ul> <li> <p>Pattern: Maintain a flag that tracks whether the component is mounted and use it to conditionally perform state updates.</p> </li> <li> <p>Example:</p> <pre><code>useEffect(() =&gt; {\n    let isMounted = true;\n\n    const fetchData = async () =&gt; {\n        const result = await fetchSomeData();\n        if (isMounted) {\n            setData(result);\n        }\n    };\n\n    fetchData();\n\n    return () =&gt; {\n        isMounted = false;\n    };\n}, []);\n</code></pre> </li> </ul> </li> <li> <p>AbortController for Fetch Requests:</p> <ul> <li> <p>Pattern: Use AbortController to cancel ongoing fetch requests when the component unmounts.</p> </li> <li> <p>Example:</p> <pre><code>useEffect(() =&gt; {\n    const controller = new AbortController();\n\n    const fetchData = async () =&gt; {\n        try {\n            const response = await fetch('/data', { signal: controller.signal });\n            const data = await response.json();\n            setData(data);\n        } catch (err) {\n            if (err.name === 'AbortError') {\n                console.log('Fetch aborted');\n            }\n        }\n    };\n\n    fetchData();\n\n    return () =&gt; {\n        controller.abort();\n    };\n}, []);\n</code></pre> </li> </ul> </li> <li> <p>Cleanup for Event Listeners:</p> <ul> <li> <p>Pattern: Remove event listeners added to global objects or elements.</p> </li> <li> <p>Example:</p> <pre><code>useEffect(() =&gt; {\n    const handleResize = () =&gt; {\n        console.log('Resized');\n    };\n\n    window.addEventListener('resize', handleResize);\n\n    return () =&gt; {\n        window.removeEventListener('resize', handleResize);\n    };\n}, []);\n</code></pre> </li> </ul> </li> <li> <p>Clearing Timers:</p> <ul> <li> <p>Pattern: Clear any intervals or timeouts when the component unmounts.</p> </li> <li> <p>Example:</p> <pre><code>useEffect(() =&gt; {\n    const timer = setTimeout(() =&gt; {\n        console.log('Timer triggered');\n    }, 1000);\n\n    return () =&gt; {\n        clearTimeout(timer);\n    };\n}, []);\n</code></pre> </li> </ul> </li> </ol>"},{"location":"frontend/react/report/bugs/cleanup-function/#summary","title":"Summary","text":"<ul> <li>Asynchronous Operations: Use a mounted flag or <code>AbortController</code> to cancel ongoing tasks.</li> <li>Subscriptions: Clean up by unsubscribing or removing listeners.</li> <li>Timers: Clear <code>setTimeout</code> or <code>setInterval</code> when the component unmounts.</li> <li>Event Listeners: Remove listeners added to global objects or specific elements.</li> </ul> <p>Using these cleanup techniques helps ensure that your components are efficient and free from memory leaks, providing a better user experience and more reliable performance.</p>"},{"location":"frontend/react/report/bugs/cleanup-function/#mail-module","title":"Mail Module","text":""},{"location":"frontend/react/report/bugs/cleanup-function/#memory-leak-in-your-application","title":"memory leak in your application","text":"<p>Warning: Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in a useEffect cleanup function.</p> TheoryExample <p>\"Warning: Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application.\"</p> <p>occurs when your React component is unmounted (removed from the UI), but an asynchronous operation (like an API call, event listener, or timeout) tries to update the component\u2019s state after it\u2019s already unmounted. This can lead to a memory leak because the state update is unnecessary and React doesn\u2019t know how to handle it anymore.</p> <p>Why This Happens:</p> <p>When a component is unmounted, it no longer exists in the React tree. However, if asynchronous tasks like API requests, <code>setTimeout</code>, or event listeners are still running, they might try to update the state of the unmounted component, which React warns against.</p> <p>How to Fix It:</p> <p>The solution is to clean up any asynchronous tasks when the component unmounts using the <code>cleanup</code> function in the <code>useEffect</code> hook. This ensures that any pending operations like API calls, subscriptions, or timeouts are canceled before the component unmounts, preventing state updates on unmounted components.</p> <p>Fixing a Memory Leak in <code>useEffect</code></p> Before (Potential Problem)After (With Cleanup) <pre><code>useEffect(() =&gt; {\n    const fetchData = async () =&gt; {\n        const result = await fetchSomeData();\n        setData(result);  // This may cause a state update on an unmounted component\n    };\n\n    fetchData();\n}, []);  // No cleanup, could cause memory leaks\n</code></pre> <p>To prevent the memory leak, you should clean up the asynchronous task when the component unmounts:</p> <pre><code>useEffect(() =&gt; {\n    let isMounted = true;  // This flag will track if the component is still mounted\n\n    const fetchData = async () =&gt; {\n        const result = await fetchSomeData();\n\n        if (isMounted) {  // Only update the state if the component is still mounted\n            setData(result);\n        }\n    };\n\n    fetchData();\n\n    return () =&gt; {\n        isMounted = false;  // Clean up when the component unmounts\n    };\n}, []);  // Cleanup ensures that no updates occur if the component is unmounted\n</code></pre> How to Identify the Issue <ul> <li> <p>Look at <code>ReplyChatBox.js</code>, line 292 (based on the error message). There may be an asynchronous operation, such as an API request, event listener, or timeout, that's trying to update the component's state after it has been unmounted.</p> </li> <li> <p>Check all <code>useEffect</code> hooks in that component to ensure you're properly cleaning up any asynchronous tasks, such as:</p> <ul> <li>API calls (e.g., <code>fetch</code>)</li> <li>WebSocket connections</li> <li><code>setTimeout</code> or <code>setInterval</code></li> <li>Event listeners (<code>addEventListener</code>)</li> </ul> </li> </ul> General Steps to Fix <ul> <li>Identify the asynchronous task that is trying to update state after the component has unmounted.</li> <li>Use <code>useEffect</code> cleanup by returning a function that cancels or cleans up any ongoing async operations or event listeners.</li> <li>Use a mounted flag or <code>AbortController</code> for fetch requests to ensure that state is only updated while the component is still mounted.</li> </ul> <p>Example for Fetch Requests with AbortController:</p> <p>If you are using <code>fetch</code>, you can cancel the request using an <code>AbortController</code>:</p> <pre><code>useEffect(() =&gt; {\n  const controller = new AbortController();\n  const signal = controller.signal;\n\n  const fetchData = async () =&gt; {\n    try {\n      const result = await fetchSomeData({ signal });\n      setData(result);  // Only update if fetch is successful\n    } catch (err) {\n      if (err.name === \"AbortError\") {\n        console.log(\"Fetch aborted\");\n      }\n    }\n  };\n\n  fetchData();\n\n  return () =&gt; {\n    controller.abort();  // Clean up the fetch request when the component unmounts\n  };\n}, []);\n</code></pre> Summary <ul> <li>The warning indicates that some asynchronous task is trying to update state after the component has unmounted.</li> <li>To prevent this, clean up those tasks using <code>useEffect</code> cleanup functions.</li> <li>Be sure to use techniques like the <code>isMounted</code> flag or <code>AbortController</code> to ensure that no state updates occur on unmounted components.</li> </ul>"},{"location":"frontend/react/report/bugs/cleanup-function/#improved-code-with-cleanup","title":"Improved Code with Cleanup","text":"Bug CodeImporved CodeKey Improvements <pre><code>useEffect(() =&gt; {\n    fetchAllParticipants();\n}, []);\n\n\nconst fetchAllParticipants = async () =&gt; {\n    const resp = await getAllUsers().catch((err) =&gt; {\n        message.error(\"Failure\");\n    });\n\n    if (resp &amp;&amp; resp.status === 200) {\n        let participantFrom = storage.getItem(\"userId\");\n        let allUsers = resp.data.filter(\n            (obj) =&gt; obj.appUserId == participantFrom\n        );\n\n        setUsers(allUsers);\n    }\n};\n</code></pre> <p>Yes, there\u2019s a potential issue with the code related to asynchronous operations and component unmounting. Specifically, if <code>fetchAllParticipants</code> completes after the component has unmounted, it could attempt to call <code>setUsers</code>, which would lead to the warning you saw: \"Can't perform a React state update on an unmounted component.\"</p> <pre><code>import { useEffect, useState } from 'react';\nimport { message } from 'antd'; // Assuming you're using Ant Design for messages\nimport storage from 'some-storage-module'; // Adjust import based on your setup\nimport { getAllUsers } from 'some-api-module'; // Adjust import based on your setup\n\nconst MyComponent = () =&gt; {\n    const [users, setUsers] = useState([]);\n\n    useEffect(() =&gt; {\n        let isMounted = true; // Flag to track component mount status\n\n        const fetchAllParticipants = async () =&gt; {\n            try {\n                const resp = await getAllUsers();\n                if (isMounted &amp;&amp; resp &amp;&amp; resp.status === 200) {\n                    let participantFrom = storage.getItem(\"userId\");\n                    let allUsers = resp.data.filter(\n                        (obj) =&gt; obj.appUserId == participantFrom\n                    );\n                    setUsers(allUsers);\n                }\n            } catch (err) {\n                message.error(\"Failure\");\n            }\n        };\n\n        fetchAllParticipants();\n\n        return () =&gt; {\n            isMounted = false; // Cleanup function to update the flag on unmount\n        };\n    }, []);\n\n\n    return (\n        &lt;div&gt;\n            {/* Render your users or other components here */}\n        &lt;/div&gt;\n    );\n};\n\nexport default MyComponent;\n</code></pre> <ol> <li> <p>Mounted Flag: Added <code>let isMounted = true;</code> and updated it in the cleanup function to <code>isMounted = false;</code>. This ensures that state updates only occur if the component is still mounted.</p> </li> <li> <p>Error Handling: Moved the <code>catch</code> block into the <code>try...catch</code> statement to handle any potential errors and show a message if something goes wrong with <code>getAllUsers()</code>.</p> </li> <li> <p>Cleanup Function: Ensured that <code>isMounted</code> is set to <code>false</code> when the component unmounts, which prevents <code>setUsers</code> from being called if the component is no longer present.</p> </li> </ol> <p>Summary:</p> <p>By implementing the mounted flag, you prevent the warning about state updates on an unmounted component. This approach ensures that asynchronous operations don't attempt to update state after the component has unmounted, thereby avoiding potential memory leaks and other issues.</p>"},{"location":"frontend/react/report/bugs/debouncing/","title":"debouncing","text":""},{"location":"frontend/react/report/bugs/debouncing/#overview","title":"Overview","text":"<p>Debouncing is a technique used in programming to improve performance and efficiency, particularly in scenarios where certain actions are triggered repeatedly in a short period. Here\u2019s a breakdown of what debouncing is, why it\u2019s needed, and when to use it:</p>"},{"location":"frontend/react/report/bugs/debouncing/#what-is-debouncing","title":"What is Debouncing?","text":"<p>Debouncing is a method used to ensure that a function is only executed after a certain amount of time has passed since the last time it was invoked. In other words, it limits the rate at which a function can fire by postponing the execution until a period of inactivity has been observed.</p>"},{"location":"frontend/react/report/bugs/debouncing/#why-do-we-need-debouncing","title":"Why Do We Need Debouncing?","text":"<ol> <li> <p>Performance Improvement: Frequent triggering of functions can cause performance issues, especially if the function involves heavy computations or makes network requests. Debouncing helps to minimize these issues by consolidating multiple triggers into a single execution.</p> </li> <li> <p>User Experience: In web applications, debouncing is often used to improve user experience. For instance, it prevents a search query from being sent to the server on every keystroke, which can be annoying and inefficient.</p> </li> <li> <p>Resource Management: It helps to manage resources better by avoiding unnecessary function calls, reducing the load on both the client and server sides.</p> </li> </ol>"},{"location":"frontend/react/report/bugs/debouncing/#when-to-use-debouncing","title":"When to Use Debouncing?","text":"<ol> <li> <p>Search Inputs: When implementing search functionality with real-time suggestions, debouncing can prevent excessive querying of a backend server as users type.</p> </li> <li> <p>Window Resizing: If you have functionality that adjusts based on the window size, debouncing can help avoid multiple calls to resize handlers while the user is actively resizing the window.</p> </li> <li> <p>Scroll Events: Debouncing is useful for handling scroll events, especially if you have features that trigger actions based on scrolling.</p> </li> <li> <p>Form Validation: In forms where validation occurs as the user types, debouncing can prevent constant validation checks on every keystroke.</p> </li> </ol>"},{"location":"frontend/react/report/bugs/debouncing/#example","title":"Example","text":"<p>How to Implement Debouncing</p> <p>Here\u2019s a basic example of how to implement debouncing in JavaScript:</p> <pre><code>function debounce(func, delay) {\n    let timeoutId;\n    return function(...args) {\n        clearTimeout(timeoutId);\n        timeoutId = setTimeout(() =&gt; func.apply(this, args), delay);\n    };\n}\n\n// Usage example:\nfunction search(query) {\n    console.log('Searching for:', query);\n}\n\nconst debouncedSearch = debounce(search, 300);\n\n// Attach debouncedSearch to an input event\ndocument.getElementById('searchInput').addEventListener('input', (event) =&gt; {\n    debouncedSearch(event.target.value);\n});\n</code></pre> <p>In this example:</p> <ul> <li><code>debounce</code> is a higher-order function that takes a function <code>func</code> and a delay in milliseconds.</li> <li>It returns a new function that, when invoked, clears the previous timeout and sets a new one. If the function is invoked again within the delay period, the previous timeout is cleared and a new one is set.</li> <li><code>debouncedSearch</code> is a debounced version of the <code>search</code> function, which will only be called 300 milliseconds after the user stops typing.</li> </ul> <p>By using debouncing, you ensure that <code>search</code> is not called too frequently and is executed only after the user has paused their input.</p>"},{"location":"frontend/react/report/bugs/debouncing/#react","title":"React","text":"<p>What is Debouncing?</p> <p>Debouncing is a technique to limit how often a function is called. It makes sure that the function is only executed after a certain amount of time has passed since the last call. This is useful in scenarios where a function might be called repeatedly in a short period of time.</p> <p>When to Use Debounce in React</p> Use Debounce WhenDon\u2019t Use Debounce When <ol> <li> <p>User Input: If you have a search input field that triggers an API call or filtering every time the user types.</p> <ul> <li>Why? To avoid making an API call for every keystroke, which could overwhelm the server and slow down the app.</li> </ul> </li> <li> <p>Window Resize: If you have functionality that reacts to window resizing, like adjusting layout or reloading data.</p> <ul> <li>Why? To prevent excessive calls while the user is actively resizing the window.</li> </ul> </li> <li> <p>Scroll Events: If you\u2019re implementing infinite scrolling or tracking scroll position.</p> <ul> <li>Why? To limit how often you perform actions based on the scroll position, improving performance.</li> </ul> </li> </ol> <ol> <li> <p>Instant Feedback: If the action needs to happen immediately without delay, such as a submit button.</p> <ul> <li>Why? Debouncing would introduce a delay, which might not be suitable for actions requiring immediate response.</li> </ul> </li> <li> <p>Non-Frequent Actions: If the function is not triggered frequently or doesn\u2019t affect performance significantly.</p> <ul> <li>Why? Debouncing is unnecessary for actions that don\u2019t occur often or are already well-managed.</li> </ul> </li> </ol> <p>Simple Example with lodash</p> InstallImplementationExplanation <pre><code>npm install lodash\n</code></pre> <p>Here\u2019s a basic React component with a debounced search input:</p> <pre><code>import React, { useState, useCallback } from 'react';\nimport debounce from 'lodash/debounce';\n\nconst SearchComponent = () =&gt; {\n    const [query, setQuery] = useState('');\n    const [results, setResults] = useState([]);\n\n    // Create a debounced function for searching\n    const debouncedSearch = useCallback(\n        debounce(async (searchTerm) =&gt; {\n            if (searchTerm) {\n                try {\n                    const response = await fetch(`https://api.example.com/search?q=${searchTerm}`);\n                    const data = await response.json();\n                    setResults(data);\n                } catch (error) {\n                    console.error('Error fetching data:', error);\n                }\n            } else {\n                setResults([]);\n            }\n        }, 300), // Debounce with a 300ms delay\n        []\n    );\n\n    // Call the debounced search function whenever the query changes\n    const handleChange = (event) =&gt; {\n        const newQuery = event.target.value;\n        setQuery(newQuery);\n        debouncedSearch(newQuery);\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;input\n                type=\"text\"\n                value={query}\n                onChange={handleChange}\n                placeholder=\"Search...\"\n            /&gt;\n            &lt;ul&gt;\n                {results.map((result, index) =&gt; (\n                    &lt;li key={index}&gt;{result.name}&lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default SearchComponent;\n</code></pre> <ul> <li> <p>State Variables: <code>query</code> holds the current search input, and <code>results</code> holds the search results.</p> </li> <li> <p>Debounce Function: <code>debouncedSearch</code> is created using <code>lodash</code>'s <code>debounce</code>. It\u2019s called with a 300ms delay, meaning it waits 300ms after the last change before making an API request.</p> </li> <li> <p>Handle Input Change: When the input changes, <code>handleChange</code> updates <code>query</code> and calls the debounced function. The debounced function will only trigger the API call 300ms after the user stops typing.</p> </li> <li> <p>Display Results: The results from the API call are displayed in a list.</p> </li> </ul> Summary <ul> <li>Use Debounce: When you want to limit the frequency of function calls, especially with user input or events that can fire rapidly.</li> <li>Don\u2019t Use Debounce: When immediate action is required or the function is not called frequently enough to benefit from debouncing.</li> </ul> <p>Using lodash for debouncing simplifies this process and ensures efficient performance.</p> COdeExplanation <pre><code>import React, { useCallback, useState } from 'react';\nimport debounce from 'lodash/debounce';\nimport { useDispatch } from 'react-redux'; // or wherever your dispatch is from\n\n// Example of the component\nconst MyComponent = () =&gt; {\n    const [selectedAttendees, setSelectedAttendees] = useState([]);\n    const [hasSelectedAttentionTos, setHasSelectedAttentionTos] = useState(false);\n    const dispatch = useDispatch(); // Assuming you are using Redux for state management\n\n    // Define the debounced version of your dispatch function\n    const debouncedDispatch = useCallback(\n        debounce((selectedPersonIds, selectedCompanyId) =&gt; {\n            dispatch(getCompanyorPersonEmailAddess(selectedPersonIds, selectedCompanyId));\n        }, 300), // Adjust the debounce delay as needed (300ms here)\n        [dispatch]\n    );\n\n    // The handleSelectChange function\n    const handleSelectChange = (values, options) =&gt; {\n        const selectedData = options.map((option) =&gt; ({\n            AttentionTo: option.props.children,\n            AttentionId: option.key,\n        }));\n\n        let selectedPersonIds = selectedData.map((item) =&gt; ({\n            contactPersonIds: item.AttentionId,\n        }));\n\n        setSelectedAttendees(selectedData);\n        setHasSelectedAttentionTos(!isEmpty(values));\n\n        // Call the debounced dispatch function\n        debouncedDispatch(selectedPersonIds, selectedCompanyId);\n    };\n\n    // Your component render logic here\n    return (\n        &lt;div&gt;\n            {/* Render your component here */}\n        &lt;/div&gt;\n    );\n};\n\nexport default MyComponent;\n</code></pre> <ol> <li> <p>Install and Import <code>debounce</code>: Import <code>debounce</code> from <code>lodash</code>.</p> </li> <li> <p>Create a Debounced Dispatch Function:</p> <ul> <li>Use <code>useCallback</code> to memoize the debounced function so that it doesn't get recreated on every render.</li> <li>The <code>debouncedDispatch</code> function is created using <code>debounce</code>. It wraps the dispatch call and delays its execution until after 300 milliseconds have passed since the last call. You can adjust this delay as needed.</li> </ul> </li> <li> <p>Update <code>handleSelectChange</code>:</p> <ul> <li>Inside <code>handleSelectChange</code>, instead of calling <code>dispatch</code> directly, call debouncedDispatch with the necessary parameters.</li> <li><code>debouncedDispatch</code> will now ensure that the <code>dispatch</code> function is only called after the specified delay, which prevents it from being called too frequently if <code>handleSelectChange</code> is triggered multiple times in quick succession.</li> </ul> </li> <li> <p>Include Dependencies:</p> <p>Make sure to include <code>dispatch</code> as a dependency in <code>useCallback</code> so that the debounced function is recreated if <code>dispatch</code> changes.</p> </li> </ol> <p>This approach will help you manage performance and reduce the number of times <code>dispatch</code> is called, especially if <code>handleSelectChange</code> is triggered frequently.</p>"},{"location":"frontend/react/report/bugs/intro/","title":"Intro","text":""},{"location":"frontend/react/report/bugs/intro/#dashboard-module","title":"Dashboard Module:","text":"Warning: Invalid DOM property <code>class</code>. Did you mean <code>className</code>? Solution <p>search gloal with <code>class=\"</code> and replace with className.</p> Warning: Each child in a list should have a unique \"key\" prop. IssueSolution <p>`PublicEvents.js:183``</p> <pre><code>{data?.length &gt; 0 ? (\n    data?.map((list, i) =&gt; (\n        &lt;&gt;\n            {list.event !== \"day\" ? (\n                &lt;li\n                    key={i}\n                    className=\"dashboards__events--list\"\n                    style={{ padding: \"0px\" }}\n                &gt;&lt;/li&gt;\n            ) : null }\n        &lt;/&gt;\n    )) : null)\n}\n</code></pre> <p>use unique <code>id</code> instead of <code>index</code>.</p> <pre><code>{data?.length &gt; 0 ? (\n    data?.map((list, i) =&gt; (\n        &lt;&gt;\n            {list.event !== \"day\" ? (\n                &lt;li\n                    key={i}\n                    className=\"dashboards__events--list\"\n                    style={{ padding: \"0px\" }}\n                &gt;&lt;/li&gt;\n            ) : null }\n        &lt;/&gt;\n    )) : null)\n}\n</code></pre> Warning: Each child in a list should have a unique \"key\" prop. <pre><code>children HonorRollPagiantion.js:153\nHonorRollPagination HonorRollPagiantion.js:139\n</code></pre> IssueSolved <pre><code>HonorRollPagiantion.js\n\n&lt;div\n    className=\"honor__card--circle\"\n\n    // ISSUE HERE\n    key={i}\n&gt;\n</code></pre> <pre><code>&lt;Carousel autoplay={true} dots={false}&gt;\n    {list?.honorRollCandidateDtos?.map(\n    (picture, i) =&gt; {\n        let name = picture?.candidateName;\n        let profilePicNameFL = name\n        ?.match(/\\b(\\w)/g)\n        .join(\"\");\n\n        return (\n        &lt;&gt;\n            &lt;div\n            className=\"honor__card--circle\"\n            key={i}\n            &gt;\n            {!isEmpty(\n                picture.candiateProfilePictureURL\n            ) ? (\n                &lt;img\n                src={\n                    cqBaseUrl +\n                    \"/\" +\n                    picture.candiateProfilePictureURL +\n                    token\n                }\n                alt=\"profile\"\n                /&gt;\n            ) : (\n                &lt;div\n                className=\"default-profile-name\"\n                style={{\n                    width: \"52px\",\n                    height: \"52px\",\n                }}\n                key={i}\n                &gt;\n                {profilePicNameFL}\n                &lt;/div&gt;\n            )}\n            &lt;/div&gt;\n        &lt;/&gt;\n        )\n    })\n    }\n&lt;/Carousel&gt;\n</code></pre> <p>updated the <code>key={i}</code> to <code>key={picture?.id}</code></p> <pre><code>&lt;&gt;\n    &lt;div\n    className=\"honor__card--circle\"\n    key={picture?.id}\n    &gt;\n    {!isEmpty(\n        picture.candiateProfilePictureURL\n    ) ? (\n        &lt;img\n        src={\n            cqBaseUrl +\n            \"/\" +\n            picture.candiateProfilePictureURL +\n            token\n        }\n        alt=\"profile\"\n        /&gt;\n    ) : (\n        &lt;div\n        className=\"default-profile-name\"\n        style={{\n            width: \"52px\",\n            height: \"52px\",\n        }}\n        key={picture?.id}\n        &gt;\n        {profilePicNameFL}\n        &lt;/div&gt;\n    )}\n    &lt;/div&gt;\n&lt;/&gt;\n</code></pre>"},{"location":"frontend/react/report/bugs/intro/#mail-module","title":"Mail Module","text":"<p>Warning: Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application.</p> BugSolution ReplyChatBox.js<pre><code>// pg: 192\nuseEffect(() =&gt; {\n    fetchAllParticipants();\n}, []);\n\n// pg: 281\nconst fetchAllParticipants = async () =&gt; {\n    const resp = await getAllUsers().catch((err) =&gt; {\n        message.error(\"Failure\");\n    });\n\n    if (resp &amp;&amp; resp.status === 200) {\n        let participantFrom = storage.getItem(\"userId\");\n        let allUsers = resp.data.filter(\n            (obj) =&gt; obj.appUserId == participantFrom\n        );\n\n        setUsers(allUsers);\n    }\n};\n</code></pre> ReplyChatBox.js<pre><code>useEffect(() =&gt; {\n    // fetchAllParticipants();\n    let isMounted = true; // Flag to track component mount status\n\n    const fetchAllParticipants = async () =&gt; {\n        try {\n            const resp = await getAllUsers();\n\n            if (isMounted &amp;&amp; resp &amp;&amp; resp.status === 200) {\n                let participantFrom = storage.getItem(\"userId\");\n                let allUsers = resp.data.filter(\n                    (obj) =&gt; obj.appUserId == participantFrom\n                );\n                setUsers(allUsers);\n            }\n        } catch (err) {\n            message.error(\"Failure\");\n        }\n    };\n\n    fetchAllParticipants();\n\n    return () =&gt; {\n        isMounted = false; // Cleanup function to update the flag on unmount\n    };\n}, []);\n</code></pre>"},{"location":"frontend/react/report/bugs/master-topic/","title":"master topic","text":"<p>To fully master React and build robust, maintainable applications, you'll want to familiarize yourself with a variety of techniques, patterns, and libraries. Here\u2019s a comprehensive guide to what you should know:</p>"},{"location":"frontend/react/report/bugs/master-topic/#techniques","title":"Techniques","text":"<ol> <li> <p>Component-Based Architecture:</p> <ul> <li>Understand: How to build reusable and composable components.</li> <li>Key Concepts: Props, state, lifecycle methods, hooks.</li> </ul> </li> <li> <p>State Management:</p> <ul> <li>Local State: Use <code>useState</code> and <code>useReducer</code>.</li> <li>Global State: Understand Context API and third-party libraries like Redux or Zustand.</li> </ul> </li> <li> <p>Effect Management:</p> <ul> <li>Understand: Side effects in components using <code>useEffect</code>.</li> <li>Best Practices: Cleanup functions, dependencies.</li> </ul> </li> <li> <p>Performance Optimization:</p> <ul> <li>Techniques: Memoization with <code>useMemo</code> and <code>useCallback</code>, code splitting, lazy loading components with <code>React.lazy</code> and <code>Suspense</code>.</li> <li>Tools: React Profiler, performance monitoring tools.</li> </ul> </li> <li> <p>Form Handling:</p> <ul> <li>Understand: Controlled vs. uncontrolled components.</li> <li>Libraries: React Hook Form, Formik.</li> </ul> </li> <li> <p>Routing:</p> <ul> <li>Library: React Router.</li> <li>Concepts: Dynamic routing, nested routes, route guards.</li> </ul> </li> <li> <p>Error Handling:</p> <ul> <li>Technique: Error boundaries to catch JavaScript errors anywhere in the component tree.</li> <li>Best Practices: Display user-friendly error messages.</li> </ul> </li> <li> <p>Testing:</p> <ul> <li>Tools: Jest for unit testing, React Testing Library for component testing.</li> <li>Concepts: Mocking, snapshot testing.</li> </ul> </li> <li> <p>Styling:</p> <ul> <li>Options: CSS-in-JS libraries (styled-components, Emotion), CSS modules, and traditional CSS/Sass.</li> </ul> </li> <li> <p>Server-Side Rendering (SSR) and Static Site Generation (SSG):</p> <ul> <li>Frameworks: Next.js for SSR and SSG.</li> <li>Concepts: Benefits of SSR, SSG vs. CSR (Client-Side Rendering).</li> </ul> </li> <li> <p>Internationalization (i18n):</p> <ul> <li>Library: react-i18next for localization.</li> </ul> </li> <li> <p>Accessibility:</p> <ul> <li>Best Practices: Use semantic HTML, ARIA attributes, and tools like Lighthouse.</li> </ul> </li> </ol>"},{"location":"frontend/react/report/bugs/master-topic/#patterns","title":"Patterns","text":"<ol> <li> <p>Functional vs. Class Components:</p> <ul> <li>Understand: Differences and when to use each.</li> </ul> </li> <li> <p>Higher-Order Components (HOCs):</p> <ul> <li>Concept: A pattern for reusing component logic.</li> </ul> </li> <li> <p>Render Props:</p> <ul> <li>Concept: A pattern for sharing code between components using a function that returns a React element.</li> </ul> </li> <li> <p>Custom Hooks:</p> <ul> <li>Concept: Encapsulate reusable logic into custom hooks.</li> </ul> </li> <li> <p>Context API for Dependency Injection:</p> <ul> <li>Concept: Provide and consume context to avoid prop drilling.</li> </ul> </li> <li> <p>Controlled and Uncontrolled Components:</p> <ul> <li>Concept: Managing form inputs and state.</li> </ul> </li> <li> <p>Compound Components:</p> <ul> <li>Concept: Design components that work together and share implicit state.</li> </ul> </li> <li> <p>Function-as-Child (Render Props):</p> <ul> <li>Concept: Sharing component logic with a function that provides children.</li> </ul> </li> </ol>"},{"location":"frontend/react/report/bugs/master-topic/#libraries-and-tools","title":"Libraries and Tools","text":"<ol> <li> <p>State Management Libraries:</p> <ul> <li>Redux: For complex state management.</li> <li>Zustand: Lightweight state management.</li> <li>Recoil: For managing state with atoms and selectors.</li> </ul> </li> <li> <p>Data Fetching Libraries:</p> <ul> <li>Axios: For HTTP requests.</li> <li>React Query: For server-state management and data fetching.</li> </ul> </li> <li> <p>Routing Libraries:</p> <ul> <li>React Router: For client-side routing.</li> </ul> </li> <li> <p>Styling Libraries:</p> <ul> <li>styled-components: For CSS-in-JS styling.</li> <li>Emotion: Another CSS-in-JS library.</li> </ul> </li> <li> <p>Form Handling Libraries:</p> <ul> <li>React Hook Form: Simplifies form handling and validation.</li> <li>Formik: Another popular form management library.</li> </ul> </li> <li> <p>Testing Libraries:</p> <ul> <li>Jest: For unit testing.</li> <li>React Testing Library: For testing React components.</li> </ul> </li> <li> <p>Development Tools:</p> <ul> <li>ESLint: For code quality and consistency.</li> <li>Prettier: For code formatting.</li> </ul> </li> <li> <p>Build Tools:</p> <ul> <li>Webpack: For module bundling.</li> <li>Vite: A modern build tool that provides fast development server and optimized builds.</li> </ul> </li> <li> <p>Server-Side Frameworks:</p> <ul> <li>Next.js: For SSR and static site generation.</li> </ul> </li> <li> <p>Internationalization Libraries:</p> <ul> <li>react-i18next: For managing translations.</li> </ul> </li> <li> <p>Accessibility Tools:</p> <ul> <li>React Axe: For accessibility auditing.</li> </ul> </li> <li> <p>GraphQL Libraries:</p> <ul> <li>Apollo Client: For managing GraphQL data.</li> </ul> </li> </ol>"},{"location":"frontend/react/report/bugs/master-topic/#summary","title":"Summary","text":"<ul> <li>Master React Basics: Components, state, props, hooks.</li> <li>Adopt Advanced Patterns: HOCs, render props, custom hooks.</li> <li>Optimize Performance: Memoization, code splitting, lazy loading.</li> <li>Use Libraries Wisely: State management (Redux, Zustand), data fetching (React Query), styling (styled-components), routing (React Router).</li> <li>Test Your Code: With Jest and React Testing Library.</li> <li>Handle Forms and Internationalization: With React Hook Form or Formik, and react-i18next.</li> <li>Stay Updated: With new React features and best practices.</li> </ul> <p>By understanding and applying these techniques, patterns, and libraries, you'll be well-equipped to build robust, efficient, and maintainable React applications.</p>"},{"location":"frontend/react/report/bugs/solution/","title":"Solution","text":""},{"location":"frontend/react/report/bugs/solution/#dashboard-module","title":"Dashboard Module","text":""},{"location":"frontend/react/report/bugs/solution/#each-child-in-a-list-should-have-a-unique-key-prop","title":"Each child in a list should have a unique \"key\" prop","text":"Warning: Each child in a list should have a unique \"key\" prop. <p>Check the render method of <code>PublicEvents</code>. See https://reactjs.org/link/warning-keys for more information. PublicEvents@http://localhost:3000/static/js/main.chunk.js:218280:7</p> <p><code>PublicEvents.js:183</code></p> SourceSolutionTheory <pre><code># PublicEvents.js\n# page number : 189\n</code></pre> PublicEvents.js<pre><code>    &lt;&gt;\n        {data?.length &gt; 0 ? (\n          data?.map((list, i) =&gt; (\n            &lt;&gt;\n              {list.event !== \"day\" ? (\n                &lt;li\n                  key={i}\n                  className=\"dashboards__events--list\"\n                  style={{ padding: \"0px\" }}\n                &gt;\n                  &lt;div\n                    className={`dashboards__events--listTitle ${list?.event} `}\n                    style={{ flex: 6 }}\n                  &gt;\n                    &lt;span\n                      style={{ width: \"20px\", display: \"inline-block\" }}\n                    &gt;\n                      {i + 1}.\n                    &lt;/span&gt;\n\n                    {/* COMMENT */} \n                )})))}\n</code></pre> <pre><code>{data?.length &gt; 0 ? (\n    data.map((list, index) =&gt; (\n        &lt;li key={index}&gt;{list.name}&lt;/li&gt; // Using the index as a fallback\n    ))\n) : null}\n</code></pre> <p>Key changes:</p> <ul> <li>Used <code>list.id</code> as the key prop: React expects each item in a list to have a unique key for efficient rendering. Using list.id ensures that React can uniquely identify each item.</li> <li>Avoided using i (the index) as the key: Using the index as a key can lead to issues when items in the list are reordered or when items are added/removed, causing incorrect re-rendering.</li> </ul> <p>If list.id is guaranteed to be unique, this should fix the warning you're seeing.</p>"},{"location":"frontend/react/report/bugs/solution/#problem-title","title":"Problem Title","text":"<p>Problem Title: React List Rendering Warning: \"Each child in a list should have a unique 'key' prop\"</p> Problem Explanation <p>In React, when rendering a list of elements using the <code>.map()</code> method, each element must have a unique <code>key</code> prop. This key helps React efficiently identify and manage each item in the list, especially when items are added, removed, or reordered.</p> <p>If you don\u2019t provide a unique key for each list item, or if you use an unstable key (like an index <code>i</code>), React will display a warning: \"Each child in a list should have a unique 'key' prop\".</p> Why It Happens <p>When React renders a list, it needs to know which items are which. If items change order or some are removed/added, React uses the <code>key</code> prop to track these changes. If the key isn\u2019t unique or stable, React might:</p> <ol> <li>Re-render items unnecessarily.</li> <li>Confuse one item with another, leading to incorrect behavior (e.g., losing input values in a form).</li> </ol> <p>To avoid this issue, always provide a unique identifier (such as <code>id</code> from the list object) as the <code>key</code> prop instead of using something that might change, like an array index.</p>"},{"location":"frontend/react/report/bugs/solution/#few-strategies","title":"Few strategies","text":"<p>If you don't receive a unique ID from the API, there are a few strategies you can use to provide a stable <code>key</code> for each list item in React. Here are some common solutions:</p> <ol> <li> <p>Generate a Unique ID Locally (Using a Library)</p> <p>You can use libraries like <code>uuid</code> or <code>nanoid</code> to generate unique IDs for each item when you don't have one from the API. This is a good approach if the list doesn't change frequently or you're fine with generating new IDs on each render.</p> <p>Using <code>uuid</code>:</p> <pre><code>npm install uuid\n</code></pre> <pre><code>import { v4 as uuidv4 } from 'uuid';\n\n{data?.length &gt; 0 ? (\n    data.map((list) =&gt; (\n        &lt;li key={uuidv4()}&gt;{list.name}&lt;/li&gt; // Generate a unique key for each item\n    ))\n) : null}\n</code></pre> <p>This ensures each item has a stable, unique key.</p> </li> <li> <p>Combine Multiple Properties to Form a Unique Key</p> <p>If the items have other properties that are relatively unique, you can combine those properties to create a unique key.</p> <p>For example, if you have a list of users but no unique <code>id</code>, you can combine <code>name</code> and <code>email</code> or other available fields:</p> <pre><code>{data?.length &gt; 0 ? (\n    data.map((list) =&gt; (\n        &lt;li key={`${list.name}-${list.email}`}&gt;{list.name}&lt;/li&gt; // Combine properties\n    ))\n) : null}\n</code></pre> <p>This method works as long as the combination of properties guarantees uniqueness.</p> </li> <li> <p>Use the Index with Caution</p> <p>If none of the above options are available and the list is static (i.e., the order of the items doesn't change, and items are never added/removed), you can use the index as the key temporarily:</p> <pre><code>{data?.length &gt; 0 ? (\n    data.map((list, index) =&gt; (\n        &lt;li key={index}&gt;{list.name}&lt;/li&gt; // Using the index as a fallback\n    ))\n) : null}\n</code></pre> <p>However, using the index as a key is not ideal for dynamic lists, because:</p> <ul> <li>If the list changes (items are reordered, added, or removed), React can misidentify the items.</li> <li>Component states could get mixed up when using the index.</li> </ul> </li> </ol> Summary <ul> <li>Best Practice: Use a unique <code>id</code> if available.</li> <li>Fallback Options: Generate unique IDs locally, combine fields to create a unique key, or cautiously use the index if the list doesn't change frequently.</li> </ul>"},{"location":"frontend/react/report/bugs/solution/#best-choice","title":"Best choice","text":"<p>The best choice depends on the specific use case, but generally speaking:</p> <ol> <li> <p>Use a Unique ID from the Data (Best Option)</p> <p>If the API provides a unique <code>id</code> (like a database <code>id</code>, <code>uuid</code>, etc.), this is always the best option. It ensures stability and guarantees uniqueness even when the list changes (items added, removed, or reordered).</p> </li> <li> <p>Generate a Unique ID Locally (Good Alternative)</p> <p>If the API doesn\u2019t provide a unique <code>id</code>, generating a unique ID using a library like <code>uuid</code> or <code>nanoid</code> is the next best option. This approach creates a stable unique key for each item.</p> <ul> <li>Why it's good: Each key is truly unique and doesn\u2019t depend on changing data.</li> <li>When to use: When the list items are dynamic, and you need stable keys even after re-renders.</li> </ul> </li> <li> <p>Combine Properties to Form a Key (Depends on Uniqueness)</p> <p>If there are certain properties that can be combined to create a unique value (like combining <code>name</code> and <code>email</code>), this is a valid approach. However, this method only works if the combination is guaranteed to be unique across all items.</p> <ul> <li>Why it's good: It avoids adding external dependencies.</li> <li>When to use: If the list contains objects with multiple consistent properties, but no single unique identifier.</li> </ul> </li> <li> <p>Use the Index (Last Resort)</p> <p>Using the array index (<code>i</code>) as the key should be the last resort and only in very specific cases where:</p> <ul> <li>The list won\u2019t change (no new items added, no reordering).</li> <li> <p>It\u2019s acceptable to lose performance and stability benefits.</p> </li> <li> <p>Why it's risky: Keys based on the index can lead to incorrect updates when items are added, removed, or reordered.</p> </li> </ul> </li> </ol> Best Choice Recommendation <ol> <li>Unique ID from API (best).</li> <li>Generated unique ID using libraries like <code>uuid</code>.</li> <li>Combine properties (if you can guarantee uniqueness).</li> <li>Index as key (last resort, use with caution).</li> </ol> <p>In general, using a unique identifier from the data or generating a unique key locally is the most stable and reliable approach for React's list rendering.</p>"},{"location":"frontend/react/testing/cypress/","title":"Cypress","text":""},{"location":"frontend/react/testing/cypress/#theory","title":"Theory","text":"<p>Cypress is an end-to-end testing framework that provides a fast, reliable, and easy-to-use way to test your web applications.</p>"},{"location":"frontend/react/testing/cypress/#key-features-of-cypress","title":"Key Features of Cypress:","text":"<ol> <li>Real Browser Testing: Cypress runs tests directly in the browser, giving you a realistic testing environment.</li> <li>Automatic Waiting: Cypress automatically waits for commands and assertions to pass, making your tests more reliable without adding manual waits.</li> <li>Time Travel: Cypress captures snapshots as your tests run, allowing you to hover over commands in the Command Log to see what happened at each step.</li> <li>Debuggability: With detailed error messages and stack traces, Cypress makes debugging failed tests straightforward.</li> <li>Network Traffic Control: Cypress lets you stub and spy on network requests, giving you control over your application's API interactions during tests.</li> <li>Integration with CI/CD: Cypress integrates seamlessly with continuous integration and continuous deployment (CI/CD) pipelines.</li> </ol>"},{"location":"frontend/react/testing/cypress/#when-to-use-cypress","title":"When to Use Cypress","text":"<ul> <li>End-to-End Testing: Cypress is perfect for testing the complete user journey, from loading the application to interacting with various elements and verifying outcomes.</li> <li>Integration Testing: When you need to test how different parts of your application work together, Cypress's realistic browser environment is beneficial.</li> <li>Real Browser Interactions: If you need to test how your application behaves in a real browser, including handling of network requests, cookies, and local storage, Cypress is the right tool.</li> <li>User Interface Testing: Cypress excels at simulating real user interactions and verifying the application's response.</li> </ul>"},{"location":"frontend/react/testing/cypress/#example-use-cases","title":"Example Use Cases","text":"<p>Cypress Example (End-to-End Testing a Login Flow)</p> <ol> <li> <p>Install Cypress:</p> <pre><code>npm install --save-dev cypress\n</code></pre> </li> <li> <p>Example Test File (login.spec.js):</p> <pre><code>describe('Login Flow', () =&gt; {\n    it('should log in successfully', () =&gt; {\n        cy.visit('http://localhost:3000/login');\n        cy.get('input[name=username]').type('user');\n        cy.get('input[name=password]').type('password');\n        cy.get('button[type=submit]').click();\n        cy.url().should('include', '/dashboard');\n        cy.contains('Welcome, user!');\n    });\n});\n</code></pre> </li> <li> <p>Run Tests:</p> <pre><code>npx cypress open\n</code></pre> </li> </ol>"},{"location":"frontend/react/testing/cypress/#summary","title":"Summary","text":"<p>Use Cypress for end-to-end testing, integration testing, and when you need to simulate real user interactions in a browser.</p> <p>In many projects, both tools are used together: Jest for unit and component tests, and Cypress for end-to-end tests. This combination ensures comprehensive test coverage and a robust testing strategy.</p>"},{"location":"frontend/react/testing/intro/","title":"Intro","text":"<p>Mastering React testing in a large codebase can be challenging but is crucial for maintaining a robust and reliable application. Here\u2019s a comprehensive approach to get you started:</p>"},{"location":"frontend/react/testing/intro/#1-understand-the-fundamentals","title":"1.  Understand the Fundamentals","text":"<p>Before diving into complex scenarios, ensure you\u2019re comfortable with the basics:</p> <ul> <li>React Testing Library: Focus on testing components in a way that resembles how users interact with them. It encourages testing components from the user's perspective rather than the implementation details.</li> <li>Jest: A popular testing framework for React applications, providing utilities for assertions, mocking, and more.</li> </ul>"},{"location":"frontend/react/testing/intro/#2-set-up-a-testing-strategy","title":"2.  Set Up a Testing Strategy","text":"<p>Define Objectives:</p> <ul> <li>Unit Tests: Test individual components or functions in isolation.</li> <li>Integration Tests: Ensure that different parts of your application work together as expected.</li> <li>End-to-End Tests: Test the full application flow to simulate real user interactions.</li> </ul> <p>Testing Pyramid:</p> <ul> <li>Unit Tests: Most numerous, quick to run.</li> <li>Integration Tests: Fewer than unit tests, validate interactions.</li> <li>End-to-End Tests: Least frequent but cover the entire workflow.</li> </ul>"},{"location":"frontend/react/testing/intro/#3-establish-a-testing-framework","title":"3.  Establish a Testing Framework","text":"<p>Tools and Libraries:</p> <ul> <li>React Testing Library: For rendering components and querying the DOM.</li> <li>Jest: For assertions, mocking, and test utilities.</li> <li>Cypress or Playwright: For end-to-end testing.</li> <li>Storybook: For visual component testing and development.</li> </ul> <p>Configuration:</p> <ul> <li>Set up Jest and React Testing Library with a consistent configuration. Ensure that Jest is configured for handling imports and processing files correctly.</li> </ul>"},{"location":"frontend/react/testing/intro/#4-write-effective-tests","title":"4. Write Effective Tests","text":"<p>Component Testing:</p> <ul> <li>Render the Component: Use render from React Testing Library to render your component.</li> <li>Query Elements: Use queries like getByText, getByRole, etc., to select elements.</li> <li>Assertions: Use expect to assert conditions about your component.</li> </ul> <pre><code>import { render, screen } from '@testing-library/react';\nimport MyComponent from './MyComponent';\n\ntest('renders the correct text', () =&gt; {\n  render(&lt;MyComponent /&gt;);\n  expect(screen.getByText(/expected text/i)).toBeInTheDocument();\n});\n</code></pre> <p>Integration Testing:</p> <ul> <li>Mock Dependencies: Use tools like jest.mock to mock out dependencies or services.</li> <li>Test User Interactions: Simulate user interactions and verify the outcomes.</li> </ul> <pre><code>import { render, screen, fireEvent } from '@testing-library/react';\nimport MyForm from './MyForm';\n\ntest('submits form data correctly', () =&gt; {\n  render(&lt;MyForm /&gt;);\n  fireEvent.change(screen.getByLabelText(/name/i), { target: { value: 'John Doe' } });\n  fireEvent.click(screen.getByRole('button', { name: /submit/i }));\n  expect(screen.getByText(/form submitted/i)).toBeInTheDocument();\n});\n</code></pre>"},{"location":"frontend/react/testing/intro/#5-maintain-and-scale-tests","title":"5.  Maintain and Scale Tests","text":"<p>Refactor Tests:</p> <ul> <li>Regularly refactor tests to keep them clean and maintainable.</li> <li>Use helper functions or custom hooks for repetitive testing logic.</li> </ul> <p>Test Coverage:</p> <ul> <li>Aim for high test coverage but focus on critical paths and user interactions rather than striving for 100% coverage.</li> </ul> <p>Continuous Integration (CI):</p> <ul> <li>Integrate your tests into a CI pipeline to automatically run tests on code changes and pull requests.</li> </ul>"},{"location":"frontend/react/testing/intro/#6-address-common-challenges","title":"6.  Address Common Challenges","text":"<p>Large Codebase Specifics:</p> <ul> <li>Test Isolation: Ensure tests do not depend on each other. Use mocks and stubs effectively.</li> <li>Performance: Optimize tests to run quickly by avoiding excessive rendering or complex setups.</li> <li>Debugging: Leverage Jest\u2019s debugging tools and React Testing Library\u2019s debugging utilities to troubleshoot failing tests.</li> </ul> <p>Documentation and Best Practices:</p> <ul> <li>Document your testing strategy and best practices for consistency.</li> <li>Conduct regular reviews and updates of your testing approach as the codebase evolves.</li> </ul> <p>By focusing on these areas, you can effectively master React testing and ensure your large codebase remains reliable and maintainable.</p> <p>Testing API calls and optimizing graphs, especially in the context of React applications, involves different strategies for each task. Let\u2019s break down the approaches for both:</p>"},{"location":"frontend/react/testing/intro/#testing-api-calls-in-react","title":"Testing API Calls in React","text":"<ol> <li> <p>Testing API Calls</p> <p>When testing API calls in React components, you'll generally want to isolate the component from the network request to ensure your tests are reliable and fast.</p> <p>Mocking API Calls</p> <ul> <li> <p>Use <code>jest.mock()</code>: You can mock the module that performs the API request (e.g., <code>axios</code>, <code>fetch</code>) to avoid actual network calls during testing.</p> myComponent.jsmyComponent.test.js <pre><code>// myComponent.js\nimport React, { useEffect, useState } from 'react';\nimport axios from 'axios';\n\nconst MyComponent = () =&gt; {\n    const [data, setData] = useState(null);\n\n    useEffect(() =&gt; {\n        axios.get('/api/data')\n        .then(response =&gt; setData(response.data))\n        .catch(error =&gt; console.error(error));\n    }, []);\n\n    if (!data) return &lt;div&gt;Loading...&lt;/div&gt;;\n\n    return &lt;div&gt;{data.message}&lt;/div&gt;;\n};\n\nexport default MyComponent;\n</code></pre> <pre><code>// myComponent.test.js\nimport { render, screen, waitFor } from '@testing-library/react';\nimport axios from 'axios';\nimport MyComponent from './myComponent';\n\n// Mocking axios\njest.mock('axios');\n\ntest('fetches and displays data', async () =&gt; {\n    // Mock implementation\n    axios.get.mockResolvedValue({ data: { message: 'Hello World' } });\n\n    render(&lt;MyComponent /&gt;);\n\n    // Assertion\n    await waitFor(() =&gt; screen.getByText(/hello world/i));\n    expect(screen.getByText(/hello world/i)).toBeInTheDocument();\n});\n</code></pre> </li> </ul> </li> <li> <p>Handling Asynchronous Code</p> <p>When dealing with asynchronous operations:</p> <ul> <li>Use <code>waitFor</code>: To wait for changes in the DOM.</li> <li>Use <code>findBy</code> queries: For assertions involving async updates.</li> </ul> <pre><code>await waitFor(() =&gt; {\n    expect(screen.getByText(/hello world/i)).toBeInTheDocument();\n});\n</code></pre> </li> </ol>"},{"location":"frontend/react/testing/intro/#optimizing-graphs","title":"Optimizing Graphs","text":"<p>Optimizing graphs usually refers to improving the performance of data visualizations. Here\u2019s how to approach this:</p>"},{"location":"frontend/react/testing/intro/#1-before-optimization","title":"1.  Before Optimization","text":"Identify Performance Issues <ul> <li>Large Data Sets: Rendering large amounts of data can be slow.</li> <li>Re-renders: Unnecessary re-renders can impact performance.</li> <li>Complex Calculations: Expensive operations can affect responsiveness.</li> </ul>"},{"location":"frontend/react/testing/intro/#2-optimization-techniques","title":"2.  Optimization Techniques","text":"Optimize Data Handling <ul> <li>Data Aggregation: Aggregate data on the server side to reduce the amount of data sent to the client.</li> <li>Pagination/Infinite Scroll: Load data in chunks rather than all at once.</li> </ul> Optimize Rendering <ul> <li>Virtualization: Use libraries like <code>react-virtualized</code> or <code>react-window</code> to render only visible parts of the graph.</li> <li>Memoization: Use <code>React.memo</code> or <code>useMemo</code> to prevent unnecessary re-renders.</li> <li>Debouncing: For user interactions that trigger updates, use debouncing to limit the frequency of updates.</li> </ul> <pre><code>import React, { memo } from 'react';\nimport { FixedSizeList as List } from 'react-window';\n\nconst Row = memo(({ index, style }) =&gt; (\n&lt;div style={style}&gt;\n    {/* Row content */}\n&lt;/div&gt;\n));\n\nconst MyGraph = ({ data }) =&gt; (\n&lt;List\n    height={600}\n    itemCount={data.length}\n    itemSize={35}\n    width={1000}\n&gt;\n    {Row}\n&lt;/List&gt;\n);\n</code></pre>"},{"location":"frontend/react/testing/intro/#optimize-graph-calculations","title":"Optimize Graph Calculations","text":"<ul> <li>Web Workers: Offload intensive calculations to web workers.</li> <li>Canvas/SVG: Choose the right technology for rendering. For complex graphs, <code>canvas</code> may be more performant than <code>SVG</code>.</li> </ul> <pre><code>const MyGraph = ({ data }) =&gt; {\n  // Drawing logic using canvas API\n\n  return &lt;canvas id=\"graphCanvas\"&gt;&lt;/canvas&gt;;\n};\n</code></pre>"},{"location":"frontend/react/testing/intro/#profile-and-measure-performance","title":"Profile and Measure Performance","text":"<ul> <li>React DevTools: Use the Profiler tab to identify performance bottlenecks in React components.</li> <li>Browser DevTools: Use performance profiling tools to analyze rendering times and identify slow operations.</li> </ul>"},{"location":"frontend/react/testing/intro/#3-after-optimization","title":"3. After Optimization","text":""},{"location":"frontend/react/testing/intro/#test-and-validate","title":"Test and Validate","text":"<ul> <li>Benchmarking: Measure performance improvements before and after optimization.</li> <li>User Testing: Validate that the optimizations improve user experience and do not introduce new issues.</li> </ul>"},{"location":"frontend/react/testing/intro/#continuous-monitoring","title":"Continuous Monitoring","text":"<ul> <li>Performance Monitoring: Continuously monitor performance in production using tools like Google Lighthouse, New Relic, or custom performance metrics.</li> <li>By focusing on these strategies for both testing API calls and optimizing graphs, you can improve the performance and reliability of your React application.</li> </ul>"},{"location":"frontend/react/testing/jest/","title":"Jest","text":""},{"location":"frontend/react/testing/jest/#theory","title":"Theory","text":"<p>Jest is a delightful JavaScript testing framework developed by Facebook, designed to ensure correctness of any JavaScript codebase. It is widely used for testing React applications, but it can be used with any JavaScript project.</p>"},{"location":"frontend/react/testing/jest/#key-features-of-jest","title":"Key Features of Jest:","text":"<ol> <li>Zero Configuration: Jest works out of the box for most JavaScript projects, especially those using React.</li> <li>Snapshots: Jest can capture the output of your components and compare it to a reference snapshot file to ensure UI consistency.</li> <li>Isolated Tests: Each test runs in its own sandbox environment to avoid global state pollution.</li> <li>Coverage Reporting: Jest can generate code coverage reports, helping you understand how much of your code is tested.</li> <li>Mocking: Jest provides powerful mocking capabilities to simulate different scenarios and behaviors for your code dependencies. Parallel Execution: Tests run in parallel, speeding up the testing process.</li> </ol>"},{"location":"frontend/react/testing/jest/#when-to-use-jest","title":"When to Use Jest","text":"<ul> <li>Unit Testing: Jest is ideal for testing individual functions, modules, or components in isolation.</li> <li>Snapshot Testing: If you want to ensure that your UI components render consistently, snapshot testing with Jest is very effective.</li> <li>Mocking Dependencies: When you need to mock dependencies or simulate different scenarios, Jest's mocking capabilities are highly useful.</li> <li>Fast Feedback Loop: Jest's parallel execution and watch mode provide quick feedback during development.</li> </ul>"},{"location":"frontend/react/testing/jest/#example-use-cases","title":"Example Use Cases","text":"<p>Jest Example (Unit Testing a React Component)</p> <ol> <li> <p>Install Jest:</p> <pre><code>npm install --save-dev jest @testing-library/react @testing-library/jest-dom\n</code></pre> </li> <li> <p>Example Test File (<code>MyComponent.test.js</code>):</p> <pre><code>import React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport MyComponent from './MyComponent';\n\ntest('renders a message', () =&gt; {\n    render(&lt;MyComponent /&gt;);\n    const messageElement = screen.getByText(/hello, world!/i);\n    expect(messageElement).toBeInTheDocument();\n});\n</code></pre> </li> <li> <p>Run Tests:</p> <pre><code>npm test\n</code></pre> </li> </ol>"},{"location":"frontend/react/testing/jest/#summary","title":"Summary","text":"<p>Use Jest for unit testing, snapshot testing, and when you need fast feedback during development.</p> <p>In many projects, both tools are used together: Jest for unit and component tests, and Cypress for end-to-end tests. This combination ensures comprehensive test coverage and a robust testing strategy.</p>"},{"location":"frontend/react/testing/measuring-optimization-tools/","title":"Measuring Tools","text":"<p>Measuring the impact of optimizations, particularly in client-side applications like React, involves evaluating several performance metrics before and after making changes. Here\u2019s a structured approach to assess the effectiveness of your optimizations:</p>"},{"location":"frontend/react/testing/measuring-optimization-tools/#1-define-performance-metrics","title":"1.  Define Performance Metrics","text":"<p>Before you can measure changes, you need to define what metrics you\u2019ll be tracking. Common performance metrics include:</p> <ul> <li>Page Load Time: Time taken from initiating a page load to complete rendering.</li> <li>Time to Interactive (TTI): Time until the page is fully interactive.</li> <li>First Contentful Paint (FCP): Time taken for the first piece of content to be painted on the screen.</li> <li>Largest Contentful Paint (LCP): Time taken for the largest piece of content to be painted.</li> <li>Total Blocking Time (TBT): Time during which the page is blocked from user input.</li> <li>FPS (Frames Per Second): Smoothness of animations and interactions.</li> </ul>"},{"location":"frontend/react/testing/measuring-optimization-tools/#2-use-performance-measurement-tools","title":"2.  Use Performance Measurement Tools","text":"<p>1. Google Lighthouse:</p> <ul> <li>How to Use: Run Lighthouse audits in Chrome DevTools (Lighthouse tab), from the command line, or within CI/CD pipelines.</li> <li>What to Measure: Provides scores for performance, accessibility, SEO, and more. Use the performance score and individual metrics (FCP, LCP, TTI) to assess changes.</li> </ul> <p>2. Web Vitals:</p> <ul> <li>How to Use: Integrate the web-vitals library into your application to collect metrics like FCP, LCP, and CLS (Cumulative Layout Shift).</li> <li>What to Measure: Provides real-world performance data from actual user interactions.</li> </ul> <p>3. Chrome DevTools:</p> <ul> <li>How to Use: Use the Performance tab to record and analyze runtime performance, including rendering and scripting times.</li> <li>What to Measure: Look for metrics like scripting time, rendering time, and network requests.</li> </ul> <p>4. Performance APIs:</p> <ul> <li>How to Use: Use the Performance API in your code to manually measure specific timings and events.</li> <li>What to Measure: Custom timings for specific actions or events in your application.</li> </ul> <p>5. Real User Monitoring (RUM):</p> <ul> <li>How to Use: Tools like Google Analytics, New Relic, or Sentry can provide real-user performance metrics.</li> <li>What to Measure: Collect data from actual users to get insights into performance under real-world conditions.</li> </ul>"},{"location":"frontend/react/testing/measuring-optimization-tools/#3-establish-baseline-metrics","title":"3. Establish Baseline Metrics","text":"Before Optimization: <ul> <li>Run Performance Tests: Use the tools mentioned to capture performance metrics before implementing optimizations.</li> <li>Document Baseline Data: Record the metrics as a reference point for comparison.</li> </ul> <pre><code>import { getCLS, getFCP, getLCP, getFID } from 'web-vitals';\n\ngetCLS(console.log); // Report Cumulative Layout Shift\ngetFCP(console.log); // Report First Contentful Paint\ngetLCP(console.log); // Report Largest Contentful Paint\ngetFID(console.log); // Report First Input Delay\n</code></pre>"},{"location":"frontend/react/testing/measuring-optimization-tools/#4-apply-optimizations","title":"4. Apply Optimizations","text":"<p>Implement the changes you believe will improve performance, such as code splitting, lazy loading, optimizing data fetching, or using virtualized lists.</p>"},{"location":"frontend/react/testing/measuring-optimization-tools/#5-re-measure-performance","title":"5. Re-Measure Performance","text":"After Optimization: <ul> <li>Re-run Tests: Use the same tools and methods to measure performance after optimizations are applied.</li> <li>Compare Metrics: Compare the new data against your baseline to assess the impact of the optimizations.</li> </ul>"},{"location":"frontend/react/testing/measuring-optimization-tools/#6-analyze-results","title":"6. Analyze Results","text":"<p>Compare and Interpret:</p> <ul> <li>Improvement: Determine if metrics have improved, such as faster load times, reduced time to interactive, or smoother animations.</li> <li>Regression: Identify if any metrics have worsened or if new issues have been introduced.</li> </ul>"},{"location":"frontend/react/testing/measuring-optimization-tools/#7-continuous-monitoring","title":"7. Continuous Monitoring","text":"<p>Regular Checks:</p> <ul> <li>Ongoing Monitoring: Integrate performance monitoring into your CI/CD pipeline and regularly review performance metrics.</li> <li>User Feedback: Collect feedback from users to ensure that optimizations align with user experience improvements.</li> </ul> <p>Performance Dashboards:</p> <ul> <li>Create Dashboards: Use tools like Google Data Studio, Grafana, or custom dashboards to visualize performance metrics over time.</li> </ul>"},{"location":"frontend/react/testing/measuring-optimization-tools/#example-process","title":"Example Process","text":"<ol> <li> <p>Baseline Measurement:</p> <ul> <li>Before: Run Lighthouse audit and note down FCP, LCP, TTI.</li> </ul> </li> <li> <p>Optimization:</p> <ul> <li>Implement code splitting and lazy loading.</li> </ul> </li> <li> <p>Re-measure:</p> <ul> <li>After: Run Lighthouse audit again and compare the updated metrics.</li> </ul> </li> <li> <p>Analyze:</p> <ul> <li>Results: If FCP improved from 2s to 1s, LCP improved from 3s to 1.5s, this indicates a successful optimization.</li> </ul> </li> </ol> <p>By following these steps, you can effectively measure the impact of your optimizations and ensure that your changes lead to real performance improvements for your users.</p>"},{"location":"frontend/react/testing/measuring-optimization-tools/#react-tools-for-optimization","title":"React Tools for Optimization","text":"<p>For optimizing and measuring performance in a React web application, you have a variety of tools at your disposal. Here\u2019s a comprehensive list of tools categorized by their primary functions:</p>"},{"location":"frontend/react/testing/measuring-optimization-tools/#1-performance-testing-and-optimization","title":"1. Performance Testing and Optimization","text":"<p>1.1 Google Lighthouse</p> <ul> <li>Purpose: Provides performance audits, accessibility, SEO, and best practices.</li> <li>How to Use: Available in Chrome DevTools (Lighthouse tab), as a CLI tool, or as a GitHub Action.</li> <li>Website: Lighthouse</li> </ul> <p>1.2 Web Vitals</p> <ul> <li>Purpose: Measures key user-centric metrics like First Contentful Paint (FCP), Largest Contentful Paint (LCP), and Cumulative Layout Shift (CLS).</li> <li>How to Use: Integrate the web-vitals library into your application to collect and report metrics.</li> <li>Website: Web Vitals</li> </ul> <p>1.3 Chrome DevTools</p> <ul> <li>Purpose: Provides real-time performance insights, profiling, and debugging.</li> <li>How to Use: Access the Performance tab in Chrome DevTools to record and analyze performance.</li> <li>Website: Chrome DevTools</li> </ul> <p>1.4 React DevTools</p> <ul> <li>Purpose: Helps inspect React component hierarchies, measure component render times, and track state and props.</li> <li>How to Use: Available as a browser extension or standalone app.</li> <li>Website: React DevTools</li> </ul> <p>1.5 Webpack Bundle Analyzer</p> <ul> <li>Purpose: Visualizes the size of webpack output files to help optimize bundling.</li> <li>How to Use: Integrate with your webpack configuration to generate interactive bundle reports.</li> <li>Website: Webpack Bundle Analyzer</li> </ul> <p>1.6 Source Map Explorer</p> <ul> <li>Purpose: Analyzes the size of the bundled code and its dependencies.</li> <li>How to Use: Run as a CLI tool to visualize and understand the size of your code.</li> <li>Website: Source Map Explorer</li> </ul>"},{"location":"frontend/react/testing/measuring-optimization-tools/#2-testing-tools","title":"2. Testing Tools","text":"<p>2.1 Jest</p> <ul> <li>Purpose: A testing framework for unit and integration tests with built-in test runners and assertions.</li> <li>How to Use: Write and run tests for JavaScript and React components.</li> <li>Website: Jest</li> </ul> <p>2.2 React Testing Library</p> <ul> <li>Purpose: Provides utilities for testing React components by interacting with the DOM in a user-centric way.</li> <li>How to Use: Write tests that focus on user interactions rather than implementation details.</li> <li>Website: React Testing Library</li> </ul> <p>2.3 Cypress</p> <ul> <li>Purpose: End-to-end testing framework that allows for writing and running integration and UI tests.</li> <li>How to Use: Write tests that simulate user interactions and validate application behavior.</li> <li>Website: Cypress</li> </ul> <p>2.4 Playwright</p> <ul> <li>Purpose: End-to-end testing framework with cross-browser support and automation capabilities.</li> <li>How to Use: Write tests to verify interactions across different browsers.</li> <li>Website: Playwright</li> </ul>"},{"location":"frontend/react/testing/measuring-optimization-tools/#3-monitoring-and-analytics","title":"3. Monitoring and Analytics","text":"<p>3.1 Google Analytics</p> <ul> <li>Purpose: Tracks user interactions and performance metrics for web applications.</li> <li>How to Use: Integrate with your React app to gather and analyze usage data.</li> <li>Website: Google Analytics</li> </ul> <p>3.2 Sentry</p> <ul> <li>Purpose: Provides error tracking and performance monitoring for web applications.</li> <li>How to Use: Integrate with React to track errors, performance issues, and monitor user interactions.</li> <li>Website: Sentry</li> </ul> <p>3.3 New Relic</p> <ul> <li>Purpose: Application performance monitoring (APM) tool with real-time performance metrics and insights.</li> <li>How to Use: Integrate with your app to monitor performance, errors, and user experience.</li> <li>Website: New Relic</li> </ul>"},{"location":"frontend/react/testing/measuring-optimization-tools/#4-code-quality-and-best-practices","title":"4. Code Quality and Best Practices","text":"<p>4.1 ESLint</p> <ul> <li>Purpose: A linting tool for identifying and fixing problems in your JavaScript code.</li> <li>How to Use: Integrate with your development workflow to enforce coding standards and catch errors.</li> <li>Website: ESLint</li> </ul> <p>4.2 Prettier</p> <ul> <li>Purpose: Code formatter that ensures consistent styling across your codebase.</li> <li>How to Use: Integrate with your code editor to format code automatically.</li> <li>Website: Prettier</li> </ul>"},{"location":"frontend/react/testing/measuring-optimization-tools/#5-documentation-and-development","title":"5. Documentation and Development","text":"<p>5.1 Storybook</p> <ul> <li>Purpose: Develop and test UI components in isolation with interactive documentation.</li> <li>How to Use: Set up Storybook to create a component library and visualize components in various states.</li> <li>Website: Storybook</li> </ul> <p>By leveraging these tools, you can effectively measure, optimize, test, and maintain your React web application, ensuring both performance improvements and code quality.</p>"},{"location":"frontend/state-management/intro/","title":"Intro","text":"<p>Most developers use Redux, Recoil, Mobx, and other third-party libraries to manage the global state in large-scale applications.</p> <ul> <li> <p> Redux</p> <p>Install <code>mkdocs-material</code> with <code>pip</code> and get up and running in minutes</p> <p> Getting started</p> </li> <li> <p> Mobx</p> <p>Focus on your content and generate a responsive and searchable static site</p> <p> Reference</p> </li> <li> <p> Recoil</p> <p>Change the colors, fonts, language, icons, logo and more with a few lines</p> <p> Customization</p> </li> </ul>"},{"location":"frontend/state-management/middleware/","title":"Intro","text":"<ul> <li> <p> redux-thunk </p> </li> <li> <p> redux-saga </p> </li> </ul>"},{"location":"frontend/state-management/middleware/#question","title":"Question","text":""},{"location":"frontend/state-management/middleware/#middleware-in-react","title":"Middleware in react","text":"<p>why do we need middleware in react. what do we need it. when do we need it. what is the problem. what exactly the problem does it solve. when do we do not need it. example me clearly and simply.</p> <p>Middleware in React is commonly associated with state management libraries like Redux. Middleware provides a way to extend the capabilities of Redux by adding custom functionality to the dispatching of actions. Here's a breakdown of why and when you might need middleware, what problems it solves, and when you might not need it.</p>"},{"location":"frontend/state-management/middleware/#why-do-we-need-middleware","title":"Why Do We Need Middleware?","text":"<ol> <li> <p>Enhance Dispatching:</p> <p>Middleware allows you to enhance the behavior of the dispatch function. This can include logging actions, handling asynchronous actions, or modifying actions before they reach the reducer.</p> </li> <li> <p>Asynchronous Actions:</p> <p>By default, Redux actions are synchronous. Middleware like redux-thunk or redux-saga allows you to handle asynchronous operations (e.g., API calls) within your action creators.</p> </li> <li> <p>Side Effects Management:</p> <p>Middleware helps manage side effects in a predictable manner, ensuring that the state changes in response to actions are manageable and traceable.</p> </li> </ol>"},{"location":"frontend/state-management/middleware/#what-problems-does-middleware-solve","title":"What Problems Does Middleware Solve?","text":"<ol> <li> <p>Handling Async Logic:</p> <p>Middleware allows you to write asynchronous logic that interacts with the Redux store. Without middleware, you'd have to handle async logic outside of Redux, which can lead to a less organized codebase.</p> </li> <li> <p>Action Logging:</p> <p>Middleware can log every action dispatched, along with the state before and after the action. This is helpful for debugging and understanding the flow of actions in your application.</p> </li> <li> <p>Centralized Error Handling:</p> <p>Middleware can be used to catch and handle errors that occur during the dispatching of actions, ensuring that your application remains stable.</p> </li> </ol>"},{"location":"frontend/state-management/middleware/#when-do-you-need-middleware","title":"When Do You Need Middleware?","text":"<ul> <li> <p>Asynchronous Data Fetching:</p> <p>If your application needs to fetch data from an API or handle other asynchronous operations, middleware like redux-thunk or redux-saga is necessary.</p> </li> <li> <p>Complex State Management:</p> <p>When your application has complex state transitions and side effects that need to be managed in a centralized way.</p> </li> <li> <p>Enhanced Debugging:</p> <p>To provide better debugging and logging capabilities, middleware can be very useful.</p> </li> </ul>"},{"location":"frontend/state-management/middleware/#when-do-you-not-need-middleware","title":"When Do You Not Need Middleware?","text":"<ul> <li> <p>Simple Applications:</p> <p>For simple applications with straightforward state management and no asynchronous operations, middleware might be overkill.</p> </li> <li> <p>Local State Management:</p> <p>If your state management needs are limited to a few components, using local component state and React's context API might be sufficient.</p> </li> </ul>"},{"location":"frontend/state-management/middleware/#example","title":"Example","text":"<p>Let's consider a simple example using redux-thunk to handle an asynchronous API call.</p>"},{"location":"frontend/state-management/middleware/#without-middleware-synchronous","title":"Without Middleware (Synchronous)","text":"<pre><code>// actions.js\nexport const increment = () =&gt; ({\n  type: 'INCREMENT'\n});\n\n// reducer.js\nconst counter = (state = 0, action) =&gt; {\n  switch (action.type) {\n    case 'INCREMENT':\n      return state + 1;\n    default:\n      return state;\n  }\n};\n</code></pre>"},{"location":"frontend/state-management/middleware/#with-middleware-asynchronous","title":"With Middleware (Asynchronous)","text":"<pre><code>// actions.js\nexport const fetchUserData = () =&gt; {\n  return async (dispatch) =&gt; {\n    dispatch({ type: 'FETCH_USER_REQUEST' });\n    try {\n      const response = await fetch('https://api.example.com/user');\n      const data = await response.json();\n      dispatch({ type: 'FETCH_USER_SUCCESS', payload: data });\n    } catch (error) {\n      dispatch({ type: 'FETCH_USER_FAILURE', error });\n    }\n  };\n};\n\n// reducer.js\nconst user = (state = { data: null, loading: false, error: null }, action) =&gt; {\n  switch (action.type) {\n    case 'FETCH_USER_REQUEST':\n      return { ...state, loading: true, error: null };\n    case 'FETCH_USER_SUCCESS':\n      return { ...state, loading: false, data: action.payload };\n    case 'FETCH_USER_FAILURE':\n      return { ...state, loading: false, error: action.error };\n    default:\n      return state;\n  }\n};\n</code></pre> <p>In this example, redux-thunk middleware allows us to handle the asynchronous API call within the action creators, making it easier to manage the state transitions related to fetching user data.</p>"},{"location":"frontend/state-management/middleware/#summary","title":"Summary","text":"<p>Middleware in React (typically used with Redux) is essential for managing complex state transitions, especially when dealing with asynchronous operations. It extends the capabilities of the Redux store, allowing for enhanced dispatching, centralized error handling, and better debugging. While it's invaluable for complex applications, simpler applications might not need middleware.</p>"},{"location":"frontend/state-management/mobx/intro/","title":"Intro","text":"<p>mobx</p>"},{"location":"frontend/state-management/recoil/intro/","title":"Intro","text":"<p>recoil</p>"},{"location":"frontend/state-management/redux/folder-structure/","title":"Folder Structure","text":"<p>Application Structure for React.js</p>"},{"location":"frontend/state-management/redux/folder-structure/#redux-thunk","title":"Redux Thunk","text":"<p>To use an API in a React application with Redux Thunk, you'll need to follow these steps:</p> <ol> <li> <p>Set up Redux Thunk: Ensure you have Redux and Redux Thunk installed and configured in your React application.</p> </li> <li> <p>Create an API Service: Create a file to manage your API calls, typically using a library like axios or fetch.</p> </li> <li> <p>Create Action Types: Define the action types for your API calls.</p> </li> <li> <p>Create Actions: Use Redux Thunk to create asynchronous actions that dispatch the appropriate actions based on the API response.</p> </li> <li> <p>Create Reducers: Create reducers to handle the actions and update the state accordingly.</p> </li> <li> <p>Connect Redux to React Components: Use <code>connect</code> or hooks (<code>useSelector</code> and <code>useDispatch</code>) to connect your React components to the Redux store.</p> </li> </ol>"},{"location":"frontend/state-management/redux/folder-structure/#set-up-redux-thunk","title":"Set up Redux Thunk","text":"<pre><code>npm install redux react-redux redux-thunk axios\n</code></pre>"},{"location":"frontend/state-management/redux/folder-structure/#basic","title":"Basic","text":"<pre><code>my-app/\n\u251c\u2500\u2500 node_modules/\n\u251c\u2500\u2500 public/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 actions/\n\u2502   \u2502   \u251c\u2500\u2500 actionTypes.js\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u251c\u2500\u2500 api/\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u251c\u2500\u2500 components/\n\u2502   \u2502   \u2514\u2500\u2500 DataComponent.js\n\u2502   \u251c\u2500\u2500 reducers/\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u251c\u2500\u2500 store/\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u251c\u2500\u2500 App.js\n\u2502   \u251c\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 index.css\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 package-lock.json\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"frontend/state-management/redux/folder-structure/#folder-structure-explanation","title":"Folder Structure Explanation","text":"<ul> <li> <p>actions/: Contains action types and action creators.</p> <ul> <li>actionTypes.js: Defines the action types.</li> <li>index.js: Contains action creators using Redux Thunk.</li> </ul> </li> <li> <p>api/: Contains API service functions.</p> <ul> <li>index.js: Defines the functions to make API calls (e.g., using axios).</li> </ul> </li> <li> <p>components/: Contains React components.</p> <ul> <li>DataComponent.js: Example component that uses Redux Thunk to fetch and display data.</li> </ul> </li> <li> <p>reducers/: Contains Redux reducers.</p> <ul> <li>index.js: Combines and exports all the reducers.</li> </ul> </li> <li> <p>store/: Contains the Redux store configuration.</p> <ul> <li>index.js: Sets up the Redux store with Thunk middleware.</li> </ul> </li> <li> <p>App.js: Main app component.</p> </li> <li> <p>index.js: Entry point of the application, where you set up React and Redux.</p> </li> <li> <p>index.css: Global CSS file for styling.</p> </li> </ul>"},{"location":"frontend/state-management/redux/folder-structure/#example-files","title":"Example Files","text":"Example actions/api/components/reducers/store/App.jsindex.js actionTypes.jsindex.js <pre><code>export const FETCH_DATA_REQUEST = 'FETCH_DATA_REQUEST';\nexport const FETCH_DATA_SUCCESS = 'FETCH_DATA_SUCCESS';\nexport const FETCH_DATA_FAILURE = 'FETCH_DATA_FAILURE';\n</code></pre> <pre><code>import {\n    FETCH_DATA_REQUEST,\n    FETCH_DATA_SUCCESS,\n    FETCH_DATA_FAILURE,\n} from './actionTypes';\nimport { fetchData } from '../api';\n\nexport const fetchDataRequest = () =&gt; ({\n    type: FETCH_DATA_REQUEST,\n});\n\nexport const fetchDataSuccess = (data) =&gt; ({\n    type: FETCH_DATA_SUCCESS,\n    payload: data,\n});\n\nexport const fetchDataFailure = (error) =&gt; ({\n    type: FETCH_DATA_FAILURE,\n    payload: error,\n});\n\nexport const fetchDataThunk = () =&gt; {\n    return (dispatch) =&gt; {\n        dispatch(fetchDataRequest());\n        fetchData()\n            .then((response) =&gt; {\n                dispatch(fetchDataSuccess(response.data));\n            })\n            .catch((error) =&gt; {\n                dispatch(fetchDataFailure(error.message));\n            });\n    };\n};\n</code></pre> index.js <pre><code>import axios from 'axios';\n\nconst API_URL = 'https://api.example.com';\n\nexport const fetchData = () =&gt; {\n    return axios.get(`${API_URL}/data`);\n};\n</code></pre> DataComponent.js <pre><code>import React, { useEffect } from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { fetchDataThunk } from '../actions';\n\nconst DataComponent = () =&gt; {\n    const dispatch = useDispatch();\n    const dataState = useSelector((state) =&gt; state.data);\n\n    useEffect(() =&gt; {\n        dispatch(fetchDataThunk());\n    }, [dispatch]);\n\n    return (\n        &lt;div&gt;\n            {dataState.loading ? (\n                &lt;p&gt;Loading...&lt;/p&gt;\n            ) : dataState.error ? (\n                &lt;p&gt;Error: {dataState.error}&lt;/p&gt;\n            ) : (\n                &lt;ul&gt;\n                {dataState.data.map((item) =&gt; (\n                    &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;\n                ))}\n                &lt;/ul&gt;\n            )}\n        &lt;/div&gt;\n    );\n};\n\nexport default DataComponent;\n</code></pre> index.js <pre><code>import {\n    FETCH_DATA_REQUEST,\n    FETCH_DATA_SUCCESS,\n    FETCH_DATA_FAILURE,\n} from '../actions/actionTypes';\n\nconst initialState = {\n    loading: false,\n    data: [],\n    error: '',\n};\n\nconst dataReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case FETCH_DATA_REQUEST:\n            return {\n                ...state,\n                loading: true,\n            };\n        case FETCH_DATA_SUCCESS:\n            return {\n                loading: false,\n                data: action.payload,\n                error: '',\n            };\n        case FETCH_DATA_FAILURE:\n            return {\n                loading: false,\n                data: [],\n                error: action.payload,\n            };\n        default:\n            return state;\n    }\n};\n\nexport default combineReducers({\n    data: dataReducer,\n});\n</code></pre> index.js <pre><code>import { createStore, applyMiddleware, combineReducers } from 'redux';\nimport thunk from 'redux-thunk';\nimport dataReducer from '../reducers';\n\nconst rootReducer = combineReducers({\n    data: dataReducer,\n});\n\nconst store = createStore(rootReducer, applyMiddleware(thunk));\n\nexport default store;\n</code></pre> <pre><code>import React from 'react';\nimport DataComponent from './components/DataComponent';\n\nconst App = () =&gt; (\n    &lt;div className=\"App\"&gt;\n        &lt;DataComponent /&gt;\n    &lt;/div&gt;\n);\n\nexport default App;\n</code></pre> <pre><code>import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport store from './store';\nimport App from './App';\nimport './index.css';\n\nReactDOM.render(\n    &lt;Provider store={store}&gt;\n        &lt;App /&gt;\n    &lt;/Provider&gt;,\n    document.getElementById('root')\n);\n\n// or\n\nReactDOM.createRoot(document.getElementById('root')).render(\n    &lt;React.StrictMode&gt;\n        &lt;Provider store={store}&gt;\n            &lt;App /&gt;\n        &lt;/Provider&gt;\n    &lt;/React.StrictMode&gt;\n);\n</code></pre> <p>This structure helps you organize your code in a modular and maintainable way. Each part of your application is separated by its responsibility, making it easier to manage and scale.</p>"},{"location":"frontend/state-management/redux/folder-structure/#intermediate-example","title":"Intermediate Example","text":"<pre><code>src/\n\u251c\u2500\u2500 api/\n\u2502   \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 components/\n\u2502   \u2514\u2500\u2500 DataComponent.js\n\u251c\u2500\u2500 redux/\n\u2502   \u251c\u2500\u2500 actions/\n\u2502   \u2502   \u251c\u2500\u2500 actionTypes.js\n\u2502   \u2502   \u2514\u2500\u2500 dataActions.js\n\u2502   \u251c\u2500\u2500 reducers/\n\u2502   \u2502   \u251c\u2500\u2500 dataReducer.js\n\u2502   \u2502   \u2514\u2500\u2500 rootReducer.js\n\u2502   \u251c\u2500\u2500 store/\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 selectors/\n\u2502       \u2514\u2500\u2500 dataSelectors.js\n\u251c\u2500\u2500 App.js\n\u251c\u2500\u2500 index.js\n\u251c\u2500\u2500 index.css\n\u2514\u2500\u2500 utils/\n    \u2514\u2500\u2500 apiHelpers.js\n</code></pre>"},{"location":"frontend/state-management/redux/folder-structure/#folder-structure-explanation_1","title":"Folder Structure Explanation","text":"<ul> <li> <p>api/: Contains files related to API calls.</p> <ul> <li>index.js: Manages API requests.</li> </ul> </li> <li> <p>components/: Contains reusable React components.</p> <ul> <li>DataComponent.js: Example component.</li> </ul> </li> <li> <p>redux/: Contains all Redux-related logic.</p> <ul> <li>actions/: Contains action types and action creators.<ul> <li>actionTypes.js: Defines action types.</li> <li>dataActions.js: Contains action creators related to data.</li> </ul> </li> <li>reducers/: Contains reducer functions.<ul> <li>dataReducer.js: Reducer for data-related actions.</li> <li>rootReducer.js: Combines all reducers.</li> </ul> </li> <li>store/: Contains the Redux store configuration.<ul> <li>index.js: Sets up the Redux store with middleware.</li> </ul> </li> <li>selectors/: Contains selector functions.<ul> <li>dataSelectors.js: Selectors for accessing data state.</li> </ul> </li> </ul> </li> <li> <p>utils/: Contains utility functions and helpers.</p> <ul> <li>apiHelpers.js: Helper functions for API calls.</li> </ul> </li> </ul>"},{"location":"frontend/state-management/redux/folder-structure/#example-files_1","title":"Example Files","text":"redux/ /actions//reducers//store//selectors/ /actionTypes.js/dataActions.js <pre><code>export const FETCH_DATA_REQUEST = 'FETCH_DATA_REQUEST';\nexport const FETCH_DATA_SUCCESS = 'FETCH_DATA_SUCCESS';\nexport const FETCH_DATA_FAILURE = 'FETCH_DATA_FAILURE';\n</code></pre> <pre><code>import {\n    FETCH_DATA_REQUEST,\n    FETCH_DATA_SUCCESS,\n    FETCH_DATA_FAILURE,\n} from './actionTypes';\nimport { fetchData } from '../../api';\n\nexport const fetchDataRequest = () =&gt; ({\n    type: FETCH_DATA_REQUEST,\n});\n\nexport const fetchDataSuccess = (data) =&gt; ({\n    type: FETCH_DATA_SUCCESS,\n    payload: data,\n});\n\nexport const fetchDataFailure = (error) =&gt; ({\n    type: FETCH_DATA_FAILURE,\n    payload: error,\n});\n\nexport const fetchDataThunk = () =&gt; {\n    return (dispatch) =&gt; {\n        dispatch(fetchDataRequest());\n        fetchData()\n            .then((response) =&gt; {\n                dispatch(fetchDataSuccess(response.data));\n            })\n            .catch((error) =&gt; {\n                dispatch(fetchDataFailure(error.message));\n            });\n    };\n};\n</code></pre> /dataReducer.js/rootReducer.js <pre><code>import {\n    FETCH_DATA_REQUEST,\n    FETCH_DATA_SUCCESS,\n    FETCH_DATA_FAILURE,\n} from '../actions/actionTypes';\n\nconst initialState = {\n    loading: false,\n    data: [],\n    error: '',\n};\n\nconst dataReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case FETCH_DATA_REQUEST:\n            return {\n                ...state,\n                loading: true,\n            };\n        case FETCH_DATA_SUCCESS:\n            return {\n                loading: false,\n                data: action.payload,\n                error: '',\n            };\n        case FETCH_DATA_FAILURE:\n            return {\n                loading: false,\n                data: [],\n                error: action.payload,\n            };\n        default:\n            return state;\n    }\n};\n\nexport default dataReducer;\n</code></pre> <pre><code>import { combineReducers } from 'redux';\nimport dataReducer from './dataReducer';\n\nconst rootReducer = combineReducers({\n    data: dataReducer,\n});\n\nexport default rootReducer;\n</code></pre> /index.js <pre><code>import { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport rootReducer from '../reducers/rootReducer';\n\nconst store = createStore(rootReducer, applyMiddleware(thunk));\n\nexport default store;\n</code></pre> /dataSelectors.js <pre><code>export const getDataState = (state) =&gt; state.data;\nexport const getData = (state) =&gt; getDataState(state).data;\nexport const getDataLoading = (state) =&gt; getDataState(state).loading;\nexport const getDataError = (state) =&gt; getDataState(state).error;\n</code></pre>"},{"location":"frontend/state-management/redux/folder-structure/#connecting-components","title":"Connecting Components","text":"Example components/App.jsindex.js DataComponent.js<pre><code>import React, { useEffect } from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { fetchDataThunk } from '../redux/actions/dataActions';\nimport { getData, getDataLoading, getDataError } from '../redux/selectors/dataSelectors';\n\nconst DataComponent = () =&gt; {\n    const dispatch = useDispatch();\n    const data = useSelector(getData);\n    const loading = useSelector(getDataLoading);\n    const error = useSelector(getDataError);\n\n    useEffect(() =&gt; {\n        dispatch(fetchDataThunk());\n    }, [dispatch]);\n\n    return (\n        &lt;div&gt;\n            {loading ? (\n                &lt;p&gt;Loading...&lt;/p&gt;\n            ) : error ? (\n                &lt;p&gt;Error: {error}&lt;/p&gt;\n            ) : (\n                &lt;ul&gt;\n                {data.map((item) =&gt; (\n                    &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;\n                ))}\n                &lt;/ul&gt;\n            )}\n        &lt;/div&gt;\n    );\n};\n\nexport default DataComponent;\n</code></pre> <pre><code>//App and index.js\nimport React from 'react';\nimport DataComponent from './components/DataComponent';\n\nconst App = () =&gt; (\n    &lt;div className=\"App\"&gt;\n        &lt;DataComponent /&gt;\n    &lt;/div&gt;\n);\n\nexport default App;\n</code></pre> <pre><code>import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport { Provider } from 'react-redux';\nimport store from './redux/store';\nimport App from './App';\nimport './index.css';\n\nReactDOM.createRoot(document.getElementById('root')).render(\n    &lt;React.StrictMode&gt;\n        &lt;Provider store={store}&gt;\n            &lt;App /&gt;\n        &lt;/Provider&gt;\n    &lt;/React.StrictMode&gt;\n);\n</code></pre> <p>This structure helps maintain a clear separation of concerns, making the codebase easier to manage and scale as the application grows. It also adheres to best practices, making it easier for other developers to understand and contribute to the project.</p>"},{"location":"frontend/state-management/redux/folder-structure/#advanced-example","title":"Advanced Example","text":"<pre><code>src/\n\u251c\u2500\u2500 api/\n\u2502   \u2514\u2500\u2500 user.js\n\u251c\u2500\u2500 components/\n\u2502   \u2514\u2500\u2500 UserComponent.js\n\u251c\u2500\u2500 redux/\n\u2502   \u251c\u2500\u2500 actions/\n\u2502   \u2502   \u251c\u2500\u2500 actionTypes.js\n\u2502   \u2502   \u2514\u2500\u2500 userActions.js\n\u2502   \u251c\u2500\u2500 reducers/\n\u2502   \u2502   \u251c\u2500\u2500 entitiesReducer.js\n\u2502   \u2502   \u251c\u2500\u2500 usersReducer.js\n\u2502   \u2502   \u2514\u2500\u2500 rootReducer.js\n\u2502   \u251c\u2500\u2500 selectors/\n\u2502   \u2502   \u2514\u2500\u2500 userSelectors.js\n\u2502   \u251c\u2500\u2500 store/\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 utils/\n\u2502       \u251c\u2500\u2500 normalize.js\n\u2502       \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 App.js\n\u251c\u2500\u2500 index.js\n\u251c\u2500\u2500 index.css\n\u2514\u2500\u2500 utils/\n    \u2514\u2500\u2500 apiHelpers.js\n</code></pre>"},{"location":"frontend/state-management/redux/folder-structure/#action","title":"Action","text":"redux/actions/ actionTypes.jsuserActions.js <pre><code>export const FETCH_USER_REQUEST = 'FETCH_USER_REQUEST';\nexport const FETCH_USER_SUCCESS = 'FETCH_USER_SUCCESS';\nexport const FETCH_USER_FAILURE = 'FETCH_USER_FAILURE';\nexport const CREATE_USER_REQUEST = 'CREATE_USER_REQUEST';\nexport const CREATE_USER_SUCCESS = 'CREATE_USER_SUCCESS';\nexport const CREATE_USER_FAILURE = 'CREATE_USER_FAILURE';\n// Other action types...\n</code></pre> <pre><code>import {\n    FETCH_USER_REQUEST,\n    FETCH_USER_SUCCESS,\n    FETCH_USER_FAILURE,\n    CREATE_USER_REQUEST,\n    CREATE_USER_SUCCESS,\n    CREATE_USER_FAILURE,\n} from './actionTypes';\n\nimport {\n    getUserById,\n    createUser,\n    updateUser,\n    deleteUser,\n    searchUsers,\n} from '../../api/user';\n\nimport { normalizeUserData } from '../utils/normalize';\n\n// Fetch user by ID\nexport const fetchUser = (id) =&gt; {\n    return async (dispatch) =&gt; {\n        dispatch({ type: FETCH_USER_REQUEST });\n\n        try {\n            const response = await getUserById(id);\n            const normalizedData = normalizeUserData(response.data);\n            dispatch({ type: FETCH_USER_SUCCESS, payload: normalizedData });\n        } catch (error) {\n            dispatch({ type: FETCH_USER_FAILURE, payload: error.message });\n        }\n    };\n};\n\n// Create user\nexport const addUser = (userData) =&gt; {\n    return async (dispatch) =&gt; {\n        dispatch({ type: CREATE_USER_REQUEST });\n\n        try {\n            const response = await createUser(userData);\n            const normalizedData = normalizeUserData(response.data);\n            dispatch({ type: CREATE_USER_SUCCESS, payload: normalizedData });\n        } catch (error) {\n            dispatch({ type: CREATE_USER_FAILURE, payload: error.message });\n        }\n    };\n};\n\n// Update user\nexport const modifyUser = (id, userData) =&gt; {\n    return async (dispatch) =&gt; {\n        dispatch({ type: UPDATE_USER_REQUEST });\n\n        try {\n            const response = await updateUser(id, userData);\n            const normalizedData = normalizeUserData(response.data);\n            dispatch({ type: UPDATE_USER_SUCCESS, payload: normalizedData });\n        } catch (error) {\n            dispatch({ type: UPDATE_USER_FAILURE, payload: error.message });\n        }\n    };\n};\n\n// Delete user\nexport const removeUser = (id) =&gt; {\n    return async (dispatch) =&gt; {\n        dispatch({ type: DELETE_USER_REQUEST });\n\n        try {\n            await deleteUser(id);\n            dispatch({ type: DELETE_USER_SUCCESS, payload: id });\n        } catch (error) {\n            dispatch({ type: DELETE_USER_FAILURE, payload: error.message });\n        }\n    };\n};\n\n// Search users\nexport const findUsers = (queryParams) =&gt; {\n    return async (dispatch) =&gt; {\n        dispatch({ type: SEARCH_USERS_REQUEST });\n\n        try {\n            const response = await searchUsers(queryParams);\n            const normalizedData = normalizeUserData(response.data);\n            dispatch({ type: SEARCH_USERS_SUCCESS, payload: normalizedData });\n        } catch (error) {\n            dispatch({ type: SEARCH_USERS_FAILURE, payload: error.message });\n        }\n    };\n};\n</code></pre>"},{"location":"frontend/state-management/redux/folder-structure/#reducers","title":"Reducers","text":"redux/reducers/ entitiesReducer.jsusersReducer.jsrootReducer.js <p>This reducer handles the normalization of entities, which helps in managing relationships between different entities.</p> <pre><code>import { combineReducers } from 'redux';\nimport {\n    FETCH_USER_SUCCESS,\n    CREATE_USER_SUCCESS,\n    UPDATE_USER_SUCCESS,\n    SEARCH_USERS_SUCCESS,\n} from '../actions/actionTypes';\n\nconst initialState = {\n    users: {},\n};\n\nconst users = (state = initialState.users, action) =&gt; {\n    switch (action.type) {\n        case FETCH_USER_SUCCESS:\n        case CREATE_USER_SUCCESS:\n        case UPDATE_USER_SUCCESS:\n        case SEARCH_USERS_SUCCESS:\n            return {\n                ...state,\n                ...action.payload.entities.users,\n            };\n        default:\n            return state;\n    }\n};\n\nexport default combineReducers({\n    users,\n});\n</code></pre> <p>This reducer handles the specific logic related to users, such as loading states and errors.</p> <pre><code>import {\n    FETCH_USER_REQUEST,\n    FETCH_USER_SUCCESS,\n    FETCH_USER_FAILURE,\n    CREATE_USER_REQUEST,\n    CREATE_USER_SUCCESS,\n    CREATE_USER_FAILURE,\n    UPDATE_USER_REQUEST,\n    UPDATE_USER_SUCCESS,\n    UPDATE_USER_FAILURE,\n    DELETE_USER_REQUEST,\n    DELETE_USER_SUCCESS,\n    DELETE_USER_FAILURE,\n    SEARCH_USERS_REQUEST,\n    SEARCH_USERS_SUCCESS,\n    SEARCH_USERS_FAILURE,\n} from '../actions/actionTypes';\n\nconst initialState = {\n    loading: false,\n    error: null,\n    allIds: [],\n    currentUser: null,\n};\n\nconst usersReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case FETCH_USER_REQUEST:\n        case CREATE_USER_REQUEST:\n        case UPDATE_USER_REQUEST:\n        case DELETE_USER_REQUEST:\n        case SEARCH_USERS_REQUEST:\n            return {\n                ...state,\n                loading: true,\n                error: null,\n            };\n        case FETCH_USER_SUCCESS:\n            return {\n                ...state,\n                loading: false,\n                currentUser: action.payload.result,\n            };\n        case CREATE_USER_SUCCESS:\n            return {\n                ...state,\n                loading: false,\n                allIds: [...state.allIds, action.payload.result],\n            };\n        case UPDATE_USER_SUCCESS:\n            return {\n                ...state,\n                loading: false,\n            };\n        case DELETE_USER_SUCCESS:\n            return {\n                ...state,\n                loading: false,\n                allIds: state.allIds.filter((id) =&gt; id !== action.payload),\n            };\n        case SEARCH_USERS_SUCCESS:\n            return {\n                ...state,\n                loading: false,\n                allIds: action.payload.result,\n            };\n        case FETCH_USER_FAILURE:\n        case CREATE_USER_FAILURE:\n        case UPDATE_USER_FAILURE:\n        case DELETE_USER_FAILURE:\n        case SEARCH_USERS_FAILURE:\n            return {\n                ...state,\n                loading: false,\n                error: action.payload,\n            };\n        default:\n            return state;\n    }\n};\n\nexport default usersReducer;\n</code></pre> <p>Combine the entity and user-specific reducers to create the root reducer.</p> <pre><code>import { combineReducers } from 'redux';\nimport entitiesReducer from './entitiesReducer';\nimport usersReducer from './usersReducer';\n\nconst rootReducer = combineReducers({\n    entities: entitiesReducer,\n    users: usersReducer,\n});\n\nexport default rootReducer;\n</code></pre>"},{"location":"frontend/state-management/redux/folder-structure/#normalization","title":"Normalization","text":"<p>Normalize the data received from the API to ensure it is stored in a flat structure, making it easier to manage and update.</p> redux/utils/normalize.js <pre><code>import { normalize, schema } from 'normalizr';\n\n// Define a user schema\nconst user = new schema.Entity('users');\n\n// Define a function to normalize user data\nexport const normalizeUserData = (data) =&gt; {\n    return normalize(data, user);\n};\n</code></pre> <p>Selectors</p> <p>Use selectors to access and derive data from the state, keeping your components clean and focused on rendering.</p> redux/selectors/userSelectors.js <pre><code>import { createSelector } from 'reselect';\n\nexport const getUsersState = (state) =&gt; state.users;\nexport const getEntitiesState = (state) =&gt; state.entities;\n\nexport const getAllUserIds = createSelector(\n    [getUsersState],\n    (usersState) =&gt; usersState.allIds\n);\n\nexport const getUserById = (state, userId) =&gt;\ngetEntitiesState(state).users[userId];\n\nexport const getAllUsers = createSelector(\n    [getAllUserIds, getEntitiesState],\n    (allIds, entities) =&gt; allIds.map((id) =&gt; entities.users[id])\n);\n\nexport const getCurrentUser = createSelector(\n    [getUsersState, getEntitiesState],\n    (usersState, entities) =&gt; entities.users[usersState.currentUser]\n);\n</code></pre>"},{"location":"frontend/state-management/redux/folder-structure/#connecting-components_1","title":"Connecting Components","text":"components/UserComponent.js <pre><code>import React, { useEffect } from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { fetchUser, addUser, modifyUser, removeUser, findUsers } from '../redux/actions/userActions';\nimport { getAllUsers, getCurrentUser, getUserLoading, getUserError } from '../redux/selectors/userSelectors';\n\nconst UserComponent = () =&gt; {\n    const dispatch = useDispatch();\n    const users = useSelector(getAllUsers);\n    const currentUser = useSelector(getCurrentUser);\n    const loading = useSelector(getUserLoading);\n    const error = useSelector(getUserError);\n\n    useEffect(() =&gt; {\n        dispatch(fetchUser(1)); // Fetch user with ID 1\n    }, [dispatch]);\n\n    const handleAddUser = (userData) =&gt; {\n        dispatch(addUser(userData));\n    };\n\n    const handleUpdateUser = (id, userData) =&gt; {\n        dispatch(modifyUser(id, userData));\n    };\n\n    const handleDeleteUser = (id) =&gt; {\n        dispatch(removeUser(id));\n    };\n\n    const handleSearchUsers = (queryParams) =&gt; {\n        dispatch(findUsers(queryParams));\n    };\n\n    return (\n        &lt;div&gt;\n            {loading ? (\n                &lt;p&gt;Loading...&lt;/p&gt;\n            ) : error ? (\n                &lt;p&gt;Error: {error}&lt;/p&gt;\n            ) : (\n                &lt;div&gt;\n                &lt;h1&gt;User Details&lt;/h1&gt;\n                {currentUser &amp;&amp; &lt;div&gt;{currentUser.name}&lt;/div&gt;}\n                &lt;h1&gt;All Users&lt;/h1&gt;\n                &lt;ul&gt;\n                    {users.map((u) =&gt; (\n                    &lt;li key={u.id}&gt;{u.name}&lt;/li&gt;\n                    ))}\n                &lt;/ul&gt;\n                &lt;/div&gt;\n            )}\n            &lt;button onClick={() =&gt; handleAddUser({ name: 'New User' })}&gt;Add User&lt;/button&gt;\n            &lt;button onClick={() =&gt; handleUpdateUser(1, { name: 'Updated User' })}&gt;Update User&lt;/button&gt;\n            &lt;button onClick={() =&gt; handleDeleteUser(1)}&gt;Delete User&lt;/button&gt;\n            &lt;button onClick={() =&gt; handleSearchUsers({ name: 'John' })}&gt;Search Users&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default UserComponent;\n</code></pre> <p>Store</p> redux/store/index.js <pre><code>import { createStore, applyMiddleware } from 'redux';\nimport { composeWithDevTools } from 'redux-devtools-extension';\nimport thunk from 'redux-thunk';\nimport rootReducer from '../reducers/rootReducer';\n\nconst store = createStore(rootReducer, composeWithDevTools(applyMiddleware(thunk)));\n\nexport default store;\n</code></pre> <p>This structure allows for scalability, as each part of the state is managed independently and can be easily extended with new entities or additional logic. The use of selectors ensures that the component logic remains clean and focused on rendering, while the normalization of data helps manage relationships and avoid nested state.</p>"},{"location":"frontend/state-management/redux/intro/","title":"Intro","text":"<ul> <li> <p> Standard Redux</p> <p>Install <code>mkdocs-material</code> with <code>pip</code> and get up and running in minutes</p> <p> Getting started</p> </li> <li> <p> RTK Redux</p> <p>Focus on your content and generate a responsive and searchable static site</p> <p> Reference</p> </li> </ul>"},{"location":"frontend/state-management/redux/redux-pattern/","title":"Redux Pattern","text":""},{"location":"frontend/state-management/redux/redux-pattern/#redux-pattern","title":"Redux Pattern","text":"<p>The Redux pattern is an architecture for managing and centralizing application state in JavaScript applications, particularly those with complex, shared states across multiple components. It follows a unidirectional data flow and is based on the principles of predictability, immutability, and state management.</p> <p>Here's a breakdown of the key concepts:</p>"},{"location":"frontend/state-management/redux/redux-pattern/#key-concepts-of-redux-pattern","title":"Key Concepts of Redux Pattern:","text":"<ol> <li> <p>Store:</p> <ul> <li>The store is a single, centralized object that holds the entire state of the application. In Redux, there is usually just one store for the whole app, which contains the global state.</li> </ul> </li> <li> <p>State:</p> <ul> <li>The state is the current state of the application, kept in the store. The state is read-only, meaning it can only be updated through specific actions.</li> </ul> </li> <li> <p>Action:</p> <ul> <li> <p>An action is a plain JavaScript object that describes an event or something that happened in the application. Actions have a <code>type</code> (describing the event) and an optional payload containing additional data.</p> </li> <li> <p>Example: <code>{ type: 'ADD_TODO', payload: { text: 'Learn Redux' } }</code></p> </li> </ul> </li> <li> <p>Reducer:</p> <ul> <li> <p>A reducer is a pure function that takes the current state and an action as arguments, and returns a new state based on the action. Reducers must be pure functions, meaning they should not mutate the state but instead return a new state object.</p> </li> <li> <p>Example:</p> <pre><code>function todoReducer(state = [], action) {\n    switch (action.type) {\n        case 'ADD_TODO':\n            return [...state, { text: action.payload.text, completed: false }];\n        default:\n            return state;\n    }\n}\n</code></pre> </li> </ul> </li> <li> <p>Dispatch:</p> <ul> <li>The dispatch function is used to send actions to the store. When an action is dispatched, Redux passes the action to the reducers, which calculate the new state based on the action type.</li> <li>Example: <code>store.dispatch({ type: 'ADD_TODO', payload: { text: 'Learn Redux' } })</code></li> </ul> </li> <li> <p>Selectors:</p> <ul> <li>Selectors are functions used to access or derive specific pieces of state from the store. They help in keeping the state access logic in one place and promoting reusability.</li> </ul> </li> <li> <p>Middleware:</p> <ul> <li>Middleware functions provide a way to extend Redux with custom behavior, often for things like logging, handling asynchronous actions (e.g., redux-thunk or redux-saga), or intercepting actions before they reach the reducer.</li> </ul> </li> </ol>"},{"location":"frontend/state-management/redux/redux-pattern/#unidirectional-data-flow-in-redux","title":"Unidirectional Data Flow in Redux:","text":"<ul> <li>Component -&gt; Dispatch an Action -&gt; Reducer updates the Store -&gt; Component re-renders based on new state.</li> </ul>"},{"location":"frontend/state-management/redux/redux-pattern/#benefits-of-the-redux-pattern","title":"Benefits of the Redux Pattern:","text":"<ol> <li>Predictable State Updates: Since all state changes happen through actions and reducers, it's easy to track how and where state is updated.</li> <li>Centralized State: The entire application state is stored in a single place (the store), making it easier to debug and maintain.</li> <li>Time Travel Debugging: Since state updates are predictable and actions are serializable, you can \"time travel\" to different states in the application (with Redux DevTools).</li> <li>Separation of Concerns: The Redux pattern keeps the UI logic separate from the state management logic.</li> <li>Immutability: Redux encourages immutable updates to state, which helps prevent accidental mutations and bugs.</li> </ol>"},{"location":"frontend/state-management/redux/redux-pattern/#common-tools-with-redux","title":"Common Tools with Redux:","text":"<ol> <li>Redux Toolkit: A modern, opinionated approach to writing Redux logic with simplified syntax and best practices.</li> <li>Redux Thunk: Middleware for handling asynchronous actions.</li> <li>Redux Saga: A middleware for managing side effects with generator functions.</li> </ol>"},{"location":"frontend/state-management/redux/redux-pattern/#basic-folder-structure","title":"Basic Folder Structure:","text":"<ul> <li><code>actions/</code>: Contains the action creators and types.</li> <li><code>reducers/</code>: Contains the reducers for different parts of the state.</li> <li><code>store.js</code>: Configures the store and applies middleware.</li> <li><code>components/</code>: React components that dispatch actions and subscribe to state.</li> </ul>"},{"location":"frontend/state-management/redux/redux-pattern/#middleware","title":"Middleware","text":"<p>Let's dive deeper into handling asynchronous logic in Redux, especially focusing on middleware like Redux Thunk and Redux Saga.</p>"},{"location":"frontend/state-management/redux/redux-pattern/#1-handling-asynchronous-logic-in-redux","title":"1. Handling Asynchronous Logic in Redux:","text":"<p>By default, Redux only supports synchronous data flow\u2014state is updated immediately after an action is dispatched. However, most modern apps require dealing with asynchronous operations (like API requests). To handle this, Redux uses middleware that allows you to write logic between the action being dispatched and the reducer handling it.</p> <p>Key Middleware for Asynchronous Logic:</p> <ul> <li>Redux Thunk (Simple, widely used for small to medium apps)</li> <li>Redux Saga (More advanced, great for large, complex apps)</li> </ul>"},{"location":"frontend/state-management/redux/redux-pattern/#2-redux-thunk","title":"2. Redux Thunk:","text":"<p>Overview:</p> <p>Redux Thunk is the most popular middleware for handling asynchronous logic. It allows you to write action creators that return a function instead of an action object. This function can perform side effects (e.g., API calls) and dispatch actions based on the result.</p> <p>How Thunk Works:</p> <p>Without Redux Thunk, action creators return a plain JavaScript object. With Thunk, they can return a function that takes <code>dispatch</code> as an argument and allows for asynchronous calls.</p> <p>Basic Example:</p> InstallationExampleExplanation <pre><code>npm install redux-thunk\n</code></pre> <pre><code>// actionTypes.js\nexport const FETCH_DATA_REQUEST = 'FETCH_DATA_REQUEST';\nexport const FETCH_DATA_SUCCESS = 'FETCH_DATA_SUCCESS';\nexport const FETCH_DATA_FAILURE = 'FETCH_DATA_FAILURE';\n\n// actions.js\nexport const fetchData = () =&gt; {\n    return async (dispatch) =&gt; {\n        dispatch({ type: FETCH_DATA_REQUEST });\n        try {\n            const response = await fetch('https://api.example.com/data');\n            const data = await response.json();\n            dispatch({ type: FETCH_DATA_SUCCESS, payload: data });\n        } catch (error) {\n            dispatch({ type: FETCH_DATA_FAILURE, payload: error.message });\n        }\n    };\n};\n\n// reducer.js\nconst initialState = {\n    loading: false,\n    data: [],\n    error: null,\n};\n\nexport const dataReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case FETCH_DATA_REQUEST:\n            return { ...state, loading: true };\n        case FETCH_DATA_SUCCESS:\n            return { ...state, loading: false, data: action.payload };\n        case FETCH_DATA_FAILURE:\n            return { ...state, loading: false, error: action.payload };\n        default:\n            return state;\n    }\n};\n</code></pre> <p>Explanation:</p> <ul> <li>Dispatching Actions: The <code>fetchData</code> action first dispatches <code>FETCH_DATA_REQUEST</code>, performs the API call, and based on success or failure, dispatches either <code>FETCH_DATA_SUCCESS</code> or <code>FETCH_DATA_FAILURE</code>.</li> <li>Handling Asynchronous Logic: The middleware intercepts this function and ensures the async operation is executed.</li> </ul> <p>Pros of Redux Thunk:</p> <ul> <li>Simplicity: Easy to understand and use.</li> <li>Direct access to dispatch: You can control when to dispatch actions (before, during, or after async operations).</li> </ul> <p>Cons of Redux Thunk:</p> <ul> <li>Messy code: Thunks can get long and cluttered if there's too much logic in them.</li> <li>Testing challenges: Testing action creators can be more difficult as they contain both logic and side effects.</li> </ul>"},{"location":"frontend/state-management/redux/redux-pattern/#3-redux-saga","title":"3. Redux Saga:","text":"<p>Overview:</p> <p>Redux Saga is a middleware that handles more complex asynchronous logic using generator functions. It's great for dealing with complex async workflows (like canceling, debouncing, or retrying actions), managing multiple side effects, and handling intricate state changes.</p> <p>Redux Saga introduces a more declarative style where you \"describe\" side effects in your sagas and then \"yield\" them.</p> <p>How Redux Saga Works:</p> <ul> <li>It listens for dispatched actions and runs sagas in response.</li> <li>Sagas are generator functions that handle side effects like data fetching, background processing, or state updates.</li> </ul> InstallationExampleExplanation <pre><code>npm install redux-saga\n</code></pre> <pre><code>import { call, put, takeLatest } from 'redux-saga/effects';\nimport { FETCH_DATA_REQUEST, FETCH_DATA_SUCCESS, FETCH_DATA_FAILURE } from './actionTypes';\nimport { fetchDataFromApi } from './api';\n\n// Worker Saga: Will be fired on FETCH_DATA_REQUEST actions\nfunction* fetchDataSaga(action) {\n    try {\n        const data = yield call(fetchDataFromApi);\n        yield put({ type: FETCH_DATA_SUCCESS, payload: data });\n    } catch (error) {\n        yield put({ type: FETCH_DATA_FAILURE, payload: error.message });\n    }\n}\n\n// Watcher Saga: Spawn a new fetchDataSaga on each FETCH_DATA_REQUEST\nfunction* watchFetchDataSaga() {\n    yield takeLatest(FETCH_DATA_REQUEST, fetchDataSaga);\n}\n\nexport default watchFetchDataSaga;\n</code></pre> <p>Explanation:</p> <ul> <li>Saga Workflow: The <code>watchFetchDataSaga</code> listens for <code>FETCH_DATA_REQUEST</code> actions and runs the <code>fetchDataSaga</code>. The <code>fetchDataSaga</code> performs an API call using <code>call()</code> and dispatches actions using <code>put()</code>.</li> <li>Effects:<ul> <li><code>call()</code>: Calls the <code>fetchDataFromApi</code> function.</li> <li><code>put()</code>: Dispatches an action (<code>FETCH_DATA_SUCCESS</code> or <code>FETCH_DATA_FAILURE</code>).</li> <li><code>takeLatest()</code>: Ensures only the latest request is handled, canceling previous ones.</li> </ul> </li> </ul> <p>Pros of Redux Saga:</p> <ul> <li>Structured code: Complex async logic is easier to structure and manage.</li> <li>Powerful features: Offers fine-grained control over side effects like cancelation, debouncing, retrying, etc.</li> <li>Testable: Generator functions are easier to test in isolation.</li> </ul> <p>Cons of Redux Saga:</p> <ul> <li>Steeper learning curve: Using generators and understanding Redux Saga\u2019s API can be challenging.</li> <li>More boilerplate: Sagas can add more code overhead.</li> </ul>"},{"location":"frontend/state-management/redux/redux-pattern/#4-which-one-should-you-use","title":"4. Which One Should You Use?","text":"<p>Redux Thunk: -   Ideal for simple to moderately complex applications where you only need basic async functionality (like fetching data). -   It's easier to learn and can handle most common use cases.</p> <p>Redux Saga: -   Best for complex applications where you need to handle multiple side effects, complex async flows (like canceling, retrying, or parallel execution), or want more control over async logic. -   It\u2019s suited for larger projects with many async actions and requirements like debouncing or task cancelation.</p>"},{"location":"frontend/state-management/redux/redux-pattern/#5-combining-redux-with-other-middleware","title":"5. Combining Redux with Other Middleware:","text":"<p>You can use multiple middleware together (e.g., both Redux Thunk and logging middleware) to enhance Redux functionality.</p> <p>Example of combining middleware:</p> <pre><code>import { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport createSagaMiddleware from 'redux-saga';\nimport logger from 'redux-logger';\nimport rootReducer from './reducers';\nimport rootSaga from './sagas';\n\nconst sagaMiddleware = createSagaMiddleware();\nconst store = createStore(\n  rootReducer,\n  applyMiddleware(thunk, sagaMiddleware, logger)\n);\n\n// Run the saga middleware\nsagaMiddleware.run(rootSaga);\n</code></pre>"},{"location":"frontend/state-management/redux/redux-pattern/#conclusion","title":"Conclusion:","text":"<ul> <li>Redux Thunk is straightforward and good for smaller apps with simple async needs.</li> <li>Redux Saga is powerful and suited for larger, more complex applications requiring more control over side effects.</li> </ul> <p>If you're looking for simplicity, start with Thunk. If you're dealing with complex workflows and need advanced side effect management, Saga is the way to go. Would you like to explore any specific real-world scenarios using Thunk or Saga?</p>"},{"location":"frontend/state-management/redux/redux-pattern/#example","title":"Example","text":"<p>Let\u2019s explore some real-world scenarios where we can apply Redux Thunk and Redux Saga to manage asynchronous operations effectively.</p>"},{"location":"frontend/state-management/redux/redux-pattern/#scenario-1-api-fetching-with-redux-thunk","title":"Scenario 1: API Fetching with Redux Thunk","text":"<p>Scenario:</p> <p>Imagine an e-commerce app where you need to fetch a list of products from an API when a user visits the product page.</p> <p>Step-by-Step Solution Using Redux Thunk:</p> <ol> <li> <p>Set Up the Action Types: Define action types for requesting, succeeding, and failing the product fetch operation.</p> <pre><code>// actionTypes.js\nexport const FETCH_PRODUCTS_REQUEST = 'FETCH_PRODUCTS_REQUEST';\nexport const FETCH_PRODUCTS_SUCCESS = 'FETCH_PRODUCTS_SUCCESS';\nexport const FETCH_PRODUCTS_FAILURE = 'FETCH_PRODUCTS_FAILURE';\n</code></pre> </li> <li> <p>Create the Action Creator with Thunk: Use <code>redux-thunk</code> to create an action creator that fetches the products asynchronously.</p> <pre><code>// actions.js\nimport { FETCH_PRODUCTS_REQUEST, FETCH_PRODUCTS_SUCCESS, FETCH_PRODUCTS_FAILURE } from './actionTypes';\n\nexport const fetchProducts = () =&gt; {\n    return async (dispatch) =&gt; {\n        dispatch({ type: FETCH_PRODUCTS_REQUEST });\n        try {\n            const response = await fetch('https://api.example.com/products');\n            const products = await response.json();\n            dispatch({ type: FETCH_PRODUCTS_SUCCESS, payload: products });\n        } catch (error) {\n            dispatch({ type: FETCH_PRODUCTS_FAILURE, payload: error.message });\n        }\n    };\n};\n</code></pre> </li> <li> <p>Create the Reducer: The reducer will handle the state changes for product fetching. It reacts to the actions dispatched by the thunk.</p> <pre><code>// productReducer.js\nconst initialState = {\n    loading: false,\n    products: [],\n    error: null,\n};\n\nexport const productReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case FETCH_PRODUCTS_REQUEST:\n            return { ...state, loading: true, error: null };\n        case FETCH_PRODUCTS_SUCCESS:\n            return { ...state, loading: false, products: action.payload };\n        case FETCH_PRODUCTS_FAILURE:\n            return { ...state, loading: false, error: action.payload };\n        default:\n            return state;\n    }\n};\n</code></pre> </li> <li> <p>Dispatch the Action in a React Component: Use <code>useEffect</code> to dispatch the <code>fetchProducts</code> action when the product page component mounts.</p> <pre><code>import React, { useEffect } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { fetchProducts } from './actions';\n\nconst ProductPage = () =&gt; {\n    const dispatch = useDispatch();\n    const { products, loading, error } = useSelector(state =&gt; state.productReducer);\n\n    useEffect(() =&gt; {\n        dispatch(fetchProducts());\n    }, [dispatch]);\n\n    if (loading) return &lt;p&gt;Loading...&lt;/p&gt;;\n    if (error) return &lt;p&gt;Error: {error}&lt;/p&gt;;\n\n    return (\n        &lt;div&gt;\n            {products.map(product =&gt; (\n                &lt;div key={product.id}&gt;\n                    &lt;h2&gt;{product.name}&lt;/h2&gt;\n                    &lt;p&gt;{product.description}&lt;/p&gt;\n                &lt;/div&gt;\n            ))}\n        &lt;/div&gt;\n    );\n};\n\nexport default ProductPage;\n</code></pre> </li> </ol> <p>Result:</p> <p>When the <code>ProductPage</code> component is mounted, the <code>fetchProducts</code> thunk is dispatched. It sends a request to the API, and depending on the outcome, either the product list or an error message is rendered.</p>"},{"location":"frontend/state-management/redux/redux-pattern/#scenario-2-handling-multiple-concurrent-api-calls-with-redux-saga","title":"Scenario 2: Handling Multiple Concurrent API Calls with Redux Saga","text":"<p>Scenario:</p> <p>Let\u2019s say you\u2019re developing a social media app. When a user logs in, you need to fetch their profile, notifications, and posts concurrently. If any of these requests fail, you want to retry the failed request up to 3 times.</p> <p>Step-by-Step Solution Using Redux Saga:</p> <ol> <li> <p>Set Up Action Types: Define action types for fetching the profile, notifications, and posts.</p> <pre><code>// actionTypes.js\nexport const FETCH_PROFILE_REQUEST = 'FETCH_PROFILE_REQUEST';\nexport const FETCH_PROFILE_SUCCESS = 'FETCH_PROFILE_SUCCESS';\nexport const FETCH_PROFILE_FAILURE = 'FETCH_PROFILE_FAILURE';\nexport const FETCH_NOTIFICATIONS_REQUEST = 'FETCH_NOTIFICATIONS_REQUEST';\nexport const FETCH_NOTIFICATIONS_SUCCESS = 'FETCH_NOTIFICATIONS_SUCCESS';\nexport const FETCH_NOTIFICATIONS_FAILURE = 'FETCH_NOTIFICATIONS_FAILURE';\nexport const FETCH_POSTS_REQUEST = 'FETCH_POSTS_REQUEST';\nexport const FETCH_POSTS_SUCCESS = 'FETCH_POSTS_SUCCESS';\nexport const FETCH_POSTS_FAILURE = 'FETCH_POSTS_FAILURE';\n</code></pre> </li> <li> <p>Create the API Call Functions: These functions will perform the actual API calls to fetch the data.</p> <pre><code>// api.js\nexport const fetchProfileApi = () =&gt; fetch('https://api.example.com/profile').then(res =&gt; res.json());\nexport const fetchNotificationsApi = () =&gt; fetch('https://api.example.com/notifications').then(res =&gt; res.json());\nexport const fetchPostsApi = () =&gt; fetch('https://api.example.com/posts').then(res =&gt; res.json());\n</code></pre> </li> <li> <p>Create the Saga with Retry Logic: The <code>yield</code> keyword allows us to handle async actions declaratively. We can use <code>all</code> to run multiple API requests concurrently and <code>retry</code> to handle failed requests.</p> <pre><code>import { call, put, all, retry } from 'redux-saga/effects';\nimport { FETCH_PROFILE_REQUEST, FETCH_PROFILE_SUCCESS, FETCH_PROFILE_FAILURE, FETCH_NOTIFICATIONS_REQUEST, FETCH_NOTIFICATIONS_SUCCESS, FETCH_NOTIFICATIONS_FAILURE, FETCH_POSTS_REQUEST, FETCH_POSTS_SUCCESS, FETCH_POSTS_FAILURE } from './actionTypes';\nimport { fetchProfileApi, fetchNotificationsApi, fetchPostsApi } from './api';\n\nfunction* fetchUserProfile() {\n    try {\n        const profile = yield retry(3, 1000, fetchProfileApi);  // Retry up to 3 times with 1-second intervals\n        yield put({ type: FETCH_PROFILE_SUCCESS, payload: profile });\n    } catch (error) {\n        yield put({ type: FETCH_PROFILE_FAILURE, payload: error.message });\n    }\n}\n\nfunction* fetchUserNotifications() {\n    try {\n        const notifications = yield retry(3, 1000, fetchNotificationsApi);\n        yield put({ type: FETCH_NOTIFICATIONS_SUCCESS, payload: notifications });\n    } catch (error) {\n        yield put({ type: FETCH_NOTIFICATIONS_FAILURE, payload: error.message });\n    }\n}\n\nfunction* fetchUserPosts() {\n    try {\n        const posts = yield retry(3, 1000, fetchPostsApi);\n        yield put({ type: FETCH_POSTS_SUCCESS, payload: posts });\n    } catch (error) {\n        yield put({ type: FETCH_POSTS_FAILURE, payload: error.message });\n    }\n}\n\nfunction* fetchUserData() {\n    yield all([\n        call(fetchUserProfile),\n        call(fetchUserNotifications),\n        call(fetchUserPosts),\n    ]);\n}\n\nexport default function* watchFetchUserData() {\n    yield takeLatest(FETCH_PROFILE_REQUEST, fetchUserData);\n}\n</code></pre> </li> <li> <p>Dispatch the Action: When the user logs in, dispatch the action to start fetching all required data.</p> <pre><code>// In a component or action creator\ndispatch({ type: FETCH_PROFILE_REQUEST });\n</code></pre> </li> </ol> <p>Result:</p> <p>The <code>fetchUserData</code> saga runs <code>fetchUserProfile</code>, <code>fetchUserNotifications</code>, and <code>fetchUserPosts</code> concurrently using <code>all()</code>. If any of these requests fail, they will be retried up to 3 times using <code>retry()</code>. Once all the requests have succeeded or failed, the appropriate success or failure actions are dispatched.</p>"},{"location":"frontend/state-management/redux/redux-pattern/#conclusion_1","title":"Conclusion:","text":"<ul> <li>Thunk Example: Perfect for handling simple API requests, ideal when the logic isn't too complex.</li> <li>Saga Example: Shows the power of Redux Saga in managing multiple asynchronous operations and more advanced control like retrying failed requests or handling concurrent actions.</li> </ul>"},{"location":"frontend/state-management/redux/redux-testing/","title":"Redux Testing","text":"<p>Great! Let\u2019s dive deeper into testing Redux Thunk and Redux Saga to ensure that your asynchronous operations behave as expected in real-world applications.</p>"},{"location":"frontend/state-management/redux/redux-testing/#testing-redux-thunk","title":"Testing Redux Thunk","text":"<p>When testing actions that use Redux Thunk, we can use a mock store to dispatch actions and check that the correct actions are being dispatched based on the asynchronous logic.</p> <ol> <li> <p>Testing Redux Thunk with Jest</p> <p>Scenario: You want to test the <code>fetchProducts</code> thunk action creator, which dispatches <code>FETCH_PRODUCTS_REQUEST</code>, <code>FETCH_PRODUCTS_SUCCESS</code>, or <code>FETCH_PRODUCTS_FAILURE</code> depending on the result of an API call.</p> <p>Test Setup:</p> <ul> <li>Mocking the API: We'll mock the API call to return some fake data.</li> <li>Mock Store: Use <code>redux-mock-store</code> to simulate Redux store behavior.</li> </ul> </li> </ol> <p>Code:</p> <ol> <li> <p>Install dependencies for testing:</p> <pre><code>npm install redux-mock-store redux-thunk jest --save-dev\n</code></pre> </li> <li> <p>Write the Test for Redux Thunk:</p> ExampleHow the Test Works <pre><code>import configureMockStore from 'redux-mock-store';\nimport thunk from 'redux-thunk';\nimport fetchMock from 'jest-fetch-mock'; // To mock fetch API\nimport { fetchProducts } from './actions'; // Thunk action\nimport { FETCH_PRODUCTS_REQUEST, FETCH_PRODUCTS_SUCCESS, FETCH_PRODUCTS_FAILURE } from './actionTypes';\n\nconst middlewares = [thunk];\nconst mockStore = configureMockStore(middlewares);\n\ndescribe('fetchProducts action', () =&gt; {\n    beforeEach(() =&gt; {\n        fetchMock.resetMocks();\n    });\n\n    it('dispatches FETCH_PRODUCTS_SUCCESS after a successful API request', () =&gt; {\n        const mockProducts = [{ id: 1, name: 'Product 1' }, { id: 2, name: 'Product 2' }];\n        fetchMock.mockResponseOnce(JSON.stringify(mockProducts));\n\n        const expectedActions = [\n            { type: FETCH_PRODUCTS_REQUEST },\n            { type: FETCH_PRODUCTS_SUCCESS, payload: mockProducts },\n        ];\n\n        const store = mockStore({ products: [] });\n\n        return store.dispatch(fetchProducts()).then(() =&gt; {\n            expect(store.getActions()).toEqual(expectedActions);\n        });\n    });\n\n    it('dispatches FETCH_PRODUCTS_FAILURE when the API request fails', () =&gt; {\n        const errorMessage = 'Failed to fetch';\n        fetchMock.mockRejectOnce(new Error(errorMessage));\n\n        const expectedActions = [\n            { type: FETCH_PRODUCTS_REQUEST },\n            { type: FETCH_PRODUCTS_FAILURE, payload: errorMessage },\n        ];\n\n        const store = mockStore({ products: [] });\n\n        return store.dispatch(fetchProducts()).then(() =&gt; {\n            expect(store.getActions()).toEqual(expectedActions);\n        });\n    });\n});\n</code></pre> <ul> <li>Mock Store: <code>redux-mock-store</code> creates a mock version of the Redux store.</li> <li>Action Sequence: The test ensures that the correct sequence of actions (<code>FETCH_PRODUCTS_REQUEST</code>, <code>FETCH_PRODUCTS_SUCCESS</code>, or    <code>FETCH_PRODUCTS_FAILURE</code>) is dispatched based on the result of the API call.</li> <li>Mock API Response: We use <code>fetchMock</code> to simulate different API responses (success and failure).</li> </ul> </li> </ol>"},{"location":"frontend/state-management/redux/redux-testing/#testing-redux-saga","title":"Testing Redux Saga","text":"<p>Testing Redux Saga involves verifying the flow of effects (<code>call</code>, <code>put</code>, <code>take</code>, etc.). We can use a library like <code>redux-saga-test-plan</code> to test sagas in isolation.</p> <ol> <li> <p>Testing Redux Saga with Jest and redux-saga-test-plan</p> <p>Scenario: You want to test the <code>fetchUserData</code> saga, which fetches the user profile, notifications, and posts concurrently. You also want to ensure it retries the API calls up to 3 times if they fail.</p> </li> </ol> <p>Code:</p> <ol> <li> <p>Install the necessary testing libraries:</p> <pre><code>npm install redux-saga-test-plan jest --save-dev\n</code></pre> </li> <li> <p>Write the Test for Redux Saga:</p> ExampleHow the Test Works <pre><code>import { testSaga } from 'redux-saga-test-plan';\nimport { fetchUserData } from './sagas';\nimport { fetchProfileApi, fetchNotificationsApi, fetchPostsApi } from './api';\nimport { FETCH_PROFILE_SUCCESS, FETCH_NOTIFICATIONS_SUCCESS, FETCH_POSTS_SUCCESS } from './actionTypes';\n\ndescribe('fetchUserData saga', () =&gt; {\n    it('fetches profile, notifications, and posts concurrently', () =&gt; {\n        const mockProfile = { name: 'John Doe' };\n        const mockNotifications = [{ id: 1, message: 'New notification' }];\n        const mockPosts = [{ id: 1, content: 'New post' }];\n\n        testSaga(fetchUserData)\n            .next()\n            .all([\n                call(fetchProfileApi),\n                call(fetchNotificationsApi),\n                call(fetchPostsApi),\n            ])\n            .next([mockProfile, mockNotifications, mockPosts])\n            .put({ type: FETCH_PROFILE_SUCCESS, payload: mockProfile })\n            .next()\n            .put({ type: FETCH_NOTIFICATIONS_SUCCESS, payload: mockNotifications })\n            .next()\n            .put({ type: FETCH_POSTS_SUCCESS, payload: mockPosts })\n            .next()\n            .isDone();\n    });\n\n    it('retries API calls up to 3 times if they fail', () =&gt; {\n        const error = new Error('API error');\n\n        testSaga(fetchUserData)\n            .next()\n            .all([\n                retry(3, 1000, fetchProfileApi),\n                retry(3, 1000, fetchNotificationsApi),\n                retry(3, 1000, fetchPostsApi),\n            ])\n            .throw(error)\n            .put({ type: FETCH_PROFILE_FAILURE, payload: error.message })\n            .next()\n            .isDone();\n    });\n});\n</code></pre> <ul> <li>Test Flow: <code>redux-saga-test-plan</code> allows you to simulate the exact flow of your saga and assert each step (<code>call</code>, <code>put</code>, etc.).</li> <li>Concurrent API Calls: We use <code>all()</code> to test that profile, notifications, and posts are fetched concurrently.</li> <li>Retry Mechanism: The second test ensures that the API call retries up to 3 times using the <code>retry()</code> effect.</li> </ul> </li> </ol>"},{"location":"frontend/state-management/redux/redux-testing/#testing-best-practices-for-redux-thunk-and-redux-saga","title":"Testing Best Practices for Redux Thunk and Redux Saga","text":"<ol> <li> <p>Mock External Dependencies:</p> <ul> <li>For Thunk, mock API calls using <code>jest-fetch-mock</code> or similar libraries.</li> <li>For Saga, use <code>redux-saga-test-plan</code> to simulate effects and test the sequence of actions.</li> </ul> </li> <li> <p>Test Action Sequences:</p> <ul> <li>Ensure the correct actions are dispatched in the expected order.</li> <li>For complex flows, check that the appropriate success or failure actions are dispatched based on the outcome.</li> </ul> </li> <li> <p>Isolate Logic:</p> <ul> <li>Test action creators, reducers, and sagas separately to ensure that each piece of logic works independently before testing them together.</li> </ul> </li> </ol>"},{"location":"frontend/state-management/redux/redux-testing/#summary","title":"Summary:","text":"<ul> <li>Thunk Testing: Use <code>redux-mock-store</code> to mock the Redux store and simulate dispatching asynchronous actions.</li> <li>Saga Testing: Use <code>redux-saga-test-plan</code> to test the flow of saga effects like <code>call</code>, <code>put</code>, and <code>all()</code>, and simulate advanced logic such as retries.</li> </ul>"},{"location":"frontend/state-management/redux/redux-testing/#testing-reducers","title":"Testing Reducers","text":"<p>Reducers are pure functions in Redux, meaning they should always produce the same output given the same input. This makes them easy to test. The goal of testing reducers is to ensure that they correctly update the state based on the dispatched actions.</p>"},{"location":"frontend/state-management/redux/redux-testing/#1-basic-structure-of-a-reducer","title":"1.  Basic Structure of a Reducer","text":"<pre><code>Let\u2019s say you have a reducer that handles fetching products:\n\n```jsx\nconst initialState = {\n    products: [],\n    loading: false,\n    error: null,\n};\n\nfunction productReducer(state = initialState, action) {\n    switch (action.type) {\n        case 'FETCH_PRODUCTS_REQUEST':\n            return { ...state, loading: true };\n        case 'FETCH_PRODUCTS_SUCCESS':\n            return { ...state, loading: false, products: action.payload };\n        case 'FETCH_PRODUCTS_FAILURE':\n            return { ...state, loading: false, error: action.payload };\n        default:\n            return state;\n    }\n}\n```\n</code></pre>"},{"location":"frontend/state-management/redux/redux-testing/#writing-unit-tests-for-reducers","title":"Writing Unit Tests for Reducers","text":"<p>Testing reducers is straightforward because they are pure functions. You only need to call the reducer with an action and an initial state, and then check if the output matches the expected state.</p>"},{"location":"frontend/state-management/redux/redux-testing/#2-writing-tests-for-the-product-reducer","title":"2.  Writing Tests for the Product Reducer","text":"<p>Here\u2019s an example of how you would test this reducer using Jest:</p> <pre><code>import productReducer from './productReducer';\n\ndescribe('Product Reducer', () =&gt; {\n  const initialState = {\n    products: [],\n    loading: false,\n    error: null,\n  };\n\n  it('should return the initial state', () =&gt; {\n    expect(productReducer(undefined, {})).toEqual(initialState);\n  });\n\n  it('should handle FETCH_PRODUCTS_REQUEST', () =&gt; {\n    const action = { type: 'FETCH_PRODUCTS_REQUEST' };\n    const expectedState = { ...initialState, loading: true };\n    expect(productReducer(initialState, action)).toEqual(expectedState);\n  });\n\n  it('should handle FETCH_PRODUCTS_SUCCESS', () =&gt; {\n    const action = {\n      type: 'FETCH_PRODUCTS_SUCCESS',\n      payload: [{ id: 1, name: 'Product 1' }],\n    };\n    const expectedState = {\n      ...initialState,\n      loading: false,\n      products: action.payload,\n    };\n    expect(productReducer(initialState, action)).toEqual(expectedState);\n  });\n\n  it('should handle FETCH_PRODUCTS_FAILURE', () =&gt; {\n    const action = { type: 'FETCH_PRODUCTS_FAILURE', payload: 'Error' };\n    const expectedState = {\n      ...initialState,\n      loading: false,\n      error: 'Error',\n    };\n    expect(productReducer(initialState, action)).toEqual(expectedState);\n  });\n});\n</code></pre>"},{"location":"frontend/state-management/redux/redux-testing/#best-practices-for-testing-reducers","title":"Best Practices for Testing Reducers","text":"<ol> <li> <p>Test for Default State:</p> <ul> <li> <p>Always test that the reducer returns the initial state when the state is <code>undefined</code> and the action is irrelevant (e.g., <code>{}</code>).</p> <pre><code>it('should return the initial state', () =&gt; {\n    expect(productReducer(undefined, {})).toEqual(initialState);\n});\n</code></pre> </li> </ul> </li> <li> <p>Test Each Action Type:</p> <ul> <li>Write a test case for each action type the reducer handles (<code>FETCH_PRODUCTS_REQUEST</code>, <code>FETCH_PRODUCTS_SUCCESS</code>, etc.). Ensure the state is updated as expected.</li> </ul> </li> <li> <p>Use Mocks for Action Payloads:</p> <ul> <li> <p>If an action payload is complex (e.g., an array of products), use mock data to ensure the test is focused on the reducer logic.</p> <pre><code>const action = {\n    type: 'FETCH_PRODUCTS_SUCCESS',\n    payload: [{ id: 1, name: 'Mock Product' }],\n};\n</code></pre> </li> </ul> </li> <li> <p>Test Edge Cases:</p> <ul> <li>Consider testing edge cases like actions that are dispatched with unexpected payloads or malformed data.</li> </ul> </li> <li> <p>Avoid Testing Built-in Functions:</p> <ul> <li>Don\u2019t test things like <code>Object.assign</code> or spread operators (<code>...</code>), as these are built-in JavaScript features. Focus on testing that your reducer logic is correct.</li> </ul> </li> </ol>"},{"location":"frontend/state-management/redux/redux-testing/#testing-redux-with-thunk-saga-and-reducers-summary","title":"Testing Redux with Thunk, Saga, and Reducers: Summary","text":"<p>Now that you\u2019ve seen how to test thunks, sagas, and reducers, here\u2019s a summary of the flow:</p> <ol> <li> <p>Thunks:</p> <ul> <li>Use <code>redux-mock-store</code> to mock the Redux store.</li> <li>Mock external dependencies like APIs and verify that the correct actions are dispatched based on asynchronous logic.</li> </ul> </li> <li> <p>Sagas:</p> <ul> <li>Use <code>redux-saga-test-plan</code> to simulate effects and check the flow of your saga (e.g., concurrent API calls, retry logic).</li> <li>Focus on verifying the flow of effects (<code>call</code>, <code>put</code>, etc.).</li> </ul> </li> <li> <p>Reducers:</p> <ul> <li>Test reducers by dispatching different actions and ensuring the state is updated correctly.</li> <li>Write one test per action type, ensuring each action\u2019s impact on the state is validated.</li> </ul> </li> </ol> <p>Awesome! Let\u2019s move into testing React components that connect to Redux and handle more advanced testing scenarios, such as dealing with components that rely on Redux state and actions.</p>"},{"location":"frontend/state-management/redux/redux-testing/#testing-react-components-connected-to-redux","title":"Testing React Components Connected to Redux","text":"<p>When testing React components that are connected to Redux, we need to ensure:</p> <ol> <li>The component renders correctly with the expected state from Redux.</li> <li>The component dispatches the correct actions when interacting with UI elements (e.g., clicking buttons).</li> </ol> <p>We'll use <code>react-testing-library</code> (or <code>@testing-library/react</code>) and <code>redux-mock-store</code> to test connected components without relying on a real Redux store.</p>"},{"location":"frontend/state-management/redux/redux-testing/#1-basic-structure-of-a-connected-component","title":"1. Basic Structure of a Connected Component","text":"<p>Let\u2019s assume we have a React component, <code>ProductList</code>, which is connected to Redux. It fetches products from the store and displays them, and it also has a button to reload the products.</p> <pre><code>import React, { useEffect } from 'react';\nimport { connect } from 'react-redux';\nimport { fetchProducts } from './actions';\n\nconst ProductList = ({ products, loading, fetchProducts }) =&gt; {\n  useEffect(() =&gt; {\n    fetchProducts(); // Fetch products when component mounts\n  }, [fetchProducts]);\n\n  if (loading) {\n    return &lt;div&gt;Loading...&lt;/div&gt;;\n  }\n\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Product List&lt;/h2&gt;\n      &lt;ul&gt;\n        {products.map((product) =&gt; (\n          &lt;li key={product.id}&gt;{product.name}&lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n      &lt;button onClick={fetchProducts}&gt;Reload Products&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nconst mapStateToProps = (state) =&gt; ({\n  products: state.products.items,\n  loading: state.products.loading,\n});\n\nexport default connect(mapStateToProps, { fetchProducts })(ProductList);\n</code></pre>"},{"location":"frontend/state-management/redux/redux-testing/#2-writing-tests-for-the-connected-component","title":"2. Writing Tests for the Connected Component","text":"<p>We\u2019ll test two scenarios:</p> <ol> <li>Rendering the component with initial state.</li> <li>Simulating a button click to dispatch the <code>fetchProducts</code> action.</li> </ol> <p>Setting Up Tests for Connected Components</p> <ol> <li> <p>Install necessary libraries:</p> <pre><code>npm install @testing-library/react redux-mock-store jest --save-dev\n</code></pre> </li> <li> <p>Writing Tests with Mock Redux Store:</p> <p>We can use a mock Redux store to simulate different states in our tests. Here\u2019s how to set it up.</p> ExampleExplanation <pre><code>import React from 'react';\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport configureMockStore from 'redux-mock-store';\nimport { Provider } from 'react-redux';\nimport ProductList from './ProductList'; // The connected component\nimport thunk from 'redux-thunk';\n\n// Mock store\nconst middlewares = [thunk];\nconst mockStore = configureMockStore(middlewares);\n\ndescribe('ProductList Component', () =&gt; {\n    let store;\n\n    beforeEach(() =&gt; {\n        // Initial mock state\n        store = mockStore({\n            products: {\n                items: [{ id: 1, name: 'Product 1' }, { id: 2, name: 'Product 2' }],\n                loading: false,\n            },\n        });\n    });\n\n    it('should render product list with products from Redux state', () =&gt; {\n        render(\n            &lt;Provider store={store}&gt;\n                &lt;ProductList /&gt;\n            &lt;/Provider&gt;\n        );\n\n        expect(screen.getByText('Product List')).toBeInTheDocument();\n        expect(screen.getByText('Product 1')).toBeInTheDocument();\n        expect(screen.getByText('Product 2')).toBeInTheDocument();\n    });\n\n    it('should dispatch fetchProducts action when \"Reload Products\" button is clicked', () =&gt; {\n        render(\n            &lt;Provider store={store}&gt;\n                &lt;ProductList /&gt;\n            &lt;/Provider&gt;\n        );\n\n        const reloadButton = screen.getByText('Reload Products');\n        fireEvent.click(reloadButton);\n\n        const actions = store.getActions();\n        expect(actions).toEqual([{ type: 'FETCH_PRODUCTS_REQUEST' }]); // Adjust depending on the action dispatched\n    });\n\n    it('should show loading message when fetching products', () =&gt; {\n        store = mockStore({\n            products: { items: [], loading: true },\n        });\n\n        render(\n            &lt;Provider store={store}&gt;\n                &lt;ProductList /&gt;\n            &lt;/Provider&gt;\n        );\n\n        expect(screen.getByText('Loading...')).toBeInTheDocument();\n    });\n});\n</code></pre> <ol> <li>Mock Store: We create a mock Redux store with an initial state that mimics the real state in your app.</li> <li>Provider: Wrap the component in the Redux <code>Provider</code> and pass the mock store.</li> <li> <p>Assertions:</p> <ul> <li>Check if the component correctly renders data from the mock Redux state.</li> <li>Simulate a button click and verify if the correct action is dispatched.</li> </ul> </li> </ol> </li> </ol>"},{"location":"frontend/state-management/redux/redux-testing/#best-practices-for-testing-connected-components","title":"Best Practices for Testing Connected Components:","text":"<ul> <li>Mock the Store: Use a mock store to simulate various Redux states (loading, error, etc.) to thoroughly test how your component handles different scenarios.</li> <li>Test Action Dispatching: Simulate user interactions (like clicking a button) and verify if the correct Redux actions are dispatched.</li> <li>Isolate UI Logic: Focus on testing the UI\u2019s interaction with Redux, not the internal logic of actions or reducers. These can be tested separately.</li> </ul>"},{"location":"frontend/state-management/redux/redux-testing/#advanced-testing-scenarios-for-redux-connected-components","title":"Advanced Testing Scenarios for Redux-Connected Components","text":"<ol> <li> <p>Testing with Nested States:</p> <ul> <li> <p>If your Redux state has nested objects (e.g., <code>state.products.items</code>), ensure that you correctly mock and test the nested structure.</p> <pre><code>// Example for a deeply nested state:\n\nstore = mockStore({\n    products: {\n        data: {\n            items: [{ id: 1, name: 'Product 1' }],\n        },\n        loading: false,\n    },\n});\n</code></pre> </li> </ul> </li> <li> <p>Testing with Selectors:</p> <ul> <li> <p>If you\u2019re using selectors to derive data from the Redux store, you should mock the selector\u2019s output and test how the component renders based on it.</p> <pre><code>import { getVisibleProducts } from './selectors';\njest.mock('./selectors');\n\nit('should render visible products', () =&gt; {\n    getVisibleProducts.mockReturnValue([{ id: 1, name: 'Visible Product' }]);\n\n    render(\n        &lt;Provider store={store}&gt;\n        &lt;ProductList /&gt;\n        &lt;/Provider&gt;\n    );\n\n    expect(screen.getByText('Visible Product')).toBeInTheDocument();\n});\n</code></pre> </li> </ul> </li> <li> <p>Testing Middleware:</p> <ul> <li> <p>If you\u2019re using custom middleware or middleware like redux-thunk, ensure you test the interaction with middleware by checking the actions that are dispatched as a result of user interactions.</p> <pre><code>const middlewares = [thunk]; // Include middleware in mock store setup\n</code></pre> </li> </ul> </li> <li> <p>Testing Complex Interactions:</p> <ul> <li>For more complex interactions, simulate multiple steps (e.g., multiple button clicks or form submissions) and verify that the state and actions evolve correctly.</li> </ul> <p>Example: Testing a multi-step form that dispatches multiple actions:</p> <pre><code>fireEvent.click(screen.getByText('Next Step'));\nexpect(store.getActions()).toEqual([\n    { type: 'STEP_1_COMPLETE' },\n    { type: 'LOAD_NEXT_STEP' },\n]);\n</code></pre> </li> </ol> <p>Great! Let\u2019s dive into middleware testing and mocking API calls within Redux-connected components to handle asynchronous behavior.</p>"},{"location":"frontend/state-management/redux/redux-testing/#testing-middleware-in-redux","title":"Testing Middleware in Redux","text":"<p>Middleware in Redux is used to extend the functionality of the Redux store, allowing you to intercept actions before they reach the reducers. Common middleware like redux-thunk and redux-saga enable handling side effects such as API calls.</p>"},{"location":"frontend/state-management/redux/redux-testing/#1-testing-thunk-middleware","title":"1. Testing Thunk Middleware","text":"<p>If you're using redux-thunk for async operations (like API calls), you\u2019ll often want to ensure that:</p> <ul> <li>Correct actions are dispatched before and after the async logic (e.g., <code>LOADING</code>, <code>SUCCESS</code>, <code>ERROR</code>).</li> <li>The API calls (or any async logic) are correctly mocked.</li> </ul> <p>Example: Async Action with Thunk</p> <p>Let\u2019s assume you have a simple thunk that fetches products from an API:</p> <pre><code>// actions.js\nexport const fetchProducts = () =&gt; {\n  return async (dispatch) =&gt; {\n    dispatch({ type: 'FETCH_PRODUCTS_REQUEST' });\n    try {\n      const response = await fetch('/api/products');\n      const data = await response.json();\n      dispatch({ type: 'FETCH_PRODUCTS_SUCCESS', payload: data });\n    } catch (error) {\n      dispatch({ type: 'FETCH_PRODUCTS_FAILURE', payload: error.message });\n    }\n  };\n};\n</code></pre> <p>Writing Tests for Thunks</p> <p>To test this, we mock the API call and check that the right actions are dispatched.</p> <pre><code>import configureMockStore from 'redux-mock-store';\nimport thunk from 'redux-thunk';\nimport fetchMock from 'jest-fetch-mock'; // or axios-mock-adapter if you use axios\nimport { fetchProducts } from './actions';\n\n// Setup mock store\nconst middlewares = [thunk];\nconst mockStore = configureMockStore(middlewares);\n\ndescribe('fetchProducts thunk', () =&gt; {\n  beforeEach(() =&gt; {\n    fetchMock.resetMocks(); // Reset mock fetch calls\n  });\n\n  it('should dispatch FETCH_PRODUCTS_SUCCESS after successful API call', async () =&gt; {\n    // Mock the API response\n    fetchMock.mockResponseOnce(\n      JSON.stringify([{ id: 1, name: 'Product 1' }])\n    );\n\n    const expectedActions = [\n      { type: 'FETCH_PRODUCTS_REQUEST' },\n      {\n        type: 'FETCH_PRODUCTS_SUCCESS',\n        payload: [{ id: 1, name: 'Product 1' }],\n      },\n    ];\n\n    const store = mockStore({ products: [] });\n\n    await store.dispatch(fetchProducts());\n\n    expect(store.getActions()).toEqual(expectedActions);\n  });\n\n  it('should dispatch FETCH_PRODUCTS_FAILURE after a failed API call', async () =&gt; {\n    // Mock a failed API response\n    fetchMock.mockReject(new Error('Failed to fetch'));\n\n    const expectedActions = [\n      { type: 'FETCH_PRODUCTS_REQUEST' },\n      { type: 'FETCH_PRODUCTS_FAILURE', payload: 'Failed to fetch' },\n    ];\n\n    const store = mockStore({ products: [] });\n\n    await store.dispatch(fetchProducts());\n\n    expect(store.getActions()).toEqual(expectedActions);\n  });\n});\n</code></pre> <p>??+ note \"Key Points\"</p> <pre><code>1.  **Mocking API calls**:\n\n    -   Use `fetch-mock` or `axios-mock-adapter` to simulate successful and failed API responses.\n\n2.  **Asserting Dispatched Actions**:\n\n    -   Verify that the correct actions (e.g., `REQUEST`, `SUCCESS`, `FAILURE`) are dispatched in the right order based on the API call.\n</code></pre>"},{"location":"frontend/state-management/redux/redux-testing/#2-testing-redux-saga-middleware","title":"2. Testing Redux Saga Middleware","text":"<p>If you\u2019re using redux-saga for side effects, testing involves simulating the side effects and asserting the correct sequence of events (e.g., dispatching actions, making API calls).</p> <p>Saga Example</p> <p>Let\u2019s say you have a saga that fetches products:</p> <pre><code>// sagas.js\nimport { call, put, takeEvery } from 'redux-saga/effects';\n\nfunction* fetchProductsSaga() {\n  try {\n    yield put({ type: 'FETCH_PRODUCTS_REQUEST' });\n    const response = yield call(fetch, '/api/products');\n    const data = yield call([response, 'json']);\n    yield put({ type: 'FETCH_PRODUCTS_SUCCESS', payload: data });\n  } catch (error) {\n    yield put({ type: 'FETCH_PRODUCTS_FAILURE', payload: error.message });\n  }\n}\n\nexport function* watchFetchProducts() {\n  yield takeEvery('FETCH_PRODUCTS', fetchProductsSaga);\n}\n</code></pre> <p>Testing Sagas with <code>redux-saga-test-plan</code></p> <p>The <code>redux-saga-test-plan</code> library simplifies testing sagas by allowing you to simulate effects and assert their behavior.</p> <ol> <li> <p>Install the library:</p> <pre><code>npm install redux-saga-test-plan --save-dev\n</code></pre> </li> <li> <p>Writing Tests for the Saga:</p> <p>Here\u2019s how you can test the <code>fetchProductsSaga</code>:</p> ExampleKey Points for Saga Testing <pre><code>import { runSaga } from 'redux-saga';\nimport { fetchProductsSaga } from './sagas';\nimport fetchMock from 'jest-fetch-mock';\n\ndescribe('fetchProductsSaga', () =&gt; {\n    beforeEach(() =&gt; {\n        fetchMock.resetMocks(); // Reset mock fetch calls\n    });\n\n    it('should dispatch success action after fetching products', async () =&gt; {\n        // Mock API response\n        fetchMock.mockResponseOnce(JSON.stringify([{ id: 1, name: 'Product 1' }]));\n\n        const dispatchedActions = [];\n\n        // Run the saga\n        await runSaga(\n            {\n                dispatch: (action) =&gt; dispatchedActions.push(action),\n            },\n            fetchProductsSaga\n        ).toPromise();\n\n        expect(dispatchedActions).toContainEqual({\n            type: 'FETCH_PRODUCTS_SUCCESS',\n            payload: [{ id: 1, name: 'Product 1' }],\n        });\n    });\n\n    it('should dispatch failure action if API call fails', async () =&gt; {\n        // Mock API error\n        fetchMock.mockReject(new Error('API Error'));\n\n        const dispatchedActions = [];\n\n        // Run the saga\n        await runSaga(\n            {\n                dispatch: (action) =&gt; dispatchedActions.push(action),\n            },\n            fetchProductsSaga\n        ).toPromise();\n\n        expect(dispatchedActions).toContainEqual({\n            type: 'FETCH_PRODUCTS_FAILURE',\n            payload: 'API Error',\n        });\n    });\n});\n</code></pre> <ol> <li> <p>Use runSaga:</p> <ul> <li>Run your saga with mocked <code>dispatch</code> and <code>state</code> functions to simulate side effects.</li> </ul> </li> <li> <p>Mock API Calls:</p> <ul> <li>Mock the API calls (or any other side effects) to ensure that your saga correctly handles both success and failure cases.</li> </ul> </li> <li> <p>Verify Dispatched Actions:</p> <ul> <li>After running the saga, check that the correct actions were dispatched (e.g., <code>SUCCESS</code>, <code>FAILURE</code>).</li> </ul> </li> </ol> </li> </ol>"},{"location":"frontend/state-management/redux/redux-testing/#mocking-api-calls-in-redux-connected-components","title":"Mocking API Calls in Redux-Connected Components","text":"<p>Testing components that rely on async data (like API calls) means you need to mock those API responses and ensure the component behaves correctly.</p> <p>Example: ProductList Component with Thunk</p> <p>Let\u2019s take the <code>ProductList</code> component and test it with mocked API calls:</p> <pre><code>import React, { useEffect } from 'react';\nimport { connect } from 'react-redux';\nimport { fetchProducts } from './actions';\n\nconst ProductList = ({ products, loading, fetchProducts }) =&gt; {\n  useEffect(() =&gt; {\n    fetchProducts();\n  }, [fetchProducts]);\n\n  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Product List&lt;/h2&gt;\n      &lt;ul&gt;\n        {products.map((product) =&gt; (\n          &lt;li key={product.id}&gt;{product.name}&lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n      &lt;button onClick={fetchProducts}&gt;Reload Products&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nconst mapStateToProps = (state) =&gt; ({\n  products: state.products.items,\n  loading: state.products.loading,\n});\n\nexport default connect(mapStateToProps, { fetchProducts })(ProductList);\n</code></pre>"},{"location":"frontend/state-management/redux/redux-testing/#testing-the-component-with-api-calls","title":"Testing the Component with API Calls","text":"<p>We\u2019ll mock the API call and test the component rendering.</p> <pre><code>import React from 'react';\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport { Provider } from 'react-redux';\nimport configureMockStore from 'redux-mock-store';\nimport thunk from 'redux-thunk';\nimport fetchMock from 'jest-fetch-mock';\nimport ProductList from './ProductList';\n\n// Mock store and thunk middleware\nconst middlewares = [thunk];\nconst mockStore = configureMockStore(middlewares);\n\ndescribe('ProductList Component', () =&gt; {\n  let store;\n\n  beforeEach(() =&gt; {\n    fetchMock.resetMocks(); // Reset the fetch mocks before each test\n\n    store = mockStore({\n      products: { items: [], loading: false },\n    });\n  });\n\n  it('should fetch and display products', async () =&gt; {\n    // Mock the API response\n    fetchMock.mockResponseOnce(\n      JSON.stringify([{ id: 1, name: 'Product 1' }])\n    );\n\n    render(\n      &lt;Provider store={store}&gt;\n        &lt;ProductList /&gt;\n      &lt;/Provider&gt;\n    );\n\n    // Simulate component mounting and fetching products\n    expect(fetchMock).toHaveBeenCalledTimes(1); // Ensure the API call was made\n\n    // Assert that the product is rendered\n    expect(await screen.findByText('Product 1')).toBeInTheDocument();\n  });\n\n  it('should display loading state', () =&gt; {\n    store = mockStore({\n      products: { items: [], loading: true },\n    });\n\n    render(\n      &lt;Provider store={store}&gt;\n        &lt;ProductList /&gt;\n      &lt;/Provider&gt;\n    );\n\n    expect(screen.getByText('Loading...')).toBeInTheDocument();\n  });\n});\n</code></pre>"},{"location":"frontend/state-management/redux/redux-testing/#summary_1","title":"Summary:","text":"<ul> <li>Thunk Testing: Simulate API calls and check dispatched actions using a mock store.</li> <li>Saga Testing: Use <code>runSaga</code> to execute sagas and assert the side effects.</li> <li>Component Testing: Mock API calls using fetchMock or similar tools and verify the component behavior.</li> </ul>"},{"location":"frontend/state-management/redux/action/intro/","title":"Intro","text":""},{"location":"frontend/state-management/redux/action/intro/#what-is-an-action-in-redux","title":"What is an Action in Redux?","text":"<p>In Redux, an action is a plain JavaScript object that represents an event or change that happened in the application. It is the only source of information for the store, meaning all state changes in the store are triggered by actions.</p> <p>An action has two key properties:</p> <ul> <li>type: A string that defines the type of action (e.g., 'ADD_TODO', 'FETCH_DATA_SUCCESS'). This is mandatory.</li> <li>payload (optional): An additional data object that contains the information needed to perform the action (e.g., the todo item or fetched data).</li> </ul> Basic Example of an Action <pre><code>// Simple action to add a todo\nconst addTodoAction = {\n    type: 'ADD_TODO',               // Mandatory 'type' field\n    payload: {\n        text: 'Learn Redux',        // Optional 'payload' field containing data\n        id: 1\n    }\n};\n</code></pre> <p>The type field tells the Redux store what happened, and the payload field holds the data related to the action.</p> How Actions Work in Redux <ol> <li>Dispatch: Actions are dispatched from the UI or other parts of the app.</li> <li>Reducer: The action is passed to the reducer, which determines how the state should change based on the action's type.</li> <li>State Update: The store updates the state according to the reducer's instructions.</li> </ol>"},{"location":"frontend/state-management/redux/action/intro/#action-creator","title":"Action Creator","text":"<p>An action creator is a function that returns an action. It simplifies creating actions and helps avoid manually creating action objects.</p> <pre><code>// Action Creator to add a todo\nconst addTodo = (todo) =&gt; ({\n    type: 'ADD_TODO',\n    payload: { todo }\n});\n</code></pre> Using Action in a Component <pre><code>import React from 'react';\nimport { useDispatch } from 'react-redux';\nimport { addTodo } from './actions/todoActions';\n\nconst TodoComponent = () =&gt; {\n    const dispatch = useDispatch();\n\n    const handleAddTodo = () =&gt; {\n        const newTodo = { text: 'Learn Redux Basics', id: 1 };\n        dispatch(addTodo(newTodo)); // Dispatching the action\n    };\n\n    return (\n        &lt;button onClick={handleAddTodo}&gt;Add Todo&lt;/button&gt;\n    );\n};\n</code></pre> Simple Reducer Example <pre><code>const todoReducer = (state = { todos: [] }, action) =&gt; {\n    switch (action.type) {\n        case 'ADD_TODO':\n            return {\n                ...state,\n                todos: [...state.todos, action.payload.todo],\n            };\n        default:\n            return state;\n    }\n};\n</code></pre>"},{"location":"frontend/state-management/redux/action/intro/#difference-between-plain-action-action-creator","title":"Difference between plain action &amp; action creator","text":"<p>In Redux, actions and action creators are related but distinct concepts:</p>"},{"location":"frontend/state-management/redux/action/intro/#action","title":"Action","text":"<p>An action is a plain JavaScript object that describes a change or event in your application. It has at least one required property:</p> <ul> <li>type: A string that specifies the action type (e.g., 'ADD_TODO').</li> </ul> <p>Optionally, it can also include other properties:</p> <ul> <li>payload: Additional data needed to describe the action (e.g., the new todo item).</li> </ul> Example of an Action:<pre><code>// actions/todoActions.js (if you want to keep it organized)\nexport const addTodoAction = {\n    type: 'ADD_TODO',\n    payload: {\n        text: 'Learn Redux',\n        id: 1\n    }\n}\n// Usage in component\nconst handleAddTodo = () =&gt; {\n    dispatch(addTodoAction); // Dispatch the plain action object\n};\n</code></pre>"},{"location":"frontend/state-management/redux/action/intro/#action-creator_1","title":"Action Creator","text":"<p>An action creator is a function that creates and returns an action. It abstracts away the action object creation process and makes it easier to generate actions with the right structure.</p> <p>Action creators simplify creating actions and are useful for:</p> <ul> <li>Consistent action creation.</li> <li>Dynamically generating actions with specific payloads.</li> <li>Avoiding typos in action types.</li> </ul> <pre><code>// actions/todoActions.js (if you want to keep it organized)\nconst addTodo = (todo) =&gt; ({\n    type: 'ADD_TODO',\n    payload: todo\n});\n\n// Usage\nconst handleAddTodo = () =&gt; {\n  const newTodo = { text: 'Learn Redux', id: 1 };\n  dispatch(addTodo(newTodo)); // Using action creator\n};\n</code></pre> Summary <ul> <li>Action: A plain object that represents an event or change in the application. It has a type and optionally other properties like payload.</li> <li>Action Creator: A function that returns an action object. It helps in creating actions with the right structure and potentially dynamic data.</li> </ul> <p>In practice, action creators are commonly used in Redux applications because they provide a clear and consistent way to create actions and often handle complex logic for creating action objects.</p>"},{"location":"frontend/state-management/redux/action/intro/#tips-and-tricks-for-redux-actions","title":"Tips and Tricks for Redux Actions","text":"<ol> <li> <p>Action Types as Constants:</p> <ul> <li> <p>Use constants for action types to prevent typos and make refactoring easier.</p> <pre><code>export const ADD_TODO = 'ADD_TODO';\n</code></pre> </li> </ul> </li> <li> <p>Batched Actions:</p> <ul> <li> <p>Instead of dispatching multiple actions in sequence, you can batch them together.</p> <pre><code>const addTodoAndLog = (todo) =&gt; {\n    return (dispatch) =&gt; {\n        dispatch(addTodoAction(todo));\n        dispatch(logAction(todo));\n    };\n};\n</code></pre> </li> </ul> </li> </ol>"},{"location":"frontend/state-management/redux/reducer/example/","title":"Example","text":"<p>Facebook's developers follow a modular and organized approach to manage action types in their projects. Here is a closer look at how Facebook's React and Redux codebases might handle action types, inspired by best practices from projects like React and React Native.</p>"},{"location":"frontend/state-management/redux/reducer/example/#directory-structure","title":"Directory Structure","text":"<p>Let's assume a structure similar to how a large project at Facebook might be organized:</p> <pre><code>src/\n\u251c\u2500\u2500 actions/\n\u2502   \u251c\u2500\u2500 userActions.js\n\u2502   \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 actionTypes/\n\u2502   \u251c\u2500\u2500 userActionTypes.js\n\u2502   \u251c\u2500\u2500 notificationActionTypes.js\n\u2502   \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 reducers/\n\u2502   \u251c\u2500\u2500 userReducer.js\n\u2502   \u251c\u2500\u2500 notificationReducer.js\n\u2502   \u2514\u2500\u2500 index.js\n\u2514\u2500\u2500 store.js\n</code></pre>"},{"location":"frontend/state-management/redux/reducer/example/#define-action-types-in-separate-files","title":"Define Action Types in Separate Files","text":"<p>Each module or domain (e.g., users, notifications) has its own action types file.</p> <p>actionTypes/userActionTypes.js</p> <pre><code>export const FETCH_USERS_REQUEST = 'FETCH_USERS_REQUEST';\nexport const FETCH_USERS_SUCCESS = 'FETCH_USERS_SUCCESS';\nexport const FETCH_USERS_FAILURE = 'FETCH_USERS_FAILURE';\n</code></pre> <p>actionTypes/notificationActionTypes.js</p> <pre><code>export const FETCH_NOTIFICATIONS_REQUEST = 'FETCH_NOTIFICATIONS_REQUEST';\nexport const FETCH_NOTIFICATIONS_SUCCESS = 'FETCH_NOTIFICATIONS_SUCCESS';\nexport const FETCH_NOTIFICATIONS_FAILURE = 'FETCH_NOTIFICATIONS_FAILURE';\n</code></pre> <p>actionTypes/index.js</p> <p>This file aggregates all the action types from different domains.</p> <pre><code>export * from './userActionTypes';\nexport * from './notificationActionTypes';\n// Export other action types as needed\n</code></pre>"},{"location":"frontend/state-management/redux/reducer/example/#define-actions","title":"Define Actions","text":"<p>Each module has its own action creators, which use the specific action types.</p> <p>actions/userActions.js</p> <pre><code>import {\n  FETCH_USERS_REQUEST,\n  FETCH_USERS_SUCCESS,\n  FETCH_USERS_FAILURE\n} from '../actionTypes';\n\n// Action creator for initiating the fetch request\nexport const fetchUsersRequest = () =&gt; ({\n  type: FETCH_USERS_REQUEST\n});\n\n// Action creator for handling successful fetch\nexport const fetchUsersSuccess = (users) =&gt; ({\n  type: FETCH_USERS_SUCCESS,\n  payload: users\n});\n\n// Action creator for handling fetch failure\nexport const fetchUsersFailure = (error) =&gt; ({\n  type: FETCH_USERS_FAILURE,\n  payload: error\n});\n\n// Thunk action creator for fetching users from API\nexport const fetchUsers = () =&gt; {\n  return async (dispatch) =&gt; {\n    dispatch(fetchUsersRequest());\n\n    try {\n      const response = await fetch('https://api.example.com/users');\n      const data = await response.json();\n\n      if (response.ok) {\n        dispatch(fetchUsersSuccess(data));\n      } else {\n        throw new Error(data.message || 'Failed to fetch users');\n      }\n    } catch (error) {\n      dispatch(fetchUsersFailure(error.message));\n    }\n  };\n};\n</code></pre> <p>actions/index.js</p> <p>This file aggregates all action creators from different modules.</p> <pre><code>export * from './userActions';\nexport * from './notificationActions';\n// Export other actions as needed\n</code></pre>"},{"location":"frontend/state-management/redux/reducer/example/#define-reducers","title":"Define Reducers","text":"<p>Each module has its own reducer, which handles the specific action types.</p> <p>reducers/userReducer.js</p> <pre><code>import {\n  FETCH_USERS_REQUEST,\n  FETCH_USERS_SUCCESS,\n  FETCH_USERS_FAILURE\n} from '../actionTypes';\n\nconst initialState = {\n  loading: false,\n  users: [],\n  error: ''\n};\n\nconst userReducer = (state = initialState, action) =&gt; {\n  switch (action.type) {\n    case FETCH_USERS_REQUEST:\n      return {\n        ...state,\n        loading: true\n      };\n    case FETCH_USERS_SUCCESS:\n      return {\n        ...state,\n        loading: false,\n        users: action.payload,\n        error: ''\n      };\n    case FETCH_USERS_FAILURE:\n      return {\n        ...state,\n        loading: false,\n        users: [],\n        error: action.payload\n      };\n    default:\n      return state;\n  }\n};\n\nexport default userReducer;\n</code></pre> <p>reducers/index.js</p> <p>This file combines all the reducers from different modules.</p> <pre><code>import { combineReducers } from 'redux';\nimport userReducer from './userReducer';\nimport notificationReducer from './notificationReducer';\n\nconst rootReducer = combineReducers({\n  user: userReducer,\n  notification: notificationReducer,\n  // Add other reducers as needed\n});\n\nexport default rootReducer;\n</code></pre>"},{"location":"frontend/state-management/redux/reducer/example/#setting-up-the-redux-store","title":"Setting Up the Redux Store","text":"<p>store.js</p> <pre><code>import { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport rootReducer from './reducers';\n\nconst store = createStore(\n  rootReducer,\n  applyMiddleware(thunk)\n);\n\nexport default store;\n</code></pre>"},{"location":"frontend/state-management/redux/reducer/example/#using-actions-in-a-component","title":"Using Actions in a Component","text":"UserList.js<pre><code>import React, { useEffect } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { fetchUsers } from './actions';\n\nconst UserList = () =&gt; {\n  const dispatch = useDispatch();\n  const { loading, users, error } = useSelector((state) =&gt; state.user);\n\n  useEffect(() =&gt; {\n    dispatch(fetchUsers());\n  }, [dispatch]);\n\n  return (\n    &lt;div&gt;\n      {loading &amp;&amp; &lt;p&gt;Loading...&lt;/p&gt;}\n      {error &amp;&amp; &lt;p&gt;Error: {error}&lt;/p&gt;}\n      &lt;ul&gt;\n        {users.map((user) =&gt; (\n          &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default UserList;\n</code></pre> <p>By modularizing the action types, actions, and reducers, the codebase remains clean, maintainable, and scalable. This approach aligns with how large teams, like those at Facebook, manage their code.</p>"},{"location":"frontend/state-management/redux/reducer/intro/","title":"Intro","text":"<p>To master the Redux reducer, you should focus on understanding its core principles and progressively advancing to more complex patterns. Here\u2019s a step-by-step guide to mastering Redux reducers:</p>"},{"location":"frontend/state-management/redux/reducer/intro/#mastering-reducer","title":"Mastering Reducer","text":"<ol> <li> <p>Understand the Basics of a Reducer</p> <ul> <li>Pure Functions: Reducers must be pure functions. They should return a new state based on the action type without modifying the original state.</li> <li>Action Types: Actions describe what happened, and reducers define how the state changes in response to those actions.</li> <li>State Immutability: Always return a new copy of the state. Use spread syntax (<code>...state</code>) or libraries like <code>immer</code> for immutability.</li> </ul> <pre><code>const initialState = { count: 0 };\n\nconst counterReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case 'INCREMENT':\n            return { ...state, count: state.count + 1 };\n        case 'DECREMENT':\n            return { ...state, count: state.count - 1 };\n        default:\n            return state;\n    }\n};\n</code></pre> </li> <li> <p>Work with Complex State</p> <p>Once comfortable with simple states, move to complex nested state management. This is common in real-world apps, where state contains objects or arrays.</p> <ul> <li>Updating nested properties: For deep nested properties, make sure you understand how to properly update them without mutating the state.</li> </ul> <pre><code>const initialState = {\n    user: { name: 'John', details: { age: 30 } }\n};\n\nconst userReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case 'UPDATE_AGE':\n            return {\n                ...state,\n                user: {\n                    ...state.user,\n                    details: {\n                        ...state.user.details,\n                        age: action.payload.age\n                    }\n                }\n            };\n        default:\n            return state;\n    }\n};\n</code></pre> </li> <li> <p>Handle Arrays in Reducers</p> <p>Understanding how to add, remove, or update items in arrays is crucial for managing lists in Redux.</p> <pre><code>const initialState = { todos: [] };\n\nconst todoReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case 'ADD_TODO':\n            return {\n                ...state,\n                todos: [...state.todos, action.payload.todo]\n            };\n        case 'REMOVE_TODO':\n            return {\n                ...state,\n                todos: state.todos.filter(todo =&gt; todo.id !== action.payload.id)\n            };\n        default:\n            return state;\n    }\n};\n</code></pre> </li> <li> <p>Refactor and Modularize Reducers</p> <p>For large applications, breaking your reducers into smaller, manageable pieces (reducer composition) is crucial.</p> <ul> <li>Combine Reducers: Use <code>combineReducers</code> to split large reducers into smaller ones.</li> </ul> <pre><code>import { combineReducers } from 'redux';\n\nconst rootReducer = combineReducers({\n    counter: counterReducer,\n    todos: todoReducer,\n});\n</code></pre> <ul> <li>Action creators: Define action creators to make your reducer more readable and maintainable.</li> </ul> <pre><code>const increment = () =&gt; ({ type: 'INCREMENT' });\nconst addTodo = (todo) =&gt; ({ type: 'ADD_TODO', payload: { todo } });\n</code></pre> </li> <li> <p>Use Middlewares (for Async Logic)</p> <p>Mastering reducers also involves handling asynchronous logic. Redux Thunk or Redux-Saga are commonly used for side effects.</p> Thunk Example: <pre><code>const fetchData = () =&gt; async (dispatch) =&gt; {\n    dispatch({ type: 'FETCH_DATA_START' });\n    try {\n        const data = await apiCall();\n        dispatch({ type: 'FETCH_DATA_SUCCESS', payload: data });\n    } catch (error) {\n        dispatch({ type: 'FETCH_DATA_FAILURE', payload: error });\n    }\n};\n</code></pre> </li> <li> <p>Learn Advanced Patterns</p> <ul> <li>Normalization of State: As your state grows, it\u2019s crucial to normalize it, particularly for collections of related data like lists of users or posts.</li> <li>Reducer Factories: For repetitive tasks, such as managing similar types of state (e.g., loading/error states), use factory functions to create reusable reducer logic.</li> </ul> <pre><code>const createLoadingReducer = (actionType) =&gt; (state = false, action) =&gt; {\n    switch (action.type) {\n        case `${actionType}_REQUEST`:\n            return true;\n        case `${actionType}_SUCCESS`:\n        case `${actionType}_FAILURE`:\n            return false;\n        default:\n            return state;\n    }\n};\n\nconst loadingReducer = createLoadingReducer('FETCH_DATA');\n</code></pre> </li> <li> <p>Immer for Simplified State Management</p> <p>Immer is a popular library that allows you to write reducers as if you're mutating the state directly while keeping it immutable under the hood.</p> <pre><code>import produce from 'immer';\n\nconst todoReducer = (state = initialState, action) =&gt; \n    produce(state, draft =&gt; {\n        switch (action.type) {\n            case 'ADD_TODO':\n                draft.todos.push(action.payload.todo);\n                break;\n            case 'REMOVE_TODO':\n                const index = draft.todos.findIndex(todo =&gt; todo.id === action.payload.id);\n                if (index !== -1) draft.todos.splice(index, 1);\n                break;\n            }\n    });\n</code></pre> </li> <li> <p>Testing Reducers</p> <p>Testing is key to mastering reducers. Write unit tests for your reducers to ensure they behave as expected.</p> <pre><code>it('should increment the count', () =&gt; {\n    const action = { type: 'INCREMENT' };\n    const initialState = { count: 0 };\n    const newState = counterReducer(initialState, action);\n    expect(newState.count).toEqual(1);\n});\n</code></pre> </li> <li> <p>Master Edge Cases</p> <ul> <li>Handle default states and unknown actions.</li> <li>Ensure your reducer is optimized and scalable, particularly when dealing with large state objects.</li> </ul> </li> <li> <p>Keep Up with Best Practices</p> <ul> <li>Regularly review Redux documentation and explore Redux Toolkit, which simplifies many Redux patterns, such as creating reducers and handling immutability.</li> </ul> <pre><code>import { createSlice } from '@reduxjs/toolkit';\n\nconst todoSlice = createSlice({\n    name: 'todos',\n    initialState: [],\n    reducers: {\n        addTodo: (state, action) =&gt; {\n            state.push(action.payload.todo);\n        },\n        removeTodo: (state, action) =&gt; {\n            return state.filter(todo =&gt; todo.id !== action.payload.id);\n        },\n    },\n});\n\nexport const { addTodo, removeTodo } = todoSlice.actions;\nexport default todoSlice.reducer;\n</code></pre> </li> </ol> <p>By mastering these steps and gradually building more complex reducers, you'll become proficient in managing state in Redux.</p>"},{"location":"frontend/state-management/redux/reducer/intro/#what-is-an-action-creator","title":"What is an Action Creator?","text":"<p>An action creator is simply a function that returns an action. Actions are plain JavaScript objects that describe what happened in your application. The action creator is responsible for constructing that action object.</p> <p>In Redux, actions must have a <code>type</code> property that indicates the type of action being performed. Additional data related to the action can be passed as <code>payload</code>.</p>"},{"location":"frontend/state-management/redux/reducer/intro/#basic-example-of-an-action-creator","title":"Basic Example of an Action Creator","text":"<p>Here's a simple action creator:</p> <pre><code>// Basic Action Creator\nconst increment = () =&gt; ({\n  type: 'INCREMENT',\n});\n</code></pre> <p>This action creator returns an object with a <code>type</code> property. When dispatched, it will tell the reducer to increment the value in the state.</p> Usage: <pre><code>// Action object returned by the action creator\n{\n    type: 'INCREMENT'\n}\n\n// Dispatch the action\nstore.dispatch(increment());\n</code></pre> With Payload (passing additional data): <pre><code>const addTodo = (todo) =&gt; ({\n    type: 'ADD_TODO',\n    payload: {\n        todo,\n    },\n});\n\n// Example usage:\nstore.dispatch(addTodo('Learn Redux'));\n\n// This returns:\n{\n    type: 'ADD_TODO',\n    payload: { todo: 'Learn Redux' }\n}\n</code></pre> <pre><code>// todoActions.js (Action File)\n\n// Action creator for adding a todo\nexport const addTodo = (todo) =&gt; ({\n    type: 'ADD_TODO',\n    payload: { todo },\n});\n\n// Action creator for deleting a todo\nexport const deleteTodo = (id) =&gt; ({\n    type: 'DELETE_TODO',\n    payload: { id },\n});\n</code></pre> <pre><code>// todoReducer.js (Reducer File)\n\nconst initialState = { todos: [] };\n\n// Reducer function for handling todo actions\nconst todoReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case 'ADD_TODO':\n            return {\n                ...state,\n                todos: [...state.todos, action.payload.todo],\n            };\n        case 'DELETE_TODO':\n            return {\n                ...state,\n                todos: state.todos.filter(todo =&gt; todo.id !== action.payload.id),\n            };\n        default:\n            return state;\n  }\n};\n\nexport default todoReducer;\n</code></pre>"},{"location":"frontend/state-management/redux/reducer/modular-reducer/","title":"Modular Reducer","text":""},{"location":"frontend/state-management/redux/reducer/modular-reducer/#define-api-urls","title":"Define API URLs","text":"apiUrls.js<pre><code>export const API_URLS = {\n    FETCH_ITEMS: '/api/items',\n    CREATE_ITEM: '/api/items',\n    // Add more URLs as needed\n};\n</code></pre>"},{"location":"frontend/state-management/redux/reducer/modular-reducer/#define-headers","title":"Define Headers","text":"headers.js<pre><code>export const DEFAULT_HEADERS = {\n    'Content-Type': 'application/json',\n    // Add more default headers if needed\n};\n</code></pre>"},{"location":"frontend/state-management/redux/reducer/modular-reducer/#define-api-request-functions","title":"Define API Request Functions","text":"api.js<pre><code>import { DEFAULT_HEADERS } from './headers';\n\nexport const getApi = async (url, headers = DEFAULT_HEADERS) =&gt; {\n  const response = await fetch(url, { headers });\n  const data = await response.json();\n\n  if (!response.ok) {\n    throw new Error(data.message || 'Something went wrong');\n  }\n\n  return data;\n};\n\nexport const postApi = async (url, body, headers = DEFAULT_HEADERS) =&gt; {\n  const options = {\n    method: 'POST',\n    headers,\n    body: JSON.stringify(body)\n  };\n\n  const response = await fetch(url, options);\n  const data = await response.json();\n\n  if (!response.ok) {\n    throw new Error(data.message || 'Something went wrong');\n  }\n\n  return data;\n};\n\n// Add more methods (PUT, DELETE, etc.) as needed\n</code></pre>"},{"location":"frontend/state-management/redux/reducer/modular-reducer/#use-the-api-request-functions-in-action-creators","title":"Use the API Request Functions in Action Creators","text":"actions/itemActions.js<pre><code>import { getApi, postApi } from '../api';\nimport { API_URLS } from '../apiUrls';\nimport {\n  FETCH_ITEMS_REQUEST,\n  FETCH_ITEMS_SUCCESS,\n  FETCH_ITEMS_FAILURE,\n  CREATE_ITEM_REQUEST,\n  CREATE_ITEM_SUCCESS,\n  CREATE_ITEM_FAILURE\n} from '../actionTypes';\n\n// Fetch items\nexport const fetchItems = () =&gt; async (dispatch) =&gt; {\n  dispatch({ type: FETCH_ITEMS_REQUEST });\n  try {\n    const data = await getApi(API_URLS.FETCH_ITEMS);\n    dispatch({ type: FETCH_ITEMS_SUCCESS, payload: data });\n  } catch (error) {\n    dispatch({ type: FETCH_ITEMS_FAILURE, payload: error.message });\n  }\n};\n\n// Create item\nexport const createItem = (item) =&gt; async (dispatch) =&gt; {\n  dispatch({ type: CREATE_ITEM_REQUEST });\n  try {\n    const data = await postApi(API_URLS.CREATE_ITEM, item);\n    dispatch({ type: CREATE_ITEM_SUCCESS, payload: data });\n  } catch (error) {\n    dispatch({ type: CREATE_ITEM_FAILURE, payload: error.message });\n  }\n};\n</code></pre>"},{"location":"frontend/state-management/redux/reducer/modular-reducer/#full-example-directory-structure","title":"Full Example Directory Structure","text":"<pre><code>src/\n\u251c\u2500\u2500 actions/\n\u2502   \u251c\u2500\u2500 itemActions.js\n\u2502   \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 actionTypes/\n\u2502   \u251c\u2500\u2500 itemActionTypes.js\n\u2502   \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 api/\n\u2502   \u251c\u2500\u2500 api.js\n\u2502   \u251c\u2500\u2500 apiUrls.js\n\u2502   \u2514\u2500\u2500 headers.js\n\u251c\u2500\u2500 reducers/\n\u2502   \u251c\u2500\u2500 itemReducer.js\n\u2502   \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 store.js\n\u2514\u2500\u2500 components/\n    \u2514\u2500\u2500 ItemList.js\n</code></pre>"},{"location":"frontend/state-management/redux/reducer/modular-reducer/#putting-it-all-together","title":"Putting It All Together","text":"src/actions/itemActions.js<pre><code>import { getApi, postApi } from '../api/api';\nimport { API_URLS } from '../api/apiUrls';\nimport {\n  FETCH_ITEMS_REQUEST,\n  FETCH_ITEMS_SUCCESS,\n  FETCH_ITEMS_FAILURE,\n  CREATE_ITEM_REQUEST,\n  CREATE_ITEM_SUCCESS,\n  CREATE_ITEM_FAILURE\n} from '../actionTypes/itemActionTypes';\n\n// Fetch items\nexport const fetchItems = () =&gt; async (dispatch) =&gt; {\n  dispatch({ type: FETCH_ITEMS_REQUEST });\n  try {\n    const data = await getApi(API_URLS.FETCH_ITEMS);\n    dispatch({ type: FETCH_ITEMS_SUCCESS, payload: data });\n  } catch (error) {\n    dispatch({ type: FETCH_ITEMS_FAILURE, payload: error.message });\n  }\n};\n\n// Create item\nexport const createItem = (item) =&gt; async (dispatch) =&gt; {\n  dispatch({ type: CREATE_ITEM_REQUEST });\n  try {\n    const data = await postApi(API_URLS.CREATE_ITEM, item);\n    dispatch({ type: CREATE_ITEM_SUCCESS, payload: data });\n  } catch (error) {\n    dispatch({ type: CREATE_ITEM_FAILURE, payload: error.message });\n  }\n};\n</code></pre>"},{"location":"frontend/state-management/redux/reducer/throw-new-error/","title":"Throw New Error","text":""},{"location":"frontend/state-management/redux/reducer/throw-new-error/#understanding-throw-new-error","title":"Understanding throw new Error","text":"<p><code>throw new Error</code> is a way to create and throw a custom error in JavaScript. When you throw an <code>Error</code> object, you stop the normal execution flow and send control to the nearest catch block or global error handler, if no catch block is found.</p> Syntax<pre><code>if (!response.ok) {\n  throw new Error(data.message || 'Something went wrong');\n}\n</code></pre>"},{"location":"frontend/state-management/redux/reducer/throw-new-error/#importance-in-redux","title":"Importance in Redux","text":"<p>In a Redux-based application, throwing a new <code>Error</code> object is crucial for several reasons:</p> <ol> <li> <p>Consistent Error Handling:</p> <ul> <li> <p>By throwing an <code>Error</code>, you ensure that all errors are handled in a consistent manner. This consistency is vital for debugging and maintenance.</p> </li> <li> <p>Example:</p> <pre><code>try {\n    const data = await apiCall(url);\n} catch (error) {\n    console.error(error.message);\n}\n</code></pre> </li> </ul> </li> <li> <p>Centralized Error Management:</p> <ul> <li> <p>Redux action creators often make asynchronous calls (e.g., API requests). Throwing an <code>Error</code> allows these action creators to handle errors centrally, dispatching appropriate error actions.</p> </li> <li> <p>Example:</p> <pre><code>export const fetchData = () =&gt; async (dispatch) =&gt; {\n    dispatch({ type: FETCH_DATA_REQUEST });\n    try {\n        const data = await apiCall(url);\n        dispatch({ type: FETCH_DATA_SUCCESS, payload: data });\n    } catch (error) {\n        dispatch({ type: FETCH_DATA_FAILURE, payload: error.message });\n    }\n};\n</code></pre> </li> </ul> </li> <li> <p>Enhanced Debugging:</p> <ul> <li> <p>The <code>Error</code> object captures a stack trace, which provides valuable context about where the error occurred. This stack trace can be logged and used for debugging.</p> </li> <li> <p>Example:</p> <pre><code>catch (error) {\n    console.error('Error stack:', error.stack);\n}\n</code></pre> </li> </ul> </li> <li> <p>Flow Control:</p> <ul> <li> <p>Throwing an <code>Error</code> ensures that the normal flow of execution is interrupted, allowing you to handle exceptions appropriately. Without this, errors might go unnoticed, leading to unexpected behavior.</p> </li> <li> <p>Example:</p> <pre><code>const fetchData = async () =&gt; {\n    const response = await fetch(url);\n    if (!response.ok) {\n        throw new Error('Failed to fetch data');\n    }\n    return response.json();\n};\n</code></pre> </li> </ul> </li> </ol>"},{"location":"frontend/state-management/redux/reducer/throw-new-error/#consequences-of-not-throwing-an-error","title":"Consequences of Not Throwing an Error","text":"<p>If you don't throw an <code>Error</code>, the consequences can include:</p> <ol> <li> <p>Silent Failures:</p> <ul> <li> <p>Errors may go unnoticed, leading to silent failures where the application continues to run without handling the error.</p> </li> <li> <p>Example:</p> <pre><code>if (!response.ok) {\n    // No error thrown, so the function continues executing\n    console.error('Error fetching data');\n}\n</code></pre> </li> </ul> </li> <li> <p>Inconsistent State::</p> <ul> <li> <p>The application state might become inconsistent if errors are not properly handled, potentially causing further issues down the line.</p> </li> <li> <p>Example:</p> <pre><code>try {\n    const data = await apiCall(url);\n    // State might not update correctly if error is not handled\n} catch (error) {\n    // Handle error here\n}\n</code></pre> </li> </ul> </li> <li> <p>Difficult Debugging:</p> <ul> <li> <p>Without stack traces, debugging becomes more challenging. Developers have less context about where and why the error occurred.</p> </li> <li> <p>Example:</p> <pre><code>if (!response.ok) {\n    // No stack trace available\n    console.error('Error occurred');\n}\n</code></pre> </li> </ul> </li> </ol>"},{"location":"frontend/state-management/redux/reducer/throw-new-error/#example-in-redux-action-creator","title":"Example in Redux Action Creator","text":"<p>Here\u2019s a complete example demonstrating the use of throw new Error in a Redux action creator:</p> api.js<pre><code>export const apiCall = async (url, method = 'GET', body = null, headers = { 'Content-Type': 'application/json' }) =&gt; {\n    const options = { method, headers };\n    if (body) {\n        options.body = JSON.stringify(body);\n    }\n    const response = await fetch(url, options);\n    const data = await response.json();\n    if (!response.ok) {\n        throw new Error(data.message || 'Something went wrong');\n    }\n    return data;\n};\n</code></pre> actions/itemActions.js<pre><code>import { apiCall } from '../api/api';\nimport {\n    FETCH_ITEMS_REQUEST,\n    FETCH_ITEMS_SUCCESS,\n    FETCH_ITEMS_FAILURE,\n    CREATE_ITEM_REQUEST,\n    CREATE_ITEM_SUCCESS,\n    CREATE_ITEM_FAILURE\n} from '../actionTypes/itemActionTypes';\n\n// Fetch items\nexport const fetchItems = () =&gt; async (dispatch) =&gt; {\n    dispatch({ type: FETCH_ITEMS_REQUEST });\n    try {\n        const data = await apiCall('/api/items');\n        dispatch({ type: FETCH_ITEMS_SUCCESS, payload: data });\n    } catch (error) {\n        dispatch({ type: FETCH_ITEMS_FAILURE, payload: error.message });\n    }\n};\n\n// Create item\nexport const createItem = (item) =&gt; async (dispatch) =&gt; {\n    dispatch({ type: CREATE_ITEM_REQUEST });\n    try {\n        const data = await apiCall('/api/items', 'POST', item);\n        dispatch({ type: CREATE_ITEM_SUCCESS, payload: data });\n    } catch (error) {\n        dispatch({ type: CREATE_ITEM_FAILURE, payload: error.message });\n    }\n};\n</code></pre> <p>By throwing an <code>Error</code>, you ensure that your Redux actions can handle errors robustly and consistently, leading to a more stable and maintainable application.</p>"},{"location":"frontend/state-management/redux/reducer/throw-new-error/#why-we-throw-errors","title":"Why We Throw Errors","text":"<p>The primary reason for throwing errors is to ensure that they can be caught and handled appropriately. When you throw an error using <code>throw new Error</code>, it interrupts the normal execution flow and transfers control to the nearest <code>catch</code> block or an equivalent error-handling mechanism. Without this, errors might not be caught, leading to potential issues such as silent failures or inconsistent application states.</p>"},{"location":"frontend/state-management/redux/reducer/throw-new-error/#what-happens-if-we-dont-throw-an-error","title":"What Happens if We Don't Throw an Error","text":"<p>If you don't throw an error, it won't be caught by the catch block, and the execution will continue as if nothing went wrong. This can lead to various issues:</p> <ol> <li> <p>Silent Failures:</p> <p>The error might go unnoticed, leading to the application behaving incorrectly without any indication of what went wrong.</p> </li> <li> <p>Inconsistent State:</p> <p>If an error occurs and is not handled, the application state might become inconsistent, causing further issues down the line.</p> </li> <li> <p>Difficulty in Debugging:</p> <p>Without throwing an error, you lose the stack trace information, making it harder to debug and trace the source of the issue.</p> </li> </ol>"},{"location":"frontend/state-management/redux/reducer/throw-new-error/#example-without-throwing-an-error","title":"Example Without Throwing an Error","text":"<p>Here\u2019s an example to illustrate what happens when you don't throw an error:</p> api.js<pre><code>export const apiCall = async (url, method = 'GET', body = null, headers = { 'Content-Type': 'application/json' }) =&gt; {\n    const options = { method, headers };\n    if (body) {\n        options.body = JSON.stringify(body);\n    }\n    const response = await fetch(url, options);\n    const data = await response.json();\n    // Not throwing an error\n    if (!response.ok) {\n        return data.message || 'Something went wrong';\n    }\n    return data;\n};\n</code></pre> actions/itemActions.js<pre><code>import { apiCall } from '../api/api';\nimport {\n  FETCH_ITEMS_REQUEST,\n  FETCH_ITEMS_SUCCESS,\n  FETCH_ITEMS_FAILURE,\n  CREATE_ITEM_REQUEST,\n  CREATE_ITEM_SUCCESS,\n  CREATE_ITEM_FAILURE\n} from '../actionTypes/itemActionTypes';\n\n// Fetch items\nexport const fetchItems = () =&gt; async (dispatch) =&gt; {\n  dispatch({ type: FETCH_ITEMS_REQUEST });\n  try {\n    const data = await apiCall('/api/items');\n    if (!data.ok) {\n      dispatch({ type: FETCH_ITEMS_FAILURE, payload: data.message });\n    } else {\n      dispatch({ type: FETCH_ITEMS_SUCCESS, payload: data });\n    }\n  } catch (error) {\n    dispatch({ type: FETCH_ITEMS_FAILURE, payload: error.message });\n  }\n};\n\n// Create item\nexport const createItem = (item) =&gt; async (dispatch) =&gt; {\n    dispatch({ type: CREATE_ITEM_REQUEST });\n    try {\n        const data = await apiCall('/api/items', 'POST', item);\n        if (!data.ok) {\n            dispatch({ type: CREATE_ITEM_FAILURE, payload: data.message });\n        } else {\n            dispatch({ type: CREATE_ITEM_SUCCESS, payload: data });\n        }\n    } catch (error) {\n        dispatch({ type: CREATE_ITEM_FAILURE, payload: error.message });\n    }\n};\n</code></pre> <p>In this case, you have to handle the error within the action creator itself by checking the response. This approach is cumbersome and error-prone.</p>"},{"location":"frontend/state-management/redux/reducer/throw-new-error/#example-with-throwing-an-error","title":"Example With Throwing an Error","text":"<p>By throwing an error, you can simplify the error handling process:</p> api.js<pre><code>export const apiCall = async (url, method = 'GET', body = null, headers = { 'Content-Type': 'application/json' }) =&gt; {\n    const options = { method, headers };\n    if (body) {\n        options.body = JSON.stringify(body);\n    }\n    const response = await fetch(url, options);\n    const data = await response.json();\n    if (!response.ok) {\n        throw new Error(data.message || 'Something went wrong');\n    }\n    return data;\n};\n</code></pre> actions/itemActions.js<pre><code>import { apiCall } from '../api/api';\nimport {\n    FETCH_ITEMS_REQUEST,\n    FETCH_ITEMS_SUCCESS,\n    FETCH_ITEMS_FAILURE,\n    CREATE_ITEM_REQUEST,\n    CREATE_ITEM_SUCCESS,\n    CREATE_ITEM_FAILURE\n} from '../actionTypes/itemActionTypes';\n\n// Fetch items\nexport const fetchItems = () =&gt; async (dispatch) =&gt; {\n    dispatch({ type: FETCH_ITEMS_REQUEST });\n    try {\n        const data = await apiCall('/api/items');\n        dispatch({ type: FETCH_ITEMS_SUCCESS, payload: data });\n    } catch (error) {\n        dispatch({ type: FETCH_ITEMS_FAILURE, payload: error.message });\n    }\n};\n\n// Create item\nexport const createItem = (item) =&gt; async (dispatch) =&gt; {\n    dispatch({ type: CREATE_ITEM_REQUEST });\n    try {\n        const data = await apiCall('/api/items', 'POST', item);\n        dispatch({ type: CREATE_ITEM_SUCCESS, payload: data });\n    } catch (error) {\n        dispatch({ type: CREATE_ITEM_FAILURE, payload: error.message });\n    }\n};\n</code></pre>"},{"location":"frontend/state-management/redux/reducer/throw-new-error/#advantages-of-throwing-an-error","title":"Advantages of Throwing an Error","text":"<ol> <li> <p>Centralized Error Handling:</p> <p>By throwing an error, you allow the catch block to handle it centrally, making your code cleaner and easier to maintain.</p> </li> <li> <p>Clear Flow Control:</p> <p>Throwing an error immediately stops execution of the current function and transfers control to the nearest error handler.</p> </li> <li> <p>Detailed Error Information:</p> <p>The Error object includes a message and a stack trace, which are useful for debugging.</p> </li> <li> <p>Consistency:</p> <p>Ensures that all errors are handled consistently, reducing the likelihood of uncaught errors.</p> </li> </ol> <p>By adhering to this pattern, you ensure that your application handles errors robustly, making it more reliable and easier to maintain.</p>"},{"location":"frontend/state-management/redux/redux-middleware/intro/","title":"Intro","text":""},{"location":"frontend/state-management/redux/redux-middleware/intro/#redux-middleware-saga-and-thunk","title":"Redux middleware \u2013 Saga and Thunk","text":"<p>The basic Redux store can only perform simple synchronous state updates by dispatching an action.</p> <p>Middleware such as Redux Thunk and Redux Saga help extend the store capabilities by writing the async logic to interact with the store. These middleware are helpful to avoid directly causing side effects in our actions, action creators, or components.</p>"},{"location":"frontend/state-management/redux/redux-middleware/intro/#what-is-redux-middleware-how-do-you-create-middleware","title":"What is Redux middleware? How do you create middleware?","text":"<p>Redux middleware provides a third-party extension to intercept every action sent to the reducer by modifying the action or canceling the action. It is helpful for logging, error reporting, routing, and making asynchronous API calls. Although Redux middleware is like Node.js middleware (for example, Express and Koa), it solves different problems.</p>"},{"location":"frontend/state-management/redux/redux-middleware/intro/#how-do-you-handle-asynchronous-tasks-in-redux","title":"How do you handle asynchronous tasks in Redux?","text":"<p>Most modern web applications need to deal with asynchronous tasks. In React, there are two popular libraries available to handle them: </p> <ol> <li>Redux Thunk &amp;</li> <li>Redux Saga.</li> </ol>"},{"location":"frontend/state-management/redux/redux-middleware/intro/#how-do-you-choose-between-redux-saga-and-redux-thunk","title":"How do you choose between Redux Saga and Redux Thunk?","text":"<p>Both Redux Thunk and Redux Saga middleware are helpful in allowing the Redux store to interact with external API calls (or side effects) asynchronously. But the decision to choose one of them totally depends on your project requirements and personal preference. </p> <p>Redux Thunk is a good choice if you are new to the React or Redux ecosystem and the project is small in size. Moreover, Redux Thunk requires less boilerplate code and is easy to understand.</p> <p>On the other hand, Redux Saga is suitable for big projects where you need to split the logic into multiple files. However, the main advantage of Redux Saga over Redux Thunk is the ability to write clean and readable tests for asynchronous code.</p> <p>The plain Redux requires a lot of boilerplate code to fulfill the state management requirements.Developers need to implement common tasks such as store setup, writing reducers and actions, and so on. Also, you may need to import APIs from other packages based on needs. So, this entire process makes it difficult for developers to learn and implement the Redux solution. RTK is going to standardize the process and simplify it with its helpers.</p>"},{"location":"frontend/state-management/redux/redux-middleware/intro/#standardizing-redux-logic-using-rtk","title":"Standardizing Redux logic using RTK","text":"<p>The RTK package provides the necessary tools to ease Redux development. This package not only eases development but also prevents common mistakes, provides suggested best practices, and many more features.</p>"},{"location":"frontend/state-management/redux/redux-middleware/intro/#what-is-rtk","title":"What is RTK?","text":"<p>Redux Toolkit (RTK) is a set of tools that simplifies Redux development and is used as an officially recommended approach to writing Redux logic. It was previously known as Redux Smarter Kit. The node package for this toolkit is available with the name @reduxjs/toolkit, which is wrapped around the core redux package. In summary, this package provides utilities and common dependencies that are required for building a Redux application.</p> <p>This tool helps cover common use cases such as setting up the store, creating the reducers and actions, writing immutable update logic, and creating entire slices of state at once.</p> <p>By default, RTK automatically supports the following officially recommended set of tools or libraries to cover most of the common use cases:</p> <ul> <li>Redux DevTools</li> <li>Immer</li> <li>Redux Thunk</li> <li>Reselect</li> </ul> <p>RTK supports TypeScript through which APIs provide excellent type safety and reduce the number of types used in the code.</p>"},{"location":"frontend/state-management/redux/redux-middleware/intro/#what-are-the-problems-solved-by-rtk","title":"What are the problems solved by RTK?","text":"<p>RTK is helpful to speed up the development process and apply the recommended best practices automatically. It solves the following three major issues found in the Redux library:</p> <ul> <li>Configuring a Redux store that is too complicated</li> <li>This Redux library requires a lot of dependencies for building a large-scale application</li> <li>Redux requires too much boilerplate code, which impacts the efficiency and quality of the code</li> </ul> <p>The toolkit provides certain options to configure the global store, creating actions and reducers that make the development simpler by abstracting the Redux API.</p>"},{"location":"frontend/state-management/redux/redux-middleware/intro/#what-is-rtk-query-how-do-you-use-it","title":"What is RTK Query? How do you use it?","text":"<p>RTK Query is a powerful data fetching and client-side caching tool to simplify common use cases in Redux applications. For example, this tool supports use cases such as loading data in the web application, avoiding the need for hand-written data fetching and caching logic, and so on. If you are using the RTK package, this query feature is going to be available as an optional add-on. Also, this feature is built-in on top of the RTK API methods such as <code>createSlice</code> and <code>createAsyncThunk</code> for its implementation.</p>"},{"location":"frontend/state-management/redux/redux-middleware/intro/#reference","title":"Reference","text":"<ul> <li>React Interview Guide - packt pg:155</li> </ul>"},{"location":"frontend/state-management/redux/redux-middleware/redux-saga/","title":"Redux Saga","text":""},{"location":"frontend/state-management/redux/redux-middleware/redux-saga/#what-is-redux-saga","title":"What is Redux Saga?","text":"<p>Redux Saga is a popular competitor for Redux Thunk middleware for handling asynchronous side effects. Redux Saga uses an ES6 feature known as generators that helps in writing asynchronous code. These generators are functions that can be paused, resumed, exited in the middle of execution, and re-entered later during the operations.</p> <p>The side effects will be generated using special helper functions from the <code>redux-saga</code> package. Some of those commonly used functions are listed here:</p> <ul> <li>Call: An effect description that instructs the middleware to call other functions in Saga</li> <li>Put: Used to dispatch an action to the store</li> <li>Yield: A built-in function that allows the use of generator functions sequentially</li> <li>takeLatest: Invokes the function handler only once at a time and cancels the previous tasks by running again with the latest data</li> <li>takeEvery: Invokes the function handler every time infinitely and concurrently whenever the action fires</li> </ul> <ul> <li>React Interview Guide - packt pg:155</li> </ul>"},{"location":"frontend/state-management/redux/redux-middleware/redux-thunk/","title":"Redux Thunk","text":"<p>Redux Thunk middleware is used to write an action creator that returns a function instead of just an action object in the Redux application. The functions returned from the action creator are called thunk functions and are used to delay the computation. These functions accept two arguments \u2013 the dispatch and getState methods:</p>"},{"location":"frontend/state-management/redux/redux-middleware/redux-thunk/#what-are-the-use-cases-of-redux-thunk","title":"What are the use cases of Redux Thunk?","text":"<p>Redux Thunk can have any arbitrary logic and it can be used for a variety of purposes. The most common use cases of Redux Thunk are listed as follows:</p> <ul> <li>When you\u2019re trying to move complex logic out of React components</li> <li>When you are making async requests such as Ajax calls and other async logic</li> <li>When you need to create a logic that needs to dispatch multiple distinct actions in a row</li> <li>When you are planning to write a logic that needs to access getState or other state values to make decisions</li> </ul> <p>In summary, the main use case of Redux Thunk middleware is for handling actions that are not synchronous.</p> <ul> <li>React Interview Guide - packt pg:155</li> </ul>"},{"location":"frontend/state-management/redux/rtk/folder-structure/","title":"Folder Structure","text":""},{"location":"frontend/state-management/redux/rtk/folder-structure/#basic-redux-toolkit-rtk-folder-structure","title":"Basic Redux Toolkit (RTK) Folder Structure","text":"<p>A basic folder structure using Redux Toolkit might look something like this:</p> <pre><code>src/\n\u2502\n\u251c\u2500\u2500 app/\n\u2502   \u2514\u2500\u2500 store.js\n\u2502\n\u251c\u2500\u2500 features/\n\u2502   \u2514\u2500\u2500 counter/\n\u2502       \u251c\u2500\u2500 counterSlice.js\n\u2502       \u2514\u2500\u2500 Counter.js\n\u2502\n\u251c\u2500\u2500 App.js\n\u2514\u2500\u2500 index.js\n</code></pre> Example store.jscounterSlice.jsCounter.jsApp.jsindex.js <pre><code>// src/app/store.js\n\nimport { configureStore } from '@reduxjs/toolkit';\nimport counterReducer from '../features/counter/counterSlice';\n\nexport const store = configureStore({\n    reducer: {\n        counter: counterReducer,\n    },\n});\n</code></pre> <pre><code>// src/features/counter/counterSlice.js\n\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst counterSlice = createSlice({\n    name: 'counter',\n    initialState: {\n        value: 0,\n    },\n    reducers: {\n        increment: (state) =&gt; {\n            state.value += 1;\n        },\n        decrement: (state) =&gt; {\n            state.value -= 1;\n        },\n        incrementByAmount: (state, action) =&gt; {\n            state.value += action.payload;\n        },\n    },\n});\n\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions;\n\nexport default counterSlice.reducer;\n</code></pre> <pre><code>import React from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { increment, decrement, incrementByAmount } from './counterSlice';\n\nconst Counter = () =&gt; {\n    const count = useSelector((state) =&gt; state.counter.value);\n    const dispatch = useDispatch();\n\n    return (\n        &lt;div&gt;\n            &lt;div&gt;\n                &lt;button \n                    aria-label=\"Increment value\"\n                    onClick={() =&gt; dispatch(increment())}\n                &gt;\n                +\n                &lt;/button&gt;\n\n                &lt;span&gt;{count}&lt;/span&gt;\n\n                &lt;button\n                    aria-label=\"Decrement value\"\n                    onClick={() =&gt; dispatch(decrement())}\n                &gt;\n                -\n                &lt;/button&gt;\n            &lt;/div&gt;\n\n            &lt;div&gt;\n                &lt;button\n                    onClick={() =&gt; dispatch(incrementByAmount(5))}\n                &gt;\n                    Increment by 5\n                &lt;/button&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Counter;\n</code></pre> <pre><code>// src/App.js\n\nimport React from 'react';\nimport Counter from './features/counter/Counter';\n\nconst App = () =&gt; (\n    &lt;div&gt;\n        &lt;h1&gt;Counter App&lt;/h1&gt;\n        &lt;Counter /&gt;\n    &lt;/div&gt;\n);\n\nexport default App;\n</code></pre> <pre><code>// src/index.js\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport { store } from './app/store';\nimport App from './App';\n\nReactDOM.render(\n    &lt;Provider store={store}&gt;\n        &lt;App /&gt;\n    &lt;/Provider&gt;,\n    document.getElementById('root')\n);\n</code></pre>"},{"location":"frontend/state-management/redux/rtk/folder-structure/#advanced-redux-toolkit-rtk-folder-structure","title":"Advanced Redux Toolkit (RTK) Folder Structure","text":"<p>For a more complex application, the folder structure can be expanded to include additional features such as authentication, API calls, and more modular organization.</p> <pre><code>src/\n\u2502\n\u251c\u2500\u2500 app/\n\u2502   \u2514\u2500\u2500 store.js\n\u2502\n\u251c\u2500\u2500 features/\n\u2502   \u251c\u2500\u2500 auth/\n\u2502   \u2502   \u251c\u2500\u2500 authSlice.js\n\u2502   \u2502   \u251c\u2500\u2500 Login.js\n\u2502   \u2502   \u2514\u2500\u2500 Register.js\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 counter/\n\u2502   \u2502   \u251c\u2500\u2500 counterSlice.js\n\u2502   \u2502   \u2514\u2500\u2500 Counter.js\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 api/\n\u2502   \u2502   \u2514\u2500\u2500 apiSlice.js\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 user/\n\u2502       \u251c\u2500\u2500 userSlice.js\n\u2502       \u2514\u2500\u2500 UserProfile.js\n\u2502\n\u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 Navbar.js\n\u2502   \u2514\u2500\u2500 PrivateRoute.js\n\u2502\n\u251c\u2500\u2500 utils/\n\u2502   \u251c\u2500\u2500 authUtils.js\n\u2502   \u2514\u2500\u2500 apiUtils.js\n\u2502\n\u251c\u2500\u2500 App.js\n\u2514\u2500\u2500 index.js\n</code></pre> Example store.jsauthSlice.jsapiSlice.jsuserSlice.jsPrivateRoute.jsauthUtils.js <pre><code>// src/app/store.js\n\nimport { configureStore } from '@reduxjs/toolkit';\nimport counterReducer from '../features/counter/counterSlice';\nimport authReducer from '../features/auth/authSlice';\nimport userReducer from '../features/user/userSlice';\nimport { apiSlice } from '../features/api/apiSlice';\n\nexport const store = configureStore({\n    reducer: {\n        counter: counterReducer,\n        auth: authReducer,\n        user: userReducer,\n        [apiSlice.reducerPath]: apiSlice.reducer,\n    },\n    middleware: (getDefaultMiddleware) =&gt;\n        getDefaultMiddleware().concat(apiSlice.middleware),\n});\n</code></pre> <pre><code>// src/features/auth/authSlice.js\n\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport axios from 'axios';\n\nexport const login = createAsyncThunk('auth/login', async (credentials) =&gt; {\n    const response = await axios.post('/api/auth/login', credentials);\n    return response.data;\n});\n\nconst authSlice = createSlice({\n    name: 'auth',\n    initialState: {\n        user: null,\n        token: null,\n        status: 'idle',\n        error: null,\n    },\n    reducers: {\n        logout: (state) =&gt; {\n            state.user = null;\n            state.token = null;\n        },\n    },\n    extraReducers: (builder) =&gt; {\n        builder\n        .addCase(login.pending, (state) =&gt; {\n            state.status = 'loading';\n        })\n        .addCase(login.fulfilled, (state, action) =&gt; {\n            state.status = 'succeeded';\n            state.user = action.payload.user;\n            state.token = action.payload.token;\n        })\n        .addCase(login.rejected, (state, action) =&gt; {\n            state.status = 'failed';\n            state.error = action.error.message;\n        });\n    },\n});\n\nexport const { logout } = authSlice.actions;\n\nexport default authSlice.reducer;\n</code></pre> <pre><code>// src/features/api/apiSlice.js\n\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';\n\nexport const apiSlice = createApi({\n    reducerPath: 'api',\n    baseQuery: fetchBaseQuery({ baseUrl: '/api' }),\n    endpoints: (builder) =&gt; ({\n            getUserById: builder.query({\n            query: (id) =&gt; `user/${id}`,\n            }),\n            updateUser: builder.mutation({\n            query: (user) =&gt; ({\n                url: `user/${user.id}`,\n                method: 'PUT',\n                body: user,\n            }),\n        }),\n    }),\n});\n\nexport const { useGetUserByIdQuery, useUpdateUserMutation } = apiSlice;\n</code></pre> <pre><code>// src/features/user/userSlice.js\n\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst userSlice = createSlice({\n    name: 'user',\n    initialState: {\n        profile: null,\n    },\n    reducers: {\n        setProfile: (state, action) =&gt; {\n            state.profile = action.payload;\n        },\n    },\n});\n\nexport const { setProfile } = userSlice.actions;\n\nexport default userSlice.reducer;\n</code></pre> <pre><code>// src/components/PrivateRoute.js\nimport React from 'react';\nimport { Route, Redirect } from 'react-router-dom';\nimport { useSelector } from 'react-redux';\n\nconst PrivateRoute = ({ component: Component, ...rest }) =&gt; {\n    const { token } = useSelector((state) =&gt; state.auth);\n\n    return (\n        &lt;Route\n            {...rest}\n            render={(props) =&gt;\n                token ? &lt;Component {...props} /&gt; : &lt;Redirect to=\"/login\" /&gt;\n            }\n        /&gt;\n    );\n};\n\nexport default PrivateRoute;\n</code></pre> <pre><code>// src/utils/authUtils.js\n\nexport const isAuthenticated = () =&gt; {\n    const token = localStorage.getItem('token');\n    return !!token;\n};\n\nexport const getToken = () =&gt; {\n    return localStorage.getItem('token');\n};\n</code></pre> <p>Summary</p> <ul> <li>Basic Structure: Simple setup with essential files and folders.</li> <li>Advanced Structure: More complex organization with features, components, and utility functions separated into dedicated folders.</li> </ul> <p>By organizing your project in this way, you can scale your application more effectively and maintain a clean and manageable codebase.</p>"},{"location":"frontend/state-management/redux/rtk/folder-structure/#more-advanced","title":"More Advanced","text":"<pre><code>src/\n\u2502\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 store.js\n\u2502   \u2514\u2500\u2500 rootReducer.js\n\u2502\n\u251c\u2500\u2500 features/\n\u2502   \u251c\u2500\u2500 auth/\n\u2502   \u2502   \u251c\u2500\u2500 authApi.js\n\u2502   \u2502   \u251c\u2500\u2500 authSlice.js\n\u2502   \u2502   \u251c\u2500\u2500 Login.js\n\u2502   \u2502   \u2514\u2500\u2500 Register.js\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 counter/\n\u2502   \u2502   \u251c\u2500\u2500 counterApi.js\n\u2502   \u2502   \u251c\u2500\u2500 counterSlice.js\n\u2502   \u2502   \u2514\u2500\u2500 Counter.js\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 user/\n\u2502   \u2502   \u251c\u2500\u2500 userApi.js\n\u2502   \u2502   \u251c\u2500\u2500 userSlice.js\n\u2502   \u2502   \u251c\u2500\u2500 UserProfile.js\n\u2502   \u2502   \u2514\u2500\u2500 UserList.js\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 dashboard/\n\u2502   \u2502   \u251c\u2500\u2500 dashboardApi.js\n\u2502   \u2502   \u251c\u2500\u2500 dashboardSlice.js\n\u2502   \u2502   \u2514\u2500\u2500 Dashboard.js\n\u2502\n\u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 Navbar.js\n\u2502   \u2514\u2500\u2500 PrivateRoute.js\n\u2502\n\u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 api.js\n\u2502   \u251c\u2500\u2500 auth.js\n\u2502   \u2514\u2500\u2500 user.js\n\u2502\n\u251c\u2500\u2500 utils/\n\u2502   \u251c\u2500\u2500 authUtils.js\n\u2502   \u2514\u2500\u2500 apiUtils.js\n\u2502\n\u251c\u2500\u2500 hooks/\n\u2502   \u2514\u2500\u2500 useAuth.js\n\u2502\n\u251c\u2500\u2500 App.js\n\u2514\u2500\u2500 index.js\n</code></pre> Example store.jsrootReducer.js <pre><code>// src/app/store.js\n\nimport { configureStore } from '@reduxjs/toolkit';\nimport rootReducer from './rootReducer';\n\nexport const store = configureStore({\n    reducer: rootReducer,\n    middleware: (getDefaultMiddleware) =&gt;\n        getDefaultMiddleware().concat(),\n});\n</code></pre> <pre><code>// src/app/rootReducer.js\n\nimport { combineReducers } from 'redux';\nimport authReducer from '../features/auth/authSlice';\nimport counterReducer from '../features/counter/counterSlice';\nimport userReducer from '../features/user/userSlice';\nimport dashboardReducer from '../features/dashboard/dashboardSlice';\n\nconst rootReducer = combineReducers({\n    auth: authReducer,\n    counter: counterReducer,\n    user: userReducer,\n    dashboard: dashboardReducer,\n});\n\nexport default rootReducer;\n</code></pre> <p>Feature Slices and APIs</p> Example authSlice.jsauthApi.jsDashboard.jsx <pre><code>// src/features/auth/authSlice.js\n\nimport { createSlice } from '@reduxjs/toolkit';\nimport { login } from './authApi';\n\nconst authSlice = createSlice({\n    name: 'auth',\n    initialState: {\n        user: null,\n        token: null,\n        status: 'idle',\n        error: null,\n    },\n    reducers: {\n        logout: (state) =&gt; {\n        state.user = null;\n        state.token = null;\n        },\n    },\n    extraReducers: (builder) =&gt; {\n        builder\n        .addCase(login.pending, (state) =&gt; {\n            state.status = 'loading';\n        })\n        .addCase(login.fulfilled, (state, action) =&gt; {\n            state.status = 'succeeded';\n            state.user = action.payload.user;\n            state.token = action.payload.token;\n        })\n        .addCase(login.rejected, (state, action) =&gt; {\n            state.status = 'failed';\n            state.error = action.error.message;\n        });\n    },\n});\n\nexport const { logout } = authSlice.actions;\n\nexport default authSlice.reducer;\n</code></pre> <pre><code>// src/features/auth/authApi.js\n\nimport { createAsyncThunk } from '@reduxjs/toolkit';\nimport axios from 'axios';\n\nexport const login = createAsyncThunk('auth/login', async (credentials) =&gt; {\n    const response = await axios.post('/api/auth/login', credentials);\n    return response.data;\n});\n</code></pre> <pre><code>// src/features/dashboard/Dashbaord.jsx\nimport { useSelector } from 'react-redux';\n\nconst Dashboard = () =&gt; {\n    const { user } = useSelector((state) =&gt; state.auth);\n\n    return (\n        &lt;div className=\"dashboard-container\"&gt;\n        &lt;h1&gt;Welcome to your Dashboard, {user?.name}!&lt;/h1&gt;\n        &lt;p&gt;This is a protected route. Only authenticated users can see this.&lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Dashboard;\n</code></pre> <p>Centralized API Service</p> Example api.jsauth.js <pre><code>// src/services/api.js\n\nimport axios from 'axios';\n\nconst apiClient = axios.create({\n    baseURL: '/api',\n    headers: {\n        'Content-Type': 'application/json',\n    },\n});\n\nexport const setAuthToken = (token) =&gt; {\n    if (token) {\n        apiClient.defaults.headers.common['Authorization'] = `Bearer ${token}`;\n    } else {\n        delete apiClient.defaults.headers.common['Authorization'];\n    }\n};\n\nexport default apiClient;\n</code></pre> <pre><code>// src/services/auth.js\n\nimport apiClient from './api';\n\nexport const login = (credentials) =&gt; {\n    return apiClient.post('/auth/login', credentials);\n};\n\nexport const register = (userData) =&gt; {\n    return apiClient.post('/auth/register', userData);\n};\n</code></pre> <p>Utility Functions</p> Example authUtils.js <pre><code>// src/utils/authUtils.js\n\nexport const isAuthenticated = () =&gt; {\n    const token = localStorage.getItem('token');\n    return !!token;\n};\n\nexport const getToken = () =&gt; {\n    return localStorage.getItem('token');\n};\n</code></pre> <p>Custom Hooks</p> Example useAuth.js <pre><code>// src/hooks/useAuth.js\n\nimport { useSelector } from 'react-redux';\n\nconst useAuth = () =&gt; {\n    const { user, token } = useSelector((state) =&gt; state.auth);\n    return { user, token };\n};\n\nexport default useAuth;\n</code></pre> Example App.jsxmain.jsx <pre><code>// src/App.jsx\nimport { BrowserRouter as Router, Routes, Route } from 'react-router-dom';\nimport Login from './features/auth/login.jsx';\nimport Dashboard from './features/dashboard/Dashboard.jsx';\nimport PrivateRoute from './components/PrivateRoute.jsx';\nimport Navbar from './components/Navbar.jsx';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;div&gt;\n            &lt;Navbar /&gt;\n            &lt;Routes&gt;\n                &lt;Route path=\"/login\" element={&lt;Login /&gt;} /&gt;\n                &lt;PrivateRoute path=\"/dashboard\" component={Dashboard} /&gt;\n            &lt;/Routes&gt;\n        &lt;/div&gt;\n    &lt;/Router&gt;\n);\n\nexport default App;\n</code></pre> <pre><code>// src/main.jsx\n\nimport React from 'react'\nimport ReactDOM from 'react-dom/client'\nimport { Provider } from 'react-redux';\nimport { store } from './app/store';\nimport App from './App.jsx'\nimport './index.css'\n\nReactDOM.createRoot(document.getElementById('root')).render(\n    &lt;Provider store={store}&gt;\n        &lt;React.StrictMode&gt;\n            &lt;App /&gt;\n        &lt;/React.StrictMode&gt;\n    &lt;/Provider&gt;\n)\n</code></pre> <p>Components</p> <pre><code>=== \"Navbar.jsx\"\n\n    ```jsx\n    // components/Navbar.jsx\n    import { Link } from 'react-router-dom';\n    import { useDispatch, useSelector } from 'react-redux';\n    import { logout } from '../features/auth/authSlice';\n\n    const Navbar = () =&gt; {\n        const dispatch = useDispatch();\n        const { user } = useSelector((state) =&gt; state.auth);\n\n        const handleLogout = () =&gt; {\n            dispatch(logout());\n        };\n\n        return (\n            &lt;nav&gt;\n                &lt;Link to=\"/\"&gt;Home&lt;/Link&gt;\n                {user ? (\n                    &lt;&gt;\n                        &lt;Link to=\"/dashboard\"&gt;Dashboard&lt;/Link&gt;\n                        &lt;button onClick={handleLogout}&gt;Logout&lt;/button&gt;\n                    &lt;/&gt;\n                ) : (\n                    &lt;Link to=\"/login\"&gt;Login&lt;/Link&gt;\n                )}\n            &lt;/nav&gt;\n        );\n    };\n\n    export default Navbar;\n\n    ```\n\n\n=== \"PrivateRoute.jsx\"\n\n    ```jsx\n    // components/PrivateRoute.jsx\n\n    import { Route, Navigate } from 'react-router-dom';\n    import { useSelector } from 'react-redux';\n    import PropTypes from 'prop-types';\n\n    const PrivateRoute = ({ component: Component, ...rest }) =&gt; {\n        const { token } = useSelector((state) =&gt; state.auth);\n\n        return (\n            &lt;Route\n                {...rest}\n                element={token ? &lt;Component /&gt; : &lt;Navigate to=\"/login\" /&gt;}\n            /&gt;\n        );\n    };\n\n    PrivateRoute.propTypes = {\n        component: PropTypes.elementType.isRequired,\n    };\n\n    export default PrivateRoute;\n    ```\n</code></pre> <p>Summary</p> <ul> <li>Modular Structure: Break down features into separate folders, each containing related slices, API calls, and components.</li> <li>Centralized API Service: Use a single api.js file to configure and manage API calls.</li> <li>Custom Hooks: Create custom hooks for reusable logic.</li> <li>Utility Functions: Use utility functions to manage common operations.</li> </ul> <p>Benefits of this Approach</p> <ol> <li>Scalability: Easy to add new features without disrupting the existing codebase.</li> <li>Maintainability: Clear separation of concerns makes it easier to maintain and update the code.</li> <li>Reusability: Common logic and utilities are centralized, promoting code reuse.</li> <li>Extensibility: Easily extend the application by adding new features, APIs, and components.</li> </ol> <p>By following this modular approach, you can manage a large codebase effectively, ensuring that your application remains organized and maintainable as it grows.</p>"},{"location":"frontend/state-management/redux/rtk/intro/","title":"Intro","text":""},{"location":"frontend/state-management/redux/rtk/intro/#authorization","title":"Authorization","text":"<p>Implementing login and authorization in a React application can be achieved through various libraries and techniques. Here's a step-by-step guide using common libraries like <code>redux</code>, <code>redux-toolkit</code>, <code>react-router</code>, and <code>jwt-decode</code>.</p>"},{"location":"frontend/state-management/redux/rtk/intro/#libraries-to-use","title":"Libraries to Use","text":"<ol> <li>React Router: For handling routing.</li> <li>Redux/Redux Toolkit: For state management.</li> <li>Axios: For making API requests.</li> <li>JWT-decode: For decoding JSON Web Tokens.</li> <li>React Hook Form: For handling form state.</li> </ol>"},{"location":"frontend/state-management/redux/rtk/intro/#step-by-step-implementation","title":"Step-by-Step Implementation","text":"<ol> <li> <p>Setting Up Your Project</p> <p>Install the necessary packages:</p> <pre><code>npm install react-router-dom @reduxjs/toolkit react-redux axios jwt-decode react-hook-form\n</code></pre> </li> <li> <p>Configure Redux Store</p> <p>Set up a Redux store with slices for authentication.</p> <pre><code>// store.js\nimport { configureStore } from '@reduxjs/toolkit';\nimport authReducer from './features/auth/authSlice';\n\nexport const store = configureStore({\n    reducer: {\n        auth: authReducer,\n    },\n});\n</code></pre> </li> <li> <p>Create Authentication Slice</p> <p>Create a slice for authentication state management.</p> <pre><code>// features/auth/authSlice.js\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport axios from 'axios';\nimport jwt_decode from 'jwt-decode';\n\nconst initialState = {\n    token: localStorage.getItem('token') || null,\n    user: localStorage.getItem('token') ? jwt_decode(localStorage.getItem('token')) : null,\n    status: 'idle',\n    error: null,\n};\n\nexport const login = createAsyncThunk('auth/login', async (credentials) =&gt; {\n    const response = await axios.post('/api/auth/login', credentials);\n    return response.data.token;\n});\n\nconst authSlice = createSlice({\n    name: 'auth',\n    initialState,\n    reducers: {\n        logout: (state) =&gt; {\n            state.token = null;\n            state.user = null;\n            localStorage.removeItem('token');\n        },\n    },\n    extraReducers: (builder) =&gt; {\n        builder\n        .addCase(login.pending, (state) =&gt; {\n            state.status = 'loading';\n        })\n        .addCase(login.fulfilled, (state, action) =&gt; {\n            state.status = 'succeeded';\n            state.token = action.payload;\n            state.user = jwt_decode(action.payload);\n            localStorage.setItem('token', action.payload);\n        })\n        .addCase(login.rejected, (state, action) =&gt; {\n            state.status = 'failed';\n            state.error = action.error.message;\n        });\n    },\n});\n\nexport const { logout } = authSlice.actions;\n\nexport default authSlice.reducer;\n</code></pre> </li> <li> <p>Create Login Component</p> <p>Create a component for the login form using react-hook-form.</p> <pre><code>// components/Login.js\nimport React from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { useForm } from 'react-hook-form';\nimport { login } from '../features/auth/authSlice';\nimport { Redirect } from 'react-router-dom';\n\nconst Login = () =&gt; {\n    const dispatch = useDispatch();\n    const { register, handleSubmit } = useForm();\n    const { token, error, status } = useSelector((state) =&gt; state.auth);\n\n    const onSubmit = (data) =&gt; {\n        dispatch(login(data));\n    };\n\n    if (token) {\n        return &lt;Redirect to=\"/\" /&gt;;\n    }\n\n    return (\n        &lt;div&gt;\n            &lt;h2&gt;Login&lt;/h2&gt;\n\n            &lt;form onSubmit={handleSubmit(onSubmit)}&gt;\n                &lt;div&gt;\n                    &lt;label&gt;Email:&lt;/label&gt;\n                    &lt;input type=\"email\" {...register('email')} /&gt;\n                &lt;/div&gt;\n                &lt;div&gt;\n                    &lt;label&gt;Password:&lt;/label&gt;\n                    &lt;input type=\"password\" {...register('password')} /&gt;\n                &lt;/div&gt;\n                &lt;button type=\"submit\"&gt;Login&lt;/button&gt;\n            &lt;/form&gt;\n\n            {status === 'loading' &amp;&amp; &lt;p&gt;Loading...&lt;/p&gt;}\n            {error &amp;&amp; &lt;p&gt;{error}&lt;/p&gt;}\n        &lt;/div&gt;\n    );\n};\n\nexport default Login;\n</code></pre> </li> <li> <p>Protect Routes</p> <p>Create a higher-order component (HOC) to protect routes.</p> <pre><code>// components/PrivateRoute.js\nimport React from 'react';\nimport { Route, Redirect } from 'react-router-dom';\nimport { useSelector } from 'react-redux';\n\nconst PrivateRoute = ({ component: Component, ...rest }) =&gt; {\n    const token = useSelector((state) =&gt; state.auth.token);\n\n    return (\n        &lt;Route\n            {...rest}\n            render={(props) =&gt;\n                token ? (\n                    &lt;Component {...props} /&gt;\n                ) : (\n                    &lt;Redirect to=\"/login\" /&gt;\n                )\n            }\n        /&gt;\n    );\n};\n\nexport default PrivateRoute;\n</code></pre> </li> <li> <p>Set Up Routing</p> <p>Configure routing in your application using React Router.</p> <pre><code>// App.js\nimport React from 'react';\nimport { BrowserRouter as Router, Route, Switch } from 'react-router-dom';\nimport { Provider } from 'react-redux';\nimport { store } from './store';\nimport Login from './components/Login';\nimport PrivateRoute from './components/PrivateRoute';\nimport Home from './components/Home';\n\nconst App = () =&gt; (\n    &lt;Provider store={store}&gt;\n        &lt;Router&gt;\n            &lt;Switch&gt;\n                &lt;Route path=\"/login\" component={Login} /&gt;\n                &lt;PrivateRoute path=\"/\" component={Home} /&gt;\n            &lt;/Switch&gt;\n        &lt;/Router&gt;\n    &lt;/Provider&gt;\n);\n\nexport default App;\n</code></pre> </li> </ol>"},{"location":"frontend/state-management/redux/rtk/intro/#summary","title":"Summary","text":"<ol> <li>Setup Redux store: Configure the store with <code>redux-toolkit</code>.</li> <li>Create auth slice: Manage authentication state with a slice.</li> <li>Login component: Use <code>react-hook-form</code>for handling the login form.</li> <li>Protect routes: Use a higher-order component to protect routes.</li> <li>Configure routing: Set up routing with React Router.</li> </ol> <p>By using these tools and techniques, you can implement robust login and authorization mechanisms in your React application.</p>"},{"location":"frontend/state-management/redux/rtk/intro/#choice","title":"Choice","text":"<ul> <li>Standard Redux is still usable and maintained but involves more boilerplate and manual configuration.</li> <li>Redux Toolkit (RTK) is recommended for new projects as it simplifies Redux setup, encourages best practices, and provides tools to reduce boilerplate.</li> </ul> <p>If you are starting a new project or maintaining an existing one, it is highly advisable to use Redux Toolkit for a better development experience.</p>"},{"location":"frontend/state-management/redux/standard-redux/intro/","title":"Intro","text":""},{"location":"frontend/state-management/redux/standard-redux/intro/#redux-toolkit-a-modern-approach-to-redux","title":"Redux Toolkit: a modern approach to Redux","text":"<p>Redux Toolkit is the official, opinionated, and batteries-included toolset for efficient Redux development. It was created to help developers write better and more efficient Redux code with less boilerplate.</p> <p>Intallation</p>"},{"location":"frontend/state-management/redux/standard-redux/intro/#install-redux-toolkit-and-react-redux","title":"Install Redux Toolkit and React-Redux","text":"<p>Add the Redux Toolkit and React-Redux packages to your project:</p> <pre><code>npm install @reduxjs/toolkit react-redux\n</code></pre> <ul> <li>ofiical redux tookit</li> </ul>"},{"location":"frontend/state-management/redux/standard-redux/intro/#key-features","title":"Key features","text":"<p>Redux Toolkit comes with several key features that simplify the Redux development process:</p> <ul> <li>configureStore: A function that sets up a Redux store with sensible defaults.</li> <li>createSlice: A function that automatically generates action creators and reducers based on a provided configuration.</li> <li>createAction: A utility function to create action creators with a specific type and payload.</li> <li>createReducer: A utility function that simplifies reducer creation using Immer, enabling direct state manipulation.</li> </ul> <p>Redux Middleware is code that lets us intercept redux actions before they reach the reducer. <code>redux-thunk</code> is an example of Redux Middleware, along with other popular <code>redux</code> libraries like <code>redux-logger</code> , <code>redux-promise-middleware</code> , and <code>redux-saga</code> (an alternative to <code>redux-thunk</code> ).</p> <p></p>"},{"location":"frontend/state-management/redux/standard-redux/intro/#redux-thunk-gives-redux-side-effects","title":"Redux Thunk Gives Redux Side-Effects","text":"<p>In <code>redux</code>, actions creators are functions that return an action, which is a plain javascript objects with a <code>type</code> property.</p> <ul> <li><code>redux-thunk</code> is a Redux Middleware that lets your action creators return a function called a thunk, instead of an action. </li> <li>This thunk can return an action when invoked but it also has access to the Redux store's <code>dispatch</code> function, meaning it can also dispatch other actions. </li> <li>Typically, API calls are invoked inside these thunks and different actions are dispatched depending on these API responses.</li> </ul> <p>For example, below are two action creators, the first returns a plain redux action. The second returns a <code>thunk</code>, thanks to <code>redux-thunk</code>.</p> <pre><code>// action creators\n\n// Action Creator returns action\nloadUser = (userData) =&gt; ({\n  type: \"LOAD_USER_DATA\", userData\n})\n\n/* \n  Action Creator which returns function which dispatches other actions\n*/\nfetchUser = (usersUrl) =&gt; (dispatch) =&gt; {\n  dispatch({ type: \"DISPLAY_LOADING_SCREEN\" })\n\n  return fetch(usersUrl)\n    .then(response =&gt; response.json())\n    .then((json) =&gt; {\n      if (json.success) {\n        dispatch({ type: \"LOAD_USER_DATA\", json.userData })\n      } else {\n        dispatch({ type: \"LOAD_USER_FAILED\" })\n      }\n    })\n}\n</code></pre>"},{"location":"frontend/state-management/redux/standard-redux/intro/#summary","title":"Summary","text":"<ul> <li><code>redux-thunk</code> lets us create actions which are functions that can dispatch other functions instead of just objects.</li> <li><code>redux-thunk</code> is an example of Redux Middleware and as such, needs to adhere to the Redux Middleware signature of <code>validMiddleware =&gt; (store) =&gt; (next) =&gt; (action)</code></li> <li>The core logic of <code>redux-thunk</code> is essentially a simple if statement that checks if the action is a thunk (ie. a function) and invokes it if it is. By default, it exports the Middleware with no <code>extraArgument</code> but it then attaches the <code>createThunkMiddleware</code> function onto the exported Middleware to be used if needed.</li> </ul>"},{"location":"frontend/state-management/redux/standard-redux/intro/#differences-between-standard-redux-and-redux-toolkit-rtk","title":"Differences between <code>standard Redux</code> and <code>Redux Toolkit</code> (RTK)","text":"<p>The key differences between standard Redux and Redux Toolkit (RTK) revolve around simplification, boilerplate reduction, and built-in best practices. RTK is a set of tools and recommendations to help write Redux logic more efficiently and with fewer bugs.</p>"},{"location":"frontend/state-management/redux/standard-redux/intro/#standard-redux","title":"Standard Redux","text":"Characteristics: <ol> <li> <p>Boilerplate Code:</p> <p>Writing actions, action creators, and reducers involves a lot of repetitive boilerplate code.</p> </li> <li> <p>Manual Immutable Updates:</p> <p>You must ensure immutability by manually copying and updating state slices, which can be error-prone.</p> </li> <li> <p>Middleware Setup:</p> <p>Middleware like <code>redux-thunk</code> or <code>redux-saga</code> must be manually added and configured.</p> </li> <li> <p>Configure Store:</p> <p>Creating and configuring the store involves several steps and manual setup for middleware, devtools, etc.</p> </li> <li> <p>Async Logic:</p> <p>Handling asynchronous logic typically requires custom middleware and manually structured action types and creators.</p> </li> <li> <p>Code Organization:</p> <p>Developers need to decide how to organize actions, reducers, and constants, leading to varied and inconsistent project structures.</p> </li> </ol>"},{"location":"frontend/state-management/redux/standard-redux/intro/#standard-redux-example","title":"Standard Redux Example","text":"Example ActionsReducerStore Configuration <pre><code>// actions.js\nexport const INCREMENT = 'INCREMENT';\n\nexport const increment = () =&gt; ({\n    type: INCREMENT,\n});\n</code></pre> <pre><code>// reducer.js\nimport { INCREMENT } from './actions';\n\nconst initialState = { value: 0 };\n\nconst counterReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case INCREMENT:\n            return { ...state, value: state.value + 1 };\n        default:\n            return state;\n    }\n};\n\nexport default counterReducer;\n</code></pre> <pre><code>// store.js\nimport { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport counterReducer from './reducer';\n\nconst store = createStore(counterReducer, applyMiddleware(thunk));\n\nexport default store;\n</code></pre>"},{"location":"frontend/state-management/redux/standard-redux/intro/#redux-toolkit-rtk","title":"Redux Toolkit (RTK)","text":"Characteristics: <ol> <li> <p>Reduced Boilerplate:</p> <p>Provides utilities like <code>createSlice</code>, <code>createAsyncThunk</code>, and <code>createAction</code> that automate and reduce boilerplate.</p> </li> <li> <p>Automatic Immutable Updates:</p> <p>Uses Immer under the hood to handle immutable state updates automatically.</p> </li> <li> <p>Integrated Middleware:</p> <p>Pre-configures the store with useful middleware like <code>redux-thunk</code>, and you can easily add more.</p> </li> <li> <p>Simplified Store Configuration:</p> <p>The <code>configureStore</code> function simplifies the store creation process, integrating devtools, middleware, and enhancers by default.</p> </li> <li> <p>Built-in Async Logic:</p> <p>The <code>createAsyncThunk</code> utility standardizes and simplifies handling asynchronous actions.</p> </li> <li> <p>Standardized Code Organization:</p> <p>Encourages a standardized way to organize slices, reducers, and actions, leading to more consistent codebases.</p> </li> </ol>"},{"location":"frontend/state-management/redux/standard-redux/intro/#redux-toolkit-example","title":"Redux Toolkit Example","text":"Example SliceStore Configuration <pre><code>// counterSlice.js\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst counterSlice = createSlice({\n    name: 'counter',\n    initialState: { value: 0 },\n    reducers: {\n        increment: (state) =&gt; {\n            state.value += 1;\n        },\n    },\n});\n\nexport const { increment } = counterSlice.actions;\nexport default counterSlice.reducer;\n</code></pre> <pre><code>// store.js\nimport { configureStore } from '@reduxjs/toolkit';\nimport counterReducer from './counterSlice';\n\nconst store = configureStore({\n    reducer: {\n        counter: counterReducer,\n    },\n});\n\nexport default store;\n</code></pre>"},{"location":"frontend/state-management/redux/standard-redux/intro/#key-benefits-of-rtk","title":"Key Benefits of RTK","text":"<ol> <li>Boilerplate Reduction: By automating repetitive tasks, RTK reduces boilerplate, making the codebase cleaner and easier to maintain.</li> <li>Immutability Handling: Automatic handling of immutable updates using Immer simplifies state updates and reduces bugs.</li> <li>Pre-configured Store: configureStore streamlines the store setup process, providing good defaults and simplifying middleware addition.</li> <li>Async Thunks: createAsyncThunk offers a standardized way to handle async logic, reducing the need for custom middleware.</li> <li>Code Structure: Encourages a modular and consistent way to structure code using slices, leading to more maintainable projects.</li> </ol> <p>Overall, RTK provides a more modern and efficient way to write Redux logic, addressing many of the pain points associated with standard Redux.</p>"},{"location":"frontend/state-management/redux/standard-redux/intro/#reference","title":"Reference","text":"<ul> <li> <p>React 18 Design Patterns - 2023</p> </li> <li> <p>RTK</p> </li> <li>official redux rtk</li> <li>Understanding Redux Toolkit</li> <li> <p>reduxt toolkit</p> </li> <li> <p>Middleware</p> </li> <li>Understanding redux thunk</li> <li>What is the use of middleware Redux thunk ?</li> </ul>"},{"location":"frontend/typescript/typescript-compiler/","title":"compiler","text":""},{"location":"frontend/typescript/typescript-compiler/#typescript-compiler","title":"TypeScript Compiler","text":"<p>TypeScript is transpiled into JavaScript using a compiler.</p> <p>TypeScript being converted into JavaScript means it runs anywhere that JavaScript runs!</p>"},{"location":"frontend/typescript/typescript-compiler/#installing-the-compiler","title":"Installing the Compiler","text":"<p>TypeScript has an official compiler which can be installed through npm.</p> <p>Within your npm project, run the following command to install the compiler:</p> <p>npm install typescript --save-dev</p> <p>You can then run the TypeScript compiler using one of the following commands:</p> <p>npx tsc</p> <p>yarn tsc</p> <p>pnpm tsc</p>"},{"location":"frontend/typescript/typescript-compiler/#globally-installing-typescript","title":"Globally Installing TypeScript","text":"<p>npm install -g typescript</p>"},{"location":"frontend/typescript/typescript-compiler/#configuring-the-compiler","title":"Configuring the compiler","text":"<p>You can have TypeScript create <code>tsconfig.json</code> with the recommended settings with:</p> <p>npx tsc --init</p> <p>Here is an example of more things you could add to the <code>tsconfig.json</code> file:</p> <pre><code>{\n  \"include\": [\"src\"],\n  \"compilerOptions\": {\n    \"outDir\": \"./build\"\n  }\n}\n</code></pre>"},{"location":"frontend/typescript/typescript-compiler/#working-with-typescript-compatible-transpilers","title":"Working with TypeScript-compatible transpilers","text":"<p>There are other tools which convert TypeScript files to JavaScript files</p> <ol> <li>Babel: Babel is a very popular JavaScript transpiler which supports TypeScript files via the plugin @babel/plugin-transform-typescript.</li> <li>swc: swc is a fast transpiler created in Rust which supports many of Babel's features including TypeScript.</li> <li>Sucrase: Sucrase is a Babel fork focused on speed for using in development mode. Sucrase supports TypeScript natively.</li> </ol>"},{"location":"frontend/typescript/typescript-compiler/#reference","title":"Reference","text":"<ul> <li>TypeScript Compiler :w3chools.com</li> </ul>"},{"location":"frontend/typescript/typescript-installation/","title":"installation","text":""},{"location":"frontend/typescript/typescript-installation/#typescript","title":"Typescript","text":""},{"location":"frontend/typescript/typescript-installation/#what-is-typescript","title":"What is TypeScript?","text":"<p>TypeScript is JavaScript with added syntax for types.</p> <p>TypeScript is a syntactic superset of JavaScript which adds static typing.</p> <p>This basically means that TypeScript adds syntax on top of JavaScript, allowing developers to add types.</p> <p>TypeScript being a \"Syntactic Superset\" means that it shares the same base syntax as JavaScript, but adds something to it.</p>"},{"location":"frontend/typescript/typescript-installation/#how-do-i-use-typescript","title":"How do I use TypeScript?","text":"<p>A common way to use TypeScript is to use the official TypeScript compiler, which transpiles TypeScript code into JavaScript.</p> <p>The next section shows how to get the compiler setup for a local project.</p> <p>Some popular code editors, such as Visual Studio Code, have built-in TypeScript support and can show errors as you write code!</p> <p>TypeScript uses compile time type checking. Which means it checks if the specified types match before running the code, not while running the code.</p> <p>TypeScript allows developers to add types to JavaScript.</p>"},{"location":"frontend/typescript/typescript-installation/#reference","title":"Reference","text":"<ul> <li>TypeScript Tutorial: w3schools.com</li> </ul>"},{"location":"interview/codesnap/","title":"Code Snap","text":""},{"location":"interview/codesnap/#destructuring-props","title":"Destructuring props","text":""},{"location":"interview/codesnap/#antd-eclipse-column","title":"antd eclipse column","text":""},{"location":"interview/codesnap/#reference","title":"Reference","text":"<ul> <li>uncontrolled-components: official</li> <li>understanding uncontrolled components an essential-guide-for-react-developers</li> </ul>"},{"location":"interview/micro-frontend/","title":"Micro Frontend","text":""},{"location":"interview/micro-frontend/#micro-frontend","title":"Micro Frontend","text":""},{"location":"interview/micro-frontend/#reference","title":"Reference","text":""},{"location":"interview/react/","title":"React","text":"<p>Tip</p> <ul> <li>Next.js: React framework</li> <li>styled-components: CSS styling</li> <li>apollographql: Data API</li> <li>authjs: Authentication</li> <li>React Testing Library and Jest: Testing</li> <li>GitHub: Version control</li> <li>Vercel: Serverless online web host</li> </ul>"},{"location":"interview/react/#internationalization-and-localization","title":"Internationalization and localization","text":"<p>Internationalization and localization are basic practices in software development that enable you to design and deploy systems that can be tailored to multiple languages and areas. Let\u2019s learn the difference between them.</p>"},{"location":"interview/react/#what-is-internationalization","title":"What is internationalization?","text":"<p>Internationalization is the process of creating and preparing your application so that it can potentially be used in several languages. This frequently entails extracting all of your application\u2019s strings into distinct files that can potentially be translated into multiple languages. It also requires structuring your software to ensure that it can correctly manage and show these translations.</p>"},{"location":"interview/react/#what-is-localization","title":"What is localization?","text":"<p>This involves translating your locally optimized application into specific native languages. Translating an application\u2019s text is only one aspect of localization. It might also include other regionally unique elements, such as text direction, number forms, and date and time formats, among other things. React Router allows you to build localized routes. To manage language choice, you might, for instance, have several routes for various languages (such as \"<code>/en/about</code>\u201d and \"<code>/fr/about</code>\") or you can utilize a context or state.</p> <p>We have learned so much already and our knowledge has increased a lot. Next, we will move on to the penultimate section of this chapter, where we are going to learn all about adding translations and formatted messages in our React applications. We just learned about internationalization and localization, which is where we prepare our applications for different languages. Now, let\u2019s learn how to implement different languages in the code we write.</p>"},{"location":"blog/archive/2024/","title":"2024","text":""},{"location":"blog/page/2/","title":"Blog","text":""},{"location":"blog/page/3/","title":"Blog","text":""},{"location":"blog/archive/2024/page/2/","title":"2024","text":""},{"location":"blog/archive/2024/page/3/","title":"2024","text":""},{"location":"tags/","title":"Tags","text":""},{"location":"tags/#tags","title":"Tags","text":"<ul> <li>Programming</li> <li>Web Development</li> <li>Design</li> <li>Testing</li> <li>Database</li> </ul>"},{"location":"tags/#frameworks","title":"Frameworks","text":"<ul> <li>Django</li> <li>Drf</li> <li>React</li> <li>Jest</li> </ul>"},{"location":"tags/#language","title":"Language","text":"<ul> <li>Python</li> <li>JavaScript</li> </ul>"},{"location":"tags/#tools","title":"Tools","text":"<ul> <li>Vim</li> <li>Git</li> <li>Github</li> <li>SSH</li> </ul>"},{"location":"tags/#misc","title":"Misc","text":"<ul> <li>Personal</li> <li>Postman</li> <li>Redis</li> <li>RabbitMQ</li> <li>SimpleJWT</li> </ul>"},{"location":"tags/#porgramming","title":"Porgramming","text":"<ul> <li>Application Structure for React.js</li> <li>How to Check the React Version in Your Project</li> </ul>"},{"location":"tags/#programming","title":"Programming","text":"<ul> <li>Understanding JavaScript Array Methods: Mutating vs. Non-Mutating</li> <li>React Router v6 Guide</li> </ul>"},{"location":"tags/#react","title":"React","text":"<ul> <li>Application Structure for React.js</li> <li>How to Check the React Version in Your Project</li> </ul>"},{"location":"tags/#arrow","title":"arrow","text":"<ul> <li>JavaScript Arrow Functions</li> </ul>"},{"location":"tags/#base64","title":"base64","text":"<ul> <li>Saving base64 data into an Excel file in a React application</li> </ul>"},{"location":"tags/#databse","title":"databse","text":"<ul> <li>Conditional Rendering in React</li> <li>Handling Multiple API Calls with Search Input in React using Debouncing and Axios</li> <li>Order of Operations in Ant Design Forms: Ensuring Proper Form Resetting</li> <li>Role-Based vs Permission-Based Access Control in React</li> </ul>"},{"location":"tags/#django","title":"django","text":"<ul> <li>Conditional Rendering in React</li> <li>Handling Multiple API Calls with Search Input in React using Debouncing and Axios</li> <li>Order of Operations in Ant Design Forms: Ensuring Proper Form Resetting</li> <li>Role-Based vs Permission-Based Access Control in React</li> </ul>"},{"location":"tags/#formatting","title":"formatting","text":"<ul> <li>Prettier Formatter for Visual Studio Code</li> </ul>"},{"location":"tags/#http","title":"http","text":"<ul> <li>Useful React Libraries for Projects</li> </ul>"},{"location":"tags/#js","title":"js","text":"<ul> <li>Checking Node.js Versions in React Projects</li> <li>Understanding e.item.props in React and Ant Design's Menu Component</li> <li>Exploring Object.prototype in JavaScript</li> <li>Understanding Functional State Updates in React: A Deep Dive into setSelectedGroupData</li> <li>Handling Circular References in JavaScript: Avoiding 'TypeError: cyclic object value' in JSON.stringify</li> <li>Handling JSON Parsing Errors in JavaScript: A Practical Approach</li> <li>History API</li> <li>JavaScript Arrow Functions</li> <li>JS objects</li> <li>Understanding the Difference Between Response Object and Parsed Data Object</li> <li>Unveiling Static and Prototype Methods in JavaScript Built-in Objects</li> </ul>"},{"location":"tags/#postgresql","title":"postgresql","text":"<ul> <li>Conditional Rendering in React</li> <li>Handling Multiple API Calls with Search Input in React using Debouncing and Axios</li> <li>Order of Operations in Ant Design Forms: Ensuring Proper Form Resetting</li> <li>Role-Based vs Permission-Based Access Control in React</li> </ul>"},{"location":"tags/#postman","title":"postman","text":"<ul> <li>Useful React Libraries for Projects</li> </ul>"},{"location":"tags/#react_1","title":"react","text":"<ul> <li>Checking Node.js Versions in React Projects</li> <li>Understanding e.item.props in React and Ant Design's Menu Component</li> <li>Understanding Functional State Updates in React: A Deep Dive into setSelectedGroupData</li> <li>Handling JSON Parsing Errors in JavaScript: A Practical Approach</li> <li>History API</li> <li>Saving base64 data into an Excel file in a React application</li> </ul>"},{"location":"tags/#vscode","title":"vscode","text":"<ul> <li>Prettier Formatter for Visual Studio Code</li> </ul>"}]}