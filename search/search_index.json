{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to JSExpert","text":""},{"location":"#welcome-to-jsexpert","title":"Welcome to JSExpert","text":""},{"location":"#react","title":"React","text":""},{"location":"tags/","title":"Tags","text":""},{"location":"tags/#tags","title":"Tags","text":"<ul> <li>Programming</li> <li>Web Development</li> <li>Design</li> <li>Testing</li> <li>Database</li> </ul>"},{"location":"tags/#frameworks","title":"Frameworks","text":"<ul> <li>Django</li> <li>Drf</li> <li>React</li> <li>Jest</li> </ul>"},{"location":"tags/#language","title":"Language","text":"<ul> <li>Python</li> <li>JavaScript</li> </ul>"},{"location":"tags/#tools","title":"Tools","text":"<ul> <li>Vim</li> <li>Git</li> <li>Github</li> <li>SSH</li> </ul>"},{"location":"tags/#misc","title":"Misc","text":"<ul> <li>Personal</li> <li>Postman</li> <li>Redis</li> <li>RabbitMQ</li> <li>SimpleJWT</li> </ul>"},{"location":"tags/#porgramming","title":"Porgramming","text":"<ul> <li>Application Structure for React.js</li> <li>How to Check the React Version in Your Project</li> </ul>"},{"location":"tags/#programming","title":"Programming","text":"<ul> <li>Understanding JavaScript Array Methods: Mutating vs. Non-Mutating</li> <li>React Router v6 Guide</li> </ul>"},{"location":"tags/#react","title":"React","text":"<ul> <li>Application Structure for React.js</li> <li>How to Check the React Version in Your Project</li> </ul>"},{"location":"tags/#arrow","title":"arrow","text":"<ul> <li>JavaScript Arrow Functions</li> </ul>"},{"location":"tags/#formatting","title":"formatting","text":"<ul> <li>Prettier Formatter for Visual Studio Code</li> </ul>"},{"location":"tags/#js","title":"js","text":"<ul> <li>Checking Node.js Versions in React Projects</li> <li>Understanding Functional State Updates in React: A Deep Dive into setSelectedGroupData</li> <li>Handling JSON Parsing Errors in JavaScript: A Practical Approach</li> <li>History API</li> <li>JavaScript Arrow Functions</li> <li>Understanding the Difference Between Response Object and Parsed Data Object</li> </ul>"},{"location":"tags/#react_1","title":"react","text":"<ul> <li>Checking Node.js Versions in React Projects</li> <li>Understanding Functional State Updates in React: A Deep Dive into setSelectedGroupData</li> <li>Handling JSON Parsing Errors in JavaScript: A Practical Approach</li> <li>History API</li> </ul>"},{"location":"tags/#vscode","title":"vscode","text":"<ul> <li>Prettier Formatter for Visual Studio Code</li> </ul>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2024/05/16/application-structure-for-reactjs/","title":"Application Structure for React.js","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#application-structure-for-reactjs","title":"Application Structure for React.js","text":"<p>React.js itself does not provide a guideline on structuring projects but does suggest a few commonly used approaches.</p> <p>At the high level, you can group files in a React application in two ways:</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#1-group-by-feature","title":"1. Group by feature","text":"<ul> <li>Create folders for every application module, feature, or route.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#2-group-by-file-type","title":"2.  Group by file type","text":"<ul> <li>Create folders for different types of files.</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#group-by-module-feature-or-route","title":"Group by Module, Feature, or Route","text":"<p>In this case, the file structure would mirror the business model or the application flow. For example, if you have an ecommerce application, you will have folders for product, productlist, checkout, etc. The CSS, JSX components, tests, subcomponents, or helper libraries explicitly required for the product module reside in the product folder:</p> <pre><code>common/\n    Avatar.js\n    Avatar.css\n    ErrorUtils.js\n    ErrorUtils.test.js\n\nproduct/\n    index.js\n    product.css\n    price.js\n    product.test.js\n\ncheckout/\n    index.js\n    checkout.css\n    checkout.test.js\n</code></pre> <p>The advantage of grouping files by feature is that if there is a change to the module, all the affected files are colocated in the same folder, and the change gets localized to a specific part of the code.</p> <p>The disadvantage is common components, logic, or styles used across modules should be identified periodically to avoid repetition and promote consistency and reuse.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#group-by-file-type","title":"Group by File Type","text":"<p>In this type of grouping, you would create different folders for CSS, components, test files, images, libraries, etc. Thus, logically related files would reside in different folders based on the file type:</p> <pre><code>css/\n    global.css\n    checkout.css\n    product.css\n\nlib/\n    date.js\n    currency.js\n    gtm.js\n\npages/\n    product.js\n    productlist.js\n    checkout.js\n</code></pre> <p>The advantages of this approach are:</p> <ul> <li>You have a standard structure that you can reuse across projects.</li> <li>Newer team members with little knowledge of the application-specific logic can still find files for something like styles or tests.</li> <li>Common components (such as date pickers) and styles imported in different routes or modules can be changed once to ensure that the effect is seen across the application.</li> </ul> <p>The disadvantages are:</p> <ul> <li>A change in logic for a specific module would likely require changes in files across different folders.</li> <li>As the number of features in the application grows, the number of files in different folders would increase, making it difficult to find a specific file.</li> </ul> <p>Either of these approaches could be easy to set up for small- to mid-sized applications with a small number of files (50 to 100) per folder. For larger projects, however, you may want to go for a hybrid approach based on the logical structure of your application. Let us look at some of the possibilities.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#hybrid-grouping-based-on-domain-and-common-components","title":"Hybrid Grouping Based on Domain and Common Components","text":"<p>Here you would group all common components required across the application in a Components folder and all application flow-specific routes or features in a domain folder (the name could be domain, pages, or routes). Every folder can have subfolders for specific components and related files:</p> <pre><code>css/\n    global.css\ncomponents/\n    User/\n        profile.js\n        profile.test.js\n        avatar.js\n    date.js\n    currency.js\n    gtm.js\n    errorUtils.js\ndomain/\n    product/\n        product.js\n        product.css\n        product.test.js\n    checkout/\n        checkout.js\n        checkout.css\n        checkout.test.js\n</code></pre> <p>Thus, you can combine the advantages of both \u201cGroup by file type\u201d and \u201cGroup by feature\u201d by colocating related files, which change together frequently and common reusable components and styles used across the application. Depending on the complexity of the application, you can modify this to a flatter structure without subfolders or a more nested structure:</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#flatter-structure","title":"Flatter structure","text":"<p>The following example illustrates a flatter structure:</p> <pre><code>domain/\n    product.js\n    product.css\n    product.test.js\n    checkout.js\n    checkout.css\n    checkout.test.js\n</code></pre>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#nested-structure","title":"Nested structure","text":"<p>The following example shows a more nested structure:</p> <pre><code>domain/\n    product/\n        productType/\n            features.js\n            features.css\n            size.js\n        price/\n            listprice.js\n            discount.js\n</code></pre> <p>A variation to this approach is to create folders based on views or routes, in addition to those based on domain, as discussed here. A routing component can then coordinate the view to be displayed based on the current route. Next.js uses a similar structure.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#application-structure-for-modern-react-features","title":"Application Structure for Modern React Features","text":"<p>Modern React apps use different features such as Redux, stateful containers, Hooks, and Styled Components. Let\u2019s see where the code related to these would fit in the application structure proposed in the previous section.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#redux","title":"Redux","text":"<p>Redux documentation strongly recommends colocating logic for a given feature in one place. Within a given feature folder, the Redux logic for that feature should be written as a single \u201cslice\u201d file, preferably using the Redux Toolkit createSlice API.</p> <p>The file bundles <code>{actionTypes, actions, reducer}</code> to a self-contained, isolated module. This is also known as the \u201cducks\u201d pattern (from Redux). </p> <p>For example, as given here:</p> <pre><code>/src\n    index.tsx: Entry point file that renders the React component tree\n\n/app\n    store.ts: store setup\n    rootReducer.ts: root reducer (optional)\n    App.tsx: root React component\n\n/common: hooks, generic components, utils, etc\n\n/features: contains all \"feature folders\"\n\n/todos: a single feature folder\n    todosSlice.ts: Redux reducer logic and associated actions\n    Todos.tsx: a React component\n</code></pre> <p>Another comprehensive example that uses Redux without creating containers or Hooks is available here.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#containers","title":"Containers","text":"<p>If you have structured your code to categorize components into presentational components and stateful container components, you can create a separate folder for the container components. Containers let you separate complex stateful logic from other aspects of the component:</p> <pre><code>/src\n    /components\n        /component1\n            index.js\n            styled.js\n    /containers\n        /container1\n</code></pre> <p>You can find a complete structure for an app with containers in the same article.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#hooks","title":"Hooks","text":"<p>Hooks can fit into the hybrid structure just like any other type of code. You can have a folder at the app level for common Hooks that can be consumed by all React components. React Hooks used by only one component should remain in the component\u2019s file or a separate hooks.js file in the component\u2019s folder. You can find a sample structure here:</p> <pre><code>/components\n    /productList\n        index.js\n        test.js\n        style.css\n        hooks.js\n\n/hooks\n    /useClickOutside\n        index.js\n    /useData\n        index.js\n</code></pre>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#styled-components","title":"Styled Components","text":"<p>If you are using Styled Components instead of CSS, you can have style.js files instead of the component-level CSS files mentioned earlier. For example, if you have a titlebar component, the structure would be something like this:</p> <pre><code>/src/components/button/\n    index.js\n    style.js\n</code></pre> <p>An application-level theme.js file would contain the values for colors to be used for background and text. A globals component could include definitions for common style elements that other components can use.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/16/application-structure-for-reactjs/#reference","title":"Reference","text":"<ul> <li>Learning JavaScript Design Patterns: 2nd edition by Addy Osmani</li> </ul>","tags":["Porgramming","React"]},{"location":"blog/2024/01/22/how-to-check-the-react-version-in-your-project/","title":"How to Check the React Version in Your Project","text":"","tags":["Porgramming","React"]},{"location":"blog/2024/01/22/how-to-check-the-react-version-in-your-project/#how-to-check-the-react-version-in-your-project","title":"How to Check the React Version in Your Project","text":"<p>React, a popular JavaScript library for building user interfaces, undergoes regular updates to introduce new features, improvements, and bug fixes. As a React developer, it's essential to know the version of React used in your project. In this short blog post, we'll explore how you can easily check the React version of your project.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/01/22/how-to-check-the-react-version-in-your-project/#methods-to-check-react-version","title":"Methods to Check React Version:","text":"<ol> <li> <p>Examine <code>package.json</code>:</p> <p>The <code>package.json</code> file is a central configuration file for Node.js projects, including React applications. Open the <code>package.json</code> file in your project's root directory using a text editor. Look for the \"dependencies\" section, where React is listed with its version.</p> <pre><code>\"dependencies\": {\n    \"react\": \"^17.0.1\",\n    \"react-dom\": \"^17.0.1\",\n\n    // other dependencies...\n}\n</code></pre> <p>In this example, the version of React is specified as \"<code>^17.0.1</code>\".</p> </li> <li> <p>Use Command Line:</p> <p>You can also use the command line to check the installed version of React. Open your terminal or command prompt, navigate to your project's root directory, and run the following command:</p> <pre><code>npm list react\n</code></pre> <p>If you're using Yarn, run:</p> <pre><code>yarn list react\n</code></pre> <p>This command will display the version of React installed in your project.</p> </li> <li> <p>Inspect the Browser Console:</p> <p>During development, you can view the React version in your browser's developer tools console. Open your application in a web browser, right-click on the page, select \"Inspect\" to open the developer tools, and navigate to the \"Console\" tab. Type the following command and press Enter:</p> <pre><code>console.log(React.version);\n</code></pre> <p>This will log the React version to the console.</p> </li> </ol>","tags":["Porgramming","React"]},{"location":"blog/2024/01/22/how-to-check-the-react-version-in-your-project/#conclusion","title":"Conclusion:","text":"<p>Knowing the React version in your project is crucial for various reasons, including understanding the available features, compatibility, and potential need for updates. By examining your <code>package.json</code> file, using command-line tools, or inspecting the browser console, you can easily check the React version and ensure your project stays up-to-date with the latest advancements in React development.</p>","tags":["Porgramming","React"]},{"location":"blog/2024/05/11/checking-nodejs-versions-in-react-projects/","title":"Checking Node.js Versions in React Projects","text":"","tags":["react","js"]},{"location":"blog/2024/05/11/checking-nodejs-versions-in-react-projects/#checking-nodejs-versions-in-react-projects","title":"Checking <code>Node.js</code> Versions in React Projects","text":"<p>React itself doesn't directly depend on Node.js version. However, when you're developing a React application, you typically use Node.js and npm (Node Package Manager) to manage your project's dependencies, run development servers, and build your application for production.</p> <p>React projects typically come with a package.json file which specifies the project's dependencies, including the version of Node.js it's compatible with. You can find the required version of Node.js specified in the engines field of the package.json file.</p> package.json<pre><code>\"engines\": {\n  \"node\": \"&gt;=12.0.0\"\n}\n</code></pre> <p>This indicates that the project requires Node.js version <code>12.0.0</code> or later to run properly. You should install the specified version of Node.js on your development machine to ensure compatibility with the React project.</p> <p>You can check the <code>package.json</code> file in your React project's root directory to see which version of Node.js it requires. If you don't have a <code>package.json</code> file, it's likely that your React project hasn't been initialized properly, and you might need to set it up with npm init or yarn init to generate the file.</p>","tags":["react","js"]},{"location":"blog/2024/05/17/understanding-functional-state-updates-in-react-a-deep-dive-into-setselectedgroupdata/","title":"Understanding Functional State Updates in React: A Deep Dive into setSelectedGroupData","text":"","tags":["react","js"]},{"location":"blog/2024/05/17/understanding-functional-state-updates-in-react-a-deep-dive-into-setselectedgroupdata/#understanding-functional-state-updates-in-react-a-deep-dive-into-setselectedgroupdata","title":"Understanding Functional State Updates in React: A Deep Dive into <code>setSelectedGroupData</code>","text":"<p>When managing state in React, especially with complex objects, you often need to update just one part of the state without affecting the rest. A common pattern for this is the functional state update, which ensures your state changes are safe, predictable, and efficient.</p> <p>Let\u2019s break down the line of code:</p> <pre><code>setSelectedGroupData((prevData) =&gt; ({\n    ...prevData,\n    isReadUnread: updatedIsRead,\n}));\n</code></pre> What\u2019s Happening Here? <ol> <li> <p>Functional Update:</p> <p>The function passed to <code>setSelectedGroupData</code> receives the previous state (<code>prevData</code>) as an argument. This approach is particularly useful when your new state depends on the previous one, preventing potential bugs caused by asynchronous state updates.</p> </li> <li> <p>Immutability with the Spread Operator:</p> <p>The spread operator (<code>...prevData</code>) is used to create a shallow copy of the current state. In React, state is immutable\u2014meaning you shouldn't modify it directly. By copying the existing state into a new object, you preserve immutability, which is crucial for React to efficiently detect changes and trigger re-renders.</p> </li> <li> <p>Merging State:</p> <p>After copying the old state, the <code>isReadUnread</code> property is updated with a new value (<code>updatedIsRead</code>). This process ensures that only this specific property is changed, while all other properties remain intact.</p> </li> </ol> Why Use This Pattern? <ul> <li>Avoiding Bugs: Functional updates ensure that your state is always based on the most current data, avoiding potential race conditions.</li> <li>Performance: By only changing the necessary parts of the state, React can optimize re-renders, leading to better performance.</li> <li>Readability: This pattern makes it clear which parts of the state are being updated, making your code easier to understand and maintain.</li> </ul>","tags":["react","js"]},{"location":"blog/2024/05/17/understanding-functional-state-updates-in-react-a-deep-dive-into-setselectedgroupdata/#conclusion","title":"Conclusion","text":"<p>Understanding and utilizing functional state updates in React is essential for building reliable and performant applications. By leveraging patterns like the one we've explored, you can ensure that your state management is both efficient and robust, paving the way for a smoother development process.</p>","tags":["react","js"]},{"location":"blog/2024/05/12/handling-json-parsing-errors-in-javascript-a-practical-approach/","title":"Handling JSON Parsing Errors in JavaScript: A Practical Approach","text":"","tags":["react","js"]},{"location":"blog/2024/05/12/handling-json-parsing-errors-in-javascript-a-practical-approach/#handling-json-parsing-errors-in-javascript-a-practical-approach","title":"Handling JSON Parsing Errors in JavaScript: A Practical Approach","text":"<p>Parsing JSON strings in JavaScript can sometimes lead to unexpected errors, especially when dealing with data from various sources. One common error encountered is \"Unexpected token 's', 'string' is not valid JSON,\" indicating an issue with the input string. In this blog, we'll explore a practical approach to handle such errors effectively.</p>","tags":["react","js"]},{"location":"blog/2024/05/12/handling-json-parsing-errors-in-javascript-a-practical-approach/#understanding-the-problem","title":"Understanding the Problem","text":"<p>The error typically occurs when the input string is not a valid JSON format. For instance, when the input string is plain text or improperly formatted JSON, attempting to parse it will result in a syntax error. To address this, we need to ensure the input is a valid JSON string before parsing it.</p> <p>Bug</p> TypeError: cyclic object value in ReactTypeError: o is undefined <p>Error parsing JSON: SyntaxError: Unexpected token 's', \"string\" is not valid JSON</p> <ul> <li>Error \"Uncaught SyntaxError: Unexpected token with JSON.parse\"</li> <li>How to Fix SyntaxError: Unexpected token &lt; in JSON at position 0</li> <li>JavaScript TypeError \u2013 Cyclic object value</li> <li>TypeError: cyclic object value in React</li> </ul> <ul> <li>TypeError: Cannot read property '0' of undefined in react</li> </ul>","tags":["react","js"]},{"location":"blog/2024/05/12/handling-json-parsing-errors-in-javascript-a-practical-approach/#the-solution","title":"The Solution","text":"<p>To handle this issue, we can follow a structured approach:</p> <ol> <li> <p>Log the Raw Input:</p> <p>Inspect the raw input to understand its content.</p> </li> <li> <p>Check for Valid JSON:</p> <p>Ensure the input is a valid JSON string.</p> </li> <li> <p>Parse Safely:</p> <p>Parse the JSON string and handle any errors gracefully.</p> </li> </ol> <p>Example</p> explainclean code <pre><code>render: (record) =&gt; {\n    console.log(\"Record: \", record);\n\n    try {\n        const rawAttentionTo = record?.attentionTo;\n        console.log(\"Raw attentionTo: \", rawAttentionTo);\n\n        // Check if rawAttentionTo is a valid JSON string\n        if (typeof rawAttentionTo === 'string' &amp;&amp; \n            rawAttentionTo.trim().startsWith('[') &amp;&amp; \n            rawAttentionTo.trim().endsWith(']')) {\n\n            const attentionToArray = JSON.parse(rawAttentionTo);\n            console.log(\"Parsed Array: \", attentionToArray);\n\n            // Ensure the parsed value is an array and contains data\n            if (Array.isArray(attentionToArray) &amp;&amp; attentionToArray.length &gt; 0) {\n                return attentionToArray.map((x) =&gt; x.AttentionTo).join(\", \");\n            }\n        }\n\n        // Return a fallback value if attentionToArray is empty or not an array\n        return \"\";\n    } catch (error) {\n        console.error(\"Error parsing JSON:\", error);\n        return \"\"; // Return an empty string or a fallback value in case of error\n    }\n}\n</code></pre> <pre><code>render: (record) =&gt; {\n    try {\n        const rawAttentionTo = record?.attentionTo;\n\n        if (typeof rawAttentionTo === 'string' &amp;&amp; \n            rawAttentionTo.trim().startsWith('[') &amp;&amp; \n            rawAttentionTo.trim().endsWith(']')) {\n\n            const attentionToArray = JSON.parse(rawAttentionTo);\n\n            if (Array.isArray(attentionToArray) &amp;&amp; attentionToArray.length &gt; 0) {\n                return attentionToArray.map((x) =&gt; x.AttentionTo).join(\", \");\n            }\n        }\n\n        return \"\";\n    } catch (error) {\n        console.error(\"Error parsing JSON:\", error);\n        return \"\";\n    }\n}\n</code></pre>","tags":["react","js"]},{"location":"blog/2024/05/12/handling-json-parsing-errors-in-javascript-a-practical-approach/#why-this-approach-works","title":"Why This Approach Works","text":"<p>This approach works by ensuring that only valid JSON strings are parsed, preventing unexpected errors. By validating the input and handling errors gracefully, we ensure the application remains robust and user-friendly.</p>","tags":["react","js"]},{"location":"blog/2024/05/12/handling-json-parsing-errors-in-javascript-a-practical-approach/#conclusion","title":"Conclusion","text":"<p>Handling JSON parsing errors in JavaScript requires careful validation and error handling. By following the steps outlined above, you can effectively manage and debug JSON parsing issues, ensuring a smoother user experience. Whether you're dealing with data from APIs or other sources, this approach helps maintain the integrity and reliability of your application.</p>","tags":["react","js"]},{"location":"blog/2024/05/13/history-api/","title":"History API","text":"","tags":["react","js"]},{"location":"blog/2024/05/13/history-api/#history-api","title":"History API","text":"<p>The History API in JavaScript provides methods to manipulate the browser's history stack programmatically. This allows developers to navigate back and forth between different states of the application without reloading the page. This API is particularly useful in single-page applications (SPAs) and web applications that dynamically load content without full page refreshes.</p> <p>The History interface of the History API allows manipulation of the browser session history, that is the pages visited in the tab or frame that the current page is loaded in.</p>","tags":["react","js"]},{"location":"blog/2024/05/13/history-api/#importance-of-history-api","title":"Importance of History API:","text":"<ul> <li> <p>Enhanced User Experience: Allows smoother navigation within an application without reloading the entire page, which can improve perceived performance and user experience.</p> </li> <li> <p>State Management: Enables saving and managing application state in the browser history, making it possible to bookmark or share specific states of the application.</p> </li> <li> <p>SEO Benefits: Helps in building SPAs that can still have SEO-friendly URLs and states, as the application can update the URL without reloading the page.</p> </li> </ul>","tags":["react","js"]},{"location":"blog/2024/05/13/history-api/#when-to-use-the-history-api","title":"When to Use the History API:","text":"<ul> <li> <p>Single-Page Applications (SPAs): When building applications where page transitions and state changes occur without full page reloads.</p> </li> <li> <p>Enhancing Navigation: When you want to enable back and forward navigation within your application's states or pages.</p> </li> <li> <p>Managing Application State: When you need to manage and update the browser URL to reflect different states or sections of your application.</p> </li> </ul> <p>Tip</p> Instance propertiesInstance methods <ul> <li>length</li> <li>scrollRestoration</li> <li>state</li> </ul> <ul> <li>back()</li> <li>forward()</li> <li>go()</li> <li>pushState()</li> <li>replaceState()</li> </ul> <p>Example</p> <pre><code>// Adding a new state to the history\nhistory.pushState({ page: 'home' }, \"Home\", \"/\");\n\n// Handling popstate event to detect back/forward navigation\nwindow.onpopstate = function(event) {\nconsole.log('Navigated to state:', event.state);\n// Code to update UI based on the state object\n};\n</code></pre> <p>In this simple example:</p> <ul> <li>history.pushState() adds a new state to the history stack with the specified state object <code>({ page: 'home' })</code>, a title (\"Home\"), and URL (\"/\").</li> <li>window.onpopstate listens for back/forward navigation events (popstate), allowing you to handle these events and update your UI accordingly.</li> </ul>","tags":["react","js"]},{"location":"blog/2024/05/13/history-api/#reference","title":"Reference","text":"<ul> <li>History: mozilla</li> <li>Working_with_the_History_API: mozzila</li> <li>api-reference history :github</li> </ul>","tags":["react","js"]},{"location":"blog/2024/04/01/understanding-javascript-array-methods-mutating-vs-non-mutating/","title":"Understanding JavaScript Array Methods: Mutating vs. Non-Mutating","text":"","tags":["Programming"]},{"location":"blog/2024/04/01/understanding-javascript-array-methods-mutating-vs-non-mutating/#understanding-javascript-array-methods-mutating-vs-non-mutating","title":"Understanding JavaScript Array Methods: Mutating vs. Non-Mutating","text":"<p>When working with arrays in JavaScript, it's crucial to understand the distinction between mutating and non-mutating array methods. This differentiation plays a significant role in how arrays are manipulated and can greatly impact the behavior of your code.</p>","tags":["Programming"]},{"location":"blog/2024/04/01/understanding-javascript-array-methods-mutating-vs-non-mutating/#mutating-array-methods","title":"Mutating Array Methods:","text":"<p>Mutating array methods are those that modify the original array directly. They alter the array's contents in place, without creating a new array.</p> <p>Some commonly used mutating array methods include:</p> <ol> <li> <p><code>push()</code> and <code>pop()</code>: These methods add and remove elements from the end of the array, respectively.</p> </li> <li> <p><code>shift()</code> and <code>unshift()</code>: They add and remove elements from the beginning of the array, respectively.</p> </li> <li> <p><code>splice()</code>: This method can add, remove, or replace elements at any position within the array.</p> </li> <li> <p><code>sort()</code> and <code>reverse()</code>: These methods reorder the elements of the array.</p> </li> <li> <p><code>fill()</code> and <code>copyWithin()</code>: They modify elements within the array based on specified criteria.</p> </li> <li> <p><code>forEach()</code>: It iterates over each element of the array and allows you to perform actions on them.</p> </li> </ol>","tags":["Programming"]},{"location":"blog/2024/04/01/understanding-javascript-array-methods-mutating-vs-non-mutating/#non-mutating-array-methods","title":"Non-Mutating Array Methods:","text":"<p>Non-mutating array methods, on the other hand, do not modify the original array. Instead, they return a new array with the desired modifications, leaving the original array unchanged.</p> <p>Some common non-mutating array methods include:</p> <ol> <li> <p><code>concat()</code>:     This method combines two or more arrays and returns a new array.</p> </li> <li> <p><code>slice()</code>:     It returns a portion of the array without modifying the original array (returns a new array).</p> </li> <li> <p><code>filter()</code> and <code>map()</code>:     These methods create new arrays based on specific criteria or transformations applied to the original array's elements.</p> </li> <li> <p><code>reduce()</code> and <code>reduceRight()</code>:     They reduce the array to a single value based on a provided function.</p> </li> <li> <p><code>some()</code> and <code>every()</code>:     These methods check if certain conditions are met by at least one or all elements in the array, respectively.</p> </li> <li> <p><code>indexOf()</code> and <code>lastIndexOf()</code>:     They find the index of a specified element within the array.</p> </li> </ol> <p>Understanding the difference between <code>mutating</code> and <code>non-mutating</code> array methods is crucial for writing efficient and bug-free JavaScript code. Choosing the appropriate method based on your requirements can lead to cleaner, more maintainable code and prevent unintended side effects.</p>","tags":["Programming"]},{"location":"blog/2024/04/01/understanding-javascript-array-methods-mutating-vs-non-mutating/#conclusion","title":"Conclusion","text":"<p>In summary, mutating array methods directly modify the original array, while non-mutating array methods return a new array without altering the original one. By leveraging these methods effectively, you can harness the full power of JavaScript arrays in your projects.</p>","tags":["Programming"]},{"location":"blog/2024/05/15/javascript-arrow-functions/","title":"JavaScript Arrow Functions","text":"","tags":["js","arrow"]},{"location":"blog/2024/05/15/javascript-arrow-functions/#javascript-arrow-functions","title":"JavaScript Arrow Functions","text":"<p>Modern JavaScript introduced arrow functions as alternatives to regular functions. \u00adThere are two concepts you need to know about arrow functions.</p> <p>First, they use a dif\u00adfer\u00adent syntax than regular functions. Defining an arrow function is much quicker, requiring just a few characters and one line of code. The second impor\u00adt ant, but not so obvious, change is that they use something called a lexical scope, making them more intuitive and less error prone.</p>","tags":["js","arrow"]},{"location":"blog/2024/05/15/javascript-arrow-functions/#writing-arrow-functions","title":"Writing Arrow Functions","text":"<p>Instead of using the function keyword to declare an arrow function, we use the equal-to and greater-\u00adthan signs to form an arrow (=&gt;). This syntax, also called the fat arrow, reduces noise and results in more compact code.</p> <p>Therefore, modern JavaScript prefers this syntax when passing functions as arguments.</p> <p>In addition, if an arrow function has only one \u00adparameter and one statement, we can omit the curly brackets and the return keyword. In this compact form, we call the function a concise body function. Listing 2-10 shows the definition of a traditional function followed by an arrow function.</p> <pre><code>const traditional = function (x) {\n    return x * x;\n}\nconst conciseBody = x =&gt; x * x;\n</code></pre> <p>Listing 2-10: A traditional function and an arrow function with the concise body syntax </p> <p>We first define a standard function with the function keyword and familiar return statement. Then we write the same functionality as an arrow function with the concise body syntax. Here we omit the curly brackets and use an implied return statement, without the return keyword.</p>","tags":["js","arrow"]},{"location":"blog/2024/05/15/javascript-arrow-functions/#reference","title":"Reference","text":"<ul> <li>The complete developer by Martin Krause : pg-20</li> </ul>","tags":["js","arrow"]},{"location":"blog/2024/05/14/prettier-formatter-for-visual-studio-code/","title":"Prettier Formatter for Visual Studio Code","text":"","tags":["vscode","formatting"]},{"location":"blog/2024/05/14/prettier-formatter-for-visual-studio-code/#prettier-formatter-for-visual-studio-code","title":"Prettier Formatter for Visual Studio Code","text":"<p>Prettier is an opinionated code formatter. It enforces a consistent style by parsing your code and re-printing it with its own rules that take the maximum line length into account, wrapping code when necessary.</p> <p></p> <p></p>","tags":["vscode","formatting"]},{"location":"blog/2024/01/18/react-router-v6-guide/","title":"React Router v6 Guide","text":"","tags":["Programming"]},{"location":"blog/2024/01/18/react-router-v6-guide/#react-router-v6-guide","title":"React Router v6 Guide","text":"<p>React Router is a popular library for handling navigation and routing in React applications. It enables the creation of single-page applications (SPAs) by allowing developers to define the navigation structure of their applications, rendering different components based on the URL, and managing browser history.</p> <ol> <li> <p>Installation:</p> <p>Make sure you have React and React DOM installed, and then install React Router:</p> bash<pre><code>npm install react-router-dom\n</code></pre> </li> <li> <p>Basic Usage:</p> <p>Import necessary components:</p> jsx<pre><code>import { BrowserRouter as Router, Routes, Route, Link } from 'react-router-dom';\n</code></pre> <p>Wrap your application with the <code>Router</code> component:</p> jsx<pre><code>function App() {\n    return (\n        &lt;Router&gt;\n        &lt;Routes&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n        &lt;/Routes&gt;\n        &lt;/Router&gt;\n    );\n}\n</code></pre> </li> <li> <p>Nested Routes:</p> <p>You can nest Route components to create nested routes:</p> jsx<pre><code>function App() {\n    return (\n        &lt;Router&gt;\n        &lt;Routes&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/dashboard\" element={&lt;Dashboard /&gt;}&gt;\n            &lt;Route path=\"profile\" element={&lt;Profile /&gt;} /&gt;\n            &lt;Route path=\"settings\" element={&lt;Settings /&gt;} /&gt;\n            &lt;/Route&gt;\n        &lt;/Routes&gt;\n        &lt;/Router&gt;\n    );\n}\n</code></pre> </li> <li> <p>Route Parameters:</p> <p>You can capture parameters from the URL using <code>`:param</code> syntax:</p> jsx<pre><code>&lt;Route path=\"/user/:id\" element={&lt;UserProfile /&gt;} /&gt;\n</code></pre> <p>Access the parameter in the component:</p> jsx<pre><code>import { useParams } from 'react-router-dom';\n\nfunction UserProfile() {\nconst { id } = useParams();\n\n// Use the id parameter\n// ...\n}\n</code></pre> </li> <li> <p>Navigating Between Routes:</p> <p>Use the <code>Link</code> component for navigation:</p> jsx<pre><code>&lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n</code></pre> </li> <li> <p>Navigation Lifecycle Events:</p> <p>React Router v6 introduces the <code>useNavigate</code> hook for programmatic navigation:</p> jsx<pre><code>import { useNavigate } from 'react-router-dom';\n\nfunction MyComponent() {\nconst navigate = useNavigate();\n\nconst handleClick = () =&gt; {\n    // Navigate to a specific route\n    navigate('/new-route');\n};\n\n// ...\n}\n</code></pre> </li> <li> <p>Route Guards:</p> <p>Use the <code>useEffect</code> hook to guard against unauthorized access:</p> jsx<pre><code>import { useEffect } from 'react';\nimport { useNavigate } from 'react-router-dom';\n\nfunction PrivateRoute() {\nconst navigate = useNavigate();\n\nuseEffect(() =&gt; {\n    // Check if the user is authenticated\n    const isAuthenticated = // Your authentication logic here\n\n    if (!isAuthenticated) {\n    // Redirect to the login page\n    navigate('/login');\n    }\n}, [navigate]);\n\n// Render your private route content\nreturn &lt;div&gt;Private Route Content&lt;/div&gt;;\n}\n</code></pre> </li> <li> <p>Query Parameters:</p> <p>Access and manipulate query parameters using the <code>useSearchParams</code> hook:</p> jsx<pre><code>import { useSearchParams } from 'react-router-dom';\n\nfunction MyComponent() {\nconst [searchParams, setSearchParams] = useSearchParams();\n\n// Access and manipulate search parameters\nconst paramValue = searchParams.get('paramName');\nsetSearchParams({ paramName: 'newValue' });\n\n// ...\n}\n</code></pre> </li> <li> <p>Custom Route Matching:</p> <p>You can define custom route matching logic using the <code>path</code> prop and the <code>element</code> prop of the <code>Route</code> component:</p> jsx<pre><code>&lt;Route\n    path=\"/custom-route\"\n    element={&lt;CustomComponent /&gt;}\n    caseSensitive={true}\n/&gt;\n</code></pre> </li> <li> <p>Error Boundary for Routes:</p> <p>Wrap your route components with an error boundary:</p> jsx<pre><code>function ErrorBoundary() {\n    // Your error handling logic\n\n    return (\n        &lt;div&gt;\n        &lt;h1&gt;Something went wrong!&lt;/h1&gt;\n        &lt;/div&gt;\n    );\n}\n\n&lt;Route\n    path=\"/error-boundary\"\n    element={&lt;ErrorBoundary&gt;&lt;ErrorProneComponent /&gt;&lt;/ErrorBoundary&gt;}\n/&gt;\n</code></pre> </li> </ol> <p>This advanced guide covers some key concepts of React Router v6. Remember to refer to the official documentation for the most accurate and up-to-date information.</p>","tags":["Programming"]},{"location":"blog/2024/01/18/react-router-v6-guide/#reference","title":"Reference","text":"","tags":["Programming"]},{"location":"blog/2024/05/10/understanding-the-difference-between-response-object-and-parsed-data-object/","title":"Understanding the Difference Between Response Object and Parsed Data Object","text":"","tags":["js"]},{"location":"blog/2024/05/10/understanding-the-difference-between-response-object-and-parsed-data-object/#understanding-the-difference-between-response-object-and-parsed-data-object","title":"Understanding the Difference Between Response Object and Parsed Data Object","text":"<p>When working with APIs in JavaScript, particularly with the Fetch API, it's crucial to distinguish between the Response object and the parsed data object obtained from API responses. </p> <p>Here\u2019s a concise breakdown to clarify these concepts:</p>","tags":["js"]},{"location":"blog/2024/05/10/understanding-the-difference-between-response-object-and-parsed-data-object/#response-object","title":"Response Object","text":"<ul> <li>Definition: The Response object is provided by the Fetch API to represent the entire HTTP response received from an API endpoint.</li> <li>Contents: It includes metadata such as headers, status codes, and methods to access the response body (e.g., <code>.json()</code>, <code>.text()</code>).</li> <li>Type: When checking its type with <code>typeof</code>, it returns \"object\".</li> <li>Usage: You use the Response object to check the status of the request, access headers, and initiate methods to read and parse the response body content.</li> </ul>","tags":["js"]},{"location":"blog/2024/05/10/understanding-the-difference-between-response-object-and-parsed-data-object/#parsed-data-object","title":"Parsed Data Object","text":"<ul> <li>Definition: After parsing the response body using methods like <code>.json()</code> or <code>.text()</code> on the Response object, you obtain a parsed JavaScript object or string.</li> <li>Contents: This object represents the actual data content received from the API in a usable format within JavaScript.</li> <li>Type: When checking its type with <code>typeof</code>, it typically returns \"object\" (for JSON data) or \"string\" (for text data).</li> <li>Usage: It allows you to directly manipulate and use the data obtained from the API response within your application logic, such as rendering UI components or processing further.</li> </ul> <p>Example Scenario</p> javascript<pre><code>fetch('https://api.example.com/data')\n.then(response =&gt; {\n    if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    return response.json(); // Parse JSON response body\n})\n.then(data =&gt; {\n    // Response object\n    console.log(typeof response); // Outputs: \"object\"\n\n    // Parsed data object\n    console.log(typeof data); // Outputs: \"object\" (if parsed as JSON)\n\n    // Further process 'data' as needed\n    console.log(data); // Parsed JSON data object\n})\n.catch(error =&gt; {\n    console.error('Fetch error:', error);\n});\n</code></pre>","tags":["js"]},{"location":"blog/2024/05/10/understanding-the-difference-between-response-object-and-parsed-data-object/#conclusion","title":"Conclusion","text":"<p>Understanding the distinction between the Response object and the parsed data object is fundamental for effective API integration in JavaScript. The Response object encapsulates the entire HTTP response, while the parsed data object represents the meaningful content of that response in a format suitable for application logic. This clarity enables developers to handle API responses efficiently and leverage data seamlessly in their web applications.</p>","tags":["js"]},{"location":"blog/2024/01/29/understanding-the-impact-of-the-return-statement-in-javascripts-map-function/","title":"Understanding the Impact of the Return Statement in JavaScript's Map Function","text":""},{"location":"blog/2024/01/29/understanding-the-impact-of-the-return-statement-in-javascripts-map-function/#understanding-the-impact-of-the-return-statement-in-javascripts-map-function","title":"Understanding the Impact of the Return Statement in JavaScript's Map Function","text":"<p>In JavaScript, the <code>map</code> function is a powerful tool for transforming arrays by applying a function to each element. However, the presence or absence of the <code>return</code> statement within this function can significantly affect its behavior and the resulting output.</p> <p>Consider the following code snippet:</p> javascript<pre><code>const participantIds = test?.applicationTypeDetails?.tos?.map((item) =&gt; {\n  console.log(\"Ttos: \", item?.participantId);\n  return item?.participantId;\n});\n</code></pre> <p>In this snippet, <code>participantIds</code> is generated by mapping over the tos array, and for each item, we log \"Ttos: \" along with the participantId value. But crucially, we also use the <code>return</code> statement to explicitly specify that the <code>participantId</code> value should be included in the resulting array.</p> <p>Using the <code>return</code> statement ensures that each element processed by the <code>map</code> function contributes a specific value to the resulting array. This clarity is especially important when dealing with potentially <code>undefined</code> values, as it allows for consistent handling.</p> <p>However, if we were to omit the return statement, JavaScript would implicitly add <code>undefined</code> values to the resulting array for each item processed. While this may not always be desirable, it illustrates how the absence of the <code>return</code> statement impacts the function's behavior.</p>"},{"location":"blog/2024/01/29/understanding-the-impact-of-the-return-statement-in-javascripts-map-function/#conclusion","title":"Conclusion","text":"<p>In conclusion, the choice of using or not using the <code>return</code> statement within the <code>map</code> function depends on the desired outcome. Explicitly using return offers clarity and control over the resulting array, especially when dealing with potentially undefined values, while omitting it may lead to implicit <code>undefined</code> values being included in the output. Understanding this distinction empowers JavaScript developers to wield the <code>map</code> function effectively in their code.</p>"},{"location":"blog/2024/04/23/formsetfieldsvalue-vs-defaultvalue-in-react/","title":"form.setFieldsValue vs defaultValue in react","text":""},{"location":"blog/2024/04/23/formsetfieldsvalue-vs-defaultvalue-in-react/#formsetfieldsvalue-vs-defaultvalue-in-react","title":"form.setFieldsValue <code>vs</code> defaultValue in react","text":"<p>Whether to set the default value using form.setFieldsValue or by using the defaultValue prop in <code>&lt;Select&gt;</code> depends on your specific use case and preference.</p> <p>Here's a breakdown of each approach:</p> <ol> <li> <p>Setting Default Value with <code>form.setFieldsValue</code>:</p> <p>Tip</p> jsx<pre><code>import { useEffect } from 'react';\nimport { Form, Select } from 'antd';\n\nconst YourComponent = ({ form, details, remainingLeaveApplicationTypesListing }) =&gt; {\n    useEffect(() =&gt; {\n        form.setFieldsValue({\n            leaveApplicationTypeId: details?.leaveApplicationTypeDto?.id\n        });\n    }, [form, details]);\n\n    return (\n        &lt;Form form={form}&gt;\n            &lt;Form.Item name=\"leaveApplicationTypeId\"&gt;\n                &lt;Select\n                    placeholder=\"Please select\"\n                    autoComplete=\"off\"\n                    // Define a function to handle selection changes\n                    onChange={(value) =&gt; handleSelect(value)}\n                &gt;\n                    {!isEmpty(remainingLeaveApplicationTypesListing) &amp;&amp;\n                    remainingLeaveApplicationTypesListing.map((leaveType, i) =&gt; (\n                        &lt;Select.Option\n                            value={leaveType.leaveApplicationTypeId}\n                            title={leaveType?.leaveApplicationTypeDto?.leaveTypeName}\n                            key={i}\n                        &gt;\n                            {leaveType?.leaveApplicationTypeDto?.leaveTypeName}\n                        &lt;/Select.Option&gt;\n                    ))}\n                &lt;/Select&gt;\n            &lt;/Form.Item&gt;\n        &lt;/Form&gt;\n    );\n};\n</code></pre> <p>With this approach, the default value is set programmatically using form.setFieldsValue inside a useEffect hook. This allows you to set the default value dynamically based on the details object. </p> <p>This approach is suitable when you need to calculate the default value or when the default value depends on asynchronous data fetching.</p> </li> <li> <p>Setting Default Value with <code>defaultValue</code> prop:</p> <p>Tip</p> jsx<pre><code>&lt;Select\n    placeholder=\"Please select\"\n    autoComplete=\"off\"\n    // Set the default value\n    defaultValue={details?.leaveApplicationTypeDto?.id}\n    // Define a function to handle selection changes\n    onChange={(value) =&gt; handleSelect(value)}\n&gt;\n    {!isEmpty(remainingLeaveApplicationTypesListing) &amp;&amp;\n        remainingLeaveApplicationTypesListing.map((leaveType, i) =&gt; (\n            &lt;Select.Option\n                value={leaveType.leaveApplicationTypeId}\n                title={leaveType?.leaveApplicationTypeDto?.leaveTypeName}\n                key={i}\n            &gt;\n                {leaveType?.leaveApplicationTypeDto?.leaveTypeName}\n            &lt;/Select.Option&gt;\n        ))}\n&lt;/Select&gt;\n</code></pre> <p>With this approach, you directly set the default value using the defaultValue prop of the <code>&lt;Select&gt;</code> component. </p> <p>This approach is simpler and more straightforward when you have a static default value or when the default value doesn't depend on other factors.</p> </li> </ol>"},{"location":"blog/2024/04/23/formsetfieldsvalue-vs-defaultvalue-in-react/#which-approach-to-choose","title":"Which Approach to Choose:","text":"<ul> <li>If the default value depends on dynamic data or needs to be calculated based on other state/props, using <code>form.setFieldsValue</code> inside a <code>useEffect</code> hook is more appropriate.</li> <li>If the default value is static or doesn't depend on other factors, using the <code>defaultValue</code> prop directly in the <code>&lt;Select&gt;</code> component is simpler and cleaner.</li> </ul>"},{"location":"frontend/js/intro/","title":"Intro","text":"<p>What\u2019s in a name?</p> <p>The name JavaScript was chosen to take advantage of the popularity of Java \u2013 just as a marketing ploy! Its first name was Mocha, then, LiveScript, and only then JavaScript.</p>"},{"location":"frontend/js/intro/#fp-and-other-programming-paradigms","title":"FP and other programming paradigms","text":"<p>Programming paradigms classify programming languages according to their features. </p> <p>However, some languages may be classified into multiple paradigms \u2013 as is the case of JavaScript itself!</p> <p>A primary division is imperative versus declarative languages. In the former, developers must instruct the machine on how to do its work, step by step. </p> <p>Programming may be procedural (if instructions are grouped into procedures) or object-oriented (if instructions are grouped with a related state).</p> <p>In declarative languages, in opposition, developers just declare properties that the sought result must satisfy, but not how to calculate it. Declarative languages may be logic-based (based on logic rules and constraints), reactive (based on data and event streams), or functional (based on the application and combination of functions). </p> <p>In a sense, we could say that imperative languages focus on how, while declarative languages focus on what.</p> <p>JavaScript is multi-paradigm: it\u2019s imperative (both procedural and object-oriented) but also allows declarative programming, both functional (like almost everything in this book! In particular, we will devote Chapter 5, Programming Declaratively, to this topic) and reactive (we\u2019ll see reactive FP in Chapter 11, Implementing Design Patterns).</p>"},{"location":"frontend/js/intro/#reference","title":"Reference","text":"<ul> <li>Mastering JavaScript Functional Programming Third Edition by Federico Kereki</li> </ul>"},{"location":"frontend/js/core/api-response-object/","title":"Response Object","text":"when we fetch the api endpoint, the reponse data is in which format do we get? object or string <p>When you fetch data from an API endpoint, the response data is typically received as a <code>string</code>. This string needs to be parsed into an object to be usable within your application.</p> Is the json response format is <code>object</code> or <code>string</code> ? <p>When you receive a JSON response from an API, the data is initially received as a string. This string represents the JSON data. To work with this data as a JavaScript object, you need to parse the JSON string into an object.</p> <p>Here's a detailed explanation:</p> so what is the difference between <code>.json()</code> method and <code>JSON.parse</code> when to use. is it the same <p>The <code>.json()</code> method and <code>JSON.parse()</code> serve similar purposes but are used in different contexts. Here's a breakdown of the differences and when to use each:</p> <code>.json()</code> MethodJSON.parse()Key Differences <ul> <li>Context: Used with the <code>fetch</code> API to read and parse the response body as JSON.</li> <li>Functionality: The <code>.json()</code> method is called on a Response object. It reads the response stream to completion and parses it as JSON.</li> <li>Return Value: Returns a promise that resolves with the result of parsing the response body text as JSON.</li> <li>Usage: Use <code>.json()</code> when dealing with the response from a fetch request.</li> </ul>"},{"location":"frontend/js/core/api-response-object/#fetching-api-data-in-javascript","title":"Fetching API Data in JavaScript","text":"<p>When using the <code>fetch</code> API in JavaScript, the response is received as a raw stream of data, which is then processed into a string and parsed as needed. Here's the process:</p> <ol> <li>Fetching the Data:</li> </ol> javascript<pre><code>fetch('https://api.example.com/data')\n.then(response =&gt; response.json())  // Parses the response as JSON\n.then(data =&gt; {\n    console.log(data);  // The data is now a JavaScript object\n})\n.catch(error =&gt; console.error('Error:', error));\n</code></pre> <p>In this example, the <code>response.json()</code> method is called on the response object. This method reads the response stream to completion and parses it as JSON. The result is a JavaScript object.</p> Response Data Formats <ol> <li> <p>JSON (Most Common)</p> <ul> <li>Received as: String</li> <li>Parsed to: JavaScript object</li> <li>Example:</li> </ul> <pre><code>fetch('https://api.example.com/data')\n.then(response =&gt; response.json())  // Converts JSON string to JavaScript object\n.then(data =&gt; {\n    console.log(data);\n});\n</code></pre> </li> <li> <p>Text</p> <ul> <li>Received as: String</li> <li>Example:</li> </ul> <pre><code>fetch('https://api.example.com/text')\n.then(response =&gt; response.text())  // Reads response as plain text\n.then(data =&gt; {\n    console.log(data);\n});\n</code></pre> </li> <li> <p>Blob (Binary Large Object)</p> <ul> <li>Received as: Binary data</li> <li>Example:</li> </ul> <pre><code>fetch('https://api.example.com/image')\n.then(response =&gt; response.blob())  // Reads response as binary data (Blob)\n.then(blob =&gt; {\n    console.log(blob);\n});\n</code></pre> </li> <li> <p>FormData</p> <ul> <li>Received as: Form data</li> <li>Example:</li> </ul> <pre><code>fetch('https://api.example.com/formdata')\n.then(response =&gt; response.formData())  // Reads response as FormData\n.then(formData =&gt; {\n    console.log(formData);\n});\n</code></pre> </li> <li> <p>ArrayBuffer</p> <ul> <li>Received as: Binary data</li> <li>Example:</li> </ul> <pre><code>fetch('https://api.example.com/binary')\n.then(response =&gt; response.arrayBuffer())  // Reads response as ArrayBuffer\n.then(buffer =&gt; {\n    console.log(buffer);\n});\n</code></pre> </li> </ol>"},{"location":"frontend/js/core/api-response-object/#summary","title":"Summary","text":"<p>When fetching data from an API endpoint, the response is initially received as a string or binary data. For JSON responses, which are most common, the string is parsed into a JavaScript object using the <code>response.json()</code> method. Other methods like <code>response.text()</code>, <code>response.blob()</code>, <code>response.formData()</code>, and <code>response.arrayBuffer()</code> are used to handle different types of response data. The parsed data can then be used within your application as needed.</p>"},{"location":"frontend/js/core/api-response-object/#process-of-fetching-and-parsing-json-data","title":"Process of Fetching and Parsing JSON Data","text":"<ol> <li> <p>Fetching the Data:</p> <p>When you use the fetch API to make a request, the response body is a readable stream. This stream needs to be read to obtain the actual data.</p> </li> <li> <p>Response as JSON:</p> <p>The <code>response.json()</code> method reads the response stream to completion and parses the text as JSON. This method returns a promise that resolves with the result of parsing the body text as JSON.</p> </li> </ol>"},{"location":"frontend/js/core/api-response-object/#example-in-javascript","title":"Example in JavaScript","text":"<ol> <li> <p>Fetching and Parsing JSON Data:</p> javascript<pre><code>fetch('https://api.example.com/data')\n.then(response =&gt; response.json())  // Parses the response text as JSON\n.then(data =&gt; {\n    console.log(data);  // 'data' is now a JavaScript object\n})\n.catch(error =&gt; console.error('Error:', error));\n</code></pre> </li> </ol> <p>In this example:</p> <ul> <li><code>fetch('https://api.example.com/data')</code> sends a request to the API.</li> <li><code>response.json()</code> reads the response stream and parses it as JSON, converting it from a string to a JavaScript object.</li> <li>The resulting data is a JavaScript object that can be used in your code.</li> </ul>"},{"location":"frontend/js/core/api-response-object/#clarification-on-json-response","title":"Clarification on JSON Response","text":"<ul> <li>Initial Format: When the JSON response is received from the API, it is in string format.</li> <li>After Parsing: The JSON string is parsed into a JavaScript object using response.json().</li> </ul>"},{"location":"frontend/js/core/api-response-object/#example-of-json-response","title":"Example of JSON Response","text":"<ol> <li> <p>Raw JSON Response (String):</p> json<pre><code>{\n    \"name\": \"Alice\",\n    \"age\": 30,\n    \"isMember\": true\n}\n</code></pre> </li> <li> <p>Parsed JavaScript Object:</p> javascript<pre><code>{\n    name: \"Alice\",\n    age: 30,\n    isMember: true\n}\n</code></pre> </li> </ol> <ul> <li>Context: Used to parse a JSON string into a JavaScript object.</li> <li>Functionality: <code>JSON.parse()</code> takes a JSON string and parses it to produce a JavaScript object.</li> <li>Return Value: Returns a JavaScript object.</li> <li>Usage: Use <code>JSON.parse()</code> when you have a JSON string (e.g., stored in a variable) and need to convert it to a JavaScript object.</li> </ul> javascript<pre><code>let jsonString = '{\"name\": \"Alice\", \"age\": 30, \"isMember\": true}';\nlet data = JSON.parse(jsonString);  // Parses JSON string into JavaScript object\nconsole.log(data.name);  // Output: Alice\n</code></pre> <ol> <li> <p>Source of Data:</p> <ul> <li><code>.json()</code>: Used directly on the Response object returned by the fetch API to handle the response stream.</li> <li><code>JSON.parse()</code>: Used on a JSON string that you already have (e.g., from a variable, local storage, etc.).</li> </ul> </li> <li> <p>Return Type:</p> <ul> <li><code>.json()</code>: Returns a promise that resolves with the parsed JavaScript object.</li> <li><code>JSON.parse()</code>: Directly returns the parsed JavaScript object.</li> </ul> </li> <li> <p>Common Usage:</p> <ul> <li><code>.json()</code>: Commonly used in asynchronous operations involving fetching data from APIs.</li> <li><code>JSON.parse()</code>: Used whenever you have a JSON string and need to convert it to a JavaScript object, irrespective of how you obtained the string.</li> </ul> </li> </ol>"},{"location":"frontend/js/core/api-response-object/#summary_1","title":"Summary","text":"<p>While JSON responses from an API are initially received as strings, they are typically parsed into JavaScript objects using methods like <code>response.json()</code>. This parsing process is necessary to convert the string representation of the JSON data into a format (JavaScript object) that can be easily manipulated in your code.</p>"},{"location":"frontend/js/core/api-response-object/#example","title":"Example","text":"JavaScript<pre><code>fetch('https://api.example.com/data')\n.then(response =&gt; response.json())  // Reads and parses response body as JSON\n.then(data =&gt; {\n    console.log(data);  // 'data' is now a JavaScript object\n})\n.catch(error =&gt; console.error('Error:', error));\n</code></pre>"},{"location":"frontend/js/core/api-response-object/#summary_2","title":"Summary","text":"<ul> <li>Use <code>.json()</code>: When handling responses from fetch API requests to read and parse the JSON response.</li> <li>Use <code>JSON.parse()</code>: When you have a JSON string and need to convert it to a JavaScript object in other contexts.</li> </ul> <p>Both methods are essential for working with JSON data, but they are applied in different scenarios to achieve similar results: converting JSON-formatted data into JavaScript objects.</p>"},{"location":"frontend/js/core/api-response-object/#what-is-reponse-api-object","title":"what is reponse API object","text":"<p>The Response object in the Fetch API represents the response to a request. It contains information about the response, including the status code, status text, headers, and the body of the response. This object is returned as a promise when a fetch request is made.</p> <p>Key Properties and Methods of the Response Object</p> PropertiesMethodsExampleExplanation <ul> <li>type: Indicates the type of the response (e.g., \"basic\", \"cors\", \"error\", \"opaque\").</li> <li>url: The URL of the response.</li> <li>redirected: Indicates whether the response is the result of a redirect.</li> <li>status: The status code of the response (e.g., 200 for a successful request).</li> <li>statusText: The status message corresponding to the status code (e.g., \"OK\" for status 200).</li> <li>ok: A boolean indicating whether the response was successful (status in the range 200-299).</li> <li>headers: The <code>Headers</code> object associated with the response.</li> <li>body: A <code>ReadableStream</code> of the body contents.</li> <li>bodyUsed: A boolean indicating whether the body has been read.</li> </ul> <ul> <li>arrayBuffer(): Reads the response body and returns it as a promise that resolves with an ArrayBuffer.</li> <li>blob(): Reads the response body and returns it as a promise that resolves with a Blob.</li> <li>formData(): Reads the response body and returns it as a promise that resolves with FormData.</li> <li>json(): Reads the response body and parses it as JSON, returning a promise that resolves with a JavaScript object.</li> <li>text(): Reads the response body and returns it as a promise that resolves with a string.</li> </ul> javascript<pre><code>fetch('https://api.example.com/data')\n.then(response =&gt; {\n    // Check if the request was successful\n    if (!response.ok) {\n    throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    // Access response properties\n    console.log(response.status);      // e.g., 200\n    console.log(response.statusText);  // e.g., \"OK\"\n    console.log(response.headers.get('Content-Type'));  // e.g., \"application/json\"\n\n    // Read and parse the response body\n    return response.json();  // Returns a promise that resolves with the JSON-parsed body\n})\n.then(data =&gt; {\n    // 'data' is now a JavaScript object\n    console.log(data);\n})\n.catch(error =&gt; {\n    console.error('Fetch error:', error);\n});\n</code></pre> <ol> <li><code>fetch('https://api.example.com/data')</code>: Initiates a request to the specified URL and returns a promise that resolves to a Response object.</li> <li><code>response.ok</code>: Checks if the response status code indicates a successful request.</li> <li><code>response.status</code>: Accesses the status code of the response.</li> <li><code>response.statusText</code>: Accesses the status text of the response.</li> <li><code>response.headers.get('Content-Type')</code>: Accesses the Content-Type header of the response.</li> <li><code>response.json()</code>: Reads and parses the response body as JSON, returning a promise that resolves to a JavaScript object.</li> <li>Handling the parsed data: The parsed JSON data is logged to the console.</li> <li>Error handling: Catches and logs any errors that occur during the fetch or parsing process.</li> </ol>"},{"location":"frontend/js/core/api-response-object/#summary_3","title":"Summary","text":"<p>The Response object in the Fetch API encapsulates the response to a request, providing access to the status, headers, and body of the response. You use various methods like <code>.json()</code>, <code>.text()</code>, and others to read and parse the response body, converting it into a usable format such as a JavaScript object or string. This process is essential for working with API responses in web development.</p>"},{"location":"frontend/js/core/array-prototype/","title":"Array Prototype","text":""},{"location":"frontend/js/core/array-prototype/#array-prototype","title":"Array Prototype","text":"<p>In JavaScript, the Array prototype is an object that contains methods and properties available to all arrays. When you create a new array, it inherits these methods and properties through its prototype chain.</p> <p>Here's how the prototype chain works for arrays:</p> <ul> <li>When you create an array like <code>let myArray = [1, 2, 3];</code>, myArray inherits from <code>Array.prototype</code>.</li> <li>Array.prototype is itself an object that inherits from Object.prototype.</li> </ul>"},{"location":"frontend/js/core/array-prototype/#why-is-the-array-prototype-important","title":"Why is the Array Prototype Important?","text":"<ul> <li> <p>Inheritance:</p> <p>All arrays have access to the methods defined on Array.prototype. This means you can call methods like push, pop, map, filter, etc., on any array.</p> <pre><code>let myArray = [1, 2, 3];\nmyArray.push(4);\nconsole.log(myArray); // [1, 2, 3, 4]\n</code></pre> </li> <li> <p>Extensibility:</p> <p>You can add custom methods to all arrays by modifying <code>Array.prototype</code>. However, this is generally discouraged in practice because it can lead to conflicts and unexpected behavior, especially in shared environments or libraries.</p> <pre><code>Array.prototype.first = function() {\n    return this[0];\n};\n\nlet myArray = [1, 2, 3];\nconsole.log(myArray.first()); // 1\n</code></pre> </li> <li> <p>Efficiency:</p> <p>By defining methods on the prototype, JavaScript ensures that only one copy of each method exists in memory, regardless of the number of arrays you create. This is more efficient than defining the same method individually for each array instance.</p> </li> </ul>"},{"location":"frontend/js/core/array-prototype/#example-of-adding-a-custom-method-to-array-prototype","title":"Example of Adding a Custom Method to Array Prototype","text":"<pre><code>Array.prototype.last = function() {\n  return this[this.length - 1];\n};\n\nlet myArray = [1, 2, 3, 4];\nconsole.log(myArray.last()); // 4\n</code></pre> <p>In this example:</p> <ul> <li>We add a last method to <code>Array.prototype</code>, which returns the last element of the array.</li> <li>All arrays now have access to this <code>last</code> method.</li> </ul>"},{"location":"frontend/js/core/array-prototype/#summary","title":"Summary","text":"<ul> <li> <p>Higher-order functions are functions that operate on other functions, either by taking them as arguments or by returning them. Many array methods in JavaScript are higher-order functions.</p> </li> <li> <p>The Array prototype is an object from which all arrays inherit their methods and properties. It allows for method sharing and efficient memory use, as well as extensibility by adding custom methods.</p> </li> </ul>"},{"location":"frontend/js/core/array-prototype/#most-important-about-array","title":"Most Important about Array","text":"<p>One of the most important things to learn about arrays in JavaScript to master advanced programming is understanding and effectively utilizing higher-order functions provided by the Array prototype. These functions include methods like <code>map()</code>, <code>filter()</code>, <code>reduce()</code>, <code>forEach()</code>, <code>find()</code>, <code>some()</code>, and <code>every()</code>. Mastering these functions allows you to write concise, expressive, and efficient code for manipulating and processing arrays</p> Example and Explanation of Key Higher-Order Functions: <ol> <li> <p>map():</p> <p>Creates a new array populated with the results of calling a provided function on every element in the calling array.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst doubled = numbers.map(num =&gt; num * 2);\nconsole.log(doubled); // [2, 4, 6, 8]\n</code></pre> </li> <li> <p>filter():</p> <p>Creates a new array with all elements that pass the test implemented by the provided function.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst evens = numbers.filter(num =&gt; num % 2 === 0);\nconsole.log(evens); // [2, 4]\n</code></pre> </li> <li> <p>reduce():</p> <p>Executes a reducer function on each element of the array, resulting in a single output value.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst sum = numbers.reduce((accumulator, currentValue) =&gt; accumulator + currentValue, 0);\nconsole.log(sum); // 10\n</code></pre> </li> <li> <p>forEach():</p> <p>Executes a provided function once for each array element.</p> <pre><code>const numbers = [1, 2, 3, 4];\nnumbers.forEach(num =&gt; console.log(num));\n// Outputs: 1, 2, 3, 4\n</code></pre> </li> <li> <p>find():</p> <p>Returns the value of the first element in the provided array that satisfies the provided testing function.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst firstEven = numbers.find(num =&gt; num % 2 === 0);\nconsole.log(firstEven); // 2\n</code></pre> </li> <li> <p>some():</p> <p>Tests whether at least one element in the array passes the test implemented by the provided function. It returns a Boolean value.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst hasEven = numbers.some(num =&gt; num % 2 === 0);\nconsole.log(hasEven); // true\n</code></pre> </li> <li> <p>every():</p> <p>Tests whether all elements in the array pass the test implemented by the provided function. It returns a Boolean value.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst allEven = numbers.every(num =&gt; num % 2 === 0);\nconsole.log(allEven); // false\n</code></pre> </li> </ol>"},{"location":"frontend/js/core/array-prototype/#why-mastering-these-functions-is-important","title":"Why Mastering These Functions is Important:","text":"<ul> <li>Expressiveness: They allow you to express complex operations on arrays concisely and declaratively.</li> <li>Readability: Code written with these methods is often more readable and easier to understand, as it closely matches the high-level description of the logic.</li> <li>Functional Programming: These methods are fundamental to functional programming techniques, which are powerful for writing clean, maintainable, and bug-resistant code.</li> <li>Efficiency: They are optimized for performance in most JavaScript engines, making them efficient for large datasets.</li> </ul> <p>Understanding and mastering these higher-order functions will significantly enhance your ability to write advanced and efficient JavaScript code.</p>"},{"location":"frontend/js/core/array/","title":"Array","text":""},{"location":"frontend/js/core/array/#array","title":"Array","text":""},{"location":"frontend/js/core/array/#why-is-an-array-an-object-in-javascript","title":"Why is an Array an Object in JavaScript?","text":"<p>In JavaScript, arrays are a type of object because the language is designed around the concept of objects as the fundamental building blocks. Here are a few reasons why arrays are implemented as objects in JavaScript:</p> <ul> <li> <p>Unified Data Structure: JavaScript is a language designed to be flexible and dynamic. By treating arrays as objects, JavaScript can leverage the existing object infrastructure, providing a unified way to handle collections of data.</p> </li> <li> <p>Dynamic Properties and Methods: As objects, arrays can have properties and methods. This allows for powerful features like dynamic resizing, and built-in methods (e.g., <code>push</code>, <code>pop</code>, <code>map</code>, <code>filter</code>) that make working with arrays convenient.</p> </li> <li> <p>Flexibility: Arrays being objects allow them to be extended and manipulated in ways that more rigid, statically-typed arrays in other languages might not support. This fits well with JavaScript's dynamic and loosely-typed nature.</p> </li> </ul>"},{"location":"frontend/js/core/array/#are-arrays-objects-in-other-programming-languages","title":"Are Arrays Objects in Other Programming Languages?","text":"<p>The treatment of arrays varies across different programming languages:</p> <ul> <li> <p>C/C++: In languages like <code>C</code> and <code>C++</code>, arrays are not objects. They are contiguous blocks of memory with a fixed size. Arrays in these languages are more primitive and have limited functionality compared to JavaScript arrays.</p> </li> <li> <p>Java: In Java, arrays are objects. They are instances of a class and have a fixed size once created. They also have properties (like <code>length</code>) and methods.</p> </li> <li> <p>Python: In Python, the closest equivalent to JavaScript arrays is the list. Lists are objects in Python, with dynamic sizing and many built-in methods, similar to JavaScript arrays.</p> </li> <li> <p>Ruby: In Ruby, arrays are also objects. They are instances of the Array class and come with a rich set of methods for manipulation.</p> </li> </ul>"},{"location":"frontend/js/core/array/#reason-behind-the-design-choice","title":"Reason Behind the Design Choice","text":"<p>The decision to make arrays objects in JavaScript (and other high-level languages) often comes down to the following reasons:</p> <ul> <li> <p>Consistency: By making arrays objects, the language maintains a consistent approach to data structures. Everything is an object, which simplifies the language model and makes it easier to learn and use.</p> </li> <li> <p>Extensibility: Arrays as objects can be easily extended with new properties and methods. This allows for more powerful and flexible programming paradigms.</p> </li> <li> <p>Ease of Use: Built-in methods and properties provided by the array object simplify many common tasks, reducing the need for boilerplate code and making the language more expressive and productive for developers.</p> </li> </ul>"},{"location":"frontend/js/core/array/#summary","title":"Summary","text":"<ul> <li>In JavaScript: Arrays are objects to provide a consistent, flexible, and powerful way to handle collections of data.</li> <li>In Other Languages: The treatment of arrays varies, with some languages treating them as primitive types and others as objects.</li> <li>Design Reasons: Making arrays objects allows for extensibility, ease of use, and a unified data structure model.</li> </ul> <p>This design choice reflects JavaScript's overall philosophy of being a flexible and dynamic language, aiming to simplify and enhance the developer experience.</p> what is exactly an array in javascript. <p>Yes, in JavaScript, an array is indeed a type of object. Here's a more detailed explanation:</p> is array an object in javascript <p>In JavaScript, arrays are a type of object. Specifically, they are a specialized type of object designed to store indexed collections of data. Arrays in JavaScript can hold various types of data (such as <code>numbers</code>, <code>strings</code>, <code>objects</code>, or even other <code>arrays</code>) and provide methods for manipulating those data elements.</p> <pre><code>let myArray = [1, 2, 3, 4, 5]; // An array of numbers\n\nconsole.log(typeof myArray); // Outputs: object\nconsole.log(Array.isArray(myArray)); // Outputs: true\n</code></pre> <p>Even though <code>typeof myArray</code> returns \"object\", you can use Array.isArray() to specifically check if a variable is an array. Arrays have additional properties and methods compared to regular objects, such as length for the number of elements and methods like <code>push</code>, <code>pop</code>, <code>forEach</code>, etc., for array manipulation.</p> what do you mean by type of object. is it exactly object? what is it? if it is an object then why do we need isArray <p>In JavaScript, the <code>typeof</code> operator can return several values, including \"object\" for objects and arrays. However, arrays are a specialized type of object with additional features and behaviors tailored specifically for handling ordered collections of data.</p> <p>Here's why <code>Array.isArray()</code> is useful:</p> <ul> <li> <p>Clarity: Arrays and objects are both considered \"object\" types by <code>typeof</code>, so Array.isArray() provides a clear and specific way to determine if a variable is an array.</p> </li> <li> <p>Behavior: Arrays in JavaScript have specialized methods and properties (length, push, pop, etc.) that make them distinct from regular objects. Using Array.isArray() ensures that you are working with an array and can safely use array-specific methods without encountering unexpected behavior.</p> </li> <li> <p>Compatibility: In older versions of JavaScript, before Array.isArray() was introduced in ECMAScript 5 (2009), checking if an object was an array was less straightforward. Array.isArray() provides a reliable cross-browser way to perform this check.</p> </li> </ul> <p>Here\u2019s an example of how you might use Array.isArray():</p> <pre><code>let myArray = [1, 2, 3];\nlet myObject = { key: 'value' };\n\nconsole.log(Array.isArray(myArray)); // true\nconsole.log(Array.isArray(myObject)); // false\n\n// Using typeof\nconsole.log(typeof myArray); // \"object\"\nconsole.log(typeof myObject); // \"object\"\n</code></pre> <p>So, while arrays are objects in JavaScript, Array.isArray() is necessary to distinguish arrays from other types of objects and ensure correct behavior when working with arrays.</p> so why do we need array object type and Array.isArray() <p>The distinction between arrays and regular objects in JavaScript, as well as the use of Array.isArray(), serves several important purposes:</p> <ol> <li> <p>Specialized Functionality:</p> <p>Arrays are specialized objects designed specifically for storing ordered collections of data. They come with built-in methods (push, pop, forEach, etc.) that make it easy to manipulate and iterate over their elements. This specialization allows for efficient handling of sequential data, which is common in programming tasks.</p> </li> <li> <p>Type Checking:</p> <p>JavaScript's typeof operator returns \"object\" for both arrays and regular objects. However, arrays have distinct behavior and capabilities compared to generic objects. Array.isArray() provides a reliable way to specifically check if a variable is an array, ensuring that you can safely use array-specific methods without encountering errors or unexpected behavior.</p> </li> <li> <p>Compatibility:</p> <p>Prior to the introduction of Array.isArray() in ECMAScript 5 (2009), developers often used less reliable methods to check if an object was an array (such as checking for the presence of array-specific methods like push). Array.isArray() provides a standardized and cross-browser-compatible approach to this check.</p> </li> <li> <p>Code Readability:</p> <p>Explicitly using Array.isArray() improves the readability and maintainability of your code. It clearly communicates your intention to check whether a variable is an array, making the code easier to understand for other developers who may work with or maintain it in the future.</p> </li> </ol> <p>In essence, while arrays are objects in JavaScript, they have specialized features that distinguish them from regular objects. Array.isArray() is a utility function that ensures clarity, reliability, and compatibility when working with arrays, helping developers write more robust and understandable code.</p>"},{"location":"frontend/js/core/array/#what-is-an-array","title":"What is an Array?","text":"<p>An array in JavaScript is a special type of object used to store multiple values in a single variable. Unlike regular objects, which use named keys to store values, arrays use numeric indices.</p>"},{"location":"frontend/js/core/array/#characteristics-of-arrays","title":"Characteristics of Arrays","text":"<ol> <li>Indexed Collection: Arrays are indexed, meaning each element in the array has a numbered position (starting from 0).</li> <li>Dynamic Size: Arrays can grow and shrink in size dynamically as elements are added or removed.</li> <li>Zero-based Index: The index of the first element is 0, the second element is 1, and so on.</li> <li>Heterogeneous Elements: Arrays can store elements of different types (numbers, strings, objects, other arrays, etc.).</li> </ol> Example of an Array<pre><code>let fruits = ['Apple', 'Banana', 'Cherry'];\n</code></pre> <p>In this example, <code>fruits</code> is an array containing three string elements.</p>"},{"location":"frontend/js/core/array/#arrays-are-objects","title":"Arrays are Objects","text":"<p>Internally, arrays are a specialized type of object. You can verify this by using the typeof operator:</p> javascript<pre><code>console.log(typeof fruits); // \"object\"\n</code></pre> <p>Despite being objects, arrays have special properties and methods that make them particularly useful for working with ordered collections of data. For example:</p> <ul> <li>length property: Returns the number of elements in the array.</li> <li>push method: Adds one or more elements to the end of the array.</li> <li>pop method: Removes the last element from the array.</li> <li>map method: Creates a new array with the results of calling a provided function on every element in the array.</li> </ul>"},{"location":"frontend/js/core/array/#key-differences-between-arrays-and-objects","title":"Key Differences Between <code>Arrays</code> and <code>Objects</code>","text":"<ul> <li>Indexing: Arrays are indexed using numeric indices, while objects use named keys.</li> <li>Length Property: Arrays have a <code>length</code> property that keeps track of the number of elements. Objects do not have a built-in <code>length</code> property.</li> <li>Iteration: Arrays can be easily iterated using loops (like <code>for</code>, <code>for...of</code>, <code>forEach</code>). Iterating over an object typically requires using a <code>for...in</code> loop or <code>Object.keys()</code>.</li> </ul>"},{"location":"frontend/js/core/array/#summary_1","title":"Summary","text":"<ul> <li>Arrays are objects with additional functionality suited for storing ordered collections of data.</li> <li>They provide methods and properties that make it easier to manipulate sequences of values.</li> </ul> Example: some common array operations<pre><code>let numbers = [1, 2, 3, 4, 5];\n\nconsole.log(numbers.length); // 5\nnumbers.push(6);\nconsole.log(numbers); // [1, 2, 3, 4, 5, 6]\nnumbers.pop();\nconsole.log(numbers); // [1, 2, 3, 4, 5]\n\nnumbers.forEach(num =&gt; console.log(num * 2)); // 2, 4, 6, 8, 10\n</code></pre>"},{"location":"frontend/js/core/array/#example","title":"Example","text":"<p>Tip</p> <p>Certainly! Here are basic and advanced examples demonstrating the usage of <code>Array.isArray()</code> in JavaScript:</p> Basic ExampleAdvanced Example javascript<pre><code>// Basic example\nlet arr = [1, 2, 3];\n\nconsole.log(Array.isArray(arr)); // true\n\nlet obj = { name: 'John', age: 30 };\n\nconsole.log(Array.isArray(obj)); // false\n</code></pre> <p>In this basic example:</p> <ul> <li>Array.isArray(arr) returns true because arr is an array.</li> <li>Array.isArray(obj) returns false because obj is a plain object, not an array.</li> </ul> javascript<pre><code>function processArray(input) {\n    if (Array.isArray(input)) {\n        input.forEach(item =&gt; console.log(item));\n    } else {\n        console.log(\"Input is not an array.\");\n    }\n}\n\nlet arr = [1, 2, 3];\nlet obj = { name: 'Jane', age: 25 };\n\nprocessArray(arr); // Outputs: 1, 2, 3\nprocessArray(obj); // Outputs: \"Input is not an array.\"\n</code></pre> <p>In this advanced example:</p> <ul> <li>The <code>processArray</code> function takes <code>input</code> as a parameter.</li> <li>Inside the function, <code>Array.isArray(input)</code> checks if <code>input</code> is an array.</li> <li>If <code>input</code> is an array, it iterates over its elements using <code>forEach</code>.</li> <li>If <code>input</code> is not an array, it outputs a message indicating that it's not an array.</li> </ul> <p>These examples illustrate how <code>Array.isArray()</code> can be used to safely and reliably determine whether a variable is an array before performing operations specific to arrays. This helps prevent errors and ensures that your code behaves as expected in different scenarios.</p>"},{"location":"frontend/js/core/control-statement/","title":"Control Statement","text":"<p>Control statements in JavaScript allow you to control the flow of execution within your programs. They enable you to make decisions, iterate over collections, and manage complex logical operations. Here are the main control statements in JavaScript:</p> <p>Tip</p> <ul> <li>Conditional Statements: <code>if</code>, <code>if...else</code>, <code>if...else if...else</code>, <code>switch</code>.</li> <li>Looping Statements: <code>for</code>, <code>while</code>, <code>do...while</code>.</li> <li>Jump Statements: <code>break</code>, <code>continue</code>, <code>return</code>.</li> <li>Exception Handling Statements: <code>try...catch</code>, <code>try...catch...finally</code>, <code>throw</code>.</li> </ul> Looping an Array &amp; Object Looping an ArrayLooping through an Object <ol> <li> <p><code>for</code> loop:</p> <ul> <li>Does not return a new array.</li> <li> <p>It is simply a control flow statement.</p> <pre><code>const array = [1, 2, 3, 4, 5];\n\nfor (let i = 0; i &lt; array.length; i++) {\n    console.log(array[i]);\n}\n</code></pre> </li> </ul> </li> <li> <p><code>for...of</code> loop:</p> <ul> <li>Does not return a new array.</li> <li> <p>It is used to iterate over iterable objects.</p> <pre><code>const array = [1, 2, 3, 4, 5];\n\nfor (const item of array) {\n    console.log(item);\n}\n</code></pre> </li> </ul> </li> <li> <p><code>forEach</code> method:</p> <ul> <li>Does not return a new array.</li> <li> <p>It executes a provided function once for each array element.</p> <pre><code>const array = [1, 2, 3, 4, 5];\n\narray.forEach(item =&gt; {\n    console.log(item);\n});\n</code></pre> </li> </ul> </li> <li> <p><code>map</code> method:</p> <ul> <li>Returns a new array.</li> <li> <p>It creates a new array with the results of calling a provided function on every element in the calling array.</p> <pre><code>const array = [1, 2, 3, 4, 5];\n\narray.map(item =&gt; {\n    console.log(item);\n    return item;\n});\n\n// Example\nconst array = [1, 2, 3, 4, 5];\nconst newArray = array.map(item =&gt; item * 2);\nconsole.log(newArray); // [2, 4, 6, 8, 10]\n</code></pre> </li> </ul> </li> </ol> <ol> <li> <p><code>for...in</code> loop:</p> <ul> <li>Does not return a new object.</li> <li> <p>It is used to iterate over the enumerable properties of an object.</p> <pre><code>const obj = {a: 1, b: 2, c: 3};\n\nfor (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n        console.log(key, obj[key]);\n    }\n}\n</code></pre> </li> </ul> </li> <li> <p><code>Object.keys</code> method:</p> <ul> <li> <p>Returns a new array of the object\u2019s own enumerable property names (keys).</p> <pre><code>const obj = {a: 1, b: 2, c: 3};\n\nObject.keys(obj).forEach(key =&gt; {\n    console.log(key, obj[key]);\n});\n\n// Example\nconst obj = {a: 1, b: 2, c: 3};\nconst keys = Object.keys(obj);\nconsole.log(keys); // ['a', 'b', 'c']\n</code></pre> </li> </ul> </li> <li> <p><code>Object.entries</code> method:</p> <ul> <li> <p>Returns a new array of the object\u2019s own enumerable string-keyed property [key, value] pairs.</p> <pre><code>const obj = {a: 1, b: 2, c: 3};\n\nObject.entries(obj).forEach(([key, value]) =&gt; {\n    console.log(key, value);\n});\n\n// Example\nconst obj = {a: 1, b: 2, c: 3};\nconst entries = Object.entries(obj);\nconsole.log(entries); // [['a', 1], ['b', 2], ['c', 3]]\n</code></pre> </li> </ul> </li> <li> <p><code>Object.values</code> method:</p> <ul> <li> <p>Returns a new array of the object\u2019s own enumerable property values.</p> <pre><code>const obj = {a: 1, b: 2, c: 3};\n\nObject.values(obj).forEach(value =&gt; {\n    console.log(value);\n});\n\n// Example\nconst obj = {a: 1, b: 2, c: 3};\nconst values = Object.values(obj);\nconsole.log(values); // [1, 2, 3]\n</code></pre> </li> </ul> </li> </ol> <p>These methods provide flexibility depending on the specific requirements of your task. For example, <code>for...in</code> is generally used for objects, while <code>for...of</code> is typically used for arrays and iterable objects.</p> <p>In summary, among the array methods, only map returns a new array. For objects, Object.keys, Object.entries, and Object.values return new arrays. Methods like for, for...of, forEach, and for...in are used for iteration and do not inherently create new arrays or objects.</p>"},{"location":"frontend/js/core/control-statement/#for-in-vs-for-of-loop","title":"for in <code>vs</code> for of Loop","text":"<p>The <code>for...in</code> and <code>for...of</code> loops are both used for iterating over collections in JavaScript, but they serve different purposes and work with different types of collections.</p>"},{"location":"frontend/js/core/control-statement/#forin-loop","title":"<code>for...in</code> Loop","text":"<ul> <li>Purpose: Iterates over the enumerable properties of an object.</li> <li>Usage: Typically used for iterating over the keys of an object.</li> <li>Works with: Objects (though it can also be used with <code>arrays</code>, it is generally not recommended).</li> </ul> <pre><code>const obj = {a: 1, b: 2, c: 3};\n\nfor (const key in obj) {\n    console.log(key, obj[key]);\n}\n\n// Output:\n// a 1\n// b 2\n// c 3\n</code></pre> <p>When used with <code>arrays</code>, it iterates over the array indices (which are the enumerable properties of the array object).</p> <pre><code>const array = [1, 2, 3, 4, 5];\n\nfor (const index in array) {\n    console.log(index, array[index]);\n}\n\n// Output:\n// 0 1\n// 1 2\n// 2 3\n// 3 4\n// 4 5\n</code></pre>"},{"location":"frontend/js/core/control-statement/#forof-loop","title":"for...of Loop","text":"<ul> <li>Purpose: Iterates over the values of an iterable object.</li> <li>Usage: Typically used for iterating over the values of arrays, strings, maps, sets, and other iterable objects.</li> <li>Works with: Arrays, strings, maps, sets, and other iterable objects.</li> </ul> <pre><code>const array = [1, 2, 3, 4, 5];\n\nfor (const value of array) {\n    console.log(value);\n}\n\n// Output:\n// 1\n// 2\n// 3\n// 4\n// 5\n</code></pre> <p>It can also be used with other iterable objects like strings:</p> <pre><code>const string = \"hello\";\n\nfor (const char of string) {\n    console.log(char);\n}\n\n// Output:\n// h\n// e\n// l\n// l\n// o\n</code></pre>"},{"location":"frontend/js/core/control-statement/#key-differences","title":"Key Differences","text":"<ol> <li> <p>Iteration Target:</p> <ul> <li><code>for...in</code> iterates over the enumerable properties (keys) of an object.</li> <li><code>for...of</code> iterates over the values of an iterable object.</li> </ul> </li> <li> <p>Common Use Cases:</p> <ul> <li><code>for...in</code> is commonly used with objects to get the keys.</li> <li><code>for...of</code> is commonly used with <code>arrays</code>, <code>strings</code>, <code>maps</code>, <code>sets</code>, and other iterable objects to get the values.</li> </ul> </li> <li> <p>Arrays:</p> <ul> <li><code>for...in</code> should generally be avoided for arrays because it iterates over keys (indices) and can include properties from the prototype chain.</li> <li><code>for...of</code> is ideal for arrays as it directly iterates over the values.</li> </ul> </li> <li> <p>Prototype Chain:</p> <ul> <li><code>for...in</code> iterates over all enumerable properties, including those inherited from the prototype chain.</li> <li><code>for...of</code> only iterates over the values of the iterable object and does not consider properties from the prototype chain.</li> </ul> </li> </ol> <p>In summary, use <code>for...in</code> when you need to iterate over the properties of an object and use <code>for...of</code> when you need to iterate over the values of an iterable collection like an array or string.</p>"},{"location":"frontend/js/core/data-types/","title":"Data Type","text":""},{"location":"frontend/js/core/data-types/#data-types-in-js","title":"Data Types in JS","text":"<p>In JavaScript, while many things are objects, not everything is an object. JavaScript has a variety of data types, and understanding which are objects and which are not is important for grasping the language's structure.</p>"},{"location":"frontend/js/core/data-types/#javascript-data-types","title":"JavaScript Data Types","text":"<p>JavaScript has both primitive data types and objects.</p> <p>primitive</p> <p>Object</p>"},{"location":"frontend/js/core/data-types/#primitive-data-types","title":"Primitive Data Types","text":"<p>Primitive data types are not objects and do not have properties or methods. They are immutable and are directly assigned and manipulated.</p> <ol> <li> <p>Number: Represents both integer and floating-point numbers.</p> <pre><code>let num = 42;\n</code></pre> </li> <li> <p>String: Represents a sequence of characters.</p> <pre><code>let str = \"Hello, world!\";\n</code></pre> </li> <li> <p>Boolean: Represents a logical entity with two values: <code>true</code> and <code>false</code>.</p> <pre><code>let bool = true;\n</code></pre> </li> <li> <p>Null: Represents the intentional absence of any object value.</p> <pre><code>let nullValue = null;\n</code></pre> </li> <li> <p>Undefined:: Represents a variable that has been declared but not assigned a value.</p> <pre><code>let undefinedValue;\n</code></pre> </li> <li> <p>Symbol: Represents a unique and immutable identifier.</p> <pre><code>let sym = Symbol('description');\n</code></pre> </li> <li> <p>BigInt: Represents integers with arbitrary precision.</p> <pre><code>let bigInt = 1234567890123456789012345678901234567890n;\n</code></pre> </li> </ol>"},{"location":"frontend/js/core/data-types/#objects","title":"Objects","text":"<p>Objects are collections of properties and are more complex. <code>Arrays</code>, <code>functions</code>, and <code>objects</code> created using the Object constructor or object literals are examples of objects.</p> <ol> <li> <p>Object: General-purpose containers for named properties.</p> <pre><code>let obj = { key: 'value' };\n</code></pre> </li> <li> <p>Array: Ordered lists of values.</p> <pre><code>let arr = [1, 2, 3];\n</code></pre> </li> <li> <p>Function: Callable objects.</p> <pre><code>function func() { return 'Hello!'; }\n</code></pre> </li> <li> <p>Date: Represents dates and times.</p> <pre><code>let date = new Date();\n</code></pre> </li> <li> <p>RegExp: Represents regular expressions.</p> <pre><code>let regex = /abc/;\n</code></pre> </li> <li> <p>Map: Key-value pairs where keys can be of any type.</p> <pre><code>let map = new Map();\n</code></pre> </li> <li> <p>Set: Collections of unique values.</p> <pre><code>let set = new Set();\n</code></pre> </li> </ol>"},{"location":"frontend/js/core/data-types/#why-not-everything-is-an-object","title":"Why Not Everything is an Object","text":"<p>Primitive types are not objects because they are meant to be simple and efficient. They are stored directly in memory rather than by reference, which allows for faster access and manipulation. For example, mathematical operations on numbers or string manipulations are faster because these operations do not involve object overhead. Wrappers for Primitives</p> <p>JavaScript automatically provides temporary objects, known as wrapper objects, when methods or properties are accessed on primitive values. These objects allow primitives to behave like objects in certain contexts.</p> <pre><code>let str = \"hello\";\nconsole.log(str.toUpperCase()); // \"HELLO\"\n</code></pre> <p>In this example, <code>str</code> is a primitive string, but JavaScript temporarily wraps it in a <code>String</code> object to call the <code>toUpperCase</code> method.</p>"},{"location":"frontend/js/core/data-types/#summary","title":"Summary","text":"<ul> <li>Primitive Types: <code>Number</code>, <code>String</code>, <code>Boolean</code>, <code>Null</code>, <code>Undefined</code>, <code>Symbol</code>, <code>BigInt</code>. Not objects, immutable, and have no properties or methods directly.</li> <li>Objects: More complex structures including plain <code>objects</code>, <code>arrays</code>, <code>functions</code>, etc. Have properties and methods and are stored by reference.</li> </ul> <p>While JavaScript provides a unified and flexible approach to handling various data types, understanding the distinction between primitives and objects is crucial for effective programming in JavaScript.</p> autoboxing in javascript"},{"location":"frontend/js/core/data-types/#autoboxing","title":"autoboxing","text":"<p>In JavaScript, when you attempt to access a property or method on a primitive value, the language automatically wraps the primitive in a temporary object so that you can use the properties and methods that are typically available on objects. This process is known as autoboxing. Here\u2019s a detailed explanation of how this works:</p>"},{"location":"frontend/js/core/data-types/#how-javascript-wraps-primitives","title":"How JavaScript Wraps Primitives","text":"<ol> <li> <p>Autoboxing: When you try to access a method or property on a primitive value, JavaScript temporarily converts (or \"boxes\") the primitive value into an object.</p> <pre><code>let str = \"hello\";\nconsole.log(str.toUpperCase()); // \"HELLO\"\n</code></pre> </li> </ol> <p>Here's what happens behind the scenes:</p> <ul> <li>JavaScript sees that you're calling <code>toUpperCase()</code> on the str variable, which is a string primitive.</li> <li>It creates a temporary <code>String</code> object from the primitive value \"hello\".</li> <li>It calls the toUpperCase method on this temporary <code>String</code> object.</li> <li>The method returns the result (\"HELLO\").</li> <li>The temporary <code>String</code> object is discarded.</li> </ul>"},{"location":"frontend/js/core/data-types/#steps-involved","title":"Steps Involved","text":"<ol> <li> <p>Primitive Detection: When you try to access a property or method on a primitive value, the JavaScript engine checks the type of the value.</p> <ul> <li>If the value is a primitive type (<code>string</code>, <code>number</code>, <code>boolean</code>, <code>symbol</code>, <code>bigint</code>), the engine understands that it needs to provide access to the methods and properties that are defined on the corresponding wrapper objects (<code>String</code>, <code>Number</code>, <code>Boolean</code>, <code>Symbol</code>, <code>BigInt</code>).</li> </ul> </li> <li> <p>Temporary Object Creation: The JavaScript engine creates a temporary object of the corresponding wrapper type.</p> <ul> <li>For a string, it creates a <code>String</code> object.</li> <li>For a number, it creates a <code>Number</code> object.</li> <li>For a boolean, it creates a <code>Boolean</code> object.</li> <li>For a symbol, it creates a <code>Symbol</code> object.</li> <li>For a bigint, it creates a <code>BigInt</code> object.</li> </ul> </li> <li> <p>Method/Property Access: The engine uses this temporary object to access the desired method or property.</p> <ul> <li>In the case of \"hello\".toUpperCase(), it creates a <code>String</code> object and calls the <code>toUpperCase</code> method on it.</li> </ul> </li> <li> <p>Result Return and Discarding Temporary Object: The result of the method or property access is returned, and the temporary object is discarded.</p> <ul> <li>The temporary <code>String</code> object is no longer needed after the <code>toUpperCase</code> method is called, so it is discarded.</li> </ul> </li> </ol>"},{"location":"frontend/js/core/data-types/#example-in-detail","title":"Example in Detail","text":"<p>Here\u2019s a more detailed breakdown of the example:</p> <pre><code>let str = \"hello\";\nconsole.log(str.toUpperCase()); // \"HELLO\"\n</code></pre> <ol> <li>Primitive Detection: The JavaScript engine sees that str is a primitive string.</li> <li> <p>Temporary Object Creation: The engine creates a temporary String object that represents the value \"hello\".</p> <pre><code>let tempStrObj = new String(\"hello\");\n</code></pre> </li> <li> <p>Method/Property Access: The engine calls the <code>toUpperCase</code> method on the <code>tempStrObj</code> object.</p> <pre><code>let result = tempStrObj.toUpperCase(); // \"HELLO\"\n</code></pre> </li> <li> <p>Result Return and Discarding Temporary Object: The engine returns the result (\"HELLO\") and discards the temporary <code>String</code> object.</p> </li> </ol>"},{"location":"frontend/js/core/data-types/#summary_1","title":"Summary","text":"<ul> <li>JavaScript uses autoboxing to wrap primitive values in temporary objects when you try to access properties or methods on them.</li> <li>The engine checks the type of the value and creates a corresponding wrapper object (<code>String</code>, <code>Number</code>, <code>Boolean</code>, <code>Symbol</code>, <code>BigInt</code>).</li> <li>After accessing the property or method, the result is returned, and the temporary object is discarded.</li> </ul> <p>This mechanism allows primitive values to behave like objects when needed, providing a seamless and flexible programming experience.</p>"},{"location":"frontend/js/core/data-types/#reference","title":"Reference","text":"<ul> <li>Autoboxing in JavaScript</li> </ul>"},{"location":"frontend/js/core/high-order-function/","title":"High Order Function (Hof)","text":""},{"location":"frontend/js/core/high-order-function/#higher-order-functions","title":"Higher-Order Functions","text":"<p>A higher-order function is a function that does at least one of the following:</p> <ul> <li>Takes one or more functions as arguments.</li> <li>Returns a function as its result.</li> </ul> <p>In JavaScript, many of the methods provided by the Array object are higher-order functions because they accept a function as an argument to process each element in the array. Here are a couple of examples:</p> Example map()filter()reduce()forEach()some()every()find()findIndex()sort()concat() <p>Takes a function as an argument to apply to each element and returns a new array.</p> <pre><code>const numbers = [1, 2, 3];\nconst doubled = numbers.map(num =&gt; num * 2);\nconsole.log(doubled); // [2, 4, 6]\n</code></pre> <p>Takes a function as an argument to determine which elements to include in the new array.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst evens = numbers.filter(num =&gt; num % 2 === 0);\nconsole.log(evens); // [2, 4]\n</code></pre> <p>Executes a reducer function (that you provide) on each element of the array, resulting in a single output value.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst sum = numbers.reduce((accumulator, currentValue) =&gt; accumulator + currentValue, 0);\nconsole.log(sum); // 10\n</code></pre> <p>Executes a provided function once for each array element.</p> <pre><code>const numbers = [1, 2, 3, 4];\nnumbers.forEach(num =&gt; console.log(num)); // 1 2 3 4\n</code></pre> <p>Tests whether at least one element in the array passes the test implemented by the provided function. Returns a Boolean value.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst hasEven = numbers.some(num =&gt; num % 2 === 0);\nconsole.log(hasEven); // true\n</code></pre> <p>Tests whether all elements in the array pass the test implemented by the provided function. Returns a Boolean value.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst allEven = numbers.every(num =&gt; num % 2 === 0);\nconsole.log(allEven); // false\n</code></pre> <p>Returns the value of the first element in the array that satisfies the provided testing function. Otherwise undefined is returned.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst firstEven = numbers.find(num =&gt; num % 2 === 0);\nconsole.log(firstEven); // 2\n</code></pre> <p>Returns the index of the first element in the array that satisfies the provided testing function. Otherwise, -1 is returned.</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst firstEvenIndex = numbers.findIndex(num =&gt; num % 2 === 0);\nconsole.log(firstEvenIndex); // 1\n</code></pre> <p>Sorts the elements of an array in place and returns the sorted array.</p> <pre><code>const numbers = [4, 2, 3, 1];\nnumbers.sort((a, b) =&gt; a - b);\nconsole.log(numbers); // [1, 2, 3, 4]\n</code></pre> <p>Merges two or more arrays. This method does not change the existing arrays, but instead returns a new array.</p> <pre><code>const array1 = [1, 2];\nconst array2 = [3, 4];\nconst combined = array1.concat(array2);\nconsole.log(combined); // [1, 2, 3, 4]\n</code></pre> <p>These functions are \"higher-order\" because they operate on other functions, either by receiving them as arguments or by returning them.</p> what is high order function in javascript? why it is called hof? why do we need them. when does the hof comes in javascript? explain me in depth <p>A higher-order function (HOF) in JavaScript is a function that either takes one or more functions as arguments, returns a function as its result, or both. Higher-order functions are a key feature in functional programming, allowing for more flexible and reusable code.</p> <p>Why It's Called HOF</p> <p>The term \"higher-order\" comes from mathematics, where functions that operate on other functions are called higher-order functions. This terminology has been adopted in programming to describe functions that can take other functions as parameters or return functions as results.</p> <p>Why We Need Higher-Order Functions</p> <ul> <li> <p>Abstraction: Higher-order functions allow for abstraction of actions, not just values. They enable you to create more generic and reusable code by encapsulating behavior that can be varied.</p> </li> <li> <p>Code Reusability: By using HOFs, you can write more generic functions that can be reused with different behaviors, leading to less code duplication.</p> </li> <li> <p>Functional Programming: They are a cornerstone of functional programming, promoting a declarative coding style. This can make code more readable and maintainable.</p> </li> <li> <p>Composability: HOFs enable function composition, which is a way to build complex functions by combining simpler ones.</p> </li> </ul> <p>Examples of Higher-Order Functions</p> Functions as Arguments:Functions as Return Values:Both: <pre><code>function filter(array, test) {\n    let passed = [];\n    for (let element of array) {\n        if (test(element)) {\n            passed.push(element);\n        }\n    }\n    return passed;\n}\n\nconst isEven = n =&gt; n % 2 === 0;\nconst numbers = [1, 2, 3, 4, 5, 6];\nconsole.log(filter(numbers, isEven)); // [2, 4, 6]\n</code></pre> <pre><code>function createMultiplier(multiplier) {\n    return function(x) {\n        return x * multiplier;\n    };\n}\n\nconst double = createMultiplier(2);\nconsole.log(double(5)); // 10\n</code></pre> <pre><code>function repeat(n, action) {\n    for (let i = 0; i &lt; n; i++) {\n        action(i);\n    }\n}\n\nrepeat(3, console.log);\n// Output:\n// 0\n// 1\n// 2\n</code></pre> <p>Common JavaScript Higher-Order Functions</p> <ol> <li> <p>Array.prototype.map():</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst doubled = numbers.map(n =&gt; n * 2);\nconsole.log(doubled); // [2, 4, 6, 8]\n</code></pre> </li> <li> <p>Array.prototype.filter():</p> <pre><code>const numbers = [1, 2, 3, 4, 5];\nconst evens = numbers.filter(n =&gt; n % 2 === 0);\nconsole.log(evens); // [2, 4]\n</code></pre> </li> <li> <p>Array.prototype.reduce():</p> <pre><code>const numbers = [1, 2, 3, 4];\nconst sum = numbers.reduce((acc, n) =&gt; acc + n, 0);\nconsole.log(sum); // 10\n</code></pre> </li> </ol> <p>When Do HOFs Come in JavaScript?</p> <p>HOFs come into play in various scenarios:</p> <ul> <li>Array Operations: Functions like <code>map</code>, <code>filter</code>, <code>reduce</code>, and <code>forEach</code> are higher-order functions that operate on arrays.</li> <li>Event Handling: Functions like <code>addEventListener</code> in the browser API take a callback function to be executed when an event occurs.</li> <li>Asynchronous Programming: Functions like <code>setTimeout</code>, <code>setInterval</code>, and <code>promises</code> use callbacks to handle asynchronous operations.</li> </ul> <p>Conclusion</p> <p>Higher-order functions are a powerful feature in JavaScript that allows for more flexible, reusable, and composable code. They enable a functional programming approach, promoting a declarative coding style and making complex operations more manageable. Understanding and using HOFs can greatly enhance your ability to write clean and efficient JavaScript code.</p> higher-order functions can be applied in various contexts beyond array operations? <ol> <li> <p>Event Handling</p> <p>Higher-order functions are widely used in event handling in web development.</p> <pre><code>document.getElementById(\"myButton\").addEventListener(\"click\", function() {\n    alert(\"Button was clicked!\");\n});\n</code></pre> <p>In this example, <code>addEventListener</code> is a higher-order function that takes another function (the event handler) as an argument.</p> </li> <li> <p>Asynchronous Programming</p> <p>Higher-order functions are crucial in asynchronous programming with <code>callbacks</code>, <code>promises</code>, and <code>async/await</code>.</p> Callbacks<pre><code>function fetchData(callback) {\n    setTimeout(() =&gt; {\n        const data = { name: \"John\", age: 30 };\n        callback(data);\n    }, 1000);\n}\n\nfetchData(function(data) {\n    console.log(data);\n});\n</code></pre> Promises<pre><code>function fetchData() {\n    return new Promise((resolve, reject) =&gt; {\n        setTimeout(() =&gt; {\n        const data = { name: \"John\", age: 30 };\n        resolve(data);\n        }, 1000);\n    });\n}\n\nfetchData().then(data =&gt; {\n    console.log(data);\n});\n</code></pre> </li> <li> <p>Function Composition</p> <p>Higher-order functions are used to compose functions.</p> <pre><code>const add = x =&gt; x + 1;\nconst multiply = x =&gt; x * 2;\n\nconst compose = (f, g) =&gt; x =&gt; f(g(x));\n\nconst addThenMultiply = compose(multiply, add);\n\nconsole.log(addThenMultiply(5)); // 12\n</code></pre> </li> <li> <p>Middleware</p> <p>In frameworks like <code>Express.js</code>, middleware functions are higher-order functions that process HTTP requests and responses.</p> <pre><code>const express = require(\"express\");\nconst app = express();\n\napp.use((req, res, next) =&gt; {\n    console.log(\"Middleware function\");\n    next();\n});\n\napp.get(\"/\", (req, res) =&gt; {\n    res.send(\"Hello World\");\n});\n\napp.listen(3000);\n</code></pre> </li> <li> <p>Currying</p> <p>Currying transforms a function with multiple arguments into a sequence of functions each with a single argument.</p> <pre><code>const multiply = a =&gt; b =&gt; a * b;\nconst double = multiply(2);\nconsole.log(double(5)); // 10\n</code></pre> </li> </ol> <p>Conclusion</p> <p>Higher-order functions in JavaScript are versatile and can be applied in various contexts, including but not limited to array operations. They play a significant role in event handling, asynchronous programming, function composition, middleware, and more. Understanding how to use higher-order functions effectively can greatly enhance your programming skills and enable you to write more flexible and reusable code.</p> does high order function used in object? <p>Yes, higher-order functions can be used with objects in JavaScript. While they are often associated with arrays due to methods like <code>map</code>, <code>filter</code>, and <code>reduce</code>, higher-order functions can operate on objects and be used in various object-oriented programming scenarios. Here are some examples to illustrate how higher-order functions can be used with objects:</p> <p>1. Iterating Over Object Properties</p> <p>You can create higher-order functions to iterate over an object's properties.</p> Mapping Over Object Properties<pre><code>const mapObject = (obj, fn) =&gt; {\n    const result = {};\n    for (const [key, value] of Object.entries(obj)) {\n        result[key] = fn(value);\n    }\n    return result;\n};\n\nconst user = { name: \"Alice\", age: 25, country: \"USA\" };\nconst upperCasedUser = mapObject(user, val =&gt; val.toString().toUpperCase());\nconsole.log(upperCasedUser); \n// { name: \"ALICE\", age: \"25\", country: \"USA\" }\n</code></pre> <p>2. Object Methods as Higher-Order Functions</p> <p>Objects can have methods that accept functions as arguments or return functions.</p> Configurable Logger<pre><code>const logger = {\n    log: (message) =&gt; console.log(`LOG: ${message}`),\n    error: (message) =&gt; console.error(`ERROR: ${message}`),\n    withPrefix: function(prefix) {\n        return (message) =&gt; this.log(`${prefix} ${message}`);\n    }\n};\n\nconst prefixedLogger = logger.withPrefix(\"Prefix\");\nprefixedLogger(\"This is a message.\"); \n// LOG: Prefix This is a message.\n</code></pre> <p>3. Functional Programming with Objects</p> <p>You can use higher-order functions to manipulate objects in a functional programming style.</p> Object Transformation<pre><code>const transformObject = (obj, transformFn) =&gt; {\n    return Object.keys(obj).reduce((acc, key) =&gt; {\n        acc[key] = transformFn(obj[key]);\n        return acc;\n    }, {});\n};\n\nconst user = { name: \"Alice\", age: 25, country: \"USA\" };\nconst doubledAgesUser = transformObject(user, val =&gt; typeof val === 'number' ? val * 2 : val);\nconsole.log(doubledAgesUser); \n// { name: \"Alice\", age: 50, country: \"USA\" }\n</code></pre> <p>4. Creating Fluent APIs</p> <p>Higher-order functions can help create fluent APIs, where methods can be chained together.</p> Fluent API for Object Manipulation<pre><code>const user = {\n    name: \"Alice\",\n    age: 25,\n    setName: function(newName) {\n        this.name = newName;\n        return this;\n    },\n    setAge: function(newAge) {\n        this.age = newAge;\n        return this;\n    }\n};\n\nconst updatedUser = user.setName(\"Bob\").setAge(30);\nconsole.log(updatedUser); \n// { name: \"Bob\", age: 30, setName: [Function], setAge: [Function] }\n</code></pre> <p>Conclusion</p> <p>Higher-order functions are not limited to arrays and can be effectively used with objects in JavaScript. They enable powerful patterns for iterating over object properties, transforming objects, creating methods that accept or return functions, and building fluent APIs. Understanding how to apply higher-order functions to objects can help you write more flexible, reusable, and expressive code.</p> Example <p>In JavaScript, a higher-order function is a function that either takes one or more functions as arguments or returns a function as a result. This allows for more abstract and flexible code.</p> <p>Here's a simple mathematical example using higher-order functions in JavaScript:</p> <p>Example 1: Function that multiplies numbers by a given factor</p> <p>We'll create a higher-order function called <code>createMultiplier</code> that takes a number as an argument and returns a new function. This returned function will multiply its input by the given number.</p> <pre><code>// Higher-order function\nfunction createMultiplier(factor) {\n    // Returning a new function\n    return function(number) {\n        return number * factor;\n    };\n}\n\n// Using the higher-order function to create multiplier functions\nconst double = createMultiplier(2);\nconst triple = createMultiplier(3);\n\n// Testing the created functions\nconsole.log(double(5)); // Output: 10\nconsole.log(triple(5)); // Output: 15\n</code></pre> <p>Explanation</p> <ul> <li>Higher-Order Function: <code>createMultiplier</code> is a higher-order function because it takes a number (<code>factor</code>) as an argument and returns a new function.</li> <li>Returned Function: The returned function takes another number (<code>number</code>) as an argument and multiplies it by the <code>factor</code>.</li> <li>Usage: We use <code>createMultiplier</code> to create two new functions: <code>double</code> (which multiplies by 2) and <code>triple</code> (which multiplies by 3).</li> <li>Testing: When we call <code>double(5)</code>, it returns <code>10</code> (because 5\u00d72=10). When we call <code>triple(5)</code>, it returns <code>15</code> (because 5\u00d73=15).</li> </ul> <p>Another Example: Function Composition</p> <p>Here's another mathematical example using higher-order functions for function composition:</p> <pre><code>// Higher-order function for function composition\nfunction compose(f, g) {\n    // Returning a new function\n    return function(x) {\n        return f(g(x));\n    };\n}\n\n// Simple mathematical functions\nfunction add2(x) {\n    return x + 2;\n}\n\nfunction square(x) {\n    return x * x;\n}\n\n// Using the compose function\nconst add2AndSquare = compose(square, add2);\n\n// Testing the composed function\nconsole.log(add2AndSquare(3)); // Output: 25\n</code></pre> <p>Explanation</p> <ul> <li>Higher-Order Function: <code>compose</code> is a higher-order function because it takes two functions (<code>f</code> and <code>g</code>) as arguments and returns a new function.</li> <li>Returned Function: The returned function takes a number (<code>x</code>) as an argument and applies <code>g</code> to <code>x</code>, then applies <code>f</code> to the result of <code>g(x)</code>.</li> <li>Simple Functions: <code>add2</code> adds 2 to its input, and <code>square</code> squares its input.</li> <li>Usage: We use <code>compose</code> to create a new function <code>add2AndSquare</code> which first adds 2 to the input and then squares the result.</li> <li>Testing: When we call <code>add2AndSquare(3)</code>, it returns <code>25</code> (because (3+2)\u00d7(3+2)=5\u00d75=25).</li> </ul> <p>Higher-order functions are powerful tools in functional programming, allowing you to create more flexible and reusable code by abstracting common patterns.</p> Warning <p>The two functions you've provided are quite different in both their structure and their behavior. Let's break down the differences:</p> <p>First Function: Higher-Order Function</p> <pre><code>function createMultiplier(factor) {\n    // Returning a new function\n    return function(number) {\n        return number * factor;\n    };\n}\n</code></pre> <p>Explanation:</p> <ul> <li>Higher-Order Function: This function is a higher-order function because it returns a new function.</li> <li>Returned Function: The returned function takes an argument <code>number</code> and multiplies it by factor.</li> <li>Usage: You can use this function to create specific multiplier functions that can be used multiple times with different inputs.</li> </ul> Example Usage<pre><code>const double = createMultiplier(2);\nconst triple = createMultiplier(3);\n\nconsole.log(double(5)); // Output: 10\nconsole.log(triple(5)); // Output: 15\n</code></pre> <p>Second Function: Simple Multiplication</p> <pre><code>function createMultiplier(factor) {\n    return factor * factor;\n}\n</code></pre> <p>Explanation:</p> <ul> <li>Simple Function: This function is not a higher-order function. It simply multiplies the <code>factor</code> by itself and returns the result.</li> <li>Immediate Result: The function returns the result of <code>factor * factor</code> immediately without returning another function.</li> <li>Usage: You use this function to get the square of a number.</li> </ul> Example Usage<pre><code>console.log(createMultiplier(2)); // Output: 4\nconsole.log(createMultiplier(3)); // Output: 9\n</code></pre> Differences: <ol> <li> <p>Function Type:</p> <ul> <li>First Function: A higher-order function that returns a new function.</li> <li>Second Function: A simple function that performs a calculation and returns the result immediately.</li> </ul> </li> <li> <p>Purpose:</p> <ul> <li>First Function: Designed to create and return a multiplier function that can be used to multiply different numbers by a specific factor.</li> <li>Second Function: Designed to return the square of the given factor.</li> </ul> </li> <li> <p>Usage:</p> <ul> <li>First Function: Can be used to create specific multiplier functions (e.g., doubling, tripling).</li> <li>Second Function: Can only be used to calculate the square of the given factor.</li> </ul> </li> </ol> <p>Summary:</p> <ul> <li>The first function (<code>createMultiplier(factor) { return function(number) { return number * factor; }; }</code>) is a higher-order function that returns a new function capable of multiplying a number by the specified factor.</li> <li>The second function (<code>createMultiplier(factor) { return factor * factor; }</code>) is a simple function that returns the square of the given factor.</li> </ul> <p>Each function serves a different purpose and is used in different contexts. The higher-order function is more flexible and can create various multiplier functions, while the simple function is limited to calculating the square of the input factor.</p>"},{"location":"frontend/js/core/high-order-function/#finale-example","title":"FINALE EXAMPLE","text":"javascript<pre><code>function createMultiplier(factor) {\n    // Returning a new function\n    return function(number) {\n        return number * factor;\n    };\n}\nconst double = createMultiplier(2);\nconsole.log(double(5));\n</code></pre>"},{"location":"frontend/js/core/high-order-function/#lets-clarify-where-5-and-2-fit-in","title":"Let's clarify where 5 and 2 fit in:","text":"<ul> <li> <p>Factor (<code>factor</code>): When you call <code>createMultiplier(2)</code>, <code>2</code> is passed as an argument to <code>createMultiplier</code>, which assigns it to the parameter <code>factor</code>. So, <code>factor</code> becomes <code>2</code> within the scope of the returned function.</p> </li> <li> <p>Number (<code>number</code>): When you call <code>double(5)</code>, <code>5</code> is passed as an argument to double, which is actually the function returned by <code>createMultiplier(2)</code>. Inside this function, <code>number</code> refers to <code>5</code> in this particular call.</p> </li> </ul>"},{"location":"frontend/js/core/js-exception-handling/","title":"Exception Handling","text":"<p>In JavaScript, the throw new Error(errorMessage); statement does not display the error on the web by itself. Instead, it creates an Error object with the provided errorMessage and then throws that error. This error will be caught by the nearest catch block in a try...catch structure.</p> Here\u2019s a breakdown of how it works: <ol> <li> <p>Error Creation and Throwing:</p> <ul> <li><code>throw new Error(errorMessage)</code>; creates a new <code>Error</code> object with the specified errorMessage.</li> <li>The <code>throw</code> statement then throws this Error object, which immediately exits the current function and passes the error to the nearest <code>catch</code> block.</li> </ul> </li> <li> <p>Error Handling in <code>catch</code>:</p> <ul> <li>If there is a <code>catch</code> block that matches this <code>Error</code>, the error is caught and can be handled appropriately (e.g., logging the error, dispatching an error action, displaying an error message to the user).</li> </ul> </li> <li> <p>Error Display on the Web:</p> <ul> <li>To show an error message to the user, you must explicitly handle and display it. This usually involves:<ul> <li>Catching the error and then displaying a message in the UI.</li> <li>Using a library or UI component to show user-friendly error messages (e.g., alert, modal, or notification).</li> </ul> </li> </ul> </li> </ol> <pre><code>// Action creator with error handling\nexport const actionForUpdateDailyDairy = (id, body) =&gt; {\n    return async(dispatch) =&gt; {\n        dispatch(init(DAILY_DAIRY.UPDATE_DAILY_DIARY));\n\n        try {\n            const response = await dailyDairyService.apiForDailyDiaryUpdate(id, body);\n            if(response.isSuccess) {\n                dispatch(success(DAILY_DAIRY.UPDATE_DAILY_DIARY, response.data));\n                return response.data;\n            } else {\n                const errorMessage = response.errorMessage || 'Unknown error occurred during the update';\n                dispatch(error(errorMessage));\n                throw new Error(errorMessage); // Throwing error to be caught by catch block\n            }\n        } catch (err) {\n            // Handling the error\n            const errorMessage = err.message || 'Unknown error occurred';\n            dispatch(error(errorMessage));\n            // Optionally show the error message in the UI\n            // e.g., displayNotification(errorMessage);\n        } finally {\n            dispatch(finish(DAILY_DAIRY.UPDATE_DAILY_DIARY));\n        }\n    }\n}\n</code></pre> Points to Note: <ol> <li> <p>Error Propagation:</p> <ul> <li>The error thrown is caught by the <code>catch</code> block, where you can handle it (e.g., dispatch an error action to update the UI).</li> </ul> </li> <li> <p>UI Error Display:</p> <ul> <li>To display an error message on the web, ensure that your <code>catch</code> block (or the part of the application handling errors) updates the UI or shows a message to the user.</li> </ul> </li> <li> <p>No Automatic Display:</p> <ul> <li>JavaScript does not automatically display error messages. You need to implement a mechanism to display errors if needed.</li> </ul> </li> </ol> <p>By correctly handling errors in the <code>catch</code> block, you can manage how errors are propagated and displayed in your application.</p> <p>Mastering JavaScript exception handling involves understanding how errors work, effectively using error-handling mechanisms, and implementing best practices to ensure robust and user-friendly applications. Here\u2019s a comprehensive guide to help you master JavaScript exception handling:</p> <ol> <li> <p>Understanding JavaScript Errors</p> <p>JavaScript errors are instances of the Error class and its subclasses:</p> <ul> <li>:Error: Base class for all errors.</li> <li>:TypeError:: Indicates an operation was performed on a value of the wrong type.</li> <li>:ReferenceError:: Indicates a reference to an undefined variable.</li> <li>:SyntaxError:: Indicates a syntax mistake in code.</li> <li>:RangeError:: Indicates a value is out of range.</li> <li>:EvalError:: Indicates an error with the <code>eval()</code> function (rarely used).</li> </ul> </li> <li> <p>Basic Exception Handling</p> <p>Use <code>try...catch</code> blocks to handle exceptions:</p> <pre><code>try {\n    // Code that may throw an error\n    let result = riskyOperation();\n} catch (error) {\n    // Handle the error\n    console.error('Error occurred:', error.message);\n} finally {\n    // Code that always executes\n    console.log('Cleanup code');\n}\n</code></pre> <ul> <li>try: Contains code that might throw an error.</li> <li>catch: Handles the error if one occurs.</li> <li>finally: Executes code regardless of whether an error occurred.</li> </ul> </li> <li> <p>Throwing Errors</p> <p>You can throw your own errors using <code>throw</code>:</p> <pre><code>function validate(value) {\n    if (value &lt; 0) {\n        throw new RangeError('Value must be non-negative');\n    }\n    return value;\n}\n</code></pre> </li> <li> <p>Custom Error Classes</p> <p>Create custom error classes to represent specific error conditions:</p> <pre><code>class CustomError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = 'CustomError';\n    }\n}\n\nfunction doSomething() {\n    throw new CustomError('Something went wrong');\n}\n</code></pre> </li> </ol> Best Practices <ul> <li>Avoid Silent Failures: Always handle errors to avoid silent failures that can lead to unexpected behavior.</li> <li>Use Specific Errors: Throw specific error types where applicable to make debugging easier.</li> <li>Avoid Overuse of <code>try...catch</code>: Only use <code>try...catch</code> where necessary, as overuse can obscure issues.</li> </ul>"},{"location":"frontend/js/core/js-exception-handling/#reducer","title":"REDUCER","text":""},{"location":"frontend/js/core/js-exception-handling/#function","title":"FUNCTION","text":""},{"location":"frontend/js/core/js-exception-handling/#question-1","title":"Question 1:","text":"Question <pre><code>const handleTodaySaveDiary = () =&gt; {\n    console.log(\"data.items\", data.items);\n}\n\n&lt;Content\n    style={{\n        display: \"flex\",\n        justifyContent: \"end\",\n        paddingTop: \"8px\",\n    }}\n&gt;\n{!loading &amp;&amp; data != null &amp;&amp; !isEmpty(data.items) &amp;&amp; (\n    &lt;Button\n        type=\"primary\"\n        // disabled\n        // loading={loading}\n        onClick={handleTodaySaveDiary}\n        style={{\n            padding: \"0px 10px\"\n        }}\n    &gt;\n        Save\n    &lt;/Button&gt;\n)}\n&lt;/Content&gt;\n\n&lt;Modal\n    title=\"Basic Modal\"\n    visible={isModalOpen}\n    onOk={handleOk}\n    onCancel={handleCancel}\n    fotter={null}\n&gt;\n    &lt;Form\n        form={formToday}\n    &gt;\n        Today Form\n    &lt;/Form&gt;\n&lt;/Modal&gt;\n\n\n// data.items value\n\n{\n    \"totalCount\": 2,\n    \"items\": [\n    {\n        \"id\": \"5a618cd6-53d8-4d49-b0b9-23f1ef72a395\",\n        \"todoEventId\": \"cafba611-b13b-4881-8639-b7715257a430\",\n        \"dailyDairyDate\": \"2024-08-15T12:07:48.1704016\",\n        \"stutusId\": \"4de2c2e9-aed1-4b28-bec0-6e52ab148f87\",\n        \"statusName\": \"Start\",\n        \"userId\": \"73fc9457-6b63-6a4a-64de-39f960722731\",\n        \"userName\": \"admin_bbask\",\n        \"title\": \"OS\",\n        \"remarks\": \"KHALAS xcccpp\",\n        \"isActive\": true,\n        \"statusDto\": {\n        \"id\": \"4de2c2e9-aed1-4b28-bec0-6e52ab148f87\",\n        \"name\": \"Start\",\n        \"colorHexValue\": \"#6a71ad\",\n        \"colorFontHexValue\": \"#ffffff\"\n        }\n    },\n    {\n        \"id\": \"84970e8e-2d55-4703-b4a8-ce118cd2a363\",\n        \"todoEventId\": \"f83a16b1-3931-4b0f-b2ea-59a123e4b2af\",\n        \"dailyDairyDate\": \"2024-08-15T09:34:31.976906\",\n        \"stutusId\": \"6a4a2e83-c05a-4134-999b-fd211a546e86\",\n        \"statusName\": \"Completed\",\n        \"userId\": \"73fc9457-6b63-6a4a-64de-39f960722731\",\n        \"userName\": \"admin_bbask\",\n        \"title\": \"NEW TASK TODAY\",\n        \"remarks\": \"fsfafsdfdsfasdf  jkhjk sadfjasdfb sadasdf\\ndsds\",\n        \"isActive\": true,\n        \"statusDto\": {\n        \"id\": \"6a4a2e83-c05a-4134-999b-fd211a546e86\",\n        \"name\": \"Completed\",\n        \"colorHexValue\": \"#cbce91\",\n        \"colorFontHexValue\": \"#ffffff\"\n        }\n    }\n    ]\n}\n</code></pre> <p>Scenario: after click the handleTodaySaveDiary button if the data.items contains object which statusName is not Completed then open the modal and list the title and remarks description box to submit. if all the statusName is completed then donot open the modal.</p>"},{"location":"frontend/js/core/js-exception-handling/#solution-1","title":"SOLUTION 1:","text":"Question <p>To ensure that <code>handleAddUpdateDairy()</code> is only called if <code>actionForUpdateDailyDairy</code> completes successfully, you need to adjust your <code>handleOnFinish</code> function to properly handle errors from the asynchronous action. Currently, <code>handleAddUpdateDairy()</code> is called unconditionally after dispatching <code>actionForUpdateDailyDairy</code>, so you should modify the function to wait for <code>actionForUpdateDailyDairy</code> to complete and handle errors properly.</p> <p>Here's how you can adjust the handleOnFinish function:</p> <ol> <li> <p>Use <code>await</code> for asynchronous operations: Since <code>dispatch</code> is returning a promise, you should await the result of <code>dispatch(actionForUpdateDailyDairy(selectedRecordData?.id, body))</code> to handle errors effectively.</p> </li> <li> <p>Check the result of dispatch before calling <code>handleAddUpdateDairy()</code>: Only call <code>handleAddUpdateDairy()</code> if the update action was successful.</p> </li> </ol> <p>Here's the updated handleOnFinish function:</p> <pre><code>const handleOnFinish = async (values) =&gt; {\n    let body = {\n        statusId: values?.todoEventStatusId,\n        remarks: values?.remarks\n    };\n\n    try {\n        // Ensure dispatch returns a promise to await it\n        const result = await dispatch(actionForUpdateDailyDairy(selectedRecordData?.id, body));\n\n        // If the result was successful, proceed with handleAddUpdateDairy\n        if (result) {\n            handleAddUpdateDairy();\n        }\n    } catch (err) {\n        console.log(\"Error: \", err);\n    }\n}\n</code></pre> Explanation <ol> <li> <p>Await Dispatch: The <code>await dispatch(actionForUpdateDailyDairy(selectedRecordData?.id, body))</code> will pause execution until <code>actionForUpdateDailyDairy</code> has finished, allowing you to catch any errors that might be thrown during the dispatch.</p> </li> <li> <p>Conditional Call: <code>handleAddUpdateDairy()</code> is only called if the result from <code>actionForUpdateDailyDairy</code> indicates success. You may need to adjust the <code>actionForUpdateDailyDairy</code> action to ensure it returns a result that you can check, such as a boolean indicating success.</p> </li> <li> <p>Error Handling: The catch block will handle any errors thrown during the dispatch or the async operation itself.</p> </li> </ol> Important Note <p>Make sure that <code>actionForUpdateDailyDairy</code>'s promise resolves with a value you can check. If the action creator does not currently return a meaningful result, you might need to adjust it so that it does. For example, you could modify <code>actionForUpdateDailyDairy</code> to return <code>response.data</code> only when the operation is successful, and ensure that the error handling logic is correctly implemented.</p>"},{"location":"frontend/js/core/js-exception-handling/#solution-2","title":"SOLUTION 2:","text":"<p>To update your <code>handleOnFinish</code> function so that <code>handleAddUpdateDairy</code> is only called if there is no error in <code>actionForUpdateDailyDairy</code>, you'll need to handle the asynchronous nature of <code>dispatch</code>. You should await the result of <code>dispatch</code> and check for errors before proceeding. Here\u2019s how you can modify your code:</p> Updated handleOnFinish Function<pre><code>const handleOnFinish = async (values) =&gt; {\n    let body = {\n        statusId: values?.todoEventStatusId,\n        remarks: values?.remarks\n    };\n\n    try {\n        if (values?.todoEventStatusId) {\n            // Await the dispatch to ensure completion\n            await dispatch(actionForUpdateDailyDairy(selectedRecordData?.id, body));\n        }\n\n        // Only call handleAddUpdateDairy if dispatch was successful\n        handleAddUpdateDairy();\n    } catch (err) {\n        // Log error and handle it appropriately\n        console.log(\"Error: \", err);\n        // Optionally handle or display the error to the user\n    }\n};\n</code></pre> Explanation: <ol> <li> <p>Await Dispatch: The <code>await dispatch(actionForUpdateDailyDairy(selectedRecordData?.id, body))</code>; line ensures that you wait for the asynchronous action to complete. This means <code>handleAddUpdateDairy()</code> will only be called after <code>actionForUpdateDailyDairy</code> has finished.</p> </li> <li> <p>Conditional Call: <code>handleAddUpdateDairy()</code> is called after the <code>dispatch</code> promise resolves successfully. If <code>dispatch</code> throws an error or fails, the catch block will handle it, and <code>handleAddUpdateDairy()</code> will not be executed.</p> </li> <li> <p>Error Handling: The <code>catch</code> block catches any errors thrown during the dispatch process. You can log or handle these errors as needed.</p> </li> </ol> Additional Considerations: <ul> <li> <p>Action Return Values: Ensure that <code>actionForUpdateDailyDairy</code> is set up to correctly handle and throw errors if necessary. The action creator should be designed to handle success and failure cases.</p> </li> <li> <p>User Feedback: Depending on your UI needs, you might want to provide feedback to the user if an error occurs. This can be done using a UI library or custom error messaging.</p> </li> </ul> <p>With this approach, your code will properly handle the asynchronous operation and ensure that subsequent actions are only taken if the update is successful.</p>"},{"location":"frontend/js/core/js-exception-handling/#example","title":"Example","text":""},{"location":"frontend/js/core/js-exception-handling/#question-2","title":"Question 2:","text":"<ul> <li><code>onClick={handleTodaySaveDiary}</code>: Directly assigns the function to the <code>onClick</code> event, so it will be called when the button is clicked.</li> <li><code>onClick={() =&gt; handleTodaySaveDiary()}</code>: Uses an arrow function to call <code>handleTodaySaveDiary()</code> when the button is clicked. This is useful if you need to perform additional logic in the future.</li> </ul>"},{"location":"frontend/js/core/js-exception-handling/#button-code-snippit-example","title":"Button Code Snippit Example","text":"Example <pre><code>{!loading &amp;&amp; data != null &amp;&amp; !isEmpty(data.items) &amp;&amp; (\n    &lt;Button\n        type=\"primary\"\n        loading={loading}\n        onClick={() =&gt; console.log(\"hello world\", data?.items)}\n        style={{\n            padding: \"0px 10px\"\n        }}\n    &gt;\n        Save\n    &lt;/Button&gt;\n)}\n\n// or\n\n&lt;Button\n    // disabled\n    type=\"primary\"\n    loading={loading}\n    onClick={() =&gt; console.log(\"hello world\", data?.items)}\n    style={{\n        padding: \"0px 10px\"\n    }}\n&gt;\n    Save\n&lt;/Button&gt;\n</code></pre>"},{"location":"frontend/js/core/js-exception-handling/#use-content-for-layout","title":"use <code>Content</code> for Layout","text":"Note <pre><code>import { Layout } from \"antd\";\n\nconst { Content } = Layout;\n\n&lt;Content\n    style={{\n        display: \"flex\",\n        justifyContent: \"end\",\n        paddingTop: \"8px\",\n    }}\n&gt;\n    &lt;Button\n        // disabled\n        type=\"primary\"\n        loading={loading}\n        onClick={() =&gt; console.log(\"hello world\", data?.items)}\n        style={{\n            padding: \"0px 10px\"\n        }}\n    &gt;\n        Save\n    &lt;/Button&gt;\n&lt;/Content&gt;\n</code></pre>"},{"location":"frontend/js/core/js-exception-handling/#office-solve","title":"Office Solve","text":""},{"location":"frontend/js/core/js-exception-handling/#question-1_1","title":"Question 1","text":"Example CodeExplanationModified <p>To implement this scenario, you can filter data.items based on the statusName. If there are any items with statusName not equal to \"Completed\", the modal will open; otherwise, it will remain closed.</p> <p>Here's how you can achieve this:</p> Updated Code:<pre><code>const handleTodaySaveDiary = () =&gt; {\n    const incompleteItems = data.items.filter(item =&gt; item.statusName !== \"Completed\");\n\n    // Log items that are not completed\n    console.log(\"Incomplete Items:\", incompleteItems);\n\n    if (incompleteItems.length &gt; 0) {\n        // Open the modal\n        setIsModalOpen(true);\n    } else {\n        // All items are completed, do not open the modal\n        console.log(\"All items are completed, no modal needed\");\n    }\n};\n\n&lt;Content\n    style={{\n        display: \"flex\",\n        justifyContent: \"end\",\n        paddingTop: \"8px\",\n    }}\n&gt;\n{!loading &amp;&amp; data != null &amp;&amp; !isEmpty(data.items) &amp;&amp; (\n    &lt;Button\n        type=\"primary\"\n        onClick={handleTodaySaveDiary}\n        style={{\n            padding: \"0px 10px\"\n        }}\n    &gt;\n        Save\n    &lt;/Button&gt;\n)}\n&lt;/Content&gt;\n\n&lt;Modal\n    title=\"Incomplete Tasks\"\n    visible={isModalOpen}\n    onOk={handleOk}\n    onCancel={handleCancel}\n    footer={null}\n&gt;\n    &lt;Form form={formToday}&gt;\n        {data.items.filter(item =&gt; item.statusName !== \"Completed\").map(item =&gt; (\n            &lt;div key={item.id}&gt;\n                &lt;h3&gt;{item.title}&lt;/h3&gt;\n                &lt;p&gt;{item.remarks}&lt;/p&gt;\n                &lt;Form.Item\n                    name={`remarks_${item.id}`}\n                    label=\"Remarks\"\n                    rules={[{ required: true, message: 'Please enter remarks' }]}\n                &gt;\n                    &lt;Input.TextArea rows={4} defaultValue={item.remarks} /&gt;\n                &lt;/Form.Item&gt;\n            &lt;/div&gt;\n        ))}\n    &lt;/Form&gt;\n&lt;/Modal&gt;\n</code></pre> <ol> <li> <p><code>handleTodaySaveDiary</code> Function:</p> <ul> <li>Filters <code>data.items</code> to find objects where <code>statusName</code> is not \"Completed\".</li> <li>If there are any such objects, it opens the modal by setting <code>setIsModalOpen(true)</code>.</li> <li>Otherwise, it logs that all items are completed and the modal doesn't open.</li> </ul> </li> <li> <p>Modal Rendering:</p> <ul> <li>Inside the modal, we map over the filtered items (those that are not completed) and display the <code>title</code> and a <code>TextArea</code> input field pre-filled with the current <code>remarks</code>.</li> </ul> </li> </ol> <p>This way, you ensure that the modal only opens when there are incomplete tasks, and it provides an interface for the user to edit the <code>remarks</code> for those tasks.</p> <pre><code>const handleOk = () =&gt; {\n    // Submit the form when Ok is clicked\n    formToday.submit();\n};\n\nconst handleCancel = () =&gt; {\n    formToday.resetFields();\n    setIsModalOpen(false);\n};\n\nconst handleOnFinishFormModal = (values) =&gt; {\n    // Log the form values on form submission\n    console.log(\"Form Values Submitted: \", values);\n\n    // Close the modal after successful submission\n    setIsModalOpen(false);\n};\n</code></pre> Explanation: <ol> <li> <p>onFinish: This function (<code>handleOnFinishFormModal</code>) will be triggered when the form is successfully submitted. The submitted form values are captured in the <code>values</code> parameter.</p> </li> <li> <p>formToday.submit(): Inside <code>handleOk()</code>, calling <code>formToday.submit()</code> ensures that the form submission is triggered when the \"Ok\" button is clicked in the modal.</p> </li> <li> <p>footer={null}: Removed the default footer of the modal to prevent the default \"Ok\" and \"Cancel\" buttons, ensuring you have full control over when the form is submitted.</p> </li> </ol> <p>With this setup, when the modal is open, and the user fills in the remarks and clicks \"Ok,\" the form values will be logged to the console, and you can handle them as needed.</p> <pre><code>if (InomplteStatusItems.length &gt; 0) {\n    // Open the modal\n    setIsModalOpen(true);\n\n    //\n    const initialFormValues = {};\n    InomplteStatusItems.forEach(item =&gt; {\n        initialFormValues[`remarks_${item.id}`] = item.remarks || '';  // Set initial remarks or empty if not available\n    });\n    formToday.setFieldsValue(initialFormValues);\n} else {\n    // All items are completed, do not open the modal\n    console.log(\"All items are completed, no modal needed\");\n}\n</code></pre>"},{"location":"frontend/js/core/js-exception-handling/#reference","title":"Reference","text":"<ul> <li>Control flow and error handling: developer.mozilla</li> <li>JavaScript Errors: w3schools</li> </ul>"},{"location":"frontend/js/core/maps-and-sets/","title":"Maps and Sets","text":""},{"location":"frontend/js/core/maps-and-sets/#maps-and-sets-the-new-data-structures-on-the-block","title":"Maps and Sets <code>\u2014 The New Data-structures on the Block</code>","text":""},{"location":"frontend/js/core/maps-and-sets/#reference","title":"Reference","text":"<ul> <li>JavaScript Next by Raju Gandhi, pg: 81</li> </ul>"},{"location":"frontend/js/core/object-prototype/","title":"Object Prototype","text":""},{"location":"frontend/js/core/object-prototype/#objectprototype","title":"Object.prototype","text":"<p>In JavaScript, Object.prototype is the prototype object from which all other objects inherit their properties and methods, unless explicitly specified otherwise. It is the top of the prototype chain, meaning that any object created using a constructor function or an object literal will have Object.prototype in its prototype chain.</p>"},{"location":"frontend/js/core/object-prototype/#what-is-objectprototype","title":"What is Object.prototype?","text":"<ul> <li> <p>Prototype Chain:</p> <p>In JavaScript, objects can have a prototype, which is another object from which they inherit properties. The prototype of an object is accessible through the <code>__proto__</code> property (or <code>[[Prototype]]</code> in more formal terms).</p> </li> <li> <p>Inheritance:</p> <p><code>Object.prototype</code> is the final object in the prototype chain. It means that all properties and methods defined on <code>Object.prototype</code> are available to all other objects, unless those properties and methods are overridden further down the prototype chain.</p> </li> </ul>"},{"location":"frontend/js/core/object-prototype/#common-properties-and-methods-from-objectprototype","title":"Common Properties and Methods from <code>Object.prototype</code>","text":"<p>Object.prototype includes several methods and properties that are useful and commonly used:</p> <ol> <li> <p>hasOwnProperty:</p> <p>Checks if a property is a direct property of the object (not inherited).</p> <pre><code>const obj = { a: 1 };\nconsole.log(obj.hasOwnProperty('a')); // true\nconsole.log(obj.hasOwnProperty('toString')); // false\n</code></pre> </li> <li> <p>isPrototypeOf:</p> <p>Checks if an object exists in another object's prototype chain.</p> <pre><code>function Person() {}\nconst person = new Person();\nconsole.log(Person.prototype.isPrototypeOf(person)); // true\n</code></pre> </li> <li> <p>toString:</p> <p>Returns a string representation of the object.</p> <pre><code>const obj = { a: 1 };\nconsole.log(obj.toString()); // \"[object Object]\"\n</code></pre> </li> <li> <p>valueOf:</p> <p>Returns the primitive value of the specified object.</p> <pre><code>const obj = { a: 1 };\nconsole.log(obj.valueOf()); // { a: 1 }\n</code></pre> </li> </ol> <p>Prototype Chain Example</p>"},{"location":"frontend/js/core/object-prototype/#prototype-chain-example","title":"Prototype Chain Example","text":"<p>To better understand Object.prototype and the prototype chain, consider the following example:</p> <pre><code>const person = {\n    name: 'John',\n    greet: function() {\n        console.log('Hello, ' + this.name);\n    }\n};\n\n// Create a new object that inherits from person\nconst anotherPerson = Object.create(person);\nanotherPerson.name = 'Jane';\n\nanotherPerson.greet(); // Hello, Jane\n\n// Check the prototype chain\nconsole.log(Object.getPrototypeOf(anotherPerson) === person); // true\nconsole.log(Object.getPrototypeOf(person) === Object.prototype); // true\n</code></pre> <p>In this example:</p> <ol> <li>We define an object <code>person</code> with a property <code>name</code> and a method <code>greet</code>.</li> <li>We create a new object <code>anotherPerson</code> that inherits from person using Object.create.</li> <li>The <code>anotherPerson</code> object can access properties and methods from <code>person</code> because <code>person</code> is in its prototype chain.</li> <li>We verify the prototype chain using Object.getPrototypeOf.</li> </ol>"},{"location":"frontend/js/core/object-prototype/#customizing-objectprototype","title":"Customizing Object.prototype","text":"<p>While it is possible to add properties or methods to Object.prototypeit is generally discouraged== because it can lead to unexpected behavior and conflicts in your code, especially when working with third-party libraries. Modifying Object.prototype affects all objects, which can have unintended side effects.</p> <pre><code>Object.prototype.customMethod = function() {\n  console.log('This is a custom method.');\n};\n\nconst obj = {};\nobj.customMethod(); // This is a custom method.\n</code></pre> <p>In this example, the <code>customMethod</code> is added to Object.prototype, making it available to all objects. However, this practice should be used with caution.</p>"},{"location":"frontend/js/core/object-prototype/#summary","title":"Summary","text":"<ul> <li>Object.prototype is the top-level prototype object from which all other objects inherit properties and methods.</li> <li>It provides several built-in methods like <code>hasOwnProperty</code>, <code>isPrototypeOf</code>, <code>toString</code>, and <code>valueOf</code>.</li> <li>All objects in JavaScript have Object.prototype in their prototype chain unless explicitly specified otherwise.</li> <li>Modifying Object.prototype is possible but generally discouraged due to the potential for unintended side effects.</li> </ul>"},{"location":"frontend/js/core/object/","title":"Object","text":""},{"location":"frontend/js/core/object/#object","title":"Object","text":""},{"location":"frontend/js/core/object/#question","title":"Question","text":"<p>what is exactly object in programming language. why it is called the king in programming language. where does it exist. where does not it exist. how does it transfer in http protocal.\"</p> <p>An object in programming is an instance of a class that encapsulates both data and methods that operate on that data. Objects are fundamental building blocks in object-oriented programming (OOP) and represent real-world entities and concepts within the code.</p> <p>Tip</p> <p>Success</p> <p>Danger</p> <p>Example</p>"},{"location":"frontend/js/core/object/#why-is-an-object-called-the-king-in-programming","title":"Why is an Object Called the \"King\" in Programming?","text":"<ul> <li>Encapsulation: Objects bundle data and methods that operate on the data, ensuring a modular and organized code structure.</li> <li>Abstraction: Objects provide a simplified interface to interact with complex systems, hiding unnecessary details.</li> <li>Inheritance: Objects can inherit properties and methods from other objects, promoting code reuse and efficiency.</li> <li>Polymorphism**: Objects can take many forms, allowing methods to be used interchangeably across different classes.</li> </ul> <p>These principles make objects central to OOP, hence they are often referred to as the \"king\" in programming.</p>"},{"location":"frontend/js/core/object/#where-do-objects-exist","title":"Where Do Objects Exist?","text":"<ul> <li>Object-Oriented Programming Languages: Objects are fundamental in languages like <code>Java</code>, <code>C++</code>, <code>Python</code>, <code>Ruby</code>, and <code>JavaScript</code>.</li> <li>In Memory: At runtime, objects exist in a computer's memory, where they are instantiated, manipulated, and used by the program.</li> </ul>"},{"location":"frontend/js/core/object/#where-do-objects-not-exist","title":"Where Do Objects Not Exist?","text":"<ul> <li>Non-OOP Languages: In procedural programming languages like <code>C</code> (not C++), there is no concept of objects. Code is organized around procedures or functions.</li> <li>Static Resources: Objects do not exist in static resources like <code>plain text files</code>, simple scripts, or configuration files, which do not use OOP principles.</li> </ul>"},{"location":"frontend/js/core/object/#how-do-objects-transfer-in-http-protocol","title":"How Do Objects Transfer in HTTP Protocol?","text":"<p>Objects transfer in HTTP protocol typically <code>through serialization</code>, where the object's state is converted into a format that can be transmitted over the network. Common serialization formats include:</p> <ol> <li> <p>JSON (<code>JavaScript Object Notation</code>): Widely used due to its simplicity and readability.</p> json<pre><code>{\n    \"name\": \"Alice\",\n    \"age\": 30,\n    \"isMember\": true\n}\n</code></pre> </li> <li> <p>XML (<code>Extensible Markup Language</code>): More verbose than JSON but still commonly used.</p> xml<pre><code>&lt;person&gt;\n    &lt;name&gt;Alice&lt;/name&gt;\n    &lt;age&gt;30&lt;/age&gt;\n    &lt;isMember&gt;true&lt;/isMember&gt;\n&lt;/person&gt;\n</code></pre> </li> <li> <p>Binary Formats: <code>Protocol Buffers</code>, <code>Apache Avro</code>, or <code>MessagePack</code>, which are more efficient for data transfer but less human-readable.</p> </li> </ol> <p>The serialized object is included in the HTTP request or response body and transferred between the client and server.</p> HTTP Request Example:<pre><code>POST /api/users HTTP/1.1\nHost: example.com\nContent-Type: application/json\n\n{\n    \"name\": \"Alice\",\n    \"age\": 30,\n    \"isMember\": true\n}\n</code></pre> HTTP Response Example:<pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n    \"status\": \"success\",\n    \"data\": {\n        \"id\": 123,\n        \"name\": \"Alice\"\n    }\n}\n</code></pre>"},{"location":"frontend/js/core/object/#summary","title":"Summary","text":"<p>Objects are essential in OOP, providing a structured way to represent and manipulate data. They exist in memory and within OOP languages but not in non-OOP contexts. They transfer over HTTP through serialization into formats like JSON, XML, or binary.</p>"},{"location":"frontend/js/core/prototype/","title":"Prototype","text":""},{"location":"frontend/js/core/prototype/#prototype","title":"Prototype","text":""},{"location":"frontend/js/core/prototype/#objectprototype","title":"Object.prototype","text":"<ul> <li> <p>Base Prototype:</p> <p>Object.prototype is the prototype object from which all other objects inherit, unless explicitly specified otherwise. It is the root of the prototype chain for most objects.</p> </li> <li> <p>Properties and Methods:</p> <p>It includes methods and properties that are common to all objects, such as <code>toString()</code>, <code>valueOf()</code>, <code>hasOwnProperty()</code>, <code>isPrototypeOf()</code>, and <code>propertyIsEnumerable()</code>.</p> </li> <li> <p>Role:</p> <p>Any object created using an object literal or the Object constructor will have Object.prototype in its prototype chain.</p> </li> </ul> <p>Example</p> Function.prototypeString.prototypeNumber.prototypeBoolean.prototypeDate.prototypeRegExp.prototype <p>The prototype for all function objects. It includes methods like <code>apply()</code>, <code>call()</code>, and <code>bind()</code>.</p> <pre><code>function sayHello() {\n    console.log('Hello');\n}\n\nsayHello.call(); // Hello\n</code></pre> <p>The prototype for all string objects. It includes methods like <code>charAt()</code>, <code>indexOf()</code>, <code>toUpperCase()</code>, <code>toLowerCase()</code>, <code>substring()</code>, <code>slice()</code>, and <code>replace()</code>.</p> <pre><code>const str = 'hello';\nconsole.log(str.toUpperCase()); // HELLO\n</code></pre> <p>The prototype for all number objects. It includes methods like <code>toFixed()</code>, <code>toExponential()</code>, and <code>toPrecision()</code>.</p> <pre><code>const num = 123.456;\nconsole.log(num.toFixed(2)); // 123.46\n</code></pre> <p>The prototype for all boolean objects. It has methods like <code>toString()</code> and <code>valueOf()</code>.</p> <pre><code>const bool = true;\nconsole.log(bool.toString()); // true\n</code></pre> <p>The prototype for all date objects. It includes methods like <code>getDate()</code>, <code>getDay()</code>, <code>getFullYear()</code>, <code>getHours()</code>, and <code>toISOString()</code>.</p> <pre><code>const date = new Date();\nconsole.log(date.toISOString()); // Current date in ISO format\n</code></pre> <p>The prototype for all regular expression objects. It includes methods like <code>exec()</code>, <code>test()</code>, and properties like source.</p> <pre><code>const regex = /hello/;\nconsole.log(regex.test('hello world')); // true\n</code></pre>"},{"location":"frontend/js/core/prototype/#key-differences-and-summary","title":"Key Differences and Summary","text":"<ul> <li> <p>Purpose:</p> <p><code>Object.prototype</code> provides generic methods and properties for all objects, while Array.prototype provides specific methods and properties for array instances.</p> </li> <li> <p>Inheritance:</p> <p>All objects inherit from <code>Object.prototype</code>, but array instances additionally inherit from <code>Array.prototype</code>.</p> </li> <li> <p>Methods and Properties:</p> <p>The methods and properties on <code>Object.prototype</code>are applicable to all objects, whereas those on Array.prototype are specifically for arrays.</p> </li> </ul> <p>Understanding the prototype chain and how different prototypes provide different methods and properties is crucial for effective JavaScript programming. It helps in leveraging the full power of built-in objects and creating custom objects with shared behaviors.</p>"},{"location":"frontend/js/core/prototype/#prototype-chain-illustration","title":"Prototype Chain Illustration","text":"<p>Here\u2019s a simplified illustration of the prototype chain for these <code>built-in</code> objects:</p> <ol> <li> <p>Function:</p> <ul> <li><code>example.__proto__ === Function.prototype</code></li> <li><code>Function.prototype.__proto__ === Object.prototype</code></li> </ul> </li> <li> <p>String:</p> <ul> <li><code>str.__proto__ === String.prototype</code></li> <li><code>String.prototype.__proto__ === Object.prototype</code></li> </ul> </li> <li> <p>Array:</p> <ul> <li><code>arr.__proto__ === Array.prototype</code></li> <li><code>Array.prototype.__proto__ === Object.prototype</code></li> </ul> </li> <li> <p>Boolean:</p> <ul> <li><code>bool.__proto__ === Boolean.prototype</code></li> <li><code>Boolean.prototype.__proto__ === Object.prototype</code></li> </ul> </li> </ol> <p>Example of Prototype Chain</p> <pre><code>function example() {}\nconst str = 'hello';\nconst arr = [1, 2, 3];\nconst bool = true;\n\n// Checking the prototype chain\nconsole.log(Object.getPrototypeOf(example) === Function.prototype); // true\nconsole.log(Object.getPrototypeOf(Function.prototype) === Object.prototype); // true\n\nconsole.log(Object.getPrototypeOf(str) === String.prototype); // true\nconsole.log(Object.getPrototypeOf(String.prototype) === Object.prototype); // true\n\nconsole.log(Object.getPrototypeOf(arr) === Array.prototype); // true\nconsole.log(Object.getPrototypeOf(Array.prototype) === Object.prototype); // true\n\nconsole.log(Object.getPrototypeOf(bool) === Boolean.prototype); // true\nconsole.log(Object.getPrototypeOf(Boolean.prototype) === Object.prototype); // true\n</code></pre>"},{"location":"frontend/js/core/prototype/#__proto__","title":"<code>__proto__</code>","text":"<p>A hidden link that lets an object inherit properties and methods from another object.</p>"},{"location":"frontend/js/core/serialization/","title":"Serialization","text":""},{"location":"frontend/js/core/serialization/#serialization","title":"Serialization","text":""},{"location":"frontend/js/core/serialization/#question","title":"Question","text":"<p>why do we need to serailize to tranfer in http protocal? why does we can't transfers the direct object. what is the reason?\"</p> <p>Serialization is necessary to transfer objects over the HTTP protocol because HTTP is a text-based protocol that only understands text or binary data formats. Directly transferring an object as it exists in memory is not feasible due to several reasons:</p> Reasons for Serialization <ol> <li> <p>Incompatibility with HTTP Protocol: HTTP is designed to transfer data in text (ASCII or UTF-8) or binary format, not in the complex memory structures that objects are represented as within a running program.</p> </li> <li> <p>Language and Platform Independence: Serialization transforms objects into a standardized format that can be understood across different programming languages and platforms. Without serialization, the internal memory representation of an object in one language (e.g., Python) might not be understandable by another language (e.g., JavaScript).</p> </li> <li> <p>Security: Directly transferring raw memory data could expose sensitive information and increase the risk of security vulnerabilities. Serialization allows control over what data is included and how it is represented, enhancing security.</p> </li> <li> <p>Data Integrity and Structure: Serialization ensures that the data structure is preserved and can be accurately reconstructed. It converts complex objects into a structured format (like JSON or XML) that maintains the relationships between data fields.</p> </li> <li> <p>Efficiency and Performance: Serialized data can be optimized for transmission. Formats like JSON and Protocol Buffers are designed to be lightweight and efficient, reducing the amount of data transferred and improving performance.</p> </li> </ol> Why Direct Transfer of Objects is Not Feasible <ol> <li> <p>Memory Representation: Objects in memory contain pointers, memory addresses, and other metadata that are specific to the runtime environment. This low-level information is not meaningful outside the context of that environment.</p> </li> <li> <p>Endianness and Architecture Differences: Computers may have different endianness (byte order) and architecture (<code>32-bit</code> vs. <code>64-bit</code>), leading to differences in how data is stored in memory. Serialization abstracts these differences.</p> </li> <li> <p>Complex Object Graphs: Objects often reference other objects, creating complex graphs of interconnected data. Direct transfer would require duplicating the entire memory structure, which is impractical and error-prone.</p> </li> </ol> <p>Example</p>"},{"location":"frontend/js/core/serialization/#serialization-process","title":"Serialization Process","text":"<ol> <li> <p>Conversion to Text or Binary Format: The object is converted into a format like <code>JSON</code>, <code>XML</code>, or <code>Protocol Buffers</code>. This format represents the object's data in a standardized way.</p> </li> <li> <p>Transmission Over HTTP: The serialized data is included in the HTTP request or response body, allowing it to be transmitted over the network.</p> </li> <li> <p>Deserialization: On the receiving end, the data is converted back into an object, reconstructing the original data structure.</p> </li> </ol>"},{"location":"frontend/js/core/serialization/#example-of-serialization-and-transmission","title":"Example of Serialization and Transmission","text":""},{"location":"frontend/js/core/serialization/#json-serialization","title":"JSON Serialization","text":"Original Object (Python):<pre><code>user = {\"name\": \"Alice\", \"age\": 30, \"isMember\": True}\n</code></pre>"},{"location":"frontend/js/core/serialization/#serialized-json","title":"Serialized JSON:","text":"json<pre><code>{\n    \"name\": \"Alice\",\n    \"age\": 30,\n    \"isMember\": true\n}\n</code></pre>"},{"location":"frontend/js/core/serialization/#http-request","title":"HTTP Request:","text":"http<pre><code>POST /api/users HTTP/1.1\nHost: example.com\nContent-Type: application/json\n\n{\n    \"name\": \"Alice\",\n    \"age\": 30,\n    \"isMember\": true\n}\n</code></pre>"},{"location":"frontend/js/core/serialization/#deserialization-javascript","title":"Deserialization (JavaScript):","text":"javascript<pre><code>let user = JSON.parse('{\"name\": \"Alice\", \"age\": 30, \"isMember\": true}');\n</code></pre>"},{"location":"frontend/js/core/serialization/#conclusion","title":"Conclusion","text":"<p>Serialization is essential for transferring objects over the HTTP protocol because it converts objects into a text or binary format that is compatible with HTTP, ensures language and platform independence, and maintains data integrity and security. Direct transfer of objects is not feasible due to the complexity of memory representations and the need for standardized data formats.</p>"},{"location":"frontend/js/core/spread-vs-rest-operator/","title":"Spread vs Rest Operator","text":""},{"location":"frontend/js/core/spread-vs-rest-operator/#spread-vs-rest-polar-opposite-twins","title":"Spread vs. Rest <code>\u2014 Polar Opposite Twins</code>","text":"<p>One will have observed that the syntax for the rest parameter and the spread operator is identical, but their behavior is the exact opposite of one another. The rest parameter \u201ccollects\u201d all the unaccounted arguments supplied to a function into an array, while the spread operator extracts all the elements out of an array. What differentiates what the ... syntax does depends on the invocation context. ... only acts as the rest parameter when an assignment happens, and if not, then it acts as a spread operator. This contradiction can be both interesting and disconcerting at the same time:</p> <p>Differences Between Spread and Rest</p> <ol> <li> <p>Spread Operator: Expands an array or object into individual elements.</p> <ul> <li>Example: <code>...array</code></li> </ul> </li> <li> <p>Rest Operator: Collects multiple elements into a single array.</p> <ul> <li>Example: <code>...args</code></li> </ul> </li> </ol> <p>Tip</p>"},{"location":"frontend/js/core/spread-vs-rest-operator/#destructuring","title":"Destructuring","text":"Array DestructuringObject DestructuringCombination"},{"location":"frontend/js/core/spread-vs-rest-operator/#reference","title":"Reference","text":"<ul> <li>JavaScript Next by Raju Gandhi, pg: 48</li> </ul>"},{"location":"frontend/js/core/topic/","title":"Topic","text":"<p>Mastering JavaScript requires a deep understanding of both its fundamental concepts and advanced topics. Here are some key areas to focus on, along with some hidden depths you should explore:</p>"},{"location":"frontend/js/core/topic/#core-concepts","title":"Core Concepts","text":"<ol> <li> <p>Data Types and Structures</p> <ul> <li>Primitive types and their behavior.</li> <li>Objects, arrays, and their methods.</li> <li>Map and Set objects.</li> </ul> </li> <li> <p>Functions</p> <ul> <li>Function declarations, expressions, and arrow functions.</li> <li>Scope, closures, and lexical scoping.</li> <li>Higher-order functions and callbacks.</li> <li>The <code>this</code> keyword and context binding.</li> </ul> </li> <li> <p>Asynchronous Programming</p> <ul> <li>Callbacks, promises, and async/await.</li> <li>Event loop and concurrency model.</li> <li>Error handling in asynchronous code.</li> </ul> </li> </ol>"},{"location":"frontend/js/core/topic/#advanced-topics","title":"Advanced Topics","text":"<ol> <li> <p>Prototypes and Inheritance</p> <ul> <li>Prototypal inheritance and the prototype chain.</li> <li>ES6 class syntax and how it relates to prototypes.</li> <li><code>Object.create</code> and inheritance patterns.</li> </ul> </li> <li> <p>Execution Context and Hoisting</p> <ul> <li>Execution context and the call stack.</li> <li>Variable and function hoisting.</li> <li>Temporal dead zone (TDZ) with <code>let</code> and <code>const</code>.</li> </ul> </li> <li> <p>Closures and Lexical Scope</p> <ul> <li>Understanding closures and their applications.</li> <li>Practical uses of closures in module patterns and function factories.</li> </ul> </li> <li> <p>Modules and Module Bundlers</p> <ul> <li>ES6 modules: import and export.</li> <li>Module patterns in older JavaScript (CommonJS, AMD).</li> <li>Using module bundlers like Webpack, Parcel, and Rollup.</li> </ul> </li> <li> <p>Event Handling and DOM Manipulation</p> <ul> <li>Event delegation and propagation (bubbling and capturing).</li> <li>Modern DOM APIs and manipulation techniques.</li> <li>Understanding and handling browser events.</li> </ul> </li> </ol>"},{"location":"frontend/js/core/topic/#deep-dive-topics","title":"Deep Dive Topics","text":"<ol> <li> <p>Memory Management and Performance</p> <ul> <li>Garbage collection and memory leaks.</li> <li>Optimizing performance: profiling and benchmarking.</li> <li>Understanding V8 engine optimizations.</li> </ul> </li> <li> <p>Design Patterns</p> <ul> <li>Common JavaScript design patterns (e.g., Singleton, Factory, Observer).</li> <li>Applying design patterns to real-world problems.</li> </ul> </li> <li> <p>Type Systems and Type Checking</p> <ul> <li>Dynamic vs. static typing.</li> <li>Using TypeScript for type safety.</li> <li>Flow and other type checkers.</li> </ul> </li> <li> <p>Testing</p> <ul> <li>Unit testing, integration testing, and end-to-end testing.</li> <li>Popular testing frameworks (<code>Jest</code>, <code>Mocha</code>, <code>Chai</code>, <code>Cypress</code>).</li> <li>Test-driven development (TDD) practices.</li> </ul> </li> <li> <p>Tooling and Build Processes</p> <ul> <li>Modern JavaScript tooling: ESLint, Prettier, Babel.</li> <li>Setting up and configuring build processes with tools like Webpack.</li> <li>Continuous integration and deployment (CI/CD) for JavaScript projects.</li> </ul> </li> </ol>"},{"location":"frontend/js/core/topic/#hidden-depths","title":"Hidden Depths","text":"<ol> <li> <p>Symbol and Meta-programming</p> <ul> <li>Using symbols to create unique property keys.</li> <li>Understanding well-known symbols and their uses.</li> <li>Proxy objects and the Reflect API for metaprogramming.</li> </ul> </li> <li> <p>Iterators and Generators</p> <ul> <li>Custom iterators and the iterable protocol.</li> <li>Generator functions and the yield keyword.</li> <li>Using generators for asynchronous control flow.</li> </ul> </li> <li> <p>Concurrency and Parallelism</p> <ul> <li>Web Workers for parallel processing.</li> <li>Understanding and using SharedArrayBuffer and Atomics.</li> <li>Concurrency models in JavaScript.</li> </ul> </li> <li> <p>Advanced Asynchronous Patterns</p> <ul> <li>Async iterators and generators.</li> <li>Using <code>Promise.all</code>, <code>Promise.race</code>, and <code>Promise.allSettled</code>.</li> <li>Managing complex async workflows with libraries like RxJS.</li> </ul> </li> <li> <p>Understanding the Event Loop and Microtasks</p> <ul> <li>Detailed workings of the event loop.</li> <li>Difference between macro-tasks and micro-tasks.</li> <li>Practical implications for writing efficient asynchronous code.</li> </ul> </li> </ol>"},{"location":"frontend/js/core/topic/#practical-application","title":"Practical Application","text":"<ul> <li>Building Projects: Apply what you learn by building real-world projects.</li> <li>Contributing to Open Source: Contribute to JavaScript libraries and frameworks.</li> <li>Reading and Understanding Source Code: Study the source code of popular libraries and frameworks.</li> </ul> <p>Mastering JavaScript is a journey that involves both understanding the theory and applying it in practical scenarios. By delving into these topics, you will gain a comprehensive and deep understanding of JavaScript, enabling you to write efficient, maintainable, and robust code.</p> Abstract <p>To gain a deep understanding of JavaScript, the main approach is to focus on mastering its core concepts and advanced features. Here's a structured plan to achieve that:</p> <ol> <li> <p>Fundamentals:</p> <ul> <li>Variables and Data Types: Understand var, let, const, and data types (number, string, boolean, object, undefined, null).</li> <li>Functions: Learn about function declarations, expressions, arrow functions, and IIFE (Immediately Invoked Function Expressions).</li> <li>Control Structures: Master if statements, loops (for, while, do-while), and switch statements.</li> </ul> </li> <li> <p>Advanced Concepts:</p> <ul> <li>Closures: Understand how closures work and how they enable functions to have private variables.</li> <li>Prototypes and Inheritance: Learn about prototype chains, inheritance models, and how to create objects using constructor functions and class syntax.</li> <li>Asynchronous Programming: Master callbacks, promises, async/await, and event loop mechanisms.</li> <li>Scope and Hoisting: Understand the scope (global, local, block) and hoisting behaviors in JavaScript.</li> </ul> </li> <li> <p>JavaScript in the Browser:</p> <ul> <li>DOM Manipulation: Learn how to select, traverse, and manipulate DOM elements.</li> <li>Event Handling: Understand how to handle user interactions and events.</li> <li>Browser APIs: Explore key browser APIs like fetch, localStorage, and sessionStorage.</li> </ul> </li> <li> <p>Modern JavaScript (ES6+):</p> <ul> <li>Learn new syntax and features introduced in ES6 and later versions, including template literals, destructuring, spread/rest operators, modules, and enhanced object literals.</li> </ul> </li> <li> <p>Tooling and Ecosystem:</p> <ul> <li>Node.js: Understand server-side JavaScript and how to build backend applications with Node.js.</li> <li>Build Tools: Learn about build tools like Webpack, Babel, and task runners like Gulp or Grunt.</li> <li>Testing: Master JavaScript testing frameworks like Jest, Mocha, or Jasmine.</li> </ul> </li> <li> <p>Best Practices:</p> <ul> <li>Code Organization: Learn how to write modular, maintainable, and reusable code.</li> <li>Performance Optimization: Understand techniques for optimizing JavaScript performance.</li> <li>Security: Learn common security practices to prevent vulnerabilities like XSS and CSRF.</li> </ul> </li> <li> <p>Projects and Real-world Applications:</p> <ul> <li>Build projects that challenge you to apply what you've learned.</li> <li>Contribute to open-source projects or collaborate on team projects to gain practical experience.</li> </ul> </li> </ol> <p>By systematically studying these areas, practicing through projects, and keeping up with the latest advancements in JavaScript, you'll be able to develop a deep and comprehensive understanding of the language.</p>"},{"location":"frontend/js/ecmascript/es6/","title":"es6","text":""},{"location":"frontend/js/ecmascript/es6/#javascript-es6","title":"JavaScript ES6","text":"<p>ES6 is a significant update. It contains a whole host of new features for JavaScript, almost two dozen in total. JavaScript written in ES6 is tangibly different than JavaScript written in ES5.</p> <p>The most important ECMAScript version is generally considered to be <code>ECMAScript 2015 (ES6)</code>. Here are the reasons why ES6 is so significant:</p>"},{"location":"frontend/js/ecmascript/es6/#impact-of-es6","title":"Impact of ES6:","text":"<ul> <li>Modern JavaScript: ES6 transformed JavaScript into a more modern, powerful, and developer-friendly language.</li> <li>Tooling and Frameworks: Many modern JavaScript frameworks and libraries (e.g., React, Angular, Vue.js) heavily utilize ES6 features.</li> <li>Backward Compatibility: Tools like Babel allow developers to write ES6+ code while maintaining compatibility with older browsers.</li> <li>Standardization: Set the foundation for annual updates to the ECMAScript specification, ensuring continuous improvement of the language.</li> </ul> <p>Due to these significant enhancements and its foundational role in modern JavaScript development, ECMAScript 2015 (ES6) is often regarded as the most important ECMAScript version.</p>"},{"location":"frontend/js/ecmascript/es6/#key-features-of-es6","title":"Key Features of ES6:","text":"React <p>There are two ways to declare React components:</p> <ol> <li>ES6 classes</li> <li>Function components</li> </ol> <p>An example of using an ES6 class:</p> <pre><code>class HelloWorld extends React.Component {\n    render() { return &lt;p&gt;Hello, world!&lt;/p&gt;; }\n}\n</code></pre> <p>The same component written in a \u201cfunctional component\u201d style:</p> <pre><code>function HelloWorld() {\n    return &lt;p&gt;Hello, world!&lt;/p&gt;;\n}\n</code></pre> <p>At the time of writing, both types of declarations are in widespread use. </p> <p>While they both do essentially the same thing, there are some important differences that we\u2019ll get to later in the book.</p> <p>We\u2019ll be using ES6 class components through much of the book, but we\u2019ll be using function components from time-to-time as well. While it might seem cleaner to just pick one, you\u2019ll encounter (and use) both in your real-world work. So we\u2019ll cover both.</p> <ul> <li>Fullstack React The Complete Guide to ReactJS and Friends by Anthony Accomazzo :21</li> </ul>"},{"location":"frontend/js/json/intro/","title":"Intro","text":"<p>JSON or JavaScript Object Notation is a very popular data interchange format. It was developed by Douglas Crockford. JSON is text-based, lightweight, and a human-readable format for data exchange between clients and servers. JSON is derived from JavaScript and bears a close resemblance to JavaScript objects, but it is not dependent on JavaScript. JSON is language-independent, and support for the JSON data format is available in all the popular languages, some of which are C#, PHP, Java, C++, Python, and Ruby.</p> <p>JSON is a format and not a language.</p> <p>JSON can be used in web applications for data transfer. Prior to JSON, XML was considered to be the chosen data interchange format. </p>"},{"location":"frontend/js/json/intro/#datatypes-in-json","title":"Datatypes in JSON","text":"<p>Tip</p> <p>JSON supports six datatypes: </p> <ol> <li>strings, </li> <li>numbers, </li> <li>Booleans, </li> <li>arrays, </li> <li>objects, &amp; </li> <li>null.</li> </ol> <ul> <li>JavaScript and JSON Essentials by Sai Srinivas Sriparasa: 2013 Packt Publishing</li> </ul>"},{"location":"frontend/js/testing/cypress/","title":"Cypress","text":""},{"location":"frontend/js/testing/cypress/#theory","title":"Theory","text":"<p>Cypress is an end-to-end testing framework that provides a fast, reliable, and easy-to-use way to test your web applications.</p>"},{"location":"frontend/js/testing/cypress/#key-features-of-cypress","title":"Key Features of Cypress:","text":"<ol> <li>Real Browser Testing: Cypress runs tests directly in the browser, giving you a realistic testing environment.</li> <li>Automatic Waiting: Cypress automatically waits for commands and assertions to pass, making your tests more reliable without adding manual waits.</li> <li>Time Travel: Cypress captures snapshots as your tests run, allowing you to hover over commands in the Command Log to see what happened at each step.</li> <li>Debuggability: With detailed error messages and stack traces, Cypress makes debugging failed tests straightforward.</li> <li>Network Traffic Control: Cypress lets you stub and spy on network requests, giving you control over your application's API interactions during tests.</li> <li>Integration with CI/CD: Cypress integrates seamlessly with continuous integration and continuous deployment (CI/CD) pipelines.</li> </ol>"},{"location":"frontend/js/testing/cypress/#when-to-use-cypress","title":"When to Use Cypress","text":"<ul> <li>End-to-End Testing: Cypress is perfect for testing the complete user journey, from loading the application to interacting with various elements and verifying outcomes.</li> <li>Integration Testing: When you need to test how different parts of your application work together, Cypress's realistic browser environment is beneficial.</li> <li>Real Browser Interactions: If you need to test how your application behaves in a real browser, including handling of network requests, cookies, and local storage, Cypress is the right tool.</li> <li>User Interface Testing: Cypress excels at simulating real user interactions and verifying the application's response.</li> </ul>"},{"location":"frontend/js/testing/cypress/#example-use-cases","title":"Example Use Cases","text":"<p>Cypress Example (End-to-End Testing a Login Flow)</p> <ol> <li> <p>Install Cypress:</p> <pre><code>npm install --save-dev cypress\n</code></pre> </li> <li> <p>Example Test File (login.spec.js):</p> <pre><code>describe('Login Flow', () =&gt; {\n    it('should log in successfully', () =&gt; {\n        cy.visit('http://localhost:3000/login');\n        cy.get('input[name=username]').type('user');\n        cy.get('input[name=password]').type('password');\n        cy.get('button[type=submit]').click();\n        cy.url().should('include', '/dashboard');\n        cy.contains('Welcome, user!');\n    });\n});\n</code></pre> </li> <li> <p>Run Tests:</p> <pre><code>npx cypress open\n</code></pre> </li> </ol>"},{"location":"frontend/js/testing/cypress/#summary","title":"Summary","text":"<p>Use Cypress for end-to-end testing, integration testing, and when you need to simulate real user interactions in a browser.</p> <p>In many projects, both tools are used together: Jest for unit and component tests, and Cypress for end-to-end tests. This combination ensures comprehensive test coverage and a robust testing strategy.</p>"},{"location":"frontend/js/testing/jest/","title":"Jest","text":""},{"location":"frontend/js/testing/jest/#theory","title":"Theory","text":"<p>Jest is a delightful JavaScript testing framework developed by Facebook, designed to ensure correctness of any JavaScript codebase. It is widely used for testing React applications, but it can be used with any JavaScript project.</p>"},{"location":"frontend/js/testing/jest/#key-features-of-jest","title":"Key Features of Jest:","text":"<ol> <li>Zero Configuration: Jest works out of the box for most JavaScript projects, especially those using React.</li> <li>Snapshots: Jest can capture the output of your components and compare it to a reference snapshot file to ensure UI consistency.</li> <li>Isolated Tests: Each test runs in its own sandbox environment to avoid global state pollution.</li> <li>Coverage Reporting: Jest can generate code coverage reports, helping you understand how much of your code is tested.</li> <li>Mocking: Jest provides powerful mocking capabilities to simulate different scenarios and behaviors for your code dependencies. Parallel Execution: Tests run in parallel, speeding up the testing process.</li> </ol>"},{"location":"frontend/js/testing/jest/#when-to-use-jest","title":"When to Use Jest","text":"<ul> <li>Unit Testing: Jest is ideal for testing individual functions, modules, or components in isolation.</li> <li>Snapshot Testing: If you want to ensure that your UI components render consistently, snapshot testing with Jest is very effective.</li> <li>Mocking Dependencies: When you need to mock dependencies or simulate different scenarios, Jest's mocking capabilities are highly useful.</li> <li>Fast Feedback Loop: Jest's parallel execution and watch mode provide quick feedback during development.</li> </ul>"},{"location":"frontend/js/testing/jest/#example-use-cases","title":"Example Use Cases","text":"<p>Jest Example (Unit Testing a React Component)</p> <ol> <li> <p>Install Jest:</p> <pre><code>npm install --save-dev jest @testing-library/react @testing-library/jest-dom\n</code></pre> </li> <li> <p>Example Test File (<code>MyComponent.test.js</code>):</p> <pre><code>import React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport MyComponent from './MyComponent';\n\ntest('renders a message', () =&gt; {\n    render(&lt;MyComponent /&gt;);\n    const messageElement = screen.getByText(/hello, world!/i);\n    expect(messageElement).toBeInTheDocument();\n});\n</code></pre> </li> <li> <p>Run Tests:</p> <pre><code>npm test\n</code></pre> </li> </ol>"},{"location":"frontend/js/testing/jest/#summary","title":"Summary","text":"<p>Use Jest for unit testing, snapshot testing, and when you need fast feedback during development.</p> <p>In many projects, both tools are used together: Jest for unit and component tests, and Cypress for end-to-end tests. This combination ensures comprehensive test coverage and a robust testing strategy.</p>"},{"location":"frontend/js/tools/ESLint/","title":"ESLint","text":""},{"location":"frontend/js/tools/ESLint/#theory","title":"Theory","text":""},{"location":"frontend/js/tools/ESLint/#what-is-eslint","title":"What is ESLint?","text":"<p>ESLint is an open-source JavaScript linting tool that helps developers find and fix problems in their JavaScript code. Linting is the process of analyzing code for potential errors, bugs, stylistic errors, and suspicious constructs.</p>"},{"location":"frontend/js/tools/ESLint/#where-does-eslint-come-from","title":"Where Does ESLint Come From?","text":"<p>ESLint was created by Nicholas C. Zakas in June 2013. It was developed to address some of the limitations of other JavaScript linting tools like <code>JSLint</code> and <code>JSHint</code>. ESLint is highly configurable and extensible, which has made it the preferred choice for many developers.</p>"},{"location":"frontend/js/tools/ESLint/#how-to-use-eslint","title":"How to Use ESLint","text":"Installation: <ol> <li> <p>Install ESLint:     Use npm (Node Package Manager) or yarn to install ESLint in your project.</p> <pre><code>npm install eslint --save-dev\n# or\nyarn add eslint --dev\n</code></pre> </li> <li> <p>Initialize ESLint:</p> <p>Run the ESLint initialization command to create a configuration file (<code>.eslintrc.json</code>).</p> <pre><code>npx eslint --init\n</code></pre> </li> </ol>"},{"location":"frontend/js/tools/ESLint/#configuration","title":"Configuration:","text":"<ol> <li> <p>Config File:</p> <p>The initialization command will prompt you to answer a series of questions to set up your configuration file. Here is an example <code>.eslintrc.json</code>:</p> <pre><code>{\n    \"env\": {\n        \"browser\": true,\n        \"es2021\": true\n    },\n    \"extends\": \"eslint:recommended\",\n    \"parserOptions\": {\n        \"ecmaVersion\": 12,\n        \"sourceType\": \"module\"\n    },\n    \"rules\": {\n        \"indent\": [\"error\", 2],\n        \"linebreak-style\": [\"error\", \"unix\"],\n        \"quotes\": [\"error\", \"single\"],\n        \"semi\": [\"error\", \"always\"]\n    }\n}\n</code></pre> <ol> <li>Custom Rules:</li> </ol> <p>You can customize ESLint rules according to your project's needs by modifying the <code>rules</code> section in the configuration file.</p> </li> </ol>"},{"location":"frontend/js/tools/ESLint/#running-eslint","title":"Running ESLint:","text":"<ol> <li> <p>Command Line:</p> <p>You can run ESLint from the command line to lint your code:</p> <pre><code>npx eslint yourfile.js\n</code></pre> </li> <li> <p>Automatic Fixes:</p> <p>ESLint can automatically fix certain issues:</p> <pre><code>npx eslint yourfile.js --fix\n</code></pre> </li> </ol>"},{"location":"frontend/js/tools/ESLint/#integration-with-code-editors","title":"Integration with Code Editors:","text":"<ol> <li> <p>VSCode:</p> <p>Install the ESLint extension from the Visual Studio Code Marketplace to get real-time linting feedback.</p> </li> <li> <p>Other Editors:</p> <p>Most popular editors like Atom, Sublime Text, and WebStorm have plugins or built-in support for ESLint.</p> </li> </ol>"},{"location":"frontend/js/tools/ESLint/#do-we-need-to-use-eslint-in-react","title":"Do We Need to Use ESLint in React?","text":"<p>Using ESLint in React projects is highly recommended for several reasons:</p> <ol> <li> <p>Code Quality: ESLint helps ensure that your React code follows best practices and avoids common pitfalls.</p> </li> <li> <p>Consistency: Enforces a consistent coding style across your React codebase, making it easier to read and maintain.</p> </li> <li> <p>Error Prevention: Helps catch potential errors early in the development process, reducing the likelihood of bugs in production.</p> </li> <li> <p>Integration: ESLint can be easily integrated with React projects, especially with popular configurations like Airbnb's style guide, which includes rules for React and JSX.</p> </li> </ol>"},{"location":"frontend/js/tools/ESLint/#example-configuration-for-react","title":"Example Configuration for React:","text":"<p>To use ESLint with React, you can extend a popular style guide like Airbnb\u2019s that includes React-specific linting rules. Here is an example <code>.eslintrc.json</code> for a React project:</p> <pre><code>{\n  \"env\": {\n    \"browser\": true,\n    \"es2021\": true,\n    \"node\": true\n  },\n  \"extends\": [\n    \"eslint:recommended\",\n    \"plugin:react/recommended\",\n    \"airbnb\"\n  ],\n  \"parserOptions\": {\n    \"ecmaFeatures\": {\n      \"jsx\": true\n    },\n    \"ecmaVersion\": 12,\n    \"sourceType\": \"module\"\n  },\n  \"plugins\": [\n    \"react\"\n  ],\n  \"rules\": {\n    \"react/react-in-jsx-scope\": \"off\",\n    \"indent\": [\"error\", 2],\n    \"linebreak-style\": [\"error\", \"unix\"],\n    \"quotes\": [\"error\", \"single\"],\n    \"semi\": [\"error\", \"always\"]\n  }\n}\n</code></pre> <p>Using ESLint in your React projects will help you maintain high code quality, consistent style, and catch errors early, ultimately leading to more robust and maintainable code.</p>"},{"location":"frontend/js/tools/ESLint/#add-eslint-scripts-to-packagejson","title":"Add ESLint Scripts to <code>package.json</code>","text":"<pre><code>{\n  \"scripts\": {\n    \"lint\": \"eslint 'src/**/*.{js,jsx}'\",\n    \"lint:fix\": \"eslint 'src/**/*.{js,jsx}' --fix\"\n  }\n}\n</code></pre>"},{"location":"frontend/js/tools/node-package-manager/","title":"npm","text":"<p>npm is a powerful package manager for JavaScript and Node.js, serving as the default package manager for the <code>Node.js</code> runtime environment. It includes a command-line client (npm) and an online repository (<code>npm registry</code>) for hosting and sharing JavaScript packages.</p> Example"},{"location":"frontend/js/tools/node-package-manager/#using-npm-flags-effectively-when-to-use-d-s-and-more","title":"Using npm Flags Effectively: When to Use <code>-D</code>, <code>-S</code>, and More","text":"<ol> <li> <p>-D or --save-dev:</p> <ul> <li>Purpose: Install packages needed only for development, such as build tools, testing libraries, and linters. This means the package will be listed under the devDependencies section in the <code>package.json</code> file.</li> <li>Usage: Use this flag when adding development tools that aren\u2019t needed in production.</li> <li>Example: <code>npm install -D jest eslint webpack</code></li> </ul> </li> <li> <p>No Flag or --save or -S:</p> <ul> <li>Purpose: Install packages needed for both <code>development</code> and <code>production</code>, such as frameworks and libraries. This is the default behavior when you run <code>npm install</code> without any flags. It installs the package as a dependency and adds it to the dependencies section in <code>package.json</code>.</li> <li>Usage: Use this default behavior for core dependencies required to run your application.</li> <li>Example: <code>npm install react express axios</code></li> </ul> </li> <li> <p>-g or --global:</p> <ul> <li>Purpose: Install packages globally for system-wide access, useful for CLI tools and utilities.</li> <li>Usage: Use this flag for tools you want to use from the command line across projects.</li> <li>Example: <code>npm install -g nodemon</code></li> </ul> </li> <li> <p>--exact or -E:</p> <ul> <li>Purpose: Install packages with an exact version, avoiding automatic updates.</li> <li>Usage: Use this for version consistency in your project.</li> <li>Example: <code>npm install lodash@4.17.21 -E</code></li> </ul> </li> <li> <p>--no-save:</p> <ul> <li>Purpose: Install a package temporarily without adding it to package.json.</li> <li>Usage: Use this for testing or one-time installs.</li> <li>Example: <code>npm install some-temporary-package --no-save</code></li> </ul> </li> <li> <p>--save-optional or -O:</p> <ul> <li>Purpose: Install packages that are not essential but provide additional functionality if available.</li> <li>Usage: Use this for optional dependencies that enhance your project but aren't critical.</li> <li>Example: <code>npm install fsevents -O</code></li> </ul> </li> <li> <p>--save-peer:</p> <ul> <li>Purpose: Install packages as peer dependencies, which are meant to work alongside a specific version of another package.</li> <li>Usage: Use this for packages that should be compatible with a specific version of a core dependency.</li> <li>Example: <code>npm install react@^17.0.0 -P</code></li> </ul> </li> </ol> <p>Choosing the right flag ensures that your dependencies are managed effectively, keeping your project organized and efficient.</p> <p>Summary</p> <ul> <li>Use -D for development dependencies.</li> <li>Use without any flag for production dependencies.</li> <li>Use -g for globally installed tools.</li> <li>Use -E for exact version installations.</li> <li>Use --no-save for temporary installations.</li> <li>Use -O for optional dependencies.</li> <li>Use -P for peer dependencies.</li> </ul>"},{"location":"frontend/js/tools/node-package-manager/#deep-dive-into-packagejson","title":"Deep Dive into <code>package.json</code>","text":"<p>The <code>package.json</code> file is central to any <code>Node.js</code> project, serving as the manifest for your project. It defines project metadata, dependencies, scripts, and configurations. Here\u2019s an in-depth look at the key sections and features of package.json:</p>"},{"location":"frontend/js/tools/node-package-manager/#scripts","title":"Scripts","text":"<ul> <li>Purpose: Defines custom commands that can be run using <code>npm run &lt;script-name&gt;</code>.</li> <li> <p>Examples:</p> <pre><code>\"scripts\": {\n    \"start\": \"node index.js\",\n    \"test\": \"jest\",\n    \"build\": \"webpack --config webpack.config.js\"\n}\n</code></pre> </li> <li> <p>Custom Scripts: You can create scripts for various tasks like testing, building, linting, and more. Scripts can be executed with <code>npm run &lt;script-name&gt;</code>.</p> </li> </ul>"},{"location":"frontend/js/tools/node-package-manager/#dependencies","title":"Dependencies","text":"<ul> <li> <p>dependencies: Packages required for the application to run in production.</p> <pre><code>\"dependencies\": {\n    \"express\": \"^4.17.1\",\n    \"axios\": \"^0.21.1\"\n}\n</code></pre> </li> <li> <p>devDependencies: Packages needed only during development (e.g., testing frameworks, build tools).</p> <pre><code>\"devDependencies\": {\n    \"jest\": \"^26.6.3\",\n    \"webpack\": \"^5.24.4\"\n}\n</code></pre> </li> <li> <p>optionalDependencies: Packages that are not essential but provide additional features if available.</p> <pre><code>\"optionalDependencies\": {\n    \"fsevents\": \"^1.2.13\"\n}\n</code></pre> </li> <li> <p>peerDependencies: Packages that your project needs to work alongside a specific version of another package.</p> <pre><code>\"peerDependencies\": {\n    \"react\": \"^17.0.2\"\n}\n</code></pre> </li> </ul>"},{"location":"frontend/js/tools/node-package-manager/#configurations","title":"Configurations","text":"<ul> <li> <p>engines: Specifies which versions of Node.js and other engines your project is compatible with.</p> <pre><code>\"engines\": {\n    \"node\": \"&gt;=12.0.0\"\n}\n</code></pre> </li> <li> <p>browserslist: Defines the list of browsers that your project should support, used by tools like Babel and Autoprefixer.</p> <pre><code>\"browserslist\": [\n    \"&gt; 1%\",\n    \"last 2 versions\",\n    \"not dead\"\n]\n</code></pre> </li> </ul>"},{"location":"frontend/js/tools/node-package-manager/#scripts-configuration-hooks","title":"Scripts Configuration <code>Hooks</code>","text":"<ul> <li> <p>pre and post Hooks: Special scripts that run before or after a specific script. For example, <code>pretest</code> runs before test, and <code>postbuild</code> runs after build.</p> <pre><code>\"scripts\": {\n    \"pretest\": \"echo Preparing for tests...\",\n    \"test\": \"jest\",\n    \"posttest\": \"echo Tests completed!\"\n}\n</code></pre> </li> </ul>"},{"location":"frontend/js/tools/node-package-manager/#package-metadata","title":"Package Metadata","text":"<ul> <li> <p>main: The entry point of your project or package, usually the main file.</p> <pre><code>\"main\": \"index.js\"\n</code></pre> </li> </ul>"},{"location":"frontend/js/tools/node-package-manager/#workspaces","title":"Workspaces","text":"<ul> <li> <p>Purpose: Manage multiple packages within a single repository. Useful for monorepos.</p> </li> <li> <p>Configuration:</p> </li> </ul> <pre><code>\"workspaces\": [\n  \"packages/*\"\n]\n</code></pre>"},{"location":"frontend/js/tools/node-package-manager/#summary","title":"Summary","text":"<ul> <li><code>package.json</code> is crucial for defining project metadata, managing dependencies, configuring scripts, and setting up project settings.</li> <li>Scripts help automate development workflows.</li> <li>Dependencies are categorized into <code>dependencies</code>, <code>devDependencies</code>, <code>optionalDependencies</code>, and <code>peerDependencies</code> based on their role.</li> <li>Configurations and metadata fields help define how your project behaves and integrates with other tools.</li> </ul> <p>Mastering <code>package.json</code> allows you to effectively manage your <code>Node.js</code> projects and streamline development processes.</p>"},{"location":"frontend/js/tools/node-version-manager/","title":"Node Version Manager","text":""},{"location":"frontend/js/tools/node-version-manager/#install-nvm","title":"Install NVM","text":"<ol> <li> <p>Install NVM using either <code>curl</code> or <code>wget</code>:</p> cURLwget <p>To install NVM using <code>curl</code>, run the following command:</p> <pre><code>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.2/install.sh | bash\n</code></pre> <p>To install NVM using <code>wget</code>, run the following command:</p> <pre><code>wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.2/install.sh | bash\n</code></pre> </li> <li> <p>Source the new instructions NVM added to <code>.bashrc</code> during the installation process. You can either exit and re-enter the shell console, or manually source your <code>.bashrc</code> file. This file is almost always located at the root of your home directory:</p> <pre><code>source ~/.bashrc\n</code></pre> </li> <li> <p>Confirm the version of NVM that is running with the following command:</p> <pre><code>nvm --version\n</code></pre> </li> </ol>"},{"location":"frontend/js/tools/node-version-manager/#reference","title":"Reference","text":"<ul> <li>node version manager nvm</li> </ul>"},{"location":"frontend/js/tools/nodejs-package-manager/","title":"nodejs package manager","text":"<ul> <li> <p> npm (Node Package Manager)</p> <p>Comes pre-installed with Node.js, no additional setup required.</p> <p> Reference</p> </li> <li> <p> Yarn</p> <p>Excellent support for monorepos and managing multiple packages within a single repository.</p> <p> Reference</p> </li> <li> <p> pnpm (Performant npm)</p> <p>Uses a unique approach of symlinking packages which saves space and speeds up installations.</p> <p> Reference</p> </li> </ul>"},{"location":"frontend/js/tools/nodejs-package-manager/#decision-factors","title":"Decision Factors","text":"<ol> <li>Performance Needs: If speed and efficiency are crucial, consider Yarn or pnpm.</li> <li>Monorepo Management: For projects with multiple packages, Yarn or pnpm\u2019s workspace features are beneficial.</li> <li>Team Familiarity: Choose the package manager that your team is most comfortable with to minimize the learning curve.</li> <li>Ecosystem and Tooling: Consider the compatibility of the package manager with other tools and services you use.</li> </ol>"},{"location":"frontend/js/tools/nodejs-package-manager/#summary","title":"Summary","text":"<ul> <li>Use npm if you prefer the default, out-of-the-box solution with Node.js.</li> <li>Use Yarn if you need faster installs, stability, and good monorepo support.</li> <li>Use pnpm if you want the best performance and disk space efficiency, and are open to adopting newer tools.</li> </ul>"},{"location":"frontend/js/tools/pnpm/","title":"pnpm","text":"<p>pnpm (Performant npm):</p> <ul> <li>Focuses on efficient disk space usage and speed.</li> <li>Shares dependencies across projects without duplicating them.</li> <li>Uses a <code>pnpm-lock.yaml</code> file to lock dependencies.</li> <li>Command examples: <code>pnpm install</code>, <code>pnpm update</code>, <code>pnpm remove</code>.</li> </ul>"},{"location":"frontend/js/tools/vite/","title":"Vite","text":"<p>Vite is primarily needed during the development phase of a project, not in production. Here\u2019s why:</p> Abstract Development:Production: <ul> <li>Fast Build and HMR: Vite provides a fast and efficient development server with Hot Module Replacement (HMR), allowing you to see changes in real-time without a full page reload.</li> <li>Modern JavaScript Support: Vite leverages native ES modules in the browser for faster builds and efficient module loading during development.</li> <li>Optimized for Development: Vite is optimized to improve the development experience with features like fast refresh, instant feedback, and efficient bundling.</li> </ul> <ul> <li>Build Process: Vite is used to build the final optimized bundle of your application. It handles tasks like minification, code splitting, and other optimizations to prepare your code for production deployment.</li> <li>Static Assets Handling: Vite can process and optimize static assets such as images, stylesheets, and other resources during the build process.</li> </ul> Conclusion: <ul> <li>In Development: You need Vite to run your development server, utilize HMR, and benefit from its fast build times and modern JavaScript support.</li> <li>In Production: Vite is used to build and optimize your application, but it is not required to run the application in a production environment. The built and optimized output from Vite is what gets deployed, not Vite itself.</li> </ul> <p>Therefore, you should install Vite as a <code>development dependency</code> using the -D flag:</p> <pre><code>npm install -D vite\n</code></pre> <p>This ensures that Vite is only used during the development phase and build process, not in the production environment.</p>"},{"location":"frontend/js/tools/vite/#scaffolding-your-first-vite-project","title":"Scaffolding Your First Vite Project","text":"Compatibility Note <p>Vite requires <code>Node.js</code> version 18+ or 20+. However, some templates require a higher Node.js version to work, please upgrade if your package manager warns about it.</p> NPMYarnPNPMBun <pre><code>$ npm create vite@latest\n</code></pre> <pre><code>$ yarn create vite\n</code></pre> <pre><code>$ pnpm create vite\n</code></pre> <pre><code>$ bun create vite\n</code></pre> <p>Then follow the prompts!</p> <p>You can also directly specify the project name and the template you want to use via additional command line options. For example, to scaffold a Vite + Vue project, run:</p> <pre><code># npm 7+, extra double-dash is needed:\nnpm create vite@latest my-vue-app -- --template vue\n\n# yarn\nyarn create vite my-vue-app --template vue\n\n# pnpm\npnpm create vite my-vue-app --template vue\n\n# bun\nbun create vite my-vue-app --template vue\n</code></pre> <p>You can use <code>.</code> for the project name to scaffold in the current directory.</p>"},{"location":"frontend/js/tools/vite/#supported-template","title":"Supported Template","text":"<p>The supported template presets are:</p> JavaScript TypeScript vanilla vanilla-ts vue vue-ts react react-ts preact preact-ts lit lit-ts svelte svelte-ts solid solid-ts qwik qwik-ts"},{"location":"frontend/js/tools/vite/#viteconfigjs","title":"vite.config.js","text":"Example ViteVite <pre><code>import { defineConfig } from 'vite';\nimport vue from '@vitejs/plugin-vue'; // Example plugin for Vue\nimport path from 'path';\n\nexport default defineConfig({\n    // Basic server configuration\n    server: {\n        port: 3000, // Specify the port number\n        open: true, // Automatically open the app in the default browser\n    },\n\n    // Aliases\n    resolve: {\n        alias: {\n        '@': path.resolve(__dirname, 'src'), // Simplify import paths\n        },\n    },\n\n    // Plugins\n    plugins: [\n        vue(), // Add plugins here\n    ],\n\n    // CSS Preprocessing\n    css: {\n        preprocessorOptions: {\n        scss: {\n            additionalData: `@import \"@/styles/global.scss\";`, // Example for SCSS\n        },\n        },\n    },\n\n    // Build options\n    build: {\n        outDir: 'dist', // Output directory for the build\n        sourcemap: true, // Enable source maps for debugging\n        rollupOptions: {\n        output: {\n            // Customize the output settings\n            chunkFileNames: 'js/[name]-[hash].js',\n            entryFileNames: 'js/[name]-[hash].js',\n            assetFileNames: 'assets/[name]-[hash].[ext]',\n        },\n        },\n    },\n\n    // Environment Variables\n    define: {\n        'process.env': process.env, // Use environment variables\n    },\n});\n</code></pre> <pre><code>// vite.config.js\nimport { defineConfig } from 'vite';\n\nexport default defineConfig({\n    // Basic server configuration\n    server: {\n        port: 3000, // set the port to 3000\n        host: 'localhost', // set the host\n        https: false, // enable HTTPS\n        open: true, // automatically open the app in the browser\n        cors: true, // enable CORS\n        proxy: {\n            // configure proxy rules\n            '/api': {\n                target: 'http://localhost:5000',\n                changeOrigin: true,\n                rewrite: (path) =&gt; path.replace(/^\\/api/, '')\n            }\n        }\n    }\n});\n</code></pre>"},{"location":"frontend/js/tools/vite/#to-automatically-open-your-app-in-the-browser","title":"To automatically open your app in the browser","text":"<p>To automatically open your app in the browser when running npm run dev, you need to configure your <code>vite.config.js</code> file appropriately and ensure your <code>package.json</code> has the correct script.</p> <pre><code>// vite.config.js\nimport { defineConfig } from 'vite';\n\nexport default defineConfig({\n    // Basic server configuration\n    server: {\n        open: true, // automatically open the app in the default browser\n        port: 3000, // you can also set the port if needed\n    }\n});\n</code></pre> <p>Updating <code>package.json</code></p> <p>In your package.json, make sure you have a script defined to start the Vite development server. It typically looks like this:</p> <pre><code>// package.json\n{\n  \"scripts\": {\n    \"dev\": \"vite\"\n  }\n}\n</code></pre> <p>Running the Development Server</p> <p>With the above configurations in place, running npm run dev will start the Vite development server and automatically open your app in the default web browser.</p> <pre><code>npm run dev\n</code></pre>"},{"location":"frontend/js/tools/vite/#handling-jsxtsx-in-vite","title":"Handling JSX/TSX in Vite","text":"<p>Vite needs plugins to handle frameworks like React, Vue, etc. For React, you would typically use the <code>@vitejs/plugin-react plugin</code>.</p> <p>Install Necessary Plugins</p> <pre><code>npm install @vitejs/plugin-react\n</code></pre> <p>Update <code>vite.config.js</code> with Plugins</p> <p>Here is a complete example of <code>vite.config.js</code> for a React project:</p> <pre><code>import { defineConfig } from 'vite';\nimport react from '@vitejs/plugin-react';\n\nexport default defineConfig({\n    plugins: [react()],\n    resolve: {\n        alias: {\n        '@': path.resolve(__dirname, 'src'), // Optional alias\n        },\n        extensions: ['.js', '.jsx', '.ts', '.tsx'], // Ensure Vite resolves these extensions\n    },\n    server: {\n        port: 3000,\n        open: true,\n    },\n    build: {\n        outDir: 'dist',\n        sourcemap: true,\n    },\n});\n</code></pre> <p>Summary</p> <ol> <li>Rename your files to have the appropriate extensions (<code>.jsx</code> for JavaScript with JSX, <code>.tsx</code> for TypeScript with JSX).</li> <li>Install necessary plugins and configure Vite to recognize these extensions.</li> <li>Update your <code>vite.config.js</code> to include plugins and resolve the appropriate extensions.</li> </ol> <p>By following these steps, you should resolve the internal server error related to invalid JS syntax in Vite.</p>"},{"location":"frontend/js/tools/vite/#reference","title":"Reference","text":"<ul> <li>vitejs.dev</li> </ul>"},{"location":"frontend/js/tools/yarn/","title":"yarn","text":"<ul> <li>Developed by Facebook as an alternative to npm.</li> <li>Focuses on speed, reliability, and deterministic dependency resolution.</li> <li>Uses a <code>yarn.lock</code> file to lock dependencies.</li> <li>Command examples: <code>yarn add</code>, <code>yarn upgrade</code>, <code>yarn remove</code>.</li> </ul>"},{"location":"frontend/react/code-for-change/","title":"Code For Change","text":""},{"location":"frontend/react/code-for-change/#question","title":"Question","text":"How to: api, reducer, action <pre><code>src\n    services\n        redux\n            groupchat\n                action.js\n                reducer.js\n                api.js\n            contact\n                action.js\n                reducer.js\n                api.js\n        store\n            middlewares\n                app.js\n            index.js\n            StoreProvider.js\n    common.js\n    commonService.js\n    remanentCalls.js\n    types.js\n</code></pre> APIAction api<pre><code>import queryString from \"query-string\";\nimport { appBaseUrl } from \"utils/config\";\nimport { getService, postService, putService } from \"../../commonServices\";\n\nexport class FingerPrintService {\n    addFingerPrint(q) {\n        let query = queryString.stringify(q);\n        let url = `${appBaseUrl}/attendance/allFingerPrintDataByDateRangeAdd?${query}`;\n        // local\n        // let url = `http://localhost:7143/FingerPrintData/GetRevisedFingerPrintDataByDateRange?${query}`;\n        let data = postService(url);\n        return data;\n    }\n}\n</code></pre> action.js<pre><code>import  { FINGER_PRINT_TYPES } from '../../types';\nimport { init, success, finish, error } from 'services/common';\nimport { message } from 'antd';\nimport { FingerPrintService } from \"./api\"\n\nconst fingerPrintService = new FingerPrintService();\n\nexport const fingerPrintAdd = (body) =&gt; {\n    return async(dispatch) =&gt; {\n        dispatch(init(FINGER_PRINT_TYPES.CREATE_FINGER_PRINT));\n        const resp = await fingerPrintService.addFingerPrint(body);\n        dispatch(finish(FINGER_PRINT_TYPES.CREATE_FINGER_PRINT));\n        if(resp.isSuccess) {\n            dispatch(success(FINGER_PRINT_TYPES.CREATE_FINGER_PRINT, resp.data))\n            message.success(\"Data pull successfully\")\n        } else if(!resp.isSuccess) {\n            dispatch(error(resp.errorMessage))\n        }\n\n    }\n} \n</code></pre> Redux Folder Structure Example 1. Basic Structure2. Intermediate Structure3. Advanced Structure <p>For a small to medium-sized application, you might keep things straightforward:</p> <pre><code>src/\n|-- components/\n|-- pages/\n|-- redux/\n|   |-- actions/\n|   |   |-- exampleActions.js\n|   |-- reducers/\n|   |   |-- exampleReducer.js\n|   |-- store.js\n|-- App.js\n|-- index.js\n</code></pre> <p>Description:</p> <ul> <li>actions/: Contains action creators.</li> <li>reducers/: Contains reducer functions.</li> <li>store.js: Configures and exports the Redux store.</li> </ul> store.js<pre><code>import { createStore, combineReducers } from 'redux';\nimport exampleReducer from './reducers/exampleReducer';\n\nconst rootReducer = combineReducers({\n    example: exampleReducer,\n});\n\nconst store = createStore(rootReducer);\n\nexport default store;\n</code></pre> <p>As your application grows, you might want to organize things a bit more and introduce concepts like feature modules:</p> <pre><code>src/\n|-- components/\n|-- pages/\n|-- redux/\n|   |-- feature1/\n|   |   |-- actions.js\n|   |   |-- reducer.js\n|   |   |-- types.js\n|   |-- feature2/\n|   |   |-- actions.js\n|   |   |-- reducer.js\n|   |   |-- types.js\n|   |-- store.js\n|-- App.js\n|-- index.js\n</code></pre> <p>Description:</p> <ul> <li>feature1/ and feature2/: Feature-specific folders that include actions, reducers, and types (action type constants).</li> <li>types.js: Contains action type constants to avoid typos and make actions easier to manage.</li> </ul> feature1/actions.jsfeature1/reducer.jsstore.js actions.js<pre><code>import { FEATURE1_ACTION } from './types';\n\nexport const feature1Action = (payload) =&gt; ({\n    type: FEATURE1_ACTION,\n    payload,\n});\n</code></pre> reducer.js<pre><code>import { FEATURE1_ACTION } from './types';\nconst initialState = {};\n\nconst feature1Reducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case FEATURE1_ACTION:\n        return { ...state, ...action.payload };\n        default:\n        return state;\n    }\n};\n\nexport default feature1Reducer;\n</code></pre> <pre><code>import { createStore, combineReducers } from 'redux';\nimport feature1Reducer from './feature1/reducer';\nimport feature2Reducer from './feature2/reducer';\n\nconst rootReducer = combineReducers({\n    feature1: feature1Reducer,\n    feature2: feature2Reducer,\n});\n\nconst store = createStore(rootReducer);\n\nexport default store;\n</code></pre> <p>For larger applications, a more scalable and maintainable structure is often needed. This includes organizing by feature and separating concerns:</p> <pre><code>src/\n|-- components/\n|-- pages/\n|-- redux/\n|   |-- features/\n|   |   |-- feature1/\n|   |   |   |-- actions.js\n|   |   |   |-- reducer.js\n|   |   |   |-- selectors.js\n|   |   |   |-- types.js\n|   |   |-- feature2/\n|   |   |   |-- actions.js\n|   |   |   |-- reducer.js\n|   |   |   |-- selectors.js\n|   |   |   |-- types.js\n|   |-- rootReducer.js\n|   |-- store.js\n|   |-- thunks/\n|   |   |-- feature1Thunks.js\n|   |   |-- feature2Thunks.js\n|-- App.js\n|-- index.js\n</code></pre> <p>Description:</p> <ul> <li>features/: Organizes Redux code by feature or domain.</li> <li>selectors.js: Contains selector functions to derive data from the state.</li> <li>rootReducer.js: Combines all reducers into a single root reducer.</li> <li>thunks/: Contains asynchronous action creators (thunks) if using Redux Thunk for async operations.</li> </ul> selectors.jsactions.jsreducer.js javascript<pre><code>// features/feature1/selectors.js\n\nexport const getFeature1Data = (state) =&gt; state.feature1.data;\n</code></pre> javascript<pre><code>// features/feature1/actions.js\n\nimport { FEATURE1_ACTION } from './types';\n\nexport const feature1Action = (payload) =&gt; ({\n    type: FEATURE1_ACTION,\n    payload,\n});\n</code></pre> javascript<pre><code>// features/feature1/reducer.js\n\nimport { FEATURE1_ACTION } from './types';\n\nconst initialState = { data: [] };\n\nconst feature1Reducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case FEATURE1_ACTION:\n            return { ...state, data: action.payload };\n        default:\n            return state;\n    }\n};\n\nexport default feature1Reducer;\n</code></pre> <p>Types</p> <pre><code>// feature1/types.js\nexport const FEATURE1_ACTION = 'FEATURE1_ACTION';\nexport const FEATURE1_LOAD_REQUEST = 'FEATURE1_LOAD_REQUEST';\nexport const FEATURE1_LOAD_SUCCESS = 'FEATURE1_LOAD_SUCCESS';\nexport const FEATURE1_LOAD_FAILURE = 'FEATURE1_LOAD_FAILURE';\n</code></pre> <p>Reducer</p> rootReducer.jsstore.js <pre><code>import { combineReducers } from 'redux';\nimport feature1Reducer from './features/feature1/reducer';\nimport feature2Reducer from './features/feature2/reducer';\n\nconst rootReducer = combineReducers({\n    feature1: feature1Reducer,\n    feature2: feature2Reducer,\n});\n\nexport default rootReducer;\n</code></pre> <pre><code>import { createStore, applyMiddleware } from 'redux';\nimport rootReducer from './rootReducer';\nimport thunk from 'redux-thunk';\n\nconst store = createStore(rootReducer, applyMiddleware(thunk));\n\nexport default store;\n</code></pre> <p>This advanced structure helps in managing larger codebases by organizing Redux logic more effectively and separating concerns for better maintainability and scalability.</p> To determine if a React application is using Redux Thunk or Redux Saga middleware <p>To determine if a React application is using Redux Thunk or Redux Saga middleware, you can follow these steps:</p> <p>1. Check the Redux Store Configuration</p> <p>The most direct way to find out which middleware is being used is to examine the store configuration. The store is usually set up in a file like <code>store.js</code> or <code>configureStore.js</code>. For Redux Thunk:</p> <p>In the store configuration, look for <code>applyMiddleware</code> and see if <code>thunk</code> is being used:</p> <p>For Redux Thunk:</p> <p>In the store configuration, look for applyMiddleware and see if thunk is being used:</p> javascript<pre><code>// store.js or configureStore.js\nimport { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk'; // Import thunk middleware\nimport rootReducer from './rootReducer';\n\nconst store = createStore(\n    rootReducer,\n    applyMiddleware(thunk) // Apply thunk middleware\n);\n\nexport default store;\n</code></pre> <p>If you see <code>thunk</code> being imported and used with <code>applyMiddleware</code>, then Redux Thunk is being used.</p> <p>For Redux Saga:</p> <p>If Redux Saga is being used, the store configuration will include <code>redux-saga</code> and <code>sagaMiddleware</code>:</p> javascript<pre><code>// store.js or configureStore.js\nimport { createStore, applyMiddleware } from 'redux';\nimport createSagaMiddleware from 'redux-saga'; // Import saga middleware\nimport rootReducer from './rootReducer';\nimport rootSaga from './sagas'; // Import root saga\n\nconst sagaMiddleware = createSagaMiddleware(); // Create saga middleware\n\nconst store = createStore(\n    rootReducer,\n    applyMiddleware(sagaMiddleware) // Apply saga middleware\n);\n\nsagaMiddleware.run(rootSaga); // Run the root saga\n\nexport default store;\n</code></pre> <p>In this case, you\u2019ll find <code>createSagaMiddleware</code> and <code>sagaMiddleware.run(rootSaga)</code> in the store configuration.</p> <p>2. Check Dependencies in package.json</p> <p>Look at the <code>dependencies</code> or <code>devDependencies</code> in your <code>package.json</code> file.</p> <p>For Redux Thunk:</p> <p>You will see <code>redux-thunk</code> listed:</p> json<pre><code>\"dependencies\": {\n    \"redux-thunk\": \"^2.3.0\"\n}\n</code></pre> <p>For Redux Saga:</p> <p>You will see redux-saga listed:</p> json<pre><code>\"dependencies\": {\n    \"redux-saga\": \"^1.1.3\"\n}\n</code></pre> <p>3. Search the Codebase</p> <p>You can perform a search in your codebase to see if any <code>thunk</code> or <code>saga</code> related code is present:</p> <ul> <li>Search for <code>thunk</code>: Look for <code>import thunk from 'redux-thunk' or applyMiddleware(thunk)</code>.</li> <li>Search for <code>saga</code>: Look for <code>import createSagaMiddleware from 'redux-saga', sagaMiddleware.run</code>, or <code>import { call, put } from 'redux-saga/effects'</code>.</li> </ul> <p>4. Inspect Middleware in DevTools</p> <p>If you are using Redux DevTools, you can inspect the middleware in your application:</p> <ol> <li>Open Redux DevTools in your browser.</li> <li>Look at the middleware section or check the logs to see which middleware is being applied.</li> </ol> <p>Summary</p> <ol> <li>Check Store Configuration: Look at the <code>applyMiddleware</code> in the store setup.</li> <li>Check package.json: See which middleware libraries are listed in dependencies.</li> <li>Search Codebase: Look for imports and usage related to <code>redux-thunk</code> or <code>redux-saga</code>.</li> <li>Inspect DevTools: Use Redux DevTools to examine applied middleware.</li> </ol> <p>By using these methods, you can determine whether your React application is utilizing Redux Thunk or Redux Saga middleware.</p>"},{"location":"frontend/react/code-for-change/#code-for-change-cfc","title":"Code For Change (CFC)","text":""},{"location":"frontend/react/code-for-change/#redux","title":"REDUX","text":"Improved Error Handling and Asynchronous Code Management in Redux-Thunk with React Component Integration Old CodeNew CodeKey Differences Explained Action Creator:<pre><code>export const actionForGroupChatTitleAdd = (body) =&gt; {\n    return async(dispatch) =&gt; {\n        dispatch(init(GROUPCHAT_TYPES.CREATE_GROUPCHAT_TITLE));\n        const resp = await groupChatService.apiForGroupChatTitleAdd(body);\n        if(resp.isSuccess) {\n            dispatch(success(GROUPCHAT_TYPES.CREATE_GROUPCHAT_TITLE, resp.data))\n            message.success(\"Newly added Group Chat\")\n        } else if(!resp.isSuccess) {\n            dispatch(error(resp.errorMessage))\n        }\n        dispatch(finish(GROUPCHAT_TYPES.CREATE_GROUPCHAT_TITLE));\n    }\n}\n</code></pre> Component:<pre><code>const onFinish = (values) =&gt; {\n    let errorReq = {\n        \"chatGroupName\": \"ICTC \",\n        \"referenceId\": \"f9f8bf40-067e-42aa-8538-e9d4dbd8e2fe\"\n    };\n\n    // dispatch(actionForGroupChatTitleAdd(values));\n    dispatch(actionForGroupChatTitleAdd(errorReq))\n        .then(() =&gt; {\n            console.log(\"Successfully added group chat title\");\n            onClose();\n        })\n        .catch((error) =&gt; {\n            console.log(\"error: \", error);\n            // Do not close the drawer in case of an error\n        });\n};\n</code></pre> <p>Updated Action Creator</p> <p>Your current action creator looks good, but for better error handling, we can ensure it throws an error when the response is not successful:</p> Action Creator:<pre><code>export const actionForGroupChatTitleAdd = (body) =&gt; {\n    return async(dispatch) =&gt; {\n        dispatch(init(GROUPCHAT_TYPES.CREATE_GROUPCHAT_TITLE));\n        try {\n            const resp = await groupChatService.apiForGroupChatTitleAdd(body);\n            if(resp.isSuccess) {\n                dispatch(success(GROUPCHAT_TYPES.CREATE_GROUPCHAT_TITLE, resp.data));\n                message.success(\"Newly added Group Chat\");\n                return resp.data; // Return data for success\n            } else {\n                dispatch(error(resp.errorMessage));\n                throw new Error(resp.errorMessage); // Throw error to be caught in the component\n            }\n        } catch (err) {\n            dispatch(error(err.message || 'Unknown error occurred'));\n            throw err; // Re-throw error to be caught in the component\n        } finally {\n            dispatch(finish(GROUPCHAT_TYPES.CREATE_GROUPCHAT_TITLE));\n        }\n    }\n};\n</code></pre> <p>Component Handling the API Call</p> <p>In your component, handle the promise returned by the dispatch function to conditionally call <code>onClose</code>:</p> Component:<pre><code>const onFinish = async (values) =&gt; {\n    let errorReq = {\n        \"chatGroupName\": \"ICTC \",\n        \"referenceId\": \"f9f8bf40-067e-42aa-8538-e9d4dbd8e2fe\"\n    };\n\n    try {\n        await dispatch(actionForGroupChatTitleAdd(errorReq));\n        console.log(\"Successfully added group chat title\");\n        onClose();\n    } catch (error) {\n        console.log(\"error: \", error);\n        message.error(\"Failed to add group chat title\");\n        // Drawer remains open\n    }\n};\n</code></pre> Explanation <p>Action Creator:</p> <ul> <li>If the API response is successful, it dispatches the <code>success</code> action and returns the response data.</li> <li>If the API response is not successful, it dispatches the <code>error</code> action and throws an error to be caught by the calling component.</li> <li>Errors caught within the <code>try</code> block are dispatched as errors and re-thrown to be handled by the component.</li> </ul> <p>Component:</p> <ul> <li>The <code>onFinish</code> function is modified to use <code>async/await</code> for handling the dispatch.</li> <li>On success (<code>await dispatch(actionForGroupChatTitleAdd(errorReq));</code>), it logs the success message and calls onClose() to close the drawer.</li> <li>On error (<code>catch</code> block), it logs the error and displays an error message using <code>message.error</code>. The drawer remains open.</li> </ul> <ol> <li> <p>Error Handling in Action Creator:</p> <p>Original Code:</p> <ul> <li>The action creator does not throw an error when the response is unsuccessful. It only dispatches the error message.</li> <li>This means the component cannot directly catch errors thrown by the action creator.</li> </ul> <p>Updated Code:</p> <ul> <li>The action creator explicitly throws an error when the response is unsuccessful. This allows the component to catch and handle the error.</li> <li>It uses a try-catch block to handle both the API call and any unexpected errors, re-throwing them to be caught in the component.</li> </ul> </li> <li> <p>Promise Handling in Component:</p> <p>Original Code:</p> <ul> <li>Uses <code>.then()</code> and <code>.catch()</code> to handle the promise returned by the action creator.</li> <li>If an error occurs, it is logged, but the drawer remains open because <code>onClose()</code> is not called in the <code>catch</code> block.</li> </ul> <p>Updated Code:</p> <ul> <li>Uses <code>async/await</code> syntax for better readability and error handling.</li> <li>The <code>try-catch</code> block allows for more straightforward handling of success and error cases.</li> <li>On success, it logs a message and calls <code>onClose()</code> to close the drawer.</li> <li>On error, it logs the error, displays an error message using <code>message.error</code>, and ensures the drawer remains open.</li> </ul> </li> </ol> <p>Summary</p> <p>The updated code improves error handling and readability:</p> <p>Action Creator:</p> <ul> <li>Handles both success and error cases explicitly.</li> <li>Throws errors to be caught by the component, ensuring better error propagation.</li> </ul> <p>Component:</p> <ul> <li>Uses <code>async/await</code> for cleaner, more readable asynchronous code.</li> <li>Handles success and error cases more clearly with a <code>try-catch</code> block.</li> <li>Ensures the drawer only closes on a successful API call, keeping it open on error.</li> </ul> <p>By documenting these changes, you can ensure a clear understanding of the improvements made and the rationale behind them.</p>"},{"location":"frontend/react/code-for-change/#redux-middleware","title":"Redux Middleware","text":"which redux middleware is more advance thunk or saga? <p>Both Redux Thunk and Redux Saga are popular middleware options for managing side effects in a Redux application, but they have different approaches and capabilities. Here\u2019s a comparison to help you determine which might be more advanced or suitable for your needs:</p> Redux ThunkRedux Saga <p>Advantages:</p> <ul> <li>Simplicity: Thunks are functions that can be dispatched like normal actions, making them simple to understand and implement.</li> <li>Familiarity: It feels similar to regular JavaScript, especially for handling asynchronous logic using promises or async/await.</li> <li>Learning Curve: It has a lower learning curve compared to Redux Saga.</li> </ul> <p>Disadvantages:</p> <ul> <li>Readability: As applications grow, complex async flows can become harder to manage and read.</li> <li>Error Handling: Handling complex error scenarios can be cumbersome.</li> </ul> <p>Advantages:</p> <ul> <li>Advanced Control: Provides more powerful control over complex async flows using generators, making it easier to manage and test.</li> <li>Concurrency: Better at handling concurrent actions and coordinating complex async processes.</li> <li>Testability: Sagas are more straightforward to test due to their generator-based nature.</li> <li>Composability: Easier to compose multiple sagas to work together and handle more advanced patterns like race conditions or parallel execution.</li> </ul> <p>Disadvantages:</p> <ul> <li>Complexity: Has a steeper learning curve due to the use of ES6 generators and more advanced patterns.</li> <li>Boilerplate: Can introduce more boilerplate code compared to Thunk.</li> </ul> <p>Conclusion</p> <p>When to Use Redux Thunk:</p> <ul> <li>For simpler applications or those just starting with Redux.</li> <li>When you need straightforward async logic handling.</li> <li>If you want a lower learning curve and less boilerplate.</li> </ul> <p>When to Use Redux Saga:</p> <ul> <li>For larger applications with complex async needs.</li> <li>When you need advanced control over side effects and better testability.</li> <li>If you are comfortable with generators and more complex patterns.</li> </ul> <p>Overall, Redux Saga is generally considered more advanced due to its powerful capabilities and fine-grained control over side effects. However, it also comes with more complexity, so the choice between Thunk and Saga should be based on your specific application needs and your team's familiarity with these tools.</p>"},{"location":"frontend/react/code-for-change/#which-one-to-use","title":"Which one to use","text":"Which One to Master First: Thunk or Saga? <p>Start with Redux Thunk:</p> <ul> <li>Simplicity: Thunk is simpler and easier to grasp, making it a good starting point for understanding how to manage side effects in Redux.</li> <li>Foundational Knowledge: Learning Thunk first provides a solid foundation in handling asynchronous actions, which is beneficial before tackling the more advanced concepts in Redux Saga.</li> </ul> How to Master Redux ThunkHow to Master Redux Saga <ol> <li> <p>Understand the Basics:</p> <ul> <li>Learn how to create and dispatch actions in Redux.</li> <li>Understand synchronous vs. asynchronous actions.</li> </ul> </li> <li> <p>Set Up Redux Thunk:</p> <ul> <li>Integrate Redux Thunk into your Redux store configuration.</li> </ul> </li> <li> <p>Create Thunk Actions:</p> <ul> <li>Write action creators that return functions instead of plain objects.</li> <li>Use <code>dispatch</code> and <code>getState</code> inside these functions to manage async operations.</li> </ul> </li> <li> <p>Handle Asynchronous Logic:</p> <ul> <li>Use promises or async/await within Thunk actions to perform API calls or other async tasks.</li> <li>Manage loading states and error handling within Thunk actions.</li> </ul> </li> <li> <p>Read Documentation and Tutorials:</p> <ul> <li>Follow the Redux Thunk documentation.</li> <li>Explore tutorials and examples on managing async actions with Thunk.</li> </ul> </li> <li> <p>Build Projects:</p> <ul> <li>Apply your knowledge in real projects to gain practical experience.</li> <li>Refactor existing Redux code to use Thunk for async actions.</li> </ul> </li> </ol> <ol> <li> <p>Understand ES6 Generators:</p> <ul> <li>Familiarize yourself with ES6 generator functions, as they are fundamental to Redux Saga.</li> <li>Practice using <code>yield</code>, <code>next()</code>, and generator control flow.</li> </ul> </li> <li> <p>Learn Redux Saga Basics:</p> <ul> <li>Understand the core concepts of Redux Saga, including sagas, effects, watchers, and workers.</li> </ul> </li> <li> <p>Set Up Redux Saga:</p> <ul> <li>Integrate Redux Saga into your Redux store configuration.</li> </ul> </li> <li> <p>Create Simple Sagas:</p> <ul> <li>Write sagas to handle asynchronous actions using <code>takeEvery</code>, <code>takeLatest</code>, and <code>call</code>.</li> <li>Learn to manage side effects like API calls, delays, and parallel execution.</li> </ul> </li> <li> <p>Handle Complex Scenarios:</p> <ul> <li>Use advanced patterns like <code>race</code>, <code>all</code>, and <code>cancellation</code> to manage complex async flows.</li> <li>Handle concurrency and manage multiple sagas.</li> </ul> </li> <li> <p>Read Documentation and Tutorials:</p> <ul> <li>Follow the Redux Saga documentation.</li> <li>Explore tutorials and examples to understand advanced use cases.</li> </ul> </li> <li> <p>Build Projects:</p> <ul> <li>Apply Redux Saga in real projects to tackle more complex async logic.</li> <li>Refactor existing Thunk code to use Redux Saga for better control and testability.</li> </ul> </li> </ol> <p>Additional Tips for Mastery</p> <ul> <li>Practice Regularly: Consistent practice and application in real projects are key to mastering both Thunk and Saga.</li> <li>Join Communities: Participate in online forums, communities, and discussions to learn from others and share your experiences.</li> <li>Keep Updated: Both Thunk and Saga are actively maintained, so keep an eye on updates and best practices by following their repositories and release notes.</li> <li>Experiment: Don't be afraid to experiment with different patterns and techniques to find what works best for your use case.</li> </ul> <p>Starting with Redux Thunk provides a solid foundation, and mastering Redux Saga will give you advanced tools for handling complex asynchronous logic in your Redux applications.</p>"},{"location":"frontend/react/code-for-change/#jest","title":"Jest","text":"<p>In the context of package management, like with <code>npm</code> (Node Package Manager) for JavaScript projects, <code>--save</code> and <code>--save-dev</code> are options used during the installation of packages. Here's a simple explanation of the difference:</p> <ul> <li> <p>--save: When you install a package using --save, it means the package will be listed as a dependency in your project's <code>package.json</code> file. This indicates that your project needs this package to run properly. These dependencies are typically packages required for the application to function correctly in production.</p> </li> <li> <p>--save-dev: On the other hand, when you install a package using --save-dev, it means the package will be listed as a development dependency in your project's <code>package.json</code> file. This indicates that your project only needs this package during development, such as for testing, building, or other development-related tasks. These dependencies are typically tools or libraries used during the development process, but not necessary for the application to run in production.</p> </li> </ul> <p>So, in summary:</p> <ul> <li>Use --save for packages your project needs to run.</li> <li>Use --save-dev for packages your project needs during development but not for running the final application.</li> </ul> <ul> <li>--save <code>vs</code> --save-dev</li> <li>jest testing</li> <li>How To Structure React Projects From Beginner To Advanced</li> <li>useEffect by Example</li> </ul>"},{"location":"frontend/react/code-for-change/#easy-thumbnail","title":"Easy Thumbnail","text":"<ul> <li>easy-thumbnails 2.8.5: pypi</li> <li>easy thumbnail: readthedocs</li> <li>easy thumbnail: github</li> </ul> <pre><code>from easy_thumbnails.fields import ThumbnailerImageField\n\nclass Profile(models.Model):\n    user = models.OneToOneField('auth.User')\n    photo = ThumbnailerImageField(upload_to='photos', blank=True)\n</code></pre>"},{"location":"frontend/react/code-for-change/#step-1","title":"Step 1:","text":"<pre><code>Run pip install easy-thumbnails.\n</code></pre>"},{"location":"frontend/react/code-for-change/#step-2","title":"Step 2:","text":"<pre><code>Add `easy_thumbnails` to your INSTALLED_APPS setting:\n\n```python\nINSTALLED_APPS = (\n    ...\n    'easy_thumbnails',\n)\n```\n</code></pre>"},{"location":"frontend/react/code-for-change/#step-3","title":"Step 3:","text":"<pre><code>Run `manage.py` migrate `easy_thumbnails`\n</code></pre>"},{"location":"frontend/react/slides/","title":"Slides","text":""},{"location":"frontend/react/slides/#presentation","title":"Presentation","text":""},{"location":"frontend/react/core/guides/","title":"Guides","text":"<p>React Design Patterns and Best Practices page number: 82</p> <p>Props are the way a parent component can pass its data down the tree to every component that needs it (or part of it).</p> <p>When a component passes some props to another component, it is called the Owner, irrespective of the parent-child relation between them.</p>"},{"location":"frontend/react/core/guides/#children","title":"Children","text":"<p>There is a special prop that can be passed from the owners to the components defined inside their render method; it is called children.</p> <p>In the React documentation, it is described as <code>opaque</code> because it is a property that does not tell anything about the value it contains.</p>"},{"location":"frontend/react/core/guides/#react-hooks-reference","title":"React Hooks Reference","text":"<ul> <li>Learn core Redux \u2014 The easiest way you can imagine</li> <li> <p>Redux Toolkit \u2014 The cheat sheet for Redux development</p> </li> <li> <p>React Hooks cheat sheet: Best practices with examples</p> </li> <li> <p>React Hooks Cheat Sheet</p> </li> <li> <p>React Hooks Cheatsheet \u2014 Most commonly used hooks in ReactJS</p> </li> <li> <p>The React Cheatsheet for 2021 (+ Real-World Examples)</p> </li> </ul>"},{"location":"frontend/react/core/guides/#reference","title":"Reference","text":"<p>LinkedIn React Post</p>"},{"location":"frontend/react/core/intro/","title":"Introduction","text":""},{"location":"frontend/react/core/intro/#programming-paradigm","title":"Programming Paradigm","text":"<ul> <li>imperative (how to do)</li> <li>declarative (what to do)</li> </ul>"},{"location":"frontend/react/core/intro/#react-is-declarative","title":"React is declarative","text":"<p>In declarative programming, you concentrate on the \"<code>what</code>\". Not the \"<code>how</code>\". For instance, the following snippet tells your app to serve certain pages at the given route-paths.</p> <p>Libraries:</p> <ul> <li>React</li> <li>React-Router</li> <li>React-Apollo (GraphQL)</li> <li>Styled-Components</li> <li>Express</li> <li>Infrastructure-Components</li> </ul> <p>Notes</p> <ul> <li> <p><code>React.js</code> removed the boundaries between HTML and JavaScript. It uses the Javascript   Syntax Extension (JSX) that complements basic Javascript source code with HTML.</p> </li> <li> <p><code>Styled-Components</code> added a convenient way of styling your React-components. There\u2019s no   need for global style sheets anymore.</p> </li> <li> <p>With <code>Infrastructure-Components</code>, you can integrate REST-services into your React app. As   well as database schemes and queries. You can even configure your serverless infrastructure.</p> </li> </ul> <p>life is an experiment. The more experiments you make the better. - Ralph Waldo Emerson</p>"},{"location":"frontend/react/core/intro/#different-ways-to-scaffold-a-react-application","title":"Different Ways to Scaffold a React Application","text":"<p>There are several ways to create and scaffold a React application. Here are some of the most popular methods:</p>"},{"location":"frontend/react/core/intro/#1-create-react-app-cra","title":"1. Create React App (CRA)","text":"<p>Create React App is an officially supported way to create single-page React applications. It offers a modern build setup with no configuration.</p> Installation:<pre><code>npx create-react-app my-app\ncd my-app\nnpm start\n</code></pre>"},{"location":"frontend/react/core/intro/#2-vite","title":"2. Vite","text":"<p>Vite is a fast build tool that offers an alternative to Create React App with a focus on speed and performance.</p> Installation:<pre><code>npm create vite@latest my-app --template react\ncd my-app\nnpm install\nnpm run dev\n</code></pre>"},{"location":"frontend/react/core/intro/#3-nextjs","title":"3. Next.js","text":"<p>Next.js is a powerful framework built on top of React for building server-side rendered (SSR) and statically generated (SSG) websites.</p> Installation:<pre><code>npx create-next-app@latest my-app\ncd my-app\nnpm run dev\n</code></pre>"},{"location":"frontend/react/core/intro/#4-gatsby","title":"4. Gatsby","text":"<p>Gatsby is a React-based framework for building fast static websites and apps.</p> Installation:<pre><code>npm install -g gatsby-cli\ngatsby new my-app\ncd my-app\ngatsby develop\n</code></pre>"},{"location":"frontend/react/core/intro/#5-parcel","title":"5. Parcel","text":"<p>Parcel is a web application bundler that can also be used to scaffold a React project with zero configuration.</p> Installation:<pre><code>mkdir my-app\ncd my-app\nnpm init -y\nnpm install react react-dom parcel\n</code></pre> Project Structure: <ol> <li> <p>Create an <code>index.html</code> file:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;My App&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"app\"&gt;&lt;/div&gt;\n    &lt;script src=\"index.js\"&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> </li> <li> <p>Create an <code>index.js</code> file:</p> <pre><code>import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nconst App = () =&gt; &lt;div&gt;Hello, world!&lt;/div&gt;;\n\nReactDOM.render(&lt;App /&gt;, document.getElementById(\"app\"));\n</code></pre> </li> </ol> <p>Start the development server:</p> <pre><code>npx parcel index.html\n</code></pre>"},{"location":"frontend/react/core/intro/#6-manual-setup-with-webpack-and-babel","title":"6. Manual Setup with Webpack and Babel","text":"<p>For more control over the configuration, you can set up a React project manually using Webpack and Babel.</p> Installation:<pre><code>mkdir my-app\ncd my-app\nnpm init -y\nnpm install react react-dom webpack webpack-cli webpack-dev-server babel-loader @babel/core @babel/preset-env @babel/preset-react html-webpack-plugin\n</code></pre> Configuration <ol> <li> <p>Create a <code>webpack.config.js</code> file:</p> <pre><code>const path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: ['@babel/preset-env', '@babel/preset-react']\n          }\n        }\n      }\n    ]\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html'\n    })\n  ],\n  devServer: {\n    contentBase: './dist'\n  }\n};\n</code></pre> </li> <li> <p>Create a <code>.babelrc</code> file:</p> <pre><code>{\n  \"presets\": [\"@babel/preset-env\", \"@babel/preset-react\"]\n}\n</code></pre> </li> <li> <p>Create an <code>index.html</code> file in src:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;My App&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"app\"&gt;&lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> </li> <li> <p>Create a <code>.babelrc</code> file:</p> <pre><code>import React from 'react';\nimport ReactDOM from 'react-dom';\n\nconst App = () =&gt; &lt;div&gt;Hello, world!&lt;/div&gt;;\n\nReactDOM.render(&lt;App /&gt;, document.getElementById('app'));\n</code></pre> </li> </ol> <p>Start the development server:</p> <pre><code>npx webpack serve\n</code></pre> <p>These methods cover a range of scenarios from quick setups with Create React App to more complex configurations with Next.js and manual setups using Webpack. Choose the one that best fits your project's needs.</p>"},{"location":"frontend/react/core/intro/#recommendation","title":"Recommendation","text":"<p>For most modern React projects, Next.js is a highly recommended choice due to its flexibility, performance benefits, and future-proof features. It supports a wide range of use cases, from simple SPAs to complex, SEO-friendly applications.</p> <p>Create React App is also a solid choice for simpler projects or for those who prefer minimal configuration and an easy setup process. However, as projects scale, you might find the need to switch to a more flexible solution like Next.js.</p> <p>Vite is gaining traction and can be an excellent choice for developers who prioritize build speed and modern tooling.</p> <p>Gatsby remains a strong option for static site generation and content-driven projects.</p> <p>Ultimately, the choice depends on your project requirements, team familiarity, and long-term goals. All of these tools have strong communities and regular updates, ensuring they remain relevant and useful for years to come.</p>"},{"location":"frontend/react/core/intro/#reference","title":"Reference","text":"<ul> <li> <p>React-Architect by Dr.Frank Zickert</p> </li> <li> <p>What is Programming Paradigm?</p> </li> </ul>"},{"location":"frontend/react/core/migrating-cra-vite/","title":"Migrating Cra to vite","text":""},{"location":"frontend/react/core/migrating-cra-vite/#migrating-create-react-app-to-vite","title":"Migrating create-react-app to Vite","text":"<pre><code>for x in src/**/*.js; do mv \"$x\" \"${x%.js}.jsx\"; done\n</code></pre>"},{"location":"frontend/react/core/migrating-cra-vite/#heres-a-modified-version","title":"Here's a modified version","text":"<p>You can use the find command along with exec to achieve this more efficiently.</p> bash<pre><code>find src -type f -name '*.js' -exec sh -c 'mv \"$1\" \"${1%.js}.jsx\"' _ {} \\;\n</code></pre> <p>Explanation of the command:</p> <ul> <li> <p><code>find src -type f -name '*.js'</code>:</p> <p>This part finds all files (<code>-type f</code>) with a .js extension in the <code>src</code> directory.</p> </li> <li> <p><code>-exec sh -c 'mv \"$1\" \"${1%.js}.jsx\"' _ {} \\;</code>:</p> <p>For each file found, it executes the given shell command to rename the file. The <code>{}</code> is a placeholder for the file name, and the <code>_</code> is a placeholder for <code>$0</code> in the shell command.</p> <p>So, when you run this command, it will find all <code>.js</code> files in the src directory and rename them to <code>.jsx</code>. Make sure to run this command from the parent directory containing the src directory.</p> </li> </ul>"},{"location":"frontend/react/core/migrating-cra-vite/#editor-in-react","title":"Editor in React","text":"<ul> <li>TinyMCE React</li> <li>ckeditor5-react</li> </ul>"},{"location":"frontend/react/core/migrating-cra-vite/#outdated-library","title":"Outdated Library","text":"<ul> <li>react-kanban: archived</li> </ul>"},{"location":"frontend/react/core/migrating-cra-vite/#reference","title":"Reference","text":"<ul> <li>Upgrade React: w3schools</li> <li>create-react-app to vite: youtube</li> <li>Bash Scripting to changes all file name</li> </ul>"},{"location":"frontend/react/core/react-context-api/","title":"react context api","text":""},{"location":"frontend/react/core/react-context-api/#react-context-api","title":"React Context API","text":"<pre><code># Context API Folder Structure\n\nsrc/\n|-- components/\n|-- context/\n|   |-- MyContext.js\n|   |-- MyContextProvider.js\n|-- pages/\n|-- App.js\n|-- index.js\n</code></pre> <p>The React Context API allows you to share state or behavior across your React components without having to pass props manually through each level of the component tree. Here's a simple guide on how to use the React Context API:</p>"},{"location":"frontend/react/core/react-context-api/#step-1-create-a-context","title":"Step 1: Create a Context","text":"<p>You can create a new context using the <code>createContext</code> function from React.</p> MyContext.js<pre><code>import { createContext } from \"react\";\n\nconst MyContext = createContext();\n\nexport default MyContext;\n</code></pre>"},{"location":"frontend/react/core/react-context-api/#step-2-create-a-provider-component","title":"Step 2: Create a Provider Component","text":"<p>Create a provider component that will wrap the part of your component tree where you want to make the context available. This provider component will be responsible for managing the state that you want to share.</p> MyContextProvider.js<pre><code>import React, { useState } from \"react\";\nimport MyContext from \"./MyContext\";\n\nconst MyContextProvider = ({ children }) =&gt; {\n  const [myState, setMyState] = useState(\"Initial value\");\n\n  const updateState = (newValue) =&gt; {\n    setMyState(newValue);\n  };\n\n  return (\n    &lt;MyContext.Provider value={{ myState, updateState }}&gt;\n      {children}\n    &lt;/MyContext.Provider&gt;\n  );\n};\n\nexport default MyContextProvider;\n</code></pre>"},{"location":"frontend/react/core/react-context-api/#step-3-wrap-your-app-with-the-provider","title":"Step 3: Wrap Your App with the Provider","text":"<p>Wrap your main App component (or any parent component) with the provider component you created. This will make the context and its state available to all the components within that part of the component tree.</p> App.js<pre><code>import React from \"react\";\nimport MyContextProvider from \"./MyContextProvider\";\nimport MyComponent from \"./MyComponent\";\n\nconst App = () =&gt; {\n  return (\n    &lt;MyContextProvider&gt;\n      &lt;MyComponent /&gt;\n    &lt;/MyContextProvider&gt;\n  );\n};\n\nexport default App;\n</code></pre>"},{"location":"frontend/react/core/react-context-api/#step-4-consume-the-context-in-a-component","title":"Step 4: Consume the Context in a Component","text":"<p>Now, any component within the wrapped part of the tree can consume the context using the useContext hook.</p> MyComponent.js<pre><code>import React, { useContext } from \"react\";\nimport MyContext from \"./MyContext\";\n\nconst MyComponent = () =&gt; {\n  const { myState, updateState } = useContext(MyContext);\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Value from context: {myState}&lt;/p&gt;\n      &lt;button onClick={() =&gt; updateState(\"New value\")}&gt;Update Context&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default MyComponent;\n</code></pre> <p>Notes</p> <p>The key idea is that the state or functions you provide through the context provider become accessible to all the components that consume that context within the wrapped part of the component tree.</p>"},{"location":"frontend/react/core/react-context-api/#reference","title":"Reference","text":"<ul> <li>How to Use the React Context API in Your Projects: good</li> <li>React Context API: What is it and How it works?</li> </ul>"},{"location":"frontend/react/core/react-router/","title":"react router","text":""},{"location":"frontend/react/core/react-router/#router","title":"Router","text":"<pre><code>// Installation\n\n$ pnpm install react-router-dom\n</code></pre>"},{"location":"frontend/react/core/react-router/#how-to-install-react-router","title":"How to Install React Router?","text":"<p>React router contains 3 different packages for routing.</p> <ul> <li><code>react-router</code>: contains most of the core functionality of React Router including the route matching algorithm and most of the core components and react hooks</li> <li><code>react-router-native</code>: It is designed for mobile applications.</li> <li><code>react-router-dom</code>: It is designed for web applications.</li> </ul>"},{"location":"frontend/react/core/react-router/#components-in-react-router","title":"Components in React Router","text":"<p>React router components are divided into 3 main categories -</p> <ul> <li><code>Routers</code> - for instance, <code>&lt;BrowserRouter&gt;</code> and <code>&lt;HashRouter&gt;</code> components</li> <li><code>Route matchers</code> - for instance, <code>&lt;Routes&gt;</code> and <code>&lt;Route&gt;</code> components</li> <li><code>Navigation</code> \u2013 for instance, <code>&lt;Link&gt;</code> and <code>&lt;NavLink&gt;</code> components</li> </ul> <p></p>"},{"location":"frontend/react/core/react-router/#code","title":"Code","text":"<pre><code>import { BrowserRouter as Router, Switch, Route } from \"react-router-dom\";\n\nexport default function App() {\n  return (\n    &lt;Router&gt;\n      &lt;Navbar /&gt;\n      &lt;Switch&gt;\n        &lt;Route exact path=\"/\" component={Home} /&gt;\n        &lt;Route path=\"/about\" component={About} /&gt;\n      &lt;/Switch&gt;\n    &lt;/Router&gt;\n  );\n}\n</code></pre>"},{"location":"frontend/react/core/react-router/#redirect-component","title":"Redirect Component","text":"<pre><code>import {\n  BrowserRouter as Router,\n  Switch,\n  Route,\n  Redirect\n} from \"react-router-dom\";\n\nexport default function App() {\n  return (\n    &lt;Router&gt;\n      &lt;Switch&gt;\n        &lt;Route exact path=\"/\" component={Home} /&gt;\n        &lt;PrivateRoute path=\"/hidden\" component={Hidden} /&gt;\n      &lt;/Switch&gt;\n    &lt;/Router&gt;\n  );\n}\n\nfunction PrivateRoute({ component: Component, ...rest }) {\n  // useAuth is some custom hook to get the current user's auth state\n  const isAuth = useAuth();\n\n  return (\n    &lt;Route\n      {...rest}\n      render={(props) =&gt;\n        isAuth ? &lt;Component {...props} /&gt; : &lt;Redirect to=\"/\" /&gt;\n      }\n    /&gt;\n  );\n}\n\nfunction Home() {\n  return &lt;&gt;home&lt;/&gt;;\n}\n\nfunction Hidden() {\n  return &lt;&gt;hidden&lt;/&gt;;\n}\n</code></pre> <p>The redirect component is very simple to use, very declarative, and allows us to see the great benefit of React Router DOM being component-based, just like everything in React.</p>"},{"location":"frontend/react/core/react-router/#react-router-hooks","title":"React Router Hooks","text":"<ul> <li>useHistory Hook</li> <li>useLocation Hook</li> <li>useParams Hook + Dynamic Routes</li> <li>useRouteMatch Hook</li> </ul> <pre><code>import { useHistory } from \"react-router-dom\";\n\n\nfunction About() {\n  const history = useHistory();\n\n  console.log(history.location.pathname); // '/about'\n\n  return (\n    &lt;&gt;\n     &lt;h1&gt;The about page is on: {history.location.pathname}&lt;/h1&gt;\n     &lt;button onClick={() =&gt; history.push('/')}&gt;Go to home page&lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre>"},{"location":"frontend/react/core/react-router/#upgrading-fro-v5-to-v6","title":"Upgrading fro <code>v5</code> to <code>v6</code>","text":"<ul> <li>Upgrade all <code>&lt;Switch&gt;</code> elements to <code>&lt;Routes&gt;</code></li> <li>Use <code>useNavigate</code> instead of <code>useHistory</code></li> <li>Replace <code>useRouteMatch</code> with <code>useMatch</code></li> </ul> <p>Replacing Switch component with Routes</p> <pre><code>// old with Switch\n\nexport function App() {\n  return (\n    &lt;div&gt;\n      &lt;Switch&gt;\n        &lt;Route path=\"/about\"&gt;\n          &lt;AboutPage /&gt;\n        &lt;/Route&gt;\n        &lt;Route exact path=\"/profile\"&gt;\n          &lt;ProfilePage /&gt;\n        &lt;/Route&gt;\n        &lt;Route path=\"/profile/:id\"&gt;\n          &lt;ProfileUserPage /&gt;\n        &lt;/Route&gt;\n      &lt;/Switch&gt;\n    &lt;/div&gt;\n  )\n}\n\n// new with Routes\n\nexport function App() {\n  return (\n    &lt;div&gt;\n      &lt;Routes&gt;\n        &lt;Route path=\"/about\" element={&lt;AboutPage /&gt;} /&gt;\n        &lt;Route exact path=\"/profile\" element={&lt;ProfilePage /&gt;} /&gt;\n        &lt;Route path=\"/profile/:id\" element={&lt;ProfileUserPage /&gt;} /&gt;\n      &lt;/Routes&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre> <p>Internal changes &amp; path evaluation (no more needed exact prop) For V5 we needed to put the exact prop on the component to go for that specific route we want</p> <pre><code>// old\n\nexport function App() {\n  return (\n    &lt;div&gt;\n      &lt;Routes&gt;\n        &lt;Route path=\"/about\" element={&lt;AboutPage /&gt;} /&gt;\n        &lt;Route exact path=\"/profile\" element={&lt;ProfilePage /&gt;} /&gt;\n        &lt;Route path=\"/profile/:id\" element={&lt;ProfileUserPage /&gt;} /&gt;\n      &lt;/Routes&gt;\n    &lt;/div&gt;\n  )\n}\n\n// new\nexport function App() {\n  return (\n    &lt;div&gt;\n      &lt;Routes&gt;\n        &lt;Route path=\"/about\" element={&lt;AboutPage /&gt;} /&gt;\n        &lt;Route path=\"/profile\" element={&lt;ProfilePage /&gt;} /&gt;\n        &lt;Route path=\"/profile/:id\" element={&lt;ProfileUserPage /&gt;} /&gt;\n      &lt;/Routes&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre>"},{"location":"frontend/react/core/react-router/#history","title":"History","text":"<pre><code>$ npm i history\n</code></pre> <p>There are three types of history</p> <ul> <li>browser</li> <li>hash</li> <li>memory</li> </ul> <pre><code>import {\n  createBrowserHistory,\n  createHashHistory,\n  createMemoryHistory\n} from 'history'\n</code></pre> <p>If you are using React Router, it can automatically create history objects for you, so you may never have to actually interact with history directly. Still, it is important to understand the differences between each type of history so that you can determine which one is right for your project.</p>"},{"location":"frontend/react/core/react-router/#reference","title":"Reference","text":"<ul> <li>React router overview</li> <li>React Router - Types, Mechanism, Installation And Examples</li> <li>The React Router Cheatsheet \u2013 Everything You Need to Know - (BEST)</li> <li>Using Hashrouter With React - Definitive Guide</li> <li>What is Hash Routing?</li> <li>upgrading v5 - v6: oficial doc</li> <li>React router V6: Some of the new changes </li> <li>A little bit of history - npm</li> <li>history - npm</li> </ul>"},{"location":"frontend/react/core/useCallback/","title":"useCallback","text":""},{"location":"frontend/react/core/useCallback/#usecallback-hook","title":"useCallback Hook","text":"<p><code>useCallback</code> is a React hook that is used to memoize functions so that they do not get recreated on each render, which can be useful to optimize performance in certain scenarios. Here's a simple real example to illustrate the use of <code>useCallback</code>.</p> <p></p> <pre><code>import React, { useState, useCallback } from \"react\";\n\nconst ExampleComponent = () =&gt; {\n  const [count, setCount] = useState(0);\n\n  // Without useCallback\n  const handleClickWithoutCallback = () =&gt; {\n    console.log(\"Button clicked!\");\n    setCount(count + 1);\n  };\n\n  // With useCallback\n  const handleClickWithCallback = useCallback(() =&gt; {\n    console.log(\"Button clicked!\");\n    setCount(count + 1);\n  }, [count]);\n  // Dependency array: specify dependencies that should trigger function re-creation\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Count: {count}&lt;/p&gt;\n\n      &lt;button onClick={handleClickWithoutCallback}&gt;\n        Click Without useCallback\n      &lt;/button&gt;\n\n      &lt;button onClick={handleClickWithCallback}&gt;Click With useCallback&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default ExampleComponent;\n</code></pre> <p>In this example:</p> <ul> <li>The component renders a count state variable.</li> <li>There are two buttons: one <code>without useCallback</code> and one <code>with useCallback</code>.</li> <li>The <code>handleClickWithoutCallback</code> function is created inside the component body, so it is recreated on every render. This can lead to unnecessary re-renders of child components if passed down as props.</li> <li>The <code>handleClickWithCallback</code> function is memoized using useCallback, and the dependency array <code>[count]</code> specifies that the function should be recreated only when the <code>count</code> variable changes. This can be useful to prevent unnecessary function recreation and optimize performance.</li> </ul> <p>In this simple example, the difference might not be significant, but in larger applications, especially when passing functions down to child components, using <code>useCallback</code> can help optimize performance by avoiding unnecessary re-renders triggered by new function instances.</p> <p>Scenario: When to use useCallback &amp; when not to use</p> <p>Here are some scenarios where using useCallback in React can be beneficial, and situations where it may not be necessary:</p> <p>Use useCallback:</p> <ol> <li> <p>Optimizing Child Components:</p> <ul> <li>When passing callback functions as props to child components.</li> <li>It prevents unnecessary re-renders of child components if the callback function reference changes.</li> </ul> <pre><code>const ParentComponent = () =&gt; {\n  const handleClick = useCallback(() =&gt; {\n    console.log(\"Button clicked!\");\n  }, []);\n\n  return &lt;ChildComponent onClick={handleClick} /&gt;;\n};\n</code></pre> </li> <li> <p>Event Handlers in Dependencies:</p> <ul> <li>When using callback functions in the dependency array of <code>useEffect</code> to avoid unnecessary re-execution of the effect.   <pre><code>useEffect(() =&gt; {\n  // Effect logic\n}, [callbackFunction]);\n</code></pre></li> </ul> </li> <li> <p>Preventing Unnecessary Function Recreation:</p> <ul> <li>When you want to avoid recreating functions on each render, especially if those functions are passed as dependencies to other hooks or functions.   <pre><code>const memoizedFunction = useCallback(() =&gt; {\n  // Function logic\n}, [dependency1, dependency2]);\n</code></pre></li> </ul> </li> </ol> <p>Might Not Need useCallback:</p> <ol> <li> <p>Local Functions:</p> <ul> <li>If a function is defined inside a component and doesn't need to be referenced outside that component or passed down to child components, it may not need <code>useCallback</code></li> </ul> <pre><code>const MyComponent = () =&gt; {\n  const localFunction = () =&gt; {\n    // Local function logic\n  };\n\n  // No need for useCallback if localFunction is not passed as a prop or used in dependencies.\n  // ...\n};\n</code></pre> </li> <li> <p>Static Dependencies:</p> <ul> <li>If the function doesn't depend on any external variables or props, and its behavior is consistent across renders, <code>useCallback</code> might not be necessary.</li> </ul> <pre><code>const simpleFunction = () =&gt; {\n  // Function logic without dependencies\n};\n\n// No need for useCallback if simpleFunction doesn't depend on external variables.\n</code></pre> </li> <li> <p>Performance Impact is Negligible:</p> <ul> <li>In some cases, the performance impact of not using useCallback might be negligible, especially for smaller components or when function recreation does not affect the overall performance.</li> </ul> </li> </ol> <p>It's important to use <code>useCallback</code> judiciously and consider the specific use case and performance requirements of your application. If in doubt, you can start without <code>useCallback</code> and optimize later if performance becomes an issue.</p>"},{"location":"frontend/react/core/useCallback/#reference","title":"Reference","text":"<ul> <li>Your Guide to React.useCallback()</li> <li>Demystifying React Hooks: useCallback and useMemo </li> </ul>"},{"location":"frontend/react/core/useEffect-cleanup/","title":"useEffect cleanup","text":"<p>A cleanup function in React is typically used to perform necessary cleanup or resource disposal when a component unmounts. Here are some scenarios in which you should consider writing a cleanup function using the <code>useEffect</code> hook:</p>"},{"location":"frontend/react/core/useEffect-cleanup/#1-clearing-subscriptions-or-timers","title":"1. Clearing Subscriptions or Timers:","text":"<p>If your component sets up subscriptions (e.g., using <code>addEventListener</code>) or timers (e.g., using <code>setTimeout</code> or <code>setInterval</code>), it's crucial to clean them up when the component is unmounted to avoid memory leaks and unexpected behavior.</p> jsx<pre><code>useEffect(() =&gt; {\n  const timerId = setInterval(() =&gt; {\n    // Your logic here\n  }, 1000);\n\n  return () =&gt; {\n    // Cleanup: Clear the timer when the component unmounts\n    clearInterval(timerId);\n  };\n}, []);\n</code></pre>"},{"location":"frontend/react/core/useEffect-cleanup/#2-canceling-network-requests","title":"2. Canceling Network Requests:","text":"<p>If your component makes asynchronous requests (e.g., using <code>fetch</code>), you might want to cancel or abort the request if the component is unmounted to prevent setting state on an unmounted component.</p> jsx<pre><code>useEffect(() =&gt; {\n  const abortController = new AbortController();\n\n  const fetchData = async () =&gt; {\n    try {\n      const response = await fetch(\"https://api.example.com/data\", {\n        signal: abortController.signal,\n      });\n      const data = await response.json();\n      setData(data);\n    } catch (error) {\n      if (error.name === \"AbortError\") {\n        // Request was canceled (component unmounted)\n      } else {\n        console.error(\"Error fetching data:\", error);\n      }\n    }\n  };\n\n  fetchData();\n\n  return () =&gt; {\n    // Cleanup: Cancel the request if the component unmounts\n    abortController.abort();\n  };\n}, []);\n</code></pre>"},{"location":"frontend/react/core/useEffect-cleanup/#3-cleaning-up-external-resources","title":"3. Cleaning Up External Resources:","text":"<p>If your component interacts with external resources or libraries (e.g., closing a WebSocket connection, cleaning up a third-party library instance), the cleanup function is the right place to perform these actions.</p> jsx<pre><code>useEffect(() =&gt; {\n  const socket = new WebSocket(\"wss://example.com\");\n\n  socket.addEventListener(\"open\", () =&gt; {\n    // Your logic here\n  });\n\n  return () =&gt; {\n    // Cleanup: Close the WebSocket connection when the component unmounts\n    socket.close();\n  };\n}, []);\n</code></pre>"},{"location":"frontend/react/core/useEffect-cleanup/#4-resetting-state-or-side-effects","title":"4. Resetting State or Side Effects:","text":"<p>If your component needs to reset certain state variables or undo side effects when it unmounts, the cleanup function can be used for such purposes.</p> jsx<pre><code>useEffect(() =&gt; {\n  // Your effect logic here\n\n  return () =&gt; {\n    // Cleanup: Reset state or undo side effects when the component unmounts\n    resetState();\n  };\n}, [dependency]);\n</code></pre> <p>Remember that the cleanup function is an essential part of the useEffect lifecycle. It ensures that resources are properly released, preventing potential memory leaks or unintended behavior when a component is no longer in use. Always use the cleanup function to perform any necessary cleanup actions specific to the effects you've set up in your component.</p>"},{"location":"frontend/react/core/useEffect-technique-used/","title":"useEffect mostly used","text":"<p>The choice of <code>useEffect</code> technique often depends on the specific requirements of your application. However, one commonly used and versatile pattern is using <code>useEffect</code> for data fetching. This is especially relevant in applications that interact with APIs or external data sources. The pattern typically involves:</p> <ol> <li>Fetching data when the component mounts.</li> <li>Optionally fetching data based on changes in certain dependencies.</li> </ol> <p>Here's a breakdown of this pattern:</p>"},{"location":"frontend/react/core/useEffect-technique-used/#1-fetching-data-on-mount","title":"1. Fetching Data on Mount:","text":"<p>Use <code>useEffect</code> with an empty dependency array to fetch data when the component mounts. This ensures that the effect runs only once after the initial render.</p> jsx<pre><code>useEffect(() =&gt; {\n  const fetchData = async () =&gt; {\n    try {\n      const response = await fetch(\"https://api.example.com/data\");\n      const data = await response.json();\n      setData(data);\n    } catch (error) {\n      console.error(\"Error fetching data:\", error);\n    }\n  };\n\n  fetchData();\n}, []); // Empty dependency array means this effect runs once on mount\n</code></pre>"},{"location":"frontend/react/core/useEffect-technique-used/#2-fetching-data-based-on-dependencies","title":"2. Fetching Data Based on Dependencies:","text":"<p>Use <code>useEffect</code> with specific dependencies to refetch data when those dependencies change. This is useful for scenarios where you need to update data in response to user interactions or changes in the application state.</p> jsx<pre><code>useEffect(() =&gt; {\n  const fetchData = async () =&gt; {\n    try {\n      const response = await fetch(`https://api.example.com/data/${userId}`);\n      const data = await response.json();\n      setData(data);\n    } catch (error) {\n      console.error(\"Error fetching data:\", error);\n    }\n  };\n\n  fetchData();\n}, [userId]); // Refetch data when 'userId' changes\n</code></pre>"},{"location":"frontend/react/core/useEffect-technique-used/#3-cleanup-and-cancellation","title":"3. Cleanup and Cancellation:","text":"<p>Consider incorporating cleanup functions to handle scenarios like canceling pending requests or unsubscribing from external subscriptions when the component unmounts.</p> jsx<pre><code>useEffect(() =&gt; {\n  const abortController = new AbortController();\n\n  const fetchData = async () =&gt; {\n    try {\n      const response = await fetch(\"https://api.example.com/data\", {\n        signal: abortController.signal,\n      });\n      const data = await response.json();\n      setData(data);\n    } catch (error) {\n      if (error.name === \"AbortError\") {\n        // Request was canceled (component unmounted)\n      } else {\n        console.error(\"Error fetching data:\", error);\n      }\n    }\n  };\n\n  fetchData();\n\n  return () =&gt; {\n    // Cleanup: Cancel the request if the component unmounts\n    abortController.abort();\n  };\n}, []);\n</code></pre>"},{"location":"frontend/react/core/useEffect-technique-used/#4-combining-multiple-useeffect-hooks","title":"4. Combining Multiple useEffect Hooks:","text":"<p>Break down complex logic into multiple <code>useEffect</code> hooks for better readability and maintainability. For example, separate data fetching from UI-related side effects.</p> jsx<pre><code>useEffect(() =&gt; {\n  // Fetch initial data\n  const fetchData = async () =&gt; {\n    // ...\n  };\n  fetchData();\n}, []);\n\nuseEffect(() =&gt; {\n  // Handle UI-related side effects\n  // ...\n}, [data, userId]);\n</code></pre>"},{"location":"frontend/react/core/useEffect-technique-used/#5-asyncawait-pattern","title":"5. Async/Await Pattern:","text":"<p>Use the <code>async</code> keyword and <code>await</code> syntax for cleaner asynchronous code within the <code>useEffect</code>.</p> jsx<pre><code>useEffect(() =&gt; {\n  const fetchData = async () =&gt; {\n    try {\n      const response = await fetch(\"https://api.example.com/data\");\n      const data = await response.json();\n      setData(data);\n    } catch (error) {\n      console.error(\"Error fetching data:\", error);\n    }\n  };\n\n  fetchData();\n}, []);\n</code></pre> <p>This data-fetching pattern is commonly used because it covers a wide range of scenarios, from initial data loading to updating data based on changes in specific dependencies. It provides a clean and organized way to manage asynchronous operations in React components.</p>"},{"location":"frontend/react/core/useEffect-technique/","title":"useEffect Technique","text":""},{"location":"frontend/react/core/useEffect-technique/#_1","title":"useEffect Technique","text":"<p>The <code>useEffect</code> hook in React is used for handling side effects in functional components. It is a powerful tool that allows you to perform operations such as data fetching, subscriptions, or manually changing the DOM in response to component lifecycle events. Here are some advanced techniques and use cases for the <code>useEffect</code> hook:</p>"},{"location":"frontend/react/core/useEffect-technique/#1-conditional-execution","title":"1. Conditional Execution:","text":"<p>Use <code>useEffect</code> with dependencies to conditionally execute code when certain dependencies change. This is useful for optimizing performance and avoiding unnecessary computations.</p> jsx<pre><code>useEffect(() =&gt; {\n  // Effect will run when 'dependency' changes\n  fetchData(dependency);\n}, [dependency]);\n</code></pre>"},{"location":"frontend/react/core/useEffect-technique/#2-cleanup-function","title":"2. Cleanup Function:","text":"<p>Use the cleanup function returned by <code>useEffect</code> for cleanup operations, such as canceling subscriptions or clearing intervals.</p> jsx<pre><code>useEffect(() =&gt; {\n  const subscription = subscribe();\n  return () =&gt; {\n    // Cleanup function: unsubscribe when the component unmounts\n    subscription.unsubscribe();\n  };\n}, []); // Empty dependency array means this effect runs once on mount\n</code></pre>"},{"location":"frontend/react/core/useEffect-technique/#3-debouncing-and-throttling","title":"3. Debouncing and Throttling:","text":"<p>Use <code>useEffect</code> in combination with debouncing or throttling techniques to limit the rate at which a function is called.</p> jsx<pre><code>useEffect(() =&gt; {\n  const debouncedFunction = debounce(() =&gt; {\n    // Code to run after debounce\n  }, 300);\n\n  // Attach the debounced function to an event listener, for example\n  window.addEventListener(\"scroll\", debouncedFunction);\n\n  return () =&gt; {\n    // Cleanup: remove the event listener when the component unmounts\n    window.removeEventListener(\"scroll\", debouncedFunction);\n  };\n}, []);\n</code></pre>"},{"location":"frontend/react/core/useEffect-technique/#4-global-state-synchronization","title":"4. Global State Synchronization:","text":"<p>Use <code>useEffect</code> to synchronize the component's state with a global state management solution, like Redux.</p> jsx<pre><code>useEffect(() =&gt; {\n  // Update local state when global state changes\n  setLocalState(globalState);\n}, [globalState]);\n</code></pre>"},{"location":"frontend/react/core/useEffect-technique/#5-dependency-arrays-and-stale-closures","title":"5. Dependency Arrays and Stale Closures:","text":"<p>Be careful with dependencies and closures to avoid stale values. Use the functional form of <code>setState</code> to capture the latest state or props.</p> jsx<pre><code>useEffect(() =&gt; {\n  // Avoid stale closures\n  const fetchData = async () =&gt; {\n    const result = await fetch(url);\n    // Use result and capture the latest 'mounted' value\n    if (mounted.current) {\n      setData(result);\n    }\n  };\n\n  fetchData();\n\n  return () =&gt; {\n    // Cleanup: Set 'mounted' to false when the component unmounts\n    mounted.current = false;\n  };\n}, [url]);\n</code></pre>"},{"location":"frontend/react/core/useEffect-technique/#6-multiple-useeffect-for-separation-of-concerns","title":"6. Multiple useEffect for Separation of Concerns:","text":"<p>Use multiple <code>useEffect</code> blocks to separate different concerns, making your code more readable and maintainable.</p> jsx<pre><code>useEffect(() =&gt; {\n  // Code for fetching data\n  fetchData();\n}, [dependencyForDataFetching]);\n\nuseEffect(() =&gt; {\n  // Code for handling UI updates\n  updateUI();\n}, [dependencyForUIUpdate]);\n</code></pre>"},{"location":"frontend/react/core/useEffect-technique/#7-promise-in-useeffect","title":"7. Promise in useEffect:","text":"<p>If you want to work with asynchronous code in <code>useEffect</code>, you can use the async keyword and await syntax.</p> jsx<pre><code>useEffect(() =&gt; {\n  const fetchData = async () =&gt; {\n    try {\n      const result = await fetchDataFromAPI();\n      setData(result);\n    } catch (error) {\n      console.error(\"Error fetching data:\", error);\n    }\n  };\n\n  fetchData();\n}, [dependency]);\n</code></pre>"},{"location":"frontend/react/core/useEffect-technique/#8-combining-useeffect-with-other-hooks","title":"8. Combining useEffect with Other Hooks:","text":"<p>Combine useEffect with other hooks like useMemo or useCallback for more fine-grained control over the memoization of values and functions.</p> jsx<pre><code>const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);\n\nuseEffect(() =&gt; {\n  // Effect using memoizedValue\n  performEffectWithMemoizedValue(memoizedValue);\n}, [memoizedValue]);\n</code></pre> <p>Notes</p> <p>By mastering these advanced techniques, you can make the most of the useEffect hook in your React applications and handle complex scenarios with ease. Always consider the specific requirements of your application and choose the approach that best fits your use case.</p>"},{"location":"frontend/react/core/useRef/","title":"useRef","text":""},{"location":"frontend/react/core/useRef/#useref-hooks","title":"useRef hooks","text":"<p><code>useRef</code> is a React hook that provides a way to create a mutable object that persists across renders. It's commonly used to access and interact with a DOM element or to persist values across renders without causing re-renders.</p> <p>Here's a beginner's guide on how to use useRef in React:</p>"},{"location":"frontend/react/core/useRef/#basic-usage","title":"Basic Usage:","text":"<ol> <li> <p>Import <code>useRef</code>:</p> <p>Import the useRef hook from React.</p> <pre><code>import React, { useRef } from \"react\";\n</code></pre> </li> <li> <p>Create a Ref:</p> <p>Use useRef() to create a ref object.</p> <pre><code>const myRef = useRef();\n</code></pre> </li> <li> <p>Attach Ref to a JSX Element:</p> <p>Attach the ref to a JSX element using the <code>ref</code> attribute.</p> <pre><code>return &lt;div ref={myRef}&gt;Hello, useRef!&lt;/div&gt;;\n</code></pre> </li> <li> <p>Accessing the DOM Element:</p> <p>Use the <code>.current</code> property of the ref object to access the DOM element.</p> <pre><code>console.log(myRef.current); // Outputs the DOM element\n</code></pre> </li> </ol>"},{"location":"frontend/react/core/useRef/#example-with-a-functional-component","title":"Example with a Functional Component:","text":"<pre><code>import React, { useRef, useEffect } from \"react\";\n\nconst MyComponent = () =&gt; {\n  const myRef = useRef();\n\n  useEffect(() =&gt; {\n    // Access the DOM element after the component is mounted\n    console.log(myRef.current);\n  }, []); // Empty dependency array ensures the effect runs only once after mount\n\n  return &lt;div ref={myRef}&gt;Hello, useRef!&lt;/div&gt;;\n};\n\nexport default MyComponent;\n</code></pre>"},{"location":"frontend/react/core/useRef/#use-cases-and-when-to-use-useref","title":"Use Cases and When to Use useRef:","text":"<ol> <li> <p>Accessing or Modifying DOM Elements:</p> <ul> <li>Use <code>useRef</code> when you need to access or modify a DOM element directly. For example, focusing an input field, measuring an element, or triggering imperative animations.</li> </ul> <pre><code>const inputRef = useRef();\n\nuseEffect(() =&gt; {\n  inputRef.current.focus();\n}, []);\n</code></pre> </li> <li> <p>Holding Mutable Values Without Causing Rerenders:</p> <ul> <li><code>useRef</code> can hold mutable values that persist across renders without causing re-renders. This is useful for storing values that shouldn't trigger component updates.</li> </ul> <pre><code>const countRef = useRef(0);\n\nuseEffect(() =&gt; {\n  countRef.current += 1;\n  console.log(\"Render count:\", countRef.current);\n});\n</code></pre> </li> <li> <p>Storing Previous Values:</p> <ul> <li>Use <code>useRef</code> to store and compare previous values, useful for certain scenarios like tracking changes in dependencies.</li> </ul> <pre><code>const prevValueRef = useRef();\nuseEffect(() =&gt; {\n  if (value !== prevValueRef.current) {\n    console.log(\"Value changed!\");\n  }\n  prevValueRef.current = value;\n}, [value]);\n</code></pre> <p>Remember that the ref value persists between renders, so changes to <code>.current</code> do not trigger a re-render. This makes <code>useRef</code> suitable for scenarios where you need to hold mutable values across renders without causing unnecessary updates.</p> </li> </ol>"},{"location":"frontend/react/example/breaking-react-component-pattern/","title":"How to break react components","text":"<pre><code>Component Decomposition\nContainer and Presentational Components\nHigher-Order Components (HOCs)\nRender Props\nCustom Hooks\nContext API\nComposition Over Inheritance\n</code></pre> <p>Breaking components into smaller, manageable pieces is essential for maintaining a clean and scalable React application. Here are some of the most useful React patterns for breaking components effectively:</p>"},{"location":"frontend/react/example/breaking-react-component-pattern/#1-component-decomposition","title":"1. Component Decomposition","text":"<p>Break down large components into smaller, reusable ones based on their functionality or UI elements. This makes each component simpler and easier to maintain.</p> Example jsx<pre><code>// Large Component\nconst UserProfile = () =&gt; (\n    &lt;div&gt;\n        &lt;Avatar /&gt;\n        &lt;UserInfo /&gt;\n        &lt;UserPosts /&gt;\n    &lt;/div&gt;\n);\n\n// Smaller Components\nconst Avatar = () =&gt; &lt;img src=\"avatar.jpg\" alt=\"User Avatar\" /&gt;;\n    const UserInfo = () =&gt; (\n    &lt;div&gt;\n        &lt;h2&gt;John Doe&lt;/h2&gt;\n        &lt;p&gt;john.doe@example.com&lt;/p&gt;\n    &lt;/div&gt;\n    );\n    const UserPosts = () =&gt; (\n    &lt;ul&gt;\n        &lt;li&gt;First Post&lt;/li&gt;\n        &lt;li&gt;Second Post&lt;/li&gt;\n    &lt;/ul&gt;\n);\n</code></pre>"},{"location":"frontend/react/example/breaking-react-component-pattern/#2-container-and-presentational-components","title":"2. Container and Presentational Components","text":"<p>Separate components into container (stateful) and presentational (stateless) components. Containers handle logic and state, while presentational components handle rendering.</p> Example jsx<pre><code>// Container Component\nconst UserProfileContainer = () =&gt; {\n    const [user, setUser] = useState({ name: 'John Doe', email: 'john.doe@example.com' });\n    return &lt;UserProfile user={user} /&gt;;\n};\n\n// Presentational Component\nconst UserProfile = ({ user }) =&gt; (\n    &lt;div&gt;\n        &lt;h2&gt;{user.name}&lt;/h2&gt;\n        &lt;p&gt;{user.email}&lt;/p&gt;\n    &lt;/div&gt;\n);\n</code></pre>"},{"location":"frontend/react/example/breaking-react-component-pattern/#3-higher-order-components-hocs","title":"3. Higher-Order Components (HOCs)","text":"<p>Use HOCs to enhance components with additional functionality, such as adding authentication or fetching data.</p> Example jsx<pre><code>// Higher-Order Component\nconst withUserData = (WrappedComponent) =&gt; {\n    return (props) =&gt; {\n        const [user, setUser] = useState(null);\n\n        useEffect(() =&gt; {\n        // Fetch user data\n        setUser({ name: 'John Doe', email: 'john.doe@example.com' });\n        }, []);\n\n        return &lt;WrappedComponent user={user} {...props} /&gt;;\n    };\n};\n\n// Wrapped Component\nconst UserProfile = ({ user }) =&gt; (\n    &lt;div&gt;\n        &lt;h2&gt;{user ? user.name : 'Loading...'}&lt;/h2&gt;\n        &lt;p&gt;{user ? user.email : ''}&lt;/p&gt;\n    &lt;/div&gt;\n);\n\nconst EnhancedUserProfile = withUserData(UserProfile);\n</code></pre>"},{"location":"frontend/react/example/breaking-react-component-pattern/#4-render-props","title":"4. Render Props","text":"<p>Use render props to share code between components by passing a function as a prop that returns React elements.</p> Example jsx<pre><code>// Component with Render Props\nconst DataProvider = ({ render }) =&gt; {\n    const [data, setData] = useState('Hello World');\n\n    return render(data);\n};\n\n// Usage\nconst App = () =&gt; (\n    &lt;DataProvider render={(data) =&gt; &lt;div&gt;{data}&lt;/div&gt;} /&gt;\n);\n</code></pre>"},{"location":"frontend/react/example/breaking-react-component-pattern/#5-custom-hooks","title":"5. Custom Hooks","text":"<p>Create custom hooks to encapsulate reusable logic and state management, which can then be used across multiple components.</p> Example jsx<pre><code>// Custom Hook\nconst useCounter = () =&gt; {\n    const [count, setCount] = useState(0);\n\n    const increment = () =&gt; setCount(count + 1);\n    const decrement = () =&gt; setCount(count - 1);\n\n    return { count, increment, decrement };\n};\n\n// Component using Custom Hook\nconst Counter = () =&gt; {\n    const { count, increment, decrement } = useCounter();\n\n    return (\n        &lt;div&gt;\n        &lt;p&gt;Count: {count}&lt;/p&gt;\n        &lt;button onClick={increment}&gt;Increment&lt;/button&gt;\n        &lt;button onClick={decrement}&gt;Decrement&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n</code></pre>"},{"location":"frontend/react/example/breaking-react-component-pattern/#6-context-api","title":"6. Context API","text":"<p>Use the Context API to manage global state and avoid prop drilling by providing data to all components within a provider.</p> Example jsx<pre><code>// Context\nconst ThemeContext = createContext();\n\n// Provider Component\nconst ThemeProvider = ({ children }) =&gt; {\n    const [theme, setTheme] = useState('light');\n\n    return (\n        &lt;ThemeContext.Provider value={{ theme, setTheme }}&gt;\n        {children}\n        &lt;/ThemeContext.Provider&gt;\n    );\n};\n\n// Consuming Context\nconst ThemedComponent = () =&gt; {\n    const { theme } = useContext(ThemeContext);\n\n    return &lt;div className={theme}&gt;Current Theme: {theme}&lt;/div&gt;;\n};\n</code></pre>"},{"location":"frontend/react/example/breaking-react-component-pattern/#7-composition-over-inheritance","title":"7. Composition Over Inheritance","text":"<p>Leverage composition to build components with flexible and reusable parts, rather than relying on inheritance or deeply nested components.</p> Example jsx<pre><code>// Composition\nconst Panel = ({ header, children }) =&gt; (\n    &lt;div className=\"panel\"&gt;\n        &lt;div className=\"panel-header\"&gt;{header}&lt;/div&gt;\n        &lt;div className=\"panel-body\"&gt;{children}&lt;/div&gt;\n    &lt;/div&gt;\n);\n\n// Usage\nconst App = () =&gt; (\n    &lt;Panel header=\"Panel Header\"&gt;\n        &lt;p&gt;Panel Body Content&lt;/p&gt;\n    &lt;/Panel&gt;\n);\n</code></pre>"},{"location":"frontend/react/example/breaking-react-component-pattern/#summary","title":"Summary","text":"<p>By using these patterns, you can create more maintainable, reusable, and modular React components. Each pattern has its own use cases and benefits, and often, a combination of these patterns will be used to achieve the desired structure and behavior in a React application.</p>"},{"location":"frontend/react/example/children-prop/","title":"Children Prop","text":"<p>In React, children is a special prop that allows you to pass components or elements to a component as its children. This enables the creation of more flexible and reusable components by allowing them to render nested content. What is children?</p> <p>The children prop is a special prop in React that represents the content between the opening and closing tags of a component. This content can be other React components, elements, or plain text.</p>"},{"location":"frontend/react/example/children-prop/#how-children-relates-to-react","title":"How <code>children</code> Relates to React","text":"<p>The <code>children</code> prop is a core feature of React's composition model. It enables components to:</p> <ul> <li>Encapsulate and Render Nested Content: Components can render nested elements or components within their own output.</li> <li>Create Reusable Layouts: Layout components like modals, dialogs, or containers can use children to render dynamic content.</li> </ul>"},{"location":"frontend/react/example/children-prop/#how-to-use-children","title":"How to Use children","text":"<ol> <li> <p>Basic Usage:</p> <p>You can use <code>children</code> to render any content that is passed between the opening and closing tags of a component.</p> Example<pre><code>const Wrapper = ({ children }) =&gt; (\n    &lt;div className=\"wrapper\"&gt;\n        {children}\n    &lt;/div&gt;\n);\n\nconst App = () =&gt; (\n    &lt;Wrapper&gt;\n        &lt;h1&gt;Hello, World!&lt;/h1&gt;\n        &lt;p&gt;This is some content inside the Wrapper component.&lt;/p&gt;\n    &lt;/Wrapper&gt;\n);\n\nexport default App;\n</code></pre> <p>In this example, the Wrapper component uses the children prop to render whatever is passed inside its tags.</p> </li> <li> <p>Rendering Multiple Children:</p> <p>children can be a single element, a list of elements, or even a mix of both.</p> jsx<pre><code>const List = ({ children }) =&gt; (\n    &lt;ul&gt;\n        {React.Children.map(children, (child) =&gt; (\n        &lt;li&gt;{child}&lt;/li&gt;\n        ))}\n    &lt;/ul&gt;\n);\n\nconst App = () =&gt; (\n    &lt;List&gt;\n        &lt;span&gt;Item 1&lt;/span&gt;\n        &lt;span&gt;Item 2&lt;/span&gt;\n        &lt;span&gt;Item 3&lt;/span&gt;\n    &lt;/List&gt;\n);\n\nexport default App;\n</code></pre> <p>In this example, the <code>List</code> component takes multiple <code>children</code> elements and renders them as list items.</p> </li> <li> <p>Using <code>React.Children</code> Utilities:</p> <p>React provides utility methods for working with <code>children</code>, such as <code>React.Children.map</code>, <code>React.Children.forEach</code>, and <code>React.Children.toArray</code>.</p> jsx<pre><code>const Parent = ({ children }) =&gt; (\n    &lt;div&gt;\n        {React.Children.map(children, (child, index) =&gt; (\n        &lt;div key={index}&gt;{child}&lt;/div&gt;\n        ))}\n    &lt;/div&gt;\n);\n\nconst App = () =&gt; (\n    &lt;Parent&gt;\n        &lt;p&gt;First Child&lt;/p&gt;\n        &lt;p&gt;Second Child&lt;/p&gt;\n    &lt;/Parent&gt;\n);\n\nexport default App;\n</code></pre> <p>In this example, <code>React.Children.map</code> is used to iterate over and render each child within a <code>div</code>.</p> </li> <li> <p>Conditional Rendering of <code>children</code>:</p> <p>You can conditionally render <code>children</code> based on some logic.</p> <pre><code>const ConditionalWrapper = ({ condition, children }) =&gt; (\n    &lt;div&gt;\n        {condition ? children : &lt;p&gt;No content available&lt;/p&gt;}\n    &lt;/div&gt;\n);\n\nconst App = () =&gt; (\n    &lt;ConditionalWrapper condition={true}&gt;\n        &lt;p&gt;This content will be displayed.&lt;/p&gt;\n    &lt;/ConditionalWrapper&gt;\n);\n\nexport default App;\n</code></pre> </li> </ol>"},{"location":"frontend/react/example/children-prop/#summary","title":"Summary","text":"<p>The <code>children</code> prop in React is a powerful feature that allows components to render nested content dynamically. It helps in creating flexible and reusable components by enabling them to accept and render various types of content. By understanding and utilizing <code>children</code>, you can build more modular and maintainable React applications.</p>"},{"location":"frontend/react/example/component-composition/","title":"Component Composition","text":"<p>Component composition is a fundamental concept in React that involves building complex UIs by combining smaller, reusable components. It allows developers to create more manageable, modular, and maintainable code. Instead of creating large monolithic components, you can break them down into smaller, self-contained components that can be composed together to form the final UI.</p> <p>Practice creating small, reusable components and composing them into larger components.</p>"},{"location":"frontend/react/example/component-composition/#react-patterns-for-breaking-down-components","title":"React Patterns for Breaking Down Components","text":"<ul> <li> <p> 1. Presentational and Container Components:</p> <p>how things look &amp; how things work</p> <p> Getting started</p> </li> <li> <p> 2. Higher-Order Components (HOCs)</p> <p>Use HOCs to add common functionality to components. For example, you might have an HOC to handle form submission logic.</p> <p> Getting started</p> </li> <li> <p> 3. Render Props</p> <p>Render props is a pattern for sharing code between React components using a prop whose value is a function.</p> <p> Getting started</p> </li> </ul>"},{"location":"frontend/react/example/component-composition/#key-principles-of-component-composition","title":"Key Principles of Component Composition","text":"<ol> <li>Reusability: Create components that can be reused across different parts of your application.</li> <li>Single Responsibility: Each component should have a single responsibility, making it easier to understand and maintain.</li> <li>Separation of Concerns: Separate the concerns of different parts of your application into different components.</li> <li>Declarative Syntax: Use a declarative syntax to define how components should be composed together.</li> </ol>"},{"location":"frontend/react/example/component-composition/#example","title":"Example","text":"<p>Let's look at an example where we compose a user profile page using smaller components.</p> <ol> <li> <p>Basic Components:</p> jsx<pre><code>// Avatar.js\nconst Avatar = ({ url }) =&gt; &lt;img src={url} alt=\"User Avatar\" /&gt;;\n\n// UserInfo.js\nconst UserInfo = ({ name, email }) =&gt; (\n&lt;div&gt;\n    &lt;h2&gt;{name}&lt;/h2&gt;\n    &lt;p&gt;{email}&lt;/p&gt;\n&lt;/div&gt;\n);\n\n// UserPosts.js\nconst UserPosts = ({ posts }) =&gt; (\n&lt;ul&gt;\n    {posts.map(post =&gt; (\n    &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;\n    ))}\n&lt;/ul&gt;\n);\n</code></pre> </li> <li> <p>Composing the Components:</p> jsx<pre><code>// UserProfile.js\nimport Avatar from './Avatar';\nimport UserInfo from './UserInfo';\nimport UserPosts from './UserPosts';\n\nconst UserProfile = ({ user, posts }) =&gt; (\n&lt;div&gt;\n    &lt;Avatar url={user.avatarUrl} /&gt;\n    &lt;UserInfo name={user.name} email={user.email} /&gt;\n    &lt;UserPosts posts={posts} /&gt;\n&lt;/div&gt;\n);\n\nexport default UserProfile;\n</code></pre> </li> <li> <p>Using the Composed Component:</p> jsx<pre><code>// App.js\nimport UserProfile from './UserProfile';\n\nconst user = {\nname: 'John Doe',\nemail: 'john.doe@example.com',\navatarUrl: 'https://example.com/avatar.jpg',\n};\n\nconst posts = [\n{ id: 1, title: 'First Post' },\n{ id: 2, title: 'Second Post' },\n];\n\nconst App = () =&gt; (\n&lt;div&gt;\n    &lt;UserProfile user={user} posts={posts} /&gt;\n&lt;/div&gt;\n);\n\nexport default App;\n</code></pre> </li> </ol>"},{"location":"frontend/react/example/component-composition/#benefits-of-component-composition","title":"Benefits of Component Composition","text":"<ul> <li>Maintainability: Smaller components are easier to understand and maintain.</li> <li>Reusability: Reusable components can be used in different parts of the application.</li> <li>Testability: Smaller components are easier to test individually.</li> <li>Scalability: Composing components makes it easier to scale the application as it grows.</li> </ul>"},{"location":"frontend/react/example/component-composition/#tips-for-effective-component-composition","title":"Tips for Effective Component Composition","text":"<ul> <li>Identify Common Patterns: Look for patterns in your UI that can be abstracted into reusable components.</li> <li>Use Prop Drilling and Context: Pass data and callbacks down the component tree via props or use React Context for deeper hierarchies.</li> <li>Follow Naming Conventions: Use clear and consistent naming conventions for your components to improve readability.</li> <li>Modularity: Keep components focused and modular, avoiding unnecessary dependencies between them.</li> </ul> <p>By mastering component composition, you can create a flexible and maintainable React application, leveraging the power of reusable components to build complex UIs efficiently.</p>"},{"location":"frontend/react/example/component-composition/#handling-missing-prop-values-in-react-components","title":"Handling Missing Prop Values in React Components","text":"<p>To handle cases where the props might not contain values, you can use default values, conditional rendering, and prop type validation. Here's how you can address these scenarios:</p> 1. Using Default Props <p>You can set default props to provide default values for your component's props. This way, if a prop is not provided, the component will use the default value.</p> jsx<pre><code>// UserInfo.js\nimport PropTypes from 'prop-types';\n\nconst UserInfo = ({ name, email }) =&gt; (\n    &lt;div&gt;\n        &lt;h2&gt;{name}&lt;/h2&gt;\n        &lt;p&gt;{email}&lt;/p&gt;\n    &lt;/div&gt;\n);\n\nUserInfo.defaultProps = {\n    name: 'Unknown User',\n    email: 'No email provided',\n};\n\nUserInfo.propTypes = {\n    name: PropTypes.string,\n    email: PropTypes.string,\n};\n\nexport default UserInfo;\n</code></pre> 2. Conditional Rendering <p>You can also use conditional rendering to handle cases where the props might not contain values.</p> <pre><code>// UserInfo.js\nimport PropTypes from 'prop-types';\n\nconst UserInfo = ({ name, email }) =&gt; (\n    &lt;div&gt;\n        &lt;h2&gt;{name ? name : 'Unknown User'}&lt;/h2&gt;\n        &lt;p&gt;{email ? email : 'No email provided'}&lt;/p&gt;\n    &lt;/div&gt;\n);\n\nUserInfo.propTypes = {\n    name: PropTypes.string,\n    email: PropTypes.string,\n};\n\nexport default UserInfo;\n</code></pre> 3. Combining Default Props and Conditional Rendering <p>Combining both approaches can provide a robust solution for handling missing prop values.</p> <pre><code>// UserInfo.js\nimport PropTypes from 'prop-types';\n\nconst UserInfo = ({ name, email }) =&gt; (\n    &lt;div&gt;\n        &lt;h2&gt;{name}&lt;/h2&gt;\n        &lt;p&gt;{email}&lt;/p&gt;\n    &lt;/div&gt;\n);\n\nUserInfo.defaultProps = {\n    name: 'Unknown User',\n    email: 'No email provided',\n};\n\nUserInfo.propTypes = {\n    name: PropTypes.string,\n    email: PropTypes.string,\n};\n\nexport default UserInfo;\n</code></pre> 4. Using Nullish Coalescing Operator (Optional) <p>For modern JavaScript, you can use the nullish coalescing operator (??) to provide fallback values.</p> <pre><code>// UserInfo.js\nimport PropTypes from 'prop-types';\n\nconst UserInfo = ({ name, email }) =&gt; (\n    &lt;div&gt;\n        &lt;h2&gt;{name ?? 'Unknown User'}&lt;/h2&gt;\n        &lt;p&gt;{email ?? 'No email provided'}&lt;/p&gt;\n    &lt;/div&gt;\n);\n\nUserInfo.propTypes = {\n    name: PropTypes.string,\n    email: PropTypes.string,\n};\n\nexport default UserInfo;\n</code></pre>"},{"location":"frontend/react/example/component-composition/#example-usage-in-userprofile-component","title":"Example Usage in UserProfile Component","text":"<p>Here's how you might use the <code>UserInfo</code> component in the UserProfile component with potential missing values.</p> <pre><code>// UserProfile.js\nimport Avatar from './Avatar';\nimport UserInfo from './UserInfo';\nimport UserPosts from './UserPosts';\n\nconst UserProfile = ({ user, posts }) =&gt; (\n  &lt;div&gt;\n    &lt;Avatar url={user?.avatarUrl ?? 'default-avatar.jpg'} /&gt;\n    &lt;UserInfo name={user?.name} email={user?.email} /&gt;\n    &lt;UserPosts posts={posts} /&gt;\n  &lt;/div&gt;\n);\n\nexport default UserProfile;\n</code></pre>"},{"location":"frontend/react/example/component-composition/#example-usage-in-app-component","title":"Example Usage in App Component","text":"<pre><code>// App.js\nimport UserProfile from './UserProfile';\n\nconst user = {\n  name: 'John Doe',\n  email: 'john.doe@example.com',\n  avatarUrl: 'https://example.com/avatar.jpg',\n};\n\nconst posts = [\n  { id: 1, title: 'First Post' },\n  { id: 2, title: 'Second Post' },\n];\n\nconst App = () =&gt; (\n  &lt;div&gt;\n    &lt;UserProfile user={user} posts={posts} /&gt;\n    {/* UserProfile with missing values */}\n    &lt;UserProfile user={{}} posts={posts} /&gt;\n  &lt;/div&gt;\n);\n\nexport default App;\n</code></pre> <p>By using these techniques, you can ensure that your components handle missing prop values gracefully, improving the robustness and user experience of your application.</p>"},{"location":"frontend/react/example/hoc/","title":"High Order Component","text":"<p>High-order components (HOCs) in React are a pattern where a function takes a component and returns a new component with enhanced functionality. Here are examples categorized into basic, intermediate, and advanced HOCs:</p> <p>Use HOCs to add common functionality to components.</p> simple example <p>Use HOCs to add common functionality to components.</p> <p>For example, you might have an HOC to handle form submission logic.</p> jsx<pre><code>// withFormSubmission.js\nconst withFormSubmission = (WrappedComponent) =&gt; {\nreturn (props) =&gt; {\n    const handleSubmit = (values) =&gt; {\n    // handle form submission logic here\n    console.log('Form submitted:', values);\n    };\n\n    return &lt;WrappedComponent {...props} onSubmit={handleSubmit} /&gt;;\n};\n};\n\nexport default withFormSubmission;\n\n// EnhancedUserForm.js\nimport withFormSubmission from './withFormSubmission';\nimport UserForm from './UserForm';\n\nconst EnhancedUserForm = withFormSubmission(UserForm);\n\nexport default EnhancedUserForm;\n</code></pre> Abstract <p>Why High-Order Component Naming Starts with \"with\"</p> <p>The convention of naming higher-order components (HOCs) with a prefix \"with\" comes from the idea of enhancing or augmenting the base component with additional functionality. This naming convention makes it clear that the HOC is wrapping and modifying the behavior or appearance of the original component.</p> <p>For example:</p> <ul> <li>withLogging indicates that the wrapped component will have logging functionality added.</li> <li>withAuthentication indicates that the wrapped component will have authentication checking added.</li> <li>withDataFetching indicates that the wrapped component will have data fetching capabilities added.</li> </ul> <p>Using \"with\" helps developers quickly understand that the function is not just a regular function but an HOC that will provide additional capabilities to the component it wraps.</p> <p>When to Use HOCs</p> <p>HOCs are useful in a variety of scenarios where you want to reuse component logic or behavior across multiple components without repeating code. Here are some common use cases for HOCs:</p> <ol> <li> <p>Cross-Cutting Concerns:</p> <ul> <li>Logging: Adding logging functionality to monitor the props being passed to the component.</li> <li>Error Handling: Wrapping a component in an error boundary to catch JavaScript errors anywhere in their child component tree.</li> </ul> </li> <li> <p>Code Reuse:</p> <ul> <li>Data Fetching: Encapsulating data fetching logic and reusing it across multiple components.</li> <li>Form Handling: Managing form state and submission logic that can be reused in different forms.</li> </ul> </li> <li> <p>Conditional Rendering:</p> <ul> <li>Authorization: Restricting access to certain components based on user roles or permissions.</li> <li>Feature Flags: Conditionally rendering components based on feature flags or configuration.</li> </ul> </li> <li> <p>Enhancing Components:</p> <ul> <li>Styling: Adding or modifying styles dynamically based on props or state.</li> <li>Animation: Adding animation logic to components.</li> </ul> </li> <li> <p>State Management:</p> <ul> <li>Global State: Connecting components to a global state management system (e.g., Redux).</li> </ul> </li> </ol>"},{"location":"frontend/react/example/hoc/#basic-hocs","title":"Basic HOCs","text":""},{"location":"frontend/react/example/hoc/#1-logging-props","title":"1. Logging Props","text":"Asbtract ExampleUsage javascript<pre><code>const withLogging = (WrappedComponent) =&gt; {\n    return (props) =&gt; {\n        console.log(props);\n        return &lt;WrappedComponent {...props} /&gt;;\n    };\n};\n\n// or\n\nconst withLogging = (WrappedComponent) =&gt; (props) =&gt; {\n    console.log(props);\n    return &lt;WrappedComponent {...props} /&gt;;\n};\n</code></pre> javascript<pre><code>const withLogging = (WrappedComponent) =&gt; (props) =&gt; {\n    console.log(props);\n    return &lt;WrappedComponent {...props} /&gt;;\n};\n\nconst SimpleComponent = (props) =&gt; &lt;div&gt;{props.message}&lt;/div&gt;;\n\nconst LoggedSimpleComponent = withLogging(SimpleComponent);\n\n// Usage\n&lt;LoggedSimpleComponent message=\"Hello, World!\" /&gt;;\n</code></pre>"},{"location":"frontend/react/example/hoc/#2-default-props","title":"2. Default Props","text":"Asbtract ExampleUsage javascript<pre><code>const withDefaultProps = (defaultProps) =&gt; (WrappedComponent) =&gt; {\n    return (props) =&gt; {\n        return &lt;WrappedComponent {...defaultProps} {...props} /&gt;;\n    };\n};\n\n// or\n\nconst withDefaultProps = (defaultProps) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    return &lt;WrappedComponent {...defaultProps} {...props} /&gt;;\n};\n</code></pre> javascript<pre><code>const withDefaultProps = (defaultProps) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    return &lt;WrappedComponent {...defaultProps} {...props} /&gt;;\n};\n\nconst SimpleComponent = (props) =&gt; &lt;div&gt;{props.message}&lt;/div&gt;;\n\nconst DefaultPropsComponent = withDefaultProps({ message: \"Default Message\" })(SimpleComponent);\n\n// Usage\n&lt;DefaultPropsComponent /&gt;; // Renders \"Default Message\"\n&lt;DefaultPropsComponent message=\"Custom Message\" /&gt;; // Renders \"Custom Message\"\n</code></pre>"},{"location":"frontend/react/example/hoc/#3-conditional-rendering","title":"3. Conditional Rendering","text":"Asbtract ExampleUsage javascript<pre><code>const withConditionalRendering = (conditionFn) =&gt; (WrappedComponent) =&gt; {\n    return (props) =&gt; {\n        if (conditionFn(props)) {\n            return &lt;WrappedComponent {...props} /&gt;;\n        } else {\n            return null;\n        }\n    };\n};\n\n// or\n\nconst withConditionalRendering = (conditionFn) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    return conditionFn(props) ? &lt;WrappedComponent {...props} /&gt; : null;\n};\n</code></pre> javascript<pre><code>const withConditionalRendering = (conditionFn) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    return conditionFn(props) ? &lt;WrappedComponent {...props} /&gt; : null;\n};\n\nconst SimpleComponent = (props) =&gt; &lt;div&gt;{props.message}&lt;/div&gt;;\n\nconst ConditionalComponent = withConditionalRendering((props) =&gt; props.show)(SimpleComponent);\n\n// Usage\n&lt;ConditionalComponent show={true} message=\"Visible Message\" /&gt;; // Renders \"Visible Message\"\n&lt;ConditionalComponent show={false} message=\"Invisible Message\" /&gt;; // Renders null\n</code></pre>"},{"location":"frontend/react/example/hoc/#4-adding-class-name","title":"4. Adding Class Name","text":"Asbtract ExampleUsage javascript<pre><code>const withClassName = (className) =&gt; (WrappedComponent) =&gt; {\n    return (props) =&gt; {\n        return &lt;WrappedComponent {...props} className={className} /&gt;;\n    };\n};\n\n// or\n\nconst withClassName = (className) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    return &lt;WrappedComponent {...props} className={className} /&gt;;\n};\n</code></pre> javascript<pre><code>const withClassName = (className) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    return &lt;WrappedComponent {...props} className={className} /&gt;;\n};\n\nconst SimpleComponent = (props) =&gt; &lt;div className={props.className}&gt;{props.message}&lt;/div&gt;;\n\nconst ClassNameComponent = withClassName(\"custom-class\")(SimpleComponent);\n\n// Usage\n&lt;ClassNameComponent message=\"Styled Message\" /&gt;;\n</code></pre>"},{"location":"frontend/react/example/hoc/#5-simple-error-boundary","title":"5. Simple Error Boundary","text":"Note Functional ComponentClass ComponentUsage javascript<pre><code>const withErrorBoundary = (WrappedComponent) =&gt; (props) =&gt; {\n    const [hasError, setHasError] = React.useState(false);\n\n    try {\n        return &lt;WrappedComponent {...props} /&gt;;\n    } catch (error) {\n        setHasError(true);\n        console.error(error);\n        return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;\n    }\n};\n</code></pre> javascript<pre><code>const withErrorBoundary = (WrappedComponent) =&gt; {\n    return class extends React.Component {\n        state = { hasError: false };\n\n        static getDerivedStateFromError() {\n            return { hasError: true };\n        }\n\n        componentDidCatch(error, errorInfo) {\n        console.error(error, errorInfo);\n        }\n\n        render() {\n            if (this.state.hasError) {\n                return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;\n            }\n            return &lt;WrappedComponent {...this.props} /&gt;;\n        }\n    };\n};\n</code></pre> <pre><code>const withErrorBoundary = (WrappedComponent) =&gt; (props) =&gt; {\nconst [hasError, setHasError] = React.useState(false);\n\n    try {\n        return &lt;WrappedComponent {...props} /&gt;;\n    } catch (error) {\n        setHasError(true);\n        console.error(error);\n        return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;\n    }\n};\n\nconst SimpleComponent = (props) =&gt; {\n    if (props.throwError) {\n        throw new Error(\"Error triggered\");\n    }\n    return &lt;div&gt;{props.message}&lt;/div&gt;;\n};\n\nconst ErrorBoundaryComponent = withErrorBoundary(SimpleComponent);\n\n// Usage\n&lt;ErrorBoundaryComponent throwError={true} message=\"This will throw an error\" /&gt;; // Renders error message\n&lt;ErrorBoundaryComponent throwError={false} message=\"No error\" /&gt;; // Renders \"No error\"\n</code></pre>"},{"location":"frontend/react/example/hoc/#intermediate-hocs","title":"Intermediate HOCs","text":""},{"location":"frontend/react/example/hoc/#1-data-fetching","title":"1. Data Fetching","text":"Success Functional ComponentClass ComponentUsage javascript<pre><code>const withDataFetching = (url) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    const [data, setData] = React.useState(null);\n    const [loading, setLoading] = React.useState(true);\n\n    React.useEffect(() =&gt; {\n        fetch(url)\n        .then((response) =&gt; response.json())\n        .then((data) =&gt; {\n            setData(data);\n            setLoading(false);\n        });\n    }, [url]);\n\n    return &lt;WrappedComponent {...props} data={data} loading={loading} /&gt;;\n};\n</code></pre> javascript<pre><code>const withDataFetching = (url) =&gt; (WrappedComponent) =&gt; {\n    return class extends React.Component {\n        state = { data: null, loading: true };\n\n        componentDidMount() {\n        fetch(url)\n            .then((response) =&gt; response.json())\n            .then((data) =&gt; this.setState({ data, loading: false }));\n        }\n\n        render() {\n        return &lt;WrappedComponent {...this.props} {...this.state} /&gt;;\n        }\n    };\n};\n</code></pre> <pre><code>const withDataFetching = (url) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    const [data, setData] = React.useState(null);\n    const [loading, setLoading] = React.useState(true);\n\n    React.useEffect(() =&gt; {\n        fetch(url)\n        .then((response) =&gt; response.json())\n        .then((data) =&gt; {\n            setData(data);\n            setLoading(false);\n        });\n    }, [url]);\n\n    return &lt;WrappedComponent {...props} data={data} loading={loading} /&gt;;\n};\n\nconst DataComponent = ({ data, loading }) =&gt; {\n    if (loading) {\n        return &lt;div&gt;Loading...&lt;/div&gt;;\n    }\n    return &lt;div&gt;Data: {JSON.stringify(data)}&lt;/div&gt;;\n};\n\nconst FetchedDataComponent = withDataFetching(\"https://api.example.com/data\")(DataComponent);\n\n// Usage\n&lt;FetchedDataComponent /&gt;;\n</code></pre>"},{"location":"frontend/react/example/hoc/#2-authentication-check","title":"2. Authentication Check","text":"Success Functional ComponentClass ComponentUsage javascript<pre><code>const withAuthentication = (WrappedComponent) =&gt; (props) =&gt; {\n    if (!props.isAuthenticated) {\n        return &lt;div&gt;Please log in&lt;/div&gt;;\n    }\n    return &lt;WrappedComponent {...props} /&gt;;\n};\n</code></pre> javascript<pre><code>const withAuthentication = (WrappedComponent) =&gt; {\n    return class extends React.Component {\n        render() {\n        if (!this.props.isAuthenticated) {\n            return &lt;div&gt;Please log in&lt;/div&gt;;\n        }\n        return &lt;WrappedComponent {...this.props} /&gt;;\n        }\n    };\n};\n</code></pre> <pre><code>const withAuthentication = (WrappedComponent) =&gt; (props) =&gt; {\n    if (!props.isAuthenticated) {\n        return &lt;div&gt;Please log in&lt;/div&gt;;\n    }\n    return &lt;WrappedComponent {...props} /&gt;;\n};\n\nconst AuthenticatedComponent = (props) =&gt; &lt;div&gt;Authenticated Content&lt;/div&gt;;\n\nconst AuthCheckComponent = withAuthentication(AuthenticatedComponent);\n\n// Usage\n&lt;AuthCheckComponent isAuthenticated={true} /&gt;; // Renders \"Authenticated Content\"\n&lt;AuthCheckComponent isAuthenticated={false} /&gt;; // Renders \"Please log in\"\n</code></pre>"},{"location":"frontend/react/example/hoc/#3-form-handling","title":"3. Form Handling","text":"Success Functional ComponentClass ComponentUsage javascript<pre><code>const withFormHandling = (WrappedComponent) =&gt; (props) =&gt; {\n    const [formData, setFormData] = React.useState({});\n\n    const handleChange = (event) =&gt; {\n        const { name, value } = event.target;\n        setFormData({ ...formData, [name]: value });\n    };\n\n    const handleSubmit = (event) =&gt; {\n        event.preventDefault();\n        // handle form submission\n    };\n\n    return (\n        &lt;WrappedComponent\n        {...props}\n        formData={formData}\n        handleChange={handleChange}\n        handleSubmit={handleSubmit}\n        /&gt;\n    );\n};\n</code></pre> javascript<pre><code>const withFormHandling = (WrappedComponent) =&gt; {\n    return class extends React.Component {\n        state = { formData: {} };\n\n        handleChange = (event) =&gt; {\n        const { name, value } = event.target;\n        this.setState({ formData: { ...this.state.formData, [name]: value } });\n        };\n\n        handleSubmit = (event) =&gt; {\n        event.preventDefault();\n        // handle form submission\n        };\n\n        render() {\n        return (\n            &lt;WrappedComponent\n            {...this.props}\n            formData={this.state.formData}\n            handleChange={this.handleChange}\n            handleSubmit={this.handleSubmit}\n            /&gt;\n        );\n        }\n    };\n};\n</code></pre> <pre><code>const withFormHandling = (WrappedComponent) =&gt; (props) =&gt; {\nconst [formData, setFormData] = React.useState({});\n\nconst handleChange = (event) =&gt; {\n    const { name, value } = event.target;\n    setFormData({ ...formData, [name]: value });\n};\n\nconst handleSubmit = (event) =&gt; {\n    event.preventDefault();\n    console.log(\"Form submitted with data:\", formData);\n};\n\nreturn (\n    &lt;WrappedComponent\n    {...props}\n    formData={formData}\n    handleChange={handleChange}\n    handleSubmit={handleSubmit}\n    /&gt;\n);\n};\n\nconst FormComponent = ({ formData, handleChange, handleSubmit }) =&gt; (\n&lt;form onSubmit={handleSubmit}&gt;\n    &lt;input name=\"name\" value={formData.name || ''} onChange={handleChange} /&gt;\n    &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n&lt;/form&gt;\n);\n\nconst HandledFormComponent = withFormHandling(FormComponent);\n\n// Usage\n&lt;HandledFormComponent /&gt;;\n</code></pre>"},{"location":"frontend/react/example/hoc/#4-authorization-check","title":"4. Authorization Check","text":"Success Functional ComponentClass ComponentUsage javascript<pre><code>const withAuthorization = (allowedRoles) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    if (!allowedRoles.includes(props.role)) {\n        return &lt;div&gt;Access Denied&lt;/div&gt;;\n    }\n    return &lt;WrappedComponent {...props} /&gt;;\n};\n</code></pre> javascript<pre><code>const withAuthorization = (allowedRoles) =&gt; (WrappedComponent) =&gt; {\n    return class extends React.Component {\n        render() {\n        if (!allowedRoles.includes(this.props.role)) {\n            return &lt;div&gt;Access Denied&lt;/div&gt;;\n        }\n        return &lt;WrappedComponent {...this.props} /&gt;;\n        }\n    };\n};\n</code></pre> <pre><code>const withAuthorization = (allowedRoles) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    if (!allowedRoles.includes(props.role)) {\n        return &lt;div&gt;Access Denied&lt;/div&gt;;\n    }\n    return &lt;WrappedComponent {...props} /&gt;;\n};\n\nconst AuthorizedComponent = (props) =&gt; &lt;div&gt;Authorized Content&lt;/div&gt;;\n\nconst RoleCheckComponent = withAuthorization(['admin'])(AuthorizedComponent);\n\n// Usage\n&lt;RoleCheckComponent role=\"admin\" /&gt;; // Renders \"Authorized Content\"\n&lt;RoleCheckComponent role=\"user\" /&gt;; // Renders \"Access Denied\"\n</code></pre>"},{"location":"frontend/react/example/hoc/#5-redux-connect-hoc","title":"5. Redux Connect HOC","text":"Success ExampleUsage javascript<pre><code>import { connect } from 'react-redux';\n\nconst withReduxConnect = (mapStateToProps, mapDispatchToProps) =&gt; (WrappedComponent) =&gt; {\n    return connect(mapStateToProps, mapDispatchToProps)(WrappedComponent);\n};\n</code></pre> <pre><code>import { connect } from 'react-redux';\n\nconst withReduxConnect = (mapStateToProps, mapDispatchToProps) =&gt; (WrappedComponent) =&gt; {\n    return connect(mapStateToProps, mapDispatchToProps)(WrappedComponent);\n};\n\nconst SimpleComponent = ({ message }) =&gt; &lt;div&gt;{message}&lt;/div&gt;;\n\nconst mapStateToProps = (state) =&gt; ({\n    message: state.message,\n});\n\nconst mapDispatchToProps = (dispatch) =&gt; ({\n    updateMessage: (msg) =&gt; dispatch({ type: 'UPDATE_MESSAGE', payload: msg }),\n});\n\nconst ReduxConnectedComponent = withReduxConnect(mapStateToProps, mapDispatchToProps)(SimpleComponent);\n\n// Usage\n&lt;ReduxConnectedComponent /&gt;;\n</code></pre>"},{"location":"frontend/react/example/hoc/#advanced-hocs","title":"Advanced HOCs","text":""},{"location":"frontend/react/example/hoc/#1-dynamic-module-loader","title":"1. Dynamic Module Loader","text":"Example Functional ComponentClass ComponentUsage javascript<pre><code>const withDynamicModule = (importModule) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    const [Module, setModule] = React.useState(null);\n\n    React.useEffect(() =&gt; {\n        importModule().then((mod) =&gt; setModule(mod.default));\n    }, [importModule]);\n\n    return Module ? &lt;Module {...props} /&gt; : &lt;div&gt;Loading...&lt;/div&gt;;\n};\n</code></pre> javascript<pre><code>const withDynamicModule = (importModule) =&gt; (WrappedComponent) =&gt; {\n    return class extends React.Component {\n        state = { Module: null };\n\n        componentDidMount() {\n        importModule().then((mod) =&gt; this.setState({ Module: mod.default }));\n        }\n\n        render() {\n        const { Module } = this.state;\n        return Module ? &lt;Module {...this.props} /&gt; : &lt;div&gt;Loading...&lt;/div&gt;;\n        }\n    };\n};\n</code></pre> javascript<pre><code>const withDynamicModule = (importModule) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    const [Module, setModule] = React.useState(null);\n\n    React.useEffect(() =&gt; {\n        importModule().then((mod) =&gt; setModule(mod.default));\n    }, [importModule]);\n\n    return Module ? &lt;Module {...props} /&gt; : &lt;div&gt;Loading...&lt;/div&gt;;\n};\n\nconst DynamicComponent = (props) =&gt; &lt;div&gt;{props.dynamicContent}&lt;/div&gt;;\n\nconst DynamicLoadedComponent = withDynamicModule(() =&gt; import('./DynamicComponent'))(DynamicComponent);\n\n// Usage\n&lt;DynamicLoadedComponent dynamicContent=\"This is dynamically loaded\" /&gt;;\n</code></pre>"},{"location":"frontend/react/example/hoc/#2-performance-optimization-with-memoization","title":"2. Performance Optimization with Memoization","text":"Example Functional ComponentClass ComponentUsage javascript<pre><code>const withMemoization = (WrappedComponent) =&gt; React.memo(WrappedComponent, (prevProps, nextProps) =&gt; {\n    // Add custom comparison logic here\n    return prevProps === nextProps;\n});\n</code></pre> javascript<pre><code>const withMemoization = (WrappedComponent) =&gt; {\n    return React.memo(WrappedComponent, (prevProps, nextProps) =&gt; {\n        // Add custom comparison logic here\n        return prevProps === nextProps;\n    });\n};\n</code></pre> javascript<pre><code>const withMemoization = (WrappedComponent) =&gt; React.memo(WrappedComponent, (prevProps, nextProps) =&gt; {\n    return prevProps === nextProps;\n});\n\nconst MemoizedComponent = ({ message }) =&gt; &lt;div&gt;{message}&lt;/div&gt;;\n\nconst OptimizedComponent = withMemoization(MemoizedComponent);\n\n// Usage\n&lt;OptimizedComponent message=\"Memoized Content\" /&gt;;\n</code></pre>"},{"location":"frontend/react/example/hoc/#3-internationalization-i18n","title":"3. Internationalization (i18n)","text":"Example Functional ComponentClass ComponentUsage javascript<pre><code>import { useTranslation } from 'react-i18next';\n\nconst withI18n = (WrappedComponent) =&gt; (props) =&gt; {\n    const { t, i18n } = useTranslation();\n    return &lt;WrappedComponent {...props} t={t} i18n={i18n} /&gt;;\n};\n</code></pre> javascript<pre><code>import { withTranslation } from 'react-i18next';\n\nconst withI18n = (WrappedComponent) =&gt; {\n    return withTranslation()(WrappedComponent);\n};\n</code></pre> javascript<pre><code>import { useTranslation } from 'react-i18next';\n\nconst withI18n = (WrappedComponent) =&gt; (props) =&gt; {\n    const { t, i18n } = useTranslation();\n    return &lt;WrappedComponent {...props} t={t} i18n={i18n} /&gt;;\n};\n\nconst TranslatedComponent = ({ t }) =&gt; &lt;div&gt;{t('welcome_message')}&lt;/div&gt;;\n\nconst I18nComponent = withI18n(TranslatedComponent);\n\n// Usage\n&lt;I18nComponent /&gt;;\n</code></pre>"},{"location":"frontend/react/example/hoc/#4-analytics-tracking","title":"4. Analytics Tracking","text":"Example Functional ComponentClass ComponentUsage javascript<pre><code>const withAnalytics = (eventName) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    React.useEffect(() =&gt; {\n        // Simulate sending event to analytics service\n        console.log(`Event: ${eventName}`);\n    }, [eventName]);\n\n    return &lt;WrappedComponent {...props} /&gt;;\n};\n</code></pre> javascript<pre><code>const withAnalytics = (eventName) =&gt; (WrappedComponent) =&gt; {\n    return class extends React.Component {\n        componentDidMount() {\n            // Simulate sending event to analytics service\n            console.log(`Event: ${eventName}`);\n        }\n\n        render() {\n            return &lt;WrappedComponent {...this.props} /&gt;;\n        }\n    };\n};\n</code></pre> javascript<pre><code>const withAnalytics = (eventName) =&gt; (WrappedComponent) =&gt; (props) =&gt; {\n    React.useEffect(() =&gt; {\n        console.log(`Event: ${eventName}`);\n    }, [eventName]);\n\n    return &lt;WrappedComponent {...props} /&gt;;\n};\n\nconst AnalyticsComponent = (props) =&gt; &lt;div&gt;{props.content}&lt;/div&gt;;\n\nconst TrackedComponent = withAnalytics('ComponentLoaded')(AnalyticsComponent);\n\n// Usage\n&lt;TrackedComponent content=\"Analytics Tracked Content\" /&gt;;\n</code></pre>"},{"location":"frontend/react/example/hoc/#5-drag-and-drop","title":"5. Drag and Drop","text":"Example Functional ComponentClass ComponentUsage javascript<pre><code>import { useDrag, useDrop } from 'react-dnd';\n\nconst withDragAndDrop = (WrappedComponent) =&gt; (props) =&gt; {\n    const [, drag] = useDrag({\n        type: 'ITEM',\n        item: { id: props.id },\n    });\n\n    const [, drop] = useDrop({\n        accept: 'ITEM',\n        drop: (item) =&gt; props.onDrop(item.id, props.id),\n    });\n\n    return (\n        &lt;div ref={(node) =&gt; drag(drop(node))}&gt;\n            &lt;WrappedComponent {...props} /&gt;\n        &lt;/div&gt;\n    );\n};\n</code></pre> javascript<pre><code>import { DragSource, DropTarget } from 'react-dnd';\n\nconst withDragAndDrop = (WrappedComponent) =&gt; {\n    const dragSpec = {\n        beginDrag: (props) =&gt; ({ id: props.id })\n    };\n\n    const dropSpec = {\n        drop: (props, monitor) =&gt; {\n            const item = monitor.getItem();\n            props.onDrop(item.id, props.id);\n        }\n    };\n\n    const collectDrag = (connect) =&gt; ({\n        connectDragSource: connect.dragSource()\n    });\n\n    const collectDrop = (connect) =&gt; ({\n        connectDropTarget: connect.dropTarget()\n    });\n\n    const DraggableComponent = DragSource('ITEM', dragSpec, collectDrag)(WrappedComponent);\n    return DropTarget('ITEM', dropSpec, collectDrop)(DraggableComponent);\n};\n</code></pre> javascript<pre><code>import { useDrag, useDrop } from 'react-dnd';\n\nconst withDragAndDrop = (WrappedComponent) =&gt; (props) =&gt; {\n    const [, drag] = useDrag({\n        type: 'ITEM',\n        item: { id: props.id },\n    });\n\n    const [, drop] = useDrop({\n        accept: 'ITEM',\n        drop: (item) =&gt; props.onDrop(item.id, props.id),\n    });\n\n    return (\n        &lt;div ref={(node) =&gt; drag(drop(node))}&gt;\n        &lt;WrappedComponent {...props} /&gt;\n        &lt;/div&gt;\n    );\n};\n\nconst DraggableComponent = ({ content }) =&gt; &lt;div&gt;{content}&lt;/div&gt;;\n\nconst DragDropComponent = withDragAndDrop(DraggableComponent);\n\n// Usage\n&lt;DragDropComponent id=\"1\" content=\"Drag me\" onDrop={(sourceId, targetId) =&gt; console.log(`Dropped ${sourceId} on ${targetId}`)} /&gt;;\n</code></pre> <p>These examples should cover a wide range of scenarios and illustrate how HOCs can be used to enhance and reuse component functionality at different levels of complexity.</p>"},{"location":"frontend/react/example/hoc/#folder-structure-of-hocs","title":"Folder Structure of HOCs","text":"<p>The folder structure for Higher-Order Components (HOCs) in a React project can vary depending on the complexity and size of your project. However, a common and organized way to structure your folders and files can look like this:</p>"},{"location":"frontend/react/example/hoc/#1-basic-folder-structure","title":"1. Basic Folder Structure","text":"<p>A simple structure for a small to medium-sized project might look like this:</p> <pre><code>src/\n\u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 SomeComponent/\n\u2502   \u2502   \u251c\u2500\u2500 SomeComponent.js\n\u2502   \u2502   \u251c\u2500\u2500 SomeComponent.css\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 hocs/\n\u2502   \u251c\u2500\u2500 withAuth.js\n\u2502   \u2514\u2500\u2500 withLogging.js\n\u251c\u2500\u2500 App.js\n\u251c\u2500\u2500 index.js\n\u2514\u2500\u2500 ...\n</code></pre>"},{"location":"frontend/react/example/hoc/#2-advanced-folder-structure","title":"2. Advanced Folder Structure","text":"<p>For larger projects, it might make sense to have a more detailed structure:</p> <pre><code>src/\n\u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 SomeComponent/\n\u2502   \u2502   \u251c\u2500\u2500 SomeComponent.js\n\u2502   \u2502   \u251c\u2500\u2500 SomeComponent.css\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 AnotherComponent/\n\u2502       \u251c\u2500\u2500 AnotherComponent.js\n\u2502       \u251c\u2500\u2500 AnotherComponent.css\n\u2502       \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 hocs/\n\u2502   \u251c\u2500\u2500 withAuth/\n\u2502   \u2502   \u251c\u2500\u2500 withAuth.js\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u251c\u2500\u2500 withLogging/\n\u2502   \u2502   \u251c\u2500\u2500 withLogging.js\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 withAnotherFeature/\n\u2502       \u251c\u2500\u2500 withAnotherFeature.js\n\u2502       \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 utils/\n\u2502   \u251c\u2500\u2500 helper1.js\n\u2502   \u2514\u2500\u2500 helper2.js\n\u251c\u2500\u2500 hooks/\n\u2502   \u251c\u2500\u2500 useCustomHook.js\n\u2502   \u2514\u2500\u2500 useAnotherHook.js\n\u251c\u2500\u2500 App.js\n\u251c\u2500\u2500 index.js\n\u2514\u2500\u2500 ...\n</code></pre>"},{"location":"frontend/react/example/hoc/#explanation-of-each-folder","title":"Explanation of Each Folder:","text":"<ol> <li> <p>components/:</p> <ul> <li>Contains all your React components.</li> <li>Each component has its own folder which may contain its JavaScript file, CSS file, and an <code>index.js</code> for easier imports.</li> </ul> </li> <li> <p>hocs/:</p> <ul> <li>Contains all your Higher-Order Components.</li> <li>Each HOC can have its own folder if it consists of multiple files or just a single file if it's simple.</li> <li>Each HOC folder typically has an <code>index.js</code> file for easier imports.</li> </ul> </li> <li> <p>utils/:</p> <ul> <li>Contains utility functions that can be reused throughout your project.</li> </ul> </li> <li> <p>hooks/:</p> <ul> <li>Contains custom React hooks.</li> </ul> </li> </ol>"},{"location":"frontend/react/example/hoc/#hocs","title":"HOCs","text":"<p>Higher-Order Components (HOCs) are a pattern in React for reusing component logic. They are functions that take a component and return a new component with added functionality. HOCs are particularly useful in various scenarios, and they are commonly used for the following purposes:</p>"},{"location":"frontend/react/example/hoc/#scenarios-for-using-hocs","title":"Scenarios for Using HOCs","text":"<ol> <li> <p>Code Reuse, Logic, and Bootstrap Abstraction:</p> <ul> <li>HOCs allow you to reuse code across multiple components. This is particularly useful for logic that needs to be shared, such as fetching data, managing state, or subscribing to events.</li> </ul> </li> <li> <p>Manipulating Props:</p> <ul> <li>HOCs can manipulate the props passed to a component. This can include adding new props, modifying existing ones, or filtering out unnecessary props.</li> </ul> </li> <li> <p>Conditional Rendering:</p> <ul> <li>HOCs can be used to conditionally render components based on certain criteria, such as user authentication, feature flags, or permission levels.</li> </ul> </li> <li> <p>State Management:</p> <ul> <li>They can manage state and pass it down as props to the wrapped component. This is useful for scenarios where state management logic needs to be shared across multiple components.</li> </ul> </li> <li> <p>Handling Side Effects:</p> <ul> <li>HOCs can handle side effects like data fetching, subscriptions, or logging. This is useful for abstracting side effects out of the component, keeping them clean and focused on rendering UI.</li> </ul> </li> </ol>"},{"location":"frontend/react/example/hoc/#common-uses-of-hocs","title":"Common Uses of HOCs","text":"<ol> <li> <p>Authentication:</p> <ul> <li>Wrapping components to ensure that only authenticated users can access certain parts of an application.</li> <li>Example: <code>withAuth(Component)</code></li> </ul> </li> <li> <p>Logging:</p> <ul> <li>Adding logging functionality to components for debugging or analytics.</li> <li>Example: <code>withLogging(Component)</code></li> </ul> </li> <li> <p>Data Fetching:</p> <ul> <li>Fetching data from an API and passing it as props to the wrapped component.</li> <li>Example: <code>withDataFetching(Component, apiEndpoint)</code></li> </ul> </li> <li> <p>Theming:</p> <ul> <li>Providing theme-related props to components.</li> <li>Example: <code>withTheme(Component)</code></li> </ul> </li> <li> <p>Error Handling:</p> <ul> <li>Wrapping components with error boundaries to catch and handle errors in a standardized way.</li> <li>Example: <code>withErrorBoundary(Component)</code></li> </ul> </li> <li> <p>Access Control:</p> <ul> <li>Enforcing role-based access control by conditionally rendering components based on user roles.</li> <li>Example: <code>withRole(Component, allowedRoles)</code></li> </ul> </li> <li> <p>Form Handling:</p> <ul> <li>Managing form state and validation logic.</li> <li>Example: <code>withFormHandling(Component)</code></li> </ul> </li> </ol>"},{"location":"frontend/react/example/lifting-state-up/","title":"Lifting State Up","text":""},{"location":"frontend/react/example/lifting-state-up/#theory-of-lifting-state-up-in-react","title":"Theory of Lifting State Up in React","text":"<p>Lifting state up is a pattern in React where you move state from <code>child components</code> to a common <code>parent component</code>. This pattern is necessary for managing state that needs to be shared among multiple child components. By lifting the state up to a common ancestor, you create a single source of truth, ensuring that all child components that need the state have access to the same data.</p>"},{"location":"frontend/react/example/lifting-state-up/#why-is-it-necessary","title":"Why Is It Necessary?","text":"<p>When multiple components need to share and synchronize state, managing the state within each component individually can lead to inconsistencies and complexity. Lifting the state up solves these issues by:</p> <ul> <li>Ensuring Consistency: By having a single source of truth for the state, you avoid the risk of components having out-of-sync data.</li> <li>Simplifying State Management: It becomes easier to manage and update the state from one place, reducing the complexity of your application.</li> <li>Avoiding Prop Drilling: While lifting state up does require passing state down as props, it helps avoid deeper and more convoluted prop drilling in larger component trees.</li> </ul>"},{"location":"frontend/react/example/lifting-state-up/#how-does-it-solve-the-problem","title":"How Does It Solve the Problem?","text":"<p>Problem: </p> <p>Imagine two sibling components need to share and synchronize some state. If each component maintains its own state, it becomes challenging to keep them in sync.</p> <p>Solution: </p> <p>Lift the state up to their common parent, and pass the state and state-updating functions down to the child components via props. This way, the parent component manages the state, and the child components simply use the state and functions passed to them.</p>"},{"location":"frontend/react/example/lifting-state-up/#example","title":"Example","text":"<p>Let's consider a more detailed example:</p> Tip Without Lifting State UpWith Lifting State Up <p>We have two sibling components: TemperatureInput for Celsius and Fahrenheit. Each component maintains its own state.</p> <pre><code>function TemperatureInputCelsius() {\n    const [celsius, setCelsius] = useState('');\n\n    const handleChange = (e) =&gt; {\n        setCelsius(e.target.value);\n    };\n\n    return &lt;input type=\"text\" value={celsius} onChange={handleChange} /&gt;;\n}\n\nfunction TemperatureInputFahrenheit() {\n    const [fahrenheit, setFahrenheit] = useState('');\n\n    const handleChange = (e) =&gt; {\n        setFahrenheit(e.target.value);\n    };\n\n    return &lt;input type=\"text\" value={fahrenheit} onChange={handleChange} /&gt;;\n}\n\nfunction App() {\n    return (\n        &lt;div&gt;\n        &lt;TemperatureInputCelsius /&gt;\n        &lt;TemperatureInputFahrenheit /&gt;\n        &lt;/div&gt;\n    );\n}\n</code></pre> <p>In this setup, the components have their own state and do not share data. Converting between Celsius and Fahrenheit requires extra logic in each component and makes it hard to keep them in sync.</p> <p>Lift the state up to the App component and pass the necessary state and handlers down to the child components.</p> <pre><code>function TemperatureInput({ scale, temperature, handleChange }) {\n    return (\n        &lt;fieldset&gt;\n        &lt;legend&gt;Enter temperature in {scale}:&lt;/legend&gt;\n        &lt;input value={temperature} onChange={handleChange} /&gt;\n        &lt;/fieldset&gt;\n    );\n}\n\n// main function\nfunction App() {\n    const [temperature, setTemperature] = useState('');\n    const [scale, setScale] = useState('c');\n\n    const handleCelsiusChange = (e) =&gt; {\n        setScale('c');\n        setTemperature(e.target.value);\n    };\n\n    const handleFahrenheitChange = (e) =&gt; {\n        setScale('f');\n        setTemperature(e.target.value);\n    };\n\n    const celsius = scale === 'f' ? tryConvert(temperature, toCelsius) : temperature;\n    const fahrenheit = scale === 'c' ? tryConvert(temperature, toFahrenheit) : temperature;\n\n    return (\n        &lt;div&gt;\n        &lt;TemperatureInput\n            scale=\"Celsius\"\n            temperature={celsius}\n            handleChange={handleCelsiusChange}\n        /&gt;\n        &lt;TemperatureInput\n            scale=\"Fahrenheit\"\n            temperature={fahrenheit}\n            handleChange={handleFahrenheitChange}\n        /&gt;\n        &lt;/div&gt;\n    );\n}\n\nfunction toCelsius(fahrenheit) {\n    return ((fahrenheit - 32) * 5) / 9;\n}\n\nfunction toFahrenheit(celsius) {\n    return (celsius * 9) / 5 + 32;\n}\n\nfunction tryConvert(temperature, convert) {\n    const input = parseFloat(temperature);\n    if (Number.isNaN(input)) {\n        return '';\n    }\n    const output = convert(input);\n    const rounded = Math.round(output * 1000) / 1000;\n    return rounded.toString();\n}\n</code></pre> <p>In this example, the <code>App</code> component maintains the state for the temperature and the scale. The <code>TemperatureInput</code> components are now stateless and receive the necessary state and handlers as props. The conversion functions ensure that both input fields stay in sync.</p>"},{"location":"frontend/react/example/lifting-state-up/#summary","title":"Summary","text":"<ul> <li>Lifting state up means moving the state to the closest common ancestor of components that need to share the state.</li> <li>It ensures consistency, simplifies state management, and avoids deep prop drilling.</li> <li>By lifting state up, you centralize the state management, making your application more predictable and easier to maintain.</li> </ul> <p>This approach is essential for managing shared state in React applications, particularly as they grow in complexity.</p>"},{"location":"frontend/react/example/passing-props/","title":"Passing Props","text":""},{"location":"frontend/react/example/passing-props/#passing-props","title":"passing props","text":"<p>Yes, you can pass state and functions to other components in React, and this is a common practice. The standard approach typically involves the following methods:</p>"},{"location":"frontend/react/example/passing-props/#1-props","title":"1. Props","text":"<p>Passing state and functions through props is the most straightforward method. This is done by passing them from a parent component to its child components.</p> <pre><code>function ParentComponent() {\n  const [state, setState] = useState(initialState);\n\n  const handleAction = () =&gt; {\n    // function logic\n  };\n\n  return (\n    &lt;ChildComponent state={state} handleAction={handleAction} /&gt;\n  );\n}\n\nfunction ChildComponent({ state, handleAction }) {\n  return (\n    &lt;div&gt;\n      &lt;p&gt;{state}&lt;/p&gt;\n      &lt;button onClick={handleAction}&gt;Do Something&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"frontend/react/example/passing-props/#2-context","title":"2. Context","text":"<p>For passing state and functions down the component tree without prop drilling (passing through many intermediary components), React's Context API can be used.</p> <pre><code>const MyContext = React.createContext();\n\nfunction ParentComponent() {\n  const [state, setState] = useState(initialState);\n\n  const handleAction = () =&gt; {\n    // function logic\n  };\n\n  return (\n    &lt;MyContext.Provider value={{ state, handleAction }}&gt;\n      &lt;ChildComponent /&gt;\n    &lt;/MyContext.Provider&gt;\n  );\n}\n\nfunction ChildComponent() {\n  const { state, handleAction } = React.useContext(MyContext);\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;{state}&lt;/p&gt;\n      &lt;button onClick={handleAction}&gt;Do Something&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"frontend/react/example/passing-props/#3-custom-hooks","title":"3. Custom Hooks","text":"<p>For reusable logic that involves state and functions, you can create custom hooks.</p> <pre><code>function useCustomHook() {\n  const [state, setState] = useState(initialState);\n\n  const handleAction = () =&gt; {\n    // function logic\n  };\n\n  return { state, handleAction };\n}\n\nfunction Component() {\n  const { state, handleAction } = useCustomHook();\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;{state}&lt;/p&gt;\n      &lt;button onClick={handleAction}&gt;Do Something&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"frontend/react/example/passing-props/#standard-practices","title":"Standard Practices:","text":""},{"location":"frontend/react/example/passing-props/#lift-state-up","title":"Lift State Up:","text":"<p>Keep the state in the closest common ancestor of the components that need access to the state. This helps in avoiding unnecessary re-renders and makes the state management simpler.</p>"},{"location":"frontend/react/example/passing-props/#prop-drilling","title":"Prop Drilling:","text":"<p>If prop drilling (passing props through multiple levels of components) becomes cumbersome, consider using Context API or state management libraries like Redux.</p>"},{"location":"frontend/react/example/passing-props/#descriptive-props","title":"Descriptive Props:","text":"<p>When passing functions and state as props, use descriptive names to make the code more readable and maintainable.</p>"},{"location":"frontend/react/example/passing-props/#minimize-context-use","title":"Minimize Context Use:","text":"<p>Use context sparingly to avoid performance issues related to unnecessary re-renders. For global state management, consider state management libraries.</p> <p>By following these methods and practices, you can effectively manage and pass state and functions between components in your React application.</p>"},{"location":"frontend/react/example/passing-props/#naming-conventions-for-passing-props","title":"Naming Conventions for Passing Props","text":"Tip <ol> <li> <p>Descriptive Names:</p> <ul> <li>Use clear, descriptive names that convey the purpose of the prop.</li> <li>For state values, use the noun form.</li> <li>For functions (handlers), use the verb form, often prefixed with on or handle.</li> </ul> </li> <li> <p>State Props:</p> <ul> <li>Use the exact name of the state variable.</li> <li>Example: If the state variable is <code>user</code>, pass it as <code>user</code>.</li> </ul> </li> <li> <p>Function Props:</p> <ul> <li>Prefix functions with on if they are event handlers.</li> <li>Prefix with handle if they are general purpose functions.</li> <li>Example: onClick, onChange, handleSubmit.</li> </ul> </li> <li> <p>Boolean Props:</p> <ul> <li>Use prefixes like is, has, should, etc., to indicate boolean nature.</li> <li>Example: isOpen, hasError.</li> </ul> </li> </ol>"},{"location":"frontend/react/example/passing-props/#examples","title":"Examples","text":"<p>Here are examples demonstrating these conventions:</p> Basic Example Parent Component:Child Component: jsx<pre><code>function ParentComponent() {\n    const [count, setCount] = useState(0);\n\n    const incrementCount = () =&gt; {\n        setCount(count + 1);\n    };\n\n    return (\n        &lt;ChildComponent count={count} onIncrement={incrementCount} /&gt;\n    );\n}\n</code></pre> jsx<pre><code>function ChildComponent({ count, onIncrement }) {\n    return (\n        &lt;div&gt;\n            &lt;p&gt;Count: {count}&lt;/p&gt;\n            &lt;button onClick={onIncrement}&gt;Increment&lt;/button&gt;\n        &lt;/div&gt;\n    );\n}\n</code></pre> Advanced Example with Multiple Props Parent Component:Child Component: jsx<pre><code>function ParentComponent() {\n    const [username, setUsername] = useState('');\n    const [email, setEmail] = useState('');\n\n    const handleUsernameChange = (e) =&gt; {\n        setUsername(e.target.value);\n    };\n\n    const handleEmailChange = (e) =&gt; {\n        setEmail(e.target.value);\n    };\n\n    return (\n        &lt;FormComponent\n            username={username}\n            email={email}\n            onUsernameChange={handleUsernameChange}\n            onEmailChange={handleEmailChange}\n        /&gt;\n    );\n}\n</code></pre> jsx<pre><code>function FormComponent({ username, email, onUsernameChange, onEmailChange }) {\n    return (\n        &lt;form&gt;\n            &lt;div&gt;\n                &lt;label&gt;Username:&lt;/label&gt;\n                &lt;input type=\"text\" value={username} onChange={onUsernameChange} /&gt;\n            &lt;/div&gt;\n            &lt;div&gt;\n                &lt;label&gt;Email:&lt;/label&gt;\n                &lt;input type=\"email\" value={email} onChange={onEmailChange} /&gt;\n            &lt;/div&gt;\n        &lt;/form&gt;\n    );\n}\n</code></pre>"},{"location":"frontend/react/example/passing-props/#summary-of-naming-conventions","title":"Summary of Naming Conventions","text":"<ul> <li>State Values: Use the exact name of the state variable (e.g., <code>count</code>, <code>username</code>).</li> <li>Function Props: Prefix with on for <code>event handlers</code> and handle for <code>general functions</code> (e.g., <code>onClick</code>, <code>handleSubmit</code>).</li> <li>Boolean Props: Use prefixes like is, has, should to indicate their nature (e.g., <code>isOpen</code>, <code>hasError</code>).</li> </ul> <p>Following these conventions makes your code more predictable, readable, and easier to maintain, especially when working in teams or on large projects.</p>"},{"location":"frontend/react/example/presentational-and-container/","title":"Presentation & Container","text":""},{"location":"frontend/react/example/presentational-and-container/#presentational-components","title":"Presentational Components:","text":"<p>These components focus on how things look. They receive data and callbacks exclusively via props and rarely have their own state.</p>"},{"location":"frontend/react/example/presentational-and-container/#container-components","title":"Container Components:","text":"<p>These components focus on how things work. They manage state and handle logic, passing data and callbacks down to presentational components.</p>"},{"location":"frontend/react/example/presentational-and-container/#example","title":"Example","text":"jsx<pre><code>// UserForm.js (Presentational Component)\nimport { Form, Input, Button } from 'antd';\n\nconst UserForm = ({ form, onSubmit }) =&gt; (\n  &lt;Form form={form} layout=\"vertical\" onFinish={onSubmit}&gt;\n    &lt;Form.Item name=\"name\" label=\"Name\" rules={[{ required: true }]}&gt;\n      &lt;Input /&gt;\n    &lt;/Form.Item&gt;\n    &lt;Form.Item name=\"email\" label=\"Email\" rules={[{ required: true, type: 'email' }]}&gt;\n      &lt;Input /&gt;\n    &lt;/Form.Item&gt;\n    &lt;Button type=\"primary\" htmlType=\"submit\"&gt;Submit&lt;/Button&gt;\n  &lt;/Form&gt;\n);\n\nexport default UserForm;\n\n// UserFormContainer.js (Container Component)\nimport React from 'react';\nimport { Form, message } from 'antd';\nimport UserForm from './UserForm';\n\nconst UserFormContainer = () =&gt; {\n  const [form] = Form.useForm();\n\n  const handleSubmit = (values) =&gt; {\n    message.success('Form submitted: ' + JSON.stringify(values));\n    // handle form submission logic here\n  };\n\n  return &lt;UserForm form={form} onSubmit={handleSubmit} /&gt;;\n};\n\nexport default UserFormContainer;\n</code></pre>"},{"location":"frontend/react/example/prop-drilling/","title":"Props Drilling","text":"<p>Prop drilling is a pattern in React where you pass data and functions from a parent component through multiple levels of intermediate components down to a deeply nested child component. This can become cumbersome and make the component tree harder to manage, especially as the application grows.</p>"},{"location":"frontend/react/example/prop-drilling/#what-is-prop-drilling","title":"What is Prop Drilling?","text":"<p>Prop drilling occurs when you need to pass data or callbacks through many layers of components, even if those intermediate components don\u2019t need to use the data themselves. It can lead to:</p> <ul> <li>Complex Component Trees: Passing props through many layers can make components less reusable and harder to maintain.</li> <li>Unnecessary Re-renders: Intermediate components may re-render unnecessarily if the props change.</li> <li>Increased Boilerplate: You may need to add boilerplate code for passing props through each component layer.</li> </ul>"},{"location":"frontend/react/example/prop-drilling/#example","title":"Example","text":"Parent Component: <pre><code>const Parent = () =&gt; {\n    const [data, setData] = useState('Hello');\n\n    return &lt;Intermediate data={data} /&gt;;\n};\n</code></pre> Intermediate Component: <pre><code>const Intermediate = ({ data }) =&gt; {\n    return &lt;DeepChild data={data} /&gt;;\n};\n</code></pre> Deep Child Component: <pre><code>const DeepChild = ({ data }) =&gt; {\n    return &lt;div&gt;{data}&lt;/div&gt;;\n};\n</code></pre> <p>In this example, <code>data</code> is drilled down from <code>Parent</code> through <code>Intermediate</code> to <code>DeepChild</code>.</p>"},{"location":"frontend/react/example/prop-drilling/#how-to-avoid-prop-drilling","title":"How to Avoid Prop Drilling","text":"<p>There are several strategies to avoid prop drilling, making your component tree cleaner and more maintainable:</p>"},{"location":"frontend/react/example/prop-drilling/#1-react-context-api","title":"1. React Context API:","text":"<p>React Context allows you to share values and functions across the component tree without passing props explicitly through every level.</p> jsx<pre><code>// Create a Context\nconst DataContext = createContext();\n\n// Provider Component\nconst DataProvider = ({ children }) =&gt; {\n  const [data, setData] = useState('Hello');\n\n  return (\n    &lt;DataContext.Provider value={{ data, setData }}&gt;\n      {children}\n    &lt;/DataContext.Provider&gt;\n  );\n};\n\n// Deep Component\nconst DeepChild = () =&gt; {\n  const { data } = useContext(DataContext);\n  return &lt;div&gt;{data}&lt;/div&gt;;\n};\n\n// Usage\nconst App = () =&gt; (\n  &lt;DataProvider&gt;\n    &lt;DeepChild /&gt;\n  &lt;/DataProvider&gt;\n);\n\nexport default App;\n</code></pre>"},{"location":"frontend/react/example/prop-drilling/#2-custom-hooks","title":"2. Custom Hooks:","text":"<p>Use custom hooks to encapsulate and share logic across components.</p> <pre><code>// useData.js\nimport { useState } from 'react';\n\nexport const useData = () =&gt; {\n  const [data, setData] = useState('Hello');\n  return { data, setData };\n};\n\n// Deep Component\nconst DeepChild = () =&gt; {\n  const { data } = useData();\n  return &lt;div&gt;{data}&lt;/div&gt;;\n};\n\n// Usage\nconst App = () =&gt; (\n  &lt;div&gt;\n    &lt;DeepChild /&gt;\n  &lt;/div&gt;\n);\n\nexport default App;\n</code></pre>"},{"location":"frontend/react/example/prop-drilling/#3-state-management-libraries","title":"3. State Management Libraries:","text":"<p>Use state management libraries like Redux, Zustand, or Recoil to manage and access state globally.</p> Redux<pre><code>// actions.js\nexport const setData = (data) =&gt; ({\n  type: 'SET_DATA',\n  payload: data,\n});\n\n// reducer.js\nconst initialState = { data: 'Hello' };\n\nexport const dataReducer = (state = initialState, action) =&gt; {\n  switch (action.type) {\n    case 'SET_DATA':\n      return { ...state, data: action.payload };\n    default:\n      return state;\n  }\n};\n\n// Deep Component\nimport { useSelector } from 'react-redux';\n\nconst DeepChild = () =&gt; {\n  const data = useSelector((state) =&gt; state.data);\n  return &lt;div&gt;{data}&lt;/div&gt;;\n};\n\n// Usage\nimport { Provider } from 'react-redux';\nimport { createStore } from 'redux';\nimport { dataReducer } from './reducer';\n\nconst store = createStore(dataReducer);\n\nconst App = () =&gt; (\n  &lt;Provider store={store}&gt;\n    &lt;DeepChild /&gt;\n  &lt;/Provider&gt;\n);\n\nexport default App;\n</code></pre>"},{"location":"frontend/react/example/prop-drilling/#4-composition","title":"4. Composition:","text":"<p>Sometimes, restructuring components to use composition rather than hierarchical prop drilling can simplify the design.</p> <pre><code>// DataProvider Component\nconst DataProvider = ({ children }) =&gt; {\n  const [data, setData] = useState('Hello');\n  return React.cloneElement(children, { data, setData });\n};\n\n// Deep Component\nconst DeepChild = ({ data }) =&gt; {\n  return &lt;div&gt;{data}&lt;/div&gt;;\n};\n\n// Usage\nconst App = () =&gt; (\n  &lt;DataProvider&gt;\n    &lt;DeepChild /&gt;\n  &lt;/DataProvider&gt;\n);\n\nexport default App;\n</code></pre>"},{"location":"frontend/react/example/prop-drilling/#summary","title":"Summary","text":"<p>While prop drilling is a common pattern in React, it can be managed more effectively by leveraging Context API, custom hooks, state management libraries, and component composition. These strategies help maintain a clean and manageable component tree, avoiding the pitfalls of deep prop drilling.</p>"},{"location":"frontend/react/example/render-props/","title":"Render Props","text":"<p>Render props is a pattern for sharing code between React components using a prop whose value is a function.</p> Example jsx<pre><code>// FormContainer.js\nconst FormContainer = ({ children }) =&gt; {\n    const [form] = Form.useForm();\n\n    const handleSubmit = (values) =&gt; {\n        console.log('Form submitted:', values);\n    };\n\n    return children({ form, handleSubmit });\n};\n\n// UserForm.js\nconst UserForm = ({ form, handleSubmit }) =&gt; (\n    &lt;Form form={form} layout=\"vertical\" onFinish={handleSubmit}&gt;\n        &lt;Form.Item name=\"name\" label=\"Name\" rules={[{ required: true }]}&gt;\n            &lt;Input /&gt;\n        &lt;/Form.Item&gt;\n        &lt;Form.Item name=\"email\" label=\"Email\" rules={[{ required: true, type: 'email' }]}&gt;\n            &lt;Input /&gt;\n        &lt;/Form.Item&gt;\n        &lt;Button type=\"primary\" htmlType=\"submit\"&gt;Submit&lt;/Button&gt;\n    &lt;/Form&gt;\n);\n\n// Usage in a component\n&lt;FormContainer&gt;\n    {({ form, handleSubmit }) =&gt; (\n        &lt;UserForm form={form} handleSubmit={handleSubmit} /&gt;\n    )}\n&lt;/FormContainer&gt;\n</code></pre> <p>Render props is a pattern in React that allows sharing code between components using a prop whose value is a function. It\u2019s commonly used to provide data and behavior to a component in a way that is flexible and reusable. While \"render props\" is the most widely recognized term, there are a few other names and related concepts that describe similar patterns:</p>"},{"location":"frontend/react/example/render-props/#other-names-and-related-concepts","title":"Other Names and Related Concepts","text":""},{"location":"frontend/react/example/render-props/#1-function-as-child-component-facc","title":"1. Function as Child Component (FaCC):","text":"<p>This term describes a pattern where a function is used as a child of a component. It\u2019s conceptually similar to render props, but with the function passed as a child rather than a prop.</p> Example<pre><code>const UserProfile = ({ children }) =&gt; {\nconst user = { name: 'John Doe', email: 'john.doe@example.com' };\nreturn children(user);\n};\n\nconst App = () =&gt; (\n&lt;UserProfile&gt;\n    {user =&gt; (\n    &lt;div&gt;\n        &lt;h1&gt;{user.name}&lt;/h1&gt;\n        &lt;p&gt;{user.email}&lt;/p&gt;\n    &lt;/div&gt;\n    )}\n&lt;/UserProfile&gt;\n);\n</code></pre>"},{"location":"frontend/react/example/render-props/#2-controlled-components","title":"2. Controlled Components:","text":"<p>Controlled components use props to control their behavior and render output. While this term is often associated with form elements, it can also apply to the render props pattern where a component is controlled via functions.</p>"},{"location":"frontend/react/example/render-props/#3-function-render-pattern","title":"3. Function Render Pattern:","text":"<p>This term is used interchangeably with render props to describe the pattern of using a function to determine what should be rendered.</p>"},{"location":"frontend/react/example/render-props/#4-function-as-children-pattern","title":"4. Function-as-Children Pattern:","text":"<p>Similar to function as child components, this pattern involves passing a function as a child to render UI based on some state or logic.</p> <pre><code>const DataProvider = ({ children }) =&gt; {\n  const data = ['Item 1', 'Item 2', 'Item 3'];\n  return children(data);\n};\n\nconst App = () =&gt; (\n  &lt;DataProvider&gt;\n    {data =&gt; (\n      &lt;ul&gt;\n        {data.map((item, index) =&gt; (\n          &lt;li key={index}&gt;{item}&lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n    )}\n  &lt;/DataProvider&gt;\n);\n</code></pre>"},{"location":"frontend/react/example/render-props/#5-render-function-pattern","title":"5. Render Function Pattern:","text":"<p>This term emphasizes the use of a function to handle the rendering logic within a component. It is another way to refer to the render props pattern.</p>"},{"location":"frontend/react/example/render-props/#summary","title":"Summary","text":"<p>The render props pattern is known by various names and is conceptually related to several other patterns that involve passing functions to control rendering and behavior. These patterns provide flexibility and reusability in React component design.</p>"},{"location":"frontend/react/fake-api/intro/","title":"Intro","text":"<p>Faking an API in a React application is useful for testing and development purposes. Here are a few common methods:</p>"},{"location":"frontend/react/fake-api/intro/#1-using-mock-service-workers-msw","title":"1. Using Mock Service Workers (MSW)","text":"<p>MSW is a powerful library for mocking API requests. It intercepts requests at the network level and returns mock responses. This is especially useful for integration testing and development.</p> Setup MSW: <ol> <li> <p>Install the library:</p> <pre><code>npm install msw --save-dev\n</code></pre> </li> <li> <p>Create a mock handler file (<code>mocks/handlers.js</code>):</p> <pre><code>import { rest } from 'msw';\n\nexport const handlers = [\n    rest.get('/api/your-endpoint', (req, res, ctx) =&gt; {\n        return res(ctx.json({ message: 'This is a mock response' }));\n    }),\n    // Add more handlers for different endpoints and methods\n];\n</code></pre> </li> <li> <p>Setup the mock server in your application (<code>mocks/browser.js</code>):</p> <pre><code>import { setupWorker } from 'msw';\nimport { handlers } from './handlers';\n\nconst worker = setupWorker(...handlers);\n\nworker.start();\n</code></pre> </li> <li> <p>Include the mock server setup in your application entry point (<code>index.js</code> or <code>App.js</code>):</p> <pre><code>import './mocks/browser';\n</code></pre> </li> </ol>"},{"location":"frontend/react/fake-api/intro/#2-using-json-server","title":"2. Using json-server","text":"<p>json-server is a simple tool to create a fake REST API using a JSON file.</p> <pre><code>your-project/\n\u251c\u2500\u2500 public/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 layouts/\n\u2502   \u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 utils/\n\u2502   \u251c\u2500\u2500 views/\n\u2502   \u251c\u2500\u2500 App.js\n\u2502   \u251c\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 ... (other source files)\n\u251c\u2500\u2500 db/\n\u2502   \u251c\u2500\u2500 db.json\n\u2502   \u2514\u2500\u2500 start-mock-api.js\n\u251c\u2500\u2500 node_modules/\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 webpack.config.js\n\u2514\u2500\u2500 ... (other configuration files)\n</code></pre> db.jsonstart-mock-api.jspackage.json <pre><code>{\n    \"posts\": [\n        { \"id\": 1, \"title\": \"Hello World\" },\n        { \"id\": 2, \"title\": \"json-server is awesome\" }\n    ],\n    \"comments\": [\n        { \"id\": 1, \"body\": \"some comment\", \"postId\": 1 }\n    ],\n    \"profile\": { \"name\": \"typicode\" }\n}\n</code></pre> <pre><code>const jsonServer = require('json-server');\nconst path = require('path');\nconst server = jsonServer.create();\nconst router = jsonServer.router(path.join(__dirname, 'db.json'));\nconst middlewares = jsonServer.defaults();\n\nserver.use(middlewares);\nserver.use(router);\n\nconst PORT = 5000;\nserver.listen(PORT, () =&gt; {\n    console.log(`JSON Server is running on port ${PORT}`);\n});\n</code></pre> <pre><code>\"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"dockerbuild\": \"react-scripts --openssl-legacy-provider build\",\n    \"mac-start-run\": \"react-scripts --openssl-legacy-provider start\",\n    \"test\": \"react-scripts test\",\n    \"eject\": \"react-scripts eject\",\n    \"product\": \"set PORT=4200 &amp;&amp; react-scripts start\",\n    \"start:mock-api\": \"node db/start-mock-api.js\",\n    \"start:all\": \"concurrently \\\"npm run product\\\" \\\"npm run start:mock-api\\\"\"\n}\n</code></pre> Setup json-server: <ol> <li> <p>Install <code>json-server</code>:</p> <pre><code>npm install json-server --save-dev\n\n//or\n\nnpm install json-server@0.16.3 --save-dev\n</code></pre> </li> <li> <p>Create a <code>db.json</code> file with your mock data:</p> <pre><code>{\n    \"posts\": [\n        { \"id\": 1, \"title\": \"Hello World\" }\n    ]\n}\n</code></pre> </li> <li> <p>Add a script to your <code>package.json</code> to start the server:</p> <pre><code>\"scripts\": {\n    \"start:mock-api\": \"json-server --watch db.json --port 5000\"\n}\n</code></pre> </li> <li> <p>Run the mock API server:</p> <pre><code>npm run start:mock-api\n</code></pre> </li> </ol> <p>You can now make requests to <code>http://localhost:5000/posts</code>.</p> <p>Start Both Servers:</p> <p>Use <code>concurrently</code> to start both the React app and the mock API server.</p> <pre><code>npm run start:all\n</code></pre>"},{"location":"frontend/react/fake-api/intro/#3-using-a-simple-mock-with-axios-or-fetch","title":"3. Using a Simple Mock with Axios or Fetch","text":"<p>You can create a simple mock directly in your React application by intercepting API calls with Axios or Fetch.</p> Example using Axios: <ol> <li> <p>Install Axios:</p> <pre><code>npm install axios\n</code></pre> </li> <li> <p>Create a mock API file (<code>apiMock.js</code>):</p> <pre><code>import axios from 'axios';\n\nconst mockResponse = {\n    data: { message: 'This is a mock response' },\n};\n\naxios.interceptors.request.use(request =&gt; {\n    if (request.url === '/api/your-endpoint') {\n        return Promise.resolve(mockResponse);\n    }\n    return request;\n});\n</code></pre> </li> <li> <p>Import and use the mock API file in your application (<code>App.js</code>):</p> <pre><code>import './apiMock';\n</code></pre> </li> </ol> <p>Now, when your app makes requests to <code>/api/your-endpoint</code>, it will receive the mock response.</p> <p>These methods allow you to simulate API responses and test how your React application handles different scenarios without needing a real backend.</p>"},{"location":"frontend/react/fake-api/intro/#among-the-methods-mentioned","title":"Among the methods mentioned:","text":"<ol> <li> <p>Mock Service Workers (MSW) is the most popular and widely used method for mocking APIs in modern React applications. It provides a comprehensive and flexible solution for intercepting network requests and mocking responses. MSW is especially popular in testing environments due to its ability to handle various HTTP methods and work with both REST and GraphQL APIs. It integrates well with testing libraries like Jest and React Testing Library.</p> </li> <li> <p>json-server is also popular, particularly for creating a quick and simple REST API with a JSON file. It is commonly used for local development and prototyping. While it\u2019s less flexible compared to MSW in terms of handling different types of requests and responses, it's still a useful tool for generating mock data and endpoints quickly.</p> </li> <li> <p>Using a Simple Mock with Axios or Fetch is less common compared to the other methods but can be useful for very basic scenarios or when you need a quick solution without setting up additional libraries. It\u2019s typically used for simpler use cases or when integrating mocks directly into the application code is sufficient.</p> </li> </ol> <p>For most React applications, MSW is the go-to choice due to its robust features and flexibility in handling various mocking scenarios.</p>"},{"location":"frontend/react/fake-api/json-server/","title":"Use Mocking Libraries","text":""},{"location":"frontend/react/fake-api/json-server/#2-use-mocking-libraries-eg-json-server-miragejs","title":"2. Use Mocking Libraries (e.g., <code>json-server</code>, <code>MirageJS</code>):","text":"<ul> <li><code>json-server</code>: A full fake REST API server that you can run locally.</li> </ul> <pre><code>npm install json-server\n</code></pre> Steps: <ol> <li> <p>Install json-server:</p> <pre><code>npm install -g json-server\n</code></pre> </li> <li> <p>Create a <code>db.json</code> file with some mock data:</p> json<pre><code>{\n    \"users\": [\n        { \"id\": 1, \"name\": \"John Doe\" },\n        { \"id\": 2, \"name\": \"Jane Smith\" }\n    ]\n}\n</code></pre> </li> <li> <p>Run the server:</p> <pre><code>json-server --watch db.json --port 5000\n</code></pre> </li> <li> <p>Now, you can access your API at <code>http://localhost:5000/users</code>.</p> </li> </ol> Example in Vue/React/Angular: <pre><code>fetch(\"http://localhost:5000/users\")\n.then((response) =&gt; response.json())\n.then((data) =&gt; console.log(data));\n</code></pre>"},{"location":"frontend/react/fake-api/json-server/#example","title":"Example","text":"Abstract 1. Basic Example2. Intermediate Example3. Advanced Example <p>This example will create a simple REST API using json-server to serve basic user data.</p> Steps: <ol> <li> <p>Install <code>json-server</code> globally (if not already installed):</p> <pre><code>npm install -g json-server\n</code></pre> </li> <li> <p>Create a <code>db.json</code> file:</p> <pre><code>{\n    \"users\": [\n        { \"id\": 1, \"name\": \"John Doe\", \"email\": \"john@example.com\" },\n        { \"id\": 2, \"name\": \"Jane Smith\", \"email\": \"jane@example.com\" }\n    ]\n}\n</code></pre> </li> <li> <p>Run <code>json-server</code>:</p> <pre><code>json-server --watch db.json --port 5000\n</code></pre> </li> <li> <p>Access the API:</p> <ul> <li><code>GET http://localhost:5000/users</code> will return the list of users.</li> <li><code>GET http://localhost:5000/users/1</code> will return the user with id <code>1</code>.</li> <li><code>POST</code>, <code>PUT</code>, <code>DELETE</code> operations will work automatically for <code>users</code>.</li> </ul> </li> </ol> <p>Result:</p> <ul> <li>Simple API with RESTful routes for basic CRUD operations.</li> </ul> <p>In this example, we\u2019ll add:</p> <ul> <li>Custom Routes for more control over the API.</li> <li>Pagination and Filtering using query parameters.</li> </ul> Steps: <ol> <li> <p>Create an extended <code>db.json</code> file with multiple resources:</p> <pre><code>{\n    \"users\": [\n        { \"id\": 1, \"name\": \"John Doe\", \"email\": \"john@example.com\" },\n        { \"id\": 2, \"name\": \"Jane Smith\", \"email\": \"jane@example.com\" },\n        { \"id\": 3, \"name\": \"Bill Gates\", \"email\": \"bill@microsoft.com\" },\n        { \"id\": 4, \"name\": \"Elon Musk\", \"email\": \"elon@spacex.com\" }\n    ],\n    \"posts\": [\n        { \"id\": 1, \"title\": \"Post 1\", \"content\": \"Lorem Ipsum\", \"userId\": 1 },\n        { \"id\": 2, \"title\": \"Post 2\", \"content\": \"Dolor Sit\", \"userId\": 2 },\n        { \"id\": 3, \"title\": \"Post 3\", \"content\": \"Amet Consectetur\", \"userId\": 1 }\n    ]\n}\n</code></pre> </li> <li> <p>Add a <code>routes.json</code> file to define custom routes:</p> <pre><code>{\n    \"/api/users\": \"/users\",\n    \"/api/posts\": \"/posts\"\n}\n</code></pre> </li> <li> <p>Run <code>json-server</code> with the custom routes:</p> <pre><code>json-server --watch db.json --routes routes.json --port 5000\n</code></pre> </li> <li> <p>API Features:</p> <ul> <li>Pagination: <code>GET http://localhost:5000/users?_page=1&amp;_limit=2</code> will return 2 users per page.</li> <li>Filtering: <code>GET http://localhost:5000/posts?userId=1</code> will return all posts for user with <code>userId=1</code>.</li> <li>Custom Routes: Access users via <code>GET http://localhost:5000/api/users</code>.</li> </ul> </li> </ol> <p>Result:</p> <ul> <li>More control over API routes.</li> <li>Added pagination and filtering for more realistic data operations.</li> </ul> <p>In this example, we\u2019ll demonstrate:</p> <ul> <li>Custom Middlewares for request logging.</li> <li>Delayed Responses to simulate network delays.</li> <li>Advanced Relationships between resources (users and posts).</li> </ul> Steps: <ol> <li> <p>Create a <code>db.json</code> file with more complex relationships:</p> <pre><code>{\n    \"users\": [\n        { \"id\": 1, \"name\": \"John Doe\", \"email\": \"john@example.com\" },\n        { \"id\": 2, \"name\": \"Jane Smith\", \"email\": \"jane@example.com\" }\n    ],\n    \"posts\": [\n        { \"id\": 1, \"title\": \"Post 1\", \"userId\": 1 },\n        { \"id\": 2, \"title\": \"Post 2\", \"userId\": 1 },\n        { \"id\": 3, \"title\": \"Post 3\", \"userId\": 2 }\n    ],\n    \"comments\": [\n        { \"id\": 1, \"body\": \"Nice post!\", \"postId\": 1 },\n        { \"id\": 2, \"body\": \"Thanks for sharing!\", \"postId\": 1 },\n        { \"id\": 3, \"body\": \"Great article\", \"postId\": 2 }\n    ]\n}\n</code></pre> </li> <li> <p>Create a <code>server.js</code> file to customize the server:</p> <pre><code>const jsonServer = require('json-server');\nconst server = jsonServer.create();\nconst router = jsonServer.router('db.json');\nconst middlewares = jsonServer.defaults();\nconst port = 5000;\n\n// Custom middleware to log requests\nserver.use(middlewares);\nserver.use((req, res, next) =&gt; {\n    console.log(`[LOG] Request: ${req.method} ${req.url}`);\n    next();\n});\n\n// Custom route for delayed response\nserver.get('/api/delayed-response', (req, res) =&gt; {\n    setTimeout(() =&gt; {\n        res.status(200).jsonp({ message: \"This response is delayed!\" });\n    }, 3000); // 3-second delay\n});\n\n// Use default router with pagination, filters, etc.\nserver.use(router);\n\n// Start server\nserver.listen(port, () =&gt; {\n    console.log(`JSON Server is running on http://localhost:${port}`);\n});\n</code></pre> </li> <li> <p>Run the custom server:</p> <pre><code>node server.js\n</code></pre> </li> <li> <p>API Features:</p> <ul> <li>Logging Middleware: Logs all incoming requests with their method and URL.</li> <li>Delayed Response: <code>GET http://localhost:5000/api/delayed-response</code> simulates a 3-second delay before responding.</li> <li>Relationships: <code>GET http://localhost:5000/posts?userId=1</code> will fetch posts for a specific user, and you can fetch comments for a post with <code>GET http://localhost:5000/comments?postId=1</code>.</li> </ul> </li> </ol> <p>Result:</p> <ul> <li>Advanced API with custom middlewares, delayed responses, and relationships between entities.</li> <li>You can simulate real-world scenarios with complex data structures.</li> </ul> <p>Summary:</p> <ul> <li>Basic Example: Simple CRUD operations using <code>json-server</code>.</li> <li>Intermediate Example: Added custom routes, pagination, and filtering.</li> <li>Advanced Example: Custom middlewares, delayed responses, and more complex relationships between entities.</li> </ul> <p>These progressively advanced examples help you mock an API for frontend development, simulate realistic scenarios, and add more flexibility to your workflow.</p>"},{"location":"frontend/react/fake-api/json-server/#my-json-server","title":"My JSON Server","text":"How to <ol> <li>Create a repository on GitHub (<code>&lt;your-username&gt;/&lt;your-repo&gt;</code>)</li> <li>Create a <code>db.json</code> file</li> <li>Visit https://my-json-server.typicode.com// to access your server</li> </ol> <p>No registration. Nothing to install.</p> <ul> <li>my-json-server: github</li> </ul>"},{"location":"frontend/react/fake-api/json-server/#reference","title":"Reference","text":"<ul> <li>json server: github</li> <li>my-json-server.typicode.com</li> </ul>"},{"location":"frontend/react/fake-api/msw/","title":"Mock Services with Browser APIs","text":"<p>To fake an API for consumption in your frontend (React, Vue, Angular), you can use different tools and techniques, such as setting up a mock server or using third-party libraries. Here are a few common approaches:</p> 1. Use Mock Services in JavaScript: <p>You can define mock data directly in your frontend project for development and testing.</p> <pre><code>// Sample mock data\nconst mockData = [\n{ id: 1, name: \"John Doe\", age: 30 },\n{ id: 2, name: \"Jane Smith\", age: 25 },\n];\n\n// Mock API call\nexport const fetchMockData = () =&gt; {\nreturn new Promise((resolve) =&gt; {\n    setTimeout(() =&gt; {\n    resolve(mockData);\n    }, 1000); // Simulating network delay\n});\n};\n\n// In your React component\nuseEffect(() =&gt; {\nfetchMockData().then((data) =&gt; {\n    console.log(data); // Handle the data\n});\n}, []);\n</code></pre> 3. Use Axios Interceptors (or Fetch Mocking): <p>You can intercept network requests in your frontend using Axios or Fetch to return fake responses.</p> Axios Example:<pre><code>import axios from 'axios';\n\n// Create a mock Axios instance\nconst mockAxios = axios.create();\n\n// Intercept requests and return mock data\nmockAxios.interceptors.request.use((config) =&gt; {\n    if (config.url === '/api/users') {\n        return Promise.resolve({\n            data: [{ id: 1, name: 'John Doe' }, { id: 2, name: 'Jane Smith' }],\n        });\n    }\n    return config;\n});\n\n// In your component\nuseEffect(() =&gt; {\n    mockAxios.get('/api/users').then((response) =&gt; {\n        console.log(response.data); // Fake data\n    });\n}, []);\n</code></pre>"},{"location":"frontend/react/fake-api/msw/#4-mock-services-with-browser-apis-eg-fetch-mock-msw","title":"4. Mock Services with Browser APIs (e.g., <code>fetch-mock</code>, <code>msw</code>):","text":"<ul> <li><code>fetch-mock</code>: Mock fetch requests.</li> <li>MSW (Mock Service Worker): An API mocking library that works by intercepting requests via Service Workers.</li> </ul> MSW Example: <ol> <li> <p>Install <code>msw</code>:</p> <pre><code>npm install msw --save-dev\n</code></pre> </li> <li> <p>Setup <code>msw</code>:</p> <pre><code>import { setupWorker, rest } from \"msw\";\n\n// Define request handlers\nconst worker = setupWorker(\n    rest.get(\"/api/users\", (req, res, ctx) =&gt; {\n        return res(\n            ctx.json([\n                { id: 1, name: \"John Doe\" },\n                { id: 2, name: \"Jane Smith\" },\n            ])\n        );\n    })\n);\n\n// Start the worker\nworker.start();\n</code></pre> <p>These methods let you easily fake APIs to speed up frontend development without depending on a backend. You can choose the best approach depending on your stack and workflow!</p> </li> </ol>"},{"location":"frontend/react/others/login/react-login/","title":"Login","text":"<p>To implement login authentication in a React application, you typically need to handle user input, send authentication requests to a backend server, manage authentication tokens, and conditionally render components based on the authentication state. Here's a step-by-step guide to achieve this:</p>"},{"location":"frontend/react/others/login/react-login/#install-necessary-packages","title":"Install Necessary Packages","text":"<p>You may need some additional packages for handling HTTP requests and managing authentication state:</p> <pre><code>npm install axios react-router-dom\n</code></pre>"},{"location":"frontend/react/others/login/react-login/#folder-structure","title":"Folder Structure","text":"<p>React authentication</p> <pre><code>my-auth-app/\n\u251c\u2500\u2500 node_modules/\n\u251c\u2500\u2500 public/\n\u2502   \u251c\u2500\u2500 index.html\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 components/\n\u2502   \u2502   \u251c\u2500\u2500 Home.js\n\u2502   \u2502   \u251c\u2500\u2500 Login.js\n\u2502   \u2502   \u2514\u2500\u2500 ProtectedRoute.js\n\u2502   \u251c\u2500\u2500 context/\n\u2502   \u2502   \u2514\u2500\u2500 AuthContext.js\n\u2502   \u251c\u2500\u2500 services/\n\u2502   \u2502   \u2514\u2500\u2500 authService.js\n\u2502   \u251c\u2500\u2500 App.js\n\u2502   \u251c\u2500\u2500 index.css\n\u2502   \u251c\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 package-lock.json\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 ...\n</code></pre> Abstract <ul> <li> <p>components/: Contains the React components used in your application.</p> <ul> <li>Home.js: The protected home component.</li> <li>Login.js: The login form component.</li> <li>ProtectedRoute.js: The component that protects routes requiring authentication.</li> </ul> </li> <li> <p>context/: Contains the context for managing authentication state.</p> <ul> <li>AuthContext.js: The authentication context provider and hooks.</li> </ul> </li> <li> <p>services/: Contains service files for handling API calls and other business logic.</p> <ul> <li>authService.js: Service for handling authentication-related API calls.</li> </ul> </li> <li> <p>App.js: The main application component that sets up routing and provides context.</p> </li> <li> <p>index.js: The entry point for the React application.    </p> </li> <li> <p>index.css: Global styles for the application.</p> </li> </ul>"},{"location":"frontend/react/others/login/react-login/#code","title":"Code","text":"Success src/components/src/context/src/services/src/ Home.jsLogin.jsProtectedRoute.js <pre><code>import React, { useContext } from 'react';\nimport { AuthContext } from '../context/AuthContext';\n\nconst Home = () =&gt; {\n    const { currentUser, logout } = useContext(AuthContext);\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Welcome, {currentUser?.username}&lt;/h1&gt;\n            &lt;button onClick={logout}&gt;Logout&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Home;\n</code></pre> <pre><code>import React, { useState, useContext } from 'react';\nimport { AuthContext } from '../context/AuthContext';\n\nconst Login = () =&gt; {\n    const [username, setUsername] = useState('');\n    const [password, setPassword] = useState('');\n    const { login } = useContext(AuthContext);\n\n    const handleSubmit = async (e) =&gt; {\n        e.preventDefault();\n        try {\n            await login(username, password);\n            // Redirect or perform any action on successful login\n        } catch (error) {\n            console.error('Login failed', error);\n        }\n    };\n\n    return (\n        &lt;form onSubmit={handleSubmit}&gt;\n            &lt;div&gt;\n                &lt;label&gt;Username&lt;/label&gt;\n                &lt;input type=\"text\" value={username} onChange={(e) =&gt; setUsername(e.target.value)} /&gt;\n            &lt;/div&gt;\n            &lt;div&gt;\n                &lt;label&gt;Password&lt;/label&gt;\n                &lt;input type=\"password\" value={password} onChange={(e) =&gt; setPassword(e.target.value)} /&gt;\n            &lt;/div&gt;\n            &lt;button type=\"submit\"&gt;Login&lt;/button&gt;\n        &lt;/form&gt;\n    );\n};\n\nexport default Login;\n</code></pre> <pre><code>import React, { useContext } from 'react';\nimport { Route, Redirect } from 'react-router-dom';\nimport { AuthContext } from '../context/AuthContext';\n\nconst ProtectedRoute = ({ component: Component, ...rest }) =&gt; {\n    const { currentUser } = useContext(AuthContext);\n\n    return (\n        &lt;Route\n            {...rest}\n            render={(props) =&gt;\n                currentUser ? &lt;Component {...props} /&gt; : &lt;Redirect to=\"/login\" /&gt;\n            }\n        /&gt;\n    );\n};\n\nexport default ProtectedRoute;\n</code></pre> AuthContext.js<pre><code>import React, { createContext, useState, useEffect } from 'react';\nimport { getCurrentUser, login, logout } from '../services/authService';\n\nexport const AuthContext = createContext();\n\nexport const AuthProvider = ({ children }) =&gt; {\n    const [currentUser, setCurrentUser] = useState(null);\n\n    useEffect(() =&gt; {\n        const user = getCurrentUser();\n        if (user) {\n            setCurrentUser(user);\n        }\n    }, []);\n\n    const loginHandler = async (username, password) =&gt; {\n        const user = await login(username, password);\n        setCurrentUser(user);\n    };\n\n    const logoutHandler = () =&gt; {\n        logout();\n        setCurrentUser(null);\n    };\n\n    return (\n        &lt;AuthContext.Provider value={{ currentUser, login: loginHandler, logout: logoutHandler }}&gt;\n            {children}\n        &lt;/AuthContext.Provider&gt;\n    );\n};\n</code></pre> authService.js<pre><code>import axios from 'axios';\n\nconst API_URL = 'https://your-api-url.com'; // Replace with your API URL\n\nexport const login = async (username, password) =&gt; {\n    const response = await axios.post(`${API_URL}/auth/login`, { username, password });\n    if (response.data.token) {\n        localStorage.setItem('user', JSON.stringify(response.data));\n    }\n    return response.data;\n};\n\nexport const logout = () =&gt; {\n    localStorage.removeItem('user');\n};\n\nexport const getCurrentUser = () =&gt; {\n    return JSON.parse(localStorage.getItem('user'));\n};\n</code></pre> App.jsindex.js <pre><code>import React from 'react';\nimport { BrowserRouter as Router, Route, Switch } from 'react-router-dom';\nimport { AuthProvider } from './context/AuthContext';\nimport Login from './components/Login';\nimport ProtectedRoute from './components/ProtectedRoute';\nimport Home from './components/Home'; // Your protected home component\n\nconst App = () =&gt; {\n    return (\n        &lt;AuthProvider&gt;\n        &lt;Router&gt;\n            &lt;Switch&gt;\n            &lt;Route path=\"/login\" component={Login} /&gt;\n            &lt;ProtectedRoute path=\"/\" component={Home} /&gt;\n            &lt;/Switch&gt;\n        &lt;/Router&gt;\n        &lt;/AuthProvider&gt;\n    );\n};\n\nexport default App;\n</code></pre> <pre><code>import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n    &lt;React.StrictMode&gt;\n        &lt;App /&gt;\n    &lt;/React.StrictMode&gt;,\n    document.getElementById('root')\n);\n</code></pre> <p>This structure provides a clean and organized way to handle authentication in your React application. You can further expand it with additional features and components as needed.</p>"},{"location":"frontend/react/others/react-without-redux/intro/","title":"Login","text":""},{"location":"frontend/react/others/react-without-redux/intro/#without-state-management","title":"Without State Management","text":"<p>Certainly! Using React with APIs without state management libraries like Redux can be done by leveraging React's built-in state and effect hooks (<code>useState</code> and <code>useEffect</code>). Here's an example of how to structure your folders and code to achieve this.</p>"},{"location":"frontend/react/others/react-without-redux/intro/#folder-structure","title":"Folder Structure","text":"<pre><code>my-app/\n\u251c\u2500\u2500 public/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 api/\n\u2502   \u2502   \u2514\u2500\u2500 fetchData.js\n\u2502   \u251c\u2500\u2500 components/\n\u2502   \u2502   \u251c\u2500\u2500 DataDisplay.jsx\n\u2502   \u2502   \u2514\u2500\u2500 DataItem.jsx\n\u2502   \u251c\u2500\u2500 App.jsx\n\u2502   \u251c\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 styles/\n\u2502       \u2514\u2500\u2500 App.css\n\u2514\u2500\u2500 package.json\n</code></pre> Example fetchData.jscomponentssrc/App.jssrc/index.jssrc/styles/App.css <p>This file contains the API call logic.</p> <pre><code>// src/api/fetchData.js\n\nexport const fetchData = async () =&gt; {\n    try {\n        const response = await fetch('https://api.example.com/data');\n        if (!response.ok) {\n            throw new Error('Network response was not ok');\n        }\n        const data = await response.json();\n        return data;\n    } catch (error) {\n        console.error('Error fetching data:', error);\n        return null;\n    }\n};\n</code></pre> DataItem.jsDataDisplay.js <p>A simple component to display individual data items.</p> <pre><code>// src/components/DataItem.js\n\nimport React from 'react';\n\nconst DataItem = ({ item }) =&gt; {\n    return (\n        &lt;div className=\"data-item\"&gt;\n            &lt;h3&gt;{item.title}&lt;/h3&gt;\n            &lt;p&gt;{item.description}&lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default DataItem;\n</code></pre> <p>A component to fetch and display the data.</p> <pre><code>// src/components/DataDisplay.js\n\nimport React, { useState, useEffect } from 'react';\nimport { fetchData } from '../api/fetchData';\nimport DataItem from './DataItem';\n\nconst DataDisplay = () =&gt; {\n    const [data, setData] = useState([]);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n\n    useEffect(() =&gt; {\n        const getData = async () =&gt; {\n            setLoading(true);\n            const result = await fetchData();\n            if (result) {\n                setData(result);\n            } else {\n                setError('Failed to fetch data');\n            }\n            setLoading(false);\n        };\n\n        getData();\n    }, []);\n\n    if (loading) return &lt;p&gt;Loading...&lt;/p&gt;;\n    if (error) return &lt;p&gt;{error}&lt;/p&gt;;\n\n    return (\n        &lt;div className=\"data-display\"&gt;\n            {data.map(item =&gt; (\n                &lt;DataItem key={item.id} item={item} /&gt;\n            ))}\n        &lt;/div&gt;\n    );\n};\n\nexport default DataDisplay;\n</code></pre> <p>The main app component where DataDisplay is used.</p> <pre><code>import React from 'react';\nimport DataDisplay from './components/DataDisplay';\nimport './styles/App.css';\n\nconst App = () =&gt; {\n    return (\n        &lt;div className=\"app\"&gt;\n            &lt;h1&gt;My Data App&lt;/h1&gt;\n            &lt;DataDisplay /&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default App;\n</code></pre> <p>The entry point of the React application.</p> <pre><code>import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport './styles/App.css';\n\nReactDOM.render(\n    &lt;React.StrictMode&gt;\n        &lt;App /&gt;\n    &lt;/React.StrictMode&gt;,\n    document.getElementById('root')\n);\n</code></pre> <p>Basic styles for the application.</p> <pre><code>.app {\n    text-align: center;\n}\n\n.data-display {\n    display: flex;\n    flex-wrap: wrap;\n    justify-content: center;\n}\n\n.data-item {\n    border: 1px solid #ccc;\n    padding: 16px;\n    margin: 8px;\n    width: 200px;\n    text-align: left;\n}\n</code></pre> <p>Summary</p> <p>This example shows a simple way to structure a React application that fetches data from an API and displays it without using any state management libraries. The <code>fetchData</code> function in the <code>api</code> folder handles the API request. The <code>DataDisplay</code> component uses <code>useState</code> and <code>useEffect</code> hooks to manage and display the data. This approach is sufficient for smaller applications or components with limited state management needs.</p>"},{"location":"frontend/react/package/intro/","title":"Introduction","text":"<p>JavaScript utility libraries commonly used in React development.</p> <ul> <li> <p><code>lodash</code>:</p> <p><code>Lodash</code> is a widely used utility library in the JavaScript ecosystem, and it provides a comprehensive set of functions for working with arrays, objects, strings, and more.</p> <pre><code> // 1. Installation\n npm install lodash\n\n // 2. Importing\n import _ from 'lodash'; // Import the entire library\n // or\n import { map, filter, debounce } from 'lodash'; // Import specific functions\n\n // Example Debounce\n import _ from 'lodash';\n\n const debouncedFunction = _.debounce((value) =&gt; {\n     console.log('Debounced:', value);\n }, 300);\n</code></pre> </li> <li> <p>Underscore.js:</p> <p><code>Underscore.js</code> is similar to Lodash and provides a set of utility functions for working with arrays, objects, functions, and more. It predates Lodash and served as an inspiration for it.</p> </li> <li> <p>axios:</p> <p><code>axios</code> is a promise-based HTTP client that simplifies making HTTP requests. It is commonly used for handling API requests in React applications.</p> </li> <li> <p>React Query:</p> <p><code>React Query</code> is a library for managing, caching, and synchronizing data in React applications. It provides hooks for fetching and updating data with a focus on simplicity and performance.</p> </li> <li> <p>Ramda:</p> <p><code>Ramda</code> is a functional programming library that focuses on immutability and functional composition. It provides functions for functional programming paradigms and is suitable for projects that adopt a more functional style.</p> </li> <li> <p>Immer:</p> <p><code>Immer</code> is a library that simplifies state management by enabling a more convenient way to work with immutable data structures. It is often used in combination with React's state to make state updates more concise.</p> </li> </ul> Useful"},{"location":"frontend/react/package/intro/#useful-react-libraries","title":"Useful React Libraries","text":""},{"location":"frontend/react/package/intro/#1-react-konva","title":"1. React-Konva","text":""},{"location":"frontend/react/package/intro/#2-react-gesture-handler","title":"2. React-Gesture-Handler","text":""},{"location":"frontend/react/package/intro/#3-react-flip-move","title":"3. React-Flip-Move","text":""},{"location":"frontend/react/package/intro/#4-react-virtualized","title":"4. React-Virtualized","text":""},{"location":"frontend/react/package/intro/#5-react-toastify","title":"5. React-Toastify","text":""},{"location":"frontend/react/package/intro/#6-react-page-transition","title":"6. React-Page-Transition","text":""},{"location":"frontend/react/package/intro/#7-react-360","title":"7. React 360","text":"<ul> <li>Javascript Mastery</li> </ul>"},{"location":"frontend/react/package/antd/","title":"Intro","text":""},{"location":"frontend/react/package/antd/#and","title":"and","text":"<pre><code>$ pnpm add antd\n$ pnpm add @ant-design/icons\n</code></pre>"},{"location":"frontend/react/package/antd/antd-form-validator/","title":"Antd Form Validation","text":""},{"location":"frontend/react/package/antd/antd-form-validator/#antd-form-validation","title":"Antd Form Validation","text":"<p><code>Components/modals/quickAddPerson.js</code></p> BasicAdvanced <pre><code>const validateEmail = (_, value) =&gt; {\n    // Basic email validation using a regular expression\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n\n    if (!value || emailRegex.test(value)) {\n        return Promise.resolve();\n    }\n\n    return Promise.reject(\"Invalid email address\");\n};\n\n&lt;Form.Item\n    name=\"email\"\n    label=\"Email\"\n    rules={[\n        {\n            required: true,\n            message: \"Please enter your email\",\n        },\n        {\n            validator: validateEmail,\n        },\n    ]}\n&gt;\n    &lt;Input placeholder=\"Email\" /&gt;\n&lt;/Form.Item&gt;\n</code></pre>"},{"location":"frontend/react/package/antd/antd-form/","title":"Antd Form","text":"<p>Ant Design provides the <code>form.getFieldValue</code> and <code>form.setFieldsValue</code> methods to get and set form field values, respectively</p> jsx<pre><code>const [form] = Form.useForm();\n\nconst otherFieldValue = form.getFieldValue(\"otherField\");\n\nform.setFieldsValue({\n    currentField: /* New value based on custom logic */,\n});\n\nuseEffect(() =&gt; {\n    // Set default values based on external data\n    form.setFieldsValue({\n      username: externalData.username,\n      email: externalData.email,\n    });\n}, [externalData, form]);\n</code></pre>"},{"location":"frontend/react/package/antd/controlled-components/","title":"Controlled Component","text":""},{"location":"frontend/react/package/antd/controlled-components/#controlled-components-with-form-component","title":"Controlled Components with Form Component:","text":"<p>Ant Design provides a <code>Form</code> component that simplifies form handling. You can use controlled components and the <code>Form</code> component together to manage form state and validation easily.</p> jsx<pre><code>import { Form, Input, Button } from \"antd\";\nimport { useState } from \"react\";\n\nfunction MyForm() {\n  const [form] = Form.useForm();\n  const [formData, setFormData] = useState({});\n\n  const onFinish = (values) =&gt; {\n    console.log(\"Form submitted:\", values);\n    // Perform further actions with form data\n  };\n\n  return (\n    &lt;Form form={form} onFinish={onFinish}&gt;\n      &lt;Form.Item name=\"username\" label=\"Username\"&gt;\n        &lt;Input /&gt;\n      &lt;/Form.Item&gt;\n      &lt;Form.Item name=\"password\" label=\"Password\"&gt;\n        &lt;Input.Password /&gt;\n      &lt;/Form.Item&gt;\n      &lt;Form.Item&gt;\n        &lt;Button type=\"primary\" htmlType=\"submit\"&gt;\n          Submit\n        &lt;/Button&gt;\n      &lt;/Form.Item&gt;\n    &lt;/Form&gt;\n  );\n}\n</code></pre>"},{"location":"frontend/react/package/fetching/axios/","title":"Axios","text":""},{"location":"frontend/react/package/fetching/axios/#axios","title":"axios","text":""},{"location":"frontend/react/package/fetching/intro/","title":"Intro","text":""},{"location":"frontend/react/package/fetching/intro/#intro","title":"Intro","text":"<p>Here's a list of popular React fetching libraries along with brief descriptions and example usage for each:</p>"},{"location":"frontend/react/package/fetching/intro/#1-fetch-api","title":"1. Fetch API","text":"<p>The native way to make HTTP requests in JavaScript.</p> <pre><code>useEffect(() =&gt; {\n  fetch('https://api.example.com/data')\n    .then(response =&gt; response.json())\n    .then(data =&gt; console.log(data))\n    .catch(error =&gt; console.error('Error:', error));\n}, []);\n</code></pre>"},{"location":"frontend/react/package/fetching/intro/#2-axios","title":"2. Axios","text":"<p>A promise-based HTTP client for the browser and Node.js.</p> <pre><code>import axios from 'axios';\n\nuseEffect(() =&gt; {\n  axios.get('https://api.example.com/data')\n    .then(response =&gt; console.log(response.data))\n    .catch(error =&gt; console.error('Error:', error));\n}, []);\n</code></pre>"},{"location":"frontend/react/package/fetching/intro/#3-superagent","title":"3. SuperAgent","text":"<p>A small, progressive HTTP request library.</p> <pre><code>import superagent from 'superagent';\n\nuseEffect(() =&gt; {\n  superagent.get('https://api.example.com/data')\n    .then(response =&gt; console.log(response.body))\n    .catch(error =&gt; console.error('Error:', error));\n}, []);\n</code></pre>"},{"location":"frontend/react/package/fetching/intro/#4-swr","title":"4. SWR","text":"<p>A React Hooks library for remote data fetching developed by Vercel.</p> <pre><code>import useSWR from 'swr';\n\nconst fetcher = url =&gt; fetch(url).then(res =&gt; res.json());\n\nfunction Component() {\n  const { data, error } = useSWR('https://api.example.com/data', fetcher);\n\n  if (error) return &lt;div&gt;Error loading data&lt;/div&gt;;\n  if (!data) return &lt;div&gt;Loading...&lt;/div&gt;;\n\n  return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n</code></pre>"},{"location":"frontend/react/package/fetching/intro/#5-react-query","title":"5. React Query","text":"<p>A powerful data-fetching and state management library for React.</p> <pre><code>import { useQuery } from 'react-query';\n\nconst fetcher = async () =&gt; {\n  const response = await fetch('https://api.example.com/data');\n  return response.json();\n};\n\nfunction Component() {\n  const { data, error, isLoading } = useQuery('dataKey', fetcher);\n\n  if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;\n  if (error) return &lt;div&gt;Error loading data&lt;/div&gt;;\n\n  return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n</code></pre>"},{"location":"frontend/react/package/fetching/intro/#6-apollo-client","title":"6. Apollo Client","text":"<p>A comprehensive solution for managing GraphQL data.</p> <pre><code>import { useQuery, gql } from '@apollo/client';\n\nconst GET_DATA = gql`\n  query GetData {\n    data {\n      id\n      name\n    }\n  }\n`;\n\nfunction Component() {\n  const { data, loading, error } = useQuery(GET_DATA);\n\n  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n  if (error) return &lt;div&gt;Error loading data&lt;/div&gt;;\n\n  return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n</code></pre>"},{"location":"frontend/react/package/fetching/intro/#7-relay","title":"7. Relay","text":"<p>A JavaScript framework for building data-driven React applications using GraphQL.</p> <pre><code>import {\n  RelayEnvironmentProvider,\n  loadQuery,\n  usePreloadedQuery,\n  graphql,\n} from 'react-relay/hooks';\nimport RelayEnvironment from './RelayEnvironment';\n\nconst { PreloadedQuery, PreloadableQuery } = loadQuery(\n  RelayEnvironment,\n  graphql`\n    query AppQuery {\n      viewer {\n        name\n      }\n    }\n  `\n);\n\nfunction Component(props) {\n  const data = usePreloadedQuery(PreloadableQuery, props.preloadedQuery);\n  return &lt;div&gt;{data.viewer.name}&lt;/div&gt;;\n}\n\nfunction App() {\n  return (\n    &lt;RelayEnvironmentProvider environment={RelayEnvironment}&gt;\n      &lt;Component preloadedQuery={PreloadedQuery} /&gt;\n    &lt;/RelayEnvironmentProvider&gt;\n  );\n}\n</code></pre>"},{"location":"frontend/react/package/fetching/intro/#8-urql","title":"8. Urql","text":"<p>A highly customizable and versatile GraphQL client for React.</p> <pre><code>import { createClient, Provider, useQuery } from 'urql';\n\nconst client = createClient({\n  url: 'https://api.example.com/graphql',\n});\n\nconst GET_DATA = `\n  query {\n    data {\n      id\n      name\n    }\n  }\n`;\n\nfunction Component() {\n  const [result] = useQuery({ query: GET_DATA });\n  const { data, fetching, error } = result;\n\n  if (fetching) return &lt;div&gt;Loading...&lt;/div&gt;;\n  if (error) return &lt;div&gt;Error loading data&lt;/div&gt;;\n\n  return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n\nfunction App() {\n  return (\n    &lt;Provider value={client}&gt;\n      &lt;Component /&gt;\n    &lt;/Provider&gt;\n  );\n}\n</code></pre> <p>These libraries cover a range of use cases from basic HTTP requests to advanced GraphQL queries, allowing you to choose the one that best fits your project's needs.</p> Tips <ol> <li> <p>JavaScript Fundamentals</p> <ul> <li>Promises and Async/Await: Understanding how promises work and how to use async/await syntax for handling asynchronous code is crucial.</li> <li>Error Handling: Knowing how to handle errors properly in asynchronous code.</li> </ul> </li> <li> <p>Data Fetching</p> <ul> <li>Fetch API: Basic understanding of the native Fetch API as a starting point.</li> <li>Axios: Learning how to use Axios for more advanced use cases.</li> </ul> </li> <li> <p>Error Handling</p> <ul> <li>Properly handle errors in data fetching.</li> <li>Display appropriate error messages to users.</li> </ul> </li> </ol>"},{"location":"frontend/react/package/fetching/intro/#setup-and-installation","title":"Setup and Installation:","text":"<ol> <li> <p>Practical Steps to Get Started</p> <ul> <li>Install the chosen library using npm or yarn.</li> </ul> <pre><code>npm install axios\nnpm install swr\nnpm install @apollo/client graphql\nnpm install react-query\n</code></pre> </li> <li> <p>Basic Fetching:</p> <ul> <li>Write a simple data-fetching component.</li> </ul> <pre><code>import axios from 'axios';\nimport { useEffect, useState } from 'react';\n\nfunction DataFetchingComponent() {\nconst [data, setData] = useState(null);\n\nuseEffect(() =&gt; {\n    axios.get('https://api.example.com/data')\n    .then(response =&gt; setData(response.data))\n    .catch(error =&gt; console.error(error));\n}, []);\n\nif (!data) return &lt;div&gt;Loading...&lt;/div&gt;;\n\nreturn &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n</code></pre> </li> <li> <p>Error Handling:</p> <ul> <li>Implement proper error handling.</li> </ul> <pre><code>useEffect(() =&gt; {\naxios.get('https://api.example.com/data')\n    .then(response =&gt; setData(response.data))\n    .catch(error =&gt; {\n    console.error(error);\n    setError('Failed to fetch data');\n    });\n}, []);\n</code></pre> </li> <li> <p>Using Hooks:</p> <ul> <li>For libraries like SWR or React Query, understand and use their custom hooks.</li> </ul> <pre><code>import useSWR from 'swr';\nconst fetcher = url =&gt; fetch(url).then(res =&gt; res.json());\n\nfunction DataFetchingComponent() {\nconst { data, error } = useSWR('https://api.example.com/data', fetcher);\n\nif (error) return &lt;div&gt;Error loading data&lt;/div&gt;;\nif (!data) return &lt;div&gt;Loading...&lt;/div&gt;;\n\nreturn &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n</code></pre> </li> <li> <p>Advanced Usage:</p> <ul> <li>Explore more advanced features such as pagination, caching, and optimistic updates provided by libraries like React Query and SWR.</li> </ul> </li> </ol> <p>By understanding these core concepts and gradually building upon them, you will be well-prepared to effectively use any data-fetching library in React.</p> <p>In JavaScript, there are several traditional ways to fetch API data, including:</p>"},{"location":"frontend/react/package/fetching/intro/#traditional-methods-in-javascript","title":"Traditional Methods in JavaScript:","text":"<ol> <li> <p>XMLHttpRequest:</p> <pre><code>var xhr = new XMLHttpRequest();\nxhr.open('GET', 'https://api.example.com/data', true);\nxhr.onload = function () {\n    if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) {\n        console.log(JSON.parse(xhr.responseText));\n    } else {\n        console.error('Request failed');\n    }\n};\nxhr.send();\n</code></pre> </li> <li> <p>Fetch API:</p> <pre><code>fetch('https://api.example.com/data')\n.then(response =&gt; response.json())\n.then(data =&gt; console.log(data))\n.catch(error =&gt; console.error('Error:', error));\n</code></pre> </li> <li> <p>Async/Await with Fetch API:</p> <pre><code>async function fetchData() {\n    try {\n        const response = await fetch('https://api.example.com/data');\n        const data = await response.json();\n        console.log(data);\n    } catch (error) {\n        console.error('Error:', error);\n    }\n}\nfetchData();\n</code></pre> </li> </ol>"},{"location":"frontend/react/package/fetching/intro/#packages-in-react-to-fetch-api-data","title":"Packages in React to Fetch API Data:","text":"<ol> <li> <p>Axios:</p> <pre><code>import axios from 'axios';\n\naxios.get('https://api.example.com/data')\n    .then(response =&gt; console.log(response.data))\n    .catch(error =&gt; console.error('Error:', error));\n</code></pre> <p>Using Axios with async/await:</p> <pre><code>import axios from 'axios';\n\nasync function fetchData() {\n    try {\n        const response = await axios.get('https://api.example.com/data');\n        console.log(response.data);\n    } catch (error) {\n        console.error('Error:', error);\n    }\n}\nfetchData();\n</code></pre> </li> <li> <p>React Query:</p> <pre><code>import { useQuery } from 'react-query';\n\nfunction MyComponent() {\n    const { isLoading, error, data } = useQuery('fetchData', () =&gt;\n        fetch('https://api.example.com/data').then(res =&gt; res.json())\n    );\n\n    if (isLoading) return 'Loading...';\n    if (error) return 'An error has occurred: ' + error.message;\n\n    return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n</code></pre> </li> <li> <p>SWR (stale-while-revalidate):</p> <pre><code>import useSWR from 'swr';\n\nconst fetcher = url =&gt; fetch(url).then(res =&gt; res.json());\n\nfunction MyComponent() {\n    const { data, error } = useSWR('https://api.example.com/data', fetcher);\n\n    if (error) return &lt;div&gt;Failed to load&lt;/div&gt;;\n    if (!data) return &lt;div&gt;Loading...&lt;/div&gt;;\n\n    return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n</code></pre> </li> <li> <p>useEffect with Fetch API:</p> <pre><code>import { useEffect, useState } from 'react';\n\nfunction MyComponent() {\n    const [data, setData] = useState(null);\n    const [isLoading, setIsLoading] = useState(true);\n    const [error, setError] = useState(null);\n\n    useEffect(() =&gt; {\n        fetch('https://api.example.com/data')\n            .then(response =&gt; response.json())\n            .then(data =&gt; {\n                setData(data);\n                setIsLoading(false);\n            })\n            .catch(error =&gt; {\n                setError(error);\n                setIsLoading(false);\n            });\n    }, []);\n\n    if (isLoading) return 'Loading...';\n    if (error) return 'An error has occurred: ' + error.message;\n\n    return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;\n}\n</code></pre> </li> </ol> <p>These methods and packages cover a range of use cases and preferences for fetching API data in JavaScript and React applications.</p>"},{"location":"frontend/react/package/lodash/debounce/","title":"debounce","text":"<p><code>npm install lodash</code></p> jsx<pre><code>import React, { useState, useEffect } from \"react\";\nimport { Select } from \"antd\";\nimport debounce from \"lodash/debounce\";\n\nconst { Option } = Select;\n\nconst DebouncedSelect = () =&gt; {\n  const [searchTerm, setSearchTerm] = useState(\"\");\n\n  const debouncedSearch = debounce((value) =&gt; {\n    // Your search logic here, e.g., making an API call\n    console.log(\"Searching for:\", value);\n  }, 300); // 300ms debounce delay\n\n  useEffect(() =&gt; {\n    debouncedSearch(searchTerm);\n  }, [searchTerm, debouncedSearch]);\n\n  const handleSearch = (value) =&gt; {\n    setSearchTerm(value);\n  };\n\n  return (\n    &lt;Select\n      showSearch\n      onSearch={handleSearch}\n      style={{ width: 200 }}\n      placeholder=\"Search...\"\n    &gt;\n      &lt;Option value=\"1\"&gt;Option 1&lt;/Option&gt;\n      &lt;Option value=\"2\"&gt;Option 2&lt;/Option&gt;\n      &lt;Option value=\"3\"&gt;Option 3&lt;/Option&gt;\n    &lt;/Select&gt;\n  );\n};\n\nexport default DebouncedSelect;\n</code></pre>"},{"location":"frontend/react/package/lodash/debounce/#debounce-with-hoc","title":"Debounce with Hoc","text":"<p>separate the debounce logic and the HOC into separate files for better organization</p> 1. Debounce utility file2. HOC file3. Component file debounce.js<pre><code>// debounce.js\nconst debounce = (func, delay) =&gt; {\n    let timeoutId;\n    return function (...args) {\n        clearTimeout(timeoutId);\n        timeoutId = setTimeout(() =&gt; func.apply(this, args), delay);\n    };\n};\n\nexport default debounce;\n</code></pre> withDebounce.js<pre><code>import React from 'react';\nimport debounce from './debounce';\n\nconst withDebounce = (WrappedComponent) =&gt; {\n    return class WithDebounce extends React.Component {\n        debouncedFunction = debounce((...args) =&gt; {\n            console.log('Debounced function called with args:', args);\n        }, 500); // 500ms debounce delay\n\n        render() {\n            return (\n                &lt;WrappedComponent\n                    {...this.props}\n                    onDebouncedAction={this.debouncedFunction}\n                /&gt;\n            );\n        }\n    };\n};\n\nexport default withDebounce;\n</code></pre> MyComponent.js<pre><code>import React from 'react';\nimport withDebounce from './withDebounce';\n\nconst MyComponent = ({ onDebouncedAction }) =&gt; {\n    const handleClick = () =&gt; {\n        onDebouncedAction('Click event');\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;button onClick={handleClick}&gt;Click me&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default withDebounce(MyComponent);\n</code></pre> <p>Now you can import and use the <code>MyComponent</code> in your main application file:</p> App.js<pre><code>import React from \"react\";\nimport MyComponent from \"./MyComponent\";\n\nconst App = () =&gt; {\n  return (\n    &lt;div&gt;\n      &lt;MyComponent /&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n</code></pre> <p>This structure helps maintain a clean separation of concerns, making each file focused on its specific responsibility. The debounce utility is isolated in its own file, and the HOC is defined separately, promoting code modularity and reusability.</p>"},{"location":"frontend/react/package/tinymce/tinymce/","title":"Intro","text":"<p>TinyMCE is a popular WYSIWYG editor that can be integrated into React applications. To add a template inside the TinyMCE editor in a React project, you can follow these general steps:</p> <ol> <li> <p>Install TinyMCE:     If you haven't already, install the TinyMCE editor in your React project using a package manager like npm or yarn. Here's an example using npm:</p> <pre><code>npm install tinymce\n</code></pre> </li> <li> <p>Import TinyMCE in your React component:     Import TinyMCE in the React component where you want to use the editor.</p> <pre><code>import { Editor } from \"@tinymce/tinymce-react\";\n</code></pre> </li> <li> <p>Configure TinyMCE:     Set up the TinyMCE configuration in your component. This is where you can define the template and other settings.</p> <pre><code>const TinyMCEEditor = () =&gt; {\n  const handleEditorChange = (content, editor) =&gt; {\n    // Handle content changes here\n    console.log(\"Content:\", content);\n  };\n\n  const templateContent = `\n    &lt;p&gt;This is a template content&lt;/p&gt;\n`;\n\n  return (\n    &lt;Editor\n      apiKey=\"YOUR_API_KEY\" // You can obtain an API key by creating a TinyMCE account\n      initialValue={templateContent}\n      init={{\n        height: 500,\n        menubar: false,\n        plugins: [\n          \"advlist autolink lists link image charmap print preview anchor\",\n          \"searchreplace visualblocks code fullscreen\",\n          \"insertdatetime media table paste code help wordcount\",\n        ],\n        toolbar:\n          \"undo redo | formatselect | bold italic backcolor | \\\n        alignleft aligncenter alignright alignjustify | \\\n        bullist numlist outdent indent | removeformat | help\",\n        content_style:\n          \"body { font-family:Helvetica,Arial,sans-serif; font-size:14px }\",\n      }}\n      onChange={handleEditorChange}\n    /&gt;\n  );\n};\n\nexport default TinyMCEEditor;\n</code></pre> <p>In the above example, templateContent is the initial content of the editor, and you can customize the init object to include the desired plugins, toolbar buttons, and other configurations.</p> </li> <li> <p>Handle Template Insertion:</p> <p>You can provide a button or some other user interaction to insert the template content into the editor. For example, you can add a button that, when clicked, inserts the template content at the current cursor position.</p> <pre><code>const insertTemplate = () =&gt; {\n  const editor = tinymce.activeEditor;\n  if (editor) {\n    editor.insertContent(templateContent);\n  }\n};\n\n// ...\n\n&lt;button onClick={insertTemplate}&gt;Insert Template&lt;/button&gt;;\n</code></pre> <p>Make sure to adapt the code according to your specific requirements and integrate it seamlessly into your React application. Adjust the TinyMCE configuration and event handlers based on your needs.</p> </li> </ol>"},{"location":"frontend/react/pattern/antipattern/","title":"Anti Pattern","text":"<ol> <li> <p>Using <code>indexes</code> as a key</p> <p>Bug</p> <pre><code>return (\n&lt;div&gt;\n    &lt;ul&gt;\n    {items.map((item, index) =&gt; (\n        &lt;li key={index}&gt;\n            {item}\n            &lt;input type=\"text\" /&gt;\n        &lt;/li&gt;\n    ))}\n    &lt;/ul&gt;\n\n    &lt;button onClick={handleClick}&gt;+&lt;/button&gt;\n&lt;/div&gt;\n)\n</code></pre> <p>To solve this problem, we can, for example, use the value of the item if we expect it not to be repeated within the list, or create a unique identifier, for example:</p> <p>Success</p> <pre><code>{items.map((item, index) =&gt; (\n    &lt;li key={`${item}-${index}`}&gt;\n        {item}\n        &lt;input type=\"text\" /&gt;\n    &lt;/li&gt;\n))}\n</code></pre> </li> <li> <p>Spreading properties on DOM elements</p> </li> </ol>"},{"location":"frontend/react/pattern/compound-pattern/","title":"Compound Pattern","text":"<p>Let's create a compound component for a <code>Modal</code> that can be used to display various types of content. The compound components will include <code>Modal</code>, <code>ModalHeader</code>, <code>ModalBody</code>, and <code>ModalFooter</code>.</p> Modal.jsModalHeader.jsModalBody.jsModalFooter.js <pre><code>import React, { useState } from 'react';\n\nconst Modal = ({ children, isOpen, onClose }) =&gt; {\n    return isOpen ? (\n        &lt;div className=\"modal-overlay\" onClick={onClose}&gt;\n            &lt;div className=\"modal\" onClick={(e) =&gt; e.stopPropagation()}&gt;\n                {children}\n            &lt;/div&gt;\n        &lt;/div&gt;\n    ) : null;\n};\n\nexport default Modal;\n</code></pre> <pre><code>import React from 'react';\n\nconst ModalHeader = ({ children }) =&gt; {\n    return &lt;div className=\"modal-header\"&gt;{children}&lt;/div&gt;;\n};\n\nexport default ModalHeader;\n</code></pre> <pre><code>import React from 'react';\n\nconst ModalBody = ({ children }) =&gt; {\n    return &lt;div className=\"modal-body\"&gt;{children}&lt;/div&gt;;\n};\n\nexport default ModalBody;\n</code></pre> <pre><code>import React from 'react';\n\nconst ModalFooter = ({ children }) =&gt; {\n    return &lt;div className=\"modal-footer\"&gt;{children}&lt;/div&gt;;\n};\n\nexport default ModalFooter;\n</code></pre> <p>Now, let's use these components in an example application:</p> App.js<pre><code>// App.js\nimport React, { useState } from \"react\";\nimport Modal from \"./Modal\";\nimport ModalHeader from \"./ModalHeader\";\nimport ModalBody from \"./ModalBody\";\nimport ModalFooter from \"./ModalFooter\";\n\nconst App = () =&gt; {\n  const [isModalOpen, setIsModalOpen] = useState(false);\n\n  const openModal = () =&gt; {\n    setIsModalOpen(true);\n  };\n\n  const closeModal = () =&gt; {\n    setIsModalOpen(false);\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Compound Pattern in React - Modal Example&lt;/h1&gt;\n      &lt;button onClick={openModal}&gt;Open Modal&lt;/button&gt;\n\n      &lt;Modal isOpen={isModalOpen} onClose={closeModal}&gt;\n        &lt;ModalHeader&gt;\n          &lt;h2&gt;Modal Title&lt;/h2&gt;\n        &lt;/ModalHeader&gt;\n        &lt;ModalBody&gt;\n          &lt;p&gt;This is the content of the modal.&lt;/p&gt;\n        &lt;/ModalBody&gt;\n        &lt;ModalFooter&gt;\n          &lt;button onClick={closeModal}&gt;Close&lt;/button&gt;\n        &lt;/ModalFooter&gt;\n      &lt;/Modal&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n</code></pre> <p>In this example, the <code>Modal</code> component serves as the container for the modal content. The <code>ModalHeader</code>, <code>ModalBody</code>, and <code>ModalFooter</code> components are used within the <code>Modal</code> component to structure and style the different parts of the modal.</p> <p>This compound pattern allows you to create a reusable and flexible modal component by composing smaller components together. Each smaller component focuses on a specific part of the modal, making the code more modular and maintainable.</p>"},{"location":"frontend/react/pattern/container-presentational-patterns/","title":"container presentational patterns","text":"<p>React components typically contain a mix of logic and presentation. By logic, we refer to anything that is unrelated to the UI, such as API calls, data manipulation, and event handlers. The presentation is the part of the render where we create the elements to be displayed on the UI.</p> <p>In React, there are simple and powerful patterns, known as container and presentational, which we can apply when creating components that help us to separate those two concerns.</p>"},{"location":"frontend/react/pattern/function-as-child/","title":"FaC Pattern","text":""},{"location":"frontend/react/pattern/function-as-child/#function-as-child-fac-pattern","title":"Function as Child (FaC) pattern","text":"<p>In React, the \"<code>Function as Child</code>\" (FaC) pattern involves passing a function as a child of a component. This pattern is also known as \"Render Props.\" The basic idea is to pass a function as a child to a component, allowing the component to render content or behavior based on the result of that function.</p> <p>Here's a simple example to illustrate the Function as Child pattern:</p> ParentComponent.js<pre><code>import React from \"react\";\n\nconst ParentComponent = ({ children }) =&gt; {\n  // Execute the function (child) and pass data to it\n  return &lt;div&gt;{children(\"Data from Parent\")}&lt;/div&gt;;\n};\n\nexport default ParentComponent;\n</code></pre> <p>Now, you can use <code>ParentComponent</code> in another component and pass a function as its child:</p> App.js<pre><code>import React from \"react\";\nimport ParentComponent from \"./ParentComponent\";\n\nconst App = () =&gt; {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Function as Child Pattern&lt;/h1&gt;\n\n      {/* Using ParentComponent and passing a function as its child */}\n      &lt;ParentComponent&gt;\n        {(dataFromParent) =&gt; (\n          &lt;p&gt;{`Received data in child component: ${dataFromParent}`}&lt;/p&gt;\n        )}\n      &lt;/ParentComponent&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n</code></pre> <p>In this example, the <code>ParentComponent</code> takes a <code>children</code> prop, which is a function. Inside <code>ParentComponent</code>, it calls the <code>children</code> function and passes some data (\"<code>Data from Parent</code>\" in this case). The child component (the function passed as a child) then receives this data and can use it to render content.</p> <p>The main benefit of the Function as Child pattern is that it allows you to inject dynamic behavior or data into a component from its parent without the need for complex props or state management. It provides a way to share functionality between components in a more flexible and composable manner.</p> <p>This pattern is commonly used in React, especially in cases where you want to abstract away some logic or behavior into a component but allow customization in its usage by passing functions as children.</p> <p>Real Example</p> <p>Lets create <code>Toggle</code> component that can be used to toggle the visibility of content.</p> Toggle.js<pre><code>import React, { useState } from \"react\";\n\nconst Toggle = ({ children }) =&gt; {\n  const [isVisible, setIsVisible] = useState(false);\n\n  const toggleVisibility = () =&gt; {\n    setIsVisible(!isVisible);\n  };\n\n  // Render the child function and pass the toggleVisibility function and the current visibility state\n  return children({ isVisible, toggleVisibility });\n};\n\nexport default Toggle;\n</code></pre> <p>Now, let's use the <code>Toggle</code> component in another component:</p> App.js<pre><code>import React from \"react\";\nimport Toggle from \"./Toggle\";\n\nconst App = () =&gt; {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Function as Child Pattern - Toggle Example&lt;/h1&gt;\n\n      {/* Using Toggle and passing a function as its child */}\n      &lt;Toggle&gt;\n        {({ isVisible, toggleVisibility }) =&gt; (\n          &lt;div&gt;\n            &lt;button onClick={toggleVisibility}&gt;Toggle Visibility&lt;/button&gt;\n\n            {isVisible &amp;&amp; &lt;p&gt;This content is now visible!&lt;/p&gt;}\n          &lt;/div&gt;\n        )}\n      &lt;/Toggle&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default App;\n</code></pre> <p>In this example, the <code>Toggle</code> component encapsulates the state and logic for toggling visibility. It takes a function as a child, and that function receives an object with two properties: <code>isVisible</code> (a boolean indicating whether the content is visible) and <code>toggleVisibility</code> (a function to toggle the visibility).</p> <p>The <code>App</code> component uses the <code>Toggle</code> component, passing a function as its child. Inside the function, it receives the <code>isVisible</code> state and the <code>toggleVisibility</code> function, and it uses these to conditionally render content.</p> <p>This pattern is powerful because it allows you to encapsulate state and behavior within a component while giving the consumer of that component full control over the rendering and customization of the UI based on the component's state.</p>"},{"location":"frontend/react/pattern/hoc-pattern/","title":"HoC Pattern","text":"<p>Higher-Order Components (HOCs) are a design pattern in React that allows the reuse of component logic.</p> <p>A Higher-Order Component is a function that takes a component and returns a new component with additional props or behavior. HOCs are commonly used for cross-cutting concerns such as authentication, logging, and data fetching.</p> <p>Here's an example of a Higher-Order Component using a functional component:</p> withLogging.js (HOC file):MyComponent.jsApp.js jsx<pre><code>import React, { useEffect } from 'react';\n\nconst withLogging = (WrappedComponent) =&gt; {\n    const WithLogging = (props) =&gt; {\n        useEffect(() =&gt; {\n            console.log(`Component ${WrappedComponent.name || 'Anonymous'} is mounted`);\n            return () =&gt; {\n                console.log(`Component ${WrappedComponent.name || 'Anonymous'} is unmounted`);\n            };\n        }, []);\n\n        return &lt;WrappedComponent {...props} /&gt;;\n    };\n\n    return WithLogging;\n};\n\nexport default withLogging;\n</code></pre> jsx<pre><code>import React from 'react';\n\nconst MyComponent = () =&gt; {\n    return &lt;div&gt;Hello, I'm a functional component!&lt;/div&gt;;\n};\n\nexport default MyComponent;\n</code></pre> jsx<pre><code>import React from 'react';\nimport withLogging from './withLogging';\nimport MyComponent from './MyComponent';\n\nconst MyComponentWithLogging = withLogging(MyComponent);\n\nconst App = () =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;MyComponentWithLogging /&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default App;\n</code></pre> <p>In this structure:</p> <ul> <li><code>withLogging.js</code> contains the HOC (withLogging).</li> <li><code>MyComponent.js</code> contains the functional component (MyComponent).</li> <li><code>App.js</code> uses the HOC by importing it and applying it to MyComponent.</li> </ul> <p>This modular approach allows you to organize your code better and promotes reusability. You can easily apply the withLogging HOC to other components in different files without duplicating the logic.</p>"},{"location":"frontend/react/pattern/hoc-pattern/#when-naming-higher-order-component-hoc-files-in-a-react-application","title":"When naming Higher-Order Component (HOC) files in a React application","text":"<ul> <li> <p>Prefix with \"with\":</p> <p>It's a common convention to prefix the HOC file name with \"with\" to indicate that it is a Higher-Order Component.</p> <pre><code>withExampleHOC.js\nwithAuthentication.js\nwithTheme.js\n</code></pre> </li> <li> <p>Suffix with \"HOC\":</p> <p>Optionally, you can suffix the file name with \"HOC\" to make it explicit that it is a Higher-Order Component.</p> <pre><code>ExampleComponentHOC.js\nAuthenticationHOC.js\n</code></pre> </li> </ul>"},{"location":"frontend/react/pattern/hoc-pattern/#real-example","title":"Real Example","text":"<p>You can organize your code in a way that makes sense for your project structure. Here's an example of how you might structure the file:</p> withConditionalFormItem.js<pre><code>import React from \"react\";\nimport { Form } from \"antd\";\n\nconst withConditionalFormItem = (WrappedComponent, condition) =&gt; {\n  return (props) =&gt; {\n    if (condition) {\n      return &lt;WrappedComponent {...props} /&gt;;\n    } else {\n      return null; // or you can render an alternative component/message\n    }\n  };\n};\n\nexport default withConditionalFormItem;\n</code></pre> <p>Then, in your main component file:</p> YourFormComponent.js<pre><code>//\nimport React from \"react\";\nimport { Form, Input } from \"antd\";\nimport withConditionalFormItem from \"./withConditionalFormItem\";\n\n// Usage\nconst ConditionalRemarksFormItem = withConditionalFormItem(\n  Form.Item,\n  !isCircular // Condition based on your boolean value\n);\n\nconst YourFormComponent = () =&gt; {\n  return (\n    &lt;Form&gt;\n      {/* Other Form items */}\n      &lt;ConditionalRemarksFormItem label=\"Remarks\" name=\"remarks\"&gt;\n        &lt;Input.TextArea rows={4} placeholder=\"Remarks\" /&gt;\n      &lt;/ConditionalRemarksFormItem&gt;\n      {/* Other Form items */}\n    &lt;/Form&gt;\n  );\n};\n\nexport default YourFormComponent;\n</code></pre> <p>This way, you have a separate file for the higher-order component, making it easy to reuse across different components in your project.</p>"},{"location":"frontend/react/pattern/misc/","title":"Misc","text":""},{"location":"frontend/react/pattern/misc/#conditional-rendering-pattern","title":"<code>Conditional Rendering</code> pattern","text":"<pre><code>import React from \"react\";\n\nconst YourComponent = ({ singleCircularReferenceTemplateResponse }) =&gt; {\n  // Check if the response is still loading\n  const isLoading = !singleCircularReferenceTemplateResponse;\n\n  // Check if the response has content\n  const hasContent = !!singleCircularReferenceTemplateResponse?.content;\n\n  return (\n    &lt;div&gt;\n      {isLoading &amp;&amp; &lt;p&gt;Loading...&lt;/p&gt;}\n      {!isLoading &amp;&amp; !hasContent &amp;&amp; &lt;p&gt;No Content available.&lt;/p&gt;}\n      {!isLoading &amp;&amp; hasContent &amp;&amp; (\n        &lt;div\n          dangerouslySetInnerHTML={{\n            __html: singleCircularReferenceTemplateResponse.content,\n          }}\n        &gt;&lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default YourComponent;\n</code></pre>"},{"location":"frontend/react/pattern/react-pattern-intro/","title":"Introduction","text":""},{"location":"frontend/react/pattern/react-pattern-intro/#react-design-patterns","title":"React Design Patterns","text":"<ul> <li><code>Compound</code> Pattern</li> <li><code>HOC</code> Pattern</li> <li><code>Hooks</code> Pattern</li> <li><code>Container/Presentational</code> Pattern</li> <li><code>Render Props</code> Pattern</li> </ul>"},{"location":"frontend/react/pattern/react-pattern-intro/#reference","title":"Reference","text":"<ul> <li>reactpatterns.js.org</li> <li>patterns.dev</li> <li> <p>reactpatterns.com</p> </li> <li> <p>React Design Patterns</p> </li> </ul>"},{"location":"frontend/react/router/intro/","title":"Introduction","text":""},{"location":"frontend/react/router/intro/#react-router","title":"React Router","text":"<ul> <li>React Router v6 Update: Updated PrivateRoute to use Navigate instead of Redirect.</li> <li>Component Validation: Ensured PrivateRoute validates its props with PropTypes.</li> <li>Router Configuration: Updated App component to use Routes and Route components from react-router-dom v6.</li> </ul> <p>By making these changes, your code will be compatible with react-router-dom version 6, and you should no longer encounter the issue with the Redirect component.</p> <p>React Router is a popular library used for routing in React applications. It allows you to handle navigation and rendering of different components based on the URL, enabling single-page application (SPA) behavior.</p>"},{"location":"frontend/react/router/intro/#versions-of-react-router","title":"Versions of React Router","text":"<p>React Router has undergone several major versions, each introducing significant changes and improvements:</p> <ol> <li>React Router v1 and v2: Early versions focused on basic routing capabilities.</li> <li>React Router v3: Provided a more stable API but started showing limitations in terms of flexibility and ease of use.</li> <li>React Router v4: Introduced a major overhaul with a declarative approach to routing, enabling more powerful and flexible routing capabilities.</li> <li>React Router v5: Built on v4's foundation, providing incremental improvements and more features while maintaining backward compatibility.</li> <li>React Router v6: Another major update with significant changes to the API, simplifying and modernizing routing in React applications.</li> </ol>"},{"location":"frontend/react/router/intro/#major-updates-and-changes","title":"Major Updates and Changes","text":""},{"location":"frontend/react/router/intro/#react-router-v4","title":"React Router v4","text":"<ul> <li>Declarative Routing: Introduced a new approach where routes are declared as components, making the routing logic more intuitive and easier to manage.</li> <li>Dynamic Routing: Allowed routes to be dynamic, enabling more flexibility.</li> <li>Nested Routes: Improved support for nested routes, making it easier to build complex routing structures.</li> <li>Removal of Route Configuration: Moved away from centralized route configuration to a component-based approach.</li> </ul>"},{"location":"frontend/react/router/intro/#react-router-v5","title":"React Router v5","text":"<ul> <li>Incremental Improvements: Built on v4, adding minor enhancements and optimizations while maintaining the same declarative approach.</li> <li>Hooks Support: Introduced hooks like <code>useHistory</code>, <code>useLocation</code>, <code>useParams</code>, and <code>useRouteMatch</code> for more flexible and powerful routing.</li> <li>Suspense Integration: Improved integration with React's Suspense for data fetching and code splitting.</li> </ul>"},{"location":"frontend/react/router/intro/#react-router-v6","title":"React Router v6","text":"<ul> <li>Simplified API: Major overhaul with a more straightforward and simplified API.</li> <li>Routes and Route Elements: Introduced the Routes and Route elements, replacing Switch and Route from previous versions.</li> <li>Nested Routes: Enhanced nested routing with a more intuitive approach.</li> <li>Data Loading: Integrated better support for data loading and fetching, aligning with modern React patterns.</li> <li>Improved TypeScript Support: Enhanced TypeScript support for better type checking and developer experience.</li> <li>URL-based State: Improved handling of state through URLs, making it easier to manage state with routing.</li> <li>Route Definitions: Allowed defining routes as objects or elements, providing more flexibility.</li> </ul>"},{"location":"frontend/react/router/intro/#example-comparison","title":"Example Comparison","text":"React Router v5 <pre><code>import { BrowserRouter as Router, Switch, Route, Redirect } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Switch&gt;\n            &lt;Route path=\"/login\" component={Login} /&gt;\n            &lt;PrivateRoute path=\"/dashboard\" component={Dashboard} /&gt;\n            &lt;Redirect from=\"/\" to=\"/dashboard\" /&gt;\n        &lt;/Switch&gt;\n    &lt;/Router&gt;\n);\n</code></pre> React Router v6 <pre><code>import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Routes&gt;\n            &lt;Route path=\"/login\" element={&lt;Login /&gt;} /&gt;\n            &lt;Route path=\"/dashboard\" element={&lt;PrivateRoute component={Dashboard} /&gt;} /&gt;\n            &lt;Route path=\"*\" element={&lt;Navigate to=\"/dashboard\" /&gt;} /&gt;\n        &lt;/Routes&gt;\n    &lt;/Router&gt;\n);\n</code></pre>"},{"location":"frontend/react/router/intro/#summary-of-major-changes-in-v6","title":"Summary of Major Changes in v6","text":"<ol> <li><code>Switch</code> replaced by <code>Routes</code>: <code>Switch</code> component is replaced by <code>Routes</code>.</li> <li><code>component</code> and <code>render</code> replaced by <code>element</code>: The <code>component</code> and <code>render</code> props are replaced by <code>element</code>.</li> <li><code>Redirect</code> replaced by <code>Navigate</code>: <code>Redirect</code> component is replaced by <code>Navigate</code>.</li> <li>Route Definitions: Routes can now be defined using nested <code>Route</code> elements.</li> <li>Hooks and Context API: Improved hooks and context for routing logic.</li> <li>Improved TypeScript Support: Better TypeScript support for static type checking.</li> </ol> <p>By understanding these changes, you can effectively use React Router in your projects and take advantage of the latest features and improvements.</p>"},{"location":"frontend/state-management/intro/","title":"Intro","text":"<p>Most developers use Redux, Recoil, Mobx, and other third-party libraries to manage the global state in large-scale applications.</p> <ul> <li> <p> Redux</p> <p>Install <code>mkdocs-material</code> with <code>pip</code> and get up and running in minutes</p> <p> Getting started</p> </li> <li> <p> Mobx</p> <p>Focus on your content and generate a responsive and searchable static site</p> <p> Reference</p> </li> <li> <p> Recoil</p> <p>Change the colors, fonts, language, icons, logo and more with a few lines</p> <p> Customization</p> </li> </ul>"},{"location":"frontend/state-management/middleware/","title":"Intro","text":"<ul> <li> <p> redux-thunk </p> </li> <li> <p> redux-saga </p> </li> </ul>"},{"location":"frontend/state-management/middleware/#question","title":"Question","text":""},{"location":"frontend/state-management/middleware/#middleware-in-react","title":"Middleware in react","text":"<p>why do we need middleware in react. what do we need it. when do we need it. what is the problem. what exactly the problem does it solve. when do we do not need it. example me clearly and simply.</p> <p>Middleware in React is commonly associated with state management libraries like Redux. Middleware provides a way to extend the capabilities of Redux by adding custom functionality to the dispatching of actions. Here's a breakdown of why and when you might need middleware, what problems it solves, and when you might not need it.</p>"},{"location":"frontend/state-management/middleware/#why-do-we-need-middleware","title":"Why Do We Need Middleware?","text":"<ol> <li> <p>Enhance Dispatching:</p> <p>Middleware allows you to enhance the behavior of the dispatch function. This can include logging actions, handling asynchronous actions, or modifying actions before they reach the reducer.</p> </li> <li> <p>Asynchronous Actions:</p> <p>By default, Redux actions are synchronous. Middleware like redux-thunk or redux-saga allows you to handle asynchronous operations (e.g., API calls) within your action creators.</p> </li> <li> <p>Side Effects Management:</p> <p>Middleware helps manage side effects in a predictable manner, ensuring that the state changes in response to actions are manageable and traceable.</p> </li> </ol>"},{"location":"frontend/state-management/middleware/#what-problems-does-middleware-solve","title":"What Problems Does Middleware Solve?","text":"<ol> <li> <p>Handling Async Logic:</p> <p>Middleware allows you to write asynchronous logic that interacts with the Redux store. Without middleware, you'd have to handle async logic outside of Redux, which can lead to a less organized codebase.</p> </li> <li> <p>Action Logging:</p> <p>Middleware can log every action dispatched, along with the state before and after the action. This is helpful for debugging and understanding the flow of actions in your application.</p> </li> <li> <p>Centralized Error Handling:</p> <p>Middleware can be used to catch and handle errors that occur during the dispatching of actions, ensuring that your application remains stable.</p> </li> </ol>"},{"location":"frontend/state-management/middleware/#when-do-you-need-middleware","title":"When Do You Need Middleware?","text":"<ul> <li> <p>Asynchronous Data Fetching:</p> <p>If your application needs to fetch data from an API or handle other asynchronous operations, middleware like redux-thunk or redux-saga is necessary.</p> </li> <li> <p>Complex State Management:</p> <p>When your application has complex state transitions and side effects that need to be managed in a centralized way.</p> </li> <li> <p>Enhanced Debugging:</p> <p>To provide better debugging and logging capabilities, middleware can be very useful.</p> </li> </ul>"},{"location":"frontend/state-management/middleware/#when-do-you-not-need-middleware","title":"When Do You Not Need Middleware?","text":"<ul> <li> <p>Simple Applications:</p> <p>For simple applications with straightforward state management and no asynchronous operations, middleware might be overkill.</p> </li> <li> <p>Local State Management:</p> <p>If your state management needs are limited to a few components, using local component state and React's context API might be sufficient.</p> </li> </ul>"},{"location":"frontend/state-management/middleware/#example","title":"Example","text":"<p>Let's consider a simple example using redux-thunk to handle an asynchronous API call.</p>"},{"location":"frontend/state-management/middleware/#without-middleware-synchronous","title":"Without Middleware (Synchronous)","text":"<pre><code>// actions.js\nexport const increment = () =&gt; ({\n  type: 'INCREMENT'\n});\n\n// reducer.js\nconst counter = (state = 0, action) =&gt; {\n  switch (action.type) {\n    case 'INCREMENT':\n      return state + 1;\n    default:\n      return state;\n  }\n};\n</code></pre>"},{"location":"frontend/state-management/middleware/#with-middleware-asynchronous","title":"With Middleware (Asynchronous)","text":"<pre><code>// actions.js\nexport const fetchUserData = () =&gt; {\n  return async (dispatch) =&gt; {\n    dispatch({ type: 'FETCH_USER_REQUEST' });\n    try {\n      const response = await fetch('https://api.example.com/user');\n      const data = await response.json();\n      dispatch({ type: 'FETCH_USER_SUCCESS', payload: data });\n    } catch (error) {\n      dispatch({ type: 'FETCH_USER_FAILURE', error });\n    }\n  };\n};\n\n// reducer.js\nconst user = (state = { data: null, loading: false, error: null }, action) =&gt; {\n  switch (action.type) {\n    case 'FETCH_USER_REQUEST':\n      return { ...state, loading: true, error: null };\n    case 'FETCH_USER_SUCCESS':\n      return { ...state, loading: false, data: action.payload };\n    case 'FETCH_USER_FAILURE':\n      return { ...state, loading: false, error: action.error };\n    default:\n      return state;\n  }\n};\n</code></pre> <p>In this example, redux-thunk middleware allows us to handle the asynchronous API call within the action creators, making it easier to manage the state transitions related to fetching user data.</p>"},{"location":"frontend/state-management/middleware/#summary","title":"Summary","text":"<p>Middleware in React (typically used with Redux) is essential for managing complex state transitions, especially when dealing with asynchronous operations. It extends the capabilities of the Redux store, allowing for enhanced dispatching, centralized error handling, and better debugging. While it's invaluable for complex applications, simpler applications might not need middleware.</p>"},{"location":"frontend/state-management/mobx/intro/","title":"Intro","text":"<p>mobx</p>"},{"location":"frontend/state-management/recoil/intro/","title":"Intro","text":"<p>recoil</p>"},{"location":"frontend/state-management/redux/folder-structure/","title":"Folder Structure","text":"<p>Application Structure for React.js</p>"},{"location":"frontend/state-management/redux/folder-structure/#redux-thunk","title":"Redux Thunk","text":"<p>To use an API in a React application with Redux Thunk, you'll need to follow these steps:</p> <ol> <li> <p>Set up Redux Thunk: Ensure you have Redux and Redux Thunk installed and configured in your React application.</p> </li> <li> <p>Create an API Service: Create a file to manage your API calls, typically using a library like axios or fetch.</p> </li> <li> <p>Create Action Types: Define the action types for your API calls.</p> </li> <li> <p>Create Actions: Use Redux Thunk to create asynchronous actions that dispatch the appropriate actions based on the API response.</p> </li> <li> <p>Create Reducers: Create reducers to handle the actions and update the state accordingly.</p> </li> <li> <p>Connect Redux to React Components: Use <code>connect</code> or hooks (<code>useSelector</code> and <code>useDispatch</code>) to connect your React components to the Redux store.</p> </li> </ol>"},{"location":"frontend/state-management/redux/folder-structure/#set-up-redux-thunk","title":"Set up Redux Thunk","text":"<pre><code>npm install redux react-redux redux-thunk axios\n</code></pre>"},{"location":"frontend/state-management/redux/folder-structure/#basic","title":"Basic","text":"<pre><code>my-app/\n\u251c\u2500\u2500 node_modules/\n\u251c\u2500\u2500 public/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 actions/\n\u2502   \u2502   \u251c\u2500\u2500 actionTypes.js\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u251c\u2500\u2500 api/\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u251c\u2500\u2500 components/\n\u2502   \u2502   \u2514\u2500\u2500 DataComponent.js\n\u2502   \u251c\u2500\u2500 reducers/\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u251c\u2500\u2500 store/\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u251c\u2500\u2500 App.js\n\u2502   \u251c\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 index.css\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 package-lock.json\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"frontend/state-management/redux/folder-structure/#folder-structure-explanation","title":"Folder Structure Explanation","text":"<ul> <li> <p>actions/: Contains action types and action creators.</p> <ul> <li>actionTypes.js: Defines the action types.</li> <li>index.js: Contains action creators using Redux Thunk.</li> </ul> </li> <li> <p>api/: Contains API service functions.</p> <ul> <li>index.js: Defines the functions to make API calls (e.g., using axios).</li> </ul> </li> <li> <p>components/: Contains React components.</p> <ul> <li>DataComponent.js: Example component that uses Redux Thunk to fetch and display data.</li> </ul> </li> <li> <p>reducers/: Contains Redux reducers.</p> <ul> <li>index.js: Combines and exports all the reducers.</li> </ul> </li> <li> <p>store/: Contains the Redux store configuration.</p> <ul> <li>index.js: Sets up the Redux store with Thunk middleware.</li> </ul> </li> <li> <p>App.js: Main app component.</p> </li> <li> <p>index.js: Entry point of the application, where you set up React and Redux.</p> </li> <li> <p>index.css: Global CSS file for styling.</p> </li> </ul>"},{"location":"frontend/state-management/redux/folder-structure/#example-files","title":"Example Files","text":"Example actions/api/components/reducers/store/App.jsindex.js actionTypes.jsindex.js <pre><code>export const FETCH_DATA_REQUEST = 'FETCH_DATA_REQUEST';\nexport const FETCH_DATA_SUCCESS = 'FETCH_DATA_SUCCESS';\nexport const FETCH_DATA_FAILURE = 'FETCH_DATA_FAILURE';\n</code></pre> <pre><code>import {\n    FETCH_DATA_REQUEST,\n    FETCH_DATA_SUCCESS,\n    FETCH_DATA_FAILURE,\n} from './actionTypes';\nimport { fetchData } from '../api';\n\nexport const fetchDataRequest = () =&gt; ({\n    type: FETCH_DATA_REQUEST,\n});\n\nexport const fetchDataSuccess = (data) =&gt; ({\n    type: FETCH_DATA_SUCCESS,\n    payload: data,\n});\n\nexport const fetchDataFailure = (error) =&gt; ({\n    type: FETCH_DATA_FAILURE,\n    payload: error,\n});\n\nexport const fetchDataThunk = () =&gt; {\n    return (dispatch) =&gt; {\n        dispatch(fetchDataRequest());\n        fetchData()\n            .then((response) =&gt; {\n                dispatch(fetchDataSuccess(response.data));\n            })\n            .catch((error) =&gt; {\n                dispatch(fetchDataFailure(error.message));\n            });\n    };\n};\n</code></pre> index.js <pre><code>import axios from 'axios';\n\nconst API_URL = 'https://api.example.com';\n\nexport const fetchData = () =&gt; {\n    return axios.get(`${API_URL}/data`);\n};\n</code></pre> DataComponent.js <pre><code>import React, { useEffect } from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { fetchDataThunk } from '../actions';\n\nconst DataComponent = () =&gt; {\n    const dispatch = useDispatch();\n    const dataState = useSelector((state) =&gt; state.data);\n\n    useEffect(() =&gt; {\n        dispatch(fetchDataThunk());\n    }, [dispatch]);\n\n    return (\n        &lt;div&gt;\n            {dataState.loading ? (\n                &lt;p&gt;Loading...&lt;/p&gt;\n            ) : dataState.error ? (\n                &lt;p&gt;Error: {dataState.error}&lt;/p&gt;\n            ) : (\n                &lt;ul&gt;\n                {dataState.data.map((item) =&gt; (\n                    &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;\n                ))}\n                &lt;/ul&gt;\n            )}\n        &lt;/div&gt;\n    );\n};\n\nexport default DataComponent;\n</code></pre> index.js <pre><code>import {\n    FETCH_DATA_REQUEST,\n    FETCH_DATA_SUCCESS,\n    FETCH_DATA_FAILURE,\n} from '../actions/actionTypes';\n\nconst initialState = {\n    loading: false,\n    data: [],\n    error: '',\n};\n\nconst dataReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case FETCH_DATA_REQUEST:\n            return {\n                ...state,\n                loading: true,\n            };\n        case FETCH_DATA_SUCCESS:\n            return {\n                loading: false,\n                data: action.payload,\n                error: '',\n            };\n        case FETCH_DATA_FAILURE:\n            return {\n                loading: false,\n                data: [],\n                error: action.payload,\n            };\n        default:\n            return state;\n    }\n};\n\nexport default combineReducers({\n    data: dataReducer,\n});\n</code></pre> index.js <pre><code>import { createStore, applyMiddleware, combineReducers } from 'redux';\nimport thunk from 'redux-thunk';\nimport dataReducer from '../reducers';\n\nconst rootReducer = combineReducers({\n    data: dataReducer,\n});\n\nconst store = createStore(rootReducer, applyMiddleware(thunk));\n\nexport default store;\n</code></pre> <pre><code>import React from 'react';\nimport DataComponent from './components/DataComponent';\n\nconst App = () =&gt; (\n    &lt;div className=\"App\"&gt;\n        &lt;DataComponent /&gt;\n    &lt;/div&gt;\n);\n\nexport default App;\n</code></pre> <pre><code>import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport store from './store';\nimport App from './App';\nimport './index.css';\n\nReactDOM.render(\n    &lt;Provider store={store}&gt;\n        &lt;App /&gt;\n    &lt;/Provider&gt;,\n    document.getElementById('root')\n);\n\n// or\n\nReactDOM.createRoot(document.getElementById('root')).render(\n    &lt;React.StrictMode&gt;\n        &lt;Provider store={store}&gt;\n            &lt;App /&gt;\n        &lt;/Provider&gt;\n    &lt;/React.StrictMode&gt;\n);\n</code></pre> <p>This structure helps you organize your code in a modular and maintainable way. Each part of your application is separated by its responsibility, making it easier to manage and scale.</p>"},{"location":"frontend/state-management/redux/folder-structure/#intermediate-example","title":"Intermediate Example","text":"<pre><code>src/\n\u251c\u2500\u2500 api/\n\u2502   \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 components/\n\u2502   \u2514\u2500\u2500 DataComponent.js\n\u251c\u2500\u2500 redux/\n\u2502   \u251c\u2500\u2500 actions/\n\u2502   \u2502   \u251c\u2500\u2500 actionTypes.js\n\u2502   \u2502   \u2514\u2500\u2500 dataActions.js\n\u2502   \u251c\u2500\u2500 reducers/\n\u2502   \u2502   \u251c\u2500\u2500 dataReducer.js\n\u2502   \u2502   \u2514\u2500\u2500 rootReducer.js\n\u2502   \u251c\u2500\u2500 store/\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 selectors/\n\u2502       \u2514\u2500\u2500 dataSelectors.js\n\u251c\u2500\u2500 App.js\n\u251c\u2500\u2500 index.js\n\u251c\u2500\u2500 index.css\n\u2514\u2500\u2500 utils/\n    \u2514\u2500\u2500 apiHelpers.js\n</code></pre>"},{"location":"frontend/state-management/redux/folder-structure/#folder-structure-explanation_1","title":"Folder Structure Explanation","text":"<ul> <li> <p>api/: Contains files related to API calls.</p> <ul> <li>index.js: Manages API requests.</li> </ul> </li> <li> <p>components/: Contains reusable React components.</p> <ul> <li>DataComponent.js: Example component.</li> </ul> </li> <li> <p>redux/: Contains all Redux-related logic.</p> <ul> <li>actions/: Contains action types and action creators.<ul> <li>actionTypes.js: Defines action types.</li> <li>dataActions.js: Contains action creators related to data.</li> </ul> </li> <li>reducers/: Contains reducer functions.<ul> <li>dataReducer.js: Reducer for data-related actions.</li> <li>rootReducer.js: Combines all reducers.</li> </ul> </li> <li>store/: Contains the Redux store configuration.<ul> <li>index.js: Sets up the Redux store with middleware.</li> </ul> </li> <li>selectors/: Contains selector functions.<ul> <li>dataSelectors.js: Selectors for accessing data state.</li> </ul> </li> </ul> </li> <li> <p>utils/: Contains utility functions and helpers.</p> <ul> <li>apiHelpers.js: Helper functions for API calls.</li> </ul> </li> </ul>"},{"location":"frontend/state-management/redux/folder-structure/#example-files_1","title":"Example Files","text":"redux/ /actions//reducers//store//selectors/ /actionTypes.js/dataActions.js <pre><code>export const FETCH_DATA_REQUEST = 'FETCH_DATA_REQUEST';\nexport const FETCH_DATA_SUCCESS = 'FETCH_DATA_SUCCESS';\nexport const FETCH_DATA_FAILURE = 'FETCH_DATA_FAILURE';\n</code></pre> <pre><code>import {\n    FETCH_DATA_REQUEST,\n    FETCH_DATA_SUCCESS,\n    FETCH_DATA_FAILURE,\n} from './actionTypes';\nimport { fetchData } from '../../api';\n\nexport const fetchDataRequest = () =&gt; ({\n    type: FETCH_DATA_REQUEST,\n});\n\nexport const fetchDataSuccess = (data) =&gt; ({\n    type: FETCH_DATA_SUCCESS,\n    payload: data,\n});\n\nexport const fetchDataFailure = (error) =&gt; ({\n    type: FETCH_DATA_FAILURE,\n    payload: error,\n});\n\nexport const fetchDataThunk = () =&gt; {\n    return (dispatch) =&gt; {\n        dispatch(fetchDataRequest());\n        fetchData()\n            .then((response) =&gt; {\n                dispatch(fetchDataSuccess(response.data));\n            })\n            .catch((error) =&gt; {\n                dispatch(fetchDataFailure(error.message));\n            });\n    };\n};\n</code></pre> /dataReducer.js/rootReducer.js <pre><code>import {\n    FETCH_DATA_REQUEST,\n    FETCH_DATA_SUCCESS,\n    FETCH_DATA_FAILURE,\n} from '../actions/actionTypes';\n\nconst initialState = {\n    loading: false,\n    data: [],\n    error: '',\n};\n\nconst dataReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case FETCH_DATA_REQUEST:\n            return {\n                ...state,\n                loading: true,\n            };\n        case FETCH_DATA_SUCCESS:\n            return {\n                loading: false,\n                data: action.payload,\n                error: '',\n            };\n        case FETCH_DATA_FAILURE:\n            return {\n                loading: false,\n                data: [],\n                error: action.payload,\n            };\n        default:\n            return state;\n    }\n};\n\nexport default dataReducer;\n</code></pre> <pre><code>import { combineReducers } from 'redux';\nimport dataReducer from './dataReducer';\n\nconst rootReducer = combineReducers({\n    data: dataReducer,\n});\n\nexport default rootReducer;\n</code></pre> /index.js <pre><code>import { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport rootReducer from '../reducers/rootReducer';\n\nconst store = createStore(rootReducer, applyMiddleware(thunk));\n\nexport default store;\n</code></pre> /dataSelectors.js <pre><code>export const getDataState = (state) =&gt; state.data;\nexport const getData = (state) =&gt; getDataState(state).data;\nexport const getDataLoading = (state) =&gt; getDataState(state).loading;\nexport const getDataError = (state) =&gt; getDataState(state).error;\n</code></pre>"},{"location":"frontend/state-management/redux/folder-structure/#connecting-components","title":"Connecting Components","text":"Example components/App.jsindex.js DataComponent.js<pre><code>import React, { useEffect } from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { fetchDataThunk } from '../redux/actions/dataActions';\nimport { getData, getDataLoading, getDataError } from '../redux/selectors/dataSelectors';\n\nconst DataComponent = () =&gt; {\n    const dispatch = useDispatch();\n    const data = useSelector(getData);\n    const loading = useSelector(getDataLoading);\n    const error = useSelector(getDataError);\n\n    useEffect(() =&gt; {\n        dispatch(fetchDataThunk());\n    }, [dispatch]);\n\n    return (\n        &lt;div&gt;\n            {loading ? (\n                &lt;p&gt;Loading...&lt;/p&gt;\n            ) : error ? (\n                &lt;p&gt;Error: {error}&lt;/p&gt;\n            ) : (\n                &lt;ul&gt;\n                {data.map((item) =&gt; (\n                    &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;\n                ))}\n                &lt;/ul&gt;\n            )}\n        &lt;/div&gt;\n    );\n};\n\nexport default DataComponent;\n</code></pre> <pre><code>//App and index.js\nimport React from 'react';\nimport DataComponent from './components/DataComponent';\n\nconst App = () =&gt; (\n    &lt;div className=\"App\"&gt;\n        &lt;DataComponent /&gt;\n    &lt;/div&gt;\n);\n\nexport default App;\n</code></pre> <pre><code>import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport { Provider } from 'react-redux';\nimport store from './redux/store';\nimport App from './App';\nimport './index.css';\n\nReactDOM.createRoot(document.getElementById('root')).render(\n    &lt;React.StrictMode&gt;\n        &lt;Provider store={store}&gt;\n            &lt;App /&gt;\n        &lt;/Provider&gt;\n    &lt;/React.StrictMode&gt;\n);\n</code></pre> <p>This structure helps maintain a clear separation of concerns, making the codebase easier to manage and scale as the application grows. It also adheres to best practices, making it easier for other developers to understand and contribute to the project.</p>"},{"location":"frontend/state-management/redux/folder-structure/#advanced-example","title":"Advanced Example","text":"<pre><code>src/\n\u251c\u2500\u2500 api/\n\u2502   \u2514\u2500\u2500 user.js\n\u251c\u2500\u2500 components/\n\u2502   \u2514\u2500\u2500 UserComponent.js\n\u251c\u2500\u2500 redux/\n\u2502   \u251c\u2500\u2500 actions/\n\u2502   \u2502   \u251c\u2500\u2500 actionTypes.js\n\u2502   \u2502   \u2514\u2500\u2500 userActions.js\n\u2502   \u251c\u2500\u2500 reducers/\n\u2502   \u2502   \u251c\u2500\u2500 entitiesReducer.js\n\u2502   \u2502   \u251c\u2500\u2500 usersReducer.js\n\u2502   \u2502   \u2514\u2500\u2500 rootReducer.js\n\u2502   \u251c\u2500\u2500 selectors/\n\u2502   \u2502   \u2514\u2500\u2500 userSelectors.js\n\u2502   \u251c\u2500\u2500 store/\n\u2502   \u2502   \u2514\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 utils/\n\u2502       \u251c\u2500\u2500 normalize.js\n\u2502       \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 App.js\n\u251c\u2500\u2500 index.js\n\u251c\u2500\u2500 index.css\n\u2514\u2500\u2500 utils/\n    \u2514\u2500\u2500 apiHelpers.js\n</code></pre>"},{"location":"frontend/state-management/redux/folder-structure/#action","title":"Action","text":"redux/actions/ actionTypes.jsuserActions.js <pre><code>export const FETCH_USER_REQUEST = 'FETCH_USER_REQUEST';\nexport const FETCH_USER_SUCCESS = 'FETCH_USER_SUCCESS';\nexport const FETCH_USER_FAILURE = 'FETCH_USER_FAILURE';\nexport const CREATE_USER_REQUEST = 'CREATE_USER_REQUEST';\nexport const CREATE_USER_SUCCESS = 'CREATE_USER_SUCCESS';\nexport const CREATE_USER_FAILURE = 'CREATE_USER_FAILURE';\n// Other action types...\n</code></pre> <pre><code>import {\n    FETCH_USER_REQUEST,\n    FETCH_USER_SUCCESS,\n    FETCH_USER_FAILURE,\n    CREATE_USER_REQUEST,\n    CREATE_USER_SUCCESS,\n    CREATE_USER_FAILURE,\n} from './actionTypes';\n\nimport {\n    getUserById,\n    createUser,\n    updateUser,\n    deleteUser,\n    searchUsers,\n} from '../../api/user';\n\nimport { normalizeUserData } from '../utils/normalize';\n\n// Fetch user by ID\nexport const fetchUser = (id) =&gt; {\n    return async (dispatch) =&gt; {\n        dispatch({ type: FETCH_USER_REQUEST });\n\n        try {\n            const response = await getUserById(id);\n            const normalizedData = normalizeUserData(response.data);\n            dispatch({ type: FETCH_USER_SUCCESS, payload: normalizedData });\n        } catch (error) {\n            dispatch({ type: FETCH_USER_FAILURE, payload: error.message });\n        }\n    };\n};\n\n// Create user\nexport const addUser = (userData) =&gt; {\n    return async (dispatch) =&gt; {\n        dispatch({ type: CREATE_USER_REQUEST });\n\n        try {\n            const response = await createUser(userData);\n            const normalizedData = normalizeUserData(response.data);\n            dispatch({ type: CREATE_USER_SUCCESS, payload: normalizedData });\n        } catch (error) {\n            dispatch({ type: CREATE_USER_FAILURE, payload: error.message });\n        }\n    };\n};\n\n// Update user\nexport const modifyUser = (id, userData) =&gt; {\n    return async (dispatch) =&gt; {\n        dispatch({ type: UPDATE_USER_REQUEST });\n\n        try {\n            const response = await updateUser(id, userData);\n            const normalizedData = normalizeUserData(response.data);\n            dispatch({ type: UPDATE_USER_SUCCESS, payload: normalizedData });\n        } catch (error) {\n            dispatch({ type: UPDATE_USER_FAILURE, payload: error.message });\n        }\n    };\n};\n\n// Delete user\nexport const removeUser = (id) =&gt; {\n    return async (dispatch) =&gt; {\n        dispatch({ type: DELETE_USER_REQUEST });\n\n        try {\n            await deleteUser(id);\n            dispatch({ type: DELETE_USER_SUCCESS, payload: id });\n        } catch (error) {\n            dispatch({ type: DELETE_USER_FAILURE, payload: error.message });\n        }\n    };\n};\n\n// Search users\nexport const findUsers = (queryParams) =&gt; {\n    return async (dispatch) =&gt; {\n        dispatch({ type: SEARCH_USERS_REQUEST });\n\n        try {\n            const response = await searchUsers(queryParams);\n            const normalizedData = normalizeUserData(response.data);\n            dispatch({ type: SEARCH_USERS_SUCCESS, payload: normalizedData });\n        } catch (error) {\n            dispatch({ type: SEARCH_USERS_FAILURE, payload: error.message });\n        }\n    };\n};\n</code></pre>"},{"location":"frontend/state-management/redux/folder-structure/#reducers","title":"Reducers","text":"redux/reducers/ entitiesReducer.jsusersReducer.jsrootReducer.js <p>This reducer handles the normalization of entities, which helps in managing relationships between different entities.</p> <pre><code>import { combineReducers } from 'redux';\nimport {\n    FETCH_USER_SUCCESS,\n    CREATE_USER_SUCCESS,\n    UPDATE_USER_SUCCESS,\n    SEARCH_USERS_SUCCESS,\n} from '../actions/actionTypes';\n\nconst initialState = {\n    users: {},\n};\n\nconst users = (state = initialState.users, action) =&gt; {\n    switch (action.type) {\n        case FETCH_USER_SUCCESS:\n        case CREATE_USER_SUCCESS:\n        case UPDATE_USER_SUCCESS:\n        case SEARCH_USERS_SUCCESS:\n            return {\n                ...state,\n                ...action.payload.entities.users,\n            };\n        default:\n            return state;\n    }\n};\n\nexport default combineReducers({\n    users,\n});\n</code></pre> <p>This reducer handles the specific logic related to users, such as loading states and errors.</p> <pre><code>import {\n    FETCH_USER_REQUEST,\n    FETCH_USER_SUCCESS,\n    FETCH_USER_FAILURE,\n    CREATE_USER_REQUEST,\n    CREATE_USER_SUCCESS,\n    CREATE_USER_FAILURE,\n    UPDATE_USER_REQUEST,\n    UPDATE_USER_SUCCESS,\n    UPDATE_USER_FAILURE,\n    DELETE_USER_REQUEST,\n    DELETE_USER_SUCCESS,\n    DELETE_USER_FAILURE,\n    SEARCH_USERS_REQUEST,\n    SEARCH_USERS_SUCCESS,\n    SEARCH_USERS_FAILURE,\n} from '../actions/actionTypes';\n\nconst initialState = {\n    loading: false,\n    error: null,\n    allIds: [],\n    currentUser: null,\n};\n\nconst usersReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case FETCH_USER_REQUEST:\n        case CREATE_USER_REQUEST:\n        case UPDATE_USER_REQUEST:\n        case DELETE_USER_REQUEST:\n        case SEARCH_USERS_REQUEST:\n            return {\n                ...state,\n                loading: true,\n                error: null,\n            };\n        case FETCH_USER_SUCCESS:\n            return {\n                ...state,\n                loading: false,\n                currentUser: action.payload.result,\n            };\n        case CREATE_USER_SUCCESS:\n            return {\n                ...state,\n                loading: false,\n                allIds: [...state.allIds, action.payload.result],\n            };\n        case UPDATE_USER_SUCCESS:\n            return {\n                ...state,\n                loading: false,\n            };\n        case DELETE_USER_SUCCESS:\n            return {\n                ...state,\n                loading: false,\n                allIds: state.allIds.filter((id) =&gt; id !== action.payload),\n            };\n        case SEARCH_USERS_SUCCESS:\n            return {\n                ...state,\n                loading: false,\n                allIds: action.payload.result,\n            };\n        case FETCH_USER_FAILURE:\n        case CREATE_USER_FAILURE:\n        case UPDATE_USER_FAILURE:\n        case DELETE_USER_FAILURE:\n        case SEARCH_USERS_FAILURE:\n            return {\n                ...state,\n                loading: false,\n                error: action.payload,\n            };\n        default:\n            return state;\n    }\n};\n\nexport default usersReducer;\n</code></pre> <p>Combine the entity and user-specific reducers to create the root reducer.</p> <pre><code>import { combineReducers } from 'redux';\nimport entitiesReducer from './entitiesReducer';\nimport usersReducer from './usersReducer';\n\nconst rootReducer = combineReducers({\n    entities: entitiesReducer,\n    users: usersReducer,\n});\n\nexport default rootReducer;\n</code></pre>"},{"location":"frontend/state-management/redux/folder-structure/#normalization","title":"Normalization","text":"<p>Normalize the data received from the API to ensure it is stored in a flat structure, making it easier to manage and update.</p> redux/utils/normalize.js <pre><code>import { normalize, schema } from 'normalizr';\n\n// Define a user schema\nconst user = new schema.Entity('users');\n\n// Define a function to normalize user data\nexport const normalizeUserData = (data) =&gt; {\n    return normalize(data, user);\n};\n</code></pre> <p>Selectors</p> <p>Use selectors to access and derive data from the state, keeping your components clean and focused on rendering.</p> redux/selectors/userSelectors.js <pre><code>import { createSelector } from 'reselect';\n\nexport const getUsersState = (state) =&gt; state.users;\nexport const getEntitiesState = (state) =&gt; state.entities;\n\nexport const getAllUserIds = createSelector(\n    [getUsersState],\n    (usersState) =&gt; usersState.allIds\n);\n\nexport const getUserById = (state, userId) =&gt;\ngetEntitiesState(state).users[userId];\n\nexport const getAllUsers = createSelector(\n    [getAllUserIds, getEntitiesState],\n    (allIds, entities) =&gt; allIds.map((id) =&gt; entities.users[id])\n);\n\nexport const getCurrentUser = createSelector(\n    [getUsersState, getEntitiesState],\n    (usersState, entities) =&gt; entities.users[usersState.currentUser]\n);\n</code></pre>"},{"location":"frontend/state-management/redux/folder-structure/#connecting-components_1","title":"Connecting Components","text":"components/UserComponent.js <pre><code>import React, { useEffect } from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { fetchUser, addUser, modifyUser, removeUser, findUsers } from '../redux/actions/userActions';\nimport { getAllUsers, getCurrentUser, getUserLoading, getUserError } from '../redux/selectors/userSelectors';\n\nconst UserComponent = () =&gt; {\n    const dispatch = useDispatch();\n    const users = useSelector(getAllUsers);\n    const currentUser = useSelector(getCurrentUser);\n    const loading = useSelector(getUserLoading);\n    const error = useSelector(getUserError);\n\n    useEffect(() =&gt; {\n        dispatch(fetchUser(1)); // Fetch user with ID 1\n    }, [dispatch]);\n\n    const handleAddUser = (userData) =&gt; {\n        dispatch(addUser(userData));\n    };\n\n    const handleUpdateUser = (id, userData) =&gt; {\n        dispatch(modifyUser(id, userData));\n    };\n\n    const handleDeleteUser = (id) =&gt; {\n        dispatch(removeUser(id));\n    };\n\n    const handleSearchUsers = (queryParams) =&gt; {\n        dispatch(findUsers(queryParams));\n    };\n\n    return (\n        &lt;div&gt;\n            {loading ? (\n                &lt;p&gt;Loading...&lt;/p&gt;\n            ) : error ? (\n                &lt;p&gt;Error: {error}&lt;/p&gt;\n            ) : (\n                &lt;div&gt;\n                &lt;h1&gt;User Details&lt;/h1&gt;\n                {currentUser &amp;&amp; &lt;div&gt;{currentUser.name}&lt;/div&gt;}\n                &lt;h1&gt;All Users&lt;/h1&gt;\n                &lt;ul&gt;\n                    {users.map((u) =&gt; (\n                    &lt;li key={u.id}&gt;{u.name}&lt;/li&gt;\n                    ))}\n                &lt;/ul&gt;\n                &lt;/div&gt;\n            )}\n            &lt;button onClick={() =&gt; handleAddUser({ name: 'New User' })}&gt;Add User&lt;/button&gt;\n            &lt;button onClick={() =&gt; handleUpdateUser(1, { name: 'Updated User' })}&gt;Update User&lt;/button&gt;\n            &lt;button onClick={() =&gt; handleDeleteUser(1)}&gt;Delete User&lt;/button&gt;\n            &lt;button onClick={() =&gt; handleSearchUsers({ name: 'John' })}&gt;Search Users&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default UserComponent;\n</code></pre> <p>Store</p> redux/store/index.js <pre><code>import { createStore, applyMiddleware } from 'redux';\nimport { composeWithDevTools } from 'redux-devtools-extension';\nimport thunk from 'redux-thunk';\nimport rootReducer from '../reducers/rootReducer';\n\nconst store = createStore(rootReducer, composeWithDevTools(applyMiddleware(thunk)));\n\nexport default store;\n</code></pre> <p>This structure allows for scalability, as each part of the state is managed independently and can be easily extended with new entities or additional logic. The use of selectors ensures that the component logic remains clean and focused on rendering, while the normalization of data helps manage relationships and avoid nested state.</p>"},{"location":"frontend/state-management/redux/intro/","title":"Intro","text":"<p>folder</p>"},{"location":"frontend/state-management/redux/action/intro/","title":"Intro","text":""},{"location":"frontend/state-management/redux/action/intro/#what-is-an-action-in-redux","title":"What is an Action in Redux?","text":"<p>In Redux, an action is a plain JavaScript object that represents an event or change that happened in the application. It is the only source of information for the store, meaning all state changes in the store are triggered by actions.</p> <p>An action has two key properties:</p> <ul> <li>type: A string that defines the type of action (e.g., 'ADD_TODO', 'FETCH_DATA_SUCCESS'). This is mandatory.</li> <li>payload (optional): An additional data object that contains the information needed to perform the action (e.g., the todo item or fetched data).</li> </ul> Basic Example of an Action <pre><code>// Simple action to add a todo\nconst addTodoAction = {\n    type: 'ADD_TODO',               // Mandatory 'type' field\n    payload: {\n        text: 'Learn Redux',        // Optional 'payload' field containing data\n        id: 1\n    }\n};\n</code></pre> <p>The type field tells the Redux store what happened, and the payload field holds the data related to the action.</p> How Actions Work in Redux <ol> <li>Dispatch: Actions are dispatched from the UI or other parts of the app.</li> <li>Reducer: The action is passed to the reducer, which determines how the state should change based on the action's type.</li> <li>State Update: The store updates the state according to the reducer's instructions.</li> </ol>"},{"location":"frontend/state-management/redux/action/intro/#action-creator","title":"Action Creator","text":"<p>An action creator is a function that returns an action. It simplifies creating actions and helps avoid manually creating action objects.</p> <pre><code>// Action Creator to add a todo\nconst addTodo = (todo) =&gt; ({\n    type: 'ADD_TODO',\n    payload: { todo }\n});\n</code></pre> Using Action in a Component <pre><code>import React from 'react';\nimport { useDispatch } from 'react-redux';\nimport { addTodo } from './actions/todoActions';\n\nconst TodoComponent = () =&gt; {\n    const dispatch = useDispatch();\n\n    const handleAddTodo = () =&gt; {\n        const newTodo = { text: 'Learn Redux Basics', id: 1 };\n        dispatch(addTodo(newTodo)); // Dispatching the action\n    };\n\n    return (\n        &lt;button onClick={handleAddTodo}&gt;Add Todo&lt;/button&gt;\n    );\n};\n</code></pre> Simple Reducer Example <pre><code>const todoReducer = (state = { todos: [] }, action) =&gt; {\n    switch (action.type) {\n        case 'ADD_TODO':\n            return {\n                ...state,\n                todos: [...state.todos, action.payload.todo],\n            };\n        default:\n            return state;\n    }\n};\n</code></pre>"},{"location":"frontend/state-management/redux/action/intro/#difference-between-plain-action-action-creator","title":"Difference between plain action &amp; action creator","text":"<p>In Redux, actions and action creators are related but distinct concepts:</p>"},{"location":"frontend/state-management/redux/action/intro/#action","title":"Action","text":"<p>An action is a plain JavaScript object that describes a change or event in your application. It has at least one required property:</p> <ul> <li>type: A string that specifies the action type (e.g., 'ADD_TODO').</li> </ul> <p>Optionally, it can also include other properties:</p> <ul> <li>payload: Additional data needed to describe the action (e.g., the new todo item).</li> </ul> Example of an Action:<pre><code>// actions/todoActions.js (if you want to keep it organized)\nexport const addTodoAction = {\n    type: 'ADD_TODO',\n    payload: {\n        text: 'Learn Redux',\n        id: 1\n    }\n}\n// Usage in component\nconst handleAddTodo = () =&gt; {\n    dispatch(addTodoAction); // Dispatch the plain action object\n};\n</code></pre>"},{"location":"frontend/state-management/redux/action/intro/#action-creator_1","title":"Action Creator","text":"<p>An action creator is a function that creates and returns an action. It abstracts away the action object creation process and makes it easier to generate actions with the right structure.</p> <p>Action creators simplify creating actions and are useful for:</p> <ul> <li>Consistent action creation.</li> <li>Dynamically generating actions with specific payloads.</li> <li>Avoiding typos in action types.</li> </ul> <pre><code>// actions/todoActions.js (if you want to keep it organized)\nconst addTodo = (todo) =&gt; ({\n    type: 'ADD_TODO',\n    payload: todo\n});\n\n// Usage\nconst handleAddTodo = () =&gt; {\n  const newTodo = { text: 'Learn Redux', id: 1 };\n  dispatch(addTodo(newTodo)); // Using action creator\n};\n</code></pre> Summary <ul> <li>Action: A plain object that represents an event or change in the application. It has a type and optionally other properties like payload.</li> <li>Action Creator: A function that returns an action object. It helps in creating actions with the right structure and potentially dynamic data.</li> </ul> <p>In practice, action creators are commonly used in Redux applications because they provide a clear and consistent way to create actions and often handle complex logic for creating action objects.</p>"},{"location":"frontend/state-management/redux/action/intro/#tips-and-tricks-for-redux-actions","title":"Tips and Tricks for Redux Actions","text":"<ol> <li> <p>Action Types as Constants:</p> <ul> <li> <p>Use constants for action types to prevent typos and make refactoring easier.</p> <pre><code>export const ADD_TODO = 'ADD_TODO';\n</code></pre> </li> </ul> </li> <li> <p>Batched Actions:</p> <ul> <li> <p>Instead of dispatching multiple actions in sequence, you can batch them together.</p> <pre><code>const addTodoAndLog = (todo) =&gt; {\n    return (dispatch) =&gt; {\n        dispatch(addTodoAction(todo));\n        dispatch(logAction(todo));\n    };\n};\n</code></pre> </li> </ul> </li> </ol>"},{"location":"frontend/state-management/redux/reducer/example/","title":"Example","text":"<p>Facebook's developers follow a modular and organized approach to manage action types in their projects. Here is a closer look at how Facebook's React and Redux codebases might handle action types, inspired by best practices from projects like React and React Native.</p>"},{"location":"frontend/state-management/redux/reducer/example/#directory-structure","title":"Directory Structure","text":"<p>Let's assume a structure similar to how a large project at Facebook might be organized:</p> <pre><code>src/\n\u251c\u2500\u2500 actions/\n\u2502   \u251c\u2500\u2500 userActions.js\n\u2502   \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 actionTypes/\n\u2502   \u251c\u2500\u2500 userActionTypes.js\n\u2502   \u251c\u2500\u2500 notificationActionTypes.js\n\u2502   \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 reducers/\n\u2502   \u251c\u2500\u2500 userReducer.js\n\u2502   \u251c\u2500\u2500 notificationReducer.js\n\u2502   \u2514\u2500\u2500 index.js\n\u2514\u2500\u2500 store.js\n</code></pre>"},{"location":"frontend/state-management/redux/reducer/example/#define-action-types-in-separate-files","title":"Define Action Types in Separate Files","text":"<p>Each module or domain (e.g., users, notifications) has its own action types file.</p> <p>actionTypes/userActionTypes.js</p> <pre><code>export const FETCH_USERS_REQUEST = 'FETCH_USERS_REQUEST';\nexport const FETCH_USERS_SUCCESS = 'FETCH_USERS_SUCCESS';\nexport const FETCH_USERS_FAILURE = 'FETCH_USERS_FAILURE';\n</code></pre> <p>actionTypes/notificationActionTypes.js</p> <pre><code>export const FETCH_NOTIFICATIONS_REQUEST = 'FETCH_NOTIFICATIONS_REQUEST';\nexport const FETCH_NOTIFICATIONS_SUCCESS = 'FETCH_NOTIFICATIONS_SUCCESS';\nexport const FETCH_NOTIFICATIONS_FAILURE = 'FETCH_NOTIFICATIONS_FAILURE';\n</code></pre> <p>actionTypes/index.js</p> <p>This file aggregates all the action types from different domains.</p> <pre><code>export * from './userActionTypes';\nexport * from './notificationActionTypes';\n// Export other action types as needed\n</code></pre>"},{"location":"frontend/state-management/redux/reducer/example/#define-actions","title":"Define Actions","text":"<p>Each module has its own action creators, which use the specific action types.</p> <p>actions/userActions.js</p> <pre><code>import {\n  FETCH_USERS_REQUEST,\n  FETCH_USERS_SUCCESS,\n  FETCH_USERS_FAILURE\n} from '../actionTypes';\n\n// Action creator for initiating the fetch request\nexport const fetchUsersRequest = () =&gt; ({\n  type: FETCH_USERS_REQUEST\n});\n\n// Action creator for handling successful fetch\nexport const fetchUsersSuccess = (users) =&gt; ({\n  type: FETCH_USERS_SUCCESS,\n  payload: users\n});\n\n// Action creator for handling fetch failure\nexport const fetchUsersFailure = (error) =&gt; ({\n  type: FETCH_USERS_FAILURE,\n  payload: error\n});\n\n// Thunk action creator for fetching users from API\nexport const fetchUsers = () =&gt; {\n  return async (dispatch) =&gt; {\n    dispatch(fetchUsersRequest());\n\n    try {\n      const response = await fetch('https://api.example.com/users');\n      const data = await response.json();\n\n      if (response.ok) {\n        dispatch(fetchUsersSuccess(data));\n      } else {\n        throw new Error(data.message || 'Failed to fetch users');\n      }\n    } catch (error) {\n      dispatch(fetchUsersFailure(error.message));\n    }\n  };\n};\n</code></pre> <p>actions/index.js</p> <p>This file aggregates all action creators from different modules.</p> <pre><code>export * from './userActions';\nexport * from './notificationActions';\n// Export other actions as needed\n</code></pre>"},{"location":"frontend/state-management/redux/reducer/example/#define-reducers","title":"Define Reducers","text":"<p>Each module has its own reducer, which handles the specific action types.</p> <p>reducers/userReducer.js</p> <pre><code>import {\n  FETCH_USERS_REQUEST,\n  FETCH_USERS_SUCCESS,\n  FETCH_USERS_FAILURE\n} from '../actionTypes';\n\nconst initialState = {\n  loading: false,\n  users: [],\n  error: ''\n};\n\nconst userReducer = (state = initialState, action) =&gt; {\n  switch (action.type) {\n    case FETCH_USERS_REQUEST:\n      return {\n        ...state,\n        loading: true\n      };\n    case FETCH_USERS_SUCCESS:\n      return {\n        ...state,\n        loading: false,\n        users: action.payload,\n        error: ''\n      };\n    case FETCH_USERS_FAILURE:\n      return {\n        ...state,\n        loading: false,\n        users: [],\n        error: action.payload\n      };\n    default:\n      return state;\n  }\n};\n\nexport default userReducer;\n</code></pre> <p>reducers/index.js</p> <p>This file combines all the reducers from different modules.</p> <pre><code>import { combineReducers } from 'redux';\nimport userReducer from './userReducer';\nimport notificationReducer from './notificationReducer';\n\nconst rootReducer = combineReducers({\n  user: userReducer,\n  notification: notificationReducer,\n  // Add other reducers as needed\n});\n\nexport default rootReducer;\n</code></pre>"},{"location":"frontend/state-management/redux/reducer/example/#setting-up-the-redux-store","title":"Setting Up the Redux Store","text":"<p>store.js</p> <pre><code>import { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport rootReducer from './reducers';\n\nconst store = createStore(\n  rootReducer,\n  applyMiddleware(thunk)\n);\n\nexport default store;\n</code></pre>"},{"location":"frontend/state-management/redux/reducer/example/#using-actions-in-a-component","title":"Using Actions in a Component","text":"UserList.js<pre><code>import React, { useEffect } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { fetchUsers } from './actions';\n\nconst UserList = () =&gt; {\n  const dispatch = useDispatch();\n  const { loading, users, error } = useSelector((state) =&gt; state.user);\n\n  useEffect(() =&gt; {\n    dispatch(fetchUsers());\n  }, [dispatch]);\n\n  return (\n    &lt;div&gt;\n      {loading &amp;&amp; &lt;p&gt;Loading...&lt;/p&gt;}\n      {error &amp;&amp; &lt;p&gt;Error: {error}&lt;/p&gt;}\n      &lt;ul&gt;\n        {users.map((user) =&gt; (\n          &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default UserList;\n</code></pre> <p>By modularizing the action types, actions, and reducers, the codebase remains clean, maintainable, and scalable. This approach aligns with how large teams, like those at Facebook, manage their code.</p>"},{"location":"frontend/state-management/redux/reducer/intro/","title":"Intro","text":"<p>To master the Redux reducer, you should focus on understanding its core principles and progressively advancing to more complex patterns. Here\u2019s a step-by-step guide to mastering Redux reducers:</p>"},{"location":"frontend/state-management/redux/reducer/intro/#mastering-reducer","title":"Mastering Reducer","text":"<ol> <li> <p>Understand the Basics of a Reducer</p> <ul> <li>Pure Functions: Reducers must be pure functions. They should return a new state based on the action type without modifying the original state.</li> <li>Action Types: Actions describe what happened, and reducers define how the state changes in response to those actions.</li> <li>State Immutability: Always return a new copy of the state. Use spread syntax (<code>...state</code>) or libraries like <code>immer</code> for immutability.</li> </ul> <pre><code>const initialState = { count: 0 };\n\nconst counterReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case 'INCREMENT':\n            return { ...state, count: state.count + 1 };\n        case 'DECREMENT':\n            return { ...state, count: state.count - 1 };\n        default:\n            return state;\n    }\n};\n</code></pre> </li> <li> <p>Work with Complex State</p> <p>Once comfortable with simple states, move to complex nested state management. This is common in real-world apps, where state contains objects or arrays.</p> <ul> <li>Updating nested properties: For deep nested properties, make sure you understand how to properly update them without mutating the state.</li> </ul> <pre><code>const initialState = {\n    user: { name: 'John', details: { age: 30 } }\n};\n\nconst userReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case 'UPDATE_AGE':\n            return {\n                ...state,\n                user: {\n                    ...state.user,\n                    details: {\n                        ...state.user.details,\n                        age: action.payload.age\n                    }\n                }\n            };\n        default:\n            return state;\n    }\n};\n</code></pre> </li> <li> <p>Handle Arrays in Reducers</p> <p>Understanding how to add, remove, or update items in arrays is crucial for managing lists in Redux.</p> <pre><code>const initialState = { todos: [] };\n\nconst todoReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case 'ADD_TODO':\n            return {\n                ...state,\n                todos: [...state.todos, action.payload.todo]\n            };\n        case 'REMOVE_TODO':\n            return {\n                ...state,\n                todos: state.todos.filter(todo =&gt; todo.id !== action.payload.id)\n            };\n        default:\n            return state;\n    }\n};\n</code></pre> </li> <li> <p>Refactor and Modularize Reducers</p> <p>For large applications, breaking your reducers into smaller, manageable pieces (reducer composition) is crucial.</p> <ul> <li>Combine Reducers: Use <code>combineReducers</code> to split large reducers into smaller ones.</li> </ul> <pre><code>import { combineReducers } from 'redux';\n\nconst rootReducer = combineReducers({\n    counter: counterReducer,\n    todos: todoReducer,\n});\n</code></pre> <ul> <li>Action creators: Define action creators to make your reducer more readable and maintainable.</li> </ul> <pre><code>const increment = () =&gt; ({ type: 'INCREMENT' });\nconst addTodo = (todo) =&gt; ({ type: 'ADD_TODO', payload: { todo } });\n</code></pre> </li> <li> <p>Use Middlewares (for Async Logic)</p> <p>Mastering reducers also involves handling asynchronous logic. Redux Thunk or Redux-Saga are commonly used for side effects.</p> Thunk Example: <pre><code>const fetchData = () =&gt; async (dispatch) =&gt; {\n    dispatch({ type: 'FETCH_DATA_START' });\n    try {\n        const data = await apiCall();\n        dispatch({ type: 'FETCH_DATA_SUCCESS', payload: data });\n    } catch (error) {\n        dispatch({ type: 'FETCH_DATA_FAILURE', payload: error });\n    }\n};\n</code></pre> </li> <li> <p>Learn Advanced Patterns</p> <ul> <li>Normalization of State: As your state grows, it\u2019s crucial to normalize it, particularly for collections of related data like lists of users or posts.</li> <li>Reducer Factories: For repetitive tasks, such as managing similar types of state (e.g., loading/error states), use factory functions to create reusable reducer logic.</li> </ul> <pre><code>const createLoadingReducer = (actionType) =&gt; (state = false, action) =&gt; {\n    switch (action.type) {\n        case `${actionType}_REQUEST`:\n            return true;\n        case `${actionType}_SUCCESS`:\n        case `${actionType}_FAILURE`:\n            return false;\n        default:\n            return state;\n    }\n};\n\nconst loadingReducer = createLoadingReducer('FETCH_DATA');\n</code></pre> </li> <li> <p>Immer for Simplified State Management</p> <p>Immer is a popular library that allows you to write reducers as if you're mutating the state directly while keeping it immutable under the hood.</p> <pre><code>import produce from 'immer';\n\nconst todoReducer = (state = initialState, action) =&gt; \n    produce(state, draft =&gt; {\n        switch (action.type) {\n            case 'ADD_TODO':\n                draft.todos.push(action.payload.todo);\n                break;\n            case 'REMOVE_TODO':\n                const index = draft.todos.findIndex(todo =&gt; todo.id === action.payload.id);\n                if (index !== -1) draft.todos.splice(index, 1);\n                break;\n            }\n    });\n</code></pre> </li> <li> <p>Testing Reducers</p> <p>Testing is key to mastering reducers. Write unit tests for your reducers to ensure they behave as expected.</p> <pre><code>it('should increment the count', () =&gt; {\n    const action = { type: 'INCREMENT' };\n    const initialState = { count: 0 };\n    const newState = counterReducer(initialState, action);\n    expect(newState.count).toEqual(1);\n});\n</code></pre> </li> <li> <p>Master Edge Cases</p> <ul> <li>Handle default states and unknown actions.</li> <li>Ensure your reducer is optimized and scalable, particularly when dealing with large state objects.</li> </ul> </li> <li> <p>Keep Up with Best Practices</p> <ul> <li>Regularly review Redux documentation and explore Redux Toolkit, which simplifies many Redux patterns, such as creating reducers and handling immutability.</li> </ul> <pre><code>import { createSlice } from '@reduxjs/toolkit';\n\nconst todoSlice = createSlice({\n    name: 'todos',\n    initialState: [],\n    reducers: {\n        addTodo: (state, action) =&gt; {\n            state.push(action.payload.todo);\n        },\n        removeTodo: (state, action) =&gt; {\n            return state.filter(todo =&gt; todo.id !== action.payload.id);\n        },\n    },\n});\n\nexport const { addTodo, removeTodo } = todoSlice.actions;\nexport default todoSlice.reducer;\n</code></pre> </li> </ol> <p>By mastering these steps and gradually building more complex reducers, you'll become proficient in managing state in Redux.</p>"},{"location":"frontend/state-management/redux/reducer/intro/#what-is-an-action-creator","title":"What is an Action Creator?","text":"<p>An action creator is simply a function that returns an action. Actions are plain JavaScript objects that describe what happened in your application. The action creator is responsible for constructing that action object.</p> <p>In Redux, actions must have a <code>type</code> property that indicates the type of action being performed. Additional data related to the action can be passed as <code>payload</code>.</p>"},{"location":"frontend/state-management/redux/reducer/intro/#basic-example-of-an-action-creator","title":"Basic Example of an Action Creator","text":"<p>Here's a simple action creator:</p> <pre><code>// Basic Action Creator\nconst increment = () =&gt; ({\n  type: 'INCREMENT',\n});\n</code></pre> <p>This action creator returns an object with a <code>type</code> property. When dispatched, it will tell the reducer to increment the value in the state.</p> Usage: <pre><code>// Action object returned by the action creator\n{\n    type: 'INCREMENT'\n}\n\n// Dispatch the action\nstore.dispatch(increment());\n</code></pre> With Payload (passing additional data): <pre><code>const addTodo = (todo) =&gt; ({\n    type: 'ADD_TODO',\n    payload: {\n        todo,\n    },\n});\n\n// Example usage:\nstore.dispatch(addTodo('Learn Redux'));\n\n// This returns:\n{\n    type: 'ADD_TODO',\n    payload: { todo: 'Learn Redux' }\n}\n</code></pre> <pre><code>// todoActions.js (Action File)\n\n// Action creator for adding a todo\nexport const addTodo = (todo) =&gt; ({\n    type: 'ADD_TODO',\n    payload: { todo },\n});\n\n// Action creator for deleting a todo\nexport const deleteTodo = (id) =&gt; ({\n    type: 'DELETE_TODO',\n    payload: { id },\n});\n</code></pre> <pre><code>// todoReducer.js (Reducer File)\n\nconst initialState = { todos: [] };\n\n// Reducer function for handling todo actions\nconst todoReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case 'ADD_TODO':\n            return {\n                ...state,\n                todos: [...state.todos, action.payload.todo],\n            };\n        case 'DELETE_TODO':\n            return {\n                ...state,\n                todos: state.todos.filter(todo =&gt; todo.id !== action.payload.id),\n            };\n        default:\n            return state;\n  }\n};\n\nexport default todoReducer;\n</code></pre>"},{"location":"frontend/state-management/redux/reducer/modular-reducer/","title":"Modular Reducer","text":""},{"location":"frontend/state-management/redux/reducer/modular-reducer/#define-api-urls","title":"Define API URLs","text":"apiUrls.js<pre><code>export const API_URLS = {\n    FETCH_ITEMS: '/api/items',\n    CREATE_ITEM: '/api/items',\n    // Add more URLs as needed\n};\n</code></pre>"},{"location":"frontend/state-management/redux/reducer/modular-reducer/#define-headers","title":"Define Headers","text":"headers.js<pre><code>export const DEFAULT_HEADERS = {\n    'Content-Type': 'application/json',\n    // Add more default headers if needed\n};\n</code></pre>"},{"location":"frontend/state-management/redux/reducer/modular-reducer/#define-api-request-functions","title":"Define API Request Functions","text":"api.js<pre><code>import { DEFAULT_HEADERS } from './headers';\n\nexport const getApi = async (url, headers = DEFAULT_HEADERS) =&gt; {\n  const response = await fetch(url, { headers });\n  const data = await response.json();\n\n  if (!response.ok) {\n    throw new Error(data.message || 'Something went wrong');\n  }\n\n  return data;\n};\n\nexport const postApi = async (url, body, headers = DEFAULT_HEADERS) =&gt; {\n  const options = {\n    method: 'POST',\n    headers,\n    body: JSON.stringify(body)\n  };\n\n  const response = await fetch(url, options);\n  const data = await response.json();\n\n  if (!response.ok) {\n    throw new Error(data.message || 'Something went wrong');\n  }\n\n  return data;\n};\n\n// Add more methods (PUT, DELETE, etc.) as needed\n</code></pre>"},{"location":"frontend/state-management/redux/reducer/modular-reducer/#use-the-api-request-functions-in-action-creators","title":"Use the API Request Functions in Action Creators","text":"actions/itemActions.js<pre><code>import { getApi, postApi } from '../api';\nimport { API_URLS } from '../apiUrls';\nimport {\n  FETCH_ITEMS_REQUEST,\n  FETCH_ITEMS_SUCCESS,\n  FETCH_ITEMS_FAILURE,\n  CREATE_ITEM_REQUEST,\n  CREATE_ITEM_SUCCESS,\n  CREATE_ITEM_FAILURE\n} from '../actionTypes';\n\n// Fetch items\nexport const fetchItems = () =&gt; async (dispatch) =&gt; {\n  dispatch({ type: FETCH_ITEMS_REQUEST });\n  try {\n    const data = await getApi(API_URLS.FETCH_ITEMS);\n    dispatch({ type: FETCH_ITEMS_SUCCESS, payload: data });\n  } catch (error) {\n    dispatch({ type: FETCH_ITEMS_FAILURE, payload: error.message });\n  }\n};\n\n// Create item\nexport const createItem = (item) =&gt; async (dispatch) =&gt; {\n  dispatch({ type: CREATE_ITEM_REQUEST });\n  try {\n    const data = await postApi(API_URLS.CREATE_ITEM, item);\n    dispatch({ type: CREATE_ITEM_SUCCESS, payload: data });\n  } catch (error) {\n    dispatch({ type: CREATE_ITEM_FAILURE, payload: error.message });\n  }\n};\n</code></pre>"},{"location":"frontend/state-management/redux/reducer/modular-reducer/#full-example-directory-structure","title":"Full Example Directory Structure","text":"<pre><code>src/\n\u251c\u2500\u2500 actions/\n\u2502   \u251c\u2500\u2500 itemActions.js\n\u2502   \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 actionTypes/\n\u2502   \u251c\u2500\u2500 itemActionTypes.js\n\u2502   \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 api/\n\u2502   \u251c\u2500\u2500 api.js\n\u2502   \u251c\u2500\u2500 apiUrls.js\n\u2502   \u2514\u2500\u2500 headers.js\n\u251c\u2500\u2500 reducers/\n\u2502   \u251c\u2500\u2500 itemReducer.js\n\u2502   \u2514\u2500\u2500 index.js\n\u251c\u2500\u2500 store.js\n\u2514\u2500\u2500 components/\n    \u2514\u2500\u2500 ItemList.js\n</code></pre>"},{"location":"frontend/state-management/redux/reducer/modular-reducer/#putting-it-all-together","title":"Putting It All Together","text":"src/actions/itemActions.js<pre><code>import { getApi, postApi } from '../api/api';\nimport { API_URLS } from '../api/apiUrls';\nimport {\n  FETCH_ITEMS_REQUEST,\n  FETCH_ITEMS_SUCCESS,\n  FETCH_ITEMS_FAILURE,\n  CREATE_ITEM_REQUEST,\n  CREATE_ITEM_SUCCESS,\n  CREATE_ITEM_FAILURE\n} from '../actionTypes/itemActionTypes';\n\n// Fetch items\nexport const fetchItems = () =&gt; async (dispatch) =&gt; {\n  dispatch({ type: FETCH_ITEMS_REQUEST });\n  try {\n    const data = await getApi(API_URLS.FETCH_ITEMS);\n    dispatch({ type: FETCH_ITEMS_SUCCESS, payload: data });\n  } catch (error) {\n    dispatch({ type: FETCH_ITEMS_FAILURE, payload: error.message });\n  }\n};\n\n// Create item\nexport const createItem = (item) =&gt; async (dispatch) =&gt; {\n  dispatch({ type: CREATE_ITEM_REQUEST });\n  try {\n    const data = await postApi(API_URLS.CREATE_ITEM, item);\n    dispatch({ type: CREATE_ITEM_SUCCESS, payload: data });\n  } catch (error) {\n    dispatch({ type: CREATE_ITEM_FAILURE, payload: error.message });\n  }\n};\n</code></pre>"},{"location":"frontend/state-management/redux/reducer/throw-new-error/","title":"Throw New Error","text":""},{"location":"frontend/state-management/redux/reducer/throw-new-error/#understanding-throw-new-error","title":"Understanding throw new Error","text":"<p><code>throw new Error</code> is a way to create and throw a custom error in JavaScript. When you throw an <code>Error</code> object, you stop the normal execution flow and send control to the nearest catch block or global error handler, if no catch block is found.</p> Syntax<pre><code>if (!response.ok) {\n  throw new Error(data.message || 'Something went wrong');\n}\n</code></pre>"},{"location":"frontend/state-management/redux/reducer/throw-new-error/#importance-in-redux","title":"Importance in Redux","text":"<p>In a Redux-based application, throwing a new <code>Error</code> object is crucial for several reasons:</p> <ol> <li> <p>Consistent Error Handling:</p> <ul> <li> <p>By throwing an <code>Error</code>, you ensure that all errors are handled in a consistent manner. This consistency is vital for debugging and maintenance.</p> </li> <li> <p>Example:</p> <pre><code>try {\n    const data = await apiCall(url);\n} catch (error) {\n    console.error(error.message);\n}\n</code></pre> </li> </ul> </li> <li> <p>Centralized Error Management:</p> <ul> <li> <p>Redux action creators often make asynchronous calls (e.g., API requests). Throwing an <code>Error</code> allows these action creators to handle errors centrally, dispatching appropriate error actions.</p> </li> <li> <p>Example:</p> <pre><code>export const fetchData = () =&gt; async (dispatch) =&gt; {\n    dispatch({ type: FETCH_DATA_REQUEST });\n    try {\n        const data = await apiCall(url);\n        dispatch({ type: FETCH_DATA_SUCCESS, payload: data });\n    } catch (error) {\n        dispatch({ type: FETCH_DATA_FAILURE, payload: error.message });\n    }\n};\n</code></pre> </li> </ul> </li> <li> <p>Enhanced Debugging:</p> <ul> <li> <p>The <code>Error</code> object captures a stack trace, which provides valuable context about where the error occurred. This stack trace can be logged and used for debugging.</p> </li> <li> <p>Example:</p> <pre><code>catch (error) {\n    console.error('Error stack:', error.stack);\n}\n</code></pre> </li> </ul> </li> <li> <p>Flow Control:</p> <ul> <li> <p>Throwing an <code>Error</code> ensures that the normal flow of execution is interrupted, allowing you to handle exceptions appropriately. Without this, errors might go unnoticed, leading to unexpected behavior.</p> </li> <li> <p>Example:</p> <pre><code>const fetchData = async () =&gt; {\n    const response = await fetch(url);\n    if (!response.ok) {\n        throw new Error('Failed to fetch data');\n    }\n    return response.json();\n};\n</code></pre> </li> </ul> </li> </ol>"},{"location":"frontend/state-management/redux/reducer/throw-new-error/#consequences-of-not-throwing-an-error","title":"Consequences of Not Throwing an Error","text":"<p>If you don't throw an <code>Error</code>, the consequences can include:</p> <ol> <li> <p>Silent Failures:</p> <ul> <li> <p>Errors may go unnoticed, leading to silent failures where the application continues to run without handling the error.</p> </li> <li> <p>Example:</p> <pre><code>if (!response.ok) {\n    // No error thrown, so the function continues executing\n    console.error('Error fetching data');\n}\n</code></pre> </li> </ul> </li> <li> <p>Inconsistent State::</p> <ul> <li> <p>The application state might become inconsistent if errors are not properly handled, potentially causing further issues down the line.</p> </li> <li> <p>Example:</p> <pre><code>try {\n    const data = await apiCall(url);\n    // State might not update correctly if error is not handled\n} catch (error) {\n    // Handle error here\n}\n</code></pre> </li> </ul> </li> <li> <p>Difficult Debugging:</p> <ul> <li> <p>Without stack traces, debugging becomes more challenging. Developers have less context about where and why the error occurred.</p> </li> <li> <p>Example:</p> <pre><code>if (!response.ok) {\n    // No stack trace available\n    console.error('Error occurred');\n}\n</code></pre> </li> </ul> </li> </ol>"},{"location":"frontend/state-management/redux/reducer/throw-new-error/#example-in-redux-action-creator","title":"Example in Redux Action Creator","text":"<p>Here\u2019s a complete example demonstrating the use of throw new Error in a Redux action creator:</p> api.js<pre><code>export const apiCall = async (url, method = 'GET', body = null, headers = { 'Content-Type': 'application/json' }) =&gt; {\n    const options = { method, headers };\n    if (body) {\n        options.body = JSON.stringify(body);\n    }\n    const response = await fetch(url, options);\n    const data = await response.json();\n    if (!response.ok) {\n        throw new Error(data.message || 'Something went wrong');\n    }\n    return data;\n};\n</code></pre> actions/itemActions.js<pre><code>import { apiCall } from '../api/api';\nimport {\n    FETCH_ITEMS_REQUEST,\n    FETCH_ITEMS_SUCCESS,\n    FETCH_ITEMS_FAILURE,\n    CREATE_ITEM_REQUEST,\n    CREATE_ITEM_SUCCESS,\n    CREATE_ITEM_FAILURE\n} from '../actionTypes/itemActionTypes';\n\n// Fetch items\nexport const fetchItems = () =&gt; async (dispatch) =&gt; {\n    dispatch({ type: FETCH_ITEMS_REQUEST });\n    try {\n        const data = await apiCall('/api/items');\n        dispatch({ type: FETCH_ITEMS_SUCCESS, payload: data });\n    } catch (error) {\n        dispatch({ type: FETCH_ITEMS_FAILURE, payload: error.message });\n    }\n};\n\n// Create item\nexport const createItem = (item) =&gt; async (dispatch) =&gt; {\n    dispatch({ type: CREATE_ITEM_REQUEST });\n    try {\n        const data = await apiCall('/api/items', 'POST', item);\n        dispatch({ type: CREATE_ITEM_SUCCESS, payload: data });\n    } catch (error) {\n        dispatch({ type: CREATE_ITEM_FAILURE, payload: error.message });\n    }\n};\n</code></pre> <p>By throwing an <code>Error</code>, you ensure that your Redux actions can handle errors robustly and consistently, leading to a more stable and maintainable application.</p>"},{"location":"frontend/state-management/redux/reducer/throw-new-error/#why-we-throw-errors","title":"Why We Throw Errors","text":"<p>The primary reason for throwing errors is to ensure that they can be caught and handled appropriately. When you throw an error using <code>throw new Error</code>, it interrupts the normal execution flow and transfers control to the nearest <code>catch</code> block or an equivalent error-handling mechanism. Without this, errors might not be caught, leading to potential issues such as silent failures or inconsistent application states.</p>"},{"location":"frontend/state-management/redux/reducer/throw-new-error/#what-happens-if-we-dont-throw-an-error","title":"What Happens if We Don't Throw an Error","text":"<p>If you don't throw an error, it won't be caught by the catch block, and the execution will continue as if nothing went wrong. This can lead to various issues:</p> <ol> <li> <p>Silent Failures:</p> <p>The error might go unnoticed, leading to the application behaving incorrectly without any indication of what went wrong.</p> </li> <li> <p>Inconsistent State:</p> <p>If an error occurs and is not handled, the application state might become inconsistent, causing further issues down the line.</p> </li> <li> <p>Difficulty in Debugging:</p> <p>Without throwing an error, you lose the stack trace information, making it harder to debug and trace the source of the issue.</p> </li> </ol>"},{"location":"frontend/state-management/redux/reducer/throw-new-error/#example-without-throwing-an-error","title":"Example Without Throwing an Error","text":"<p>Here\u2019s an example to illustrate what happens when you don't throw an error:</p> api.js<pre><code>export const apiCall = async (url, method = 'GET', body = null, headers = { 'Content-Type': 'application/json' }) =&gt; {\n    const options = { method, headers };\n    if (body) {\n        options.body = JSON.stringify(body);\n    }\n    const response = await fetch(url, options);\n    const data = await response.json();\n    // Not throwing an error\n    if (!response.ok) {\n        return data.message || 'Something went wrong';\n    }\n    return data;\n};\n</code></pre> actions/itemActions.js<pre><code>import { apiCall } from '../api/api';\nimport {\n  FETCH_ITEMS_REQUEST,\n  FETCH_ITEMS_SUCCESS,\n  FETCH_ITEMS_FAILURE,\n  CREATE_ITEM_REQUEST,\n  CREATE_ITEM_SUCCESS,\n  CREATE_ITEM_FAILURE\n} from '../actionTypes/itemActionTypes';\n\n// Fetch items\nexport const fetchItems = () =&gt; async (dispatch) =&gt; {\n  dispatch({ type: FETCH_ITEMS_REQUEST });\n  try {\n    const data = await apiCall('/api/items');\n    if (!data.ok) {\n      dispatch({ type: FETCH_ITEMS_FAILURE, payload: data.message });\n    } else {\n      dispatch({ type: FETCH_ITEMS_SUCCESS, payload: data });\n    }\n  } catch (error) {\n    dispatch({ type: FETCH_ITEMS_FAILURE, payload: error.message });\n  }\n};\n\n// Create item\nexport const createItem = (item) =&gt; async (dispatch) =&gt; {\n    dispatch({ type: CREATE_ITEM_REQUEST });\n    try {\n        const data = await apiCall('/api/items', 'POST', item);\n        if (!data.ok) {\n            dispatch({ type: CREATE_ITEM_FAILURE, payload: data.message });\n        } else {\n            dispatch({ type: CREATE_ITEM_SUCCESS, payload: data });\n        }\n    } catch (error) {\n        dispatch({ type: CREATE_ITEM_FAILURE, payload: error.message });\n    }\n};\n</code></pre> <p>In this case, you have to handle the error within the action creator itself by checking the response. This approach is cumbersome and error-prone.</p>"},{"location":"frontend/state-management/redux/reducer/throw-new-error/#example-with-throwing-an-error","title":"Example With Throwing an Error","text":"<p>By throwing an error, you can simplify the error handling process:</p> api.js<pre><code>export const apiCall = async (url, method = 'GET', body = null, headers = { 'Content-Type': 'application/json' }) =&gt; {\n    const options = { method, headers };\n    if (body) {\n        options.body = JSON.stringify(body);\n    }\n    const response = await fetch(url, options);\n    const data = await response.json();\n    if (!response.ok) {\n        throw new Error(data.message || 'Something went wrong');\n    }\n    return data;\n};\n</code></pre> actions/itemActions.js<pre><code>import { apiCall } from '../api/api';\nimport {\n    FETCH_ITEMS_REQUEST,\n    FETCH_ITEMS_SUCCESS,\n    FETCH_ITEMS_FAILURE,\n    CREATE_ITEM_REQUEST,\n    CREATE_ITEM_SUCCESS,\n    CREATE_ITEM_FAILURE\n} from '../actionTypes/itemActionTypes';\n\n// Fetch items\nexport const fetchItems = () =&gt; async (dispatch) =&gt; {\n    dispatch({ type: FETCH_ITEMS_REQUEST });\n    try {\n        const data = await apiCall('/api/items');\n        dispatch({ type: FETCH_ITEMS_SUCCESS, payload: data });\n    } catch (error) {\n        dispatch({ type: FETCH_ITEMS_FAILURE, payload: error.message });\n    }\n};\n\n// Create item\nexport const createItem = (item) =&gt; async (dispatch) =&gt; {\n    dispatch({ type: CREATE_ITEM_REQUEST });\n    try {\n        const data = await apiCall('/api/items', 'POST', item);\n        dispatch({ type: CREATE_ITEM_SUCCESS, payload: data });\n    } catch (error) {\n        dispatch({ type: CREATE_ITEM_FAILURE, payload: error.message });\n    }\n};\n</code></pre>"},{"location":"frontend/state-management/redux/reducer/throw-new-error/#advantages-of-throwing-an-error","title":"Advantages of Throwing an Error","text":"<ol> <li> <p>Centralized Error Handling:</p> <p>By throwing an error, you allow the catch block to handle it centrally, making your code cleaner and easier to maintain.</p> </li> <li> <p>Clear Flow Control:</p> <p>Throwing an error immediately stops execution of the current function and transfers control to the nearest error handler.</p> </li> <li> <p>Detailed Error Information:</p> <p>The Error object includes a message and a stack trace, which are useful for debugging.</p> </li> <li> <p>Consistency:</p> <p>Ensures that all errors are handled consistently, reducing the likelihood of uncaught errors.</p> </li> </ol> <p>By adhering to this pattern, you ensure that your application handles errors robustly, making it more reliable and easier to maintain.</p>"},{"location":"frontend/state-management/redux/redux-middleware/intro/","title":"Intro","text":""},{"location":"frontend/state-management/redux/redux-middleware/intro/#redux-middleware-saga-and-thunk","title":"Redux middleware \u2013 Saga and Thunk","text":"<p>The basic Redux store can only perform simple synchronous state updates by dispatching an action.</p> <p>Middleware such as Redux Thunk and Redux Saga help extend the store capabilities by writing the async logic to interact with the store. These middleware are helpful to avoid directly causing side effects in our actions, action creators, or components.</p>"},{"location":"frontend/state-management/redux/redux-middleware/intro/#what-is-redux-middleware-how-do-you-create-middleware","title":"What is Redux middleware? How do you create middleware?","text":"<p>Redux middleware provides a third-party extension to intercept every action sent to the reducer by modifying the action or canceling the action. It is helpful for logging, error reporting, routing, and making asynchronous API calls. Although Redux middleware is like Node.js middleware (for example, Express and Koa), it solves different problems.</p>"},{"location":"frontend/state-management/redux/redux-middleware/intro/#how-do-you-handle-asynchronous-tasks-in-redux","title":"How do you handle asynchronous tasks in Redux?","text":"<p>Most modern web applications need to deal with asynchronous tasks. In React, there are two popular libraries available to handle them: </p> <ol> <li>Redux Thunk &amp;</li> <li>Redux Saga.</li> </ol>"},{"location":"frontend/state-management/redux/redux-middleware/intro/#how-do-you-choose-between-redux-saga-and-redux-thunk","title":"How do you choose between Redux Saga and Redux Thunk?","text":"<p>Both Redux Thunk and Redux Saga middleware are helpful in allowing the Redux store to interact with external API calls (or side effects) asynchronously. But the decision to choose one of them totally depends on your project requirements and personal preference. </p> <p>Redux Thunk is a good choice if you are new to the React or Redux ecosystem and the project is small in size. Moreover, Redux Thunk requires less boilerplate code and is easy to understand.</p> <p>On the other hand, Redux Saga is suitable for big projects where you need to split the logic into multiple files. However, the main advantage of Redux Saga over Redux Thunk is the ability to write clean and readable tests for asynchronous code.</p> <p>The plain Redux requires a lot of boilerplate code to fulfill the state management requirements.Developers need to implement common tasks such as store setup, writing reducers and actions, and so on. Also, you may need to import APIs from other packages based on needs. So, this entire process makes it difficult for developers to learn and implement the Redux solution. RTK is going to standardize the process and simplify it with its helpers.</p>"},{"location":"frontend/state-management/redux/redux-middleware/intro/#standardizing-redux-logic-using-rtk","title":"Standardizing Redux logic using RTK","text":"<p>The RTK package provides the necessary tools to ease Redux development. This package not only eases development but also prevents common mistakes, provides suggested best practices, and many more features.</p>"},{"location":"frontend/state-management/redux/redux-middleware/intro/#what-is-rtk","title":"What is RTK?","text":"<p>Redux Toolkit (RTK) is a set of tools that simplifies Redux development and is used as an officially recommended approach to writing Redux logic. It was previously known as Redux Smarter Kit. The node package for this toolkit is available with the name @reduxjs/toolkit, which is wrapped around the core redux package. In summary, this package provides utilities and common dependencies that are required for building a Redux application.</p> <p>This tool helps cover common use cases such as setting up the store, creating the reducers and actions, writing immutable update logic, and creating entire slices of state at once.</p> <p>By default, RTK automatically supports the following officially recommended set of tools or libraries to cover most of the common use cases:</p> <ul> <li>Redux DevTools</li> <li>Immer</li> <li>Redux Thunk</li> <li>Reselect</li> </ul> <p>RTK supports TypeScript through which APIs provide excellent type safety and reduce the number of types used in the code.</p>"},{"location":"frontend/state-management/redux/redux-middleware/intro/#what-are-the-problems-solved-by-rtk","title":"What are the problems solved by RTK?","text":"<p>RTK is helpful to speed up the development process and apply the recommended best practices automatically. It solves the following three major issues found in the Redux library:</p> <ul> <li>Configuring a Redux store that is too complicated</li> <li>This Redux library requires a lot of dependencies for building a large-scale application</li> <li>Redux requires too much boilerplate code, which impacts the efficiency and quality of the code</li> </ul> <p>The toolkit provides certain options to configure the global store, creating actions and reducers that make the development simpler by abstracting the Redux API.</p>"},{"location":"frontend/state-management/redux/redux-middleware/intro/#what-is-rtk-query-how-do-you-use-it","title":"What is RTK Query? How do you use it?","text":"<p>RTK Query is a powerful data fetching and client-side caching tool to simplify common use cases in Redux applications. For example, this tool supports use cases such as loading data in the web application, avoiding the need for hand-written data fetching and caching logic, and so on. If you are using the RTK package, this query feature is going to be available as an optional add-on. Also, this feature is built-in on top of the RTK API methods such as <code>createSlice</code> and <code>createAsyncThunk</code> for its implementation.</p>"},{"location":"frontend/state-management/redux/redux-middleware/intro/#reference","title":"Reference","text":"<ul> <li>React Interview Guide - packt pg:155</li> </ul>"},{"location":"frontend/state-management/redux/redux-middleware/redux-saga/","title":"Redux Saga","text":""},{"location":"frontend/state-management/redux/redux-middleware/redux-saga/#what-is-redux-saga","title":"What is Redux Saga?","text":"<p>Redux Saga is a popular competitor for Redux Thunk middleware for handling asynchronous side effects. Redux Saga uses an ES6 feature known as generators that helps in writing asynchronous code. These generators are functions that can be paused, resumed, exited in the middle of execution, and re-entered later during the operations.</p> <p>The side effects will be generated using special helper functions from the <code>redux-saga</code> package. Some of those commonly used functions are listed here:</p> <ul> <li>Call: An effect description that instructs the middleware to call other functions in Saga</li> <li>Put: Used to dispatch an action to the store</li> <li>Yield: A built-in function that allows the use of generator functions sequentially</li> <li>takeLatest: Invokes the function handler only once at a time and cancels the previous tasks by running again with the latest data</li> <li>takeEvery: Invokes the function handler every time infinitely and concurrently whenever the action fires</li> </ul> <ul> <li>React Interview Guide - packt pg:155</li> </ul>"},{"location":"frontend/state-management/redux/redux-middleware/redux-thunk/","title":"Redux Thunk","text":"<p>Redux Thunk middleware is used to write an action creator that returns a function instead of just an action object in the Redux application. The functions returned from the action creator are called thunk functions and are used to delay the computation. These functions accept two arguments \u2013 the dispatch and getState methods:</p>"},{"location":"frontend/state-management/redux/redux-middleware/redux-thunk/#what-are-the-use-cases-of-redux-thunk","title":"What are the use cases of Redux Thunk?","text":"<p>Redux Thunk can have any arbitrary logic and it can be used for a variety of purposes. The most common use cases of Redux Thunk are listed as follows:</p> <ul> <li>When you\u2019re trying to move complex logic out of React components</li> <li>When you are making async requests such as Ajax calls and other async logic</li> <li>When you need to create a logic that needs to dispatch multiple distinct actions in a row</li> <li>When you are planning to write a logic that needs to access getState or other state values to make decisions</li> </ul> <p>In summary, the main use case of Redux Thunk middleware is for handling actions that are not synchronous.</p> <ul> <li>React Interview Guide - packt pg:155</li> </ul>"},{"location":"frontend/state-management/redux/rtk/folder-structure/","title":"Folder Structure","text":""},{"location":"frontend/state-management/redux/rtk/folder-structure/#basic-redux-toolkit-rtk-folder-structure","title":"Basic Redux Toolkit (RTK) Folder Structure","text":"<p>A basic folder structure using Redux Toolkit might look something like this:</p> <pre><code>src/\n\u2502\n\u251c\u2500\u2500 app/\n\u2502   \u2514\u2500\u2500 store.js\n\u2502\n\u251c\u2500\u2500 features/\n\u2502   \u2514\u2500\u2500 counter/\n\u2502       \u251c\u2500\u2500 counterSlice.js\n\u2502       \u2514\u2500\u2500 Counter.js\n\u2502\n\u251c\u2500\u2500 App.js\n\u2514\u2500\u2500 index.js\n</code></pre> Example store.jscounterSlice.jsCounter.jsApp.jsindex.js <pre><code>// src/app/store.js\n\nimport { configureStore } from '@reduxjs/toolkit';\nimport counterReducer from '../features/counter/counterSlice';\n\nexport const store = configureStore({\n    reducer: {\n        counter: counterReducer,\n    },\n});\n</code></pre> <pre><code>// src/features/counter/counterSlice.js\n\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst counterSlice = createSlice({\n    name: 'counter',\n    initialState: {\n        value: 0,\n    },\n    reducers: {\n        increment: (state) =&gt; {\n            state.value += 1;\n        },\n        decrement: (state) =&gt; {\n            state.value -= 1;\n        },\n        incrementByAmount: (state, action) =&gt; {\n            state.value += action.payload;\n        },\n    },\n});\n\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions;\n\nexport default counterSlice.reducer;\n</code></pre> <pre><code>import React from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { increment, decrement, incrementByAmount } from './counterSlice';\n\nconst Counter = () =&gt; {\n    const count = useSelector((state) =&gt; state.counter.value);\n    const dispatch = useDispatch();\n\n    return (\n        &lt;div&gt;\n            &lt;div&gt;\n                &lt;button \n                    aria-label=\"Increment value\"\n                    onClick={() =&gt; dispatch(increment())}\n                &gt;\n                +\n                &lt;/button&gt;\n\n                &lt;span&gt;{count}&lt;/span&gt;\n\n                &lt;button\n                    aria-label=\"Decrement value\"\n                    onClick={() =&gt; dispatch(decrement())}\n                &gt;\n                -\n                &lt;/button&gt;\n            &lt;/div&gt;\n\n            &lt;div&gt;\n                &lt;button\n                    onClick={() =&gt; dispatch(incrementByAmount(5))}\n                &gt;\n                    Increment by 5\n                &lt;/button&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Counter;\n</code></pre> <pre><code>// src/App.js\n\nimport React from 'react';\nimport Counter from './features/counter/Counter';\n\nconst App = () =&gt; (\n    &lt;div&gt;\n        &lt;h1&gt;Counter App&lt;/h1&gt;\n        &lt;Counter /&gt;\n    &lt;/div&gt;\n);\n\nexport default App;\n</code></pre> <pre><code>// src/index.js\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport { store } from './app/store';\nimport App from './App';\n\nReactDOM.render(\n    &lt;Provider store={store}&gt;\n        &lt;App /&gt;\n    &lt;/Provider&gt;,\n    document.getElementById('root')\n);\n</code></pre>"},{"location":"frontend/state-management/redux/rtk/folder-structure/#advanced-redux-toolkit-rtk-folder-structure","title":"Advanced Redux Toolkit (RTK) Folder Structure","text":"<p>For a more complex application, the folder structure can be expanded to include additional features such as authentication, API calls, and more modular organization.</p> <pre><code>src/\n\u2502\n\u251c\u2500\u2500 app/\n\u2502   \u2514\u2500\u2500 store.js\n\u2502\n\u251c\u2500\u2500 features/\n\u2502   \u251c\u2500\u2500 auth/\n\u2502   \u2502   \u251c\u2500\u2500 authSlice.js\n\u2502   \u2502   \u251c\u2500\u2500 Login.js\n\u2502   \u2502   \u2514\u2500\u2500 Register.js\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 counter/\n\u2502   \u2502   \u251c\u2500\u2500 counterSlice.js\n\u2502   \u2502   \u2514\u2500\u2500 Counter.js\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 api/\n\u2502   \u2502   \u2514\u2500\u2500 apiSlice.js\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 user/\n\u2502       \u251c\u2500\u2500 userSlice.js\n\u2502       \u2514\u2500\u2500 UserProfile.js\n\u2502\n\u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 Navbar.js\n\u2502   \u2514\u2500\u2500 PrivateRoute.js\n\u2502\n\u251c\u2500\u2500 utils/\n\u2502   \u251c\u2500\u2500 authUtils.js\n\u2502   \u2514\u2500\u2500 apiUtils.js\n\u2502\n\u251c\u2500\u2500 App.js\n\u2514\u2500\u2500 index.js\n</code></pre> Example store.jsauthSlice.jsapiSlice.jsuserSlice.jsPrivateRoute.jsauthUtils.js <pre><code>// src/app/store.js\n\nimport { configureStore } from '@reduxjs/toolkit';\nimport counterReducer from '../features/counter/counterSlice';\nimport authReducer from '../features/auth/authSlice';\nimport userReducer from '../features/user/userSlice';\nimport { apiSlice } from '../features/api/apiSlice';\n\nexport const store = configureStore({\n    reducer: {\n        counter: counterReducer,\n        auth: authReducer,\n        user: userReducer,\n        [apiSlice.reducerPath]: apiSlice.reducer,\n    },\n    middleware: (getDefaultMiddleware) =&gt;\n        getDefaultMiddleware().concat(apiSlice.middleware),\n});\n</code></pre> <pre><code>// src/features/auth/authSlice.js\n\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport axios from 'axios';\n\nexport const login = createAsyncThunk('auth/login', async (credentials) =&gt; {\n    const response = await axios.post('/api/auth/login', credentials);\n    return response.data;\n});\n\nconst authSlice = createSlice({\n    name: 'auth',\n    initialState: {\n        user: null,\n        token: null,\n        status: 'idle',\n        error: null,\n    },\n    reducers: {\n        logout: (state) =&gt; {\n            state.user = null;\n            state.token = null;\n        },\n    },\n    extraReducers: (builder) =&gt; {\n        builder\n        .addCase(login.pending, (state) =&gt; {\n            state.status = 'loading';\n        })\n        .addCase(login.fulfilled, (state, action) =&gt; {\n            state.status = 'succeeded';\n            state.user = action.payload.user;\n            state.token = action.payload.token;\n        })\n        .addCase(login.rejected, (state, action) =&gt; {\n            state.status = 'failed';\n            state.error = action.error.message;\n        });\n    },\n});\n\nexport const { logout } = authSlice.actions;\n\nexport default authSlice.reducer;\n</code></pre> <pre><code>// src/features/api/apiSlice.js\n\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';\n\nexport const apiSlice = createApi({\n    reducerPath: 'api',\n    baseQuery: fetchBaseQuery({ baseUrl: '/api' }),\n    endpoints: (builder) =&gt; ({\n            getUserById: builder.query({\n            query: (id) =&gt; `user/${id}`,\n            }),\n            updateUser: builder.mutation({\n            query: (user) =&gt; ({\n                url: `user/${user.id}`,\n                method: 'PUT',\n                body: user,\n            }),\n        }),\n    }),\n});\n\nexport const { useGetUserByIdQuery, useUpdateUserMutation } = apiSlice;\n</code></pre> <pre><code>// src/features/user/userSlice.js\n\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst userSlice = createSlice({\n    name: 'user',\n    initialState: {\n        profile: null,\n    },\n    reducers: {\n        setProfile: (state, action) =&gt; {\n            state.profile = action.payload;\n        },\n    },\n});\n\nexport const { setProfile } = userSlice.actions;\n\nexport default userSlice.reducer;\n</code></pre> <pre><code>// src/components/PrivateRoute.js\nimport React from 'react';\nimport { Route, Redirect } from 'react-router-dom';\nimport { useSelector } from 'react-redux';\n\nconst PrivateRoute = ({ component: Component, ...rest }) =&gt; {\n    const { token } = useSelector((state) =&gt; state.auth);\n\n    return (\n        &lt;Route\n            {...rest}\n            render={(props) =&gt;\n                token ? &lt;Component {...props} /&gt; : &lt;Redirect to=\"/login\" /&gt;\n            }\n        /&gt;\n    );\n};\n\nexport default PrivateRoute;\n</code></pre> <pre><code>// src/utils/authUtils.js\n\nexport const isAuthenticated = () =&gt; {\n    const token = localStorage.getItem('token');\n    return !!token;\n};\n\nexport const getToken = () =&gt; {\n    return localStorage.getItem('token');\n};\n</code></pre> <p>Summary</p> <ul> <li>Basic Structure: Simple setup with essential files and folders.</li> <li>Advanced Structure: More complex organization with features, components, and utility functions separated into dedicated folders.</li> </ul> <p>By organizing your project in this way, you can scale your application more effectively and maintain a clean and manageable codebase.</p>"},{"location":"frontend/state-management/redux/rtk/folder-structure/#more-advanced","title":"More Advanced","text":"<pre><code>src/\n\u2502\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 store.js\n\u2502   \u2514\u2500\u2500 rootReducer.js\n\u2502\n\u251c\u2500\u2500 features/\n\u2502   \u251c\u2500\u2500 auth/\n\u2502   \u2502   \u251c\u2500\u2500 authApi.js\n\u2502   \u2502   \u251c\u2500\u2500 authSlice.js\n\u2502   \u2502   \u251c\u2500\u2500 Login.js\n\u2502   \u2502   \u2514\u2500\u2500 Register.js\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 counter/\n\u2502   \u2502   \u251c\u2500\u2500 counterApi.js\n\u2502   \u2502   \u251c\u2500\u2500 counterSlice.js\n\u2502   \u2502   \u2514\u2500\u2500 Counter.js\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 user/\n\u2502   \u2502   \u251c\u2500\u2500 userApi.js\n\u2502   \u2502   \u251c\u2500\u2500 userSlice.js\n\u2502   \u2502   \u251c\u2500\u2500 UserProfile.js\n\u2502   \u2502   \u2514\u2500\u2500 UserList.js\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 dashboard/\n\u2502   \u2502   \u251c\u2500\u2500 dashboardApi.js\n\u2502   \u2502   \u251c\u2500\u2500 dashboardSlice.js\n\u2502   \u2502   \u2514\u2500\u2500 Dashboard.js\n\u2502\n\u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 Navbar.js\n\u2502   \u2514\u2500\u2500 PrivateRoute.js\n\u2502\n\u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 api.js\n\u2502   \u251c\u2500\u2500 auth.js\n\u2502   \u2514\u2500\u2500 user.js\n\u2502\n\u251c\u2500\u2500 utils/\n\u2502   \u251c\u2500\u2500 authUtils.js\n\u2502   \u2514\u2500\u2500 apiUtils.js\n\u2502\n\u251c\u2500\u2500 hooks/\n\u2502   \u2514\u2500\u2500 useAuth.js\n\u2502\n\u251c\u2500\u2500 App.js\n\u2514\u2500\u2500 index.js\n</code></pre> Example store.jsrootReducer.js <pre><code>// src/app/store.js\n\nimport { configureStore } from '@reduxjs/toolkit';\nimport rootReducer from './rootReducer';\n\nexport const store = configureStore({\n    reducer: rootReducer,\n    middleware: (getDefaultMiddleware) =&gt;\n        getDefaultMiddleware().concat(),\n});\n</code></pre> <pre><code>// src/app/rootReducer.js\n\nimport { combineReducers } from 'redux';\nimport authReducer from '../features/auth/authSlice';\nimport counterReducer from '../features/counter/counterSlice';\nimport userReducer from '../features/user/userSlice';\nimport dashboardReducer from '../features/dashboard/dashboardSlice';\n\nconst rootReducer = combineReducers({\n    auth: authReducer,\n    counter: counterReducer,\n    user: userReducer,\n    dashboard: dashboardReducer,\n});\n\nexport default rootReducer;\n</code></pre> <p>Feature Slices and APIs</p> Example authSlice.jsauthApi.jsDashboard.jsx <pre><code>// src/features/auth/authSlice.js\n\nimport { createSlice } from '@reduxjs/toolkit';\nimport { login } from './authApi';\n\nconst authSlice = createSlice({\n    name: 'auth',\n    initialState: {\n        user: null,\n        token: null,\n        status: 'idle',\n        error: null,\n    },\n    reducers: {\n        logout: (state) =&gt; {\n        state.user = null;\n        state.token = null;\n        },\n    },\n    extraReducers: (builder) =&gt; {\n        builder\n        .addCase(login.pending, (state) =&gt; {\n            state.status = 'loading';\n        })\n        .addCase(login.fulfilled, (state, action) =&gt; {\n            state.status = 'succeeded';\n            state.user = action.payload.user;\n            state.token = action.payload.token;\n        })\n        .addCase(login.rejected, (state, action) =&gt; {\n            state.status = 'failed';\n            state.error = action.error.message;\n        });\n    },\n});\n\nexport const { logout } = authSlice.actions;\n\nexport default authSlice.reducer;\n</code></pre> <pre><code>// src/features/auth/authApi.js\n\nimport { createAsyncThunk } from '@reduxjs/toolkit';\nimport axios from 'axios';\n\nexport const login = createAsyncThunk('auth/login', async (credentials) =&gt; {\n    const response = await axios.post('/api/auth/login', credentials);\n    return response.data;\n});\n</code></pre> <pre><code>// src/features/dashboard/Dashbaord.jsx\nimport { useSelector } from 'react-redux';\n\nconst Dashboard = () =&gt; {\n    const { user } = useSelector((state) =&gt; state.auth);\n\n    return (\n        &lt;div className=\"dashboard-container\"&gt;\n        &lt;h1&gt;Welcome to your Dashboard, {user?.name}!&lt;/h1&gt;\n        &lt;p&gt;This is a protected route. Only authenticated users can see this.&lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Dashboard;\n</code></pre> <p>Centralized API Service</p> Example api.jsauth.js <pre><code>// src/services/api.js\n\nimport axios from 'axios';\n\nconst apiClient = axios.create({\n    baseURL: '/api',\n    headers: {\n        'Content-Type': 'application/json',\n    },\n});\n\nexport const setAuthToken = (token) =&gt; {\n    if (token) {\n        apiClient.defaults.headers.common['Authorization'] = `Bearer ${token}`;\n    } else {\n        delete apiClient.defaults.headers.common['Authorization'];\n    }\n};\n\nexport default apiClient;\n</code></pre> <pre><code>// src/services/auth.js\n\nimport apiClient from './api';\n\nexport const login = (credentials) =&gt; {\n    return apiClient.post('/auth/login', credentials);\n};\n\nexport const register = (userData) =&gt; {\n    return apiClient.post('/auth/register', userData);\n};\n</code></pre> <p>Utility Functions</p> Example authUtils.js <pre><code>// src/utils/authUtils.js\n\nexport const isAuthenticated = () =&gt; {\n    const token = localStorage.getItem('token');\n    return !!token;\n};\n\nexport const getToken = () =&gt; {\n    return localStorage.getItem('token');\n};\n</code></pre> <p>Custom Hooks</p> Example useAuth.js <pre><code>// src/hooks/useAuth.js\n\nimport { useSelector } from 'react-redux';\n\nconst useAuth = () =&gt; {\n    const { user, token } = useSelector((state) =&gt; state.auth);\n    return { user, token };\n};\n\nexport default useAuth;\n</code></pre> Example App.jsxmain.jsx <pre><code>// src/App.jsx\nimport { BrowserRouter as Router, Routes, Route } from 'react-router-dom';\nimport Login from './features/auth/login.jsx';\nimport Dashboard from './features/dashboard/Dashboard.jsx';\nimport PrivateRoute from './components/PrivateRoute.jsx';\nimport Navbar from './components/Navbar.jsx';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;div&gt;\n            &lt;Navbar /&gt;\n            &lt;Routes&gt;\n                &lt;Route path=\"/login\" element={&lt;Login /&gt;} /&gt;\n                &lt;PrivateRoute path=\"/dashboard\" component={Dashboard} /&gt;\n            &lt;/Routes&gt;\n        &lt;/div&gt;\n    &lt;/Router&gt;\n);\n\nexport default App;\n</code></pre> <pre><code>// src/main.jsx\n\nimport React from 'react'\nimport ReactDOM from 'react-dom/client'\nimport { Provider } from 'react-redux';\nimport { store } from './app/store';\nimport App from './App.jsx'\nimport './index.css'\n\nReactDOM.createRoot(document.getElementById('root')).render(\n    &lt;Provider store={store}&gt;\n        &lt;React.StrictMode&gt;\n            &lt;App /&gt;\n        &lt;/React.StrictMode&gt;\n    &lt;/Provider&gt;\n)\n</code></pre> <p>Components</p> <pre><code>=== \"Navbar.jsx\"\n\n    ```jsx\n    // components/Navbar.jsx\n    import { Link } from 'react-router-dom';\n    import { useDispatch, useSelector } from 'react-redux';\n    import { logout } from '../features/auth/authSlice';\n\n    const Navbar = () =&gt; {\n        const dispatch = useDispatch();\n        const { user } = useSelector((state) =&gt; state.auth);\n\n        const handleLogout = () =&gt; {\n            dispatch(logout());\n        };\n\n        return (\n            &lt;nav&gt;\n                &lt;Link to=\"/\"&gt;Home&lt;/Link&gt;\n                {user ? (\n                    &lt;&gt;\n                        &lt;Link to=\"/dashboard\"&gt;Dashboard&lt;/Link&gt;\n                        &lt;button onClick={handleLogout}&gt;Logout&lt;/button&gt;\n                    &lt;/&gt;\n                ) : (\n                    &lt;Link to=\"/login\"&gt;Login&lt;/Link&gt;\n                )}\n            &lt;/nav&gt;\n        );\n    };\n\n    export default Navbar;\n\n    ```\n\n\n=== \"PrivateRoute.jsx\"\n\n    ```jsx\n    // components/PrivateRoute.jsx\n\n    import { Route, Navigate } from 'react-router-dom';\n    import { useSelector } from 'react-redux';\n    import PropTypes from 'prop-types';\n\n    const PrivateRoute = ({ component: Component, ...rest }) =&gt; {\n        const { token } = useSelector((state) =&gt; state.auth);\n\n        return (\n            &lt;Route\n                {...rest}\n                element={token ? &lt;Component /&gt; : &lt;Navigate to=\"/login\" /&gt;}\n            /&gt;\n        );\n    };\n\n    PrivateRoute.propTypes = {\n        component: PropTypes.elementType.isRequired,\n    };\n\n    export default PrivateRoute;\n    ```\n</code></pre> <p>Summary</p> <ul> <li>Modular Structure: Break down features into separate folders, each containing related slices, API calls, and components.</li> <li>Centralized API Service: Use a single api.js file to configure and manage API calls.</li> <li>Custom Hooks: Create custom hooks for reusable logic.</li> <li>Utility Functions: Use utility functions to manage common operations.</li> </ul> <p>Benefits of this Approach</p> <ol> <li>Scalability: Easy to add new features without disrupting the existing codebase.</li> <li>Maintainability: Clear separation of concerns makes it easier to maintain and update the code.</li> <li>Reusability: Common logic and utilities are centralized, promoting code reuse.</li> <li>Extensibility: Easily extend the application by adding new features, APIs, and components.</li> </ol> <p>By following this modular approach, you can manage a large codebase effectively, ensuring that your application remains organized and maintainable as it grows.</p>"},{"location":"frontend/state-management/redux/rtk/intro/","title":"Intro","text":""},{"location":"frontend/state-management/redux/rtk/intro/#authorization","title":"Authorization","text":"<p>Implementing login and authorization in a React application can be achieved through various libraries and techniques. Here's a step-by-step guide using common libraries like <code>redux</code>, <code>redux-toolkit</code>, <code>react-router</code>, and <code>jwt-decode</code>.</p>"},{"location":"frontend/state-management/redux/rtk/intro/#libraries-to-use","title":"Libraries to Use","text":"<ol> <li>React Router: For handling routing.</li> <li>Redux/Redux Toolkit: For state management.</li> <li>Axios: For making API requests.</li> <li>JWT-decode: For decoding JSON Web Tokens.</li> <li>React Hook Form: For handling form state.</li> </ol>"},{"location":"frontend/state-management/redux/rtk/intro/#step-by-step-implementation","title":"Step-by-Step Implementation","text":"<ol> <li> <p>Setting Up Your Project</p> <p>Install the necessary packages:</p> <pre><code>npm install react-router-dom @reduxjs/toolkit react-redux axios jwt-decode react-hook-form\n</code></pre> </li> <li> <p>Configure Redux Store</p> <p>Set up a Redux store with slices for authentication.</p> <pre><code>// store.js\nimport { configureStore } from '@reduxjs/toolkit';\nimport authReducer from './features/auth/authSlice';\n\nexport const store = configureStore({\n    reducer: {\n        auth: authReducer,\n    },\n});\n</code></pre> </li> <li> <p>Create Authentication Slice</p> <p>Create a slice for authentication state management.</p> <pre><code>// features/auth/authSlice.js\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport axios from 'axios';\nimport jwt_decode from 'jwt-decode';\n\nconst initialState = {\n    token: localStorage.getItem('token') || null,\n    user: localStorage.getItem('token') ? jwt_decode(localStorage.getItem('token')) : null,\n    status: 'idle',\n    error: null,\n};\n\nexport const login = createAsyncThunk('auth/login', async (credentials) =&gt; {\n    const response = await axios.post('/api/auth/login', credentials);\n    return response.data.token;\n});\n\nconst authSlice = createSlice({\n    name: 'auth',\n    initialState,\n    reducers: {\n        logout: (state) =&gt; {\n            state.token = null;\n            state.user = null;\n            localStorage.removeItem('token');\n        },\n    },\n    extraReducers: (builder) =&gt; {\n        builder\n        .addCase(login.pending, (state) =&gt; {\n            state.status = 'loading';\n        })\n        .addCase(login.fulfilled, (state, action) =&gt; {\n            state.status = 'succeeded';\n            state.token = action.payload;\n            state.user = jwt_decode(action.payload);\n            localStorage.setItem('token', action.payload);\n        })\n        .addCase(login.rejected, (state, action) =&gt; {\n            state.status = 'failed';\n            state.error = action.error.message;\n        });\n    },\n});\n\nexport const { logout } = authSlice.actions;\n\nexport default authSlice.reducer;\n</code></pre> </li> <li> <p>Create Login Component</p> <p>Create a component for the login form using react-hook-form.</p> <pre><code>// components/Login.js\nimport React from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { useForm } from 'react-hook-form';\nimport { login } from '../features/auth/authSlice';\nimport { Redirect } from 'react-router-dom';\n\nconst Login = () =&gt; {\n    const dispatch = useDispatch();\n    const { register, handleSubmit } = useForm();\n    const { token, error, status } = useSelector((state) =&gt; state.auth);\n\n    const onSubmit = (data) =&gt; {\n        dispatch(login(data));\n    };\n\n    if (token) {\n        return &lt;Redirect to=\"/\" /&gt;;\n    }\n\n    return (\n        &lt;div&gt;\n            &lt;h2&gt;Login&lt;/h2&gt;\n\n            &lt;form onSubmit={handleSubmit(onSubmit)}&gt;\n                &lt;div&gt;\n                    &lt;label&gt;Email:&lt;/label&gt;\n                    &lt;input type=\"email\" {...register('email')} /&gt;\n                &lt;/div&gt;\n                &lt;div&gt;\n                    &lt;label&gt;Password:&lt;/label&gt;\n                    &lt;input type=\"password\" {...register('password')} /&gt;\n                &lt;/div&gt;\n                &lt;button type=\"submit\"&gt;Login&lt;/button&gt;\n            &lt;/form&gt;\n\n            {status === 'loading' &amp;&amp; &lt;p&gt;Loading...&lt;/p&gt;}\n            {error &amp;&amp; &lt;p&gt;{error}&lt;/p&gt;}\n        &lt;/div&gt;\n    );\n};\n\nexport default Login;\n</code></pre> </li> <li> <p>Protect Routes</p> <p>Create a higher-order component (HOC) to protect routes.</p> <pre><code>// components/PrivateRoute.js\nimport React from 'react';\nimport { Route, Redirect } from 'react-router-dom';\nimport { useSelector } from 'react-redux';\n\nconst PrivateRoute = ({ component: Component, ...rest }) =&gt; {\n    const token = useSelector((state) =&gt; state.auth.token);\n\n    return (\n        &lt;Route\n            {...rest}\n            render={(props) =&gt;\n                token ? (\n                    &lt;Component {...props} /&gt;\n                ) : (\n                    &lt;Redirect to=\"/login\" /&gt;\n                )\n            }\n        /&gt;\n    );\n};\n\nexport default PrivateRoute;\n</code></pre> </li> <li> <p>Set Up Routing</p> <p>Configure routing in your application using React Router.</p> <pre><code>// App.js\nimport React from 'react';\nimport { BrowserRouter as Router, Route, Switch } from 'react-router-dom';\nimport { Provider } from 'react-redux';\nimport { store } from './store';\nimport Login from './components/Login';\nimport PrivateRoute from './components/PrivateRoute';\nimport Home from './components/Home';\n\nconst App = () =&gt; (\n    &lt;Provider store={store}&gt;\n        &lt;Router&gt;\n            &lt;Switch&gt;\n                &lt;Route path=\"/login\" component={Login} /&gt;\n                &lt;PrivateRoute path=\"/\" component={Home} /&gt;\n            &lt;/Switch&gt;\n        &lt;/Router&gt;\n    &lt;/Provider&gt;\n);\n\nexport default App;\n</code></pre> </li> </ol>"},{"location":"frontend/state-management/redux/rtk/intro/#summary","title":"Summary","text":"<ol> <li>Setup Redux store: Configure the store with <code>redux-toolkit</code>.</li> <li>Create auth slice: Manage authentication state with a slice.</li> <li>Login component: Use <code>react-hook-form</code>for handling the login form.</li> <li>Protect routes: Use a higher-order component to protect routes.</li> <li>Configure routing: Set up routing with React Router.</li> </ol> <p>By using these tools and techniques, you can implement robust login and authorization mechanisms in your React application.</p>"},{"location":"frontend/state-management/redux/rtk/intro/#choice","title":"Choice","text":"<ul> <li>Standard Redux is still usable and maintained but involves more boilerplate and manual configuration.</li> <li>Redux Toolkit (RTK) is recommended for new projects as it simplifies Redux setup, encourages best practices, and provides tools to reduce boilerplate.</li> </ul> <p>If you are starting a new project or maintaining an existing one, it is highly advisable to use Redux Toolkit for a better development experience.</p>"},{"location":"frontend/state-management/redux/standard-redux/intro/","title":"Intro","text":""},{"location":"frontend/state-management/redux/standard-redux/intro/#redux-toolkit-a-modern-approach-to-redux","title":"Redux Toolkit: a modern approach to Redux","text":"<p>Redux Toolkit is the official, opinionated, and batteries-included toolset for efficient Redux development. It was created to help developers write better and more efficient Redux code with less boilerplate.</p> <p>Intallation</p>"},{"location":"frontend/state-management/redux/standard-redux/intro/#install-redux-toolkit-and-react-redux","title":"Install Redux Toolkit and React-Redux","text":"<p>Add the Redux Toolkit and React-Redux packages to your project:</p> <pre><code>npm install @reduxjs/toolkit react-redux\n</code></pre> <ul> <li>ofiical redux tookit</li> </ul>"},{"location":"frontend/state-management/redux/standard-redux/intro/#key-features","title":"Key features","text":"<p>Redux Toolkit comes with several key features that simplify the Redux development process:</p> <ul> <li>configureStore: A function that sets up a Redux store with sensible defaults.</li> <li>createSlice: A function that automatically generates action creators and reducers based on a provided configuration.</li> <li>createAction: A utility function to create action creators with a specific type and payload.</li> <li>createReducer: A utility function that simplifies reducer creation using Immer, enabling direct state manipulation.</li> </ul> <p>Redux Middleware is code that lets us intercept redux actions before they reach the reducer. <code>redux-thunk</code> is an example of Redux Middleware, along with other popular <code>redux</code> libraries like <code>redux-logger</code> , <code>redux-promise-middleware</code> , and <code>redux-saga</code> (an alternative to <code>redux-thunk</code> ).</p> <p></p>"},{"location":"frontend/state-management/redux/standard-redux/intro/#redux-thunk-gives-redux-side-effects","title":"Redux Thunk Gives Redux Side-Effects","text":"<p>In <code>redux</code>, actions creators are functions that return an action, which is a plain javascript objects with a <code>type</code> property.</p> <ul> <li><code>redux-thunk</code> is a Redux Middleware that lets your action creators return a function called a thunk, instead of an action. </li> <li>This thunk can return an action when invoked but it also has access to the Redux store's <code>dispatch</code> function, meaning it can also dispatch other actions. </li> <li>Typically, API calls are invoked inside these thunks and different actions are dispatched depending on these API responses.</li> </ul> <p>For example, below are two action creators, the first returns a plain redux action. The second returns a <code>thunk</code>, thanks to <code>redux-thunk</code>.</p> <pre><code>// action creators\n\n// Action Creator returns action\nloadUser = (userData) =&gt; ({\n  type: \"LOAD_USER_DATA\", userData\n})\n\n/* \n  Action Creator which returns function which dispatches other actions\n*/\nfetchUser = (usersUrl) =&gt; (dispatch) =&gt; {\n  dispatch({ type: \"DISPLAY_LOADING_SCREEN\" })\n\n  return fetch(usersUrl)\n    .then(response =&gt; response.json())\n    .then((json) =&gt; {\n      if (json.success) {\n        dispatch({ type: \"LOAD_USER_DATA\", json.userData })\n      } else {\n        dispatch({ type: \"LOAD_USER_FAILED\" })\n      }\n    })\n}\n</code></pre>"},{"location":"frontend/state-management/redux/standard-redux/intro/#summary","title":"Summary","text":"<ul> <li><code>redux-thunk</code> lets us create actions which are functions that can dispatch other functions instead of just objects.</li> <li><code>redux-thunk</code> is an example of Redux Middleware and as such, needs to adhere to the Redux Middleware signature of <code>validMiddleware =&gt; (store) =&gt; (next) =&gt; (action)</code></li> <li>The core logic of <code>redux-thunk</code> is essentially a simple if statement that checks if the action is a thunk (ie. a function) and invokes it if it is. By default, it exports the Middleware with no <code>extraArgument</code> but it then attaches the <code>createThunkMiddleware</code> function onto the exported Middleware to be used if needed.</li> </ul>"},{"location":"frontend/state-management/redux/standard-redux/intro/#differences-between-standard-redux-and-redux-toolkit-rtk","title":"Differences between <code>standard Redux</code> and <code>Redux Toolkit</code> (RTK)","text":"<p>The key differences between standard Redux and Redux Toolkit (RTK) revolve around simplification, boilerplate reduction, and built-in best practices. RTK is a set of tools and recommendations to help write Redux logic more efficiently and with fewer bugs.</p>"},{"location":"frontend/state-management/redux/standard-redux/intro/#standard-redux","title":"Standard Redux","text":"Characteristics: <ol> <li> <p>Boilerplate Code:</p> <p>Writing actions, action creators, and reducers involves a lot of repetitive boilerplate code.</p> </li> <li> <p>Manual Immutable Updates:</p> <p>You must ensure immutability by manually copying and updating state slices, which can be error-prone.</p> </li> <li> <p>Middleware Setup:</p> <p>Middleware like <code>redux-thunk</code> or <code>redux-saga</code> must be manually added and configured.</p> </li> <li> <p>Configure Store:</p> <p>Creating and configuring the store involves several steps and manual setup for middleware, devtools, etc.</p> </li> <li> <p>Async Logic:</p> <p>Handling asynchronous logic typically requires custom middleware and manually structured action types and creators.</p> </li> <li> <p>Code Organization:</p> <p>Developers need to decide how to organize actions, reducers, and constants, leading to varied and inconsistent project structures.</p> </li> </ol>"},{"location":"frontend/state-management/redux/standard-redux/intro/#standard-redux-example","title":"Standard Redux Example","text":"Example ActionsReducerStore Configuration <pre><code>// actions.js\nexport const INCREMENT = 'INCREMENT';\n\nexport const increment = () =&gt; ({\n    type: INCREMENT,\n});\n</code></pre> <pre><code>// reducer.js\nimport { INCREMENT } from './actions';\n\nconst initialState = { value: 0 };\n\nconst counterReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case INCREMENT:\n            return { ...state, value: state.value + 1 };\n        default:\n            return state;\n    }\n};\n\nexport default counterReducer;\n</code></pre> <pre><code>// store.js\nimport { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport counterReducer from './reducer';\n\nconst store = createStore(counterReducer, applyMiddleware(thunk));\n\nexport default store;\n</code></pre>"},{"location":"frontend/state-management/redux/standard-redux/intro/#redux-toolkit-rtk","title":"Redux Toolkit (RTK)","text":"Characteristics: <ol> <li> <p>Reduced Boilerplate:</p> <p>Provides utilities like <code>createSlice</code>, <code>createAsyncThunk</code>, and <code>createAction</code> that automate and reduce boilerplate.</p> </li> <li> <p>Automatic Immutable Updates:</p> <p>Uses Immer under the hood to handle immutable state updates automatically.</p> </li> <li> <p>Integrated Middleware:</p> <p>Pre-configures the store with useful middleware like <code>redux-thunk</code>, and you can easily add more.</p> </li> <li> <p>Simplified Store Configuration:</p> <p>The <code>configureStore</code> function simplifies the store creation process, integrating devtools, middleware, and enhancers by default.</p> </li> <li> <p>Built-in Async Logic:</p> <p>The <code>createAsyncThunk</code> utility standardizes and simplifies handling asynchronous actions.</p> </li> <li> <p>Standardized Code Organization:</p> <p>Encourages a standardized way to organize slices, reducers, and actions, leading to more consistent codebases.</p> </li> </ol>"},{"location":"frontend/state-management/redux/standard-redux/intro/#redux-toolkit-example","title":"Redux Toolkit Example","text":"Example SliceStore Configuration <pre><code>// counterSlice.js\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst counterSlice = createSlice({\n    name: 'counter',\n    initialState: { value: 0 },\n    reducers: {\n        increment: (state) =&gt; {\n            state.value += 1;\n        },\n    },\n});\n\nexport const { increment } = counterSlice.actions;\nexport default counterSlice.reducer;\n</code></pre> <pre><code>// store.js\nimport { configureStore } from '@reduxjs/toolkit';\nimport counterReducer from './counterSlice';\n\nconst store = configureStore({\n    reducer: {\n        counter: counterReducer,\n    },\n});\n\nexport default store;\n</code></pre>"},{"location":"frontend/state-management/redux/standard-redux/intro/#key-benefits-of-rtk","title":"Key Benefits of RTK","text":"<ol> <li>Boilerplate Reduction: By automating repetitive tasks, RTK reduces boilerplate, making the codebase cleaner and easier to maintain.</li> <li>Immutability Handling: Automatic handling of immutable updates using Immer simplifies state updates and reduces bugs.</li> <li>Pre-configured Store: configureStore streamlines the store setup process, providing good defaults and simplifying middleware addition.</li> <li>Async Thunks: createAsyncThunk offers a standardized way to handle async logic, reducing the need for custom middleware.</li> <li>Code Structure: Encourages a modular and consistent way to structure code using slices, leading to more maintainable projects.</li> </ol> <p>Overall, RTK provides a more modern and efficient way to write Redux logic, addressing many of the pain points associated with standard Redux.</p>"},{"location":"frontend/state-management/redux/standard-redux/intro/#reference","title":"Reference","text":"<ul> <li> <p>React 18 Design Patterns - 2023</p> </li> <li> <p>RTK</p> </li> <li>official redux rtk</li> <li>Understanding Redux Toolkit</li> <li> <p>reduxt toolkit</p> </li> <li> <p>Middleware</p> </li> <li>Understanding redux thunk</li> <li>What is the use of middleware Redux thunk ?</li> </ul>"},{"location":"frontend/typescript/typescript-compiler/","title":"compiler","text":""},{"location":"frontend/typescript/typescript-compiler/#typescript-compiler","title":"TypeScript Compiler","text":"<p>TypeScript is transpiled into JavaScript using a compiler.</p> <p>TypeScript being converted into JavaScript means it runs anywhere that JavaScript runs!</p>"},{"location":"frontend/typescript/typescript-compiler/#installing-the-compiler","title":"Installing the Compiler","text":"<p>TypeScript has an official compiler which can be installed through npm.</p> <p>Within your npm project, run the following command to install the compiler:</p> <p>npm install typescript --save-dev</p> <p>You can then run the TypeScript compiler using one of the following commands:</p> <p>npx tsc</p> <p>yarn tsc</p> <p>pnpm tsc</p>"},{"location":"frontend/typescript/typescript-compiler/#globally-installing-typescript","title":"Globally Installing TypeScript","text":"<p>npm install -g typescript</p>"},{"location":"frontend/typescript/typescript-compiler/#configuring-the-compiler","title":"Configuring the compiler","text":"<p>You can have TypeScript create <code>tsconfig.json</code> with the recommended settings with:</p> <p>npx tsc --init</p> <p>Here is an example of more things you could add to the <code>tsconfig.json</code> file:</p> <pre><code>{\n  \"include\": [\"src\"],\n  \"compilerOptions\": {\n    \"outDir\": \"./build\"\n  }\n}\n</code></pre>"},{"location":"frontend/typescript/typescript-compiler/#working-with-typescript-compatible-transpilers","title":"Working with TypeScript-compatible transpilers","text":"<p>There are other tools which convert TypeScript files to JavaScript files</p> <ol> <li>Babel: Babel is a very popular JavaScript transpiler which supports TypeScript files via the plugin @babel/plugin-transform-typescript.</li> <li>swc: swc is a fast transpiler created in Rust which supports many of Babel's features including TypeScript.</li> <li>Sucrase: Sucrase is a Babel fork focused on speed for using in development mode. Sucrase supports TypeScript natively.</li> </ol>"},{"location":"frontend/typescript/typescript-compiler/#reference","title":"Reference","text":"<ul> <li>TypeScript Compiler :w3chools.com</li> </ul>"},{"location":"frontend/typescript/typescript-installation/","title":"installation","text":""},{"location":"frontend/typescript/typescript-installation/#typescript","title":"Typescript","text":""},{"location":"frontend/typescript/typescript-installation/#what-is-typescript","title":"What is TypeScript?","text":"<p>TypeScript is JavaScript with added syntax for types.</p> <p>TypeScript is a syntactic superset of JavaScript which adds static typing.</p> <p>This basically means that TypeScript adds syntax on top of JavaScript, allowing developers to add types.</p> <p>TypeScript being a \"Syntactic Superset\" means that it shares the same base syntax as JavaScript, but adds something to it.</p>"},{"location":"frontend/typescript/typescript-installation/#how-do-i-use-typescript","title":"How do I use TypeScript?","text":"<p>A common way to use TypeScript is to use the official TypeScript compiler, which transpiles TypeScript code into JavaScript.</p> <p>The next section shows how to get the compiler setup for a local project.</p> <p>Some popular code editors, such as Visual Studio Code, have built-in TypeScript support and can show errors as you write code!</p> <p>TypeScript uses compile time type checking. Which means it checks if the specified types match before running the code, not while running the code.</p> <p>TypeScript allows developers to add types to JavaScript.</p>"},{"location":"frontend/typescript/typescript-installation/#reference","title":"Reference","text":"<ul> <li>TypeScript Tutorial: w3schools.com</li> </ul>"},{"location":"interview/codesnap/","title":"Code Snap","text":""},{"location":"interview/codesnap/#destructuring-props","title":"Destructuring props","text":""},{"location":"interview/codesnap/#antd-eclipse-column","title":"antd eclipse column","text":""},{"location":"interview/codesnap/#reference","title":"Reference","text":"<ul> <li>uncontrolled-components: official</li> <li>understanding uncontrolled components an essential-guide-for-react-developers</li> </ul>"},{"location":"interview/micro-frontend/","title":"Micro Frontend","text":""},{"location":"interview/micro-frontend/#micro-frontend","title":"Micro Frontend","text":""},{"location":"interview/micro-frontend/#reference","title":"Reference","text":""},{"location":"interview/react/","title":"React","text":"<p>Tip</p> <ul> <li>Next.js: React framework</li> <li>styled-components: CSS styling</li> <li>apollographql: Data API</li> <li>authjs: Authentication</li> <li>React Testing Library and Jest: Testing</li> <li>GitHub: Version control</li> <li>Vercel: Serverless online web host</li> </ul>"},{"location":"interview/react/#internationalization-and-localization","title":"Internationalization and localization","text":"<p>Internationalization and localization are basic practices in software development that enable you to design and deploy systems that can be tailored to multiple languages and areas. Let\u2019s learn the difference between them.</p>"},{"location":"interview/react/#what-is-internationalization","title":"What is internationalization?","text":"<p>Internationalization is the process of creating and preparing your application so that it can potentially be used in several languages. This frequently entails extracting all of your application\u2019s strings into distinct files that can potentially be translated into multiple languages. It also requires structuring your software to ensure that it can correctly manage and show these translations.</p>"},{"location":"interview/react/#what-is-localization","title":"What is localization?","text":"<p>This involves translating your locally optimized application into specific native languages. Translating an application\u2019s text is only one aspect of localization. It might also include other regionally unique elements, such as text direction, number forms, and date and time formats, among other things. React Router allows you to build localized routes. To manage language choice, you might, for instance, have several routes for various languages (such as \"<code>/en/about</code>\u201d and \"<code>/fr/about</code>\") or you can utilize a context or state.</p> <p>We have learned so much already and our knowledge has increased a lot. Next, we will move on to the penultimate section of this chapter, where we are going to learn all about adding translations and formatted messages in our React applications. We just learned about internationalization and localization, which is where we prepare our applications for different languages. Now, let\u2019s learn how to implement different languages in the code we write.</p>"},{"location":"blog/archive/2024/","title":"2024","text":""},{"location":"blog/page/2/","title":"Blog","text":""},{"location":"blog/archive/2024/page/2/","title":"2024","text":""},{"location":"tags/","title":"Tags","text":""},{"location":"tags/#tags","title":"Tags","text":"<ul> <li>Programming</li> <li>Web Development</li> <li>Design</li> <li>Testing</li> <li>Database</li> </ul>"},{"location":"tags/#frameworks","title":"Frameworks","text":"<ul> <li>Django</li> <li>Drf</li> <li>React</li> <li>Jest</li> </ul>"},{"location":"tags/#language","title":"Language","text":"<ul> <li>Python</li> <li>JavaScript</li> </ul>"},{"location":"tags/#tools","title":"Tools","text":"<ul> <li>Vim</li> <li>Git</li> <li>Github</li> <li>SSH</li> </ul>"},{"location":"tags/#misc","title":"Misc","text":"<ul> <li>Personal</li> <li>Postman</li> <li>Redis</li> <li>RabbitMQ</li> <li>SimpleJWT</li> </ul>"},{"location":"tags/#porgramming","title":"Porgramming","text":"<ul> <li>Application Structure for React.js</li> <li>How to Check the React Version in Your Project</li> </ul>"},{"location":"tags/#programming","title":"Programming","text":"<ul> <li>Understanding JavaScript Array Methods: Mutating vs. Non-Mutating</li> <li>React Router v6 Guide</li> </ul>"},{"location":"tags/#react","title":"React","text":"<ul> <li>Application Structure for React.js</li> <li>How to Check the React Version in Your Project</li> </ul>"},{"location":"tags/#arrow","title":"arrow","text":"<ul> <li>JavaScript Arrow Functions</li> </ul>"},{"location":"tags/#formatting","title":"formatting","text":"<ul> <li>Prettier Formatter for Visual Studio Code</li> </ul>"},{"location":"tags/#js","title":"js","text":"<ul> <li>Checking Node.js Versions in React Projects</li> <li>Understanding Functional State Updates in React: A Deep Dive into setSelectedGroupData</li> <li>Handling JSON Parsing Errors in JavaScript: A Practical Approach</li> <li>History API</li> <li>JavaScript Arrow Functions</li> <li>Understanding the Difference Between Response Object and Parsed Data Object</li> </ul>"},{"location":"tags/#react_1","title":"react","text":"<ul> <li>Checking Node.js Versions in React Projects</li> <li>Understanding Functional State Updates in React: A Deep Dive into setSelectedGroupData</li> <li>Handling JSON Parsing Errors in JavaScript: A Practical Approach</li> <li>History API</li> </ul>"},{"location":"tags/#vscode","title":"vscode","text":"<ul> <li>Prettier Formatter for Visual Studio Code</li> </ul>"}]}